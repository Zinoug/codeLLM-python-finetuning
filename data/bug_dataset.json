[
  {
    "commit": "37fbd8ca",
    "commit_msg": "Update average_median.py (#998)\n\nadded doctest, fixed TypeError: list indices must be integers or sl",
    "file": "maths/average_median.py",
    "function": "median",
    "bug_type": "wrong_return_value",
    "pl": "def median(nums):\n    \"\"\"Find median of a list of numbers.\"\"\"\n    # Sort list\n    sorted_list = sorted(nums)\n    print(\"List of numbers:\")\n    print(sorted_list)\n\n    # Is number of items in list even?\n    if len(sorted_list) % 2 == 0:\n        # Find index for first middle value.\n        mid_index_1 = len(sorted_list) / 2\n        # Find index for second middle value.\n        mid_index_2 = -(len(sorted_list) / 2) - 1\n        # Divide middle values by 2 to get average (mean).\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n        return med  # Return makes `else:` unnecessary.\n    # Number of items is odd.\n    mid_index = (len(sorted_list) - 1) / 2\n    # Middle index is median.\n    med = sorted_list[mid_index]\n    return med",
    "fixed_code": "def median(nums):\n    \"\"\"\n    Find median of a list of numbers.\n\n    >>> median([0])\n    0\n    >>> median([4,1,3,2])\n    2.5\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    med = None\n    if len(sorted_list) % 2 == 0:\n        mid_index_1 = len(sorted_list) // 2\n        mid_index_2 = (len(sorted_list) // 2) - 1\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n    else:\n        mid_index = (len(sorted_list) - 1) // 2\n        med = sorted_list[mid_index]\n    return med",
    "tests": [
      "assert median([0]) == 0",
      "assert median([4,1,3,2]) == 2.5"
    ]
  },
  {
    "commit": "47a9ea2b",
    "commit_msg": "Simplify code by dropping support for legacy Python (#1143)\n\n* Simplify code by dropping support for",
    "file": "project_euler/problem_48/sol1.py",
    "function": "solution",
    "bug_type": "off_by_one",
    "pl": "def solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in xrange(1, 1001):\n        total += i ** i\n    return str(total)[-10:]",
    "fixed_code": "def solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in range(1, 1001):\n        total += i ** i\n    return str(total)[-10:]",
    "tests": [
      "assert solution() == '9110846700'"
    ]
  },
  {
    "commit": "47a9ea2b",
    "commit_msg": "Simplify code by dropping support for legacy Python (#1143)\n\n* Simplify code by dropping support for",
    "file": "project_euler/problem_76/sol1.py",
    "function": "partition",
    "bug_type": "off_by_one",
    "pl": "def partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in xrange(m)] for _ in xrange(m + 1)]\n    for i in xrange(m + 1):\n        memo[i][0] = 1\n\n    for n in xrange(m + 1):\n        for k in xrange(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1",
    "fixed_code": "def partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1",
    "tests": [
      "assert partition(100) == 190569291",
      "assert partition(50) == 204225",
      "assert partition(30) == 5603",
      "assert partition(10) == 41",
      "assert partition(5) == 6",
      "assert partition(3) == 2",
      "assert partition(2) == 1",
      "assert partition(1) == 0"
    ]
  },
  {
    "commit": "390feb0b",
    "commit_msg": "Add doctests for sorting algorithms (#1263)\n\n* doctests and intro docstring added\r\n\r\n* doctests, doc",
    "file": "sorts/pigeon_sort.py",
    "function": "pigeon_sort",
    "bug_type": "off_by_one",
    "pl": "def pigeon_sort(array):\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array",
    "fixed_code": "def pigeon_sort(array):\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if(len(array) == 0):\n        return array\n\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array",
    "tests": [
      "assert pigeon_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert pigeon_sort([]) == []",
      "assert pigeon_sort([-2, -5, -45]) == [-45, -5, -2]"
    ]
  },
  {
    "commit": "c4a97677",
    "commit_msg": "Update fibonacci_sequence_recursion.py (#1287)\n\n- Fixed minor bugs.\r\n - Minimized Codes",
    "file": "maths/fibonacci_sequence_recursion.py",
    "function": "recur_fibo",
    "bug_type": "wrong_return_value",
    "pl": "def recur_fibo(n):\n    if n <= 1:\n        return n\n    else:\n        (recur_fibo(n - 1) + recur_fibo(n - 2))",
    "fixed_code": "def recur_fibo(n):\n    \"\"\"\n    >>> [recur_fibo(i) for i in range(12)]\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n    \"\"\"\n    return n if n <= 1 else recur_fibo(n-1) + recur_fibo(n-2)",
    "tests": [
      "assert [recur_fibo(i) for i in range(12)] == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]"
    ]
  },
  {
    "commit": "bfcb95b2",
    "commit_msg": "Create codespell.yml (#1698)\n\n* fixup! Format Python code with psf/black push\r\n\r\n* Create codespell.",
    "file": "strings/split.py",
    "function": "split",
    "bug_type": "other",
    "pl": "def split(string: str, seperator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values seperated by the seperator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",seperator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",seperator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",seperator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == seperator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words",
    "fixed_code": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words",
    "tests": [
      "assert split(\"apple#banana#cherry#orange\",separator='#') == ['apple', 'banana', 'cherry', 'orange']",
      "assert split(\"Hello there\") == ['Hello', 'there']",
      "assert split(\"11/22/63\",separator = '/') == ['11', '22', '63']",
      "assert split(\"12:43:39\",separator = \":\") == ['12', '43', '39']"
    ]
  },
  {
    "commit": "d8a4faf9",
    "commit_msg": "Update is_palindrome.py (#2025)\n\n* Update is_palindrome.py\r\n\r\n* Update is_palindrome.py\r\n\r\n* Reuse s",
    "file": "strings/is_palindrome.py",
    "function": "is_palindrome",
    "bug_type": "missing_edge_case",
    "pl": "def is_palindrome(s):\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    \"\"\"\n    return s == s[::-1]",
    "fixed_code": "def is_palindrome(s: str) -> bool:\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    >>> is_palindrome(\"Able was I ere I saw Elba\")\n    True\n    >>> is_palindrome(\"racecar\")\n    True\n    >>> is_palindrome(\"Mr. Owl ate my metal worm?\")\n    True\n    \"\"\"\n    # Since Punctuation, capitalization, and spaces are usually ignored while checking Palindrome,\n    # we first remove them from our string.\n    s = \"\".join([character for character in s.lower() if character.isalnum()])\n    return s == s[::-1]",
    "tests": [
      "assert is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\")) == True",
      "assert is_palindrome(\"Hello\") == False",
      "assert is_palindrome(\"Able was I ere I saw Elba\") == True",
      "assert is_palindrome(\"racecar\") == True",
      "assert is_palindrome(\"Mr. Owl ate my metal worm?\") == True"
    ]
  },
  {
    "commit": "20b21e5e",
    "commit_msg": "Refactor cycle_sort (#2072)\n\n* Refactor cycle_sort\r\n\r\n* Undo changes to keep only doctests",
    "file": "sorts/cycle_sort.py",
    "function": "cycle_sort",
    "bug_type": "off_by_one",
    "pl": "def cycle_sort(array):\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return ans",
    "fixed_code": "def cycle_sort(array: list) -> list:\n    \"\"\"\n    >>> cycle_sort([4, 3, 2, 1])\n    [1, 2, 3, 4]\n\n    >>> cycle_sort([-4, 20, 0, -50, 100, -1])\n    [-50, -4, -1, 0, 20, 100]\n\n    >>> cycle_sort([-.1, -.2, 1.3, -.8])\n    [-0.8, -0.2, -0.1, 1.3]\n\n    >>> cycle_sort([])\n    []\n    \"\"\"\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return array",
    "tests": [
      "assert cycle_sort([4, 3, 2, 1]) == [1, 2, 3, 4]",
      "assert cycle_sort([-4, 20, 0, -50, 100, -1]) == [-50, -4, -1, 0, 20, 100]",
      "assert cycle_sort([-.1, -.2, 1.3, -.8]) == [-0.8, -0.2, -0.1, 1.3]",
      "assert cycle_sort([]) == []"
    ]
  },
  {
    "commit": "657d4610",
    "commit_msg": "calc_profit always returns an int (#2090)\n\n* calc_profit always returns an int\r\n\r\n* fixup! Format Py",
    "file": "greedy_method/greedy_knapsack.py",
    "function": "calc_profit",
    "bug_type": "wrong_initialization",
    "pl": "def calc_profit(profit: list, weight: list, max_weight: int) -> Union[str, int]:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain",
    "fixed_code": "def calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain",
    "tests": [
      "assert calc_profit([1, 2, 3], [3, 4, 5], 15) == 6",
      "assert calc_profit([10, 9 , 8], [3 ,4 , 5], 25) == 27"
    ]
  },
  {
    "commit": "093a56e3",
    "commit_msg": "Remove function overhead in area (#2233)\n\n* remove function overhead\r\nadd type hints\r\n\r\n* remove unu",
    "file": "maths/area.py",
    "function": "surface_area_cube",
    "bug_type": "wrong_return_value",
    "pl": "def surface_area_cube(side_length: Union[int, float]) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * pow(side_length, 2)\r",
    "fixed_code": "def surface_area_cube(side_length: float) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * side_length ** 2\r",
    "tests": [
      "assert surface_area_cube(1) == 6",
      "assert surface_area_cube(3) == 54"
    ]
  },
  {
    "commit": "d687030d",
    "commit_msg": "fix number_of_digits bug (#2301)\n\n* fix bug\r\n\r\n* test larger negative\r\n\r\n* fixup! Format Python code",
    "file": "maths/number_of_digits.py",
    "function": "num_digits",
    "bug_type": "wrong_initialization",
    "pl": "def num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    \"\"\"\n    digits = 0\n    while n > 0:\n        n = n // 10\n        digits += 1\n    return digits",
    "fixed_code": "def num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    >>> num_digits(0)\n    1\n    >>> num_digits(-1)\n    1\n    >>> num_digits(-123456)\n    6\n    \"\"\"\n    digits = 0\n    n = abs(n)\n    while True:\n        n = n // 10\n        digits += 1\n        if n == 0:\n            break\n    return digits",
    "tests": [
      "assert num_digits(12345) == 5",
      "assert num_digits(123) == 3",
      "assert num_digits(0) == 1",
      "assert num_digits(-1) == 1",
      "assert num_digits(-123456) == 6"
    ]
  },
  {
    "commit": "fcc8a28c",
    "commit_msg": "Gnome sort : type hints, docstrings, doctests (#2307)\n\n* gnome_sort : type hints, docstring, doctest",
    "file": "sorts/gnome_sort.py",
    "function": "gnome_sort",
    "bug_type": "wrong_initialization",
    "pl": "def gnome_sort(unsorted):\n    \"\"\"Pure implementation of the gnome sort algorithm in Python.\"\"\"\n    if len(unsorted) <= 1:\n        return unsorted\n\n    i = 1\n\n    while i < len(unsorted):\n        if unsorted[i - 1] <= unsorted[i]:\n            i += 1\n        else:\n            unsorted[i - 1], unsorted[i] = unsorted[i], unsorted[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1",
    "fixed_code": "def gnome_sort(lst: list) -> list:\n    \"\"\"\n    Pure implementation of the gnome sort algorithm in Python\n\n    Take some mutable ordered collection with heterogeneous comparable items inside as\n    arguments, return the same collection ordered by ascending.\n\n    Examples:\n    >>> gnome_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> gnome_sort([])\n    []\n\n    >>> gnome_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    >>> \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\"))))\n    ' !Gadeimnoprstu'\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n\n    i = 1\n\n    while i < len(lst):\n        if lst[i - 1] <= lst[i]:\n            i += 1\n        else:\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1\n\n    return lst",
    "tests": [
      "assert gnome_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert gnome_sort([]) == []",
      "assert gnome_sort([-2, -5, -45]) == [-45, -5, -2]",
      "assert \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\")))) == ' !Gadeimnoprstu'"
    ]
  },
  {
    "commit": "34294b56",
    "commit_msg": "Update sum_of_digits.py (#2319)\n\n* * support negative number\r\n* add different version\r\n\r\n* fixup! Fo",
    "file": "maths/sum_of_digits.py",
    "function": "sum_of_digits",
    "bug_type": "missing_edge_case",
    "pl": "def sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    \"\"\"\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res",
    "fixed_code": "def sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(-123)\n    6\n    >>> sum_of_digits(0)\n    0\n    \"\"\"\n    n = -n if n < 0 else n\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res",
    "tests": [
      "assert sum_of_digits(12345) == 15",
      "assert sum_of_digits(123) == 6",
      "assert sum_of_digits(-123) == 6",
      "assert sum_of_digits(0) == 0"
    ]
  },
  {
    "commit": "799fde4c",
    "commit_msg": "Update linear_search.py (#2422)\n\n* Update linear_search.py\r\n\r\nPython implementation of recursive lin",
    "file": "searches/linear_search.py",
    "function": "linear_search",
    "bug_type": "wrong_return_value",
    "pl": "def linear_search(sequence, target):\n    \"\"\"Pure implementation of linear search algorithm in Python\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return None",
    "fixed_code": "def linear_search(sequence: list, target: int) -> int:\n    \"\"\"A pure Python implementation of a linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return -1",
    "tests": [
      "assert linear_search([0, 5, 7, 10, 15], 0) == 0",
      "assert linear_search([0, 5, 7, 10, 15], 15) == 4",
      "assert linear_search([0, 5, 7, 10, 15], 5) == 1",
      "assert linear_search([0, 5, 7, 10, 15], 6) == -1"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "backtracking/knight_tour.py",
    "function": "get_valid_pos",
    "bug_type": "boundary_condition",
    "pl": "def get_valid_pos(position: Tuple[int], n: int) -> List[Tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions",
    "fixed_code": "def get_valid_pos(position: tuple[int], n: int) -> list[tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions",
    "tests": [
      "assert get_valid_pos((1, 3), 4) == [(2, 1), (0, 1), (3, 2)]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "backtracking/knight_tour.py",
    "function": "is_complete",
    "bug_type": "other",
    "pl": "def is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)",
    "fixed_code": "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)",
    "tests": [
      "assert is_complete([[1]]) == True",
      "assert is_complete([[1, 2], [3, 0]]) == False"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "cellular_automata/one_dimensional.py",
    "function": "format_ruleset",
    "bug_type": "other",
    "pl": "def format_ruleset(ruleset: int) -> List[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]",
    "fixed_code": "def format_ruleset(ruleset: int) -> list[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]",
    "tests": [
      "assert format_ruleset(11100) == [0, 0, 0, 1, 1, 1, 0, 0]",
      "assert format_ruleset(0) == [0, 0, 0, 0, 0, 0, 0, 0]",
      "assert format_ruleset(11111111) == [1, 1, 1, 1, 1, 1, 1, 1]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "data_structures/binary_tree/lowest_common_ancestor.py",
    "function": "swap",
    "bug_type": "other",
    "pl": "def swap(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b",
    "fixed_code": "def swap(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b",
    "tests": [
      "assert swap(2,3) == (3, 2)",
      "assert swap(3,4) == (4, 3)",
      "assert swap(67, 12) == (12, 67)"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "dynamic_programming/longest_increasing_subsequence.py",
    "function": "longest_subsequence",
    "bug_type": "boundary_condition",
    "pl": "def longest_subsequence(array: List[int]) -> List[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq",
    "fixed_code": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq",
    "tests": [
      "assert longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == [10, 22, 33, 41, 60, 80]",
      "assert longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9]) == [1, 2, 3, 9]",
      "assert longest_subsequence([9, 8, 7, 6, 5, 7]) == [8]",
      "assert longest_subsequence([1, 1, 1]) == [1, 1, 1]",
      "assert longest_subsequence([]) == []"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "dynamic_programming/max_sub_array.py",
    "function": "max_sub_array",
    "bug_type": "logic_error",
    "pl": "def max_sub_array(nums: List[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best",
    "fixed_code": "def max_sub_array(nums: list[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best",
    "tests": [
      "assert max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6",
      "assert max_sub_array([]) == 0",
      "assert max_sub_array([-1, -2, -3]) == 0",
      "assert max_sub_array([5, -2, -3]) == 5",
      "assert max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84]) == 187"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "dynamic_programming/minimum_cost_path.py",
    "function": "minimum_cost_path",
    "bug_type": "off_by_one",
    "pl": "def minimum_cost_path(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]",
    "fixed_code": "def minimum_cost_path(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]",
    "tests": [
      "assert minimum_cost_path([[2, 1], [3, 1], [4, 2]]) == 6",
      "assert minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]]) == 7"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "linear_algebra/src/transformations_2d.py",
    "function": "scaling",
    "bug_type": "off_by_one",
    "pl": "def scaling(scaling_factor: float) -> List[List[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]",
    "fixed_code": "def scaling(scaling_factor: float) -> list[list[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]",
    "tests": [
      "assert scaling(5) == [[5.0, 0.0], [0.0, 5.0]]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "maths/3n_plus_1.py",
    "function": "n31",
    "bug_type": "wrong_initialization",
    "pl": "def n31(a: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)",
    "fixed_code": "def n31(a: int) -> tuple[list[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)",
    "tests": [
      "assert n31(4) == ([4, 2, 1], 3)"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "maths/abs_max.py",
    "function": "abs_max",
    "bug_type": "other",
    "pl": "def abs_max(x: List[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j",
    "fixed_code": "def abs_max(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j",
    "tests": [
      "assert abs_max([0,5,1,11]) == 11",
      "assert abs_max([3,-10,-2]) == -10"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "matrix/matrix_operation.py",
    "function": "scalar_multiply",
    "bug_type": "other",
    "pl": "def scalar_multiply(matrix: List[list], n: int) -> List[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]",
    "fixed_code": "def scalar_multiply(matrix: list[list], n: int) -> list[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]",
    "tests": [
      "assert scalar_multiply([[1,2],[3,4]],5) == [[5, 10], [15, 20]]",
      "assert scalar_multiply([[1.4,2.3],[3,4]],5) == [[7.0, 11.5], [15, 20]]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "matrix/matrix_operation.py",
    "function": "identity",
    "bug_type": "off_by_one",
    "pl": "def identity(n: int) -> List[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]",
    "fixed_code": "def identity(n: int) -> list[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]",
    "tests": [
      "assert identity(3) == [[1, 0, 0], [0, 1, 0], [0, 0, 1]]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "matrix/matrix_operation.py",
    "function": "minor",
    "bug_type": "other",
    "pl": "def minor(matrix: List[list], row: int, column: int) -> List[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]",
    "fixed_code": "def minor(matrix: list[list], row: int, column: int) -> list[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]",
    "tests": [
      "assert minor([[1, 2], [3, 4]], 1, 1) == [[1]]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "project_euler/problem_37/sol1.py",
    "function": "list_truncated_nums",
    "bug_type": "off_by_one",
    "pl": "def list_truncated_nums(n: int) -> List[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r",
    "fixed_code": "def list_truncated_nums(n: int) -> list[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r",
    "tests": [
      "assert list_truncated_nums(927628) == [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]",
      "assert list_truncated_nums(467) == [467, 67, 46, 7, 4]",
      "assert list_truncated_nums(58) == [58, 8, 5]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_waiting_times",
    "bug_type": "off_by_one",
    "pl": "def calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times",
    "fixed_code": "def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times",
    "tests": [
      "assert calculate_waiting_times([5, 10, 15]) == [0, 5, 15]",
      "assert calculate_waiting_times([1, 2, 3, 4, 5]) == [0, 1, 3, 6, 10]",
      "assert calculate_waiting_times([10, 3]) == [0, 10]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_turnaround_times",
    "bug_type": "logic_error",
    "pl": "def calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]",
    "fixed_code": "def calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]",
    "tests": [
      "assert calculate_turnaround_times([5, 10, 15], [0, 5, 15]) == [5, 15, 30]",
      "assert calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10]) == [1, 3, 6, 10, 15]",
      "assert calculate_turnaround_times([10, 3], [0, 10]) == [10, 13]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_average_turnaround_time",
    "bug_type": "other",
    "pl": "def calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)",
    "fixed_code": "def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)",
    "tests": [
      "assert calculate_average_turnaround_time([0, 5, 16]) == 7.0",
      "assert calculate_average_turnaround_time([1, 5, 8, 12]) == 6.5",
      "assert calculate_average_turnaround_time([10, 24]) == 17.0"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_average_waiting_time",
    "bug_type": "other",
    "pl": "def calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)",
    "fixed_code": "def calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)",
    "tests": [
      "assert calculate_average_waiting_time([0, 5, 16]) == 7.0",
      "assert calculate_average_waiting_time([1, 5, 8, 12]) == 6.5",
      "assert calculate_average_waiting_time([10, 24]) == 17.0"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/round_robin.py",
    "function": "calculate_waiting_times",
    "bug_type": "other",
    "pl": "def calculate_waiting_times(burst_times: List[int]) -> List[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r",
    "fixed_code": "def calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r",
    "tests": [
      "assert calculate_waiting_times([10, 5, 8]) == [13, 10, 13]",
      "assert calculate_waiting_times([4, 6, 3, 1]) == [5, 8, 9, 6]",
      "assert calculate_waiting_times([12, 2, 10]) == [12, 2, 12]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/round_robin.py",
    "function": "calculate_turn_around_times",
    "bug_type": "other",
    "pl": "def calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r",
    "fixed_code": "def calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r",
    "tests": [
      "assert calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3]) == [1, 3, 6]",
      "assert calculate_turn_around_times([10, 3, 7], [10, 6, 11]) == [20, 9, 18]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "searches/double_linear_search.py",
    "function": "double_linear_search",
    "bug_type": "wrong_initialization",
    "pl": "def double_linear_search(array: List[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r",
    "fixed_code": "def double_linear_search(array: list[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r",
    "tests": [
      "assert double_linear_search([1, 5, 5, 10], 1) == 0",
      "assert double_linear_search([1, 5, 5, 10], 5) == 1",
      "assert double_linear_search([1, 5, 5, 10], 100) == -1",
      "assert double_linear_search([1, 5, 5, 10], 10) == 3"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "sorts/merge_insertion_sort.py",
    "function": "merge_insertion_sort",
    "bug_type": "off_by_one",
    "pl": "def merge_insertion_sort(collection: List[int]) -> List[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result",
    "fixed_code": "def merge_insertion_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result",
    "tests": [
      "assert merge_insertion_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert merge_insertion_sort([99]) == [99]",
      "assert merge_insertion_sort([-2, -5, -45]) == [-45, -5, -2]"
    ]
  },
  {
    "commit": "902fe1c9",
    "commit_msg": "Fixed reverse words algorithm (#2469)\n\n* updated reversed words\r\n\r\n* fixup! Format Python code with ",
    "file": "strings/reverse_words.py",
    "function": "reverse_words",
    "bug_type": "wrong_return_value",
    "pl": "def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> sentence = \"I love Python\"\n    >>> reverse_words(sentence) == \" \".join(sentence.split()[::-1])\n    True\n    >>> reverse_words(sentence)\n    'Python love I'\n    \"\"\"\n    return \" \".join(reversed(input_str.split(\" \")))",
    "fixed_code": "def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])",
    "tests": [
      "assert reverse_words(\"I love Python\") == 'Python love I'",
      "assert reverse_words(\"I     Love          Python\") == 'Python Love I'"
    ]
  },
  {
    "commit": "3a275caf",
    "commit_msg": "Fixed remove duplicate (#2470)\n\n* fixed remove duplicate\r\n\r\n* fixup! Format Python code with psf/bla",
    "file": "strings/remove_duplicate.py",
    "function": "remove_duplicates",
    "bug_type": "logic_error",
    "pl": "def remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Reomove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split(\" \"))))",
    "fixed_code": "def remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Remove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    >>> remove_duplicates(\"Python   is      great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split())))",
    "tests": [
      "assert remove_duplicates(\"Python is great and Java is also great\") == 'Java Python also and great is'",
      "assert remove_duplicates(\"Python   is      great and Java is also great\") == 'Java Python also and great is'"
    ]
  },
  {
    "commit": "f564c9d7",
    "commit_msg": "Wiggle sort (#2419)\n\n* wiggle sort : type hint + doctest\r\n\r\n* fixed function name in docstring\r\n\r\n* ",
    "file": "sorts/wiggle_sort.py",
    "function": "wiggle_sort",
    "bug_type": "other",
    "pl": "def wiggle_sort(nums):\n    \"\"\"Perform Wiggle Sort.\"\"\"\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]",
    "fixed_code": "def wiggle_sort(nums: list) -> list:\n    \"\"\"\n    Python implementation of wiggle.\n    Example:\n    >>> wiggle_sort([0, 5, 3, 2, 2])\n    [0, 5, 2, 3, 2]\n    >>> wiggle_sort([])\n    []\n    >>> wiggle_sort([-2, -5, -45])\n    [-45, -2, -5]\n    >>> wiggle_sort([-2.1, -5.68, -45.11])\n    [-45.11, -2.1, -5.68]\n    \"\"\"\n    for i, _ in enumerate(nums):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\n    return nums",
    "tests": [
      "assert wiggle_sort([0, 5, 3, 2, 2]) == [0, 5, 2, 3, 2]",
      "assert wiggle_sort([]) == []",
      "assert wiggle_sort([-2, -5, -45]) == [-45, -2, -5]",
      "assert wiggle_sort([-2.1, -5.68, -45.11]) == [-45.11, -2.1, -5.68]"
    ]
  },
  {
    "commit": "a196a365",
    "commit_msg": "Fixed bugs (#2474)\n\n* fixed bug\r\n\r\n* fixup! Format Python code with psf/black push\r\n\r\nCo-authored-by",
    "file": "strings/check_anagrams.py",
    "function": "check_anagrams",
    "bug_type": "wrong_return_value",
    "pl": "def check_anagrams(a: str, b: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return sorted(a.lower()) == sorted(b.lower())\r",
    "fixed_code": "def check_anagrams(first_str: str, second_str: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('This is    a      string', 'Is     this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return (\r\n        \"\".join(sorted(first_str.lower())).strip()\r\n        == \"\".join(sorted(second_str.lower())).strip()\r\n    )\r",
    "tests": [
      "assert check_anagrams('Silent', 'Listen') == True",
      "assert check_anagrams('This is a string', 'Is this a string') == True",
      "assert check_anagrams('This is    a      string', 'Is     this a string') == True",
      "assert check_anagrams('There', 'Their') == False"
    ]
  },
  {
    "commit": "f36a2f62",
    "commit_msg": "Hacktoberfest 2020: Apply style guidelines for Project Euler problem_02 (#2898)\n\n* Fix typehints in ",
    "file": "project_euler/problem_02/sol2.py",
    "function": "solution",
    "bug_type": "wrong_return_value",
    "pl": "def solution(n):\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    [2, 8]\r\n    >>> solution(15)\r\n    [2, 8]\r\n    >>> solution(2)\r\n    [2]\r\n    >>> solution(1)\r\n    []\r\n    >>> solution(34)\r\n    [2, 8, 34]\r\n    \"\"\"\r\n    ls = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            ls.append(b)\r\n        a, b = b, a + b\r\n    return ls\r",
    "fixed_code": "def solution(n: int = 4000000) -> int:\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    10\r\n    >>> solution(15)\r\n    10\r\n    >>> solution(2)\r\n    2\r\n    >>> solution(1)\r\n    0\r\n    >>> solution(34)\r\n    44\r\n    \"\"\"\r\n    even_fibs = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            even_fibs.append(b)\r\n        a, b = b, a + b\r\n    return sum(even_fibs)\r",
    "tests": [
      "assert solution(10) == 10",
      "assert solution(15) == 10",
      "assert solution(2) == 2",
      "assert solution(1) == 0",
      "assert solution(34) == 44"
    ]
  },
  {
    "commit": "ddf83ec8",
    "commit_msg": "Add default arguments for Project Euler problem 6 (#2957)\n\n- Add default arguments to solution funct",
    "file": "project_euler/problem_06/sol1.py",
    "function": "solution",
    "bug_type": "off_by_one",
    "pl": "def solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares",
    "fixed_code": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares",
    "tests": [
      "assert solution(10) == 2640",
      "assert solution(15) == 13160",
      "assert solution(20) == 41230",
      "assert solution(50) == 1582700",
      "assert solution() == 25164150"
    ]
  },
  {
    "commit": "ddf83ec8",
    "commit_msg": "Add default arguments for Project Euler problem 6 (#2957)\n\n- Add default arguments to solution funct",
    "file": "project_euler/problem_06/sol2.py",
    "function": "solution",
    "bug_type": "other",
    "pl": "def solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares",
    "fixed_code": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares",
    "tests": [
      "assert solution(10) == 2640",
      "assert solution(15) == 13160",
      "assert solution(20) == 41230",
      "assert solution(50) == 1582700",
      "assert solution() == 25164150"
    ]
  },
  {
    "commit": "ddf83ec8",
    "commit_msg": "Add default arguments for Project Euler problem 6 (#2957)\n\n- Add default arguments to solution funct",
    "file": "project_euler/problem_06/sol4.py",
    "function": "solution",
    "bug_type": "other",
    "pl": "def solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution(100)\n    25164150\n    \"\"\"\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)",
    "fixed_code": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)",
    "tests": [
      "assert solution(10) == 2640",
      "assert solution(15) == 13160",
      "assert solution(20) == 41230",
      "assert solution(50) == 1582700",
      "assert solution() == 25164150"
    ]
  },
  {
    "commit": "46af42d4",
    "commit_msg": "Fix coin change (#2571)\n\n* Removed unused variable m.\r\n\r\n* Doctests are modified to match functions.",
    "file": "dynamic_programming/coin_change.py",
    "function": "dp_count",
    "bug_type": "off_by_one",
    "pl": "def dp_count(S, m, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 3, 4)\n    4\n    >>> dp_count([1, 2, 3], 3, 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 4, 10)\n    5\n    >>> dp_count([10], 1, 99)\n    0\n    >>> dp_count([4, 5, 6], 3, 0)\n    1\n    \"\"\"\n\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]",
    "fixed_code": "def dp_count(S, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 4)\n    4\n    >>> dp_count([1, 2, 3], 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 10)\n    5\n    >>> dp_count([10], 99)\n    0\n    >>> dp_count([4, 5, 6], 0)\n    1\n    >>> dp_count([1, 2, 3], -5)\n    0\n    \"\"\"\n    if n < 0:\n        return 0\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]",
    "tests": [
      "assert dp_count([1, 2, 3], 4) == 4",
      "assert dp_count([1, 2, 3], 7) == 8",
      "assert dp_count([2, 5, 3, 6], 10) == 5",
      "assert dp_count([10], 99) == 0",
      "assert dp_count([4, 5, 6], 0) == 1",
      "assert dp_count([1, 2, 3], -5) == 0"
    ]
  },
  {
    "commit": "c0d88d7f",
    "commit_msg": "Fix handling of non ascii characters in swap case (fixes: #3847) (#3848)\n\n* #3847 fix handling of no",
    "file": "strings/swap_case.py",
    "function": "swap_case",
    "bug_type": "logic_error",
    "pl": "def swap_case(sentence):\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        if char.islower():\n            new_string += char.upper()\n        if regexp.search(char):\n            new_string += char\n\n    return new_string",
    "fixed_code": "def swap_case(sentence: str) -> str:\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n\n    return new_string",
    "tests": [
      "assert swap_case('Algorithm.Python@89') == 'aLGORITHM.pYTHON@89'"
    ]
  },
  {
    "commit": "97b6ca2b",
    "commit_msg": "[mypy] Add/fix type annotations for boolean_algebra (#4172)\n\n* [mypy] Add/fix type annotations for b",
    "file": "boolean_algebra/quine_mc_cluskey.py",
    "function": "compare_string",
    "bug_type": "off_by_one",
    "pl": "def compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    -1\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return -1\n    else:\n        return \"\".join(l1)",
    "fixed_code": "def compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    'X'\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return \"X\"\n    else:\n        return \"\".join(l1)",
    "tests": [
      "assert compare_string('0010','0110') == '0_10'",
      "assert compare_string('0110','1101') == 'X'"
    ]
  },
  {
    "commit": "95950790",
    "commit_msg": "[mypy] fix small folders (#4292)\n\n* add final else-statement\r\n\r\n* fix file_transfer\r\n\r\n* fix quantum",
    "file": "divide_and_conquer/max_difference_pair.py",
    "function": "max_difference",
    "bug_type": "boundary_condition",
    "pl": "def max_difference(a: List[int]) -> (int, int):\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second",
    "fixed_code": "def max_difference(a: list[int]) -> tuple[int, int]:\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second",
    "tests": [
      "assert max_difference([5, 11, 2, 1, 7, 9, 0, 7]) == (1, 9)"
    ]
  },
  {
    "commit": "727341e3",
    "commit_msg": "Create check_pangram.py (#4389)",
    "file": "strings/check_pangram.py",
    "function": "check_pangram_faster",
    "bug_type": "missing_edge_case",
    "pl": "def check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - ord(\"a\")] = True\n    return all(flag)",
    "fixed_code": "def check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)",
    "tests": [
      "assert check_pangram_faster(\"The quick brown fox jumps over the lazy dog\") == True",
      "assert check_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\") == True",
      "assert check_pangram_faster(\"Jived fox nymph grabs quick waltz.\") == True",
      "assert check_pangram_faster(\"The quick brown fox jumps over the la_y dog\") == False",
      "assert check_pangram_faster() == True"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "backtracking/knight_tour.py",
    "function": "get_valid_pos",
    "bug_type": "boundary_condition",
    "pl": "def get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions",
    "fixed_code": "def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions",
    "tests": [
      "assert get_valid_pos((1, 3), 4) == [(2, 1), (0, 1), (3, 2)]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "backtracking/knight_tour.py",
    "function": "is_complete",
    "bug_type": "other",
    "pl": "def is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)",
    "fixed_code": "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)",
    "tests": [
      "assert is_complete([[1]]) == True",
      "assert is_complete([[1, 2], [3, 0]]) == False"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "blockchain/chinese_remainder_theorem.py",
    "function": "extended_euclid",
    "bug_type": "other",
    "pl": "def extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)",
    "fixed_code": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)",
    "tests": [
      "assert extended_euclid(10, 6) == (-1, 2)",
      "assert extended_euclid(7, 5) == (-2, 3)"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "blockchain/diophantine_equation.py",
    "function": "extended_gcd",
    "bug_type": "logic_error",
    "pl": "def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)",
    "fixed_code": "def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)",
    "tests": [
      "assert extended_gcd(10, 6) == (2, -1, 2)",
      "assert extended_gcd(7, 5) == (1, -2, 3)"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "blockchain/modular_division.py",
    "function": "extended_gcd",
    "bug_type": "logic_error",
    "pl": "def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)",
    "fixed_code": "def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)",
    "tests": [
      "assert extended_gcd(10, 6) == (2, -1, 2)",
      "assert extended_gcd(7, 5) == (1, -2, 3)"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "blockchain/modular_division.py",
    "function": "extended_euclid",
    "bug_type": "other",
    "pl": "def extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)",
    "fixed_code": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)",
    "tests": [
      "assert extended_euclid(10, 6) == (-1, 2)",
      "assert extended_euclid(7, 5) == (-2, 3)"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "boolean_algebra/quine_mc_cluskey.py",
    "function": "check",
    "bug_type": "off_by_one",
    "pl": "def check(binary: List[str]) -> List[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))",
    "fixed_code": "def check(binary: list[str]) -> list[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))",
    "tests": [
      "assert check(['0.00.01.5']) == ['0.00.01.5']"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "boolean_algebra/quine_mc_cluskey.py",
    "function": "decimal_to_binary",
    "bug_type": "off_by_one",
    "pl": "def decimal_to_binary(no_of_variable: int, minterms: List[float]) -> List[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp",
    "fixed_code": "def decimal_to_binary(no_of_variable: int, minterms: list[float]) -> list[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp",
    "tests": [
      "assert decimal_to_binary(3,[1.5]) == ['0.00.01.5']"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "boolean_algebra/quine_mc_cluskey.py",
    "function": "selection",
    "bug_type": "off_by_one",
    "pl": "def selection(chart: List[List[int]], prime_implicants: List[str]) -> List[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0",
    "fixed_code": "def selection(chart: list[list[int]], prime_implicants: list[str]) -> list[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0",
    "tests": [
      "assert selection([[1]],['0.00.01.5']) == ['0.00.01.5']",
      "assert selection([[1]],['0.00.01.5']) == ['0.00.01.5']"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "divide_and_conquer/peak.py",
    "function": "peak",
    "bug_type": "other",
    "pl": "def peak(lst: List[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])",
    "fixed_code": "def peak(lst: list[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])",
    "tests": [
      "assert peak([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5",
      "assert peak([1, 10, 9, 8, 7, 6, 5, 4]) == 10",
      "assert peak([1, 9, 8, 7]) == 9",
      "assert peak([1, 2, 3, 4, 5, 6, 7, 0]) == 7",
      "assert peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2]) == 4"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "maths/average_median.py",
    "function": "median",
    "bug_type": "other",
    "pl": "def median(nums: list) -> Union[int, float]:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )",
    "fixed_code": "def median(nums: list) -> int | float:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )",
    "tests": [
      "assert median([0]) == 0",
      "assert median([4, 1, 3, 2]) == 2.5",
      "assert median([2, 70, 6, 50, 20, 8, 4]) == 8"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "maths/extended_euclidean_algorithm.py",
    "function": "extended_euclidean_algorithm",
    "bug_type": "wrong_initialization",
    "pl": "def extended_euclidean_algorithm(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b",
    "fixed_code": "def extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b",
    "tests": [
      "assert extended_euclidean_algorithm(1, 24) == (1, 0)",
      "assert extended_euclidean_algorithm(8, 14) == (2, -1)",
      "assert extended_euclidean_algorithm(240, 46) == (-9, 47)",
      "assert extended_euclidean_algorithm(1, -4) == (1, 0)",
      "assert extended_euclidean_algorithm(-2, -4) == (-1, 0)",
      "assert extended_euclidean_algorithm(0, -4) == (0, -1)",
      "assert extended_euclidean_algorithm(2, 0) == (1, 0)"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "maths/volume.py",
    "function": "vol_cube",
    "bug_type": "other",
    "pl": "def vol_cube(side_length: Union[int, float]) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)",
    "fixed_code": "def vol_cube(side_length: int | float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)",
    "tests": [
      "assert vol_cube(1) == 1.0",
      "assert vol_cube(3) == 27.0"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_036/sol1.py",
    "function": "is_palindrome",
    "bug_type": "other",
    "pl": "def is_palindrome(n: Union[int, str]) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False",
    "fixed_code": "def is_palindrome(n: int | str) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False",
    "tests": [
      "assert is_palindrome(909) == True",
      "assert is_palindrome(908) == False",
      "assert is_palindrome('10101') == True",
      "assert is_palindrome('10111') == False"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_050/sol1.py",
    "function": "prime_sieve",
    "bug_type": "off_by_one",
    "pl": "def prime_sieve(limit: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes",
    "fixed_code": "def prime_sieve(limit: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes",
    "tests": [
      "assert prime_sieve(3) == [2]",
      "assert prime_sieve(50) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_051/sol1.py",
    "function": "prime_sieve",
    "bug_type": "off_by_one",
    "pl": "def prime_sieve(n: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes",
    "fixed_code": "def prime_sieve(n: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes",
    "tests": [
      "assert prime_sieve(3) == [2]",
      "assert prime_sieve(50) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_059/sol1.py",
    "function": "filter_common_word",
    "bug_type": "other",
    "pl": "def filter_common_word(possibles: List[str], common_word: str) -> List[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]",
    "fixed_code": "def filter_common_word(possibles: list[str], common_word: str) -> list[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]",
    "tests": [
      "assert filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am') == ['I am here']",
      "assert filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am') == ['athla amf', 'I am here']"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_070/sol1.py",
    "function": "get_totients",
    "bug_type": "off_by_one",
    "pl": "def get_totients(max_one: int) -> List[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients",
    "fixed_code": "def get_totients(max_one: int) -> list[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients",
    "tests": [
      "assert get_totients(5) == [0, 1, 1, 2, 2]",
      "assert get_totients(10) == [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_102/sol1.py",
    "function": "vector_product",
    "bug_type": "other",
    "pl": "def vector_product(point1: Tuple[int, int], point2: Tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]",
    "fixed_code": "def vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]",
    "tests": [
      "assert vector_product((1, 2), (-5, 0)) == 10",
      "assert vector_product((3, 1), (6, 10)) == 24"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_203/sol1.py",
    "function": "get_pascal_triangle_unique_coefficients",
    "bug_type": "off_by_one",
    "pl": "def get_pascal_triangle_unique_coefficients(depth: int) -> Set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients",
    "fixed_code": "def get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients",
    "tests": [
      "assert get_pascal_triangle_unique_coefficients(1) == {1}",
      "assert get_pascal_triangle_unique_coefficients(2) == {1}",
      "assert get_pascal_triangle_unique_coefficients(3) == {1, 2}",
      "assert get_pascal_triangle_unique_coefficients(8) == {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_203/sol1.py",
    "function": "get_squared_primes_to_use",
    "bug_type": "wrong_initialization",
    "pl": "def get_squared_primes_to_use(\n    num_to_look: int, squared_primes: List[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx",
    "fixed_code": "def get_squared_primes_to_use(\n    num_to_look: int, squared_primes: list[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx",
    "tests": [
      "assert get_squared_primes_to_use(1, [4, 9, 16, 25], 0) == -1",
      "assert get_squared_primes_to_use(4, [4, 9, 16, 25], 0) == 1",
      "assert get_squared_primes_to_use(16, [4, 9, 16, 25], 1) == 3"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_waiting_times",
    "bug_type": "off_by_one",
    "pl": "def calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times",
    "fixed_code": "def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times",
    "tests": [
      "assert calculate_waiting_times([5, 10, 15]) == [0, 5, 15]",
      "assert calculate_waiting_times([1, 2, 3, 4, 5]) == [0, 1, 3, 6, 10]",
      "assert calculate_waiting_times([10, 3]) == [0, 10]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_turnaround_times",
    "bug_type": "logic_error",
    "pl": "def calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]",
    "fixed_code": "def calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]",
    "tests": [
      "assert calculate_turnaround_times([5, 10, 15], [0, 5, 15]) == [5, 15, 30]",
      "assert calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10]) == [1, 3, 6, 10, 15]",
      "assert calculate_turnaround_times([10, 3], [0, 10]) == [10, 13]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_average_turnaround_time",
    "bug_type": "other",
    "pl": "def calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)",
    "fixed_code": "def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)",
    "tests": [
      "assert calculate_average_turnaround_time([0, 5, 16]) == 7.0",
      "assert calculate_average_turnaround_time([1, 5, 8, 12]) == 6.5",
      "assert calculate_average_turnaround_time([10, 24]) == 17.0"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_average_waiting_time",
    "bug_type": "other",
    "pl": "def calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)",
    "fixed_code": "def calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)",
    "tests": [
      "assert calculate_average_waiting_time([0, 5, 16]) == 7.0",
      "assert calculate_average_waiting_time([1, 5, 8, 12]) == 6.5",
      "assert calculate_average_waiting_time([10, 24]) == 17.0"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/round_robin.py",
    "function": "calculate_waiting_times",
    "bug_type": "other",
    "pl": "def calculate_waiting_times(burst_times: List[int]) -> List[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r",
    "fixed_code": "def calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r",
    "tests": [
      "assert calculate_waiting_times([10, 5, 8]) == [13, 10, 13]",
      "assert calculate_waiting_times([4, 6, 3, 1]) == [5, 8, 9, 6]",
      "assert calculate_waiting_times([12, 2, 10]) == [12, 2, 12]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/round_robin.py",
    "function": "calculate_turn_around_times",
    "bug_type": "other",
    "pl": "def calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r",
    "fixed_code": "def calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r",
    "tests": [
      "assert calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3]) == [1, 3, 6]",
      "assert calculate_turn_around_times([10, 3, 7], [10, 6, 11]) == [20, 9, 18]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "searches/binary_search.py",
    "function": "bisect_left",
    "bug_type": "logic_error",
    "pl": "def bisect_left(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo",
    "fixed_code": "def bisect_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo",
    "tests": [
      "assert bisect_left([0, 5, 7, 10, 15], 0) == 0",
      "assert bisect_left([0, 5, 7, 10, 15], 6) == 2",
      "assert bisect_left([0, 5, 7, 10, 15], 20) == 5",
      "assert bisect_left([0, 5, 7, 10, 15], 15, 1, 3) == 3",
      "assert bisect_left([0, 5, 7, 10, 15], 6, 2) == 2"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "searches/binary_search.py",
    "function": "bisect_right",
    "bug_type": "boundary_condition",
    "pl": "def bisect_right(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo",
    "fixed_code": "def bisect_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo",
    "tests": [
      "assert bisect_right([0, 5, 7, 10, 15], 0) == 1",
      "assert bisect_right([0, 5, 7, 10, 15], 15) == 5",
      "assert bisect_right([0, 5, 7, 10, 15], 6) == 2",
      "assert bisect_right([0, 5, 7, 10, 15], 15, 1, 3) == 3",
      "assert bisect_right([0, 5, 7, 10, 15], 6, 2) == 2"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "searches/ternary_search.py",
    "function": "lin_search",
    "bug_type": "off_by_one",
    "pl": "def lin_search(left: int, right: int, array: List[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1",
    "fixed_code": "def lin_search(left: int, right: int, array: list[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1",
    "tests": [
      "assert lin_search(0, 4, [4, 5, 6, 7], 7) == 3",
      "assert lin_search(0, 3, [4, 5, 6, 7], 7) == -1",
      "assert lin_search(0, 2, [-18, 2], -18) == 0",
      "assert lin_search(0, 1, [5], 5) == 0",
      "assert lin_search(0, 3, ['a', 'c', 'd'], 'c') == 1",
      "assert lin_search(0, 3, [.1, .4 , -.1], .1) == 0",
      "assert lin_search(0, 3, [.1, .4 , -.1], -.1) == 2"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "sorts/msd_radix_sort.py",
    "function": "_msd_radix_sort",
    "bug_type": "other",
    "pl": "def _msd_radix_sort(list_of_ints: List[int], bit_position: int) -> List[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res",
    "fixed_code": "def _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res",
    "tests": [
      "assert _msd_radix_sort([45, 2, 32], 1) == [2, 32, 45]",
      "assert _msd_radix_sort([10, 4, 12], 2) == [4, 12, 10]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "sorts/pigeon_sort.py",
    "function": "pigeon_sort",
    "bug_type": "off_by_one",
    "pl": "def pigeon_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array",
    "fixed_code": "def pigeon_sort(array: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array",
    "tests": [
      "assert pigeon_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert pigeon_sort([]) == []",
      "assert pigeon_sort([-2, -5, -45]) == [-45, -5, -2]"
    ]
  },
  {
    "commit": "a9846523",
    "commit_msg": "[mypy] Fix type annotations for maths directory (#5782)\n\n* [mypy] Fix annotations in `maths/series/p",
    "file": "maths/series/geometric_series.py",
    "function": "geometric_series",
    "bug_type": "off_by_one",
    "pl": "def geometric_series(nth_term: int, start_term_a: int, common_ratio_r: int) -> list:\n    \"\"\"Pure Python implementation of Geometric Series algorithm\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, '4.41', '9.261000000000001', '19.448100000000004']\n    >>> geometric_series(4, 2, -2)\n    [2, '-4.0', '8.0', '-16.0']\n    >>> geometric_series(4, -2, 2)\n    [-2, '-4.0', '-8.0', '-16.0']\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if \"\" in (nth_term, start_term_a, common_ratio_r):\n        return \"\"\n    series = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(str(float(start_term_a) * float(multiple)))\n            multiple = pow(float(common_ratio_r), power)\n    return series",
    "fixed_code": "def geometric_series(\n    nth_term: float | int,\n    start_term_a: float | int,\n    common_ratio_r: float | int,\n) -> list[float | int]:\n    \"\"\"\n    Pure Python implementation of Geometric Series algorithm\n\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\n    >>> geometric_series(4, 2, -2)\n    [2, -4.0, 8.0, -16.0]\n    >>> geometric_series(4, -2, 2)\n    [-2, -4.0, -8.0, -16.0]\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float | int] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series",
    "tests": [
      "assert geometric_series(4, 2, 2) == [2, 4.0, 8.0, 16.0]",
      "assert geometric_series(4.0, 2.0, 2.0) == [2.0, 4.0, 8.0, 16.0]",
      "assert geometric_series(4.1, 2.1, 2.1) == [2.1, 4.41, 9.261000000000001, 19.448100000000004]",
      "assert geometric_series(4, 2, -2) == [2, -4.0, 8.0, -16.0]",
      "assert geometric_series(4, -2, 2) == [-2, -4.0, -8.0, -16.0]",
      "assert geometric_series(-4, 2, 2) == []",
      "assert geometric_series(0, 100, 500) == []",
      "assert geometric_series(1, 1, 1) == [1]",
      "assert geometric_series(0, 0, 0) == []"
    ]
  },
  {
    "commit": "a9846523",
    "commit_msg": "[mypy] Fix type annotations for maths directory (#5782)\n\n* [mypy] Fix annotations in `maths/series/p",
    "file": "maths/series/p_series.py",
    "function": "p_series",
    "bug_type": "off_by_one",
    "pl": "def p_series(nth_term: int, power: int) -> list:\n    \"\"\"Pure Python implementation of P-Series algorithm\n\n    :return: The P-Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> p_series(5, 2)\n    [1, '1/4', '1/9', '1/16', '1/25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    [1, '1/0.25', '1/0.1111111111111111', '1/0.0625', '1/0.04']\n    >>> p_series(\"\", 1000)\n    ''\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    [1]\n    \"\"\"\n    if nth_term == \"\":\n        return nth_term\n    nth_term = int(nth_term)\n    power = int(power)\n    series = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1/{pow(temp + 1, int(power))}\" if series else 1)\n    return series",
    "fixed_code": "def p_series(nth_term: int | float | str, power: int | float | str) -> list[str]:\n    \"\"\"\n    Pure Python implementation of P-Series algorithm\n    :return: The P-Series starting from 1 to last (nth) term\n    Examples:\n    >>> p_series(5, 2)\n    ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']\n    >>> p_series(\"\", 1000)\n    ['']\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    ['1']\n    \"\"\"\n    if nth_term == \"\":\n        return [\"\"]\n    nth_term = int(nth_term)\n    power = int(power)\n    series: list[str] = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")\n    return series",
    "tests": [
      "assert p_series(5, 2) == ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']",
      "assert p_series(-5, 2) == []",
      "assert p_series(5, -2) == ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']",
      "assert p_series(\"\", 1000) == ['']",
      "assert p_series(0, 0) == []",
      "assert p_series(1, 1) == ['1']"
    ]
  },
  {
    "commit": "cc10b20b",
    "commit_msg": "Remove some print statements within algorithmic functions (#7499)\n\n* Remove commented-out print stat",
    "file": "dynamic_programming/sum_of_subset.py",
    "function": "is_sum_subset",
    "bug_type": "logic_error",
    "pl": "def is_sum_subset(arr, arr_len, required_sum):\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 4, 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 4, 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    subset = [[False for i in range(required_sum + 1)] for i in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    # uncomment to print the subset\n    # for i in range(arrLen+1):\n    #     print(subset[i])\n    print(subset[arr_len][required_sum])",
    "fixed_code": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    return subset[arr_len][required_sum]",
    "tests": [
      "assert is_sum_subset([2, 4, 6, 8], 5) == False",
      "assert is_sum_subset([2, 4, 6, 8], 14) == True"
    ]
  },
  {
    "commit": "cc10b20b",
    "commit_msg": "Remove some print statements within algorithmic functions (#7499)\n\n* Remove commented-out print stat",
    "file": "machine_learning/forecasting/run.py",
    "function": "data_safety_checker",
    "bug_type": "wrong_initialization",
    "pl": "def data_safety_checker(list_vote: list, actual_result: float) -> None:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2,3,4],5.0)\n    Today's data is not safe.\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe = safe + 1\n            else:\n                not_safe = not_safe + 1\n    print(f\"Today's data is {'not ' if safe <= not_safe else ''}safe.\")",
    "fixed_code": "def data_safety_checker(list_vote: list, actual_result: float) -> bool:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2, 3, 4], 5.0)\n    False\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe += 1\n            else:\n                not_safe += 1\n    return safe > not_safe",
    "tests": [
      "assert data_safety_checker([2, 3, 4], 5.0) == False"
    ]
  },
  {
    "commit": "abf0909b",
    "commit_msg": "Write a proper implementation for base16 (#6909)\n\nAccording to CONTRIBUTING.md:\r\n\"Algorithms in this",
    "file": "ciphers/base16.py",
    "function": "base16_encode",
    "bug_type": "logic_error",
    "pl": "def base16_encode(inp: str) -> bytes:\n    \"\"\"\n    Encodes a given utf-8 string into base-16.\n\n    >>> base16_encode('Hello World!')\n    b'48656C6C6F20576F726C6421'\n    >>> base16_encode('HELLO WORLD!')\n    b'48454C4C4F20574F524C4421'\n    >>> base16_encode('')\n    b''\n    \"\"\"\n    # encode the input into a bytes-like object and then encode b16encode that\n    return base64.b16encode(inp.encode(\"utf-8\"))",
    "fixed_code": "def base16_encode(data: bytes) -> str:\n    \"\"\"\n    Encodes the given bytes into base16.\n\n    >>> base16_encode(b'Hello World!')\n    '48656C6C6F20576F726C6421'\n    >>> base16_encode(b'HELLO WORLD!')\n    '48454C4C4F20574F524C4421'\n    >>> base16_encode(b'')\n    ''\n    \"\"\"\n    # Turn the data into a list of integers (where each integer is a byte),\n    # Then turn each byte into its hexadecimal representation, make sure\n    # it is uppercase, and then join everything together and return it.\n    return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])",
    "tests": [
      "assert base16_encode(b'Hello World!') == '48656C6C6F20576F726C6421'",
      "assert base16_encode(b'HELLO WORLD!') == '48454C4C4F20574F524C4421'",
      "assert base16_encode(b'') == ''"
    ]
  },
  {
    "commit": "fa077e67",
    "commit_msg": "Add doctests, type hints; fix bug for dynamic_programming/minimum_partition.py (#10012)\n\n* Add docte",
    "file": "dynamic_programming/minimum_partition.py",
    "function": "find_min",
    "bug_type": "off_by_one",
    "pl": "def find_min(arr):\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i][j - 1]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff",
    "fixed_code": "def find_min(arr: list[int]) -> int:\n    \"\"\"\n    >>> find_min([1, 2, 3, 4, 5])\n    1\n    >>> find_min([5, 5, 5, 5, 5])\n    5\n    >>> find_min([5, 5, 5, 5])\n    0\n    >>> find_min([3])\n    3\n    >>> find_min([])\n    0\n    \"\"\"\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i - 1][j]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff",
    "tests": [
      "assert find_min([1, 2, 3, 4, 5]) == 1",
      "assert find_min([5, 5, 5, 5, 5]) == 5",
      "assert find_min([5, 5, 5, 5]) == 0",
      "assert find_min([3]) == 3",
      "assert find_min([]) == 0"
    ]
  },
  {
    "commit": "66e4ea6a",
    "commit_msg": "Consolidated two scripts reverse_letters.py and reverse_long_words.py into one (#10140)\n\n* Conolidat",
    "file": "strings/reverse_letters.py",
    "function": "reverse_letters",
    "bug_type": "missing_edge_case",
    "pl": "def reverse_letters(input_str: str) -> str:\n    \"\"\"\n    Reverses letters in a given string without adjusting the position of the words\n    >>> reverse_letters('The cat in the hat')\n    'ehT tac ni eht tah'\n    >>> reverse_letters('The quick brown fox jumped over the lazy dog.')\n    'ehT kciuq nworb xof depmuj revo eht yzal .god'\n    >>> reverse_letters('Is this true?')\n    'sI siht ?eurt'\n    >>> reverse_letters(\"I   love       Python\")\n    'I evol nohtyP'\n    \"\"\"\n    return \" \".join([word[::-1] for word in input_str.split()])",
    "fixed_code": "def reverse_letters(sentence: str, length: int = 0) -> str:\n    \"\"\"\n    Reverse all words that are longer than the given length of characters in a sentence.\n    If unspecified, length is taken as 0\n\n    >>> reverse_letters(\"Hey wollef sroirraw\", 3)\n    'Hey fellow warriors'\n    >>> reverse_letters(\"nohtyP is nohtyP\", 2)\n    'Python is Python'\n    >>> reverse_letters(\"1 12 123 1234 54321 654321\", 0)\n    '1 21 321 4321 12345 123456'\n    >>> reverse_letters(\"racecar\")\n    'racecar'\n    \"\"\"\n    return \" \".join(\n        \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()\n    )",
    "tests": [
      "assert reverse_letters(\"Hey wollef sroirraw\", 3) == 'Hey fellow warriors'",
      "assert reverse_letters(\"nohtyP is nohtyP\", 2) == 'Python is Python'",
      "assert reverse_letters(\"1 12 123 1234 54321 654321\", 0) == '1 21 321 4321 12345 123456'",
      "assert reverse_letters(\"racecar\") == 'racecar'"
    ]
  },
  {
    "commit": "3ecad36f",
    "commit_msg": "fix: incorrect range detection in find_missing_number (#10361)\n\n* Fix incorrect range detection in f",
    "file": "bit_manipulation/missing_number.py",
    "function": "find_missing_number",
    "bug_type": "off_by_one",
    "pl": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n    \"\"\"\n    n = len(nums)\n    missing_number = n\n\n    for i in range(n):\n        missing_number ^= i ^ nums[i]\n\n    return missing_number",
    "fixed_code": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n\n    for i in range(low, high):\n        missing_number ^= i ^ nums[i - low]\n\n    return missing_number",
    "tests": [
      "assert find_missing_number([0, 1, 3, 4]) == 2",
      "assert find_missing_number([1, 3, 4, 5, 6]) == 2",
      "assert find_missing_number([6, 5, 4, 2, 1]) == 3",
      "assert find_missing_number([6, 1, 5, 3, 4]) == 2"
    ]
  },
  {
    "commit": "b814cf37",
    "commit_msg": "add exponential search algorithm (#10732)\n\n* add exponential_search algorithm\r\n\r\n* replace binary_se",
    "file": "searches/binary_search.py",
    "function": "binary_search",
    "bug_type": "boundary_condition",
    "pl": "def binary_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return None",
    "fixed_code": "def binary_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1",
    "tests": [
      "assert binary_search([0, 5, 7, 10, 15], 0) == 0",
      "assert binary_search([0, 5, 7, 10, 15], 15) == 4",
      "assert binary_search([0, 5, 7, 10, 15], 5) == 1",
      "assert binary_search([0, 5, 7, 10, 15], 6) == -1"
    ]
  },
  {
    "commit": "b814cf37",
    "commit_msg": "add exponential search algorithm (#10732)\n\n* add exponential_search algorithm\r\n\r\n* replace binary_se",
    "file": "searches/binary_search.py",
    "function": "binary_search_by_recursion",
    "bug_type": "logic_error",
    "pl": "def binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int, right: int\n) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n\n    \"\"\"\n    if right < left:\n        return None\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)",
    "fixed_code": "def binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n    -1\n    \"\"\"\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)",
    "tests": [
      "assert binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4) == 0",
      "assert binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4) == 4",
      "assert binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4) == 1",
      "assert binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4) == -1"
    ]
  },
  {
    "commit": "3d0a409c",
    "commit_msg": "Improved Equilibrium Index of an Array. (#10899)\n\n* Improved Equilibrium Index of an Array.\r\n\r\nThis ",
    "file": "data_structures/arrays/equilibrium_index_in_array.py",
    "function": "equilibrium_index",
    "bug_type": "other",
    "pl": "def equilibrium_index(arr: list[int], size: int) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr : The input array of integers.\n        size : The size of the array.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0], 7)\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5], 5)\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1], 5)\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3], 6)\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i in range(size):\n        total_sum -= arr[i]\n        if left_sum == total_sum:\n            return i\n        left_sum += arr[i]\n\n    return -1",
    "fixed_code": "def equilibrium_index(arr: list[int]) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5])\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1])\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3])\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i, value in enumerate(arr):\n        total_sum -= value\n        if left_sum == total_sum:\n            return i\n        left_sum += value\n\n    return -1",
    "tests": [
      "assert equilibrium_index([-7, 1, 5, 2, -4, 3, 0]) == 3",
      "assert equilibrium_index([1, 2, 3, 4, 5]) == -1",
      "assert equilibrium_index([1, 1, 1, 1, 1]) == 2",
      "assert equilibrium_index([2, 4, 6, 8, 10, 3]) == -1"
    ]
  },
  {
    "commit": "a936e947",
    "commit_msg": "Enable ruff ARG001 rule (#11321)\n\n* Enable ruff ARG001 rule\r\n\r\n* Fix dynamic_programming/combination",
    "file": "dynamic_programming/combination_sum_iv.py",
    "function": "combination_sum_iv",
    "bug_type": "logic_error",
    "pl": "def combination_sum_iv(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)",
    "fixed_code": "def combination_sum_iv(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)",
    "tests": [
      "assert combination_sum_iv([1,2,5], 5) == 9"
    ]
  },
  {
    "commit": "a936e947",
    "commit_msg": "Enable ruff ARG001 rule (#11321)\n\n* Enable ruff ARG001 rule\r\n\r\n* Fix dynamic_programming/combination",
    "file": "dynamic_programming/combination_sum_iv.py",
    "function": "combination_sum_iv_dp_array",
    "bug_type": "logic_error",
    "pl": "def combination_sum_iv_dp_array(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)",
    "fixed_code": "def combination_sum_iv_dp_array(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)",
    "tests": [
      "assert combination_sum_iv_dp_array([1,2,5], 5) == 9"
    ]
  },
  {
    "commit": "8bbe8caa",
    "commit_msg": "Improve test coverage for matrix exponentiation (#12388)\n\n* #9943 : Adding coverage test for basic_g",
    "file": "maths/matrix_exponentiation.py",
    "function": "simple_fibonacci",
    "bug_type": "wrong_return_value",
    "pl": "def simple_fibonacci(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    fn_1 = f1\n    fn_2 = f2\n    n -= 2\n\n    while n > 0:\n        fn_1, fn_2 = fn_1 + fn_2, fn_1\n        n -= 1\n\n    return fn_1",
    "fixed_code": "def simple_fibonacci(n, f1, f2):\n    \"\"\"\n    Returns the nth number of the Fibonacci sequence that\n    starts with f1 and f2\n    Uses the definition\n    >>> simple_fibonacci(1, 5, 6)\n    5\n    >>> simple_fibonacci(2, 10, 11)\n    11\n    >>> simple_fibonacci(13, 0, 1)\n    144\n    >>> simple_fibonacci(10, 5, 9)\n    411\n    >>> simple_fibonacci(9, 2, 3)\n    89\n    \"\"\"\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    n -= 2\n\n    while n > 0:\n        f2, f1 = f1 + f2, f2\n        n -= 1\n\n    return f2",
    "tests": [
      "assert simple_fibonacci(1, 5, 6) == 5",
      "assert simple_fibonacci(2, 10, 11) == 11",
      "assert simple_fibonacci(13, 0, 1) == 144",
      "assert simple_fibonacci(10, 5, 9) == 411",
      "assert simple_fibonacci(9, 2, 3) == 89"
    ]
  },
  {
    "commit": "1909f227",
    "commit_msg": "adding doctests to maths/trapezoidal_rule.py (#12193)\n\n* adding doctests to trapezoidal_rule.py\n\n* a",
    "file": "maths/trapezoidal_rule.py",
    "function": "make_points",
    "bug_type": "boundary_condition",
    "pl": "def make_points(a, b, h):\n    x = a + h\n    while x < (b - h):\n        yield x\n        x = x + h",
    "fixed_code": "def make_points(a, b, h):\n    \"\"\"\n    Generates points between 'a' and 'b' with step size 'h', excluding the end points.\n    Args:\n        a (float): Start value\n        b (float): End value\n        h (float): Step size\n    Examples:\n    >>> list(make_points(0, 10, 2.5))\n    [2.5, 5.0, 7.5]\n\n    >>> list(make_points(0, 10, 2))\n    [2, 4, 6, 8]\n\n    >>> list(make_points(1, 21, 5))\n    [6, 11, 16]\n\n    >>> list(make_points(1, 5, 2))\n    [3]\n\n    >>> list(make_points(1, 4, 3))\n    []\n    \"\"\"\n    x = a + h\n    while x <= (b - h):\n        yield x\n        x = x + h",
    "tests": [
      "assert list(make_points(0, 10, 2.5)) == [2.5, 5.0, 7.5]",
      "assert list(make_points(0, 10, 2)) == [2, 4, 6, 8]",
      "assert list(make_points(1, 21, 5)) == [6, 11, 16]",
      "assert list(make_points(1, 5, 2)) == [3]",
      "assert list(make_points(1, 4, 3)) == []"
    ]
  },
  {
    "commit": "2d68bb50",
    "commit_msg": "Fix split function to handle trailing delimiters correctly (#12423)\n\n* Fix split function to handle ",
    "file": "strings/split.py",
    "function": "split",
    "bug_type": "other",
    "pl": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words",
    "fixed_code": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n\n    >>> split(\";abbb;;c;\", separator=';')\n    ['', 'abbb', '', 'c', '']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words",
    "tests": [
      "assert split(\"apple#banana#cherry#orange\",separator='#') == ['apple', 'banana', 'cherry', 'orange']",
      "assert split(\"Hello there\") == ['Hello', 'there']",
      "assert split(\"11/22/63\",separator = '/') == ['11', '22', '63']",
      "assert split(\"12:43:39\",separator = \":\") == ['12', '43', '39']",
      "assert split(\";abbb;;c;\", separator=';') == ['', 'abbb', '', 'c', '']"
    ]
  },
  {
    "commit": "68b4c6b4",
    "commit_msg": "fix is_ip_v4_address_valid.py (#12394)\n\n* fix is_ip_v4_address_valid\r\n\r\n* [pre-commit.ci] auto fixes",
    "file": "maths/is_ip_v4_address_valid.py",
    "function": "is_ip_v4_address_valid",
    "bug_type": "logic_error",
    "pl": "def is_ip_v4_address_valid(ip_v4_address: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.255.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"254.255.0.255\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n    \"\"\"\n    octets = [int(i) for i in ip_v4_address.split(\".\") if i.isdigit()]\n    return len(octets) == 4 and all(0 <= int(octet) <= 254 for octet in octets)",
    "fixed_code": "def is_ip_v4_address_valid(ip: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.256.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"255.256.0.256\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.05\")\n    False\n    \"\"\"\n    octets = ip.split(\".\")\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        if not octet.isdigit():\n            return False\n\n        number = int(octet)\n        if len(str(number)) != len(octet):\n            return False\n\n        if not 0 <= number <= 255:\n            return False\n\n    return True",
    "tests": [
      "assert is_ip_v4_address_valid(\"192.168.0.23\") == True",
      "assert is_ip_v4_address_valid(\"192.256.15.8\") == False",
      "assert is_ip_v4_address_valid(\"172.100.0.8\") == True",
      "assert is_ip_v4_address_valid(\"255.256.0.256\") == False",
      "assert is_ip_v4_address_valid(\"1.2.33333333.4\") == False",
      "assert is_ip_v4_address_valid(\"1.2.-3.4\") == False",
      "assert is_ip_v4_address_valid(\"1.2.3\") == False",
      "assert is_ip_v4_address_valid(\"1.2.3.4.5\") == False",
      "assert is_ip_v4_address_valid(\"1.2.A.4\") == False",
      "assert is_ip_v4_address_valid(\"0.0.0.0\") == True",
      "assert is_ip_v4_address_valid(\"1.2.3.\") == False",
      "assert is_ip_v4_address_valid(\"1.2.3.05\") == False"
    ]
  },
  {
    "commit": "4c92de5e",
    "commit_msg": "Fix dynamic_programming/longest_increasing_subsequence.py (#12517)\n\n* Fix #12510\r\n\r\n* Added the doct",
    "file": "dynamic_programming/longest_increasing_subsequence.py",
    "function": "longest_subsequence",
    "bug_type": "boundary_condition",
    "pl": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq",
    "fixed_code": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [5, 7]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = array[i:]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq",
    "tests": [
      "assert longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == [10, 22, 33, 41, 60, 80]",
      "assert longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9]) == [1, 2, 3, 9]",
      "assert longest_subsequence([28, 26, 12, 23, 35, 39]) == [12, 23, 35, 39]",
      "assert longest_subsequence([9, 8, 7, 6, 5, 7]) == [5, 7]",
      "assert longest_subsequence([1, 1, 1]) == [1, 1, 1]",
      "assert longest_subsequence([]) == []"
    ]
  },
  {
    "commit": "183fa06f",
    "commit_msg": "Fix n-queens problem (#12583)\n\n* Fix n-queens problem\n\n* [pre-commit.ci] auto fixes from pre-commit.",
    "file": "backtracking/n_queens.py",
    "function": "is_safe",
    "bug_type": "logic_error",
    "pl": "def is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same row, column,\n    # left upper diagonal, and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, n)))\n        and all(\n            board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, -1, -1))\n        )\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, n)))\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, -1, -1)))\n    )",
    "fixed_code": "def is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same upper column,\n    # left upper diagonal and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))\n        )\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))\n        )\n    )",
    "tests": [
      "assert is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1) == True",
      "assert is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1) == False",
      "assert is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1) == False",
      "assert is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1) == False"
    ]
  },
  {
    "commit": "a8c56168",
    "commit_msg": "Simplify Capitalize Function (#12879)\n\n* Simplify the capitalize function using ASCII arithmetic to ",
    "file": "strings/capitalize.py",
    "function": "capitalize",
    "bug_type": "wrong_return_value",
    "pl": "def capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Create a dictionary that maps lowercase letters to uppercase letters\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    lower_to_upper = dict(zip(ascii_lowercase, ascii_uppercase))\n    return lower_to_upper.get(sentence[0], sentence[0]) + sentence[1:]",
    "fixed_code": "def capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    return sentence[0].upper() + sentence[1:]",
    "tests": [
      "assert capitalize(\"hello world\") == 'Hello world'",
      "assert capitalize(\"123 hello world\") == '123 hello world'",
      "assert capitalize(\" hello world\") == ' hello world'",
      "assert capitalize(\"a\") == 'A'",
      "assert capitalize(\"\") == ''"
    ]
  },
  {
    "commit": "37fbd8ca",
    "commit_msg": "Update average_median.py (#998)\n\nadded doctest, fixed TypeError: list indices must be integers or sl",
    "file": "maths/average_median.py",
    "function": "median",
    "bug_type": "wrong_return_value",
    "pl": "def median(nums):\n    \"\"\"Find median of a list of numbers.\"\"\"\n    # Sort list\n    sorted_list = sorted(nums)\n    print(\"List of numbers:\")\n    print(sorted_list)\n\n    # Is number of items in list even?\n    if len(sorted_list) % 2 == 0:\n        # Find index for first middle value.\n        mid_index_1 = len(sorted_list) / 2\n        # Find index for second middle value.\n        mid_index_2 = -(len(sorted_list) / 2) - 1\n        # Divide middle values by 2 to get average (mean).\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n        return med  # Return makes `else:` unnecessary.\n    # Number of items is odd.\n    mid_index = (len(sorted_list) - 1) / 2\n    # Middle index is median.\n    med = sorted_list[mid_index]\n    return med",
    "fixed_code": "def median(nums):\n    \"\"\"\n    Find median of a list of numbers.\n\n    >>> median([0])\n    0\n    >>> median([4,1,3,2])\n    2.5\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    med = None\n    if len(sorted_list) % 2 == 0:\n        mid_index_1 = len(sorted_list) // 2\n        mid_index_2 = (len(sorted_list) // 2) - 1\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n    else:\n        mid_index = (len(sorted_list) - 1) // 2\n        med = sorted_list[mid_index]\n    return med",
    "tests": [
      "assert median([0]) == 0",
      "assert median([4,1,3,2]) == 2.5"
    ]
  },
  {
    "commit": "47a9ea2b",
    "commit_msg": "Simplify code by dropping support for legacy Python (#1143)\n\n* Simplify code by dropping support for",
    "file": "project_euler/problem_48/sol1.py",
    "function": "solution",
    "bug_type": "off_by_one",
    "pl": "def solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in xrange(1, 1001):\n        total += i ** i\n    return str(total)[-10:]",
    "fixed_code": "def solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in range(1, 1001):\n        total += i ** i\n    return str(total)[-10:]",
    "tests": [
      "assert solution() == '9110846700'"
    ]
  },
  {
    "commit": "47a9ea2b",
    "commit_msg": "Simplify code by dropping support for legacy Python (#1143)\n\n* Simplify code by dropping support for",
    "file": "project_euler/problem_76/sol1.py",
    "function": "partition",
    "bug_type": "off_by_one",
    "pl": "def partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in xrange(m)] for _ in xrange(m + 1)]\n    for i in xrange(m + 1):\n        memo[i][0] = 1\n\n    for n in xrange(m + 1):\n        for k in xrange(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1",
    "fixed_code": "def partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1",
    "tests": [
      "assert partition(100) == 190569291",
      "assert partition(50) == 204225",
      "assert partition(30) == 5603",
      "assert partition(10) == 41",
      "assert partition(5) == 6",
      "assert partition(3) == 2",
      "assert partition(2) == 1",
      "assert partition(1) == 0"
    ]
  },
  {
    "commit": "390feb0b",
    "commit_msg": "Add doctests for sorting algorithms (#1263)\n\n* doctests and intro docstring added\r\n\r\n* doctests, doc",
    "file": "sorts/pigeon_sort.py",
    "function": "pigeon_sort",
    "bug_type": "off_by_one",
    "pl": "def pigeon_sort(array):\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array",
    "fixed_code": "def pigeon_sort(array):\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if(len(array) == 0):\n        return array\n\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array",
    "tests": [
      "assert pigeon_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert pigeon_sort([]) == []",
      "assert pigeon_sort([-2, -5, -45]) == [-45, -5, -2]"
    ]
  },
  {
    "commit": "c4a97677",
    "commit_msg": "Update fibonacci_sequence_recursion.py (#1287)\n\n- Fixed minor bugs.\r\n - Minimized Codes",
    "file": "maths/fibonacci_sequence_recursion.py",
    "function": "recur_fibo",
    "bug_type": "wrong_return_value",
    "pl": "def recur_fibo(n):\n    if n <= 1:\n        return n\n    else:\n        (recur_fibo(n - 1) + recur_fibo(n - 2))",
    "fixed_code": "def recur_fibo(n):\n    \"\"\"\n    >>> [recur_fibo(i) for i in range(12)]\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n    \"\"\"\n    return n if n <= 1 else recur_fibo(n-1) + recur_fibo(n-2)",
    "tests": [
      "assert [recur_fibo(i) for i in range(12)] == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]"
    ]
  },
  {
    "commit": "bfcb95b2",
    "commit_msg": "Create codespell.yml (#1698)\n\n* fixup! Format Python code with psf/black push\r\n\r\n* Create codespell.",
    "file": "strings/split.py",
    "function": "split",
    "bug_type": "other",
    "pl": "def split(string: str, seperator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values seperated by the seperator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",seperator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",seperator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",seperator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == seperator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words",
    "fixed_code": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words",
    "tests": [
      "assert split(\"apple#banana#cherry#orange\",separator='#') == ['apple', 'banana', 'cherry', 'orange']",
      "assert split(\"Hello there\") == ['Hello', 'there']",
      "assert split(\"11/22/63\",separator = '/') == ['11', '22', '63']",
      "assert split(\"12:43:39\",separator = \":\") == ['12', '43', '39']"
    ]
  },
  {
    "commit": "d8a4faf9",
    "commit_msg": "Update is_palindrome.py (#2025)\n\n* Update is_palindrome.py\r\n\r\n* Update is_palindrome.py\r\n\r\n* Reuse s",
    "file": "strings/is_palindrome.py",
    "function": "is_palindrome",
    "bug_type": "missing_edge_case",
    "pl": "def is_palindrome(s):\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    \"\"\"\n    return s == s[::-1]",
    "fixed_code": "def is_palindrome(s: str) -> bool:\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    >>> is_palindrome(\"Able was I ere I saw Elba\")\n    True\n    >>> is_palindrome(\"racecar\")\n    True\n    >>> is_palindrome(\"Mr. Owl ate my metal worm?\")\n    True\n    \"\"\"\n    # Since Punctuation, capitalization, and spaces are usually ignored while checking Palindrome,\n    # we first remove them from our string.\n    s = \"\".join([character for character in s.lower() if character.isalnum()])\n    return s == s[::-1]",
    "tests": [
      "assert is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\")) == True",
      "assert is_palindrome(\"Hello\") == False",
      "assert is_palindrome(\"Able was I ere I saw Elba\") == True",
      "assert is_palindrome(\"racecar\") == True",
      "assert is_palindrome(\"Mr. Owl ate my metal worm?\") == True"
    ]
  },
  {
    "commit": "20b21e5e",
    "commit_msg": "Refactor cycle_sort (#2072)\n\n* Refactor cycle_sort\r\n\r\n* Undo changes to keep only doctests",
    "file": "sorts/cycle_sort.py",
    "function": "cycle_sort",
    "bug_type": "off_by_one",
    "pl": "def cycle_sort(array):\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return ans",
    "fixed_code": "def cycle_sort(array: list) -> list:\n    \"\"\"\n    >>> cycle_sort([4, 3, 2, 1])\n    [1, 2, 3, 4]\n\n    >>> cycle_sort([-4, 20, 0, -50, 100, -1])\n    [-50, -4, -1, 0, 20, 100]\n\n    >>> cycle_sort([-.1, -.2, 1.3, -.8])\n    [-0.8, -0.2, -0.1, 1.3]\n\n    >>> cycle_sort([])\n    []\n    \"\"\"\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return array",
    "tests": [
      "assert cycle_sort([4, 3, 2, 1]) == [1, 2, 3, 4]",
      "assert cycle_sort([-4, 20, 0, -50, 100, -1]) == [-50, -4, -1, 0, 20, 100]",
      "assert cycle_sort([-.1, -.2, 1.3, -.8]) == [-0.8, -0.2, -0.1, 1.3]",
      "assert cycle_sort([]) == []"
    ]
  },
  {
    "commit": "657d4610",
    "commit_msg": "calc_profit always returns an int (#2090)\n\n* calc_profit always returns an int\r\n\r\n* fixup! Format Py",
    "file": "greedy_method/greedy_knapsack.py",
    "function": "calc_profit",
    "bug_type": "wrong_initialization",
    "pl": "def calc_profit(profit: list, weight: list, max_weight: int) -> Union[str, int]:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain",
    "fixed_code": "def calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain",
    "tests": [
      "assert calc_profit([1, 2, 3], [3, 4, 5], 15) == 6",
      "assert calc_profit([10, 9 , 8], [3 ,4 , 5], 25) == 27"
    ]
  },
  {
    "commit": "093a56e3",
    "commit_msg": "Remove function overhead in area (#2233)\n\n* remove function overhead\r\nadd type hints\r\n\r\n* remove unu",
    "file": "maths/area.py",
    "function": "surface_area_cube",
    "bug_type": "wrong_return_value",
    "pl": "def surface_area_cube(side_length: Union[int, float]) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * pow(side_length, 2)\r",
    "fixed_code": "def surface_area_cube(side_length: float) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * side_length ** 2\r",
    "tests": [
      "assert surface_area_cube(1) == 6",
      "assert surface_area_cube(3) == 54"
    ]
  },
  {
    "commit": "d687030d",
    "commit_msg": "fix number_of_digits bug (#2301)\n\n* fix bug\r\n\r\n* test larger negative\r\n\r\n* fixup! Format Python code",
    "file": "maths/number_of_digits.py",
    "function": "num_digits",
    "bug_type": "wrong_initialization",
    "pl": "def num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    \"\"\"\n    digits = 0\n    while n > 0:\n        n = n // 10\n        digits += 1\n    return digits",
    "fixed_code": "def num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    >>> num_digits(0)\n    1\n    >>> num_digits(-1)\n    1\n    >>> num_digits(-123456)\n    6\n    \"\"\"\n    digits = 0\n    n = abs(n)\n    while True:\n        n = n // 10\n        digits += 1\n        if n == 0:\n            break\n    return digits",
    "tests": [
      "assert num_digits(12345) == 5",
      "assert num_digits(123) == 3",
      "assert num_digits(0) == 1",
      "assert num_digits(-1) == 1",
      "assert num_digits(-123456) == 6"
    ]
  },
  {
    "commit": "fcc8a28c",
    "commit_msg": "Gnome sort : type hints, docstrings, doctests (#2307)\n\n* gnome_sort : type hints, docstring, doctest",
    "file": "sorts/gnome_sort.py",
    "function": "gnome_sort",
    "bug_type": "wrong_initialization",
    "pl": "def gnome_sort(unsorted):\n    \"\"\"Pure implementation of the gnome sort algorithm in Python.\"\"\"\n    if len(unsorted) <= 1:\n        return unsorted\n\n    i = 1\n\n    while i < len(unsorted):\n        if unsorted[i - 1] <= unsorted[i]:\n            i += 1\n        else:\n            unsorted[i - 1], unsorted[i] = unsorted[i], unsorted[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1",
    "fixed_code": "def gnome_sort(lst: list) -> list:\n    \"\"\"\n    Pure implementation of the gnome sort algorithm in Python\n\n    Take some mutable ordered collection with heterogeneous comparable items inside as\n    arguments, return the same collection ordered by ascending.\n\n    Examples:\n    >>> gnome_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> gnome_sort([])\n    []\n\n    >>> gnome_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    >>> \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\"))))\n    ' !Gadeimnoprstu'\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n\n    i = 1\n\n    while i < len(lst):\n        if lst[i - 1] <= lst[i]:\n            i += 1\n        else:\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1\n\n    return lst",
    "tests": [
      "assert gnome_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert gnome_sort([]) == []",
      "assert gnome_sort([-2, -5, -45]) == [-45, -5, -2]",
      "assert \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\")))) == ' !Gadeimnoprstu'"
    ]
  },
  {
    "commit": "34294b56",
    "commit_msg": "Update sum_of_digits.py (#2319)\n\n* * support negative number\r\n* add different version\r\n\r\n* fixup! Fo",
    "file": "maths/sum_of_digits.py",
    "function": "sum_of_digits",
    "bug_type": "missing_edge_case",
    "pl": "def sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    \"\"\"\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res",
    "fixed_code": "def sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(-123)\n    6\n    >>> sum_of_digits(0)\n    0\n    \"\"\"\n    n = -n if n < 0 else n\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res",
    "tests": [
      "assert sum_of_digits(12345) == 15",
      "assert sum_of_digits(123) == 6",
      "assert sum_of_digits(-123) == 6",
      "assert sum_of_digits(0) == 0"
    ]
  },
  {
    "commit": "799fde4c",
    "commit_msg": "Update linear_search.py (#2422)\n\n* Update linear_search.py\r\n\r\nPython implementation of recursive lin",
    "file": "searches/linear_search.py",
    "function": "linear_search",
    "bug_type": "wrong_return_value",
    "pl": "def linear_search(sequence, target):\n    \"\"\"Pure implementation of linear search algorithm in Python\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return None",
    "fixed_code": "def linear_search(sequence: list, target: int) -> int:\n    \"\"\"A pure Python implementation of a linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return -1",
    "tests": [
      "assert linear_search([0, 5, 7, 10, 15], 0) == 0",
      "assert linear_search([0, 5, 7, 10, 15], 15) == 4",
      "assert linear_search([0, 5, 7, 10, 15], 5) == 1",
      "assert linear_search([0, 5, 7, 10, 15], 6) == -1"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "backtracking/knight_tour.py",
    "function": "get_valid_pos",
    "bug_type": "boundary_condition",
    "pl": "def get_valid_pos(position: Tuple[int], n: int) -> List[Tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions",
    "fixed_code": "def get_valid_pos(position: tuple[int], n: int) -> list[tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions",
    "tests": [
      "assert get_valid_pos((1, 3), 4) == [(2, 1), (0, 1), (3, 2)]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "backtracking/knight_tour.py",
    "function": "is_complete",
    "bug_type": "other",
    "pl": "def is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)",
    "fixed_code": "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)",
    "tests": [
      "assert is_complete([[1]]) == True",
      "assert is_complete([[1, 2], [3, 0]]) == False"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "cellular_automata/one_dimensional.py",
    "function": "format_ruleset",
    "bug_type": "other",
    "pl": "def format_ruleset(ruleset: int) -> List[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]",
    "fixed_code": "def format_ruleset(ruleset: int) -> list[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]",
    "tests": [
      "assert format_ruleset(11100) == [0, 0, 0, 1, 1, 1, 0, 0]",
      "assert format_ruleset(0) == [0, 0, 0, 0, 0, 0, 0, 0]",
      "assert format_ruleset(11111111) == [1, 1, 1, 1, 1, 1, 1, 1]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "data_structures/binary_tree/lowest_common_ancestor.py",
    "function": "swap",
    "bug_type": "other",
    "pl": "def swap(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b",
    "fixed_code": "def swap(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b",
    "tests": [
      "assert swap(2,3) == (3, 2)",
      "assert swap(3,4) == (4, 3)",
      "assert swap(67, 12) == (12, 67)"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "dynamic_programming/longest_increasing_subsequence.py",
    "function": "longest_subsequence",
    "bug_type": "boundary_condition",
    "pl": "def longest_subsequence(array: List[int]) -> List[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq",
    "fixed_code": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq",
    "tests": [
      "assert longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == [10, 22, 33, 41, 60, 80]",
      "assert longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9]) == [1, 2, 3, 9]",
      "assert longest_subsequence([9, 8, 7, 6, 5, 7]) == [8]",
      "assert longest_subsequence([1, 1, 1]) == [1, 1, 1]",
      "assert longest_subsequence([]) == []"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "dynamic_programming/max_sub_array.py",
    "function": "max_sub_array",
    "bug_type": "logic_error",
    "pl": "def max_sub_array(nums: List[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best",
    "fixed_code": "def max_sub_array(nums: list[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best",
    "tests": [
      "assert max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6",
      "assert max_sub_array([]) == 0",
      "assert max_sub_array([-1, -2, -3]) == 0",
      "assert max_sub_array([5, -2, -3]) == 5",
      "assert max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84]) == 187"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "dynamic_programming/minimum_cost_path.py",
    "function": "minimum_cost_path",
    "bug_type": "off_by_one",
    "pl": "def minimum_cost_path(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]",
    "fixed_code": "def minimum_cost_path(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]",
    "tests": [
      "assert minimum_cost_path([[2, 1], [3, 1], [4, 2]]) == 6",
      "assert minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]]) == 7"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "linear_algebra/src/transformations_2d.py",
    "function": "scaling",
    "bug_type": "off_by_one",
    "pl": "def scaling(scaling_factor: float) -> List[List[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]",
    "fixed_code": "def scaling(scaling_factor: float) -> list[list[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]",
    "tests": [
      "assert scaling(5) == [[5.0, 0.0], [0.0, 5.0]]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "maths/3n_plus_1.py",
    "function": "n31",
    "bug_type": "wrong_initialization",
    "pl": "def n31(a: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)",
    "fixed_code": "def n31(a: int) -> tuple[list[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)",
    "tests": [
      "assert n31(4) == ([4, 2, 1], 3)"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "maths/abs_max.py",
    "function": "abs_max",
    "bug_type": "other",
    "pl": "def abs_max(x: List[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j",
    "fixed_code": "def abs_max(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j",
    "tests": [
      "assert abs_max([0,5,1,11]) == 11",
      "assert abs_max([3,-10,-2]) == -10"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "matrix/matrix_operation.py",
    "function": "scalar_multiply",
    "bug_type": "other",
    "pl": "def scalar_multiply(matrix: List[list], n: int) -> List[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]",
    "fixed_code": "def scalar_multiply(matrix: list[list], n: int) -> list[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]",
    "tests": [
      "assert scalar_multiply([[1,2],[3,4]],5) == [[5, 10], [15, 20]]",
      "assert scalar_multiply([[1.4,2.3],[3,4]],5) == [[7.0, 11.5], [15, 20]]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "matrix/matrix_operation.py",
    "function": "identity",
    "bug_type": "off_by_one",
    "pl": "def identity(n: int) -> List[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]",
    "fixed_code": "def identity(n: int) -> list[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]",
    "tests": [
      "assert identity(3) == [[1, 0, 0], [0, 1, 0], [0, 0, 1]]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "matrix/matrix_operation.py",
    "function": "minor",
    "bug_type": "other",
    "pl": "def minor(matrix: List[list], row: int, column: int) -> List[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]",
    "fixed_code": "def minor(matrix: list[list], row: int, column: int) -> list[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]",
    "tests": [
      "assert minor([[1, 2], [3, 4]], 1, 1) == [[1]]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "project_euler/problem_37/sol1.py",
    "function": "list_truncated_nums",
    "bug_type": "off_by_one",
    "pl": "def list_truncated_nums(n: int) -> List[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r",
    "fixed_code": "def list_truncated_nums(n: int) -> list[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r",
    "tests": [
      "assert list_truncated_nums(927628) == [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]",
      "assert list_truncated_nums(467) == [467, 67, 46, 7, 4]",
      "assert list_truncated_nums(58) == [58, 8, 5]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_waiting_times",
    "bug_type": "off_by_one",
    "pl": "def calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times",
    "fixed_code": "def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times",
    "tests": [
      "assert calculate_waiting_times([5, 10, 15]) == [0, 5, 15]",
      "assert calculate_waiting_times([1, 2, 3, 4, 5]) == [0, 1, 3, 6, 10]",
      "assert calculate_waiting_times([10, 3]) == [0, 10]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_turnaround_times",
    "bug_type": "logic_error",
    "pl": "def calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]",
    "fixed_code": "def calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]",
    "tests": [
      "assert calculate_turnaround_times([5, 10, 15], [0, 5, 15]) == [5, 15, 30]",
      "assert calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10]) == [1, 3, 6, 10, 15]",
      "assert calculate_turnaround_times([10, 3], [0, 10]) == [10, 13]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_average_turnaround_time",
    "bug_type": "other",
    "pl": "def calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)",
    "fixed_code": "def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)",
    "tests": [
      "assert calculate_average_turnaround_time([0, 5, 16]) == 7.0",
      "assert calculate_average_turnaround_time([1, 5, 8, 12]) == 6.5",
      "assert calculate_average_turnaround_time([10, 24]) == 17.0"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_average_waiting_time",
    "bug_type": "other",
    "pl": "def calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)",
    "fixed_code": "def calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)",
    "tests": [
      "assert calculate_average_waiting_time([0, 5, 16]) == 7.0",
      "assert calculate_average_waiting_time([1, 5, 8, 12]) == 6.5",
      "assert calculate_average_waiting_time([10, 24]) == 17.0"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/round_robin.py",
    "function": "calculate_waiting_times",
    "bug_type": "other",
    "pl": "def calculate_waiting_times(burst_times: List[int]) -> List[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r",
    "fixed_code": "def calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r",
    "tests": [
      "assert calculate_waiting_times([10, 5, 8]) == [13, 10, 13]",
      "assert calculate_waiting_times([4, 6, 3, 1]) == [5, 8, 9, 6]",
      "assert calculate_waiting_times([12, 2, 10]) == [12, 2, 12]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "scheduling/round_robin.py",
    "function": "calculate_turn_around_times",
    "bug_type": "other",
    "pl": "def calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r",
    "fixed_code": "def calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r",
    "tests": [
      "assert calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3]) == [1, 3, 6]",
      "assert calculate_turn_around_times([10, 3, 7], [10, 6, 11]) == [20, 9, 18]"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "searches/double_linear_search.py",
    "function": "double_linear_search",
    "bug_type": "wrong_initialization",
    "pl": "def double_linear_search(array: List[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r",
    "fixed_code": "def double_linear_search(array: list[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r",
    "tests": [
      "assert double_linear_search([1, 5, 5, 10], 1) == 0",
      "assert double_linear_search([1, 5, 5, 10], 5) == 1",
      "assert double_linear_search([1, 5, 5, 10], 100) == -1",
      "assert double_linear_search([1, 5, 5, 10], 10) == 3"
    ]
  },
  {
    "commit": "9200a2e5",
    "commit_msg": "from __future__ import annotations (#2464)\n\n* from __future__ import annotations\r\n\r\n* fixup! from __",
    "file": "sorts/merge_insertion_sort.py",
    "function": "merge_insertion_sort",
    "bug_type": "off_by_one",
    "pl": "def merge_insertion_sort(collection: List[int]) -> List[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result",
    "fixed_code": "def merge_insertion_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result",
    "tests": [
      "assert merge_insertion_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert merge_insertion_sort([99]) == [99]",
      "assert merge_insertion_sort([-2, -5, -45]) == [-45, -5, -2]"
    ]
  },
  {
    "commit": "902fe1c9",
    "commit_msg": "Fixed reverse words algorithm (#2469)\n\n* updated reversed words\r\n\r\n* fixup! Format Python code with ",
    "file": "strings/reverse_words.py",
    "function": "reverse_words",
    "bug_type": "wrong_return_value",
    "pl": "def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> sentence = \"I love Python\"\n    >>> reverse_words(sentence) == \" \".join(sentence.split()[::-1])\n    True\n    >>> reverse_words(sentence)\n    'Python love I'\n    \"\"\"\n    return \" \".join(reversed(input_str.split(\" \")))",
    "fixed_code": "def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])",
    "tests": [
      "assert reverse_words(\"I love Python\") == 'Python love I'",
      "assert reverse_words(\"I     Love          Python\") == 'Python Love I'"
    ]
  },
  {
    "commit": "3a275caf",
    "commit_msg": "Fixed remove duplicate (#2470)\n\n* fixed remove duplicate\r\n\r\n* fixup! Format Python code with psf/bla",
    "file": "strings/remove_duplicate.py",
    "function": "remove_duplicates",
    "bug_type": "logic_error",
    "pl": "def remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Reomove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split(\" \"))))",
    "fixed_code": "def remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Remove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    >>> remove_duplicates(\"Python   is      great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split())))",
    "tests": [
      "assert remove_duplicates(\"Python is great and Java is also great\") == 'Java Python also and great is'",
      "assert remove_duplicates(\"Python   is      great and Java is also great\") == 'Java Python also and great is'"
    ]
  },
  {
    "commit": "f564c9d7",
    "commit_msg": "Wiggle sort (#2419)\n\n* wiggle sort : type hint + doctest\r\n\r\n* fixed function name in docstring\r\n\r\n* ",
    "file": "sorts/wiggle_sort.py",
    "function": "wiggle_sort",
    "bug_type": "other",
    "pl": "def wiggle_sort(nums):\n    \"\"\"Perform Wiggle Sort.\"\"\"\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]",
    "fixed_code": "def wiggle_sort(nums: list) -> list:\n    \"\"\"\n    Python implementation of wiggle.\n    Example:\n    >>> wiggle_sort([0, 5, 3, 2, 2])\n    [0, 5, 2, 3, 2]\n    >>> wiggle_sort([])\n    []\n    >>> wiggle_sort([-2, -5, -45])\n    [-45, -2, -5]\n    >>> wiggle_sort([-2.1, -5.68, -45.11])\n    [-45.11, -2.1, -5.68]\n    \"\"\"\n    for i, _ in enumerate(nums):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\n    return nums",
    "tests": [
      "assert wiggle_sort([0, 5, 3, 2, 2]) == [0, 5, 2, 3, 2]",
      "assert wiggle_sort([]) == []",
      "assert wiggle_sort([-2, -5, -45]) == [-45, -2, -5]",
      "assert wiggle_sort([-2.1, -5.68, -45.11]) == [-45.11, -2.1, -5.68]"
    ]
  },
  {
    "commit": "a196a365",
    "commit_msg": "Fixed bugs (#2474)\n\n* fixed bug\r\n\r\n* fixup! Format Python code with psf/black push\r\n\r\nCo-authored-by",
    "file": "strings/check_anagrams.py",
    "function": "check_anagrams",
    "bug_type": "wrong_return_value",
    "pl": "def check_anagrams(a: str, b: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return sorted(a.lower()) == sorted(b.lower())\r",
    "fixed_code": "def check_anagrams(first_str: str, second_str: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('This is    a      string', 'Is     this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return (\r\n        \"\".join(sorted(first_str.lower())).strip()\r\n        == \"\".join(sorted(second_str.lower())).strip()\r\n    )\r",
    "tests": [
      "assert check_anagrams('Silent', 'Listen') == True",
      "assert check_anagrams('This is a string', 'Is this a string') == True",
      "assert check_anagrams('This is    a      string', 'Is     this a string') == True",
      "assert check_anagrams('There', 'Their') == False"
    ]
  },
  {
    "commit": "f36a2f62",
    "commit_msg": "Hacktoberfest 2020: Apply style guidelines for Project Euler problem_02 (#2898)\n\n* Fix typehints in ",
    "file": "project_euler/problem_02/sol2.py",
    "function": "solution",
    "bug_type": "wrong_return_value",
    "pl": "def solution(n):\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    [2, 8]\r\n    >>> solution(15)\r\n    [2, 8]\r\n    >>> solution(2)\r\n    [2]\r\n    >>> solution(1)\r\n    []\r\n    >>> solution(34)\r\n    [2, 8, 34]\r\n    \"\"\"\r\n    ls = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            ls.append(b)\r\n        a, b = b, a + b\r\n    return ls\r",
    "fixed_code": "def solution(n: int = 4000000) -> int:\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    10\r\n    >>> solution(15)\r\n    10\r\n    >>> solution(2)\r\n    2\r\n    >>> solution(1)\r\n    0\r\n    >>> solution(34)\r\n    44\r\n    \"\"\"\r\n    even_fibs = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            even_fibs.append(b)\r\n        a, b = b, a + b\r\n    return sum(even_fibs)\r",
    "tests": [
      "assert solution(10) == 10",
      "assert solution(15) == 10",
      "assert solution(2) == 2",
      "assert solution(1) == 0",
      "assert solution(34) == 44"
    ]
  },
  {
    "commit": "ddf83ec8",
    "commit_msg": "Add default arguments for Project Euler problem 6 (#2957)\n\n- Add default arguments to solution funct",
    "file": "project_euler/problem_06/sol1.py",
    "function": "solution",
    "bug_type": "off_by_one",
    "pl": "def solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares",
    "fixed_code": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares",
    "tests": [
      "assert solution(10) == 2640",
      "assert solution(15) == 13160",
      "assert solution(20) == 41230",
      "assert solution(50) == 1582700",
      "assert solution() == 25164150"
    ]
  },
  {
    "commit": "ddf83ec8",
    "commit_msg": "Add default arguments for Project Euler problem 6 (#2957)\n\n- Add default arguments to solution funct",
    "file": "project_euler/problem_06/sol2.py",
    "function": "solution",
    "bug_type": "other",
    "pl": "def solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares",
    "fixed_code": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares",
    "tests": [
      "assert solution(10) == 2640",
      "assert solution(15) == 13160",
      "assert solution(20) == 41230",
      "assert solution(50) == 1582700",
      "assert solution() == 25164150"
    ]
  },
  {
    "commit": "ddf83ec8",
    "commit_msg": "Add default arguments for Project Euler problem 6 (#2957)\n\n- Add default arguments to solution funct",
    "file": "project_euler/problem_06/sol4.py",
    "function": "solution",
    "bug_type": "other",
    "pl": "def solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution(100)\n    25164150\n    \"\"\"\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)",
    "fixed_code": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)",
    "tests": [
      "assert solution(10) == 2640",
      "assert solution(15) == 13160",
      "assert solution(20) == 41230",
      "assert solution(50) == 1582700",
      "assert solution() == 25164150"
    ]
  },
  {
    "commit": "46af42d4",
    "commit_msg": "Fix coin change (#2571)\n\n* Removed unused variable m.\r\n\r\n* Doctests are modified to match functions.",
    "file": "dynamic_programming/coin_change.py",
    "function": "dp_count",
    "bug_type": "off_by_one",
    "pl": "def dp_count(S, m, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 3, 4)\n    4\n    >>> dp_count([1, 2, 3], 3, 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 4, 10)\n    5\n    >>> dp_count([10], 1, 99)\n    0\n    >>> dp_count([4, 5, 6], 3, 0)\n    1\n    \"\"\"\n\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]",
    "fixed_code": "def dp_count(S, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 4)\n    4\n    >>> dp_count([1, 2, 3], 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 10)\n    5\n    >>> dp_count([10], 99)\n    0\n    >>> dp_count([4, 5, 6], 0)\n    1\n    >>> dp_count([1, 2, 3], -5)\n    0\n    \"\"\"\n    if n < 0:\n        return 0\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]",
    "tests": [
      "assert dp_count([1, 2, 3], 4) == 4",
      "assert dp_count([1, 2, 3], 7) == 8",
      "assert dp_count([2, 5, 3, 6], 10) == 5",
      "assert dp_count([10], 99) == 0",
      "assert dp_count([4, 5, 6], 0) == 1",
      "assert dp_count([1, 2, 3], -5) == 0"
    ]
  },
  {
    "commit": "c0d88d7f",
    "commit_msg": "Fix handling of non ascii characters in swap case (fixes: #3847) (#3848)\n\n* #3847 fix handling of no",
    "file": "strings/swap_case.py",
    "function": "swap_case",
    "bug_type": "logic_error",
    "pl": "def swap_case(sentence):\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        if char.islower():\n            new_string += char.upper()\n        if regexp.search(char):\n            new_string += char\n\n    return new_string",
    "fixed_code": "def swap_case(sentence: str) -> str:\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        elif char.islower():\n            new_string += char.upper()\n        else:\n            new_string += char\n\n    return new_string",
    "tests": [
      "assert swap_case('Algorithm.Python@89') == 'aLGORITHM.pYTHON@89'"
    ]
  },
  {
    "commit": "97b6ca2b",
    "commit_msg": "[mypy] Add/fix type annotations for boolean_algebra (#4172)\n\n* [mypy] Add/fix type annotations for b",
    "file": "boolean_algebra/quine_mc_cluskey.py",
    "function": "compare_string",
    "bug_type": "off_by_one",
    "pl": "def compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    -1\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return -1\n    else:\n        return \"\".join(l1)",
    "fixed_code": "def compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    'X'\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return \"X\"\n    else:\n        return \"\".join(l1)",
    "tests": [
      "assert compare_string('0010','0110') == '0_10'",
      "assert compare_string('0110','1101') == 'X'"
    ]
  },
  {
    "commit": "95950790",
    "commit_msg": "[mypy] fix small folders (#4292)\n\n* add final else-statement\r\n\r\n* fix file_transfer\r\n\r\n* fix quantum",
    "file": "divide_and_conquer/max_difference_pair.py",
    "function": "max_difference",
    "bug_type": "boundary_condition",
    "pl": "def max_difference(a: List[int]) -> (int, int):\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second",
    "fixed_code": "def max_difference(a: list[int]) -> tuple[int, int]:\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second",
    "tests": [
      "assert max_difference([5, 11, 2, 1, 7, 9, 0, 7]) == (1, 9)"
    ]
  },
  {
    "commit": "727341e3",
    "commit_msg": "Create check_pangram.py (#4389)",
    "file": "strings/check_pangram.py",
    "function": "check_pangram_faster",
    "bug_type": "missing_edge_case",
    "pl": "def check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - ord(\"a\")] = True\n    return all(flag)",
    "fixed_code": "def check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)",
    "tests": [
      "assert check_pangram_faster(\"The quick brown fox jumps over the lazy dog\") == True",
      "assert check_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\") == True",
      "assert check_pangram_faster(\"Jived fox nymph grabs quick waltz.\") == True",
      "assert check_pangram_faster(\"The quick brown fox jumps over the la_y dog\") == False",
      "assert check_pangram_faster() == True"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "backtracking/knight_tour.py",
    "function": "get_valid_pos",
    "bug_type": "boundary_condition",
    "pl": "def get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions",
    "fixed_code": "def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions",
    "tests": [
      "assert get_valid_pos((1, 3), 4) == [(2, 1), (0, 1), (3, 2)]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "backtracking/knight_tour.py",
    "function": "is_complete",
    "bug_type": "other",
    "pl": "def is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)",
    "fixed_code": "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)",
    "tests": [
      "assert is_complete([[1]]) == True",
      "assert is_complete([[1, 2], [3, 0]]) == False"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "blockchain/chinese_remainder_theorem.py",
    "function": "extended_euclid",
    "bug_type": "other",
    "pl": "def extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)",
    "fixed_code": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)",
    "tests": [
      "assert extended_euclid(10, 6) == (-1, 2)",
      "assert extended_euclid(7, 5) == (-2, 3)"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "blockchain/diophantine_equation.py",
    "function": "extended_gcd",
    "bug_type": "logic_error",
    "pl": "def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)",
    "fixed_code": "def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)",
    "tests": [
      "assert extended_gcd(10, 6) == (2, -1, 2)",
      "assert extended_gcd(7, 5) == (1, -2, 3)"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "blockchain/modular_division.py",
    "function": "extended_gcd",
    "bug_type": "logic_error",
    "pl": "def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)",
    "fixed_code": "def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)",
    "tests": [
      "assert extended_gcd(10, 6) == (2, -1, 2)",
      "assert extended_gcd(7, 5) == (1, -2, 3)"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "blockchain/modular_division.py",
    "function": "extended_euclid",
    "bug_type": "other",
    "pl": "def extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)",
    "fixed_code": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)",
    "tests": [
      "assert extended_euclid(10, 6) == (-1, 2)",
      "assert extended_euclid(7, 5) == (-2, 3)"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "boolean_algebra/quine_mc_cluskey.py",
    "function": "check",
    "bug_type": "off_by_one",
    "pl": "def check(binary: List[str]) -> List[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))",
    "fixed_code": "def check(binary: list[str]) -> list[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))",
    "tests": [
      "assert check(['0.00.01.5']) == ['0.00.01.5']"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "boolean_algebra/quine_mc_cluskey.py",
    "function": "decimal_to_binary",
    "bug_type": "off_by_one",
    "pl": "def decimal_to_binary(no_of_variable: int, minterms: List[float]) -> List[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp",
    "fixed_code": "def decimal_to_binary(no_of_variable: int, minterms: list[float]) -> list[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp",
    "tests": [
      "assert decimal_to_binary(3,[1.5]) == ['0.00.01.5']"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "boolean_algebra/quine_mc_cluskey.py",
    "function": "selection",
    "bug_type": "off_by_one",
    "pl": "def selection(chart: List[List[int]], prime_implicants: List[str]) -> List[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0",
    "fixed_code": "def selection(chart: list[list[int]], prime_implicants: list[str]) -> list[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0",
    "tests": [
      "assert selection([[1]],['0.00.01.5']) == ['0.00.01.5']",
      "assert selection([[1]],['0.00.01.5']) == ['0.00.01.5']"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "divide_and_conquer/peak.py",
    "function": "peak",
    "bug_type": "other",
    "pl": "def peak(lst: List[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])",
    "fixed_code": "def peak(lst: list[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])",
    "tests": [
      "assert peak([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5",
      "assert peak([1, 10, 9, 8, 7, 6, 5, 4]) == 10",
      "assert peak([1, 9, 8, 7]) == 9",
      "assert peak([1, 2, 3, 4, 5, 6, 7, 0]) == 7",
      "assert peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2]) == 4"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "maths/average_median.py",
    "function": "median",
    "bug_type": "other",
    "pl": "def median(nums: list) -> Union[int, float]:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )",
    "fixed_code": "def median(nums: list) -> int | float:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )",
    "tests": [
      "assert median([0]) == 0",
      "assert median([4, 1, 3, 2]) == 2.5",
      "assert median([2, 70, 6, 50, 20, 8, 4]) == 8"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "maths/extended_euclidean_algorithm.py",
    "function": "extended_euclidean_algorithm",
    "bug_type": "wrong_initialization",
    "pl": "def extended_euclidean_algorithm(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b",
    "fixed_code": "def extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b",
    "tests": [
      "assert extended_euclidean_algorithm(1, 24) == (1, 0)",
      "assert extended_euclidean_algorithm(8, 14) == (2, -1)",
      "assert extended_euclidean_algorithm(240, 46) == (-9, 47)",
      "assert extended_euclidean_algorithm(1, -4) == (1, 0)",
      "assert extended_euclidean_algorithm(-2, -4) == (-1, 0)",
      "assert extended_euclidean_algorithm(0, -4) == (0, -1)",
      "assert extended_euclidean_algorithm(2, 0) == (1, 0)"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "maths/volume.py",
    "function": "vol_cube",
    "bug_type": "other",
    "pl": "def vol_cube(side_length: Union[int, float]) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)",
    "fixed_code": "def vol_cube(side_length: int | float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)",
    "tests": [
      "assert vol_cube(1) == 1.0",
      "assert vol_cube(3) == 27.0"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_036/sol1.py",
    "function": "is_palindrome",
    "bug_type": "other",
    "pl": "def is_palindrome(n: Union[int, str]) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False",
    "fixed_code": "def is_palindrome(n: int | str) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False",
    "tests": [
      "assert is_palindrome(909) == True",
      "assert is_palindrome(908) == False",
      "assert is_palindrome('10101') == True",
      "assert is_palindrome('10111') == False"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_050/sol1.py",
    "function": "prime_sieve",
    "bug_type": "off_by_one",
    "pl": "def prime_sieve(limit: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes",
    "fixed_code": "def prime_sieve(limit: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes",
    "tests": [
      "assert prime_sieve(3) == [2]",
      "assert prime_sieve(50) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_051/sol1.py",
    "function": "prime_sieve",
    "bug_type": "off_by_one",
    "pl": "def prime_sieve(n: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes",
    "fixed_code": "def prime_sieve(n: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes",
    "tests": [
      "assert prime_sieve(3) == [2]",
      "assert prime_sieve(50) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_059/sol1.py",
    "function": "filter_common_word",
    "bug_type": "other",
    "pl": "def filter_common_word(possibles: List[str], common_word: str) -> List[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]",
    "fixed_code": "def filter_common_word(possibles: list[str], common_word: str) -> list[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]",
    "tests": [
      "assert filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am') == ['I am here']",
      "assert filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am') == ['athla amf', 'I am here']"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_070/sol1.py",
    "function": "get_totients",
    "bug_type": "off_by_one",
    "pl": "def get_totients(max_one: int) -> List[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients",
    "fixed_code": "def get_totients(max_one: int) -> list[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients",
    "tests": [
      "assert get_totients(5) == [0, 1, 1, 2, 2]",
      "assert get_totients(10) == [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_102/sol1.py",
    "function": "vector_product",
    "bug_type": "other",
    "pl": "def vector_product(point1: Tuple[int, int], point2: Tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]",
    "fixed_code": "def vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]",
    "tests": [
      "assert vector_product((1, 2), (-5, 0)) == 10",
      "assert vector_product((3, 1), (6, 10)) == 24"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_203/sol1.py",
    "function": "get_pascal_triangle_unique_coefficients",
    "bug_type": "off_by_one",
    "pl": "def get_pascal_triangle_unique_coefficients(depth: int) -> Set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients",
    "fixed_code": "def get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients",
    "tests": [
      "assert get_pascal_triangle_unique_coefficients(1) == {1}",
      "assert get_pascal_triangle_unique_coefficients(2) == {1}",
      "assert get_pascal_triangle_unique_coefficients(3) == {1, 2}",
      "assert get_pascal_triangle_unique_coefficients(8) == {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "project_euler/problem_203/sol1.py",
    "function": "get_squared_primes_to_use",
    "bug_type": "wrong_initialization",
    "pl": "def get_squared_primes_to_use(\n    num_to_look: int, squared_primes: List[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx",
    "fixed_code": "def get_squared_primes_to_use(\n    num_to_look: int, squared_primes: list[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx",
    "tests": [
      "assert get_squared_primes_to_use(1, [4, 9, 16, 25], 0) == -1",
      "assert get_squared_primes_to_use(4, [4, 9, 16, 25], 0) == 1",
      "assert get_squared_primes_to_use(16, [4, 9, 16, 25], 1) == 3"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_waiting_times",
    "bug_type": "off_by_one",
    "pl": "def calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times",
    "fixed_code": "def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times",
    "tests": [
      "assert calculate_waiting_times([5, 10, 15]) == [0, 5, 15]",
      "assert calculate_waiting_times([1, 2, 3, 4, 5]) == [0, 1, 3, 6, 10]",
      "assert calculate_waiting_times([10, 3]) == [0, 10]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_turnaround_times",
    "bug_type": "logic_error",
    "pl": "def calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]",
    "fixed_code": "def calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]",
    "tests": [
      "assert calculate_turnaround_times([5, 10, 15], [0, 5, 15]) == [5, 15, 30]",
      "assert calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10]) == [1, 3, 6, 10, 15]",
      "assert calculate_turnaround_times([10, 3], [0, 10]) == [10, 13]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_average_turnaround_time",
    "bug_type": "other",
    "pl": "def calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)",
    "fixed_code": "def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)",
    "tests": [
      "assert calculate_average_turnaround_time([0, 5, 16]) == 7.0",
      "assert calculate_average_turnaround_time([1, 5, 8, 12]) == 6.5",
      "assert calculate_average_turnaround_time([10, 24]) == 17.0"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/first_come_first_served.py",
    "function": "calculate_average_waiting_time",
    "bug_type": "other",
    "pl": "def calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)",
    "fixed_code": "def calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)",
    "tests": [
      "assert calculate_average_waiting_time([0, 5, 16]) == 7.0",
      "assert calculate_average_waiting_time([1, 5, 8, 12]) == 6.5",
      "assert calculate_average_waiting_time([10, 24]) == 17.0"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/round_robin.py",
    "function": "calculate_waiting_times",
    "bug_type": "other",
    "pl": "def calculate_waiting_times(burst_times: List[int]) -> List[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r",
    "fixed_code": "def calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r",
    "tests": [
      "assert calculate_waiting_times([10, 5, 8]) == [13, 10, 13]",
      "assert calculate_waiting_times([4, 6, 3, 1]) == [5, 8, 9, 6]",
      "assert calculate_waiting_times([12, 2, 10]) == [12, 2, 12]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "scheduling/round_robin.py",
    "function": "calculate_turn_around_times",
    "bug_type": "other",
    "pl": "def calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r",
    "fixed_code": "def calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r",
    "tests": [
      "assert calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3]) == [1, 3, 6]",
      "assert calculate_turn_around_times([10, 3, 7], [10, 6, 11]) == [20, 9, 18]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "searches/binary_search.py",
    "function": "bisect_left",
    "bug_type": "logic_error",
    "pl": "def bisect_left(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo",
    "fixed_code": "def bisect_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo",
    "tests": [
      "assert bisect_left([0, 5, 7, 10, 15], 0) == 0",
      "assert bisect_left([0, 5, 7, 10, 15], 6) == 2",
      "assert bisect_left([0, 5, 7, 10, 15], 20) == 5",
      "assert bisect_left([0, 5, 7, 10, 15], 15, 1, 3) == 3",
      "assert bisect_left([0, 5, 7, 10, 15], 6, 2) == 2"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "searches/binary_search.py",
    "function": "bisect_right",
    "bug_type": "boundary_condition",
    "pl": "def bisect_right(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo",
    "fixed_code": "def bisect_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo",
    "tests": [
      "assert bisect_right([0, 5, 7, 10, 15], 0) == 1",
      "assert bisect_right([0, 5, 7, 10, 15], 15) == 5",
      "assert bisect_right([0, 5, 7, 10, 15], 6) == 2",
      "assert bisect_right([0, 5, 7, 10, 15], 15, 1, 3) == 3",
      "assert bisect_right([0, 5, 7, 10, 15], 6, 2) == 2"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "searches/ternary_search.py",
    "function": "lin_search",
    "bug_type": "off_by_one",
    "pl": "def lin_search(left: int, right: int, array: List[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1",
    "fixed_code": "def lin_search(left: int, right: int, array: list[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1",
    "tests": [
      "assert lin_search(0, 4, [4, 5, 6, 7], 7) == 3",
      "assert lin_search(0, 3, [4, 5, 6, 7], 7) == -1",
      "assert lin_search(0, 2, [-18, 2], -18) == 0",
      "assert lin_search(0, 1, [5], 5) == 0",
      "assert lin_search(0, 3, ['a', 'c', 'd'], 'c') == 1",
      "assert lin_search(0, 3, [.1, .4 , -.1], .1) == 0",
      "assert lin_search(0, 3, [.1, .4 , -.1], -.1) == 2"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "sorts/msd_radix_sort.py",
    "function": "_msd_radix_sort",
    "bug_type": "other",
    "pl": "def _msd_radix_sort(list_of_ints: List[int], bit_position: int) -> List[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res",
    "fixed_code": "def _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res",
    "tests": [
      "assert _msd_radix_sort([45, 2, 32], 1) == [2, 32, 45]",
      "assert _msd_radix_sort([10, 4, 12], 2) == [4, 12, 10]"
    ]
  },
  {
    "commit": "cecf43d6",
    "commit_msg": "Pyupgrade to Python 3.9 (#4718)\n\n* Pyupgrade to Python 3.9\r\n\r\n* updating DIRECTORY.md\r\n\r\nCo-authored",
    "file": "sorts/pigeon_sort.py",
    "function": "pigeon_sort",
    "bug_type": "off_by_one",
    "pl": "def pigeon_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array",
    "fixed_code": "def pigeon_sort(array: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array",
    "tests": [
      "assert pigeon_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert pigeon_sort([]) == []",
      "assert pigeon_sort([-2, -5, -45]) == [-45, -5, -2]"
    ]
  },
  {
    "commit": "a9846523",
    "commit_msg": "[mypy] Fix type annotations for maths directory (#5782)\n\n* [mypy] Fix annotations in `maths/series/p",
    "file": "maths/series/geometric_series.py",
    "function": "geometric_series",
    "bug_type": "off_by_one",
    "pl": "def geometric_series(nth_term: int, start_term_a: int, common_ratio_r: int) -> list:\n    \"\"\"Pure Python implementation of Geometric Series algorithm\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, '4.41', '9.261000000000001', '19.448100000000004']\n    >>> geometric_series(4, 2, -2)\n    [2, '-4.0', '8.0', '-16.0']\n    >>> geometric_series(4, -2, 2)\n    [-2, '-4.0', '-8.0', '-16.0']\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if \"\" in (nth_term, start_term_a, common_ratio_r):\n        return \"\"\n    series = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(str(float(start_term_a) * float(multiple)))\n            multiple = pow(float(common_ratio_r), power)\n    return series",
    "fixed_code": "def geometric_series(\n    nth_term: float | int,\n    start_term_a: float | int,\n    common_ratio_r: float | int,\n) -> list[float | int]:\n    \"\"\"\n    Pure Python implementation of Geometric Series algorithm\n\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\n    >>> geometric_series(4, 2, -2)\n    [2, -4.0, 8.0, -16.0]\n    >>> geometric_series(4, -2, 2)\n    [-2, -4.0, -8.0, -16.0]\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float | int] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series",
    "tests": [
      "assert geometric_series(4, 2, 2) == [2, 4.0, 8.0, 16.0]",
      "assert geometric_series(4.0, 2.0, 2.0) == [2.0, 4.0, 8.0, 16.0]",
      "assert geometric_series(4.1, 2.1, 2.1) == [2.1, 4.41, 9.261000000000001, 19.448100000000004]",
      "assert geometric_series(4, 2, -2) == [2, -4.0, 8.0, -16.0]",
      "assert geometric_series(4, -2, 2) == [-2, -4.0, -8.0, -16.0]",
      "assert geometric_series(-4, 2, 2) == []",
      "assert geometric_series(0, 100, 500) == []",
      "assert geometric_series(1, 1, 1) == [1]",
      "assert geometric_series(0, 0, 0) == []"
    ]
  },
  {
    "commit": "a9846523",
    "commit_msg": "[mypy] Fix type annotations for maths directory (#5782)\n\n* [mypy] Fix annotations in `maths/series/p",
    "file": "maths/series/p_series.py",
    "function": "p_series",
    "bug_type": "off_by_one",
    "pl": "def p_series(nth_term: int, power: int) -> list:\n    \"\"\"Pure Python implementation of P-Series algorithm\n\n    :return: The P-Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> p_series(5, 2)\n    [1, '1/4', '1/9', '1/16', '1/25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    [1, '1/0.25', '1/0.1111111111111111', '1/0.0625', '1/0.04']\n    >>> p_series(\"\", 1000)\n    ''\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    [1]\n    \"\"\"\n    if nth_term == \"\":\n        return nth_term\n    nth_term = int(nth_term)\n    power = int(power)\n    series = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1/{pow(temp + 1, int(power))}\" if series else 1)\n    return series",
    "fixed_code": "def p_series(nth_term: int | float | str, power: int | float | str) -> list[str]:\n    \"\"\"\n    Pure Python implementation of P-Series algorithm\n    :return: The P-Series starting from 1 to last (nth) term\n    Examples:\n    >>> p_series(5, 2)\n    ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']\n    >>> p_series(\"\", 1000)\n    ['']\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    ['1']\n    \"\"\"\n    if nth_term == \"\":\n        return [\"\"]\n    nth_term = int(nth_term)\n    power = int(power)\n    series: list[str] = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")\n    return series",
    "tests": [
      "assert p_series(5, 2) == ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']",
      "assert p_series(-5, 2) == []",
      "assert p_series(5, -2) == ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']",
      "assert p_series(\"\", 1000) == ['']",
      "assert p_series(0, 0) == []",
      "assert p_series(1, 1) == ['1']"
    ]
  },
  {
    "commit": "cc10b20b",
    "commit_msg": "Remove some print statements within algorithmic functions (#7499)\n\n* Remove commented-out print stat",
    "file": "dynamic_programming/sum_of_subset.py",
    "function": "is_sum_subset",
    "bug_type": "logic_error",
    "pl": "def is_sum_subset(arr, arr_len, required_sum):\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 4, 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 4, 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    subset = [[False for i in range(required_sum + 1)] for i in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    # uncomment to print the subset\n    # for i in range(arrLen+1):\n    #     print(subset[i])\n    print(subset[arr_len][required_sum])",
    "fixed_code": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    return subset[arr_len][required_sum]",
    "tests": [
      "assert is_sum_subset([2, 4, 6, 8], 5) == False",
      "assert is_sum_subset([2, 4, 6, 8], 14) == True"
    ]
  },
  {
    "commit": "cc10b20b",
    "commit_msg": "Remove some print statements within algorithmic functions (#7499)\n\n* Remove commented-out print stat",
    "file": "machine_learning/forecasting/run.py",
    "function": "data_safety_checker",
    "bug_type": "wrong_initialization",
    "pl": "def data_safety_checker(list_vote: list, actual_result: float) -> None:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2,3,4],5.0)\n    Today's data is not safe.\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe = safe + 1\n            else:\n                not_safe = not_safe + 1\n    print(f\"Today's data is {'not ' if safe <= not_safe else ''}safe.\")",
    "fixed_code": "def data_safety_checker(list_vote: list, actual_result: float) -> bool:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2, 3, 4], 5.0)\n    False\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe += 1\n            else:\n                not_safe += 1\n    return safe > not_safe",
    "tests": [
      "assert data_safety_checker([2, 3, 4], 5.0) == False"
    ]
  },
  {
    "commit": "abf0909b",
    "commit_msg": "Write a proper implementation for base16 (#6909)\n\nAccording to CONTRIBUTING.md:\r\n\"Algorithms in this",
    "file": "ciphers/base16.py",
    "function": "base16_encode",
    "bug_type": "logic_error",
    "pl": "def base16_encode(inp: str) -> bytes:\n    \"\"\"\n    Encodes a given utf-8 string into base-16.\n\n    >>> base16_encode('Hello World!')\n    b'48656C6C6F20576F726C6421'\n    >>> base16_encode('HELLO WORLD!')\n    b'48454C4C4F20574F524C4421'\n    >>> base16_encode('')\n    b''\n    \"\"\"\n    # encode the input into a bytes-like object and then encode b16encode that\n    return base64.b16encode(inp.encode(\"utf-8\"))",
    "fixed_code": "def base16_encode(data: bytes) -> str:\n    \"\"\"\n    Encodes the given bytes into base16.\n\n    >>> base16_encode(b'Hello World!')\n    '48656C6C6F20576F726C6421'\n    >>> base16_encode(b'HELLO WORLD!')\n    '48454C4C4F20574F524C4421'\n    >>> base16_encode(b'')\n    ''\n    \"\"\"\n    # Turn the data into a list of integers (where each integer is a byte),\n    # Then turn each byte into its hexadecimal representation, make sure\n    # it is uppercase, and then join everything together and return it.\n    return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])",
    "tests": [
      "assert base16_encode(b'Hello World!') == '48656C6C6F20576F726C6421'",
      "assert base16_encode(b'HELLO WORLD!') == '48454C4C4F20574F524C4421'",
      "assert base16_encode(b'') == ''"
    ]
  },
  {
    "commit": "fa077e67",
    "commit_msg": "Add doctests, type hints; fix bug for dynamic_programming/minimum_partition.py (#10012)\n\n* Add docte",
    "file": "dynamic_programming/minimum_partition.py",
    "function": "find_min",
    "bug_type": "off_by_one",
    "pl": "def find_min(arr):\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i][j - 1]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff",
    "fixed_code": "def find_min(arr: list[int]) -> int:\n    \"\"\"\n    >>> find_min([1, 2, 3, 4, 5])\n    1\n    >>> find_min([5, 5, 5, 5, 5])\n    5\n    >>> find_min([5, 5, 5, 5])\n    0\n    >>> find_min([3])\n    3\n    >>> find_min([])\n    0\n    \"\"\"\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i - 1][j]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff",
    "tests": [
      "assert find_min([1, 2, 3, 4, 5]) == 1",
      "assert find_min([5, 5, 5, 5, 5]) == 5",
      "assert find_min([5, 5, 5, 5]) == 0",
      "assert find_min([3]) == 3",
      "assert find_min([]) == 0"
    ]
  },
  {
    "commit": "66e4ea6a",
    "commit_msg": "Consolidated two scripts reverse_letters.py and reverse_long_words.py into one (#10140)\n\n* Conolidat",
    "file": "strings/reverse_letters.py",
    "function": "reverse_letters",
    "bug_type": "missing_edge_case",
    "pl": "def reverse_letters(input_str: str) -> str:\n    \"\"\"\n    Reverses letters in a given string without adjusting the position of the words\n    >>> reverse_letters('The cat in the hat')\n    'ehT tac ni eht tah'\n    >>> reverse_letters('The quick brown fox jumped over the lazy dog.')\n    'ehT kciuq nworb xof depmuj revo eht yzal .god'\n    >>> reverse_letters('Is this true?')\n    'sI siht ?eurt'\n    >>> reverse_letters(\"I   love       Python\")\n    'I evol nohtyP'\n    \"\"\"\n    return \" \".join([word[::-1] for word in input_str.split()])",
    "fixed_code": "def reverse_letters(sentence: str, length: int = 0) -> str:\n    \"\"\"\n    Reverse all words that are longer than the given length of characters in a sentence.\n    If unspecified, length is taken as 0\n\n    >>> reverse_letters(\"Hey wollef sroirraw\", 3)\n    'Hey fellow warriors'\n    >>> reverse_letters(\"nohtyP is nohtyP\", 2)\n    'Python is Python'\n    >>> reverse_letters(\"1 12 123 1234 54321 654321\", 0)\n    '1 21 321 4321 12345 123456'\n    >>> reverse_letters(\"racecar\")\n    'racecar'\n    \"\"\"\n    return \" \".join(\n        \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()\n    )",
    "tests": [
      "assert reverse_letters(\"Hey wollef sroirraw\", 3) == 'Hey fellow warriors'",
      "assert reverse_letters(\"nohtyP is nohtyP\", 2) == 'Python is Python'",
      "assert reverse_letters(\"1 12 123 1234 54321 654321\", 0) == '1 21 321 4321 12345 123456'",
      "assert reverse_letters(\"racecar\") == 'racecar'"
    ]
  },
  {
    "commit": "3ecad36f",
    "commit_msg": "fix: incorrect range detection in find_missing_number (#10361)\n\n* Fix incorrect range detection in f",
    "file": "bit_manipulation/missing_number.py",
    "function": "find_missing_number",
    "bug_type": "off_by_one",
    "pl": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n    \"\"\"\n    n = len(nums)\n    missing_number = n\n\n    for i in range(n):\n        missing_number ^= i ^ nums[i]\n\n    return missing_number",
    "fixed_code": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n\n    for i in range(low, high):\n        missing_number ^= i ^ nums[i - low]\n\n    return missing_number",
    "tests": [
      "assert find_missing_number([0, 1, 3, 4]) == 2",
      "assert find_missing_number([1, 3, 4, 5, 6]) == 2",
      "assert find_missing_number([6, 5, 4, 2, 1]) == 3",
      "assert find_missing_number([6, 1, 5, 3, 4]) == 2"
    ]
  },
  {
    "commit": "b814cf37",
    "commit_msg": "add exponential search algorithm (#10732)\n\n* add exponential_search algorithm\r\n\r\n* replace binary_se",
    "file": "searches/binary_search.py",
    "function": "binary_search",
    "bug_type": "boundary_condition",
    "pl": "def binary_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return None",
    "fixed_code": "def binary_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1",
    "tests": [
      "assert binary_search([0, 5, 7, 10, 15], 0) == 0",
      "assert binary_search([0, 5, 7, 10, 15], 15) == 4",
      "assert binary_search([0, 5, 7, 10, 15], 5) == 1",
      "assert binary_search([0, 5, 7, 10, 15], 6) == -1"
    ]
  },
  {
    "commit": "b814cf37",
    "commit_msg": "add exponential search algorithm (#10732)\n\n* add exponential_search algorithm\r\n\r\n* replace binary_se",
    "file": "searches/binary_search.py",
    "function": "binary_search_by_recursion",
    "bug_type": "logic_error",
    "pl": "def binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int, right: int\n) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n\n    \"\"\"\n    if right < left:\n        return None\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)",
    "fixed_code": "def binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n    -1\n    \"\"\"\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)",
    "tests": [
      "assert binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4) == 0",
      "assert binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4) == 4",
      "assert binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4) == 1",
      "assert binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4) == -1"
    ]
  },
  {
    "commit": "3d0a409c",
    "commit_msg": "Improved Equilibrium Index of an Array. (#10899)\n\n* Improved Equilibrium Index of an Array.\r\n\r\nThis ",
    "file": "data_structures/arrays/equilibrium_index_in_array.py",
    "function": "equilibrium_index",
    "bug_type": "other",
    "pl": "def equilibrium_index(arr: list[int], size: int) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr : The input array of integers.\n        size : The size of the array.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0], 7)\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5], 5)\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1], 5)\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3], 6)\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i in range(size):\n        total_sum -= arr[i]\n        if left_sum == total_sum:\n            return i\n        left_sum += arr[i]\n\n    return -1",
    "fixed_code": "def equilibrium_index(arr: list[int]) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5])\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1])\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3])\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i, value in enumerate(arr):\n        total_sum -= value\n        if left_sum == total_sum:\n            return i\n        left_sum += value\n\n    return -1",
    "tests": [
      "assert equilibrium_index([-7, 1, 5, 2, -4, 3, 0]) == 3",
      "assert equilibrium_index([1, 2, 3, 4, 5]) == -1",
      "assert equilibrium_index([1, 1, 1, 1, 1]) == 2",
      "assert equilibrium_index([2, 4, 6, 8, 10, 3]) == -1"
    ]
  },
  {
    "commit": "a936e947",
    "commit_msg": "Enable ruff ARG001 rule (#11321)\n\n* Enable ruff ARG001 rule\r\n\r\n* Fix dynamic_programming/combination",
    "file": "dynamic_programming/combination_sum_iv.py",
    "function": "combination_sum_iv",
    "bug_type": "logic_error",
    "pl": "def combination_sum_iv(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)",
    "fixed_code": "def combination_sum_iv(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)",
    "tests": [
      "assert combination_sum_iv([1,2,5], 5) == 9"
    ]
  },
  {
    "commit": "a936e947",
    "commit_msg": "Enable ruff ARG001 rule (#11321)\n\n* Enable ruff ARG001 rule\r\n\r\n* Fix dynamic_programming/combination",
    "file": "dynamic_programming/combination_sum_iv.py",
    "function": "combination_sum_iv_dp_array",
    "bug_type": "logic_error",
    "pl": "def combination_sum_iv_dp_array(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)",
    "fixed_code": "def combination_sum_iv_dp_array(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)",
    "tests": [
      "assert combination_sum_iv_dp_array([1,2,5], 5) == 9"
    ]
  },
  {
    "commit": "8bbe8caa",
    "commit_msg": "Improve test coverage for matrix exponentiation (#12388)\n\n* #9943 : Adding coverage test for basic_g",
    "file": "maths/matrix_exponentiation.py",
    "function": "simple_fibonacci",
    "bug_type": "wrong_return_value",
    "pl": "def simple_fibonacci(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    fn_1 = f1\n    fn_2 = f2\n    n -= 2\n\n    while n > 0:\n        fn_1, fn_2 = fn_1 + fn_2, fn_1\n        n -= 1\n\n    return fn_1",
    "fixed_code": "def simple_fibonacci(n, f1, f2):\n    \"\"\"\n    Returns the nth number of the Fibonacci sequence that\n    starts with f1 and f2\n    Uses the definition\n    >>> simple_fibonacci(1, 5, 6)\n    5\n    >>> simple_fibonacci(2, 10, 11)\n    11\n    >>> simple_fibonacci(13, 0, 1)\n    144\n    >>> simple_fibonacci(10, 5, 9)\n    411\n    >>> simple_fibonacci(9, 2, 3)\n    89\n    \"\"\"\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    n -= 2\n\n    while n > 0:\n        f2, f1 = f1 + f2, f2\n        n -= 1\n\n    return f2",
    "tests": [
      "assert simple_fibonacci(1, 5, 6) == 5",
      "assert simple_fibonacci(2, 10, 11) == 11",
      "assert simple_fibonacci(13, 0, 1) == 144",
      "assert simple_fibonacci(10, 5, 9) == 411",
      "assert simple_fibonacci(9, 2, 3) == 89"
    ]
  },
  {
    "commit": "1909f227",
    "commit_msg": "adding doctests to maths/trapezoidal_rule.py (#12193)\n\n* adding doctests to trapezoidal_rule.py\n\n* a",
    "file": "maths/trapezoidal_rule.py",
    "function": "make_points",
    "bug_type": "boundary_condition",
    "pl": "def make_points(a, b, h):\n    x = a + h\n    while x < (b - h):\n        yield x\n        x = x + h",
    "fixed_code": "def make_points(a, b, h):\n    \"\"\"\n    Generates points between 'a' and 'b' with step size 'h', excluding the end points.\n    Args:\n        a (float): Start value\n        b (float): End value\n        h (float): Step size\n    Examples:\n    >>> list(make_points(0, 10, 2.5))\n    [2.5, 5.0, 7.5]\n\n    >>> list(make_points(0, 10, 2))\n    [2, 4, 6, 8]\n\n    >>> list(make_points(1, 21, 5))\n    [6, 11, 16]\n\n    >>> list(make_points(1, 5, 2))\n    [3]\n\n    >>> list(make_points(1, 4, 3))\n    []\n    \"\"\"\n    x = a + h\n    while x <= (b - h):\n        yield x\n        x = x + h",
    "tests": [
      "assert list(make_points(0, 10, 2.5)) == [2.5, 5.0, 7.5]",
      "assert list(make_points(0, 10, 2)) == [2, 4, 6, 8]",
      "assert list(make_points(1, 21, 5)) == [6, 11, 16]",
      "assert list(make_points(1, 5, 2)) == [3]",
      "assert list(make_points(1, 4, 3)) == []"
    ]
  },
  {
    "commit": "2d68bb50",
    "commit_msg": "Fix split function to handle trailing delimiters correctly (#12423)\n\n* Fix split function to handle ",
    "file": "strings/split.py",
    "function": "split",
    "bug_type": "other",
    "pl": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words",
    "fixed_code": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n\n    >>> split(\";abbb;;c;\", separator=';')\n    ['', 'abbb', '', 'c', '']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words",
    "tests": [
      "assert split(\"apple#banana#cherry#orange\",separator='#') == ['apple', 'banana', 'cherry', 'orange']",
      "assert split(\"Hello there\") == ['Hello', 'there']",
      "assert split(\"11/22/63\",separator = '/') == ['11', '22', '63']",
      "assert split(\"12:43:39\",separator = \":\") == ['12', '43', '39']",
      "assert split(\";abbb;;c;\", separator=';') == ['', 'abbb', '', 'c', '']"
    ]
  },
  {
    "commit": "68b4c6b4",
    "commit_msg": "fix is_ip_v4_address_valid.py (#12394)\n\n* fix is_ip_v4_address_valid\r\n\r\n* [pre-commit.ci] auto fixes",
    "file": "maths/is_ip_v4_address_valid.py",
    "function": "is_ip_v4_address_valid",
    "bug_type": "logic_error",
    "pl": "def is_ip_v4_address_valid(ip_v4_address: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.255.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"254.255.0.255\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n    \"\"\"\n    octets = [int(i) for i in ip_v4_address.split(\".\") if i.isdigit()]\n    return len(octets) == 4 and all(0 <= int(octet) <= 254 for octet in octets)",
    "fixed_code": "def is_ip_v4_address_valid(ip: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.256.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"255.256.0.256\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.05\")\n    False\n    \"\"\"\n    octets = ip.split(\".\")\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        if not octet.isdigit():\n            return False\n\n        number = int(octet)\n        if len(str(number)) != len(octet):\n            return False\n\n        if not 0 <= number <= 255:\n            return False\n\n    return True",
    "tests": [
      "assert is_ip_v4_address_valid(\"192.168.0.23\") == True",
      "assert is_ip_v4_address_valid(\"192.256.15.8\") == False",
      "assert is_ip_v4_address_valid(\"172.100.0.8\") == True",
      "assert is_ip_v4_address_valid(\"255.256.0.256\") == False",
      "assert is_ip_v4_address_valid(\"1.2.33333333.4\") == False",
      "assert is_ip_v4_address_valid(\"1.2.-3.4\") == False",
      "assert is_ip_v4_address_valid(\"1.2.3\") == False",
      "assert is_ip_v4_address_valid(\"1.2.3.4.5\") == False",
      "assert is_ip_v4_address_valid(\"1.2.A.4\") == False",
      "assert is_ip_v4_address_valid(\"0.0.0.0\") == True",
      "assert is_ip_v4_address_valid(\"1.2.3.\") == False",
      "assert is_ip_v4_address_valid(\"1.2.3.05\") == False"
    ]
  },
  {
    "commit": "4c92de5e",
    "commit_msg": "Fix dynamic_programming/longest_increasing_subsequence.py (#12517)\n\n* Fix #12510\r\n\r\n* Added the doct",
    "file": "dynamic_programming/longest_increasing_subsequence.py",
    "function": "longest_subsequence",
    "bug_type": "boundary_condition",
    "pl": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq",
    "fixed_code": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [5, 7]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = array[i:]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq",
    "tests": [
      "assert longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == [10, 22, 33, 41, 60, 80]",
      "assert longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9]) == [1, 2, 3, 9]",
      "assert longest_subsequence([28, 26, 12, 23, 35, 39]) == [12, 23, 35, 39]",
      "assert longest_subsequence([9, 8, 7, 6, 5, 7]) == [5, 7]",
      "assert longest_subsequence([1, 1, 1]) == [1, 1, 1]",
      "assert longest_subsequence([]) == []"
    ]
  },
  {
    "commit": "183fa06f",
    "commit_msg": "Fix n-queens problem (#12583)\n\n* Fix n-queens problem\n\n* [pre-commit.ci] auto fixes from pre-commit.",
    "file": "backtracking/n_queens.py",
    "function": "is_safe",
    "bug_type": "logic_error",
    "pl": "def is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same row, column,\n    # left upper diagonal, and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, n)))\n        and all(\n            board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, -1, -1))\n        )\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, n)))\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, -1, -1)))\n    )",
    "fixed_code": "def is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same upper column,\n    # left upper diagonal and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))\n        )\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))\n        )\n    )",
    "tests": [
      "assert is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1) == True",
      "assert is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1) == False",
      "assert is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1) == False",
      "assert is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1) == False"
    ]
  },
  {
    "commit": "a8c56168",
    "commit_msg": "Simplify Capitalize Function (#12879)\n\n* Simplify the capitalize function using ASCII arithmetic to ",
    "file": "strings/capitalize.py",
    "function": "capitalize",
    "bug_type": "wrong_return_value",
    "pl": "def capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Create a dictionary that maps lowercase letters to uppercase letters\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    lower_to_upper = dict(zip(ascii_lowercase, ascii_uppercase))\n    return lower_to_upper.get(sentence[0], sentence[0]) + sentence[1:]",
    "fixed_code": "def capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    return sentence[0].upper() + sentence[1:]",
    "tests": [
      "assert capitalize(\"hello world\") == 'Hello world'",
      "assert capitalize(\"123 hello world\") == '123 hello world'",
      "assert capitalize(\" hello world\") == ' hello world'",
      "assert capitalize(\"a\") == 'A'",
      "assert capitalize(\"\") == ''"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "ciphers/a1z26.py",
    "function": "encode",
    "bug_type": "no_bug",
    "pl": "def encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]",
    "fixed_code": "def encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]",
    "tests": [
      "assert encode(\"myname\") == [13, 25, 14, 1, 13, 5]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "ciphers/a1z26.py",
    "function": "decode",
    "bug_type": "no_bug",
    "pl": "def decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)",
    "fixed_code": "def decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)",
    "tests": [
      "assert decode([13, 25, 14, 1, 13, 5]) == 'myname'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "ciphers/atbash.py",
    "function": "atbash_slow",
    "bug_type": "no_bug",
    "pl": "def atbash_slow(sequence: str) -> str:\n    \"\"\"\n    >>> atbash_slow(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash_slow(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    output = \"\"\n    for i in sequence:\n        extract = ord(i)\n        if 65 <= extract <= 90:\n            output += chr(155 - extract)\n        elif 97 <= extract <= 122:\n            output += chr(219 - extract)\n        else:\n            output += i\n    return output",
    "fixed_code": "def atbash_slow(sequence: str) -> str:\n    \"\"\"\n    >>> atbash_slow(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash_slow(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    output = \"\"\n    for i in sequence:\n        extract = ord(i)\n        if 65 <= extract <= 90:\n            output += chr(155 - extract)\n        elif 97 <= extract <= 122:\n            output += chr(219 - extract)\n        else:\n            output += i\n    return output",
    "tests": [
      "assert atbash_slow(\"ABCDEFG\") == 'ZYXWVUT'",
      "assert atbash_slow(\"aW;;123BX\") == 'zD;;123YC'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "ciphers/diffie.py",
    "function": "find_primitive",
    "bug_type": "no_bug",
    "pl": "def find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None",
    "fixed_code": "def find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None",
    "tests": [
      "assert find_primitive(7)  # Modulo 7 has primitive root 3 == 3",
      "assert find_primitive(11)  # Modulo 11 has primitive root 2 == 2",
      "assert find_primitive(8) == None # Modulo 8 has no primitive root == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "ciphers/beaufort_cipher.py",
    "function": "generate_key",
    "bug_type": "no_bug",
    "pl": "def generate_key(message: str, key: str) -> str:\n    \"\"\"\n    >>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n    'SECRETSECRETSECRE'\n    \"\"\"\n    x = len(message)\n    i = 0\n    while True:\n        if x == i:\n            i = 0\n        if len(key) == len(message):\n            break\n        key += key[i]\n        i += 1\n    return key",
    "fixed_code": "def generate_key(message: str, key: str) -> str:\n    \"\"\"\n    >>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n    'SECRETSECRETSECRE'\n    \"\"\"\n    x = len(message)\n    i = 0\n    while True:\n        if x == i:\n            i = 0\n        if len(key) == len(message):\n            break\n        key += key[i]\n        i += 1\n    return key",
    "tests": [
      "assert generate_key(\"THE GERMAN ATTACK\",\"SECRET\") == 'SECRETSECRETSECRE'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "ciphers/vernam_cipher.py",
    "function": "vernam_encrypt",
    "bug_type": "no_bug",
    "pl": "def vernam_encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_encrypt(\"HELLO\",\"KEY\")\n    'RIJVS'\n    \"\"\"\n    ciphertext = \"\"\n    for i in range(len(plaintext)):\n        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65\n        while ct > 25:\n            ct = ct - 26\n        ciphertext += chr(65 + ct)\n    return ciphertext",
    "fixed_code": "def vernam_encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_encrypt(\"HELLO\",\"KEY\")\n    'RIJVS'\n    \"\"\"\n    ciphertext = \"\"\n    for i in range(len(plaintext)):\n        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65\n        while ct > 25:\n            ct = ct - 26\n        ciphertext += chr(65 + ct)\n    return ciphertext",
    "tests": [
      "assert vernam_encrypt(\"HELLO\",\"KEY\") == 'RIJVS'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "ciphers/vernam_cipher.py",
    "function": "vernam_decrypt",
    "bug_type": "no_bug",
    "pl": "def vernam_decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_decrypt(\"RIJVS\",\"KEY\")\n    'HELLO'\n    \"\"\"\n    decrypted_text = \"\"\n    for i in range(len(ciphertext)):\n        ct = ord(ciphertext[i]) - ord(key[i % len(key)])\n        while ct < 0:\n            ct = 26 + ct\n        decrypted_text += chr(65 + ct)\n    return decrypted_text",
    "fixed_code": "def vernam_decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_decrypt(\"RIJVS\",\"KEY\")\n    'HELLO'\n    \"\"\"\n    decrypted_text = \"\"\n    for i in range(len(ciphertext)):\n        ct = ord(ciphertext[i]) - ord(key[i % len(key)])\n        while ct < 0:\n            ct = 26 + ct\n        decrypted_text += chr(65 + ct)\n    return decrypted_text",
    "tests": [
      "assert vernam_decrypt(\"RIJVS\",\"KEY\") == 'HELLO'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "ciphers/transposition_cipher.py",
    "function": "encrypt_message",
    "bug_type": "no_bug",
    "pl": "def encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)",
    "fixed_code": "def encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)",
    "tests": [
      "assert encrypt_message(6, 'Harshil Darji') == 'Hlia rDsahrij'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "divide_and_conquer/inversions.py",
    "function": "count_inversions_bf",
    "bug_type": "no_bug",
    "pl": "def count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions",
    "fixed_code": "def count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions",
    "tests": [
      "assert count_inversions_bf([1, 4, 2, 4, 1]) == 4",
      "assert count_inversions_bf([1, 1, 2, 4, 4]) == 0",
      "assert count_inversions_bf([]) == 0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "divide_and_conquer/inversions.py",
    "function": "_count_cross_inversions",
    "bug_type": "no_bug",
    "pl": "def _count_cross_inversions(p, q):\n    \"\"\"\n    Counts the inversions across two sorted arrays.\n    And combine the two arrays into one sorted array\n    For all 1<= i<=len(P) and for all 1 <= j <= len(Q),\n    if P[i] > Q[j], then (i, j) is a cross inversion\n    Parameters\n    ----------\n    P: array-like, sorted in non-decreasing order\n    Q: array-like, sorted in non-decreasing order\n    Returns\n    ------\n    R: array-like, a sorted array of the elements of `P` and `Q`\n    num_inversion: int, the number of inversions across `P` and `Q`\n    Examples\n    --------\n    >>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\n    ([0, 1, 2, 2, 3, 5], 4)\n    >>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\n    ([1, 2, 3, 3, 4, 5], 0)\n    \"\"\"\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion",
    "fixed_code": "def _count_cross_inversions(p, q):\n    \"\"\"\n    Counts the inversions across two sorted arrays.\n    And combine the two arrays into one sorted array\n    For all 1<= i<=len(P) and for all 1 <= j <= len(Q),\n    if P[i] > Q[j], then (i, j) is a cross inversion\n    Parameters\n    ----------\n    P: array-like, sorted in non-decreasing order\n    Q: array-like, sorted in non-decreasing order\n    Returns\n    ------\n    R: array-like, a sorted array of the elements of `P` and `Q`\n    num_inversion: int, the number of inversions across `P` and `Q`\n    Examples\n    --------\n    >>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\n    ([0, 1, 2, 2, 3, 5], 4)\n    >>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\n    ([1, 2, 3, 3, 4, 5], 0)\n    \"\"\"\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion",
    "tests": [
      "assert _count_cross_inversions([1, 2, 3], [0, 2, 5]) == ([0, 1, 2, 2, 3, 5], 4)",
      "assert _count_cross_inversions([1, 2, 3], [3, 4, 5]) == ([1, 2, 3, 3, 4, 5], 0)"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "divide_and_conquer/closest_pair_of_points.py",
    "function": "euclidean_distance_sqr",
    "bug_type": "no_bug",
    "pl": "def euclidean_distance_sqr(point1, point2):\n    \"\"\"\n    >>> euclidean_distance_sqr([1,2],[2,4])\n    5\n    \"\"\"\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2",
    "fixed_code": "def euclidean_distance_sqr(point1, point2):\n    \"\"\"\n    >>> euclidean_distance_sqr([1,2],[2,4])\n    5\n    \"\"\"\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2",
    "tests": [
      "assert euclidean_distance_sqr([1,2],[2,4]) == 5"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "divide_and_conquer/closest_pair_of_points.py",
    "function": "column_based_sort",
    "bug_type": "no_bug",
    "pl": "def column_based_sort(array, column=0):\n    \"\"\"\n    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\n    [(3, 0), (5, 1), (4, 2)]\n    \"\"\"\n    return sorted(array, key=lambda x: x[column])",
    "fixed_code": "def column_based_sort(array, column=0):\n    \"\"\"\n    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\n    [(3, 0), (5, 1), (4, 2)]\n    \"\"\"\n    return sorted(array, key=lambda x: x[column])",
    "tests": [
      "assert column_based_sort([(5, 1), (4, 2), (3, 0)], 1) == [(3, 0), (5, 1), (4, 2)]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "divide_and_conquer/power.py",
    "function": "actual_power",
    "bug_type": "no_bug",
    "pl": "def actual_power(a: int, b: int) -> int:\n    \"\"\"\n    Function using divide and conquer to calculate a^b.\n    It only works for integer a,b.\n\n    :param a: The base of the power operation, an integer.\n    :param b: The exponent of the power operation, a non-negative integer.\n    :return: The result of a^b.\n\n    Examples:\n    >>> actual_power(3, 2)\n    9\n    >>> actual_power(5, 3)\n    125\n    >>> actual_power(2, 5)\n    32\n    >>> actual_power(7, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    half = actual_power(a, b // 2)\n\n    if (b % 2) == 0:\n        return half * half\n    else:\n        return a * half * half",
    "fixed_code": "def actual_power(a: int, b: int) -> int:\n    \"\"\"\n    Function using divide and conquer to calculate a^b.\n    It only works for integer a,b.\n\n    :param a: The base of the power operation, an integer.\n    :param b: The exponent of the power operation, a non-negative integer.\n    :return: The result of a^b.\n\n    Examples:\n    >>> actual_power(3, 2)\n    9\n    >>> actual_power(5, 3)\n    125\n    >>> actual_power(2, 5)\n    32\n    >>> actual_power(7, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    half = actual_power(a, b // 2)\n\n    if (b % 2) == 0:\n        return half * half\n    else:\n        return a * half * half",
    "tests": [
      "assert actual_power(3, 2) == 9",
      "assert actual_power(5, 3) == 125",
      "assert actual_power(2, 5) == 32",
      "assert actual_power(7, 0) == 1"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/regex_match.py",
    "function": "recursive_match",
    "bug_type": "no_bug",
    "pl": "def recursive_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Recursive matching algorithm.\n\n    | Time complexity: O(2^(\\|text\\| + \\|pattern\\|))\n    | Space complexity: Recursion depth is O(\\|text\\| + \\|pattern\\|).\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> recursive_match('abc', 'a.c')\n    True\n    >>> recursive_match('abc', 'af*.c')\n    True\n    >>> recursive_match('abc', 'a.c*')\n    True\n    >>> recursive_match('abc', 'a.c*d')\n    False\n    >>> recursive_match('aa', '.*')\n    True\n    \"\"\"\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False",
    "fixed_code": "def recursive_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Recursive matching algorithm.\n\n    | Time complexity: O(2^(\\|text\\| + \\|pattern\\|))\n    | Space complexity: Recursion depth is O(\\|text\\| + \\|pattern\\|).\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> recursive_match('abc', 'a.c')\n    True\n    >>> recursive_match('abc', 'af*.c')\n    True\n    >>> recursive_match('abc', 'a.c*')\n    True\n    >>> recursive_match('abc', 'a.c*d')\n    False\n    >>> recursive_match('aa', '.*')\n    True\n    \"\"\"\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False",
    "tests": [
      "assert recursive_match('abc', 'a.c') == True",
      "assert recursive_match('abc', 'af*.c') == True",
      "assert recursive_match('abc', 'a.c*') == True",
      "assert recursive_match('abc', 'a.c*d') == False",
      "assert recursive_match('aa', '.*') == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/regex_match.py",
    "function": "dp_match",
    "bug_type": "no_bug",
    "pl": "def dp_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Dynamic programming matching algorithm.\n\n    | Time complexity: O(\\|text\\| * \\|pattern\\|)\n    | Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]",
    "fixed_code": "def dp_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Dynamic programming matching algorithm.\n\n    | Time complexity: O(\\|text\\| * \\|pattern\\|)\n    | Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]",
    "tests": [
      "assert dp_match('abc', 'a.c') == True",
      "assert dp_match('abc', 'af*.c') == True",
      "assert dp_match('abc', 'a.c*') == True",
      "assert dp_match('abc', 'a.c*d') == False",
      "assert dp_match('aa', '.*') == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/subset_generation.py",
    "function": "subset_combinations",
    "bug_type": "no_bug",
    "pl": "def subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n\n    Args:\n        * `elements`: The list of elements from which combinations will be generated.\n        * `n`: The number of elements in each combination.\n\n    Returns:\n        A list of tuples, each representing a combination of `n` elements.\n\n    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n    >>> subset_combinations(elements=[1, 2, 3], n=1)\n    [(1,), (2,), (3,)]\n    >>> subset_combinations(elements=[1, 2, 3], n=3)\n    [(1, 2, 3)]\n    >>> subset_combinations(elements=[42], n=1)\n    [(42,)]\n    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n    [(6, 7, 8, 9)]\n    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n    [()]\n    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n    >>> subset_combinations(elements=['single'], n=0)\n    [()]\n    >>> subset_combinations(elements=[], n=9)\n    []\n    >>> from itertools import combinations\n    >>> all(subset_combinations(items, n) == list(combinations(items, n))\n    ...     for items, n in (\n    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n    True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]",
    "fixed_code": "def subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n\n    Args:\n        * `elements`: The list of elements from which combinations will be generated.\n        * `n`: The number of elements in each combination.\n\n    Returns:\n        A list of tuples, each representing a combination of `n` elements.\n\n    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n    >>> subset_combinations(elements=[1, 2, 3], n=1)\n    [(1,), (2,), (3,)]\n    >>> subset_combinations(elements=[1, 2, 3], n=3)\n    [(1, 2, 3)]\n    >>> subset_combinations(elements=[42], n=1)\n    [(42,)]\n    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n    [(6, 7, 8, 9)]\n    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n    [()]\n    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n    >>> subset_combinations(elements=['single'], n=0)\n    [()]\n    >>> subset_combinations(elements=[], n=9)\n    []\n    >>> from itertools import combinations\n    >>> all(subset_combinations(items, n) == list(combinations(items, n))\n    ...     for items, n in (\n    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n    True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]",
    "tests": [
      "assert subset_combinations(elements=[10, 20, 30, 40], n=2) == [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]",
      "assert subset_combinations(elements=[1, 2, 3], n=1) == [(1,), (2,), (3,)]",
      "assert subset_combinations(elements=[1, 2, 3], n=3) == [(1, 2, 3)]",
      "assert subset_combinations(elements=[42], n=1) == [(42,)]",
      "assert subset_combinations(elements=[6, 7, 8, 9], n=4) == [(6, 7, 8, 9)]",
      "assert subset_combinations(elements=[10, 20, 30, 40, 50], n=0) == [()]",
      "assert subset_combinations(elements=[1, 2, 3, 4], n=2) == [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]",
      "assert subset_combinations(elements=[1, 'apple', 3.14], n=2) == [(1, 'apple'), (1, 3.14), ('apple', 3.14)]",
      "assert subset_combinations(elements=['single'], n=0) == [()]",
      "assert subset_combinations(elements=[], n=9) == []"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/palindrome_partitioning.py",
    "function": "find_minimum_partitions",
    "bug_type": "no_bug",
    "pl": "def find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]",
    "fixed_code": "def find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]",
    "tests": [
      "assert find_minimum_partitions(\"aab\") == 1",
      "assert find_minimum_partitions(\"aaa\") == 0",
      "assert find_minimum_partitions(\"ababbbabbababa\") == 3"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/smith_waterman.py",
    "function": "score_function",
    "bug_type": "no_bug",
    "pl": "def score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch",
    "fixed_code": "def score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch",
    "tests": [
      "assert score_function('A', 'A') == 1",
      "assert score_function('A', 'C') == -1",
      "assert score_function('-', 'A') == -2",
      "assert score_function('A', '-') == -2",
      "assert score_function('-', '-') == -2"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/abbreviation.py",
    "function": "abbr",
    "bug_type": "no_bug",
    "pl": "def abbr(a: str, b: str) -> bool:\n    \"\"\"\n    >>> abbr(\"daBcd\", \"ABC\")\n    True\n    >>> abbr(\"dBcd\", \"ABC\")\n    False\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m + 1):\n            if dp[i][j]:\n                if j < m and a[i].upper() == b[j]:\n                    dp[i + 1][j + 1] = True\n                if a[i].islower():\n                    dp[i + 1][j] = True\n    return dp[n][m]",
    "fixed_code": "def abbr(a: str, b: str) -> bool:\n    \"\"\"\n    >>> abbr(\"daBcd\", \"ABC\")\n    True\n    >>> abbr(\"dBcd\", \"ABC\")\n    False\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m + 1):\n            if dp[i][j]:\n                if j < m and a[i].upper() == b[j]:\n                    dp[i + 1][j + 1] = True\n                if a[i].islower():\n                    dp[i + 1][j] = True\n    return dp[n][m]",
    "tests": [
      "assert abbr(\"daBcd\", \"ABC\") == True",
      "assert abbr(\"dBcd\", \"ABC\") == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/longest_common_subsequence.py",
    "function": "longest_common_subsequence",
    "bug_type": "no_bug",
    "pl": "def longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq",
    "fixed_code": "def longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq",
    "tests": [
      "assert longest_common_subsequence(\"programming\", \"gaming\") == (6, 'gaming')",
      "assert longest_common_subsequence(\"physics\", \"smartphone\") == (2, 'ph')",
      "assert longest_common_subsequence(\"computer\", \"food\") == (1, 'o')",
      "assert longest_common_subsequence(\"\", \"abc\")  # One string is empty == (0, '')",
      "assert longest_common_subsequence(\"abc\", \"\")  # Other string is empty == (0, '')",
      "assert longest_common_subsequence(\"\", \"\")  # Both strings are empty == (0, '')",
      "assert longest_common_subsequence(\"abc\", \"def\")  # No common subsequence == (0, '')",
      "assert longest_common_subsequence(\"abc\", \"abc\")  # Identical strings == (3, 'abc')",
      "assert longest_common_subsequence(\"a\", \"a\")  # Single character match == (1, 'a')",
      "assert longest_common_subsequence(\"a\", \"b\")  # Single character no match == (0, '')",
      "assert longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence == (3, 'ace')",
      "assert longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters == (3, 'ABD')"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/tribonacci.py",
    "function": "tribonacci",
    "bug_type": "no_bug",
    "pl": "def tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp",
    "fixed_code": "def tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp",
    "tests": [
      "assert tribonacci(5) == [0, 0, 1, 1, 2]",
      "assert tribonacci(8) == [0, 0, 1, 1, 2, 4, 7, 13]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/range_sum_query.py",
    "function": "prefix_sum",
    "bug_type": "no_bug",
    "pl": "def prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result",
    "fixed_code": "def prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result",
    "tests": [
      "assert prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)]) == [81, 85, 63]",
      "assert prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)]) == [9, 9, 7]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/max_non_adjacent_sum.py",
    "function": "maximum_non_adjacent_sum",
    "bug_type": "no_bug",
    "pl": "def maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)",
    "fixed_code": "def maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)",
    "tests": [
      "assert maximum_non_adjacent_sum([1, 2, 3]) == 4",
      "assert maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6]) == 18",
      "assert maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6]) == 0",
      "assert maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6]) == 500"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/largest_divisible_subset.py",
    "function": "largest_divisible_subset",
    "bug_type": "no_bug",
    "pl": "def largest_divisible_subset(items: list[int]) -> list[int]:\n    \"\"\"\n    Algorithm to find the biggest subset in the given array such that for any 2 elements\n    x and y in the subset, either x divides y or y divides x.\n    >>> largest_divisible_subset([1, 16, 7, 8, 4])\n    [16, 8, 4, 1]\n    >>> largest_divisible_subset([1, 2, 3])\n    [2, 1]\n    >>> largest_divisible_subset([-1, -2, -3])\n    [-3]\n    >>> largest_divisible_subset([1, 2, 4, 8])\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset((1, 2, 4, 8))\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset([1, 1, 1])\n    [1, 1, 1]\n    >>> largest_divisible_subset([0, 0, 0])\n    [0, 0, 0]\n    >>> largest_divisible_subset([-1, -1, -1])\n    [-1, -1, -1]\n    >>> largest_divisible_subset([])\n    []\n    \"\"\"\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result",
    "fixed_code": "def largest_divisible_subset(items: list[int]) -> list[int]:\n    \"\"\"\n    Algorithm to find the biggest subset in the given array such that for any 2 elements\n    x and y in the subset, either x divides y or y divides x.\n    >>> largest_divisible_subset([1, 16, 7, 8, 4])\n    [16, 8, 4, 1]\n    >>> largest_divisible_subset([1, 2, 3])\n    [2, 1]\n    >>> largest_divisible_subset([-1, -2, -3])\n    [-3]\n    >>> largest_divisible_subset([1, 2, 4, 8])\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset((1, 2, 4, 8))\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset([1, 1, 1])\n    [1, 1, 1]\n    >>> largest_divisible_subset([0, 0, 0])\n    [0, 0, 0]\n    >>> largest_divisible_subset([-1, -1, -1])\n    [-1, -1, -1]\n    >>> largest_divisible_subset([])\n    []\n    \"\"\"\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result",
    "tests": [
      "assert largest_divisible_subset([1, 16, 7, 8, 4]) == [16, 8, 4, 1]",
      "assert largest_divisible_subset([1, 2, 3]) == [2, 1]",
      "assert largest_divisible_subset([-1, -2, -3]) == [-3]",
      "assert largest_divisible_subset([1, 2, 4, 8]) == [8, 4, 2, 1]",
      "assert largest_divisible_subset((1, 2, 4, 8)) == [8, 4, 2, 1]",
      "assert largest_divisible_subset([1, 1, 1]) == [1, 1, 1]",
      "assert largest_divisible_subset([0, 0, 0]) == [0, 0, 0]",
      "assert largest_divisible_subset([-1, -1, -1]) == [-1, -1, -1]",
      "assert largest_divisible_subset([]) == []"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/combination_sum_iv.py",
    "function": "combination_sum_iv_bottom_up",
    "bug_type": "no_bug",
    "pl": "def combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations with using bottom up approach,\n    and returns the count of possible combination in O(N^2) Time Complexity\n    as we are using Dynamic programming array here.\n\n    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    dp_array = [0] * (target + 1)\n    dp_array[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - array[j] >= 0:\n                dp_array[i] += dp_array[i - array[j]]\n\n    return dp_array[target]",
    "fixed_code": "def combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations with using bottom up approach,\n    and returns the count of possible combination in O(N^2) Time Complexity\n    as we are using Dynamic programming array here.\n\n    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    dp_array = [0] * (target + 1)\n    dp_array[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - array[j] >= 0:\n                dp_array[i] += dp_array[i - array[j]]\n\n    return dp_array[target]",
    "tests": [
      "assert combination_sum_iv_bottom_up(3, [1,2,5], 5) == 9"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/wildcard_matching.py",
    "function": "is_match",
    "bug_type": "no_bug",
    "pl": "def is_match(string: str, pattern: str) -> bool:\n    \"\"\"\n    >>> is_match(\"\", \"\")\n    True\n    >>> is_match(\"aa\", \"a\")\n    False\n    >>> is_match(\"abc\", \"abc\")\n    True\n    >>> is_match(\"abc\", \"*c\")\n    True\n    >>> is_match(\"abc\", \"a*\")\n    True\n    >>> is_match(\"abc\", \"*a*\")\n    True\n    >>> is_match(\"abc\", \"?b?\")\n    True\n    >>> is_match(\"abc\", \"*?\")\n    True\n    >>> is_match(\"abc\", \"a*d\")\n    False\n    >>> is_match(\"abc\", \"a*c?\")\n    False\n    >>> is_match('baaabab','*****ba*****ba')\n    False\n    >>> is_match('baaabab','*****ba*****ab')\n    True\n    >>> is_match('aa','*')\n    True\n    \"\"\"\n    dp = [[False] * (len(pattern) + 1) for _ in string + \"1\"]\n    dp[0][0] = True\n    # Fill in the first row\n    for j, char in enumerate(pattern, 1):\n        if char == \"*\":\n            dp[0][j] = dp[0][j - 1]\n    # Fill in the rest of the DP table\n    for i, s_char in enumerate(string, 1):\n        for j, p_char in enumerate(pattern, 1):\n            if p_char in (s_char, \"?\"):\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[len(string)][len(pattern)]",
    "fixed_code": "def is_match(string: str, pattern: str) -> bool:\n    \"\"\"\n    >>> is_match(\"\", \"\")\n    True\n    >>> is_match(\"aa\", \"a\")\n    False\n    >>> is_match(\"abc\", \"abc\")\n    True\n    >>> is_match(\"abc\", \"*c\")\n    True\n    >>> is_match(\"abc\", \"a*\")\n    True\n    >>> is_match(\"abc\", \"*a*\")\n    True\n    >>> is_match(\"abc\", \"?b?\")\n    True\n    >>> is_match(\"abc\", \"*?\")\n    True\n    >>> is_match(\"abc\", \"a*d\")\n    False\n    >>> is_match(\"abc\", \"a*c?\")\n    False\n    >>> is_match('baaabab','*****ba*****ba')\n    False\n    >>> is_match('baaabab','*****ba*****ab')\n    True\n    >>> is_match('aa','*')\n    True\n    \"\"\"\n    dp = [[False] * (len(pattern) + 1) for _ in string + \"1\"]\n    dp[0][0] = True\n    # Fill in the first row\n    for j, char in enumerate(pattern, 1):\n        if char == \"*\":\n            dp[0][j] = dp[0][j - 1]\n    # Fill in the rest of the DP table\n    for i, s_char in enumerate(string, 1):\n        for j, p_char in enumerate(pattern, 1):\n            if p_char in (s_char, \"?\"):\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[len(string)][len(pattern)]",
    "tests": [
      "assert is_match(\"\", \"\") == True",
      "assert is_match(\"aa\", \"a\") == False",
      "assert is_match(\"abc\", \"abc\") == True",
      "assert is_match(\"abc\", \"*c\") == True",
      "assert is_match(\"abc\", \"a*\") == True",
      "assert is_match(\"abc\", \"*a*\") == True",
      "assert is_match(\"abc\", \"?b?\") == True",
      "assert is_match(\"abc\", \"*?\") == True",
      "assert is_match(\"abc\", \"a*d\") == False",
      "assert is_match(\"abc\", \"a*c?\") == False",
      "assert is_match('baaabab','*****ba*****ba') == False",
      "assert is_match('baaabab','*****ba*****ab') == True",
      "assert is_match('aa','*') == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/minimum_steps_to_one.py",
    "function": "min_steps_to_one",
    "bug_type": "no_bug",
    "pl": "def min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]",
    "fixed_code": "def min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]",
    "tests": [
      "assert min_steps_to_one(10) == 3",
      "assert min_steps_to_one(15) == 4",
      "assert min_steps_to_one(6) == 2"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/all_construct.py",
    "function": "all_construct",
    "bug_type": "no_bug",
    "pl": "def all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\n    \"\"\"\n    returns the list containing all the possible\n    combinations a string(`target`) can be constructed from\n    the given list of substrings(`word_bank`)\n\n    >>> all_construct(\"hello\", [\"he\", \"l\", \"o\"])\n    [['he', 'l', 'l', 'o']]\n    >>> all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"])\n    [['purp', 'le'], ['p', 'ur', 'p', 'le']]\n    \"\"\"\n\n    word_bank = word_bank or []\n    # create a table\n    table_size: int = len(target) + 1\n\n    table: list[list[list[str]]] = []\n    for _ in range(table_size):\n        table.append([])\n    # seed value\n    table[0] = [[]]  # because empty string has empty combination\n\n    # iterate through the indices\n    for i in range(table_size):\n        # condition\n        if table[i] != []:\n            for word in word_bank:\n                # slice condition\n                if target[i : i + len(word)] == word:\n                    new_combinations: list[list[str]] = [\n                        [word, *way] for way in table[i]\n                    ]\n                    # adds the word to every combination the current position holds\n                    # now,push that combination to the table[i+len(word)]\n                    table[i + len(word)] += new_combinations\n\n    # combinations are in reverse order so reverse for better output\n    for combination in table[len(target)]:\n        combination.reverse()\n\n    return table[len(target)]",
    "fixed_code": "def all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\n    \"\"\"\n    returns the list containing all the possible\n    combinations a string(`target`) can be constructed from\n    the given list of substrings(`word_bank`)\n\n    >>> all_construct(\"hello\", [\"he\", \"l\", \"o\"])\n    [['he', 'l', 'l', 'o']]\n    >>> all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"])\n    [['purp', 'le'], ['p', 'ur', 'p', 'le']]\n    \"\"\"\n\n    word_bank = word_bank or []\n    # create a table\n    table_size: int = len(target) + 1\n\n    table: list[list[list[str]]] = []\n    for _ in range(table_size):\n        table.append([])\n    # seed value\n    table[0] = [[]]  # because empty string has empty combination\n\n    # iterate through the indices\n    for i in range(table_size):\n        # condition\n        if table[i] != []:\n            for word in word_bank:\n                # slice condition\n                if target[i : i + len(word)] == word:\n                    new_combinations: list[list[str]] = [\n                        [word, *way] for way in table[i]\n                    ]\n                    # adds the word to every combination the current position holds\n                    # now,push that combination to the table[i+len(word)]\n                    table[i + len(word)] += new_combinations\n\n    # combinations are in reverse order so reverse for better output\n    for combination in table[len(target)]:\n        combination.reverse()\n\n    return table[len(target)]",
    "tests": [
      "assert all_construct(\"hello\", [\"he\", \"l\", \"o\"]) == [['he', 'l', 'l', 'o']]",
      "assert all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"]) == [['purp', 'le'], ['p', 'ur', 'p', 'le']]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "dynamic_programming/longest_palindromic_subsequence.py",
    "function": "longest_palindromic_subsequence",
    "bug_type": "no_bug",
    "pl": "def longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]",
    "fixed_code": "def longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]",
    "tests": [
      "assert longest_palindromic_subsequence(\"bbbab\") == 4",
      "assert longest_palindromic_subsequence(\"bbabcbcab\") == 7"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/nth_fibonacci_using_matrix_exponentiation.py",
    "function": "nth_fibonacci_bruteforce",
    "bug_type": "no_bug",
    "pl": "def nth_fibonacci_bruteforce(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_bruteforce(100)\n    354224848179261915075\n    >>> nth_fibonacci_bruteforce(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    fib0 = 0\n    fib1 = 1\n    for _ in range(2, n + 1):\n        fib0, fib1 = fib1, fib0 + fib1\n    return fib1",
    "fixed_code": "def nth_fibonacci_bruteforce(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_bruteforce(100)\n    354224848179261915075\n    >>> nth_fibonacci_bruteforce(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    fib0 = 0\n    fib1 = 1\n    for _ in range(2, n + 1):\n        fib0, fib1 = fib1, fib0 + fib1\n    return fib1",
    "tests": [
      "assert nth_fibonacci_bruteforce(100) == 354224848179261915075",
      "assert nth_fibonacci_bruteforce(-100) == -100"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/largest_square_area_in_matrix.py",
    "function": "largest_square_area_in_matrix_top_down_approch",
    "bug_type": "no_bug",
    "pl": "def largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We aren't using dp_array here, so the time complexity would be exponential.\n\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]",
    "fixed_code": "def largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We aren't using dp_array here, so the time complexity would be exponential.\n\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]",
    "tests": [
      "assert largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]]) == 2",
      "assert largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]]) == 0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/largest_square_area_in_matrix.py",
    "function": "largest_square_area_in_matrix_top_down_approch_with_dp",
    "bug_type": "no_bug",
    "pl": "def largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]",
    "fixed_code": "def largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]",
    "tests": [
      "assert largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]]) == 2",
      "assert largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]]) == 0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/largest_square_area_in_matrix.py",
    "function": "largest_square_area_in_matrix_bottom_up",
    "bug_type": "no_bug",
    "pl": "def largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up approach.\n\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n    0\n\n    \"\"\"\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area",
    "fixed_code": "def largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up approach.\n\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n    0\n\n    \"\"\"\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area",
    "tests": [
      "assert largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]]) == 2",
      "assert largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]]) == 0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/largest_square_area_in_matrix.py",
    "function": "largest_square_area_in_matrix_bottom_up_space_optimization",
    "bug_type": "no_bug",
    "pl": "def largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area",
    "fixed_code": "def largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area",
    "tests": [
      "assert largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]]) == 2",
      "assert largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]]) == 0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/spiral_print.py",
    "function": "spiral_traversal",
    "bug_type": "no_bug",
    "pl": "def spiral_traversal(matrix: list[list]) -> list[int]:\n    \"\"\"\n    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n    Example:\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    Algorithm:\n        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n                output of [step 2])\n        Step 2. Now perform matrix's Transpose operation (Change rows to column\n                and vice versa) and reverse the resultant matrix.\n        Step 3. Pass the output of [2nd step], to same recursive function till\n                base case hits.\n    Dry Run:\n    Stage 1.\n    [1, 2, 3, 4] +   spiral_traversal([\n        [8, 12], [7, 11], [6, 10], [5, 9]]\n     ])\n    Stage 2.\n    [1, 2, 3, 4, 8, 12] + spiral_traversal([\n        [11, 10, 9], [7, 6, 5]\n    ])\n    Stage 3.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 4.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 5.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\n    Stage 6.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])\n    \"\"\"\n    if matrix:\n        return list(matrix.pop(0)) + spiral_traversal(\n            [list(row) for row in zip(*matrix)][::-1]\n        )\n    else:\n        return []",
    "fixed_code": "def spiral_traversal(matrix: list[list]) -> list[int]:\n    \"\"\"\n    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n    Example:\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    Algorithm:\n        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n                output of [step 2])\n        Step 2. Now perform matrix's Transpose operation (Change rows to column\n                and vice versa) and reverse the resultant matrix.\n        Step 3. Pass the output of [2nd step], to same recursive function till\n                base case hits.\n    Dry Run:\n    Stage 1.\n    [1, 2, 3, 4] +   spiral_traversal([\n        [8, 12], [7, 11], [6, 10], [5, 9]]\n     ])\n    Stage 2.\n    [1, 2, 3, 4, 8, 12] + spiral_traversal([\n        [11, 10, 9], [7, 6, 5]\n    ])\n    Stage 3.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 4.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 5.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\n    Stage 6.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])\n    \"\"\"\n    if matrix:\n        return list(matrix.pop(0)) + spiral_traversal(\n            [list(row) for row in zip(*matrix)][::-1]\n        )\n    else:\n        return []",
    "tests": [
      "assert spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/matrix_based_game.py",
    "function": "find_repeat",
    "bug_type": "no_bug",
    "pl": "def find_repeat(\n    matrix_g: list[list[str]], row: int, column: int, size: int\n) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all connected elements of the same type from a given position.\n\n    >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)\n    {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}\n    >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)\n    set()\n    \"\"\"\n\n    column = size - 1 - column\n    visited = set()\n    repeated = set()\n\n    if (color := matrix_g[column][row]) != \"-\":\n\n        def dfs(row_n: int, column_n: int) -> None:\n            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:\n                return\n            if (row_n, column_n) in visited:\n                return\n            visited.add((row_n, column_n))\n            if matrix_g[row_n][column_n] == color:\n                repeated.add((row_n, column_n))\n                dfs(row_n - 1, column_n)\n                dfs(row_n + 1, column_n)\n                dfs(row_n, column_n - 1)\n                dfs(row_n, column_n + 1)\n\n        dfs(column, row)\n\n    return repeated",
    "fixed_code": "def find_repeat(\n    matrix_g: list[list[str]], row: int, column: int, size: int\n) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all connected elements of the same type from a given position.\n\n    >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)\n    {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}\n    >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)\n    set()\n    \"\"\"\n\n    column = size - 1 - column\n    visited = set()\n    repeated = set()\n\n    if (color := matrix_g[column][row]) != \"-\":\n\n        def dfs(row_n: int, column_n: int) -> None:\n            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:\n                return\n            if (row_n, column_n) in visited:\n                return\n            visited.add((row_n, column_n))\n            if matrix_g[row_n][column_n] == color:\n                repeated.add((row_n, column_n))\n                dfs(row_n - 1, column_n)\n                dfs(row_n + 1, column_n)\n                dfs(row_n, column_n - 1)\n                dfs(row_n, column_n + 1)\n\n        dfs(column, row)\n\n    return repeated",
    "tests": [
      "assert find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3) == {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}",
      "assert find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3) == set()"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/matrix_based_game.py",
    "function": "increment_score",
    "bug_type": "no_bug",
    "pl": "def increment_score(count: int) -> int:\n    \"\"\"\n    Calculates the score for a move based on the number of elements removed.\n\n    >>> increment_score(3)\n    6\n    >>> increment_score(0)\n    0\n    \"\"\"\n    return int(count * (count + 1) / 2)",
    "fixed_code": "def increment_score(count: int) -> int:\n    \"\"\"\n    Calculates the score for a move based on the number of elements removed.\n\n    >>> increment_score(3)\n    6\n    >>> increment_score(0)\n    0\n    \"\"\"\n    return int(count * (count + 1) / 2)",
    "tests": [
      "assert increment_score(3) == 6",
      "assert increment_score(0) == 0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/matrix_based_game.py",
    "function": "move_x",
    "bug_type": "no_bug",
    "pl": "def move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n    \"\"\"\n    Simulates gravity in a specific column.\n\n    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n    [['-', '-'], ['-', 'A'], ['-', 'C']]\n    \"\"\"\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g",
    "fixed_code": "def move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n    \"\"\"\n    Simulates gravity in a specific column.\n\n    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n    [['-', '-'], ['-', 'A'], ['-', 'C']]\n    \"\"\"\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g",
    "tests": [
      "assert move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2) == [['-', '-'], ['-', 'A'], ['-', 'C']]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/matrix_based_game.py",
    "function": "move_y",
    "bug_type": "no_bug",
    "pl": "def move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:\n    \"\"\"\n    Shifts all columns leftward when an entire column becomes empty.\n\n    >>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2)\n    [['A', '-'], ['-', '-'], ['-', 'C']]\n    \"\"\"\n\n    empty_columns = []\n\n    for column in range(size - 1, -1, -1):\n        if all(matrix_g[row][column] == \"-\" for row in range(size)):\n            empty_columns.append(column)\n\n    for column in empty_columns:\n        for col in range(column + 1, size):\n            for row in range(size):\n                matrix_g[row][col - 1] = matrix_g[row][col]\n        for row in range(size):\n            matrix_g[row][-1] = \"-\"\n\n    return matrix_g",
    "fixed_code": "def move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:\n    \"\"\"\n    Shifts all columns leftward when an entire column becomes empty.\n\n    >>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2)\n    [['A', '-'], ['-', '-'], ['-', 'C']]\n    \"\"\"\n\n    empty_columns = []\n\n    for column in range(size - 1, -1, -1):\n        if all(matrix_g[row][column] == \"-\" for row in range(size)):\n            empty_columns.append(column)\n\n    for column in empty_columns:\n        for col in range(column + 1, size):\n            for row in range(size):\n                matrix_g[row][col - 1] = matrix_g[row][col]\n        for row in range(size):\n            matrix_g[row][-1] = \"-\"\n\n    return matrix_g",
    "tests": [
      "assert move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2) == [['A', '-'], ['-', '-'], ['-', 'C']]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/count_negative_numbers_in_sorted_matrix.py",
    "function": "generate_large_matrix",
    "bug_type": "no_bug",
    "pl": "def generate_large_matrix() -> list[list[int]]:\n    \"\"\"\n    >>> generate_large_matrix() # doctest: +ELLIPSIS\n    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]\n    \"\"\"\n    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]",
    "fixed_code": "def generate_large_matrix() -> list[list[int]]:\n    \"\"\"\n    >>> generate_large_matrix() # doctest: +ELLIPSIS\n    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]\n    \"\"\"\n    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]",
    "tests": [
      "assert generate_large_matrix() # doctest: +ELLIPSIS == [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "matrix/count_negative_numbers_in_sorted_matrix.py",
    "function": "find_negative_index",
    "bug_type": "no_bug",
    "pl": "def find_negative_index(array: list[int]) -> int:\n    \"\"\"\n    Find the smallest negative index\n\n    >>> find_negative_index([0,0,0,0])\n    4\n    >>> find_negative_index([4,3,2,-1])\n    3\n    >>> find_negative_index([1,0,-1,-10])\n    2\n    >>> find_negative_index([0,0,0,-1])\n    3\n    >>> find_negative_index([11,8,7,-3,-5,-9])\n    3\n    >>> find_negative_index([-1,-1,-2,-3])\n    0\n    >>> find_negative_index([5,1,0])\n    3\n    >>> find_negative_index([-5,-5,-5])\n    0\n    >>> find_negative_index([0])\n    1\n    >>> find_negative_index([])\n    0\n    \"\"\"\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)",
    "fixed_code": "def find_negative_index(array: list[int]) -> int:\n    \"\"\"\n    Find the smallest negative index\n\n    >>> find_negative_index([0,0,0,0])\n    4\n    >>> find_negative_index([4,3,2,-1])\n    3\n    >>> find_negative_index([1,0,-1,-10])\n    2\n    >>> find_negative_index([0,0,0,-1])\n    3\n    >>> find_negative_index([11,8,7,-3,-5,-9])\n    3\n    >>> find_negative_index([-1,-1,-2,-3])\n    0\n    >>> find_negative_index([5,1,0])\n    3\n    >>> find_negative_index([-5,-5,-5])\n    0\n    >>> find_negative_index([0])\n    1\n    >>> find_negative_index([])\n    0\n    \"\"\"\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)",
    "tests": [
      "assert find_negative_index([0,0,0,0]) == 4",
      "assert find_negative_index([4,3,2,-1]) == 3",
      "assert find_negative_index([1,0,-1,-10]) == 2",
      "assert find_negative_index([0,0,0,-1]) == 3",
      "assert find_negative_index([11,8,7,-3,-5,-9]) == 3",
      "assert find_negative_index([-1,-1,-2,-3]) == 0",
      "assert find_negative_index([5,1,0]) == 3",
      "assert find_negative_index([-5,-5,-5]) == 0",
      "assert find_negative_index([0]) == 1",
      "assert find_negative_index([]) == 0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "web_programming/fetch_well_rx_price.py",
    "function": "fetch_pharmacy_and_price_list",
    "bug_type": "no_bug",
    "pl": "def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n    \"\"\"[summary]\n\n    This function will take input of drug name and zipcode,\n    then request to the BASE_URL site.\n    Get the page data and scrape it to generate the\n    list of the lowest prices for the prescription drug.\n\n    Args:\n        drug_name (str): [Drug name]\n        zip_code(str): [Zip code]\n\n    Returns:\n        list: [List of pharmacy name and price]\n\n    >>> print(fetch_pharmacy_and_price_list(None, None))\n    None\n    >>> print(fetch_pharmacy_and_price_list(None, 30303))\n    None\n    >>> print(fetch_pharmacy_and_price_list(\"eliquis\", None))\n    None\n    \"\"\"\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None",
    "fixed_code": "def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n    \"\"\"[summary]\n\n    This function will take input of drug name and zipcode,\n    then request to the BASE_URL site.\n    Get the page data and scrape it to generate the\n    list of the lowest prices for the prescription drug.\n\n    Args:\n        drug_name (str): [Drug name]\n        zip_code(str): [Zip code]\n\n    Returns:\n        list: [List of pharmacy name and price]\n\n    >>> print(fetch_pharmacy_and_price_list(None, None))\n    None\n    >>> print(fetch_pharmacy_and_price_list(None, 30303))\n    None\n    >>> print(fetch_pharmacy_and_price_list(\"eliquis\", None))\n    None\n    \"\"\"\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None",
    "tests": [
      "assert print(fetch_pharmacy_and_price_list(None, None)) == None",
      "assert print(fetch_pharmacy_and_price_list(None, 30303)) == None",
      "assert print(fetch_pharmacy_and_price_list(\"eliquis\", None)) == None"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/merge_insertion_sort.py",
    "function": "binary_search_insertion",
    "bug_type": "no_bug",
    "pl": "def binary_search_insertion(sorted_list, item):\n    \"\"\"\n    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)\n    [1, 2, 4, 7, 9, 10]\n    \"\"\"\n    left = 0\n    right = len(sorted_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if left == right:\n            if sorted_list[middle] < item:\n                left = middle + 1\n            break\n        elif sorted_list[middle] < item:\n            left = middle + 1\n        else:\n            right = middle - 1\n    sorted_list.insert(left, item)\n    return sorted_list",
    "fixed_code": "def binary_search_insertion(sorted_list, item):\n    \"\"\"\n    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)\n    [1, 2, 4, 7, 9, 10]\n    \"\"\"\n    left = 0\n    right = len(sorted_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if left == right:\n            if sorted_list[middle] < item:\n                left = middle + 1\n            break\n        elif sorted_list[middle] < item:\n            left = middle + 1\n        else:\n            right = middle - 1\n    sorted_list.insert(left, item)\n    return sorted_list",
    "tests": [
      "assert binary_search_insertion([1, 2, 7, 9, 10], 4) == [1, 2, 4, 7, 9, 10]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/merge_insertion_sort.py",
    "function": "merge",
    "bug_type": "no_bug",
    "pl": "def merge(left, right):\n    \"\"\"\n    >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0][0] < right[0][0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right",
    "fixed_code": "def merge(left, right):\n    \"\"\"\n    >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0][0] < right[0][0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right",
    "tests": [
      "assert merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]]) == [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/selection_sort.py",
    "function": "selection_sort",
    "bug_type": "no_bug",
    "pl": "def selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection",
    "fixed_code": "def selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection",
    "tests": [
      "assert selection_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert selection_sort([]) == []",
      "assert selection_sort([-2, -5, -45]) == [-45, -5, -2]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/shrink_shell_sort.py",
    "function": "shell_sort",
    "bug_type": "no_bug",
    "pl": "def shell_sort(collection: list) -> list:\n    \"\"\"Implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([3, 2, 1])\n    [1, 2, 3]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([1])\n    [1]\n    \"\"\"\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection",
    "fixed_code": "def shell_sort(collection: list) -> list:\n    \"\"\"Implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([3, 2, 1])\n    [1, 2, 3]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([1])\n    [1]\n    \"\"\"\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection",
    "tests": [
      "assert shell_sort([3, 2, 1]) == [1, 2, 3]",
      "assert shell_sort([]) == []",
      "assert shell_sort([1]) == [1]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/odd_even_transposition_single_threaded.py",
    "function": "odd_even_transposition",
    "bug_type": "no_bug",
    "pl": "def odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr",
    "fixed_code": "def odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr",
    "tests": [
      "assert odd_even_transposition([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]",
      "assert odd_even_transposition([13, 11, 18, 0, -1]) == [-1, 0, 11, 13, 18]",
      "assert odd_even_transposition([-.1, 1.1, .1, -2.9]) == [-2.9, -0.1, 0.1, 1.1]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/cyclic_sort.py",
    "function": "cyclic_sort",
    "bug_type": "no_bug",
    "pl": "def cyclic_sort(nums: list[int]) -> list[int]:\n    \"\"\"\n    Sorts the input list of n integers from 1 to n in-place\n    using the Cyclic Sort algorithm.\n\n    :param nums: List of n integers from 1 to n to be sorted.\n    :return: The same list sorted in ascending order.\n\n    Time complexity: O(n), where n is the number of integers in the list.\n\n    Examples:\n    >>> cyclic_sort([])\n    []\n    >>> cyclic_sort([3, 5, 2, 1, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums",
    "fixed_code": "def cyclic_sort(nums: list[int]) -> list[int]:\n    \"\"\"\n    Sorts the input list of n integers from 1 to n in-place\n    using the Cyclic Sort algorithm.\n\n    :param nums: List of n integers from 1 to n to be sorted.\n    :return: The same list sorted in ascending order.\n\n    Time complexity: O(n), where n is the number of integers in the list.\n\n    Examples:\n    >>> cyclic_sort([])\n    []\n    >>> cyclic_sort([3, 5, 2, 1, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums",
    "tests": [
      "assert cyclic_sort([]) == []",
      "assert cyclic_sort([3, 5, 2, 1, 4]) == [1, 2, 3, 4, 5]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/comb_sort.py",
    "function": "comb_sort",
    "bug_type": "no_bug",
    "pl": "def comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data",
    "fixed_code": "def comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data",
    "tests": [
      "assert comb_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert comb_sort([]) == []",
      "assert comb_sort([99, 45, -7, 8, 2, 0, -15, 3]) == [-15, -7, 0, 2, 3, 8, 45, 99]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/circle_sort.py",
    "function": "circle_sort",
    "bug_type": "no_bug",
    "pl": "def circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection",
    "fixed_code": "def circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection",
    "tests": [
      "assert circle_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert circle_sort([]) == []",
      "assert circle_sort([-2, 5, 0, -45]) == [-45, -2, 0, 5]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/counting_sort.py",
    "function": "counting_sort",
    "bug_type": "no_bug",
    "pl": "def counting_sort(collection):\n    \"\"\"Pure implementation of counting sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> counting_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> counting_sort([])\n    []\n    >>> counting_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered",
    "fixed_code": "def counting_sort(collection):\n    \"\"\"Pure implementation of counting sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> counting_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> counting_sort([])\n    []\n    >>> counting_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered",
    "tests": [
      "assert counting_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert counting_sort([]) == []",
      "assert counting_sort([-2, -5, -45]) == [-45, -5, -2]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/pancake_sort.py",
    "function": "pancake_sort",
    "bug_type": "no_bug",
    "pl": "def pancake_sort(arr):\n    \"\"\"Sort Array with Pancake Sort.\n    :param arr: Collection containing comparable items\n    :return: Collection ordered in ascending order of items\n    Examples:\n    >>> pancake_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pancake_sort([])\n    []\n    >>> pancake_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    cur = len(arr)\n    while cur > 1:\n        # Find the maximum number in arr\n        mi = arr.index(max(arr[0:cur]))\n        # Reverse from 0 to mi\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\n        # Reverse whole list\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\n        cur -= 1\n    return arr",
    "fixed_code": "def pancake_sort(arr):\n    \"\"\"Sort Array with Pancake Sort.\n    :param arr: Collection containing comparable items\n    :return: Collection ordered in ascending order of items\n    Examples:\n    >>> pancake_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pancake_sort([])\n    []\n    >>> pancake_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    cur = len(arr)\n    while cur > 1:\n        # Find the maximum number in arr\n        mi = arr.index(max(arr[0:cur]))\n        # Reverse from 0 to mi\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\n        # Reverse whole list\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\n        cur -= 1\n    return arr",
    "tests": [
      "assert pancake_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert pancake_sort([]) == []",
      "assert pancake_sort([-2, -5, -45]) == [-45, -5, -2]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/exchange_sort.py",
    "function": "exchange_sort",
    "bug_type": "no_bug",
    "pl": "def exchange_sort(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Uses exchange sort to sort a list of numbers.\n    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    >>> exchange_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([-1, -2, -3])\n    [-3, -2, -1]\n    >>> exchange_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([0, 10, -2, 5, 3])\n    [-2, 0, 3, 5, 10]\n    >>> exchange_sort([])\n    []\n    \"\"\"\n    numbers_length = len(numbers)\n    for i in range(numbers_length):\n        for j in range(i + 1, numbers_length):\n            if numbers[j] < numbers[i]:\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n    return numbers",
    "fixed_code": "def exchange_sort(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Uses exchange sort to sort a list of numbers.\n    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    >>> exchange_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([-1, -2, -3])\n    [-3, -2, -1]\n    >>> exchange_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([0, 10, -2, 5, 3])\n    [-2, 0, 3, 5, 10]\n    >>> exchange_sort([])\n    []\n    \"\"\"\n    numbers_length = len(numbers)\n    for i in range(numbers_length):\n        for j in range(i + 1, numbers_length):\n            if numbers[j] < numbers[i]:\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n    return numbers",
    "tests": [
      "assert exchange_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]",
      "assert exchange_sort([-1, -2, -3]) == [-3, -2, -1]",
      "assert exchange_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]",
      "assert exchange_sort([0, 10, -2, 5, 3]) == [-2, 0, 3, 5, 10]",
      "assert exchange_sort([]) == []"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/stalin_sort.py",
    "function": "stalin_sort",
    "bug_type": "no_bug",
    "pl": "def stalin_sort(sequence: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Stalin sort algorithm.\n\n    >>> stalin_sort([4, 3, 5, 2, 1, 7])\n    [4, 5, 7]\n\n    >>> stalin_sort([1, 2, 3, 4])\n    [1, 2, 3, 4]\n\n    >>> stalin_sort([4, 5, 5, 2, 3])\n    [4, 5, 5]\n\n    >>> stalin_sort([6, 11, 12, 4, 1, 5])\n    [6, 11, 12]\n\n    >>> stalin_sort([5, 0, 4, 3])\n    [5]\n\n    >>> stalin_sort([5, 4, 3, 2, 1])\n    [5]\n\n    >>> stalin_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> stalin_sort([1, 2, 8, 7, 6])\n    [1, 2, 8]\n    \"\"\"\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result",
    "fixed_code": "def stalin_sort(sequence: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Stalin sort algorithm.\n\n    >>> stalin_sort([4, 3, 5, 2, 1, 7])\n    [4, 5, 7]\n\n    >>> stalin_sort([1, 2, 3, 4])\n    [1, 2, 3, 4]\n\n    >>> stalin_sort([4, 5, 5, 2, 3])\n    [4, 5, 5]\n\n    >>> stalin_sort([6, 11, 12, 4, 1, 5])\n    [6, 11, 12]\n\n    >>> stalin_sort([5, 0, 4, 3])\n    [5]\n\n    >>> stalin_sort([5, 4, 3, 2, 1])\n    [5]\n\n    >>> stalin_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> stalin_sort([1, 2, 8, 7, 6])\n    [1, 2, 8]\n    \"\"\"\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result",
    "tests": [
      "assert stalin_sort([4, 3, 5, 2, 1, 7]) == [4, 5, 7]",
      "assert stalin_sort([1, 2, 3, 4]) == [1, 2, 3, 4]",
      "assert stalin_sort([4, 5, 5, 2, 3]) == [4, 5, 5]",
      "assert stalin_sort([6, 11, 12, 4, 1, 5]) == [6, 11, 12]",
      "assert stalin_sort([5, 0, 4, 3]) == [5]",
      "assert stalin_sort([5, 4, 3, 2, 1]) == [5]",
      "assert stalin_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]",
      "assert stalin_sort([1, 2, 8, 7, 6]) == [1, 2, 8]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/merge_sort.py",
    "function": "merge_sort",
    "bug_type": "no_bug",
    "pl": "def merge_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Time Complexity: O(n log n)\n    Space Complexity: O(n)\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def merge(left: list, right: list) -> list:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n\n        :param left: Left collection\n        :param right: Right collection\n        :return: Merged result\n        \"\"\"\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))",
    "fixed_code": "def merge_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Time Complexity: O(n log n)\n    Space Complexity: O(n)\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def merge(left: list, right: list) -> list:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n\n        :param left: Left collection\n        :param right: Right collection\n        :return: Merged result\n        \"\"\"\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))",
    "tests": [
      "assert merge_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]",
      "assert merge_sort([]) == []",
      "assert merge_sort([-2, -5, -45]) == [-45, -5, -2]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/quick_sort_3_partition.py",
    "function": "lomuto_partition",
    "bug_type": "no_bug",
    "pl": "def lomuto_partition(sorting: list, left: int, right: int) -> int:\n    \"\"\"\n    Example:\n    >>> lomuto_partition([1,5,7,6], 0, 3)\n    2\n    \"\"\"\n    pivot = sorting[right]\n    store_index = left\n    for i in range(left, right):\n        if sorting[i] < pivot:\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\n            store_index += 1\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\n    return store_index",
    "fixed_code": "def lomuto_partition(sorting: list, left: int, right: int) -> int:\n    \"\"\"\n    Example:\n    >>> lomuto_partition([1,5,7,6], 0, 3)\n    2\n    \"\"\"\n    pivot = sorting[right]\n    store_index = left\n    for i in range(left, right):\n        if sorting[i] < pivot:\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\n            store_index += 1\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\n    return store_index",
    "tests": [
      "assert lomuto_partition([1,5,7,6], 0, 3) == 2"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/quick_sort_3_partition.py",
    "function": "three_way_radix_quicksort",
    "bug_type": "no_bug",
    "pl": "def three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )",
    "fixed_code": "def three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )",
    "tests": [
      "assert three_way_radix_quicksort([]) == []",
      "assert three_way_radix_quicksort([1]) == [1]",
      "assert three_way_radix_quicksort([-5, -2, 1, -2, 0, 1]) == [-5, -2, -2, 0, 1, 1]",
      "assert three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1]) == [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "sorts/odd_even_sort.py",
    "function": "odd_even_sort",
    "bug_type": "no_bug",
    "pl": "def odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list",
    "fixed_code": "def odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list",
    "tests": [
      "assert odd_even_sort([5 , 4 ,3 ,2 ,1]) == [1, 2, 3, 4, 5]",
      "assert odd_even_sort([]) == []",
      "assert odd_even_sort([-10 ,-1 ,10 ,2]) == [-10, -1, 2, 10]",
      "assert odd_even_sort([1 ,2 ,3 ,4]) == [1, 2, 3, 4]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/is_contains_unique_chars.py",
    "function": "is_contains_unique_chars",
    "bug_type": "no_bug",
    "pl": "def is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True",
    "fixed_code": "def is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True",
    "tests": [
      "assert is_contains_unique_chars(\"I_love.py\") == True",
      "assert is_contains_unique_chars(\"I don't love Python\") == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/text_justification.py",
    "function": "text_justification",
    "bug_type": "no_bug",
    "pl": "def text_justification(word: str, max_width: int) -> list:\n    \"\"\"\n    Will format the string such that each line has exactly\n    (max_width) characters and is fully (left and right) justified,\n    and return the list of justified text.\n\n    example 1:\n    string = \"This is an example of text justification.\"\n    max_width = 16\n\n    output = ['This    is    an',\n              'example  of text',\n              'justification.  ']\n\n    >>> text_justification(\"This is an example of text justification.\", 16)\n    ['This    is    an', 'example  of text', 'justification.  ']\n\n    example 2:\n    string = \"Two roads diverged in a yellow wood\"\n    max_width = 16\n    output = ['Two        roads',\n              'diverged   in  a',\n              'yellow wood     ']\n\n    >>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n    ['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\n    Time complexity: O(m*n)\n    Space complexity: O(m*n)\n    \"\"\"\n\n    # Converting string into list of strings split by a space\n    words = word.split()\n\n    def justify(line: list, width: int, max_width: int) -> str:\n        overall_spaces_count = max_width - width\n        words_count = len(line)\n        if len(line) == 1:\n            # if there is only word in line\n            # just insert overall_spaces_count for the remainder of line\n            return line[0] + \" \" * overall_spaces_count\n        else:\n            spaces_to_insert_between_words = words_count - 1\n            # num_spaces_between_words_list[i] : tells you to insert\n            # num_spaces_between_words_list[i] spaces\n            # after word on line[i]\n            num_spaces_between_words_list = spaces_to_insert_between_words * [\n                overall_spaces_count // spaces_to_insert_between_words\n            ]\n            spaces_count_in_locations = (\n                overall_spaces_count % spaces_to_insert_between_words\n            )\n            # distribute spaces via round robin to the left words\n            for i in range(spaces_count_in_locations):\n                num_spaces_between_words_list[i] += 1\n            aligned_words_list = []\n            for i in range(spaces_to_insert_between_words):\n                # add the word\n                aligned_words_list.append(line[i])\n                # add the spaces to insert\n                aligned_words_list.append(num_spaces_between_words_list[i] * \" \")\n            # just add the last word to the sentence\n            aligned_words_list.append(line[-1])\n            # join the aligned words list to form a justified line\n            return \"\".join(aligned_words_list)\n\n    answer = []\n    line: list[str] = []\n    width = 0\n    for inner_word in words:\n        if width + len(inner_word) + len(line) <= max_width:\n            # keep adding words until we can fill out max_width\n            # width = sum of length of all words (without overall_spaces_count)\n            # len(inner_word) = length of current inner_word\n            # len(line) = number of overall_spaces_count to insert between words\n            line.append(inner_word)\n            width += len(inner_word)\n        else:\n            # justify the line and add it to result\n            answer.append(justify(line, width, max_width))\n            # reset new line and new width\n            line, width = [inner_word], len(inner_word)\n    remaining_spaces = max_width - width - len(line)\n    answer.append(\" \".join(line) + (remaining_spaces + 1) * \" \")\n    return answer",
    "fixed_code": "def text_justification(word: str, max_width: int) -> list:\n    \"\"\"\n    Will format the string such that each line has exactly\n    (max_width) characters and is fully (left and right) justified,\n    and return the list of justified text.\n\n    example 1:\n    string = \"This is an example of text justification.\"\n    max_width = 16\n\n    output = ['This    is    an',\n              'example  of text',\n              'justification.  ']\n\n    >>> text_justification(\"This is an example of text justification.\", 16)\n    ['This    is    an', 'example  of text', 'justification.  ']\n\n    example 2:\n    string = \"Two roads diverged in a yellow wood\"\n    max_width = 16\n    output = ['Two        roads',\n              'diverged   in  a',\n              'yellow wood     ']\n\n    >>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n    ['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\n    Time complexity: O(m*n)\n    Space complexity: O(m*n)\n    \"\"\"\n\n    # Converting string into list of strings split by a space\n    words = word.split()\n\n    def justify(line: list, width: int, max_width: int) -> str:\n        overall_spaces_count = max_width - width\n        words_count = len(line)\n        if len(line) == 1:\n            # if there is only word in line\n            # just insert overall_spaces_count for the remainder of line\n            return line[0] + \" \" * overall_spaces_count\n        else:\n            spaces_to_insert_between_words = words_count - 1\n            # num_spaces_between_words_list[i] : tells you to insert\n            # num_spaces_between_words_list[i] spaces\n            # after word on line[i]\n            num_spaces_between_words_list = spaces_to_insert_between_words * [\n                overall_spaces_count // spaces_to_insert_between_words\n            ]\n            spaces_count_in_locations = (\n                overall_spaces_count % spaces_to_insert_between_words\n            )\n            # distribute spaces via round robin to the left words\n            for i in range(spaces_count_in_locations):\n                num_spaces_between_words_list[i] += 1\n            aligned_words_list = []\n            for i in range(spaces_to_insert_between_words):\n                # add the word\n                aligned_words_list.append(line[i])\n                # add the spaces to insert\n                aligned_words_list.append(num_spaces_between_words_list[i] * \" \")\n            # just add the last word to the sentence\n            aligned_words_list.append(line[-1])\n            # join the aligned words list to form a justified line\n            return \"\".join(aligned_words_list)\n\n    answer = []\n    line: list[str] = []\n    width = 0\n    for inner_word in words:\n        if width + len(inner_word) + len(line) <= max_width:\n            # keep adding words until we can fill out max_width\n            # width = sum of length of all words (without overall_spaces_count)\n            # len(inner_word) = length of current inner_word\n            # len(line) = number of overall_spaces_count to insert between words\n            line.append(inner_word)\n            width += len(inner_word)\n        else:\n            # justify the line and add it to result\n            answer.append(justify(line, width, max_width))\n            # reset new line and new width\n            line, width = [inner_word], len(inner_word)\n    remaining_spaces = max_width - width - len(line)\n    answer.append(\" \".join(line) + (remaining_spaces + 1) * \" \")\n    return answer",
    "tests": [
      "assert text_justification(\"This is an example of text justification.\", 16) == ['This    is    an', 'example  of text', 'justification.  ']",
      "assert text_justification(\"Two roads diverged in a yellow wood\", 16) == ['Two        roads', 'diverged   in  a', 'yellow wood     ']"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/jaro_winkler.py",
    "function": "jaro_winkler",
    "bug_type": "no_bug",
    "pl": "def jaro_winkler(str1: str, str2: str) -> float:\n    \"\"\"\n    Jaro-Winkler distance is a string metric measuring an edit distance between two\n    sequences.\n    Output value is between 0.0 and 1.0.\n\n    >>> jaro_winkler(\"martha\", \"marhta\")\n    0.9611111111111111\n    >>> jaro_winkler(\"CRATE\", \"TRACE\")\n    0.7333333333333334\n    >>> jaro_winkler(\"test\", \"dbdbdbdb\")\n    0.0\n    >>> jaro_winkler(\"test\", \"test\")\n    1.0\n    >>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n    0.6363636363636364\n    >>> jaro_winkler(\"test\", \"\")\n    0.0\n    >>> jaro_winkler(\"hello\", \"world\")\n    0.4666666666666666\n    >>> jaro_winkler(\"hell**o\", \"*world\")\n    0.4365079365079365\n    \"\"\"\n\n    def get_matched_characters(_str1: str, _str2: str) -> str:\n        matched = []\n        limit = min(len(_str1), len(_str2)) // 2\n        for i, char in enumerate(_str1):\n            left = int(max(0, i - limit))\n            right = int(min(i + limit + 1, len(_str2)))\n            if char in _str2[left:right]:\n                matched.append(char)\n                _str2 = (\n                    f\"{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}\"\n                )\n\n        return \"\".join(matched)\n\n    # matching characters\n    matching_1 = get_matched_characters(str1, str2)\n    matching_2 = get_matched_characters(str2, str1)\n    match_count = len(matching_1)\n\n    # transposition\n    transpositions = (\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\n    )\n\n    if not match_count:\n        jaro = 0.0\n    else:\n        jaro = (\n            1\n            / 3\n            * (\n                match_count / len(str1)\n                + match_count / len(str2)\n                + (match_count - transpositions) / match_count\n            )\n        )\n\n    # common prefix up to 4 characters\n    prefix_len = 0\n    for c1, c2 in zip(str1[:4], str2[:4]):\n        if c1 == c2:\n            prefix_len += 1\n        else:\n            break\n\n    return jaro + 0.1 * prefix_len * (1 - jaro)",
    "fixed_code": "def jaro_winkler(str1: str, str2: str) -> float:\n    \"\"\"\n    Jaro-Winkler distance is a string metric measuring an edit distance between two\n    sequences.\n    Output value is between 0.0 and 1.0.\n\n    >>> jaro_winkler(\"martha\", \"marhta\")\n    0.9611111111111111\n    >>> jaro_winkler(\"CRATE\", \"TRACE\")\n    0.7333333333333334\n    >>> jaro_winkler(\"test\", \"dbdbdbdb\")\n    0.0\n    >>> jaro_winkler(\"test\", \"test\")\n    1.0\n    >>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n    0.6363636363636364\n    >>> jaro_winkler(\"test\", \"\")\n    0.0\n    >>> jaro_winkler(\"hello\", \"world\")\n    0.4666666666666666\n    >>> jaro_winkler(\"hell**o\", \"*world\")\n    0.4365079365079365\n    \"\"\"\n\n    def get_matched_characters(_str1: str, _str2: str) -> str:\n        matched = []\n        limit = min(len(_str1), len(_str2)) // 2\n        for i, char in enumerate(_str1):\n            left = int(max(0, i - limit))\n            right = int(min(i + limit + 1, len(_str2)))\n            if char in _str2[left:right]:\n                matched.append(char)\n                _str2 = (\n                    f\"{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}\"\n                )\n\n        return \"\".join(matched)\n\n    # matching characters\n    matching_1 = get_matched_characters(str1, str2)\n    matching_2 = get_matched_characters(str2, str1)\n    match_count = len(matching_1)\n\n    # transposition\n    transpositions = (\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\n    )\n\n    if not match_count:\n        jaro = 0.0\n    else:\n        jaro = (\n            1\n            / 3\n            * (\n                match_count / len(str1)\n                + match_count / len(str2)\n                + (match_count - transpositions) / match_count\n            )\n        )\n\n    # common prefix up to 4 characters\n    prefix_len = 0\n    for c1, c2 in zip(str1[:4], str2[:4]):\n        if c1 == c2:\n            prefix_len += 1\n        else:\n            break\n\n    return jaro + 0.1 * prefix_len * (1 - jaro)",
    "tests": [
      "assert jaro_winkler(\"martha\", \"marhta\") == 0.9611111111111111",
      "assert jaro_winkler(\"CRATE\", \"TRACE\") == 0.7333333333333334",
      "assert jaro_winkler(\"test\", \"dbdbdbdb\") == 0.0",
      "assert jaro_winkler(\"test\", \"test\") == 1.0",
      "assert jaro_winkler(\"hello world\", \"HeLLo W0rlD\") == 0.6363636363636364",
      "assert jaro_winkler(\"test\", \"\") == 0.0",
      "assert jaro_winkler(\"hello\", \"world\") == 0.4666666666666666",
      "assert jaro_winkler(\"hell**o\", \"*world\") == 0.4365079365079365"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/wave_string.py",
    "function": "wave",
    "bug_type": "no_bug",
    "pl": "def wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]",
    "fixed_code": "def wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]",
    "tests": [
      "assert wave('cat') == ['Cat', 'cAt', 'caT']",
      "assert wave('one') == ['One', 'oNe', 'onE']",
      "assert wave('book') == ['Book', 'bOok', 'boOk', 'booK']"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/lower.py",
    "function": "lower",
    "bug_type": "no_bug",
    "pl": "def lower(word: str) -> str:\n    \"\"\"\n    Will convert the entire string to lowercase letters\n\n    >>> lower(\"wow\")\n    'wow'\n    >>> lower(\"HellZo\")\n    'hellzo'\n    >>> lower(\"WHAT\")\n    'what'\n    >>> lower(\"wh[]32\")\n    'wh[]32'\n    >>> lower(\"whAT\")\n    'what'\n    \"\"\"\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)",
    "fixed_code": "def lower(word: str) -> str:\n    \"\"\"\n    Will convert the entire string to lowercase letters\n\n    >>> lower(\"wow\")\n    'wow'\n    >>> lower(\"HellZo\")\n    'hellzo'\n    >>> lower(\"WHAT\")\n    'what'\n    >>> lower(\"wh[]32\")\n    'wh[]32'\n    >>> lower(\"whAT\")\n    'what'\n    \"\"\"\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)",
    "tests": [
      "assert lower(\"wow\") == 'wow'",
      "assert lower(\"HellZo\") == 'hellzo'",
      "assert lower(\"WHAT\") == 'what'",
      "assert lower(\"wh[]32\") == 'wh[]32'",
      "assert lower(\"whAT\") == 'what'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/pig_latin.py",
    "function": "pig_latin",
    "bug_type": "no_bug",
    "pl": "def pig_latin(word: str) -> str:\n    \"\"\"Compute the piglatin of a given string.\n\n    https://en.wikipedia.org/wiki/Pig_Latin\n\n    Usage examples:\n    >>> pig_latin(\"pig\")\n    'igpay'\n    >>> pig_latin(\"latin\")\n    'atinlay'\n    >>> pig_latin(\"banana\")\n    'ananabay'\n    >>> pig_latin(\"friends\")\n    'iendsfray'\n    >>> pig_latin(\"smile\")\n    'ilesmay'\n    >>> pig_latin(\"string\")\n    'ingstray'\n    >>> pig_latin(\"eat\")\n    'eatway'\n    >>> pig_latin(\"omelet\")\n    'omeletway'\n    >>> pig_latin(\"are\")\n    'areway'\n    >>> pig_latin(\" \")\n    ''\n    >>> pig_latin(None)\n    ''\n    \"\"\"\n    if not (word or \"\").strip():\n        return \"\"\n    word = word.lower()\n    if word[0] in \"aeiou\":\n        return f\"{word}way\"\n    for i, char in enumerate(word):  # noqa: B007\n        if char in \"aeiou\":\n            break\n    return f\"{word[i:]}{word[:i]}ay\"",
    "fixed_code": "def pig_latin(word: str) -> str:\n    \"\"\"Compute the piglatin of a given string.\n\n    https://en.wikipedia.org/wiki/Pig_Latin\n\n    Usage examples:\n    >>> pig_latin(\"pig\")\n    'igpay'\n    >>> pig_latin(\"latin\")\n    'atinlay'\n    >>> pig_latin(\"banana\")\n    'ananabay'\n    >>> pig_latin(\"friends\")\n    'iendsfray'\n    >>> pig_latin(\"smile\")\n    'ilesmay'\n    >>> pig_latin(\"string\")\n    'ingstray'\n    >>> pig_latin(\"eat\")\n    'eatway'\n    >>> pig_latin(\"omelet\")\n    'omeletway'\n    >>> pig_latin(\"are\")\n    'areway'\n    >>> pig_latin(\" \")\n    ''\n    >>> pig_latin(None)\n    ''\n    \"\"\"\n    if not (word or \"\").strip():\n        return \"\"\n    word = word.lower()\n    if word[0] in \"aeiou\":\n        return f\"{word}way\"\n    for i, char in enumerate(word):  # noqa: B007\n        if char in \"aeiou\":\n            break\n    return f\"{word[i:]}{word[:i]}ay\"",
    "tests": [
      "assert pig_latin(\"pig\") == 'igpay'",
      "assert pig_latin(\"latin\") == 'atinlay'",
      "assert pig_latin(\"banana\") == 'ananabay'",
      "assert pig_latin(\"friends\") == 'iendsfray'",
      "assert pig_latin(\"smile\") == 'ilesmay'",
      "assert pig_latin(\"string\") == 'ingstray'",
      "assert pig_latin(\"eat\") == 'eatway'",
      "assert pig_latin(\"omelet\") == 'omeletway'",
      "assert pig_latin(\"are\") == 'areway'",
      "assert pig_latin(\" \") == ''",
      "assert pig_latin(None) == ''"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/levenshtein_distance.py",
    "function": "levenshtein_distance",
    "bug_type": "no_bug",
    "pl": "def levenshtein_distance(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Implementation of the Levenshtein distance in Python.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance(\"\", \"test\")\n    4\n    >>> levenshtein_distance(\"book\", \"back\")\n    2\n    >>> levenshtein_distance(\"book\", \"book\")\n    0\n    >>> levenshtein_distance(\"test\", \"\")\n    4\n    >>> levenshtein_distance(\"\", \"\")\n    0\n    >>> levenshtein_distance(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    # The longer word should come first\n    if len(first_word) < len(second_word):\n        return levenshtein_distance(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1]\n\n        for j, c2 in enumerate(second_word):\n            # Calculate insertions, deletions, and substitutions\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n\n            # Get the minimum to append to the current row\n            current_row.append(min(insertions, deletions, substitutions))\n\n        # Store the previous row\n        previous_row = current_row\n\n    # Returns the last element (distance)\n    return previous_row[-1]",
    "fixed_code": "def levenshtein_distance(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Implementation of the Levenshtein distance in Python.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance(\"\", \"test\")\n    4\n    >>> levenshtein_distance(\"book\", \"back\")\n    2\n    >>> levenshtein_distance(\"book\", \"book\")\n    0\n    >>> levenshtein_distance(\"test\", \"\")\n    4\n    >>> levenshtein_distance(\"\", \"\")\n    0\n    >>> levenshtein_distance(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    # The longer word should come first\n    if len(first_word) < len(second_word):\n        return levenshtein_distance(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1]\n\n        for j, c2 in enumerate(second_word):\n            # Calculate insertions, deletions, and substitutions\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n\n            # Get the minimum to append to the current row\n            current_row.append(min(insertions, deletions, substitutions))\n\n        # Store the previous row\n        previous_row = current_row\n\n    # Returns the last element (distance)\n    return previous_row[-1]",
    "tests": [
      "assert levenshtein_distance(\"planet\", \"planetary\") == 3",
      "assert levenshtein_distance(\"\", \"test\") == 4",
      "assert levenshtein_distance(\"book\", \"back\") == 2",
      "assert levenshtein_distance(\"book\", \"book\") == 0",
      "assert levenshtein_distance(\"test\", \"\") == 4",
      "assert levenshtein_distance(\"\", \"\") == 0",
      "assert levenshtein_distance(\"orchestration\", \"container\") == 10"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/levenshtein_distance.py",
    "function": "levenshtein_distance_optimized",
    "bug_type": "no_bug",
    "pl": "def levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]",
    "fixed_code": "def levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]",
    "tests": [
      "assert levenshtein_distance_optimized(\"planet\", \"planetary\") == 3",
      "assert levenshtein_distance_optimized(\"\", \"test\") == 4",
      "assert levenshtein_distance_optimized(\"book\", \"back\") == 2",
      "assert levenshtein_distance_optimized(\"book\", \"book\") == 0",
      "assert levenshtein_distance_optimized(\"test\", \"\") == 4",
      "assert levenshtein_distance_optimized(\"\", \"\") == 0",
      "assert levenshtein_distance_optimized(\"orchestration\", \"container\") == 10"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/upper.py",
    "function": "upper",
    "bug_type": "no_bug",
    "pl": "def upper(word: str) -> str:\n    \"\"\"\n    Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII\n    letters and subtracting 32 from their integer representation to get the uppercase\n    letter.\n\n    >>> upper(\"wow\")\n    'WOW'\n    >>> upper(\"Hello\")\n    'HELLO'\n    >>> upper(\"WHAT\")\n    'WHAT'\n    >>> upper(\"wh[]32\")\n    'WH[]32'\n    \"\"\"\n    return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)",
    "fixed_code": "def upper(word: str) -> str:\n    \"\"\"\n    Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII\n    letters and subtracting 32 from their integer representation to get the uppercase\n    letter.\n\n    >>> upper(\"wow\")\n    'WOW'\n    >>> upper(\"Hello\")\n    'HELLO'\n    >>> upper(\"WHAT\")\n    'WHAT'\n    >>> upper(\"wh[]32\")\n    'WH[]32'\n    \"\"\"\n    return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)",
    "tests": [
      "assert upper(\"wow\") == 'WOW'",
      "assert upper(\"Hello\") == 'HELLO'",
      "assert upper(\"WHAT\") == 'WHAT'",
      "assert upper(\"wh[]32\") == 'WH[]32'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/alternative_string_arrange.py",
    "function": "alternative_string_arrange",
    "bug_type": "no_bug",
    "pl": "def alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)",
    "fixed_code": "def alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)",
    "tests": [
      "assert alternative_string_arrange(\"ABCD\", \"XY\") == 'AXBYCD'",
      "assert alternative_string_arrange(\"XY\", \"ABCD\") == 'XAYBCD'",
      "assert alternative_string_arrange(\"AB\", \"XYZ\") == 'AXBYZ'",
      "assert alternative_string_arrange(\"ABC\", \"\") == 'ABC'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/is_pangram.py",
    "function": "is_pangram",
    "bug_type": "no_bug",
    "pl": "def is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    A Pangram String contains all the alphabets at least once.\n    >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram(\"My name is Unknown\")\n    False\n    >>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram()\n    True\n    \"\"\"\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26",
    "fixed_code": "def is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    A Pangram String contains all the alphabets at least once.\n    >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram(\"My name is Unknown\")\n    False\n    >>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram()\n    True\n    \"\"\"\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26",
    "tests": [
      "assert is_pangram(\"The quick brown fox jumps over the lazy dog\") == True",
      "assert is_pangram(\"Waltz, bad nymph, for quick jigs vex.\") == True",
      "assert is_pangram(\"Jived fox nymph grabs quick waltz.\") == True",
      "assert is_pangram(\"My name is Unknown\") == False",
      "assert is_pangram(\"The quick brown fox jumps over the la_y dog\") == False",
      "assert is_pangram() == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/is_pangram.py",
    "function": "is_pangram_faster",
    "bug_type": "no_bug",
    "pl": "def is_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)",
    "fixed_code": "def is_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)",
    "tests": [
      "assert is_pangram_faster(\"The quick brown fox jumps over the lazy dog\") == True",
      "assert is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\") == True",
      "assert is_pangram_faster(\"Jived fox nymph grabs quick waltz.\") == True",
      "assert is_pangram_faster(\"The quick brown fox jumps over the la_y dog\") == False",
      "assert is_pangram_faster() == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/is_pangram.py",
    "function": "is_pangram_fastest",
    "bug_type": "no_bug",
    "pl": "def is_pangram_fastest(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_fastest()\n    True\n    \"\"\"\n    return len({char for char in input_str.lower() if char.isalpha()}) == 26",
    "fixed_code": "def is_pangram_fastest(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_fastest()\n    True\n    \"\"\"\n    return len({char for char in input_str.lower() if char.isalpha()}) == 26",
    "tests": [
      "assert is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\") == True",
      "assert is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\") == True",
      "assert is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\") == True",
      "assert is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\") == False",
      "assert is_pangram_fastest() == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/prefix_function.py",
    "function": "prefix_function",
    "bug_type": "no_bug",
    "pl": "def prefix_function(input_string: str) -> list:\n    \"\"\"\n    For the given string this function computes value for each index(i),\n    which represents the longest coincidence of prefix and suffix\n    for given substring (input_str[0...i])\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> prefix_function(\"aabcdaabc\")\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\n    >>> prefix_function(\"asdasdad\")\n    [0, 0, 0, 1, 2, 3, 4, 0]\n    \"\"\"\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result",
    "fixed_code": "def prefix_function(input_string: str) -> list:\n    \"\"\"\n    For the given string this function computes value for each index(i),\n    which represents the longest coincidence of prefix and suffix\n    for given substring (input_str[0...i])\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> prefix_function(\"aabcdaabc\")\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\n    >>> prefix_function(\"asdasdad\")\n    [0, 0, 0, 1, 2, 3, 4, 0]\n    \"\"\"\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result",
    "tests": [
      "assert prefix_function(\"aabcdaabc\") == [0, 1, 0, 0, 0, 1, 2, 3, 4]",
      "assert prefix_function(\"asdasdad\") == [0, 0, 0, 1, 2, 3, 4, 0]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/naive_string_search.py",
    "function": "naive_pattern_search",
    "bug_type": "no_bug",
    "pl": "def naive_pattern_search(s: str, pattern: str) -> list:\n    \"\"\"\n    >>> naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\")\n    [4, 10, 18]\n    >>> naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\")\n    []\n    >>> naive_pattern_search(\"\", \"ABC\")\n    []\n    >>> naive_pattern_search(\"TEST\", \"TEST\")\n    [0]\n    >>> naive_pattern_search(\"ABCDEGFTEST\", \"TEST\")\n    [7]\n    \"\"\"\n    pat_len = len(pattern)\n    position = []\n    for i in range(len(s) - pat_len + 1):\n        match_found = True\n        for j in range(pat_len):\n            if s[i + j] != pattern[j]:\n                match_found = False\n                break\n        if match_found:\n            position.append(i)\n    return position",
    "fixed_code": "def naive_pattern_search(s: str, pattern: str) -> list:\n    \"\"\"\n    >>> naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\")\n    [4, 10, 18]\n    >>> naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\")\n    []\n    >>> naive_pattern_search(\"\", \"ABC\")\n    []\n    >>> naive_pattern_search(\"TEST\", \"TEST\")\n    [0]\n    >>> naive_pattern_search(\"ABCDEGFTEST\", \"TEST\")\n    [7]\n    \"\"\"\n    pat_len = len(pattern)\n    position = []\n    for i in range(len(s) - pat_len + 1):\n        match_found = True\n        for j in range(pat_len):\n            if s[i + j] != pattern[j]:\n                match_found = False\n                break\n        if match_found:\n            position.append(i)\n    return position",
    "tests": [
      "assert naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\") == [4, 10, 18]",
      "assert naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\") == []",
      "assert naive_pattern_search(\"\", \"ABC\") == []",
      "assert naive_pattern_search(\"TEST\", \"TEST\") == [0]",
      "assert naive_pattern_search(\"ABCDEGFTEST\", \"TEST\") == [7]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/count_vowels.py",
    "function": "count_vowels",
    "bug_type": "no_bug",
    "pl": "def count_vowels(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a given string.\n\n    :param s: Input string to count vowels in.\n    :return: Number of vowels in the input string.\n\n    Examples:\n    >>> count_vowels(\"hello world\")\n    3\n    >>> count_vowels(\"HELLO WORLD\")\n    3\n    >>> count_vowels(\"123 hello world\")\n    3\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a quick brown fox\")\n    5\n    >>> count_vowels(\"the quick BROWN fox\")\n    5\n    >>> count_vowels(\"PYTHON\")\n    1\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)",
    "fixed_code": "def count_vowels(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a given string.\n\n    :param s: Input string to count vowels in.\n    :return: Number of vowels in the input string.\n\n    Examples:\n    >>> count_vowels(\"hello world\")\n    3\n    >>> count_vowels(\"HELLO WORLD\")\n    3\n    >>> count_vowels(\"123 hello world\")\n    3\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a quick brown fox\")\n    5\n    >>> count_vowels(\"the quick BROWN fox\")\n    5\n    >>> count_vowels(\"PYTHON\")\n    1\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)",
    "tests": [
      "assert count_vowels(\"hello world\") == 3",
      "assert count_vowels(\"HELLO WORLD\") == 3",
      "assert count_vowels(\"123 hello world\") == 3",
      "assert count_vowels(\"\") == 0",
      "assert count_vowels(\"a quick brown fox\") == 5",
      "assert count_vowels(\"the quick BROWN fox\") == 5",
      "assert count_vowels(\"PYTHON\") == 1"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/ngram.py",
    "function": "create_ngram",
    "bug_type": "no_bug",
    "pl": "def create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]",
    "fixed_code": "def create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]",
    "tests": [
      "assert create_ngram(\"I am a sentence\", 2) == ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']",
      "assert create_ngram(\"I am an NLPer\", 2) == ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']",
      "assert create_ngram(\"This is short\", 50) == []"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/bitap_string_match.py",
    "function": "bitap_string_match",
    "bug_type": "no_bug",
    "pl": "def bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1",
    "fixed_code": "def bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1",
    "tests": [
      "assert bitap_string_match('abdabababc', 'ababc') == 5",
      "assert bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a') == 0",
      "assert bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso') == 0",
      "assert bitap_string_match('abdabababc', '') == 0",
      "assert bitap_string_match('abdabababc', 'c') == 9",
      "assert bitap_string_match('abdabababc', 'fofosdfo') == -1",
      "assert bitap_string_match('abdab', 'fofosdfo') == -1"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/manacher.py",
    "function": "palindromic_string",
    "bug_type": "no_bug",
    "pl": "def palindromic_string(input_string: str) -> str:\n    \"\"\"\n    >>> palindromic_string('abbbaba')\n    'abbba'\n    >>> palindromic_string('ababa')\n    'ababa'\n\n    Manacher's algorithm which finds Longest palindromic Substring in linear time.\n\n    1. first this convert input_string(\"xyx\") into new_string(\"x|y|x\") where odd\n        positions are actual input characters.\n    2. for each character in new_string it find corresponding length and\n        store the length and left,right to store previously calculated info.\n        (please look the explanation for details)\n\n    3. return corresponding output_string by removing all \"|\"\n    \"\"\"\n    max_length = 0\n\n    # if input_string is \"aba\" than new_input_string become \"a|b|a\"\n    new_input_string = \"\"\n    output_string = \"\"\n\n    # append each character + \"|\" in new_string for range(0, length-1)\n    for i in input_string[: len(input_string) - 1]:\n        new_input_string += i + \"|\"\n    # append last character\n    new_input_string += input_string[-1]\n\n    # we will store the starting and ending of previous furthest ending palindromic\n    # substring\n    left, right = 0, 0\n\n    # length[i] shows the length of palindromic substring with center i\n    length = [1 for i in range(len(new_input_string))]\n\n    # for each character in new_string find corresponding palindromic string\n    start = 0\n    for j in range(len(new_input_string)):\n        k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)\n        while (\n            j - k >= 0\n            and j + k < len(new_input_string)\n            and new_input_string[k + j] == new_input_string[j - k]\n        ):\n            k += 1\n\n        length[j] = 2 * k - 1\n\n        # does this string is ending after the previously explored end (that is right) ?\n        # if yes the update the new right to the last index of this\n        if j + k - 1 > right:\n            left = j - k + 1\n            right = j + k - 1\n\n        # update max_length and start position\n        if max_length < length[j]:\n            max_length = length[j]\n            start = j\n\n    # create that string\n    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]\n    for i in s:\n        if i != \"|\":\n            output_string += i\n\n    return output_string",
    "fixed_code": "def palindromic_string(input_string: str) -> str:\n    \"\"\"\n    >>> palindromic_string('abbbaba')\n    'abbba'\n    >>> palindromic_string('ababa')\n    'ababa'\n\n    Manacher's algorithm which finds Longest palindromic Substring in linear time.\n\n    1. first this convert input_string(\"xyx\") into new_string(\"x|y|x\") where odd\n        positions are actual input characters.\n    2. for each character in new_string it find corresponding length and\n        store the length and left,right to store previously calculated info.\n        (please look the explanation for details)\n\n    3. return corresponding output_string by removing all \"|\"\n    \"\"\"\n    max_length = 0\n\n    # if input_string is \"aba\" than new_input_string become \"a|b|a\"\n    new_input_string = \"\"\n    output_string = \"\"\n\n    # append each character + \"|\" in new_string for range(0, length-1)\n    for i in input_string[: len(input_string) - 1]:\n        new_input_string += i + \"|\"\n    # append last character\n    new_input_string += input_string[-1]\n\n    # we will store the starting and ending of previous furthest ending palindromic\n    # substring\n    left, right = 0, 0\n\n    # length[i] shows the length of palindromic substring with center i\n    length = [1 for i in range(len(new_input_string))]\n\n    # for each character in new_string find corresponding palindromic string\n    start = 0\n    for j in range(len(new_input_string)):\n        k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)\n        while (\n            j - k >= 0\n            and j + k < len(new_input_string)\n            and new_input_string[k + j] == new_input_string[j - k]\n        ):\n            k += 1\n\n        length[j] = 2 * k - 1\n\n        # does this string is ending after the previously explored end (that is right) ?\n        # if yes the update the new right to the last index of this\n        if j + k - 1 > right:\n            left = j - k + 1\n            right = j + k - 1\n\n        # update max_length and start position\n        if max_length < length[j]:\n            max_length = length[j]\n            start = j\n\n    # create that string\n    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]\n    for i in s:\n        if i != \"|\":\n            output_string += i\n\n    return output_string",
    "tests": [
      "assert palindromic_string('abbbaba') == 'abbba'",
      "assert palindromic_string('ababa') == 'ababa'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/damerau_levenshtein_distance.py",
    "function": "damerau_levenshtein_distance",
    "bug_type": "no_bug",
    "pl": "def damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    \"\"\"\n    Implements the Damerau-Levenshtein distance algorithm that measures\n    the edit distance between two strings.\n\n    Parameters:\n        first_string: The first string to compare\n        second_string: The second string to compare\n\n    Returns:\n        distance: The edit distance between the first and second strings\n\n    >>> damerau_levenshtein_distance(\"cat\", \"cut\")\n    1\n    >>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n    3\n    >>> damerau_levenshtein_distance(\"hello\", \"world\")\n    4\n    >>> damerau_levenshtein_distance(\"book\", \"back\")\n    2\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    \"\"\"\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]",
    "fixed_code": "def damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    \"\"\"\n    Implements the Damerau-Levenshtein distance algorithm that measures\n    the edit distance between two strings.\n\n    Parameters:\n        first_string: The first string to compare\n        second_string: The second string to compare\n\n    Returns:\n        distance: The edit distance between the first and second strings\n\n    >>> damerau_levenshtein_distance(\"cat\", \"cut\")\n    1\n    >>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n    3\n    >>> damerau_levenshtein_distance(\"hello\", \"world\")\n    4\n    >>> damerau_levenshtein_distance(\"book\", \"back\")\n    2\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    \"\"\"\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]",
    "tests": [
      "assert damerau_levenshtein_distance(\"cat\", \"cut\") == 1",
      "assert damerau_levenshtein_distance(\"kitten\", \"sitting\") == 3",
      "assert damerau_levenshtein_distance(\"hello\", \"world\") == 4",
      "assert damerau_levenshtein_distance(\"book\", \"back\") == 2",
      "assert damerau_levenshtein_distance(\"container\", \"containment\") == 3",
      "assert damerau_levenshtein_distance(\"container\", \"containment\") == 3"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/title.py",
    "function": "to_title_case",
    "bug_type": "no_bug",
    "pl": "def to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word",
    "fixed_code": "def to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word",
    "tests": [
      "assert to_title_case(\"Aakash\") == 'Aakash'",
      "assert to_title_case(\"aakash\") == 'Aakash'",
      "assert to_title_case(\"AAKASH\") == 'Aakash'",
      "assert to_title_case(\"aAkAsH\") == 'Aakash'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/wildcard_pattern_matching.py",
    "function": "match_pattern",
    "bug_type": "no_bug",
    "pl": "def match_pattern(input_string: str, pattern: str) -> bool:\n    \"\"\"\n    uses bottom-up dynamic programming solution for matching the input\n    string with a given pattern.\n\n    Runtime: O(len(input_string)*len(pattern))\n\n    Arguments\n    --------\n    input_string: str, any string which should be compared with the pattern\n    pattern: str, the string that represents a pattern and may contain\n    '.' for single character matches and '*' for zero or more of preceding character\n    matches\n\n    Note\n    ----\n    the pattern cannot start with a '*',\n    because there should be at least one character before *\n\n    Returns\n    -------\n    A Boolean denoting whether the given string follows the pattern\n\n    Examples\n    -------\n    >>> match_pattern(\"aab\", \"c*a*b\")\n    True\n    >>> match_pattern(\"dabc\", \"*abc\")\n    False\n    >>> match_pattern(\"aaa\", \"aa\")\n    False\n    >>> match_pattern(\"aaa\", \"a.a\")\n    True\n    >>> match_pattern(\"aaab\", \"aa*\")\n    False\n    >>> match_pattern(\"aaab\", \".*\")\n    True\n    >>> match_pattern(\"a\", \"bbbb\")\n    False\n    >>> match_pattern(\"\", \"bbbb\")\n    False\n    >>> match_pattern(\"a\", \"\")\n    False\n    >>> match_pattern(\"\", \"\")\n    True\n    \"\"\"\n\n    len_string = len(input_string) + 1\n    len_pattern = len(pattern) + 1\n\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\n    # length i of input_string matches with prefix string of length j of\n    # given pattern.\n    # \"dp\" stands for dynamic programming.\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\n\n    # since string of zero length match pattern of zero length\n    dp[0][0] = 1\n\n    # since pattern of zero length will never match with string of non-zero length\n    for i in range(1, len_string):\n        dp[i][0] = 0\n\n    # since string of zero length will match with pattern where there\n    # is at least one * alternatively\n    for j in range(1, len_pattern):\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \"*\" else 0\n\n    # now using bottom-up approach to find for all remaining lengths\n    for i in range(1, len_string):\n        for j in range(1, len_pattern):\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \".\":\n                dp[i][j] = dp[i - 1][j - 1]\n\n            elif pattern[j - 1] == \"*\":\n                if dp[i][j - 2] == 1:\n                    dp[i][j] = 1\n                elif pattern[j - 2] in (input_string[i - 1], \".\"):\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n\n    return bool(dp[-1][-1])",
    "fixed_code": "def match_pattern(input_string: str, pattern: str) -> bool:\n    \"\"\"\n    uses bottom-up dynamic programming solution for matching the input\n    string with a given pattern.\n\n    Runtime: O(len(input_string)*len(pattern))\n\n    Arguments\n    --------\n    input_string: str, any string which should be compared with the pattern\n    pattern: str, the string that represents a pattern and may contain\n    '.' for single character matches and '*' for zero or more of preceding character\n    matches\n\n    Note\n    ----\n    the pattern cannot start with a '*',\n    because there should be at least one character before *\n\n    Returns\n    -------\n    A Boolean denoting whether the given string follows the pattern\n\n    Examples\n    -------\n    >>> match_pattern(\"aab\", \"c*a*b\")\n    True\n    >>> match_pattern(\"dabc\", \"*abc\")\n    False\n    >>> match_pattern(\"aaa\", \"aa\")\n    False\n    >>> match_pattern(\"aaa\", \"a.a\")\n    True\n    >>> match_pattern(\"aaab\", \"aa*\")\n    False\n    >>> match_pattern(\"aaab\", \".*\")\n    True\n    >>> match_pattern(\"a\", \"bbbb\")\n    False\n    >>> match_pattern(\"\", \"bbbb\")\n    False\n    >>> match_pattern(\"a\", \"\")\n    False\n    >>> match_pattern(\"\", \"\")\n    True\n    \"\"\"\n\n    len_string = len(input_string) + 1\n    len_pattern = len(pattern) + 1\n\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\n    # length i of input_string matches with prefix string of length j of\n    # given pattern.\n    # \"dp\" stands for dynamic programming.\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\n\n    # since string of zero length match pattern of zero length\n    dp[0][0] = 1\n\n    # since pattern of zero length will never match with string of non-zero length\n    for i in range(1, len_string):\n        dp[i][0] = 0\n\n    # since string of zero length will match with pattern where there\n    # is at least one * alternatively\n    for j in range(1, len_pattern):\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \"*\" else 0\n\n    # now using bottom-up approach to find for all remaining lengths\n    for i in range(1, len_string):\n        for j in range(1, len_pattern):\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \".\":\n                dp[i][j] = dp[i - 1][j - 1]\n\n            elif pattern[j - 1] == \"*\":\n                if dp[i][j - 2] == 1:\n                    dp[i][j] = 1\n                elif pattern[j - 2] in (input_string[i - 1], \".\"):\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n\n    return bool(dp[-1][-1])",
    "tests": [
      "assert match_pattern(\"aab\", \"c*a*b\") == True",
      "assert match_pattern(\"dabc\", \"*abc\") == False",
      "assert match_pattern(\"aaa\", \"aa\") == False",
      "assert match_pattern(\"aaa\", \"a.a\") == True",
      "assert match_pattern(\"aaab\", \"aa*\") == False",
      "assert match_pattern(\"aaab\", \".*\") == True",
      "assert match_pattern(\"a\", \"bbbb\") == False",
      "assert match_pattern(\"\", \"bbbb\") == False",
      "assert match_pattern(\"a\", \"\") == False",
      "assert match_pattern(\"\", \"\") == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/strip.py",
    "function": "strip",
    "bug_type": "no_bug",
    "pl": "def strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]",
    "fixed_code": "def strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]",
    "tests": [
      "assert strip(\"   hello   \") == 'hello'",
      "assert strip(\"...world...\", \".\") == 'world'",
      "assert strip(\"123hello123\", \"123\") == 'hello'",
      "assert strip(\"\") == ''"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/credit_card_validator.py",
    "function": "luhn_validation",
    "bug_type": "no_bug",
    "pl": "def luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0",
    "fixed_code": "def luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0",
    "tests": [
      "assert luhn_validation('4111111111111111') == True",
      "assert luhn_validation('36111111111111') == True",
      "assert luhn_validation('41111111111111') == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/barcode_validator.py",
    "function": "get_check_digit",
    "bug_type": "no_bug",
    "pl": "def get_check_digit(barcode: int) -> int:\n    \"\"\"\n    Returns the last digit of barcode by excluding the last digit first\n    and then computing to reach the actual last digit from the remaining\n    12 digits.\n\n    >>> get_check_digit(8718452538119)\n    9\n    >>> get_check_digit(87184523)\n    5\n    >>> get_check_digit(87193425381086)\n    9\n    >>> [get_check_digit(x) for x in range(0, 100, 10)]\n    [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]\n    \"\"\"\n    barcode //= 10  # exclude the last digit\n    checker = False\n    s = 0\n\n    # extract and check each digit\n    while barcode != 0:\n        mult = 1 if checker else 3\n        s += mult * (barcode % 10)\n        barcode //= 10\n        checker = not checker\n\n    return (10 - (s % 10)) % 10",
    "fixed_code": "def get_check_digit(barcode: int) -> int:\n    \"\"\"\n    Returns the last digit of barcode by excluding the last digit first\n    and then computing to reach the actual last digit from the remaining\n    12 digits.\n\n    >>> get_check_digit(8718452538119)\n    9\n    >>> get_check_digit(87184523)\n    5\n    >>> get_check_digit(87193425381086)\n    9\n    >>> [get_check_digit(x) for x in range(0, 100, 10)]\n    [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]\n    \"\"\"\n    barcode //= 10  # exclude the last digit\n    checker = False\n    s = 0\n\n    # extract and check each digit\n    while barcode != 0:\n        mult = 1 if checker else 3\n        s += mult * (barcode % 10)\n        barcode //= 10\n        checker = not checker\n\n    return (10 - (s % 10)) % 10",
    "tests": [
      "assert get_check_digit(8718452538119) == 9",
      "assert get_check_digit(87184523) == 5",
      "assert get_check_digit(87193425381086) == 9",
      "assert [get_check_digit(x) for x in range(0, 100, 10)] == [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "strings/edit_distance.py",
    "function": "edit_distance",
    "bug_type": "no_bug",
    "pl": "def edit_distance(source: str, target: str) -> int:\n    \"\"\"\n    Edit distance algorithm is a string metric, i.e., it is a way of quantifying how\n    dissimilar two strings are to one another. It is measured by counting the minimum\n    number of operations required to transform one string into another.\n\n    This implementation assumes that the cost of operations (insertion, deletion and\n    substitution) is always 1\n\n    Args:\n    source: the initial string with respect to which we are calculating the edit\n        distance for the target\n    target: the target string, formed after performing n operations on the source string\n\n    >>> edit_distance(\"GATTIC\", \"GALTIC\")\n    1\n    >>> edit_distance(\"NUM3\", \"HUM2\")\n    2\n    >>> edit_distance(\"cap\", \"CAP\")\n    3\n    >>> edit_distance(\"Cat\", \"\")\n    3\n    >>> edit_distance(\"cat\", \"cat\")\n    0\n    >>> edit_distance(\"\", \"123456789\")\n    9\n    >>> edit_distance(\"Be@uty\", \"Beautyyyy!\")\n    5\n    >>> edit_distance(\"lstring\", \"lsstring\")\n    1\n    \"\"\"\n    if len(source) == 0:\n        return len(target)\n    elif len(target) == 0:\n        return len(source)\n\n    delta = int(source[-1] != target[-1])  # Substitution\n    return min(\n        edit_distance(source[:-1], target[:-1]) + delta,\n        edit_distance(source, target[:-1]) + 1,\n        edit_distance(source[:-1], target) + 1,\n    )",
    "fixed_code": "def edit_distance(source: str, target: str) -> int:\n    \"\"\"\n    Edit distance algorithm is a string metric, i.e., it is a way of quantifying how\n    dissimilar two strings are to one another. It is measured by counting the minimum\n    number of operations required to transform one string into another.\n\n    This implementation assumes that the cost of operations (insertion, deletion and\n    substitution) is always 1\n\n    Args:\n    source: the initial string with respect to which we are calculating the edit\n        distance for the target\n    target: the target string, formed after performing n operations on the source string\n\n    >>> edit_distance(\"GATTIC\", \"GALTIC\")\n    1\n    >>> edit_distance(\"NUM3\", \"HUM2\")\n    2\n    >>> edit_distance(\"cap\", \"CAP\")\n    3\n    >>> edit_distance(\"Cat\", \"\")\n    3\n    >>> edit_distance(\"cat\", \"cat\")\n    0\n    >>> edit_distance(\"\", \"123456789\")\n    9\n    >>> edit_distance(\"Be@uty\", \"Beautyyyy!\")\n    5\n    >>> edit_distance(\"lstring\", \"lsstring\")\n    1\n    \"\"\"\n    if len(source) == 0:\n        return len(target)\n    elif len(target) == 0:\n        return len(source)\n\n    delta = int(source[-1] != target[-1])  # Substitution\n    return min(\n        edit_distance(source[:-1], target[:-1]) + delta,\n        edit_distance(source, target[:-1]) + 1,\n        edit_distance(source[:-1], target) + 1,\n    )",
    "tests": [
      "assert edit_distance(\"GATTIC\", \"GALTIC\") == 1",
      "assert edit_distance(\"NUM3\", \"HUM2\") == 2",
      "assert edit_distance(\"cap\", \"CAP\") == 3",
      "assert edit_distance(\"Cat\", \"\") == 3",
      "assert edit_distance(\"cat\", \"cat\") == 0",
      "assert edit_distance(\"\", \"123456789\") == 9",
      "assert edit_distance(\"Be@uty\", \"Beautyyyy!\") == 5",
      "assert edit_distance(\"lstring\", \"lsstring\") == 1"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "conversions/molecular_chemistry.py",
    "function": "molarity_to_normality",
    "bug_type": "no_bug",
    "pl": "def molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\n    \"\"\"\n    Convert molarity to normality.\n      Volume is taken in litres.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n      >>> molarity_to_normality(2, 3.1, 0.31)\n      20\n      >>> molarity_to_normality(4, 11.4, 5.7)\n      8\n    \"\"\"\n    return round(float(moles / volume) * nfactor)",
    "fixed_code": "def molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\n    \"\"\"\n    Convert molarity to normality.\n      Volume is taken in litres.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n      >>> molarity_to_normality(2, 3.1, 0.31)\n      20\n      >>> molarity_to_normality(4, 11.4, 5.7)\n      8\n    \"\"\"\n    return round(float(moles / volume) * nfactor)",
    "tests": [
      "assert molarity_to_normality(2, 3.1, 0.31) == 20",
      "assert molarity_to_normality(4, 11.4, 5.7) == 8"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "conversions/molecular_chemistry.py",
    "function": "moles_to_pressure",
    "bug_type": "no_bug",
    "pl": "def moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to pressure.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_pressure(0.82, 3, 300)\n      90\n      >>> moles_to_pressure(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (volume)))",
    "fixed_code": "def moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to pressure.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_pressure(0.82, 3, 300)\n      90\n      >>> moles_to_pressure(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (volume)))",
    "tests": [
      "assert moles_to_pressure(0.82, 3, 300) == 90",
      "assert moles_to_pressure(8.2, 5, 200) == 10"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "conversions/molecular_chemistry.py",
    "function": "moles_to_volume",
    "bug_type": "no_bug",
    "pl": "def moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to volume.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_volume(0.82, 3, 300)\n      90\n      >>> moles_to_volume(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (pressure)))",
    "fixed_code": "def moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to volume.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_volume(0.82, 3, 300)\n      90\n      >>> moles_to_volume(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (pressure)))",
    "tests": [
      "assert moles_to_volume(0.82, 3, 300) == 90",
      "assert moles_to_volume(8.2, 5, 200) == 10"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "conversions/molecular_chemistry.py",
    "function": "pressure_and_volume_to_temperature",
    "bug_type": "no_bug",
    "pl": "def pressure_and_volume_to_temperature(\n    pressure: float, moles: float, volume: float\n) -> float:\n    \"\"\"\n    Convert pressure and volume to temperature.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> pressure_and_volume_to_temperature(0.82, 1, 2)\n      20\n      >>> pressure_and_volume_to_temperature(8.2, 5, 3)\n      60\n    \"\"\"\n    return round(float((pressure * volume) / (0.0821 * moles)))",
    "fixed_code": "def pressure_and_volume_to_temperature(\n    pressure: float, moles: float, volume: float\n) -> float:\n    \"\"\"\n    Convert pressure and volume to temperature.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> pressure_and_volume_to_temperature(0.82, 1, 2)\n      20\n      >>> pressure_and_volume_to_temperature(8.2, 5, 3)\n      60\n    \"\"\"\n    return round(float((pressure * volume) / (0.0821 * moles)))",
    "tests": [
      "assert pressure_and_volume_to_temperature(0.82, 1, 2) == 20",
      "assert pressure_and_volume_to_temperature(8.2, 5, 3) == 60"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "conversions/excel_title_to_column.py",
    "function": "excel_title_to_column",
    "bug_type": "no_bug",
    "pl": "def excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer",
    "fixed_code": "def excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer",
    "tests": [
      "assert excel_title_to_column(\"A\") == 1",
      "assert excel_title_to_column(\"B\") == 2",
      "assert excel_title_to_column(\"AB\") == 28",
      "assert excel_title_to_column(\"Z\") == 26"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "conversions/rgb_hsv_conversion.py",
    "function": "hsv_to_rgb",
    "bug_type": "no_bug",
    "pl": "def hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]",
    "fixed_code": "def hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]",
    "tests": [
      "assert hsv_to_rgb(0, 0, 0) == [0, 0, 0]",
      "assert hsv_to_rgb(0, 0, 1) == [255, 255, 255]",
      "assert hsv_to_rgb(0, 1, 1) == [255, 0, 0]",
      "assert hsv_to_rgb(60, 1, 1) == [255, 255, 0]",
      "assert hsv_to_rgb(120, 1, 1) == [0, 255, 0]",
      "assert hsv_to_rgb(240, 1, 1) == [0, 0, 255]",
      "assert hsv_to_rgb(300, 1, 1) == [255, 0, 255]",
      "assert hsv_to_rgb(180, 0.5, 0.5) == [64, 128, 128]",
      "assert hsv_to_rgb(234, 0.14, 0.88) == [193, 196, 224]",
      "assert hsv_to_rgb(330, 0.75, 0.5) == [128, 32, 80]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "conversions/rgb_hsv_conversion.py",
    "function": "approximately_equal_hsv",
    "bug_type": "no_bug",
    "pl": "def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value",
    "fixed_code": "def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value",
    "tests": [
      "assert approximately_equal_hsv([0, 0, 0], [0, 0, 0]) == True",
      "assert approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001]) == True",
      "assert approximately_equal_hsv([0, 0, 0], [1, 0, 0]) == False",
      "assert approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001]) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "conversions/ipv4_conversion.py",
    "function": "alt_ipv4_to_decimal",
    "bug_type": "no_bug",
    "pl": "def alt_ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    >>> alt_ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> alt_ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    \"\"\"\n    return int(\"0x\" + \"\".join(f\"{int(i):02x}\" for i in ipv4_address.split(\".\")), 16)",
    "fixed_code": "def alt_ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    >>> alt_ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> alt_ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    \"\"\"\n    return int(\"0x\" + \"\".join(f\"{int(i):02x}\" for i in ipv4_address.split(\".\")), 16)",
    "tests": [
      "assert alt_ipv4_to_decimal(\"192.168.0.1\") == 3232235521",
      "assert alt_ipv4_to_decimal(\"10.0.0.255\") == 167772415"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "conversions/decimal_to_binary.py",
    "function": "decimal_to_binary_iterative",
    "bug_type": "no_bug",
    "pl": "def decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)",
    "fixed_code": "def decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)",
    "tests": [
      "assert decimal_to_binary_iterative(0) == '0b0'",
      "assert decimal_to_binary_iterative(2) == '0b10'",
      "assert decimal_to_binary_iterative(7) == '0b111'",
      "assert decimal_to_binary_iterative(35) == '0b100011'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "greedy_methods/best_time_to_buy_and_sell_stock.py",
    "function": "max_profit",
    "bug_type": "no_bug",
    "pl": "def max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit",
    "fixed_code": "def max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit",
    "tests": [
      "assert max_profit([7, 1, 5, 3, 6, 4]) == 5",
      "assert max_profit([7, 6, 4, 3, 1]) == 0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "greedy_methods/minimum_waiting_time.py",
    "function": "minimum_waiting_time",
    "bug_type": "no_bug",
    "pl": "def minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))",
    "fixed_code": "def minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))",
    "tests": [
      "assert minimum_waiting_time([3, 2, 1, 2, 6]) == 17",
      "assert minimum_waiting_time([3, 2, 1]) == 4",
      "assert minimum_waiting_time([1, 2, 3, 4]) == 10",
      "assert minimum_waiting_time([5, 5, 5, 5]) == 30",
      "assert minimum_waiting_time([]) == 0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "greedy_methods/minimum_coin_change.py",
    "function": "find_minimum_change",
    "bug_type": "no_bug",
    "pl": "def find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer",
    "fixed_code": "def find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer",
    "tests": [
      "assert find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745) == [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]",
      "assert find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987) == [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]",
      "assert find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0) == []",
      "assert find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98) == []",
      "assert find_minimum_change([1, 5, 100, 500, 1000], 456) == [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "greedy_methods/optimal_merge_pattern.py",
    "function": "optimal_merge_pattern",
    "bug_type": "no_bug",
    "pl": "def optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost",
    "fixed_code": "def optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost",
    "tests": [
      "assert optimal_merge_pattern([2, 3, 4]) == 14",
      "assert optimal_merge_pattern([5, 10, 20, 30, 30]) == 205",
      "assert optimal_merge_pattern([8, 8, 8, 8, 8]) == 96"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "genetic_algorithm/basic_string.py",
    "function": "evaluate",
    "bug_type": "no_bug",
    "pl": "def evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))",
    "fixed_code": "def evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))",
    "tests": [
      "assert evaluate(\"Helxo Worlx\", \"Hello World\") == ('Helxo Worlx', 9.0)"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "cellular_automata/nagel_schrekenberg.py",
    "function": "construct_highway",
    "bug_type": "no_bug",
    "pl": "def construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway",
    "fixed_code": "def construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway",
    "tests": [
      "assert construct_highway(10, 2, 6) == [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]",
      "assert construct_highway(10, 10, 2) == [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "cellular_automata/nagel_schrekenberg.py",
    "function": "get_distance",
    "bug_type": "no_bug",
    "pl": "def get_distance(highway_now: list, car_index: int) -> int:\n    \"\"\"\n    Get the distance between a car (at index car_index) and the next car\n    >>> get_distance([6, -1, 6, -1, 6], 2)\n    1\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n    3\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n    4\n    \"\"\"\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)",
    "fixed_code": "def get_distance(highway_now: list, car_index: int) -> int:\n    \"\"\"\n    Get the distance between a car (at index car_index) and the next car\n    >>> get_distance([6, -1, 6, -1, 6], 2)\n    1\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n    3\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n    4\n    \"\"\"\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)",
    "tests": [
      "assert get_distance([6, -1, 6, -1, 6], 2) == 1",
      "assert get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0) == 3",
      "assert get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1) == 4"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "machine_learning/linear_discriminant_analysis.py",
    "function": "y_generator",
    "bug_type": "no_bug",
    "pl": "def y_generator(class_count: int, instance_count: list) -> list:\n    \"\"\"\n    Generate y values for corresponding classes\n    :param class_count: Number of classes(data groupings) in dataset\n    :param instance_count: number of instances in class\n    :return: corresponding values for data groupings in dataset\n\n    >>> y_generator(1, [10])\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    >>> y_generator(2, [5, 10])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    return [k for k in range(class_count) for _ in range(instance_count[k])]",
    "fixed_code": "def y_generator(class_count: int, instance_count: list) -> list:\n    \"\"\"\n    Generate y values for corresponding classes\n    :param class_count: Number of classes(data groupings) in dataset\n    :param instance_count: number of instances in class\n    :return: corresponding values for data groupings in dataset\n\n    >>> y_generator(1, [10])\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    >>> y_generator(2, [5, 10])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    return [k for k in range(class_count) for _ in range(instance_count[k])]",
    "tests": [
      "assert y_generator(1, [10]) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
      "assert y_generator(2, [5, 10]) == [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]",
      "assert y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "machine_learning/linear_discriminant_analysis.py",
    "function": "calculate_probabilities",
    "bug_type": "no_bug",
    "pl": "def calculate_probabilities(instance_count: int, total_count: int) -> float:\n    \"\"\"\n    Calculate the probability that a given instance will belong to which class\n    :param instance_count: number of instances in class\n    :param total_count: the number of all instances\n    :return: value of probability for considered class\n\n    >>> calculate_probabilities(20, 60)\n    0.3333333333333333\n    >>> calculate_probabilities(30, 100)\n    0.3\n    \"\"\"\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count",
    "fixed_code": "def calculate_probabilities(instance_count: int, total_count: int) -> float:\n    \"\"\"\n    Calculate the probability that a given instance will belong to which class\n    :param instance_count: number of instances in class\n    :param total_count: the number of all instances\n    :return: value of probability for considered class\n\n    >>> calculate_probabilities(20, 60)\n    0.3333333333333333\n    >>> calculate_probabilities(30, 100)\n    0.3\n    \"\"\"\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count",
    "tests": [
      "assert calculate_probabilities(20, 60) == 0.3333333333333333",
      "assert calculate_probabilities(30, 100) == 0.3"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "machine_learning/word_frequency_functions.py",
    "function": "tf_idf",
    "bug_type": "no_bug",
    "pl": "def tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)",
    "fixed_code": "def tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)",
    "tests": [
      "assert tf_idf(2, 0.477) == 0.954"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "machine_learning/apriori_algorithm.py",
    "function": "load_data",
    "bug_type": "no_bug",
    "pl": "def load_data() -> list[list[str]]:\n    \"\"\"\n    Returns a sample transaction dataset.\n\n    >>> load_data()\n    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]\n    \"\"\"\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]",
    "fixed_code": "def load_data() -> list[list[str]]:\n    \"\"\"\n    Returns a sample transaction dataset.\n\n    >>> load_data()\n    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]\n    \"\"\"\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]",
    "tests": [
      "assert load_data() == [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "machine_learning/data_transformations.py",
    "function": "normalization",
    "bug_type": "no_bug",
    "pl": "def normalization(data: list, ndigits: int = 3) -> list:\n    \"\"\"\n    Return a normalized list of values.\n\n    @params: data, a list of values to normalize\n    @returns: a list of normalized values (rounded to ndigits decimal places)\n    @examples:\n    >>> normalization([2, 7, 10, 20, 30, 50])\n    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\n    >>> normalization([5, 10, 15, 20, 25])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # variables for calculation\n    x_min = min(data)\n    x_max = max(data)\n    # normalize data\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]",
    "fixed_code": "def normalization(data: list, ndigits: int = 3) -> list:\n    \"\"\"\n    Return a normalized list of values.\n\n    @params: data, a list of values to normalize\n    @returns: a list of normalized values (rounded to ndigits decimal places)\n    @examples:\n    >>> normalization([2, 7, 10, 20, 30, 50])\n    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\n    >>> normalization([5, 10, 15, 20, 25])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # variables for calculation\n    x_min = min(data)\n    x_max = max(data)\n    # normalize data\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]",
    "tests": [
      "assert normalization([2, 7, 10, 20, 30, 50]) == [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]",
      "assert normalization([5, 10, 15, 20, 25]) == [0.0, 0.25, 0.5, 0.75, 1.0]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "machine_learning/mfcc.py",
    "function": "mel_to_freq",
    "bug_type": "no_bug",
    "pl": "def mel_to_freq(mels: float) -> float:\n    \"\"\"\n    Convert a frequency in the mel scale to Hertz.\n\n    Args:\n        mels: The frequency in mel scale.\n\n    Returns:\n        The frequency in Hertz.\n\n    Examples:\n    >>> round(mel_to_freq(999.99), 2)\n    1000.01\n    \"\"\"\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)",
    "fixed_code": "def mel_to_freq(mels: float) -> float:\n    \"\"\"\n    Convert a frequency in the mel scale to Hertz.\n\n    Args:\n        mels: The frequency in mel scale.\n\n    Returns:\n        The frequency in Hertz.\n\n    Examples:\n    >>> round(mel_to_freq(999.99), 2)\n    1000.01\n    \"\"\"\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)",
    "tests": [
      "assert round(mel_to_freq(999.99), 2) == 1000.01"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "fractals/sierpinski_triangle.py",
    "function": "get_mid",
    "bug_type": "no_bug",
    "pl": "def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2",
    "fixed_code": "def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2",
    "tests": [
      "assert get_mid((0, 0), (2, 2)) == (1.0, 1.0)",
      "assert get_mid((-3, -3), (3, 3)) == (0.0, 0.0)",
      "assert get_mid((1, 0), (3, 2)) == (2.0, 1.0)",
      "assert get_mid((0, 0), (1, 1)) == (0.5, 0.5)",
      "assert get_mid((0, 0), (0, 0)) == (0.0, 0.0)"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "fractals/mandelbrot.py",
    "function": "get_black_and_white_rgb",
    "bug_type": "no_bug",
    "pl": "def get_black_and_white_rgb(distance: float) -> tuple:\n    \"\"\"\n    Black&white color-coding that ignores the relative distance. The Mandelbrot\n    set is black, everything else is white.\n\n    >>> get_black_and_white_rgb(0)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(0.5)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return (255, 255, 255)",
    "fixed_code": "def get_black_and_white_rgb(distance: float) -> tuple:\n    \"\"\"\n    Black&white color-coding that ignores the relative distance. The Mandelbrot\n    set is black, everything else is white.\n\n    >>> get_black_and_white_rgb(0)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(0.5)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return (255, 255, 255)",
    "tests": [
      "assert get_black_and_white_rgb(0) == (255, 255, 255)",
      "assert get_black_and_white_rgb(0.5) == (255, 255, 255)",
      "assert get_black_and_white_rgb(1) == (0, 0, 0)"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_104/sol1.py",
    "function": "check1",
    "bug_type": "no_bug",
    "pl": "def check1(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital from END\n\n    >>> check1(123456789987654321)\n    True\n\n    >>> check1(120000987654321)\n    True\n\n    >>> check1(12345678957656779870004321)\n    False\n\n    \"\"\"\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f",
    "fixed_code": "def check1(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital from END\n\n    >>> check1(123456789987654321)\n    True\n\n    >>> check1(120000987654321)\n    True\n\n    >>> check1(12345678957656779870004321)\n    False\n\n    \"\"\"\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f",
    "tests": [
      "assert check1(123456789987654321) == True",
      "assert check1(120000987654321) == True",
      "assert check1(12345678957656779870004321) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_047/sol1.py",
    "function": "unique_prime_factors",
    "bug_type": "no_bug",
    "pl": "def unique_prime_factors(n: int) -> set:\n    \"\"\"\n    Find unique prime factors of an integer.\n    Tests include sorting because only the set matters,\n    not the order in which it is produced.\n    >>> sorted(set(unique_prime_factors(14)))\n    [2, 7]\n    >>> sorted(set(unique_prime_factors(644)))\n    [2, 7, 23]\n    >>> sorted(set(unique_prime_factors(646)))\n    [2, 17, 19]\n    \"\"\"\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors",
    "fixed_code": "def unique_prime_factors(n: int) -> set:\n    \"\"\"\n    Find unique prime factors of an integer.\n    Tests include sorting because only the set matters,\n    not the order in which it is produced.\n    >>> sorted(set(unique_prime_factors(14)))\n    [2, 7]\n    >>> sorted(set(unique_prime_factors(644)))\n    [2, 7, 23]\n    >>> sorted(set(unique_prime_factors(646)))\n    [2, 17, 19]\n    \"\"\"\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors",
    "tests": [
      "assert sorted(set(unique_prime_factors(14))) == [2, 7]",
      "assert sorted(set(unique_prime_factors(644))) == [2, 7, 23]",
      "assert sorted(set(unique_prime_factors(646))) == [2, 17, 19]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_047/sol1.py",
    "function": "equality",
    "bug_type": "no_bug",
    "pl": "def equality(iterable: list) -> bool:\n    \"\"\"\n    Check the equality of ALL elements in an iterable\n    >>> equality([1, 2, 3, 4])\n    False\n    >>> equality([2, 2, 2, 2])\n    True\n    >>> equality([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    return len(set(iterable)) in (0, 1)",
    "fixed_code": "def equality(iterable: list) -> bool:\n    \"\"\"\n    Check the equality of ALL elements in an iterable\n    >>> equality([1, 2, 3, 4])\n    False\n    >>> equality([2, 2, 2, 2])\n    True\n    >>> equality([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    return len(set(iterable)) in (0, 1)",
    "tests": [
      "assert equality([1, 2, 3, 4]) == False",
      "assert equality([2, 2, 2, 2]) == True",
      "assert equality([1, 2, 3, 2, 1]) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_025/sol1.py",
    "function": "fibonacci",
    "bug_type": "no_bug",
    "pl": "def fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]",
    "fixed_code": "def fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]",
    "tests": [
      "assert fibonacci(2) == 1",
      "assert fibonacci(3) == 2",
      "assert fibonacci(5) == 5",
      "assert fibonacci(10) == 55",
      "assert fibonacci(12) == 144"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_062/sol1.py",
    "function": "get_digits",
    "bug_type": "no_bug",
    "pl": "def get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))",
    "fixed_code": "def get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))",
    "tests": [
      "assert get_digits(3) == '27'",
      "assert get_digits(99) == '027999'",
      "assert get_digits(123) == '0166788'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_055/sol1.py",
    "function": "sum_reverse",
    "bug_type": "no_bug",
    "pl": "def sum_reverse(n: int) -> int:\n    \"\"\"\n    Returns the sum of n and reverse of n.\n    >>> sum_reverse(123)\n    444\n    >>> sum_reverse(3478)\n    12221\n    >>> sum_reverse(12)\n    33\n    \"\"\"\n    return int(n) + int(str(n)[::-1])",
    "fixed_code": "def sum_reverse(n: int) -> int:\n    \"\"\"\n    Returns the sum of n and reverse of n.\n    >>> sum_reverse(123)\n    444\n    >>> sum_reverse(3478)\n    12221\n    >>> sum_reverse(12)\n    33\n    \"\"\"\n    return int(n) + int(str(n)[::-1])",
    "tests": [
      "assert sum_reverse(123) == 444",
      "assert sum_reverse(3478) == 12221",
      "assert sum_reverse(12) == 33"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_188/sol1.py",
    "function": "_modexpt",
    "bug_type": "no_bug",
    "pl": "def _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value",
    "fixed_code": "def _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value",
    "tests": [
      "assert _modexpt(2, 4, 10) == 6",
      "assert _modexpt(2, 1024, 100) == 16",
      "assert _modexpt(13, 65535, 7) == 6"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_008/sol3.py",
    "function": "str_eval",
    "bug_type": "no_bug",
    "pl": "def str_eval(s: str) -> int:\n    \"\"\"\n    Returns product of digits in given string n\n\n    >>> str_eval(\"987654321\")\n    362880\n    >>> str_eval(\"22222222\")\n    256\n    \"\"\"\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product",
    "fixed_code": "def str_eval(s: str) -> int:\n    \"\"\"\n    Returns product of digits in given string n\n\n    >>> str_eval(\"987654321\")\n    362880\n    >>> str_eval(\"22222222\")\n    256\n    \"\"\"\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product",
    "tests": [
      "assert str_eval(\"987654321\") == 362880",
      "assert str_eval(\"22222222\") == 256"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_044/sol1.py",
    "function": "is_pentagonal",
    "bug_type": "no_bug",
    "pl": "def is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0",
    "fixed_code": "def is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0",
    "tests": [
      "assert is_pentagonal(330) == True",
      "assert is_pentagonal(7683) == False",
      "assert is_pentagonal(2380) == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_043/sol1.py",
    "function": "is_substring_divisible",
    "bug_type": "no_bug",
    "pl": "def is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True",
    "fixed_code": "def is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True",
    "tests": [
      "assert is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9)) == False",
      "assert is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9)) == False",
      "assert is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9)) == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_122/sol1.py",
    "function": "solve",
    "bug_type": "no_bug",
    "pl": "def solve(nums: list[int], goal: int, depth: int) -> bool:\n    \"\"\"\n    Checks if nums can have a sum equal to goal, given that length of nums does\n    not exceed depth.\n\n    >>> solve([1], 2, 2)\n    True\n    >>> solve([1], 2, 0)\n    False\n    \"\"\"\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False",
    "fixed_code": "def solve(nums: list[int], goal: int, depth: int) -> bool:\n    \"\"\"\n    Checks if nums can have a sum equal to goal, given that length of nums does\n    not exceed depth.\n\n    >>> solve([1], 2, 2)\n    True\n    >>> solve([1], 2, 0)\n    False\n    \"\"\"\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False",
    "tests": [
      "assert solve([1], 2, 2) == True",
      "assert solve([1], 2, 0) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_045/sol1.py",
    "function": "hexagonal_num",
    "bug_type": "no_bug",
    "pl": "def hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)",
    "fixed_code": "def hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)",
    "tests": [
      "assert hexagonal_num(143) == 40755",
      "assert hexagonal_num(21) == 861",
      "assert hexagonal_num(10) == 190"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_070/sol1.py",
    "function": "has_same_digits",
    "bug_type": "no_bug",
    "pl": "def has_same_digits(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if num1 and num2 have the same frequency of every digit, False\n    otherwise.\n\n    >>> has_same_digits(123456789, 987654321)\n    True\n\n    >>> has_same_digits(123, 23)\n    False\n\n    >>> has_same_digits(1234566, 123456)\n    False\n    \"\"\"\n    return sorted(str(num1)) == sorted(str(num2))",
    "fixed_code": "def has_same_digits(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if num1 and num2 have the same frequency of every digit, False\n    otherwise.\n\n    >>> has_same_digits(123456789, 987654321)\n    True\n\n    >>> has_same_digits(123, 23)\n    False\n\n    >>> has_same_digits(1234566, 123456)\n    False\n    \"\"\"\n    return sorted(str(num1)) == sorted(str(num2))",
    "tests": [
      "assert has_same_digits(123456789, 987654321) == True",
      "assert has_same_digits(123, 23) == False",
      "assert has_same_digits(1234566, 123456) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_203/sol1.py",
    "function": "get_squarefrees",
    "bug_type": "no_bug",
    "pl": "def get_squarefrees(unique_coefficients: set[int]) -> set[int]:\n    \"\"\"\n    Calculates the squarefree numbers inside unique_coefficients.\n\n    Based on the definition of a non-squarefree number, then any non-squarefree\n    n can be decomposed as n = p*p*r, where p is positive prime number and r\n    is a positive integer.\n\n    Under the previous formula, any coefficient that is lower than p*p is\n    squarefree as r cannot be negative. On the contrary, if any r exists such\n    that n = p*p*r, then the number is non-squarefree.\n\n    >>> get_squarefrees({1})\n    {1}\n    >>> get_squarefrees({1, 2})\n    {1, 2}\n    >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})\n    {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}\n    \"\"\"\n\n    non_squarefrees = set()\n    for number in unique_coefficients:\n        divisor = 2\n        copy_number = number\n        while divisor**2 <= copy_number:\n            multiplicity = 0\n            while copy_number % divisor == 0:\n                copy_number //= divisor\n                multiplicity += 1\n            if multiplicity >= 2:\n                non_squarefrees.add(number)\n                break\n            divisor += 1\n\n    return unique_coefficients.difference(non_squarefrees)",
    "fixed_code": "def get_squarefrees(unique_coefficients: set[int]) -> set[int]:\n    \"\"\"\n    Calculates the squarefree numbers inside unique_coefficients.\n\n    Based on the definition of a non-squarefree number, then any non-squarefree\n    n can be decomposed as n = p*p*r, where p is positive prime number and r\n    is a positive integer.\n\n    Under the previous formula, any coefficient that is lower than p*p is\n    squarefree as r cannot be negative. On the contrary, if any r exists such\n    that n = p*p*r, then the number is non-squarefree.\n\n    >>> get_squarefrees({1})\n    {1}\n    >>> get_squarefrees({1, 2})\n    {1, 2}\n    >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})\n    {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}\n    \"\"\"\n\n    non_squarefrees = set()\n    for number in unique_coefficients:\n        divisor = 2\n        copy_number = number\n        while divisor**2 <= copy_number:\n            multiplicity = 0\n            while copy_number % divisor == 0:\n                copy_number //= divisor\n                multiplicity += 1\n            if multiplicity >= 2:\n                non_squarefrees.add(number)\n                break\n            divisor += 1\n\n    return unique_coefficients.difference(non_squarefrees)",
    "tests": [
      "assert get_squarefrees({1}) == {1}",
      "assert get_squarefrees({1, 2}) == {1, 2}",
      "assert get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}) == {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_101/sol1.py",
    "function": "question_function",
    "bug_type": "no_bug",
    "pl": "def question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )",
    "fixed_code": "def question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )",
    "tests": [
      "assert question_function(0) == 1",
      "assert question_function(1) == 1",
      "assert question_function(5) == 8138021",
      "assert question_function(10) == 9090909091"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_113/sol1.py",
    "function": "choose",
    "bug_type": "no_bug",
    "pl": "def choose(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n    >>> choose(4,2)\n    6\n    >>> choose(5,3)\n    10\n    >>> choose(20,6)\n    38760\n    \"\"\"\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)",
    "fixed_code": "def choose(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n    >>> choose(4,2)\n    6\n    >>> choose(5,3)\n    10\n    >>> choose(20,6)\n    38760\n    \"\"\"\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)",
    "tests": [
      "assert choose(4,2) == 6",
      "assert choose(5,3) == 10",
      "assert choose(20,6) == 38760"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_119/sol1.py",
    "function": "digit_sum",
    "bug_type": "no_bug",
    "pl": "def digit_sum(n: int) -> int:\n    \"\"\"\n    Returns the sum of the digits of the number.\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(456)\n    15\n    >>> digit_sum(78910)\n    25\n    \"\"\"\n    return sum(int(digit) for digit in str(n))",
    "fixed_code": "def digit_sum(n: int) -> int:\n    \"\"\"\n    Returns the sum of the digits of the number.\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(456)\n    15\n    >>> digit_sum(78910)\n    25\n    \"\"\"\n    return sum(int(digit) for digit in str(n))",
    "tests": [
      "assert digit_sum(123) == 6",
      "assert digit_sum(456) == 15",
      "assert digit_sum(78910) == 25"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_095/sol1.py",
    "function": "find_longest_chain",
    "bug_type": "no_bug",
    "pl": "def find_longest_chain(chain: list[int], max_num: int) -> int:\n    \"\"\"\n    Finds the smallest element of longest chain\n\n    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n    6\n    \"\"\"\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem",
    "fixed_code": "def find_longest_chain(chain: list[int], max_num: int) -> int:\n    \"\"\"\n    Finds the smallest element of longest chain\n\n    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n    6\n    \"\"\"\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem",
    "tests": [
      "assert find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6) == 6"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_035/sol1.py",
    "function": "contains_an_even_digit",
    "bug_type": "no_bug",
    "pl": "def contains_an_even_digit(n: int) -> bool:\n    \"\"\"\n    Return True if n contains an even digit.\n    >>> contains_an_even_digit(0)\n    True\n    >>> contains_an_even_digit(975317933)\n    False\n    >>> contains_an_even_digit(-245679)\n    True\n    \"\"\"\n    return any(digit in \"02468\" for digit in str(n))",
    "fixed_code": "def contains_an_even_digit(n: int) -> bool:\n    \"\"\"\n    Return True if n contains an even digit.\n    >>> contains_an_even_digit(0)\n    True\n    >>> contains_an_even_digit(975317933)\n    False\n    >>> contains_an_even_digit(-245679)\n    True\n    \"\"\"\n    return any(digit in \"02468\" for digit in str(n))",
    "tests": [
      "assert contains_an_even_digit(0) == True",
      "assert contains_an_even_digit(975317933) == False",
      "assert contains_an_even_digit(-245679) == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_065/sol1.py",
    "function": "sum_digits",
    "bug_type": "no_bug",
    "pl": "def sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum",
    "fixed_code": "def sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum",
    "tests": [
      "assert sum_digits(1) == 1",
      "assert sum_digits(12345) == 15",
      "assert sum_digits(999001) == 28"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_129/sol1.py",
    "function": "least_divisible_repunit",
    "bug_type": "no_bug",
    "pl": "def least_divisible_repunit(divisor: int) -> int:\n    \"\"\"\n    Return the least value k such that the Repunit of length k is divisible by divisor.\n    >>> least_divisible_repunit(7)\n    6\n    >>> least_divisible_repunit(41)\n    5\n    >>> least_divisible_repunit(1234567)\n    34020\n    \"\"\"\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index",
    "fixed_code": "def least_divisible_repunit(divisor: int) -> int:\n    \"\"\"\n    Return the least value k such that the Repunit of length k is divisible by divisor.\n    >>> least_divisible_repunit(7)\n    6\n    >>> least_divisible_repunit(41)\n    5\n    >>> least_divisible_repunit(1234567)\n    34020\n    \"\"\"\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index",
    "tests": [
      "assert least_divisible_repunit(7) == 6",
      "assert least_divisible_repunit(41) == 5",
      "assert least_divisible_repunit(1234567) == 34020"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_068/sol1.py",
    "function": "generate_gon_ring",
    "bug_type": "no_bug",
    "pl": "def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result",
    "fixed_code": "def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result",
    "tests": [
      "assert generate_gon_ring(3, [4, 2, 3, 5, 1, 6]) == [4, 2, 3, 5, 3, 1, 6, 1, 2]",
      "assert generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10]) == [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_089/sol1.py",
    "function": "generate_roman_numerals",
    "bug_type": "no_bug",
    "pl": "def generate_roman_numerals(num: int) -> str:\n    \"\"\"\n    Generates a string of roman numerals for a given integer.\n    e.g.\n    >>> generate_roman_numerals(89)\n    'LXXXIX'\n    >>> generate_roman_numerals(4)\n    'IV'\n    \"\"\"\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals",
    "fixed_code": "def generate_roman_numerals(num: int) -> str:\n    \"\"\"\n    Generates a string of roman numerals for a given integer.\n    e.g.\n    >>> generate_roman_numerals(89)\n    'LXXXIX'\n    >>> generate_roman_numerals(4)\n    'IV'\n    \"\"\"\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals",
    "tests": [
      "assert generate_roman_numerals(89) == 'LXXXIX'",
      "assert generate_roman_numerals(4) == 'IV'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_032/sol32.py",
    "function": "is_combination_valid",
    "bug_type": "no_bug",
    "pl": "def is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )",
    "fixed_code": "def is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )",
    "tests": [
      "assert is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4')) == True",
      "assert is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9')) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_049/sol1.py",
    "function": "search",
    "bug_type": "no_bug",
    "pl": "def search(target: int, prime_list: list) -> bool:\n    \"\"\"\n    function to search a number in a list using Binary Search.\n    >>> search(3, [1, 2, 3])\n    True\n    >>> search(4, [1, 2, 3])\n    False\n    >>> search(101, list(range(-100, 100)))\n    False\n    \"\"\"\n\n    left, right = 0, len(prime_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if prime_list[middle] == target:\n            return True\n        elif prime_list[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return False",
    "fixed_code": "def search(target: int, prime_list: list) -> bool:\n    \"\"\"\n    function to search a number in a list using Binary Search.\n    >>> search(3, [1, 2, 3])\n    True\n    >>> search(4, [1, 2, 3])\n    False\n    >>> search(101, list(range(-100, 100)))\n    False\n    \"\"\"\n\n    left, right = 0, len(prime_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if prime_list[middle] == target:\n            return True\n        elif prime_list[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return False",
    "tests": [
      "assert search(3, [1, 2, 3]) == True",
      "assert search(4, [1, 2, 3]) == False",
      "assert search(101, list(range(-100, 100))) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_009/sol1.py",
    "function": "solution_fast",
    "bug_type": "no_bug",
    "pl": "def solution_fast() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution_fast()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(400):\n            c = 1000 - a - b\n            if a < b < c and (a**2) + (b**2) == (c**2):\n                return a * b * c\n\n    return -1",
    "fixed_code": "def solution_fast() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution_fast()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(400):\n            c = 1000 - a - b\n            if a < b < c and (a**2) + (b**2) == (c**2):\n                return a * b * c\n\n    return -1",
    "tests": [
      "assert solution_fast() == 31875000"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_009/sol4.py",
    "function": "get_squares",
    "bug_type": "no_bug",
    "pl": "def get_squares(n: int) -> list[int]:\n    \"\"\"\n    >>> get_squares(0)\n    []\n    >>> get_squares(1)\n    [0]\n    >>> get_squares(2)\n    [0, 1]\n    >>> get_squares(3)\n    [0, 1, 4]\n    >>> get_squares(4)\n    [0, 1, 4, 9]\n    \"\"\"\n    return [number * number for number in range(n)]",
    "fixed_code": "def get_squares(n: int) -> list[int]:\n    \"\"\"\n    >>> get_squares(0)\n    []\n    >>> get_squares(1)\n    [0]\n    >>> get_squares(2)\n    [0, 1]\n    >>> get_squares(3)\n    [0, 1, 4]\n    >>> get_squares(4)\n    [0, 1, 4, 9]\n    \"\"\"\n    return [number * number for number in range(n)]",
    "tests": [
      "assert get_squares(0) == []",
      "assert get_squares(1) == [0]",
      "assert get_squares(2) == [0, 1]",
      "assert get_squares(3) == [0, 1, 4]",
      "assert get_squares(4) == [0, 1, 4, 9]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_206/sol1.py",
    "function": "is_square_form",
    "bug_type": "no_bug",
    "pl": "def is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True",
    "fixed_code": "def is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True",
    "tests": [
      "assert is_square_form(1) == False",
      "assert is_square_form(112233445566778899) == True",
      "assert is_square_form(123456789012345678) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_038/sol1.py",
    "function": "is_9_pandigital",
    "bug_type": "no_bug",
    "pl": "def is_9_pandigital(n: int) -> bool:\n    \"\"\"\n    Checks whether n is a 9-digit 1 to 9 pandigital number.\n    >>> is_9_pandigital(12345)\n    False\n    >>> is_9_pandigital(156284973)\n    True\n    >>> is_9_pandigital(1562849733)\n    False\n    \"\"\"\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")",
    "fixed_code": "def is_9_pandigital(n: int) -> bool:\n    \"\"\"\n    Checks whether n is a 9-digit 1 to 9 pandigital number.\n    >>> is_9_pandigital(12345)\n    False\n    >>> is_9_pandigital(156284973)\n    True\n    >>> is_9_pandigital(1562849733)\n    False\n    \"\"\"\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")",
    "tests": [
      "assert is_9_pandigital(12345) == False",
      "assert is_9_pandigital(156284973) == True",
      "assert is_9_pandigital(1562849733) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_180/sol1.py",
    "function": "is_sq",
    "bug_type": "no_bug",
    "pl": "def is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq",
    "fixed_code": "def is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq",
    "tests": [
      "assert is_sq(1) == True",
      "assert is_sq(1000001) == False",
      "assert is_sq(1000000) == True"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "project_euler/problem_091/sol1.py",
    "function": "is_right",
    "bug_type": "no_bug",
    "pl": "def is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n    Note: this doesn't check if P and Q are equal, but that's handled by the use of\n    itertools.combinations in the solution function.\n\n    >>> is_right(0, 1, 2, 0)\n    True\n    >>> is_right(1, 0, 2, 2)\n    False\n    \"\"\"\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )",
    "fixed_code": "def is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n    Note: this doesn't check if P and Q are equal, but that's handled by the use of\n    itertools.combinations in the solution function.\n\n    >>> is_right(0, 1, 2, 0)\n    True\n    >>> is_right(1, 0, 2, 2)\n    False\n    \"\"\"\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )",
    "tests": [
      "assert is_right(0, 1, 2, 0) == True",
      "assert is_right(1, 0, 2, 2) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "electronics/real_and_reactive_power.py",
    "function": "real_power",
    "bug_type": "no_bug",
    "pl": "def real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor",
    "fixed_code": "def real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor",
    "tests": [
      "assert real_power(100, 0.9) == 90.0",
      "assert real_power(0, 0.8) == 0.0",
      "assert real_power(100, -0.9) == -90.0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "physics/speed_of_sound.py",
    "function": "speed_of_sound_in_a_fluid",
    "bug_type": "no_bug",
    "pl": "def speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20\u00b0C: bulk_modulus= 2.15MPa, density=998kg/m\u00b3\n    Example 2 --> Mercury 20\u00b0C: bulk_modulus= 28.5MPa, density=13600kg/m\u00b3\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5",
    "fixed_code": "def speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20\u00b0C: bulk_modulus= 2.15MPa, density=998kg/m\u00b3\n    Example 2 --> Mercury 20\u00b0C: bulk_modulus= 28.5MPa, density=13600kg/m\u00b3\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5",
    "tests": [
      "assert speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998) == 1467.7563207952705",
      "assert speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600) == 1447.614670861731"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "physics/coulombs_law.py",
    "function": "coulombs_law",
    "bug_type": "no_bug",
    "pl": "def coulombs_law(q1: float, q2: float, radius: float) -> float:\n    \"\"\"\n    Calculate the electrostatic force of attraction or repulsion\n    between two point charges\n\n    >>> coulombs_law(15.5, 20, 15)\n    12382849136.06\n    >>> coulombs_law(1, 15, 5)\n    5392531075.38\n    >>> coulombs_law(20, -50, 15)\n    -39944674632.44\n    >>> coulombs_law(-5, -8, 10)\n    3595020716.92\n    >>> coulombs_law(50, 100, 50)\n    17975103584.6\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)",
    "fixed_code": "def coulombs_law(q1: float, q2: float, radius: float) -> float:\n    \"\"\"\n    Calculate the electrostatic force of attraction or repulsion\n    between two point charges\n\n    >>> coulombs_law(15.5, 20, 15)\n    12382849136.06\n    >>> coulombs_law(1, 15, 5)\n    5392531075.38\n    >>> coulombs_law(20, -50, 15)\n    -39944674632.44\n    >>> coulombs_law(-5, -8, 10)\n    3595020716.92\n    >>> coulombs_law(50, 100, 50)\n    17975103584.6\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)",
    "tests": [
      "assert coulombs_law(15.5, 20, 15) == 12382849136.06",
      "assert coulombs_law(1, 15, 5) == 5392531075.38",
      "assert coulombs_law(20, -50, 15) == -39944674632.44",
      "assert coulombs_law(-5, -8, 10) == 3595020716.92",
      "assert coulombs_law(50, 100, 50) == 17975103584.6"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "physics/orbital_transfer_work.py",
    "function": "orbital_transfer_work",
    "bug_type": "no_bug",
    "pl": "def orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    \"\"\"\n    Calculates the work required to move an object from one orbit to another in a\n    gravitational field based on the change in total mechanical energy.\n\n    The formula used is:\n        W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\n    where:\n        W = work done (Joules)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the central body (kg)\n        m = mass of the orbiting object (kg)\n        r_initial = initial orbit radius (m)\n        r_final = final orbit radius (m)\n\n    Args:\n        mass_central (float): Mass of the central body (kg)\n        mass_object (float): Mass of the object being moved (kg)\n        r_initial (float): Initial orbital radius (m)\n        r_final (float): Final orbital radius (m)\n\n    Returns:\n        str: Work done in Joules as a string in scientific notation (3 decimals)\n\n    Examples:\n        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n        '2.811e+09'\n        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n        '-1.405e+09'\n        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n        '1.514e+11'\n    \"\"\"\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\"",
    "fixed_code": "def orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    \"\"\"\n    Calculates the work required to move an object from one orbit to another in a\n    gravitational field based on the change in total mechanical energy.\n\n    The formula used is:\n        W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\n    where:\n        W = work done (Joules)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the central body (kg)\n        m = mass of the orbiting object (kg)\n        r_initial = initial orbit radius (m)\n        r_final = final orbit radius (m)\n\n    Args:\n        mass_central (float): Mass of the central body (kg)\n        mass_object (float): Mass of the object being moved (kg)\n        r_initial (float): Initial orbital radius (m)\n        r_final (float): Final orbital radius (m)\n\n    Returns:\n        str: Work done in Joules as a string in scientific notation (3 decimals)\n\n    Examples:\n        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n        '2.811e+09'\n        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n        '-1.405e+09'\n        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n        '1.514e+11'\n    \"\"\"\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\"",
    "tests": [
      "assert orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6) == '2.811e+09'",
      "assert orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6) == '-1.405e+09'",
      "assert orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11) == '1.514e+11'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "physics/newtons_second_law_of_motion.py",
    "function": "newtons_second_law_of_motion",
    "bug_type": "no_bug",
    "pl": "def newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    Calculates force from `mass` and `acceleration`\n\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force",
    "fixed_code": "def newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    Calculates force from `mass` and `acceleration`\n\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force",
    "tests": [
      "assert newtons_second_law_of_motion(10, 10) == 100",
      "assert newtons_second_law_of_motion(2.0, 1) == 2.0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "physics/kinetic_energy.py",
    "function": "kinetic_energy",
    "bug_type": "no_bug",
    "pl": "def kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is \u00bdmv\u00b2\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)",
    "fixed_code": "def kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is \u00bdmv\u00b2\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)",
    "tests": [
      "assert kinetic_energy(10,10) == 500.0",
      "assert kinetic_energy(0,10) == 0.0",
      "assert kinetic_energy(10,0) == 0.0",
      "assert kinetic_energy(20,-20) == 4000.0",
      "assert kinetic_energy(0,0) == 0.0",
      "assert kinetic_energy(2,2) == 4.0",
      "assert kinetic_energy(100,100) == 500000.0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "physics/centripetal_force.py",
    "function": "centripetal",
    "bug_type": "no_bug",
    "pl": "def centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius",
    "fixed_code": "def centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius",
    "tests": [
      "assert round(centripetal(15.5,-30,10),2) == 1395.0",
      "assert round(centripetal(10,15,5),2) == 450.0",
      "assert round(centripetal(20,-50,15),2) == 3333.33",
      "assert round(centripetal(12.25,40,25),2) == 784.0",
      "assert round(centripetal(50,100,50),2) == 10000.0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "physics/grahams_law.py",
    "function": "validate",
    "bug_type": "no_bug",
    "pl": "def validate(*values: float) -> bool:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> validate(2.016, 4.002)\n    True\n    >>> validate(-2.016, 4.002)\n    False\n    >>> validate()\n    False\n    \"\"\"\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result",
    "fixed_code": "def validate(*values: float) -> bool:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> validate(2.016, 4.002)\n    True\n    >>> validate(-2.016, 4.002)\n    False\n    >>> validate()\n    False\n    \"\"\"\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result",
    "tests": [
      "assert validate(2.016, 4.002) == True",
      "assert validate(-2.016, 4.002) == False",
      "assert validate() == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "physics/shear_stress.py",
    "function": "shear_stress",
    "bug_type": "no_bug",
    "pl": "def shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )",
    "fixed_code": "def shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )",
    "tests": [
      "assert shear_stress(stress=25, tangential_force=100, area=0) == ('area', 4.0)",
      "assert shear_stress(stress=0, tangential_force=1600, area=200) == ('stress', 8.0)",
      "assert shear_stress(stress=1000, tangential_force=0, area=1200) == ('tangential_force', 1200000)"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/sum_of_harmonic_series.py",
    "function": "sum_of_harmonic_progression",
    "bug_type": "no_bug",
    "pl": "def sum_of_harmonic_progression(\n    first_term: float, common_difference: float, number_of_terms: int\n) -> float:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)\n\n    Find the sum of n terms in an harmonic progression.  The calculation starts with the\n    first_term and loops adding the common difference of Arithmetic Progression by which\n    the given Harmonic Progression is linked.\n\n    >>> sum_of_harmonic_progression(1 / 2, 2, 2)\n    0.75\n    >>> sum_of_harmonic_progression(1 / 5, 5, 5)\n    0.45666666666666667\n    \"\"\"\n    arithmetic_progression = [1 / first_term]\n    first_term = 1 / first_term\n    for _ in range(number_of_terms - 1):\n        first_term += common_difference\n        arithmetic_progression.append(first_term)\n    harmonic_series = [1 / step for step in arithmetic_progression]\n    return sum(harmonic_series)",
    "fixed_code": "def sum_of_harmonic_progression(\n    first_term: float, common_difference: float, number_of_terms: int\n) -> float:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)\n\n    Find the sum of n terms in an harmonic progression.  The calculation starts with the\n    first_term and loops adding the common difference of Arithmetic Progression by which\n    the given Harmonic Progression is linked.\n\n    >>> sum_of_harmonic_progression(1 / 2, 2, 2)\n    0.75\n    >>> sum_of_harmonic_progression(1 / 5, 5, 5)\n    0.45666666666666667\n    \"\"\"\n    arithmetic_progression = [1 / first_term]\n    first_term = 1 / first_term\n    for _ in range(number_of_terms - 1):\n        first_term += common_difference\n        arithmetic_progression.append(first_term)\n    harmonic_series = [1 / step for step in arithmetic_progression]\n    return sum(harmonic_series)",
    "tests": [
      "assert sum_of_harmonic_progression(1 / 2, 2, 2) == 0.75",
      "assert sum_of_harmonic_progression(1 / 5, 5, 5) == 0.45666666666666667"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/fibonacci.py",
    "function": "fib_memoization",
    "bug_type": "no_bug",
    "pl": "def fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]",
    "fixed_code": "def fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]",
    "tests": [
      "assert fib_memoization(0) == [0]",
      "assert fib_memoization(1) == [0, 1]",
      "assert fib_memoization(5) == [0, 1, 1, 2, 3, 5]",
      "assert fib_memoization(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/josephus_problem.py",
    "function": "josephus_iterative",
    "bug_type": "no_bug",
    "pl": "def josephus_iterative(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size iteratively.\n\n    Args:\n        num_people (int): The number of people in the circle.\n        step_size (int): The number of steps to take before eliminating someone.\n\n    Returns:\n        int: The position of the last person standing.\n\n    Examples:\n        >>> josephus_iterative(5, 2)\n        3\n        >>> josephus_iterative(7, 3)\n        4\n    \"\"\"\n    circle = list(range(1, num_people + 1))\n    current = 0\n\n    while len(circle) > 1:\n        current = (current + step_size - 1) % len(circle)\n        circle.pop(current)\n\n    return circle[0]",
    "fixed_code": "def josephus_iterative(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size iteratively.\n\n    Args:\n        num_people (int): The number of people in the circle.\n        step_size (int): The number of steps to take before eliminating someone.\n\n    Returns:\n        int: The position of the last person standing.\n\n    Examples:\n        >>> josephus_iterative(5, 2)\n        3\n        >>> josephus_iterative(7, 3)\n        4\n    \"\"\"\n    circle = list(range(1, num_people + 1))\n    current = 0\n\n    while len(circle) > 1:\n        current = (current + step_size - 1) % len(circle)\n        circle.pop(current)\n\n    return circle[0]",
    "tests": [
      "assert josephus_iterative(5, 2) == 3",
      "assert josephus_iterative(7, 3) == 4"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/modular_exponential.py",
    "function": "modular_exponential",
    "bug_type": "no_bug",
    "pl": "def modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result",
    "fixed_code": "def modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result",
    "tests": [
      "assert modular_exponential(5, 0, 10) == 1",
      "assert modular_exponential(2, 8, 7) == 4",
      "assert modular_exponential(3, -2, 9) == -1"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/simultaneous_linear_equation_solver.py",
    "function": "simplify",
    "bug_type": "no_bug",
    "pl": "def simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set",
    "fixed_code": "def simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set",
    "tests": [
      "assert simplify([[1, 2, 3], [4, 5, 6]]) == [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]",
      "assert simplify([[5, 2, 5], [5, 1, 10]]) == [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/interquartile_range.py",
    "function": "find_median",
    "bug_type": "no_bug",
    "pl": "def find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2",
    "fixed_code": "def find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2",
    "tests": [
      "assert find_median(nums=([1, 2, 2, 3, 4])) == 2",
      "assert find_median(nums=([1, 2, 2, 3, 4, 4])) == 2.5",
      "assert find_median(nums=([-1, 2, 0, 3, 4, -4])) == 1.5",
      "assert find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4])) == 2.65"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/binary_multiplication.py",
    "function": "binary_multiply",
    "bug_type": "no_bug",
    "pl": "def binary_multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply 'a' and 'b' using bitwise multiplication.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: a * b\n\n    Examples:\n    >>> binary_multiply(2, 3)\n    6\n    >>> binary_multiply(5, 0)\n    0\n    >>> binary_multiply(3, 4)\n    12\n    >>> binary_multiply(10, 5)\n    50\n    >>> binary_multiply(0, 5)\n    0\n    >>> binary_multiply(2, 1)\n    2\n    >>> binary_multiply(1, 10)\n    10\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res",
    "fixed_code": "def binary_multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply 'a' and 'b' using bitwise multiplication.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: a * b\n\n    Examples:\n    >>> binary_multiply(2, 3)\n    6\n    >>> binary_multiply(5, 0)\n    0\n    >>> binary_multiply(3, 4)\n    12\n    >>> binary_multiply(10, 5)\n    50\n    >>> binary_multiply(0, 5)\n    0\n    >>> binary_multiply(2, 1)\n    2\n    >>> binary_multiply(1, 10)\n    10\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res",
    "tests": [
      "assert binary_multiply(2, 3) == 6",
      "assert binary_multiply(5, 0) == 0",
      "assert binary_multiply(3, 4) == 12",
      "assert binary_multiply(10, 5) == 50",
      "assert binary_multiply(0, 5) == 0",
      "assert binary_multiply(2, 1) == 2",
      "assert binary_multiply(1, 10) == 10"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/binary_multiplication.py",
    "function": "binary_mod_multiply",
    "bug_type": "no_bug",
    "pl": "def binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res",
    "fixed_code": "def binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res",
    "tests": [
      "assert binary_mod_multiply(2, 3, 5) == 1",
      "assert binary_mod_multiply(5, 0, 7) == 0",
      "assert binary_mod_multiply(3, 4, 6) == 0",
      "assert binary_mod_multiply(10, 5, 13) == 11",
      "assert binary_mod_multiply(2, 1, 5) == 2",
      "assert binary_mod_multiply(1, 10, 3) == 1"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/modular_division.py",
    "function": "greatest_common_divisor",
    "bug_type": "no_bug",
    "pl": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid's Algorithm\n\n    >>> greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    >>> greatest_common_divisor(121, 11)\n    11\n\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while a % b != 0:\n        a, b = b, a % b\n\n    return b",
    "fixed_code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid's Algorithm\n\n    >>> greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    >>> greatest_common_divisor(121, 11)\n    11\n\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while a % b != 0:\n        a, b = b, a % b\n\n    return b",
    "tests": [
      "assert greatest_common_divisor(7,5) == 1",
      "assert greatest_common_divisor(121, 11) == 11"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/is_int_palindrome.py",
    "function": "is_int_palindrome",
    "bug_type": "no_bug",
    "pl": "def is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num",
    "fixed_code": "def is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num",
    "tests": [
      "assert is_int_palindrome(-121) == False",
      "assert is_int_palindrome(0) == True",
      "assert is_int_palindrome(10) == False",
      "assert is_int_palindrome(11) == True",
      "assert is_int_palindrome(101) == True",
      "assert is_int_palindrome(120) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/addition_without_arithmetic.py",
    "function": "add",
    "bug_type": "no_bug",
    "pl": "def add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first",
    "fixed_code": "def add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first",
    "tests": [
      "assert add(3, 5) == 8",
      "assert add(13, 5) == 18",
      "assert add(-7, 2) == -5",
      "assert add(0, -7) == -7",
      "assert add(-321, 0) == -321"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/sum_of_arithmetic_series.py",
    "function": "sum_of_series",
    "bug_type": "no_bug",
    "pl": "def sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:\n    \"\"\"\n    Find the sum of n terms in an arithmetic progression.\n\n    >>> sum_of_series(1, 1, 10)\n    55.0\n    >>> sum_of_series(1, 10, 100)\n    49600.0\n    \"\"\"\n    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\n    # formula for sum of series\n    return total",
    "fixed_code": "def sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:\n    \"\"\"\n    Find the sum of n terms in an arithmetic progression.\n\n    >>> sum_of_series(1, 1, 10)\n    55.0\n    >>> sum_of_series(1, 10, 100)\n    49600.0\n    \"\"\"\n    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\n    # formula for sum of series\n    return total",
    "tests": [
      "assert sum_of_series(1, 1, 10) == 55.0",
      "assert sum_of_series(1, 10, 100) == 49600.0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/sum_of_geometric_progression.py",
    "function": "sum_of_geometric_progression",
    "bug_type": "no_bug",
    "pl": "def sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)",
    "fixed_code": "def sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)",
    "tests": [
      "assert sum_of_geometric_progression(1, 2, 10) == 1023.0",
      "assert sum_of_geometric_progression(1, 10, 5) == 11111.0",
      "assert sum_of_geometric_progression(0, 2, 10) == 0.0",
      "assert sum_of_geometric_progression(1, 0, 10) == 1.0",
      "assert sum_of_geometric_progression(1, 2, 0) == -0.0",
      "assert sum_of_geometric_progression(-1, 2, 10) == -1023.0",
      "assert sum_of_geometric_progression(1, -2, 10) == -341.0",
      "assert sum_of_geometric_progression(1, 2, -10) == -0.9990234375"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/kth_lexicographic_permutation.py",
    "function": "kth_permutation",
    "bug_type": "no_bug",
    "pl": "def kth_permutation(k, n):\n    \"\"\"\n    Finds k'th lexicographic permutation (in increasing order) of\n    0,1,2,...n-1 in O(n^2) time.\n\n    Examples:\n    First permutation is always 0,1,2,...n\n    >>> kth_permutation(0,5)\n    [0, 1, 2, 3, 4]\n\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n    [1,2,3,0], [1,3,0,2]\n    >>> kth_permutation(10,4)\n    [1, 3, 0, 2]\n    \"\"\"\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation",
    "fixed_code": "def kth_permutation(k, n):\n    \"\"\"\n    Finds k'th lexicographic permutation (in increasing order) of\n    0,1,2,...n-1 in O(n^2) time.\n\n    Examples:\n    First permutation is always 0,1,2,...n\n    >>> kth_permutation(0,5)\n    [0, 1, 2, 3, 4]\n\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n    [1,2,3,0], [1,3,0,2]\n    >>> kth_permutation(10,4)\n    [1, 3, 0, 2]\n    \"\"\"\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation",
    "tests": [
      "assert kth_permutation(0,5) == [0, 1, 2, 3, 4]",
      "assert kth_permutation(10,4) == [1, 3, 0, 2]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/base_neg2_conversion.py",
    "function": "decimal_to_negative_base_2",
    "bug_type": "no_bug",
    "pl": "def decimal_to_negative_base_2(num: int) -> int:\n    \"\"\"\n    This function returns the number negative base 2\n        of the decimal number of the input data.\n\n    Args:\n        int: The decimal number to convert.\n\n    Returns:\n        int: The negative base 2 number.\n\n    Examples:\n        >>> decimal_to_negative_base_2(0)\n        0\n        >>> decimal_to_negative_base_2(-19)\n        111101\n        >>> decimal_to_negative_base_2(4)\n        100\n        >>> decimal_to_negative_base_2(7)\n        11011\n    \"\"\"\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)",
    "fixed_code": "def decimal_to_negative_base_2(num: int) -> int:\n    \"\"\"\n    This function returns the number negative base 2\n        of the decimal number of the input data.\n\n    Args:\n        int: The decimal number to convert.\n\n    Returns:\n        int: The negative base 2 number.\n\n    Examples:\n        >>> decimal_to_negative_base_2(0)\n        0\n        >>> decimal_to_negative_base_2(-19)\n        111101\n        >>> decimal_to_negative_base_2(4)\n        100\n        >>> decimal_to_negative_base_2(7)\n        11011\n    \"\"\"\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)",
    "tests": [
      "assert decimal_to_negative_base_2(0) == 0",
      "assert decimal_to_negative_base_2(-19) == 111101",
      "assert decimal_to_negative_base_2(4) == 100",
      "assert decimal_to_negative_base_2(7) == 11011"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/two_sum.py",
    "function": "two_sum",
    "bug_type": "no_bug",
    "pl": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum([15, 2, 11, 7], 13)\n    [1, 2]\n    >>> two_sum([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum([7, 15, 11, 2], 18)\n    [0, 2]\n    >>> two_sum([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum([2, 7, 11, 15], 8)\n    []\n    >>> two_sum([3 * i for i in range(10)], 19)\n    []\n    \"\"\"\n    chk_map: dict[int, int] = {}\n    for index, val in enumerate(nums):\n        compl = target - val\n        if compl in chk_map:\n            return [chk_map[compl], index]\n        chk_map[val] = index\n    return []",
    "fixed_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum([15, 2, 11, 7], 13)\n    [1, 2]\n    >>> two_sum([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum([7, 15, 11, 2], 18)\n    [0, 2]\n    >>> two_sum([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum([2, 7, 11, 15], 8)\n    []\n    >>> two_sum([3 * i for i in range(10)], 19)\n    []\n    \"\"\"\n    chk_map: dict[int, int] = {}\n    for index, val in enumerate(nums):\n        compl = target - val\n        if compl in chk_map:\n            return [chk_map[compl], index]\n        chk_map[val] = index\n    return []",
    "tests": [
      "assert two_sum([2, 7, 11, 15], 9) == [0, 1]",
      "assert two_sum([15, 2, 11, 7], 13) == [1, 2]",
      "assert two_sum([2, 7, 11, 15], 17) == [0, 3]",
      "assert two_sum([7, 15, 11, 2], 18) == [0, 2]",
      "assert two_sum([2, 7, 11, 15], 26) == [2, 3]",
      "assert two_sum([2, 7, 11, 15], 8) == []",
      "assert two_sum([3 * i for i in range(10)], 19) == []"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/trapezoidal_rule.py",
    "function": "f",
    "bug_type": "no_bug",
    "pl": "def f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2",
    "fixed_code": "def f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2",
    "tests": [
      "assert f(0) == 0",
      "assert f(1) == 1",
      "assert f(0.5) == 0.25"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/three_sum.py",
    "function": "three_sum",
    "bug_type": "no_bug",
    "pl": "def three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans",
    "fixed_code": "def three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans",
    "tests": [
      "assert three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]]",
      "assert three_sum([1, 2, 3, 4]) == []"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/perfect_cube.py",
    "function": "perfect_cube",
    "bug_type": "no_bug",
    "pl": "def perfect_cube(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not.\n\n    >>> perfect_cube(27)\n    True\n    >>> perfect_cube(4)\n    False\n    \"\"\"\n    val = n ** (1 / 3)\n    return (val * val * val) == n",
    "fixed_code": "def perfect_cube(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not.\n\n    >>> perfect_cube(27)\n    True\n    >>> perfect_cube(4)\n    False\n    \"\"\"\n    val = n ** (1 / 3)\n    return (val * val * val) == n",
    "tests": [
      "assert perfect_cube(27) == True",
      "assert perfect_cube(4) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/sum_of_digits.py",
    "function": "sum_of_digits_compact",
    "bug_type": "no_bug",
    "pl": "def sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))",
    "fixed_code": "def sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))",
    "tests": [
      "assert sum_of_digits_compact(12345) == 15",
      "assert sum_of_digits_compact(123) == 6",
      "assert sum_of_digits_compact(-123) == 6",
      "assert sum_of_digits_compact(0) == 0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/decimal_isolate.py",
    "function": "decimal_isolate",
    "bug_type": "no_bug",
    "pl": "def decimal_isolate(number: float, digit_amount: int) -> float:\n    \"\"\"\n    Isolates the decimal part of a number.\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\n    >>> decimal_isolate(1.53, 0)\n    0.53\n    >>> decimal_isolate(35.345, 1)\n    0.3\n    >>> decimal_isolate(35.345, 2)\n    0.34\n    >>> decimal_isolate(35.345, 3)\n    0.345\n    >>> decimal_isolate(-14.789, 3)\n    -0.789\n    >>> decimal_isolate(0, 2)\n    0\n    >>> decimal_isolate(-14.123, 1)\n    -0.1\n    >>> decimal_isolate(-14.123, 2)\n    -0.12\n    >>> decimal_isolate(-14.123, 3)\n    -0.123\n    \"\"\"\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)",
    "fixed_code": "def decimal_isolate(number: float, digit_amount: int) -> float:\n    \"\"\"\n    Isolates the decimal part of a number.\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\n    >>> decimal_isolate(1.53, 0)\n    0.53\n    >>> decimal_isolate(35.345, 1)\n    0.3\n    >>> decimal_isolate(35.345, 2)\n    0.34\n    >>> decimal_isolate(35.345, 3)\n    0.345\n    >>> decimal_isolate(-14.789, 3)\n    -0.789\n    >>> decimal_isolate(0, 2)\n    0\n    >>> decimal_isolate(-14.123, 1)\n    -0.1\n    >>> decimal_isolate(-14.123, 2)\n    -0.12\n    >>> decimal_isolate(-14.123, 3)\n    -0.123\n    \"\"\"\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)",
    "tests": [
      "assert decimal_isolate(1.53, 0) == 0.53",
      "assert decimal_isolate(35.345, 1) == 0.3",
      "assert decimal_isolate(35.345, 2) == 0.34",
      "assert decimal_isolate(35.345, 3) == 0.345",
      "assert decimal_isolate(-14.789, 3) == -0.789",
      "assert decimal_isolate(0, 2) == 0",
      "assert decimal_isolate(-14.123, 1) == -0.1",
      "assert decimal_isolate(-14.123, 2) == -0.12",
      "assert decimal_isolate(-14.123, 3) == -0.123"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/two_pointer.py",
    "function": "two_pointer",
    "bug_type": "no_bug",
    "pl": "def two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []",
    "fixed_code": "def two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []",
    "tests": [
      "assert two_pointer([2, 7, 11, 15], 9) == [0, 1]",
      "assert two_pointer([2, 7, 11, 15], 17) == [0, 3]",
      "assert two_pointer([2, 7, 11, 15], 18) == [1, 2]",
      "assert two_pointer([2, 7, 11, 15], 26) == [2, 3]",
      "assert two_pointer([1, 3, 3], 6) == [1, 2]",
      "assert two_pointer([2, 7, 11, 15], 8) == []",
      "assert two_pointer([3 * i for i in range(10)], 19) == []",
      "assert two_pointer([1, 2, 3], 6) == []"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/least_common_multiple.py",
    "function": "least_common_multiple_slow",
    "bug_type": "no_bug",
    "pl": "def least_common_multiple_slow(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n\n    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple\n\n    >>> least_common_multiple_slow(5, 2)\n    10\n    >>> least_common_multiple_slow(12, 76)\n    228\n    \"\"\"\n    max_num = first_num if first_num >= second_num else second_num\n    common_mult = max_num\n    while (common_mult % first_num > 0) or (common_mult % second_num > 0):\n        common_mult += max_num\n    return common_mult",
    "fixed_code": "def least_common_multiple_slow(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n\n    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple\n\n    >>> least_common_multiple_slow(5, 2)\n    10\n    >>> least_common_multiple_slow(12, 76)\n    228\n    \"\"\"\n    max_num = first_num if first_num >= second_num else second_num\n    common_mult = max_num\n    while (common_mult % first_num > 0) or (common_mult % second_num > 0):\n        common_mult += max_num\n    return common_mult",
    "tests": [
      "assert least_common_multiple_slow(5, 2) == 10",
      "assert least_common_multiple_slow(12, 76) == 228"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/joint_probability_distribution.py",
    "function": "standard_deviation",
    "bug_type": "no_bug",
    "pl": "def standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5",
    "fixed_code": "def standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5",
    "tests": [
      "assert standard_deviation(0.21) == 0.458257569495584"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/number_of_digits.py",
    "function": "num_digits_faster",
    "bug_type": "no_bug",
    "pl": "def num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))",
    "fixed_code": "def num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))",
    "tests": [
      "assert num_digits_faster(12345) == 5",
      "assert num_digits_faster(123) == 3",
      "assert num_digits_faster(0) == 1",
      "assert num_digits_faster(-1) == 1",
      "assert num_digits_faster(-123456) == 6"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/special_numbers/bell_numbers.py",
    "function": "_binomial_coefficient",
    "bug_type": "no_bug",
    "pl": "def _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\n    Args:\n        total_elements (int): The total number of elements.\n        elements_to_choose (int): The number of elements to choose.\n\n    Returns:\n        int: The binomial coefficient C(total_elements, elements_to_choose).\n\n    Examples:\n    >>> _binomial_coefficient(5, 2)\n    10\n    >>> _binomial_coefficient(6, 3)\n    20\n    \"\"\"\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient",
    "fixed_code": "def _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\n    Args:\n        total_elements (int): The total number of elements.\n        elements_to_choose (int): The number of elements to choose.\n\n    Returns:\n        int: The binomial coefficient C(total_elements, elements_to_choose).\n\n    Examples:\n    >>> _binomial_coefficient(5, 2)\n    10\n    >>> _binomial_coefficient(6, 3)\n    20\n    \"\"\"\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient",
    "tests": [
      "assert _binomial_coefficient(5, 2) == 10",
      "assert _binomial_coefficient(6, 3) == 20"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/special_numbers/krishnamurthy_number.py",
    "function": "factorial",
    "bug_type": "no_bug",
    "pl": "def factorial(digit: int) -> int:\n    \"\"\"\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    >>> factorial(5)\n    120\n    \"\"\"\n\n    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))",
    "fixed_code": "def factorial(digit: int) -> int:\n    \"\"\"\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    >>> factorial(5)\n    120\n    \"\"\"\n\n    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))",
    "tests": [
      "assert factorial(3) == 6",
      "assert factorial(0) == 1",
      "assert factorial(5) == 120"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/special_numbers/carmichael_number.py",
    "function": "power",
    "bug_type": "no_bug",
    "pl": "def power(x: int, y: int, mod: int) -> int:\n    \"\"\"\n    Examples:\n    >>> power(2, 15, 3)\n    2\n    >>> power(5, 1, 30)\n    5\n    \"\"\"\n\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, mod) % mod\n    temp = (temp * temp) % mod\n    if y % 2 == 1:\n        temp = (temp * x) % mod\n    return temp",
    "fixed_code": "def power(x: int, y: int, mod: int) -> int:\n    \"\"\"\n    Examples:\n    >>> power(2, 15, 3)\n    2\n    >>> power(5, 1, 30)\n    5\n    \"\"\"\n\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, mod) % mod\n    temp = (temp * temp) % mod\n    if y % 2 == 1:\n        temp = (temp * x) % mod\n    return temp",
    "tests": [
      "assert power(2, 15, 3) == 2",
      "assert power(5, 1, 30) == 5"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/series/harmonic_series.py",
    "function": "harmonic_series",
    "bug_type": "no_bug",
    "pl": "def harmonic_series(n_term: str) -> list:\n    \"\"\"Pure Python implementation of Harmonic Series algorithm\n\n    :param n_term: The last (nth) term of Harmonic Series\n    :return: The Harmonic Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> harmonic_series(5)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.0)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.1)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(-5)\n    []\n    >>> harmonic_series(0)\n    []\n    >>> harmonic_series(1)\n    ['1']\n    \"\"\"\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series",
    "fixed_code": "def harmonic_series(n_term: str) -> list:\n    \"\"\"Pure Python implementation of Harmonic Series algorithm\n\n    :param n_term: The last (nth) term of Harmonic Series\n    :return: The Harmonic Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> harmonic_series(5)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.0)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.1)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(-5)\n    []\n    >>> harmonic_series(0)\n    []\n    >>> harmonic_series(1)\n    ['1']\n    \"\"\"\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series",
    "tests": [
      "assert harmonic_series(5) == ['1', '1/2', '1/3', '1/4', '1/5']",
      "assert harmonic_series(5.0) == ['1', '1/2', '1/3', '1/4', '1/5']",
      "assert harmonic_series(5.1) == ['1', '1/2', '1/3', '1/4', '1/5']",
      "assert harmonic_series(-5) == []",
      "assert harmonic_series(0) == []",
      "assert harmonic_series(1) == ['1']"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/numerical_analysis/bisection_2.py",
    "function": "equation",
    "bug_type": "no_bug",
    "pl": "def equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x",
    "fixed_code": "def equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x",
    "tests": [
      "assert equation(5) == -15",
      "assert equation(0) == 10",
      "assert equation(-5) == -15",
      "assert equation(0.1) == 9.99",
      "assert equation(-0.1) == 9.99"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "maths/numerical_analysis/newton_forward_interpolation.py",
    "function": "ucal",
    "bug_type": "no_bug",
    "pl": "def ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp",
    "fixed_code": "def ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp",
    "tests": [
      "assert ucal(1, 2) == 0",
      "assert ucal(1.1, 2) == 0.11000000000000011",
      "assert ucal(1.2, 2) == 0.23999999999999994"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "hashes/djb2.py",
    "function": "djb2",
    "bug_type": "no_bug",
    "pl": "def djb2(s: str) -> int:\n    \"\"\"\n    Implementation of djb2 hash algorithm that\n    is popular because of it's magic constants.\n\n    >>> djb2('Algorithms')\n    3782405311\n\n    >>> djb2('scramble bits')\n    1609059040\n    \"\"\"\n    hash_value = 5381\n    for x in s:\n        hash_value = ((hash_value << 5) + hash_value) + ord(x)\n    return hash_value & 0xFFFFFFFF",
    "fixed_code": "def djb2(s: str) -> int:\n    \"\"\"\n    Implementation of djb2 hash algorithm that\n    is popular because of it's magic constants.\n\n    >>> djb2('Algorithms')\n    3782405311\n\n    >>> djb2('scramble bits')\n    1609059040\n    \"\"\"\n    hash_value = 5381\n    for x in s:\n        hash_value = ((hash_value << 5) + hash_value) + ord(x)\n    return hash_value & 0xFFFFFFFF",
    "tests": [
      "assert djb2('Algorithms') == 3782405311",
      "assert djb2('scramble bits') == 1609059040"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "hashes/elf.py",
    "function": "elf_hash",
    "bug_type": "no_bug",
    "pl": "def elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_",
    "fixed_code": "def elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_",
    "tests": [
      "assert elf_hash('lorem ipsum') == 253956621"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "hashes/hamming_code.py",
    "function": "text_to_bits",
    "bug_type": "no_bug",
    "pl": "def text_to_bits(text, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_to_bits(\"msg\")\n    '011011010111001101100111'\n    \"\"\"\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \"big\"))[2:]\n    return bits.zfill(8 * ((len(bits) + 7) // 8))",
    "fixed_code": "def text_to_bits(text, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_to_bits(\"msg\")\n    '011011010111001101100111'\n    \"\"\"\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \"big\"))[2:]\n    return bits.zfill(8 * ((len(bits) + 7) // 8))",
    "tests": [
      "assert text_to_bits(\"msg\") == '011011010111001101100111'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "hashes/hamming_code.py",
    "function": "text_from_bits",
    "bug_type": "no_bug",
    "pl": "def text_from_bits(bits, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_from_bits('011011010111001101100111')\n    'msg'\n    \"\"\"\n    n = int(bits, 2)\n    return n.to_bytes((n.bit_length() + 7) // 8, \"big\").decode(encoding, errors) or \"\\0\"",
    "fixed_code": "def text_from_bits(bits, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_from_bits('011011010111001101100111')\n    'msg'\n    \"\"\"\n    n = int(bits, 2)\n    return n.to_bytes((n.bit_length() + 7) // 8, \"big\").decode(encoding, errors) or \"\\0\"",
    "tests": [
      "assert text_from_bits('011011010111001101100111') == 'msg'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "hashes/sdbm.py",
    "function": "sdbm",
    "bug_type": "no_bug",
    "pl": "def sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value",
    "fixed_code": "def sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value",
    "tests": [
      "assert sdbm('Algorithms') == 1462174910723540325254304520539387479031000036",
      "assert sdbm('scramble bits') == 730247649148944819640658295400555317318720608290373040936089"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "hashes/md5.py",
    "function": "sum_32",
    "bug_type": "no_bug",
    "pl": "def sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32",
    "fixed_code": "def sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32",
    "tests": [
      "assert sum_32(1, 1) == 2",
      "assert sum_32(2, 3) == 5",
      "assert sum_32(0, 0) == 0",
      "assert sum_32(-1, -1) == 4294967294",
      "assert sum_32(4294967295, 1) == 0"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "hashes/fletcher16.py",
    "function": "fletcher16",
    "bug_type": "no_bug",
    "pl": "def fletcher16(text: str) -> int:\n    \"\"\"\n    Loop through every character in the data and add to two sums.\n\n    >>> fletcher16('hello world')\n    6752\n    >>> fletcher16('onethousandfourhundredthirtyfour')\n    28347\n    >>> fletcher16('The quick brown fox jumps over the lazy dog.')\n    5655\n    \"\"\"\n    data = bytes(text, \"ascii\")\n    sum1 = 0\n    sum2 = 0\n    for character in data:\n        sum1 = (sum1 + character) % 255\n        sum2 = (sum1 + sum2) % 255\n    return (sum2 << 8) | sum1",
    "fixed_code": "def fletcher16(text: str) -> int:\n    \"\"\"\n    Loop through every character in the data and add to two sums.\n\n    >>> fletcher16('hello world')\n    6752\n    >>> fletcher16('onethousandfourhundredthirtyfour')\n    28347\n    >>> fletcher16('The quick brown fox jumps over the lazy dog.')\n    5655\n    \"\"\"\n    data = bytes(text, \"ascii\")\n    sum1 = 0\n    sum2 = 0\n    for character in data:\n        sum1 = (sum1 + character) % 255\n        sum2 = (sum1 + sum2) % 255\n    return (sum2 << 8) | sum1",
    "tests": [
      "assert fletcher16('hello world') == 6752",
      "assert fletcher16('onethousandfourhundredthirtyfour') == 28347",
      "assert fletcher16('The quick brown fox jumps over the lazy dog.') == 5655"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "knapsack/recursive_approach_knapsack.py",
    "function": "knapsack",
    "bug_type": "no_bug",
    "pl": "def knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)",
    "fixed_code": "def knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)",
    "tests": [
      "assert knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0) == 13",
      "assert knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0) == 27"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "other/scoring_algorithm.py",
    "function": "get_data",
    "bug_type": "no_bug",
    "pl": "def get_data(source_data: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])\n    [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]\n    \"\"\"\n    data_lists: list[list[float]] = []\n    for data in source_data:\n        for i, el in enumerate(data):\n            if len(data_lists) < i + 1:\n                data_lists.append([])\n            data_lists[i].append(float(el))\n    return data_lists",
    "fixed_code": "def get_data(source_data: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])\n    [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]\n    \"\"\"\n    data_lists: list[list[float]] = []\n    for data in source_data:\n        for i, el in enumerate(data):\n            if len(data_lists) < i + 1:\n                data_lists.append([])\n            data_lists[i].append(float(el))\n    return data_lists",
    "tests": [
      "assert get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]]) == [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "other/nested_brackets.py",
    "function": "is_balanced",
    "bug_type": "no_bug",
    "pl": "def is_balanced(s: str) -> bool:\n    \"\"\"\n    >>> is_balanced(\"\")\n    True\n    >>> is_balanced(\"()\")\n    True\n    >>> is_balanced(\"[]\")\n    True\n    >>> is_balanced(\"{}\")\n    True\n    >>> is_balanced(\"()[]{}\")\n    True\n    >>> is_balanced(\"(())\")\n    True\n    >>> is_balanced(\"[[\")\n    False\n    >>> is_balanced(\"([{}])\")\n    True\n    >>> is_balanced(\"(()[)]\")\n    False\n    >>> is_balanced(\"([)]\")\n    False\n    >>> is_balanced(\"[[()]]\")\n    True\n    >>> is_balanced(\"(()(()))\")\n    True\n    >>> is_balanced(\"]\")\n    False\n    >>> is_balanced(\"Life is a bowl of cherries.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che{}ies.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che}{ies.\")\n    False\n    \"\"\"\n    open_to_closed = {\"{\": \"}\", \"[\": \"]\", \"(\": \")\"}\n    stack = []\n    for symbol in s:\n        if symbol in open_to_closed:\n            stack.append(symbol)\n        elif symbol in open_to_closed.values() and (\n            not stack or open_to_closed[stack.pop()] != symbol\n        ):\n            return False\n    return not stack  # stack should be empty",
    "fixed_code": "def is_balanced(s: str) -> bool:\n    \"\"\"\n    >>> is_balanced(\"\")\n    True\n    >>> is_balanced(\"()\")\n    True\n    >>> is_balanced(\"[]\")\n    True\n    >>> is_balanced(\"{}\")\n    True\n    >>> is_balanced(\"()[]{}\")\n    True\n    >>> is_balanced(\"(())\")\n    True\n    >>> is_balanced(\"[[\")\n    False\n    >>> is_balanced(\"([{}])\")\n    True\n    >>> is_balanced(\"(()[)]\")\n    False\n    >>> is_balanced(\"([)]\")\n    False\n    >>> is_balanced(\"[[()]]\")\n    True\n    >>> is_balanced(\"(()(()))\")\n    True\n    >>> is_balanced(\"]\")\n    False\n    >>> is_balanced(\"Life is a bowl of cherries.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che{}ies.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che}{ies.\")\n    False\n    \"\"\"\n    open_to_closed = {\"{\": \"}\", \"[\": \"]\", \"(\": \")\"}\n    stack = []\n    for symbol in s:\n        if symbol in open_to_closed:\n            stack.append(symbol)\n        elif symbol in open_to_closed.values() and (\n            not stack or open_to_closed[stack.pop()] != symbol\n        ):\n            return False\n    return not stack  # stack should be empty",
    "tests": [
      "assert is_balanced(\"\") == True",
      "assert is_balanced(\"()\") == True",
      "assert is_balanced(\"[]\") == True",
      "assert is_balanced(\"{}\") == True",
      "assert is_balanced(\"()[]{}\") == True",
      "assert is_balanced(\"(())\") == True",
      "assert is_balanced(\"[[\") == False",
      "assert is_balanced(\"([{}])\") == True",
      "assert is_balanced(\"(()[)]\") == False",
      "assert is_balanced(\"([)]\") == False",
      "assert is_balanced(\"[[()]]\") == True",
      "assert is_balanced(\"(()(()))\") == True",
      "assert is_balanced(\"]\") == False",
      "assert is_balanced(\"Life is a bowl of cherries.\") == True",
      "assert is_balanced(\"Life is a bowl of che{}ies.\") == True",
      "assert is_balanced(\"Life is a bowl of che}{ies.\") == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "other/sdes.py",
    "function": "apply_table",
    "bug_type": "no_bug",
    "pl": "def apply_table(inp, table):\n    \"\"\"\n    >>> apply_table(\"0123456789\", list(range(10)))\n    '9012345678'\n    >>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n    '8765432109'\n    \"\"\"\n    res = \"\"\n    for i in table:\n        res += inp[i - 1]\n    return res",
    "fixed_code": "def apply_table(inp, table):\n    \"\"\"\n    >>> apply_table(\"0123456789\", list(range(10)))\n    '9012345678'\n    >>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n    '8765432109'\n    \"\"\"\n    res = \"\"\n    for i in table:\n        res += inp[i - 1]\n    return res",
    "tests": [
      "assert apply_table(\"0123456789\", list(range(10))) == '9012345678'",
      "assert apply_table(\"0123456789\", list(range(9, -1, -1))) == '8765432109'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "other/sdes.py",
    "function": "left_shift",
    "bug_type": "no_bug",
    "pl": "def left_shift(data):\n    \"\"\"\n    >>> left_shift(\"0123456789\")\n    '1234567890'\n    \"\"\"\n    return data[1:] + data[0]",
    "fixed_code": "def left_shift(data):\n    \"\"\"\n    >>> left_shift(\"0123456789\")\n    '1234567890'\n    \"\"\"\n    return data[1:] + data[0]",
    "tests": [
      "assert left_shift(\"0123456789\") == '1234567890'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "other/sdes.py",
    "function": "xor",
    "bug_type": "no_bug",
    "pl": "def xor(a, b):\n    \"\"\"\n    >>> xor(\"01010101\", \"00001111\")\n    '01011010'\n    \"\"\"\n    res = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            res += \"0\"\n        else:\n            res += \"1\"\n    return res",
    "fixed_code": "def xor(a, b):\n    \"\"\"\n    >>> xor(\"01010101\", \"00001111\")\n    '01011010'\n    \"\"\"\n    res = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            res += \"0\"\n        else:\n            res += \"1\"\n    return res",
    "tests": [
      "assert xor(\"01010101\", \"00001111\") == '01011010'"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "other/alternative_list_arrange.py",
    "function": "alternative_list_arrange",
    "bug_type": "no_bug",
    "pl": "def alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    \"\"\"\n    The method arranges two lists as one list in alternative forms of the list elements.\n    :param first_input_list:\n    :param second_input_list:\n    :return: List\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\n    >>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\n    >>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list",
    "fixed_code": "def alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    \"\"\"\n    The method arranges two lists as one list in alternative forms of the list elements.\n    :param first_input_list:\n    :param second_input_list:\n    :return: List\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\n    >>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\n    >>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list",
    "tests": [
      "assert alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"]) == [1, 'A', 2, 'B', 3, 'C', 4, 5]",
      "assert alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5]) == ['A', 1, 'B', 2, 'C', 3, 4, 5]",
      "assert alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6]) == ['X', 9, 'Y', 8, 'Z', 7, 6]",
      "assert alternative_list_arrange([1, 2, 3, 4, 5], []) == [1, 2, 3, 4, 5]"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "searches/linear_search.py",
    "function": "rec_linear_search",
    "bug_type": "no_bug",
    "pl": "def rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)",
    "fixed_code": "def rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)",
    "tests": [
      "assert rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0) == 0",
      "assert rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700) == 4",
      "assert rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30) == 1",
      "assert rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6) == -1"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "searches/median_of_medians.py",
    "function": "median_of_five",
    "bug_type": "no_bug",
    "pl": "def median_of_five(arr: list) -> int:\n    \"\"\"\n    Return the median of the input list\n    :param arr: Array to find median of\n    :return: median of arr\n\n    >>> median_of_five([2, 4, 5, 7, 899])\n    5\n    >>> median_of_five([5, 7, 899, 54, 32])\n    32\n    >>> median_of_five([5, 4, 3, 2])\n    4\n    >>> median_of_five([3, 5, 7, 10, 2])\n    5\n    \"\"\"\n    arr = sorted(arr)\n    return arr[len(arr) // 2]",
    "fixed_code": "def median_of_five(arr: list) -> int:\n    \"\"\"\n    Return the median of the input list\n    :param arr: Array to find median of\n    :return: median of arr\n\n    >>> median_of_five([2, 4, 5, 7, 899])\n    5\n    >>> median_of_five([5, 7, 899, 54, 32])\n    32\n    >>> median_of_five([5, 4, 3, 2])\n    4\n    >>> median_of_five([3, 5, 7, 10, 2])\n    5\n    \"\"\"\n    arr = sorted(arr)\n    return arr[len(arr) // 2]",
    "tests": [
      "assert median_of_five([2, 4, 5, 7, 899]) == 5",
      "assert median_of_five([5, 7, 899, 54, 32]) == 32",
      "assert median_of_five([5, 4, 3, 2]) == 4",
      "assert median_of_five([3, 5, 7, 10, 2]) == 5"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "backtracking/word_break.py",
    "function": "backtrack",
    "bug_type": "no_bug",
    "pl": "def backtrack(input_string: str, word_dict: set[str], start: int) -> bool:\n    \"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\n\n    # Base case: if the starting index has reached the end of the string\n    if start == len(input_string):\n        return True\n\n    # Try every possible substring from 'start' to 'end'\n    for end in range(start + 1, len(input_string) + 1):\n        if input_string[start:end] in word_dict and backtrack(\n            input_string, word_dict, end\n        ):\n            return True\n\n    return False",
    "fixed_code": "def backtrack(input_string: str, word_dict: set[str], start: int) -> bool:\n    \"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\n\n    # Base case: if the starting index has reached the end of the string\n    if start == len(input_string):\n        return True\n\n    # Try every possible substring from 'start' to 'end'\n    for end in range(start + 1, len(input_string) + 1):\n        if input_string[start:end] in word_dict and backtrack(\n            input_string, word_dict, end\n        ):\n            return True\n\n    return False",
    "tests": [
      "assert backtrack(\"leetcode\", {\"leet\", \"code\"}, 0) == True",
      "assert backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0) == True",
      "assert backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "backtracking/generate_parentheses_iterative.py",
    "function": "generate_parentheses_iterative",
    "bug_type": "no_bug",
    "pl": "def generate_parentheses_iterative(length: int) -> list:\n    \"\"\"\n    Generate all valid combinations of parentheses (Iterative Approach).\n\n    The algorithm works as follows:\n    1. Initialize an empty list to store the combinations.\n    2. Initialize a stack to keep track of partial combinations.\n    3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n    4. While the stack is not empty:\n        a. Pop a partial combination and its open and close counts from the stack.\n        b. If the combination length is equal to 2*length, add it to the result.\n        c. If open count < length, push new combination with added '(' on stack.\n        d. If close count < open count, push new combination with added ')' on stack.\n    5. Return the result containing all valid combinations.\n\n    Args:\n        length: The desired length of the parentheses combinations\n\n    Returns:\n        A list of strings representing valid combinations of parentheses\n\n    Time Complexity:\n        O(2^(2*length))\n\n    Space Complexity:\n        O(2^(2*length))\n\n    >>> generate_parentheses_iterative(3)\n    ['()()()', '()(())', '(())()', '(()())', '((()))']\n    >>> generate_parentheses_iterative(2)\n    ['()()', '(())']\n    >>> generate_parentheses_iterative(1)\n    ['()']\n    >>> generate_parentheses_iterative(0)\n    ['']\n    \"\"\"\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result",
    "fixed_code": "def generate_parentheses_iterative(length: int) -> list:\n    \"\"\"\n    Generate all valid combinations of parentheses (Iterative Approach).\n\n    The algorithm works as follows:\n    1. Initialize an empty list to store the combinations.\n    2. Initialize a stack to keep track of partial combinations.\n    3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n    4. While the stack is not empty:\n        a. Pop a partial combination and its open and close counts from the stack.\n        b. If the combination length is equal to 2*length, add it to the result.\n        c. If open count < length, push new combination with added '(' on stack.\n        d. If close count < open count, push new combination with added ')' on stack.\n    5. Return the result containing all valid combinations.\n\n    Args:\n        length: The desired length of the parentheses combinations\n\n    Returns:\n        A list of strings representing valid combinations of parentheses\n\n    Time Complexity:\n        O(2^(2*length))\n\n    Space Complexity:\n        O(2^(2*length))\n\n    >>> generate_parentheses_iterative(3)\n    ['()()()', '()(())', '(())()', '(()())', '((()))']\n    >>> generate_parentheses_iterative(2)\n    ['()()', '(())']\n    >>> generate_parentheses_iterative(1)\n    ['()']\n    >>> generate_parentheses_iterative(0)\n    ['']\n    \"\"\"\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result",
    "tests": [
      "assert generate_parentheses_iterative(3) == ['()()()', '()(())', '(())()', '(()())', '((()))']",
      "assert generate_parentheses_iterative(2) == ['()()', '(())']",
      "assert generate_parentheses_iterative(1) == ['()']",
      "assert generate_parentheses_iterative(0) == ['']"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "backtracking/word_search.py",
    "function": "get_point_key",
    "bug_type": "no_bug",
    "pl": "def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column",
    "fixed_code": "def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column",
    "tests": [
      "assert get_point_key(10, 20, 1, 0) == 200"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "backtracking/word_search.py",
    "function": "exits_word",
    "bug_type": "no_bug",
    "pl": "def exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False",
    "fixed_code": "def exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False",
    "tests": [
      "assert exits_word([[\"A\"]], \"B\", 0, 0, 0, set()) == False"
    ]
  },
  {
    "commit": "main",
    "commit_msg": "Correct function - no bug",
    "file": "backtracking/match_word_pattern.py",
    "function": "match_word_pattern",
    "bug_type": "no_bug",
    "pl": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)",
    "fixed_code": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)",
    "tests": [
      "assert match_word_pattern(\"aba\", \"GraphTreesGraph\") == True",
      "assert match_word_pattern(\"xyx\", \"PythonRubyPython\") == True",
      "assert match_word_pattern(\"GG\", \"PythonJavaPython\") == False"
    ]
  }
]