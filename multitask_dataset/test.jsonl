{"input": "summarize code:\ndef convert_to_2d(\n    x: float, y: float, z: float, scale: float, distance: float\n) -> tuple[float, float]:\n    \"\"\"\n    Converts 3d point to a 2d drawable point\n\n    >>> convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0)\n    (7.6923076923076925, 15.384615384615385)\n\n    >>> convert_to_2d(1, 2, 3, 10, 10)\n    (7.6923076923076925, 15.384615384615385)\n\n    >>> convert_to_2d(\"1\", 2, 3, 10, 10)  # '1' is str\n    Traceback (most recent call last):\n        ...\n    TypeError: Input values must either be float or int: ['1', 2, 3, 10, 10]\n    \"\"\"\n    if not all(isinstance(val, (float, int)) for val in locals().values()):\n        msg = f\"Input values must either be float or int: {list(locals().values())}\"\n        raise TypeError(msg)\n    projected_x = ((x * distance) / (z + distance)) * scale\n    projected_y = ((y * distance) / (z + distance)) * scale\n    return projected_x, projected_y", "output": "Converts 3d point to a 2d drawable point"}
{"input": "search code:\nReturns area of concave triangle\nChoices:\n0: def concave_triangle_area(circles_number: int) -> float:\n    \"\"\"\n    Returns area of concave triangle\n\n    >>> concave_triangle_area(1)\n    0.026825229575318944\n\n    >>> concave_triangle_area(2)\n    0.01956236140083944\n    \"\"\"\n\n    intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (\n        2 * (circles_number**2 + 1)\n    )\n    intersection_x = circles_number * intersection_y\n\n    triangle_area = intersection_x * intersection_y / 2\n    concave_region_area = circle_bottom_arc_integral(\n        1 / 2\n    ) - circle_bottom_arc_integral(intersection_x)\n\n    return triangle_area + concave_region_area\n1: def calculate_turnaroundtime(\n    burst_time: list[int], no_of_processes: int, waiting_time: list[int]\n) -> list[int]:\n    \"\"\"\n    Calculate the turn around time of each Processes\n    Return: list of turn around times.\n    >>> calculate_turnaroundtime([3,3,5,1], 4, [0,3,5,0])\n    [3, 6, 10, 1]\n    >>> calculate_turnaroundtime([3,3], 2, [0,3])\n    [3, 6]\n    >>> calculate_turnaroundtime([8,10,1], 3, [1,0,3])\n    [9, 10, 4]\n    \"\"\"\n    turn_around_time = [0] * no_of_processes\n    for i in range(no_of_processes):\n        turn_around_time[i] = burst_time[i] + waiting_time[i]\n    return turn_around_time\n2: def mbd(predict, actual):\n    \"\"\"\n    This value is Negative, if the model underpredicts,\n    positive, if it overpredicts.\n\n    Example(rounded for precision):\n\n    Here the model overpredicts\n    >>> actual = [1,2,3];predict = [2,3,4]\n    >>> float(np.around(mbd(predict,actual),decimals = 2))\n    50.0\n\n    Here the model underpredicts\n    >>> actual = [1,2,3];predict = [0,1,1]\n    >>> float(np.around(mbd(predict,actual),decimals = 2))\n    -66.67\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    numerator = np.sum(difference) / len(predict)\n    denumerator = np.sum(actual) / len(predict)\n    # print(numerator, denumerator)\n    score = float(numerator) / denumerator * 100\n\n    return score", "output": "0"}
{"input": "summarize code:\ndef squareplus(vector: np.ndarray, beta: float) -> np.ndarray:\n    \"\"\"\n    Implements the SquarePlus activation function.\n\n    Parameters:\n        vector (np.ndarray): The input array for the SquarePlus activation.\n        beta (float): size of the curved region\n\n    Returns:\n        np.ndarray: The input array after applying the SquarePlus activation.\n\n    Formula: f(x) = ( x + sqrt(x^2 + b) ) / 2\n\n    Examples:\n    >>> squareplus(np.array([2.3, 0.6, -2, -3.8]), beta=2)\n    array([2.5       , 1.06811457, 0.22474487, 0.12731349])\n\n    >>> squareplus(np.array([-9.2, -0.3, 0.45, -4.56]), beta=3)\n    array([0.0808119 , 0.72891979, 1.11977651, 0.15893419])\n    \"\"\"\n    return (vector + np.sqrt(vector**2 + beta)) / 2", "output": "Implements the SquarePlus activation function."}
{"input": "search code:\nReturn first *n* items of the *iterable* as a list.\nChoices:\n0: def take(n, iterable):\n    \"\"\"Return first *n* items of the *iterable* as a list.\n\n        >>> take(3, range(10))\n        [0, 1, 2]\n\n    If there are fewer than *n* items in the iterable, all of them are\n    returned.\n\n        >>> take(10, range(3))\n        [0, 1, 2]\n\n    \"\"\"\n    return list(islice(iterable, n))\n1: def synchronized(func):\n    \"\"\"Wrap an iterator-returning callable to make its iterators thread-safe.\n\n    Existing itertools and more-itertools can be wrapped so that their\n    iterator instances are serialized.\n\n    For example, ``itertools.count`` does not make thread-safe instances,\n    but that is easily fixed with::\n\n        atomic_counter = synchronized(itertools.count)\n\n    Can also be used as a decorator for generator functions definitions\n    so that the generator instances are serialized::\n\n        @synchronized\n        def enumerate_and_timestamp(iterable):\n            for count, value in enumerate(iterable):\n                yield count, time_ns(), value\n\n    \"\"\"\n\n    @wraps(func)\n    def inner(*args, **kwargs):\n        iterator = func(*args, **kwargs)\n        return serialize(iterator)\n\n    return inner\n2: def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value", "output": "0"}
{"input": "summarize code:\ndef rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)", "output": "A pure Python implementation of a recursive linear search algorithm"}
{"input": "summarize code:\ndef column_reshape(input_array: np.ndarray) -> np.ndarray:\n    \"\"\"Function to reshape a row Numpy array into a column Numpy array\n    >>> input_array = np.array([1, 2, 3])\n    >>> column_reshape(input_array)\n    array([[1],\n           [2],\n           [3]])\n    \"\"\"\n\n    return input_array.reshape((input_array.size, 1))", "output": "Function to reshape a row Numpy array into a column Numpy array >>> input_array = np.array([1, 2, 3]) >>> column_reshape(input_array) array([[1], [2], [3]])"}
{"input": "summarize code:\ndef _ngettext_noop(singular, plural):\n    \"\"\"Mark two strings as pluralized translations without translating them.\n\n    Example usage:\n    ```python\n    CONSTANTS = [ngettext_noop('first', 'firsts'), ngettext_noop('second', 'seconds')]\n    def num_name(n):\n        return _ngettext(*CONSTANTS[n])\n    ```\n\n    Args:\n        singular (str): Singular text to translate in the future.\n        plural (str): Plural text to translate in the future.\n\n    Returns:\n        tuple: Original text, unchanged.\n    \"\"\"\n    return (singular, plural)", "output": "Mark two strings as pluralized translations without translating them."}
{"input": "search code:\nReturn an iterator over the last *n* items of *iterable*.\nChoices:\n0: def tail(n, iterable):\n    \"\"\"Return an iterator over the last *n* items of *iterable*.\n\n    >>> t = tail(3, 'ABCDEFG')\n    >>> list(t)\n    ['E', 'F', 'G']\n\n    \"\"\"\n    try:\n        size = len(iterable)\n    except TypeError:\n        return iter(deque(iterable, maxlen=n))\n    else:\n        return islice(iterable, max(0, size - n), None)\n1: def solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares\n2: def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n\n    >>> split(\";abbb;;c;\", separator=';')\n    ['', 'abbb', '', 'c', '']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "0"}
{"input": "summarize code:\ndef power_iteration(\n    input_matrix: np.ndarray,\n    vector: np.ndarray,\n    error_tol: float = 1e-12,\n    max_iterations: int = 100,\n) -> tuple[float, np.ndarray]:\n    \"\"\"\n    Power Iteration.\n    Find the largest eigenvalue and corresponding eigenvector\n    of matrix input_matrix given a random vector in the same space.\n    Will work so long as vector has component of largest eigenvector.\n    input_matrix must be either real or Hermitian.\n\n    Input\n    input_matrix: input matrix whose largest eigenvalue we will find.\n    Numpy array. np.shape(input_matrix) == (N,N).\n    vector: random initial vector in same space as matrix.\n    Numpy array. np.shape(vector) == (N,) or (N,1)\n\n    Output\n    largest_eigenvalue: largest eigenvalue of the matrix input_matrix.\n    Float. Scalar.\n    largest_eigenvector: eigenvector corresponding to largest_eigenvalue.\n    Numpy array. np.shape(largest_eigenvector) == (N,) or (N,1).\n\n    >>> import numpy as np\n    >>> input_matrix = np.array([\n    ... [41,  4, 20],\n    ... [ 4, 26, 30],\n    ... [20, 30, 50]\n    ... ])\n    >>> vector = np.array([41,4,20])\n    >>> power_iteration(input_matrix,vector)\n    (79.66086378788381, array([0.44472726, 0.46209842, 0.76725662]))\n    \"\"\"\n\n    # Ensure matrix is square.\n    assert np.shape(input_matrix)[0] == np.shape(input_matrix)[1]\n    # Ensure proper dimensionality.\n    assert np.shape(input_matrix)[0] == np.shape(vector)[0]\n    # Ensure inputs are either both complex or both real\n    assert np.iscomplexobj(input_matrix) == np.iscomplexobj(vector)\n    is_complex = np.iscomplexobj(input_matrix)\n    if is_complex:\n        # Ensure complex input_matrix is Hermitian\n        assert np.array_equal(input_matrix, input_matrix.conj().T)\n\n    # Set convergence to False. Will define convergence when we exceed max_iterations\n    # or when we have small changes from one iteration to next.\n\n    convergence = False\n    lambda_previous = 0\n    iterations = 0\n    error = 1e12\n\n    while not convergence:\n        # Multiple matrix by the vector.\n        w = np.dot(input_matrix, vector)\n        # Normalize the resulting output vector.\n        vector = w / np.linalg.norm(w)\n        # Find rayleigh quotient\n        # (faster than usual b/c we know vector is normalized already)\n        vector_h = vector.conj().T if is_complex else vector.T\n        lambda_ = np.dot(vector_h, np.dot(input_matrix, vector))\n\n        # Check convergence.\n        error = np.abs(lambda_ - lambda_previous) / lambda_\n        iterations += 1\n\n        if error <= error_tol or iterations >= max_iterations:\n            convergence = True\n\n        lambda_previous = lambda_\n\n    if is_complex:\n        lambda_ = np.real(lambda_)\n\n    return float(lambda_), vector", "output": "Power Iteration. Find the largest eigenvalue and corresponding eigenvector of matrix input_matrix given a random vector in the same space. Will work so long as vector has component of largest eigenvector. input_matrix must be either real or Hermitian."}
{"input": "summarize code:\ndef clone_graph(node: Node | None) -> Node | None:\n    \"\"\"\n    This function returns a clone of a connected undirected graph.\n    >>> clone_graph(Node(1))\n    Node(value=1, neighbors=[])\n    >>> clone_graph(Node(1, [Node(2)]))\n    Node(value=1, neighbors=[Node(value=2, neighbors=[])])\n    >>> clone_graph(None) is None\n    True\n    \"\"\"\n    if not node:\n        return None\n\n    originals_to_clones = {}  # map nodes to clones\n\n    stack = [node]\n\n    while stack:\n        original = stack.pop()\n\n        if original in originals_to_clones:\n            continue\n\n        originals_to_clones[original] = Node(original.value)\n\n        stack.extend(original.neighbors or [])\n\n    for original, clone in originals_to_clones.items():\n        for neighbor in original.neighbors or []:\n            cloned_neighbor = originals_to_clones[neighbor]\n\n            if not clone.neighbors:\n                clone.neighbors = []\n\n            clone.neighbors.append(cloned_neighbor)\n\n    return originals_to_clones[node]", "output": "This function returns a clone of a connected undirected graph. >>> clone_graph(Node(1)) Node(value=1, neighbors=[]) >>> clone_graph(Node(1, [Node(2)])) Node(value=1, neighbors=[Node(value=2, neighbors=[])]) >>> clone_graph(None) is None True"}
{"input": "summarize code:\ndef ugly_numbers(n: int) -> int:\n    \"\"\"\n    Returns the nth ugly number.\n    >>> ugly_numbers(100)\n    1536\n    >>> ugly_numbers(0)\n    1\n    >>> ugly_numbers(20)\n    36\n    >>> ugly_numbers(-5)\n    1\n    >>> ugly_numbers(-5.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    \"\"\"\n    ugly_nums = [1]\n\n    i2, i3, i5 = 0, 0, 0\n    next_2 = ugly_nums[i2] * 2\n    next_3 = ugly_nums[i3] * 3\n    next_5 = ugly_nums[i5] * 5\n\n    for _ in range(1, n):\n        next_num = min(next_2, next_3, next_5)\n        ugly_nums.append(next_num)\n        if next_num == next_2:\n            i2 += 1\n            next_2 = ugly_nums[i2] * 2\n        if next_num == next_3:\n            i3 += 1\n            next_3 = ugly_nums[i3] * 3\n        if next_num == next_5:\n            i5 += 1\n            next_5 = ugly_nums[i5] * 5\n    return ugly_nums[-1]", "output": "Returns the nth ugly number. >>> ugly_numbers(100) 1536 >>> ugly_numbers(0) 1 >>> ugly_numbers(20) 36 >>> ugly_numbers(-5) 1 >>> ugly_numbers(-5.5) Traceback (most recent call last): ... TypeError: 'float' object cannot be interpreted as an integer"}
{"input": "summarize code:\ndef iterate_function(\n    eval_function: Callable[[Any, np.ndarray], np.ndarray],\n    function_params: Any,\n    nb_iterations: int,\n    z_0: np.ndarray,\n    infinity: float | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Iterate the function \"eval_function\" exactly nb_iterations times.\n    The first argument of the function is a parameter which is contained in\n    function_params. The variable z_0 is an array that contains the initial\n    values to iterate from.\n    This function returns the final iterates.\n\n    >>> iterate_function(eval_quadratic_polynomial, 0, 3, np.array([0,1,2])).shape\n    (3,)\n    >>> complex(np.round(iterate_function(eval_quadratic_polynomial,\n    ... 0,\n    ... 3,\n    ... np.array([0,1,2]))[0]))\n    0j\n    >>> complex(np.round(iterate_function(eval_quadratic_polynomial,\n    ... 0,\n    ... 3,\n    ... np.array([0,1,2]))[1]))\n    (1+0j)\n    >>> complex(np.round(iterate_function(eval_quadratic_polynomial,\n    ... 0,\n    ... 3,\n    ... np.array([0,1,2]))[2]))\n    (256+0j)\n    \"\"\"\n\n    z_n = z_0.astype(\"complex64\")\n    for _ in range(nb_iterations):\n        z_n = eval_function(function_params, z_n)\n        if infinity is not None:\n            np.nan_to_num(z_n, copy=False, nan=infinity)\n            z_n[abs(z_n) == np.inf] = infinity\n    return z_n", "output": "Iterate the function \"eval_function\" exactly nb_iterations times. The first argument of the function is a parameter which is contained in function_params. The variable z_0 is an array that contains the initial values to iterate from. This function returns the final iterates."}
{"input": "search code:\nReturn the solution of the problem. >>> solution() 296962999629\nChoices:\n0: def get_set_bits_count_using_brian_kernighans_algorithm(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(25)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(37)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(21)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(58)\n    4\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(0)\n    0\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(256)\n    1\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must not be negative\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"the value of input must not be negative\")\n    result = 0\n    while number:\n        number &= number - 1\n        result += 1\n    return result\n1: def solution():\n    \"\"\"\n    Return the solution of the problem.\n    >>> solution()\n    296962999629\n    \"\"\"\n    prime_list = [n for n in range(1001, 10000, 2) if is_prime(n)]\n    candidates = []\n\n    for number in prime_list:\n        tmp_numbers = []\n\n        for prime_member in permutations(list(str(number))):\n            prime = int(\"\".join(prime_member))\n\n            if prime % 2 == 0:\n                continue\n\n            if search(prime, prime_list):\n                tmp_numbers.append(prime)\n\n        tmp_numbers.sort()\n        if len(tmp_numbers) >= 3:\n            candidates.append(tmp_numbers)\n\n    passed = []\n    for candidate in candidates:\n        length = len(candidate)\n        found = False\n\n        for i in range(length):\n            for j in range(i + 1, length):\n                for k in range(j + 1, length):\n                    if (\n                        abs(candidate[i] - candidate[j])\n                        == abs(candidate[j] - candidate[k])\n                        and len({candidate[i], candidate[j], candidate[k]}) == 3\n                    ):\n                        passed.append(\n                            sorted([candidate[i], candidate[j], candidate[k]])\n                        )\n                        found = True\n\n                    if found:\n                        break\n                if found:\n                    break\n            if found:\n                break\n\n    answer = set()\n    for seq in passed:\n        answer.add(\"\".join([str(i) for i in seq]))\n\n    return max(int(x) for x in answer)\n2: def tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)", "output": "1"}
{"input": "search code:\nComputes a^b % c recursively, where a is the base, b is the exponent, and c is the modulus\nChoices:\n0: def matmul(m1, m2):\n    \"\"\"Multiply two matrices.\n\n    >>> list(matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]))\n    [(49, 80), (41, 60)]\n\n    The caller should ensure that the dimensions of the input matrices are\n    compatible with each other.\n\n    Supports all numeric types: int, float, complex, Decimal, Fraction.\n    \"\"\"\n    n = len(m2[0])\n    return batched(starmap(_sumprod, product(m1, transpose(m2))), n)\n1: def binary_exp_mod_recursive(base: float, exponent: int, modulus: int) -> float:\n    \"\"\"\n    Computes a^b % c recursively, where a is the base, b is the exponent, and c is the\n    modulus\n\n    >>> binary_exp_mod_recursive(3, 4, 5)\n    1\n    >>> binary_exp_mod_recursive(11, 13, 7)\n    4\n    >>> binary_exp_mod_recursive(1.5, 4, 3)\n    2.0625\n    >>> binary_exp_mod_recursive(7, -1, 10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exponent must be a non-negative integer\n    >>> binary_exp_mod_recursive(7, 13, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Modulus must be a positive integer\n    \"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer\")\n\n    if exponent == 0:\n        return 1\n\n    if exponent % 2 == 1:\n        return (binary_exp_mod_recursive(base, exponent - 1, modulus) * base) % modulus\n\n    r = binary_exp_mod_recursive(base, exponent // 2, modulus)\n    return (r * r) % modulus\n2: def multiplication_table(number: int, number_of_terms: int) -> str:\n    \"\"\"\n    Prints the multiplication table of a given number till the given number of terms\n\n    >>> print(multiplication_table(3, 5))\n    3 * 1 = 3\n    3 * 2 = 6\n    3 * 3 = 9\n    3 * 4 = 12\n    3 * 5 = 15\n\n    >>> print(multiplication_table(-4, 6))\n    -4 * 1 = -4\n    -4 * 2 = -8\n    -4 * 3 = -12\n    -4 * 4 = -16\n    -4 * 5 = -20\n    -4 * 6 = -24\n    \"\"\"\n    return \"\\n\".join(\n        f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)\n    )", "output": "1"}
{"input": "summarize code:\ndef reverse_letters(sentence: str, length: int = 0) -> str:\n    \"\"\"\n    Reverse all words that are longer than the given length of characters in a sentence.\n    If unspecified, length is taken as 0\n\n    >>> reverse_letters(\"Hey wollef sroirraw\", 3)\n    'Hey fellow warriors'\n    >>> reverse_letters(\"nohtyP is nohtyP\", 2)\n    'Python is Python'\n    >>> reverse_letters(\"1 12 123 1234 54321 654321\", 0)\n    '1 21 321 4321 12345 123456'\n    >>> reverse_letters(\"racecar\")\n    'racecar'\n    \"\"\"\n    return \" \".join(\n        \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()\n    )", "output": "Reverse all words that are longer than the given length of characters in a sentence. If unspecified, length is taken as 0"}
{"input": "summarize code:\ndef find_triplets_with_0_sum_hashing(arr: list[int]) -> list[list[int]]:\n    \"\"\"\n    Function for finding the triplets with a given sum in the array using hashing.\n\n    Given a list of integers, return elements a, b, c such that a + b + c = 0.\n\n    Args:\n        nums: list of integers\n    Returns:\n        list of lists of integers where sum(each_list) == 0\n    Examples:\n        >>> find_triplets_with_0_sum_hashing([-1, 0, 1, 2, -1, -4])\n        [[-1, 0, 1], [-1, -1, 2]]\n        >>> find_triplets_with_0_sum_hashing([])\n        []\n        >>> find_triplets_with_0_sum_hashing([0, 0, 0])\n        [[0, 0, 0]]\n        >>> find_triplets_with_0_sum_hashing([1, 2, 3, 0, -1, -2, -3])\n        [[-1, 0, 1], [-3, 1, 2], [-2, 0, 2], [-2, -1, 3], [-3, 0, 3]]\n\n    Time complexity: O(N^2)\n    Auxiliary Space: O(N)\n\n    \"\"\"\n    target_sum = 0\n\n    # Initialize the final output array with blank.\n    output_arr = []\n\n    # Set the initial element as arr[i].\n    for index, item in enumerate(arr[:-2]):\n        # to store second elements that can complement the final sum.\n        set_initialize = set()\n\n        # current sum needed for reaching the target sum\n        current_sum = target_sum - item\n\n        # Traverse the subarray arr[i+1:].\n        for other_item in arr[index + 1 :]:\n            # required value for the second element\n            required_value = current_sum - other_item\n\n            # Verify if the desired value exists in the set.\n            if required_value in set_initialize:\n                # finding triplet elements combination.\n                combination_array = sorted([item, other_item, required_value])\n                if combination_array not in output_arr:\n                    output_arr.append(combination_array)\n\n            # Include the current element in the set\n            # for subsequent complement verification.\n            set_initialize.add(other_item)\n\n    # Return all the triplet combinations.\n    return output_arr", "output": "Function for finding the triplets with a given sum in the array using hashing."}
{"input": "summarize code:\ndef generate_parameters(formula: Formula) -> tuple[list[Clause], list[str]]:\n    \"\"\"\n    | Return the clauses and symbols from a formula.\n    | A symbol is the uncomplemented form of a literal.\n\n    For example,\n      * Symbol of A3 is A3.\n      * Symbol of A5' is A5.\n\n    >>> formula = Formula([Clause([\"A1\", \"A2'\", \"A3\"]), Clause([\"A5'\", \"A2'\", \"A1\"])])\n    >>> clauses, symbols = generate_parameters(formula)\n    >>> clauses_list = [str(i) for i in clauses]\n    >>> clauses_list\n    [\"{A1 , A2' , A3}\", \"{A5' , A2' , A1}\"]\n    >>> symbols\n    ['A1', 'A2', 'A3', 'A5']\n    \"\"\"\n    clauses = formula.clauses\n    symbols_set = []\n    for clause in formula.clauses:\n        for literal in clause.literals:\n            symbol = literal[:2]\n            if symbol not in symbols_set:\n                symbols_set.append(symbol)\n    return clauses, symbols_set", "output": "| Return the clauses and symbols from a formula. | A symbol is the uncomplemented form of a literal."}
{"input": "summarize code:\ndef recursive_lucas_number(n_th_number: int) -> int:\n    \"\"\"\n    Returns the nth lucas number\n    >>> recursive_lucas_number(1)\n    1\n    >>> recursive_lucas_number(20)\n    15127\n    >>> recursive_lucas_number(0)\n    2\n    >>> recursive_lucas_number(25)\n    167761\n    >>> recursive_lucas_number(-1.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: recursive_lucas_number accepts only integer arguments.\n    \"\"\"\n    if not isinstance(n_th_number, int):\n        raise TypeError(\"recursive_lucas_number accepts only integer arguments.\")\n    if n_th_number == 0:\n        return 2\n    if n_th_number == 1:\n        return 1\n\n    return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(\n        n_th_number - 2\n    )", "output": "Returns the nth lucas number >>> recursive_lucas_number(1) 1 >>> recursive_lucas_number(20) 15127 >>> recursive_lucas_number(0) 2 >>> recursive_lucas_number(25) 167761 >>> recursive_lucas_number(-1.5) Traceback (most recent call last): ... TypeError: recursive_lucas_number accepts only integer arguments."}
{"input": "summarize code:\ndef search_scraper(anime_name: str) -> list:\n    \"\"\"[summary]\n\n    Take an url and\n    return list of anime after scraping the site.\n\n    >>> type(search_scraper(\"demon_slayer\"))\n    <class 'list'>\n\n    Args:\n        anime_name (str): [Name of anime]\n\n    Raises:\n        e: [Raises exception on failure]\n\n    Returns:\n        [list]: [List of animes]\n    \"\"\"\n\n    # concat the name to form the search url.\n    search_url = f\"{BASE_URL}/search?keyword={anime_name}\"\n\n    response = httpx.get(\n        search_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10\n    )  # request the url.\n\n    # Is the response ok?\n    response.raise_for_status()\n\n    # parse with soup.\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    # get list of anime\n    anime_ul = soup.find(\"ul\", {\"class\": \"items\"})\n    if anime_ul is None or isinstance(anime_ul, NavigableString):\n        msg = f\"Could not find and anime with name {anime_name}\"\n        raise ValueError(msg)\n    anime_li = anime_ul.children\n\n    # for each anime, insert to list. the name and url.\n    anime_list = []\n    for anime in anime_li:\n        if isinstance(anime, Tag):\n            anime_url = anime.find(\"a\")\n            if anime_url is None or isinstance(anime_url, NavigableString):\n                continue\n            anime_title = anime.find(\"a\")\n            if anime_title is None or isinstance(anime_title, NavigableString):\n                continue\n\n            anime_list.append({\"title\": anime_title[\"title\"], \"url\": anime_url[\"href\"]})\n\n    return anime_list", "output": "[summary]"}
{"input": "summarize code:\ndef circular_shifts(iterable, steps=1):\n    \"\"\"Yield the circular shifts of *iterable*.\n\n    >>> list(circular_shifts(range(4)))\n    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n\n    Set *steps* to the number of places to rotate to the left\n    (or to the right if negative).  Defaults to 1.\n\n    >>> list(circular_shifts(range(4), 2))\n    [(0, 1, 2, 3), (2, 3, 0, 1)]\n\n    >>> list(circular_shifts(range(4), -1))\n    [(0, 1, 2, 3), (3, 0, 1, 2), (2, 3, 0, 1), (1, 2, 3, 0)]\n\n    \"\"\"\n    buffer = deque(iterable)\n    if steps == 0:\n        raise ValueError('Steps should be a non-zero integer')\n\n    buffer.rotate(steps)\n    steps = -steps\n    n = len(buffer)\n    n //= math.gcd(n, steps)\n\n    for _ in repeat(None, n):\n        buffer.rotate(steps)\n        yield tuple(buffer)", "output": "Yield the circular shifts of *iterable*."}
{"input": "search code:\nReturns two maps of (*types*, *funcs*) from *mod*, optionally ignoring based on the :class:`bool` return value of the *ignore* callable. *mod* can be a string name of a module in :data:`sys.modules` or the module instance itself.\nChoices:\n0: def repeat_each(iterable, n=2):\n    \"\"\"Repeat each element in *iterable* *n* times.\n\n    >>> list(repeat_each('ABC', 3))\n    ['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C']\n    \"\"\"\n    return chain.from_iterable(map(repeat, iterable, repeat(n)))\n1: def get_module_callables(mod, ignore=None):\n    \"\"\"Returns two maps of (*types*, *funcs*) from *mod*, optionally\n    ignoring based on the :class:`bool` return value of the *ignore*\n    callable. *mod* can be a string name of a module in\n    :data:`sys.modules` or the module instance itself.\n    \"\"\"\n    if isinstance(mod, str):\n        mod = sys.modules[mod]\n    types, funcs = {}, {}\n    for attr_name in dir(mod):\n        if ignore and ignore(attr_name):\n            continue\n        try:\n            attr = getattr(mod, attr_name)\n        except Exception:\n            continue\n        try:\n            attr_mod_name = attr.__module__\n        except AttributeError:\n            continue\n        if attr_mod_name != mod.__name__:\n            continue\n        if isinstance(attr, type):\n            types[attr_name] = attr\n        elif callable(attr):\n            funcs[attr_name] = attr\n    return types, funcs\n2: def assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:\n    \"\"\"\n    Assembles the transformations based on the ops table.\n\n    >>> ops = [['0', 'Ic', 'Iu', 'It'],\n    ...        ['Dc', 'Cc', 'Iu', 'It'],\n    ...        ['Da', 'Da', 'Rau', 'Rat'],\n    ...        ['Dt', 'Dt', 'Rtu', 'Ct']]\n    >>> x = len(ops) - 1\n    >>> y = len(ops[0]) - 1\n    >>> assemble_transformation(ops, x, y)\n    ['Cc', 'Rau', 'Ct']\n\n    >>> ops1 = [['0']]\n    >>> x1 = len(ops1) - 1\n    >>> y1 = len(ops1[0]) - 1\n    >>> assemble_transformation(ops1, x1, y1)\n    []\n\n    >>> ops2 = [['0', 'I1', 'I2', 'I3'],\n    ...         ['D1', 'C1', 'I2', 'I3'],\n    ...         ['D2', 'D2', 'R23', 'R23']]\n    >>> x2 = len(ops2) - 1\n    >>> y2 = len(ops2[0]) - 1\n    >>> assemble_transformation(ops2, x2, y2)\n    ['C1', 'I2', 'R23']\n    \"\"\"\n    if i == 0 and j == 0:\n        return []\n    elif ops[i][j][0] in {\"C\", \"R\"}:\n        seq = assemble_transformation(ops, i - 1, j - 1)\n        seq.append(ops[i][j])\n        return seq\n    elif ops[i][j][0] == \"D\":\n        seq = assemble_transformation(ops, i - 1, j)\n        seq.append(ops[i][j])\n        return seq\n    else:\n        seq = assemble_transformation(ops, i, j - 1)\n        seq.append(ops[i][j])\n        return seq", "output": "1"}
{"input": "summarize code:\ndef non_bouncy_exact(n: int) -> int:\n    \"\"\"\n    Calculate the number of non-bouncy numbers with at most n digits.\n    >>> non_bouncy_exact(1)\n    9\n    >>> non_bouncy_exact(6)\n    7998\n    >>> non_bouncy_exact(10)\n    136126\n    \"\"\"\n    return choose(8 + n, n) + choose(9 + n, n) - 10", "output": "Calculate the number of non-bouncy numbers with at most n digits. >>> non_bouncy_exact(1) 9 >>> non_bouncy_exact(6) 7998 >>> non_bouncy_exact(10) 136126"}
{"input": "summarize code:\ndef distinct_combinations(iterable, r):\n    \"\"\"Yield the distinct combinations of *r* items taken from *iterable*.\n\n        >>> list(distinct_combinations([0, 0, 1], 2))\n        [(0, 0), (0, 1)]\n\n    Equivalent to ``set(combinations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    \"\"\"\n    if r < 0:\n        raise ValueError('r must be non-negative')\n    elif r == 0:\n        yield ()\n        return\n    pool = tuple(iterable)\n    generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]\n    current_combo = [None] * r\n    level = 0\n    while generators:\n        try:\n            cur_idx, p = next(generators[-1])\n        except StopIteration:\n            generators.pop()\n            level -= 1\n            continue\n        current_combo[level] = p\n        if level + 1 == r:\n            yield tuple(current_combo)\n        else:\n            generators.append(\n                unique_everseen(\n                    enumerate(pool[cur_idx + 1 :], cur_idx + 1),\n                    key=itemgetter(1),\n                )\n            )\n            level += 1", "output": "Yield the distinct combinations of *r* items taken from *iterable*."}
{"input": "summarize code:\ndef detect_high_low_threshold(\n    image_shape, destination, threshold_low, threshold_high, weak, strong\n):\n    \"\"\"\n    High-Low threshold detection. If an edge pixel's gradient value is higher\n    than the high threshold value, it is marked as a strong edge pixel. If an\n    edge pixel's gradient value is smaller than the high threshold value and\n    larger than the low threshold value, it is marked as a weak edge pixel. If\n    an edge pixel's value is smaller than the low threshold value, it will be\n    suppressed.\n    \"\"\"\n    for row in range(1, image_shape[0] - 1):\n        for col in range(1, image_shape[1] - 1):\n            if destination[row, col] >= threshold_high:\n                destination[row, col] = strong\n            elif destination[row, col] <= threshold_low:\n                destination[row, col] = 0\n            else:\n                destination[row, col] = weak", "output": "High-Low threshold detection. If an edge pixel's gradient value is higher than the high threshold value, it is marked as a strong edge pixel. If an edge pixel's gradient value is smaller than the high threshold value and larger than the low threshold value, it is marked as a weak edge pixel. If an edge pixel's value is smaller than the low threshold value, it will be suppressed."}
{"input": "search code:\nThis function checks the grid to see if each row, column, and the 3x3 subgrids contain the digit 'n'. It returns False if it is not 'safe' (a duplicate digit is found) else returns True if it is 'safe'\nChoices:\n0: def is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:\n    \"\"\"\n    This function checks the grid to see if each row,\n    column, and the 3x3 subgrids contain the digit 'n'.\n    It returns False if it is not 'safe' (a duplicate digit\n    is found) else returns True if it is 'safe'\n    \"\"\"\n    for i in range(9):\n        if n in {grid[row][i], grid[i][column]}:\n            return False\n\n    for i in range(3):\n        for j in range(3):\n            if grid[(row - row % 3) + i][(column - column % 3) + j] == n:\n                return False\n\n    return True\n1: def build_tree() -> TreeNode:\n    \"\"\"\n    Build and return a sample binary tree.\n\n    Returns:\n        TreeNode: The root of the binary tree.\n\n    Examples:\n        >>> root = build_tree()\n        >>> root.data\n        1\n        >>> root.left.data\n        2\n        >>> root.right.data\n        5\n        >>> root.left.left.data\n        3\n        >>> root.left.right.data\n        4\n        >>> root.right.right.data\n        6\n    \"\"\"\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(5)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.right = TreeNode(6)\n    return root\n2: def chunked_even(iterable, n):\n    \"\"\"Break *iterable* into lists of approximately length *n*.\n    Items are distributed such the lengths of the lists differ by at most\n    1 item.\n\n    >>> iterable = [1, 2, 3, 4, 5, 6, 7]\n    >>> n = 3\n    >>> list(chunked_even(iterable, n))  # List lengths: 3, 2, 2\n    [[1, 2, 3], [4, 5], [6, 7]]\n    >>> list(chunked(iterable, n))  # List lengths: 3, 3, 1\n    [[1, 2, 3], [4, 5, 6], [7]]\n\n    \"\"\"\n    iterator = iter(iterable)\n\n    # Initialize a buffer to process the chunks while keeping\n    # some back to fill any underfilled chunks\n    min_buffer = (n - 1) * (n - 2)\n    buffer = list(islice(iterator, min_buffer))\n\n    # Append items until we have a completed chunk\n    for _ in islice(map(buffer.append, iterator), n, None, n):\n        yield buffer[:n]\n        del buffer[:n]\n\n    # Check if any chunks need addition processing\n    if not buffer:\n        return\n    length = len(buffer)\n\n    # Chunks are either size `full_size <= n` or `partial_size = full_size - 1`\n    q, r = divmod(length, n)\n    num_lists = q + (1 if r > 0 else 0)\n    q, r = divmod(length, num_lists)\n    full_size = q + (1 if r > 0 else 0)\n    partial_size = full_size - 1\n    num_full = length - partial_size * num_lists\n\n    # Yield chunks of full size\n    partial_start_idx = num_full * full_size\n    if full_size > 0:\n        for i in range(0, partial_start_idx, full_size):\n            yield buffer[i : i + full_size]\n\n    # Yield chunks of partial size\n    if partial_size > 0:\n        for i in range(partial_start_idx, length, partial_size):\n            yield buffer[i : i + partial_size]", "output": "0"}
{"input": "summarize code:\ndef electrical_impedance(\n    resistance: float, reactance: float, impedance: float\n) -> dict[str, float]:\n    \"\"\"\n    Apply Electrical Impedance formula, on any two given electrical values,\n    which can be resistance, reactance, and impedance, and then in a Python dict\n    return name/value pair of the zero value.\n\n    >>> electrical_impedance(3,4,0)\n    {'impedance': 5.0}\n    >>> electrical_impedance(0,4,5)\n    {'resistance': 3.0}\n    >>> electrical_impedance(3,0,5)\n    {'reactance': 4.0}\n    >>> electrical_impedance(3,4,5)\n    Traceback (most recent call last):\n      ...\n    ValueError: One and only one argument must be 0\n    \"\"\"\n    if (resistance, reactance, impedance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if resistance == 0:\n        return {\"resistance\": sqrt(pow(impedance, 2) - pow(reactance, 2))}\n    elif reactance == 0:\n        return {\"reactance\": sqrt(pow(impedance, 2) - pow(resistance, 2))}\n    elif impedance == 0:\n        return {\"impedance\": sqrt(pow(resistance, 2) + pow(reactance, 2))}\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")", "output": "Apply Electrical Impedance formula, on any two given electrical values, which can be resistance, reactance, and impedance, and then in a Python dict return name/value pair of the zero value."}
{"input": "search code:\nOptional method: interquatile range input : list of total user in float output : low limit of input in float this method can be used to check whether some data is outlier or not >>> interquartile_range_checker([1,2,3,4,5,6,7,8,9,10]) 2.8\nChoices:\n0: def create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]\n1: def interquartile_range_checker(train_user: list) -> float:\n    \"\"\"\n    Optional method: interquatile range\n    input : list of total user in float\n    output : low limit of input in float\n    this method can be used to check whether some data is outlier or not\n    >>> interquartile_range_checker([1,2,3,4,5,6,7,8,9,10])\n    2.8\n    \"\"\"\n    train_user.sort()\n    q1 = np.percentile(train_user, 25)\n    q3 = np.percentile(train_user, 75)\n    iqr = q3 - q1\n    low_lim = q1 - (iqr * 0.1)\n    return float(low_lim)\n2: def split_format_str(fstr):\n    \"\"\"Does very basic splitting of a format string, returns a list of\n    strings. For full tokenization, see :func:`tokenize_format_str`.\n\n    \"\"\"\n    ret = []\n\n    for lit, fname, fspec, conv in Formatter().parse(fstr):\n        if fname is None:\n            ret.append((lit, None))\n            continue\n        field_str = construct_format_field_str(fname, fspec, conv)\n        ret.append((lit, field_str))\n    return ret", "output": "1"}
{"input": "search code:\nImplement sin function.\nChoices:\n0: def find_min_iterative(nums: list[int | float]) -> int | float:\n    \"\"\"\n    Find Minimum Number in a List\n    :param nums: contains elements\n    :return: min number in list\n\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n    ...     find_min_iterative(nums) == min(nums)\n    True\n    True\n    True\n    True\n    >>> find_min_iterative([0, 1, 2, 3, 4, 5, -3, 24, -56])\n    -56\n    >>> find_min_iterative([])\n    Traceback (most recent call last):\n        ...\n    ValueError: find_min_iterative() arg is an empty sequence\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"find_min_iterative() arg is an empty sequence\")\n    min_num = nums[0]\n    for num in nums:\n        min_num = min(min_num, num)\n    return min_num\n1: def sin(\n    angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10\n) -> float:\n    \"\"\"\n    Implement sin function.\n\n    >>> sin(0.0)\n    0.0\n    >>> sin(90.0)\n    1.0\n    >>> sin(180.0)\n    0.0\n    >>> sin(270.0)\n    -1.0\n    >>> sin(0.68)\n    0.0118679603\n    >>> sin(1.97)\n    0.0343762121\n    >>> sin(64.0)\n    0.8987940463\n    >>> sin(9999.0)\n    -0.9876883406\n    >>> sin(-689.0)\n    0.5150380749\n    >>> sin(89.7)\n    0.9999862922\n    \"\"\"\n    # Simplify the angle to be between 360 and -360 degrees.\n    angle_in_degrees = angle_in_degrees - ((angle_in_degrees // 360.0) * 360.0)\n\n    # Converting from degrees to radians\n    angle_in_radians = radians(angle_in_degrees)\n\n    result = angle_in_radians\n    a = 3\n    b = -1\n\n    for _ in range(accuracy):\n        result += (b * (angle_in_radians**a)) / factorial(a)\n\n        b = -b  # One positive term and the next will be negative and so on...\n        a += 2  # Increased by 2 for every term.\n\n    return round(result, rounded_values_count)\n2: def inspect_formatargspec(\n        args, varargs=None, varkw=None, defaults=None,\n        kwonlyargs=(), kwonlydefaults={}, annotations={},\n        formatarg=str,\n        formatvarargs=lambda name: '*' + name,\n        formatvarkw=lambda name: '**' + name,\n        formatvalue=lambda value: '=' + repr(value),\n        formatreturns=lambda text: ' -> ' + text,\n        formatannotation=formatannotation):\n    \"\"\"Copy formatargspec from python 3.7 standard library.\n    Python 3 has deprecated formatargspec and requested that Signature\n    be used instead, however this requires a full reimplementation\n    of formatargspec() in terms of creating Parameter objects and such.\n    Instead of introducing all the object-creation overhead and having\n    to reinvent from scratch, just copy their compatibility routine.\n    \"\"\"\n\n    def formatargandannotation(arg):\n        result = formatarg(arg)\n        if arg in annotations:\n            result += ': ' + formatannotation(annotations[arg])\n        return result\n    specs = []\n    if defaults:\n        firstdefault = len(args) - len(defaults)\n    for i, arg in enumerate(args):\n        spec = formatargandannotation(arg)\n        if defaults and i >= firstdefault:\n            spec = spec + formatvalue(defaults[i - firstdefault])\n        specs.append(spec)\n    if varargs is not None:\n        specs.append(formatvarargs(formatargandannotation(varargs)))\n    else:\n        if kwonlyargs:\n            specs.append('*')\n    if kwonlyargs:\n        for kwonlyarg in kwonlyargs:\n            spec = formatargandannotation(kwonlyarg)\n            if kwonlydefaults and kwonlyarg in kwonlydefaults:\n                spec += formatvalue(kwonlydefaults[kwonlyarg])\n            specs.append(spec)\n    if varkw is not None:\n        specs.append(formatvarkw(formatargandannotation(varkw)))\n    result = '(' + ', '.join(specs) + ')'\n    if 'return' in annotations:\n        result += formatreturns(formatannotation(annotations['return']))\n    return result", "output": "1"}
{"input": "search code:\nStrips values from the beginning and end of an iterable. Stripped items will match the value of the argument strip_value. Functionality is analogous to that of the method str.strip. Returns a generator.\nChoices:\n0: def solution(max_d: int = 12_000) -> int:\n    \"\"\"\n    Returns number of fractions lie between 1/3 and 1/2 in the sorted set\n    of reduced proper fractions for d â‰¤ max_d\n\n    >>> solution(4)\n    0\n\n    >>> solution(5)\n    1\n\n    >>> solution(8)\n    3\n    \"\"\"\n\n    fractions_number = 0\n    for d in range(max_d + 1):\n        n_start = d // 3 + 1\n        n_step = 1\n        if d % 2 == 0:\n            n_start += 1 - n_start % 2\n            n_step = 2\n        for n in range(n_start, (d + 1) // 2, n_step):\n            if gcd(n, d) == 1:\n                fractions_number += 1\n    return fractions_number\n1: def is_happy_number(number: int) -> bool:\n    \"\"\"\n    A happy number is a number which eventually reaches 1 when replaced by the sum of\n    the square of each digit.\n\n    :param number: The number to check for happiness.\n    :return: True if the number is a happy number, False otherwise.\n\n    >>> is_happy_number(19)\n    True\n    >>> is_happy_number(2)\n    False\n    >>> is_happy_number(23)\n    True\n    >>> is_happy_number(1)\n    True\n    >>> is_happy_number(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: number=0 must be a positive integer\n    >>> is_happy_number(-19)\n    Traceback (most recent call last):\n        ...\n    ValueError: number=-19 must be a positive integer\n    >>> is_happy_number(19.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number=19.1 must be a positive integer\n    >>> is_happy_number(\"happy\")\n    Traceback (most recent call last):\n        ...\n    ValueError: number='happy' must be a positive integer\n    \"\"\"\n    if not isinstance(number, int) or number <= 0:\n        msg = f\"{number=} must be a positive integer\"\n        raise ValueError(msg)\n\n    seen = set()\n    while number != 1 and number not in seen:\n        seen.add(number)\n        number = sum(int(digit) ** 2 for digit in str(number))\n    return number == 1\n2: def strip_iter(iterable, strip_value=None):\n    \"\"\"Strips values from the beginning and end of an iterable. Stripped items\n    will match the value of the argument strip_value. Functionality is\n    analogous to that of the method str.strip. Returns a generator.\n\n    >>> list(strip_iter(['Fu', 'Foo', 'Bar', 'Bam', 'Fu'], 'Fu'))\n    ['Foo', 'Bar', 'Bam']\n\n    \"\"\"\n    return rstrip_iter(lstrip_iter(iterable, strip_value), strip_value)", "output": "2"}
{"input": "summarize code:\ndef unzip(iterable):\n    \"\"\"The inverse of :func:`zip`, this function disaggregates the elements\n    of the zipped *iterable*.\n\n    The ``i``-th iterable contains the ``i``-th element from each element\n    of the zipped iterable. The first element is used to determine the\n    length of the remaining elements.\n\n        >>> iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> letters, numbers = unzip(iterable)\n        >>> list(letters)\n        ['a', 'b', 'c', 'd']\n        >>> list(numbers)\n        [1, 2, 3, 4]\n\n    This is similar to using ``zip(*iterable)``, but it avoids reading\n    *iterable* into memory. Note, however, that this function uses\n    :func:`itertools.tee` and thus may require significant storage.\n\n    \"\"\"\n    head, iterable = spy(iterable)\n    if not head:\n        # empty iterable, e.g. zip([], [], [])\n        return ()\n    # spy returns a one-length iterable as head\n    head = head[0]\n    iterables = tee(iterable, len(head))\n\n    # If we have an iterable like iter([(1, 2, 3), (4, 5), (6,)]),\n    # the second unzipped iterable fails at the third tuple since\n    # it tries to access (6,)[1].\n    # Same with the third unzipped iterable and the second tuple.\n    # To support these \"improperly zipped\" iterables, we suppress\n    # the IndexError, which just stops the unzipped iterables at\n    # first length mismatch.\n    return tuple(\n        iter_suppress(map(itemgetter(i), it), IndexError)\n        for i, it in enumerate(iterables)\n    )", "output": "The inverse of :func:`zip`, this function disaggregates the elements of the zipped *iterable*."}
{"input": "search code:\nConvert a frequency in Hertz to the mel scale.\nChoices:\n0: def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n\n    >>> split(\";abbb;;c;\", separator=';')\n    ['', 'abbb', '', 'c', '']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words\n1: def freq_to_mel(freq: float) -> float:\n    \"\"\"\n    Convert a frequency in Hertz to the mel scale.\n\n    Args:\n        freq: The frequency in Hertz.\n\n    Returns:\n        The frequency in mel scale.\n\n    Examples:\n    >>> float(round(freq_to_mel(1000), 2))\n    999.99\n    \"\"\"\n    # Use the formula to convert frequency to the mel scale\n    return 2595.0 * np.log10(1.0 + freq / 700.0)\n2: def permute_backtrack(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Return all permutations of the given list.\n\n    >>> permute_backtrack([1, 2, 3])\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]\n    \"\"\"\n\n    def backtrack(start: int) -> None:\n        if start == len(nums) - 1:\n            output.append(nums[:])\n        else:\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack\n\n    output: list[list[int]] = []\n    backtrack(0)\n    return output", "output": "1"}
{"input": "summarize code:\ndef astable_duty_cycle(resistance_1: float, resistance_2: float) -> float:\n    \"\"\"\n    Usage examples:\n    >>> astable_duty_cycle(resistance_1=45, resistance_2=45)\n    66.66666666666666\n    >>> astable_duty_cycle(resistance_1=356, resistance_2=234)\n    71.60194174757282\n    >>> astable_duty_cycle(resistance_1=2, resistance_2=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be positive\n    >>> astable_duty_cycle(resistance_1=0, resistance_2=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be positive\n    \"\"\"\n\n    if resistance_1 <= 0 or resistance_2 <= 0:\n        raise ValueError(\"All values must be positive\")\n    return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100", "output": "Usage examples: >>> astable_duty_cycle(resistance_1=45, resistance_2=45) 66.66666666666666 >>> astable_duty_cycle(resistance_1=356, resistance_2=234) 71.60194174757282 >>> astable_duty_cycle(resistance_1=2, resistance_2=-1) Traceback (most recent call last): ... ValueError: All values must be positive >>> astable_duty_cycle(resistance_1=0, resistance_2=0) Traceback (most recent call last): ... ValueError: All values must be positive"}
{"input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\nChoices:\n0: def solution(n: int = 1000000) -> int:\n    \"\"\"Returns the number under n that generates the longest sequence using the\n    formula:\n    n â†’ n/2 (n is even)\n    n â†’ 3n + 1 (n is odd)\n\n    >>> solution(1000000)\n    837799\n    >>> solution(200)\n    171\n    >>> solution(5000)\n    3711\n    >>> solution(15000)\n    13255\n    \"\"\"\n    largest_number = 1\n    pre_counter = 1\n    counters = {1: 1}\n\n    for input1 in range(2, n):\n        counter = 0\n        number = input1\n\n        while True:\n            if number in counters:\n                counter += counters[number]\n                break\n            if number % 2 == 0:\n                number //= 2\n                counter += 1\n            else:\n                number = (3 * number) + 1\n                counter += 1\n\n        if input1 not in counters:\n            counters[input1] = counter\n\n        if counter > pre_counter:\n            largest_number = input1\n            pre_counter = counter\n    return largest_number\n1: def solution(max_base: int = 10, max_power: int = 22) -> int:\n    \"\"\"\n    Returns the count of all n-digit numbers which are nth power\n    >>> solution(10, 22)\n    49\n    >>> solution(0, 0)\n    0\n    >>> solution(1, 1)\n    0\n    >>> solution(-1, -1)\n    0\n    \"\"\"\n    bases = range(1, max_base)\n    powers = range(1, max_power)\n    return sum(\n        1 for power in powers for base in bases if len(str(base**power)) == power\n    )\n2: def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True", "output": "2"}
{"input": "search code:\nReturn the number of different square laminae that can be formed using up to one million tiles. >>> solution(100) 41\nChoices:\n0: def display_billionaires(forbes_billionaires: list[dict[str, int | str]]) -> None:\n    \"\"\"\n    Display Forbes real-time billionaires in a rich table.\n\n    Args:\n        forbes_billionaires (list): Forbes top 10 real-time billionaires\n    \"\"\"\n\n    table = rich_table.Table(\n        title=f\"Forbes Top {LIMIT} Real-Time Billionaires at {TODAY:%Y-%m-%d %H:%M}\",\n        style=\"green\",\n        highlight=True,\n        box=box.SQUARE,\n    )\n    for key in forbes_billionaires[0]:\n        table.add_column(key)\n\n    for billionaire in forbes_billionaires:\n        table.add_row(*billionaire.values())\n\n    rich_console.Console().print(table)\n1: def solution(limit: int = 1000000) -> int:\n    \"\"\"\n    Return the number of different square laminae that can be formed using up to\n    one million tiles.\n    >>> solution(100)\n    41\n    \"\"\"\n    answer = 0\n\n    for outer_width in range(3, (limit // 4) + 2):\n        if outer_width**2 > limit:\n            hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)\n        else:\n            hole_width_lower_bound = 1\n        if (outer_width - hole_width_lower_bound) % 2:\n            hole_width_lower_bound += 1\n\n        answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1\n\n    return answer\n2: def solution(filename: str = \"matrix.txt\") -> int:\n    \"\"\"\n    Returns the minimal path sum from the top left to the bottom right of the matrix.\n    >>> solution()\n    427337\n    \"\"\"\n    with open(os.path.join(os.path.dirname(__file__), filename)) as in_file:\n        data = in_file.read()\n\n    grid = [[int(cell) for cell in row.split(\",\")] for row in data.strip().splitlines()]\n    dp = [[0 for cell in row] for row in grid]\n    n = len(grid[0])\n\n    dp = [[0 for i in range(n)] for j in range(n)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, n):\n        dp[0][i] = grid[0][i] + dp[0][i - 1]\n    for i in range(1, n):\n        dp[i][0] = grid[i][0] + dp[i - 1][0]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]", "output": "1"}
{"input": "summarize code:\ndef windowed(src, size, fill=_UNSET):\n    \"\"\"Returns tuples with exactly length *size*. If *fill* is unset \n    and the iterable is too short to make a window of length *size*, \n    no tuples are returned. See :func:`windowed_iter` for more.\n    \"\"\"\n    return list(windowed_iter(src, size, fill=fill))", "output": "Returns tuples with exactly length *size*. If *fill* is unset and the iterable is too short to make a window of length *size*, no tuples are returned. See :func:`windowed_iter` for more."}
{"input": "search code:\nFind binomial coefficient using Pascal's triangle.\nChoices:\n0: def longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]\n1: def solution(n: int = 20) -> int:\n    \"\"\"\n    Returns the smallest positive number that is evenly divisible (divisible\n    with no remainder) by all of the numbers from 1 to n.\n\n    >>> solution(10)\n    2520\n    >>> solution(15)\n    360360\n    >>> solution(22)\n    232792560\n    >>> solution(3.4)\n    6\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    i = 0\n    while 1:\n        i += n * (n - 1)\n        nfound = 0\n        for j in range(2, n):\n            if i % j != 0:\n                nfound = 1\n                break\n        if nfound == 0:\n            if i == 0:\n                i = 1\n            return i\n    return None\n2: def binomial_coefficient(n: int, r: int) -> int:\n    \"\"\"\n    Find binomial coefficient using Pascal's triangle.\n\n    Calculate C(n, r) using Pascal's triangle.\n\n    :param n: The total number of items.\n    :param r: The number of items to choose.\n    :return: The binomial coefficient C(n, r).\n\n    >>> binomial_coefficient(10, 5)\n    252\n    >>> binomial_coefficient(10, 0)\n    1\n    >>> binomial_coefficient(0, 10)\n    1\n    >>> binomial_coefficient(10, 10)\n    1\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(5, 6)\n    0\n    >>> binomial_coefficient(3, 5)\n    0\n    >>> binomial_coefficient(-2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: n and r must be non-negative integers\n    >>> binomial_coefficient(5, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n and r must be non-negative integers\n    >>> binomial_coefficient(10.1, 5)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> binomial_coefficient(10, 5.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    \"\"\"\n    if n < 0 or r < 0:\n        raise ValueError(\"n and r must be non-negative integers\")\n    if 0 in (n, r):\n        return 1\n    c = [0 for i in range(r + 1)]\n    # nc0 = 1\n    c[0] = 1\n    for i in range(1, n + 1):\n        # to compute current row from previous row.\n        j = min(i, r)\n        while j > 0:\n            c[j] += c[j - 1]\n            j -= 1\n    return c[r]", "output": "2"}
{"input": "search code:\nCheck if the board (matrix) has been completely filled with non-zero values.\nChoices:\n0: def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)\n1: def unwrap_text(text, ending='\\n\\n'):\n    r\"\"\"\n    Unwrap text, the natural complement to :func:`textwrap.wrap`.\n\n    >>> text = \"Short \\n lines  \\nwrapped\\nsmall.\\n\\nAnother\\nparagraph.\"\n    >>> unwrap_text(text)\n    'Short lines wrapped small.\\n\\nAnother paragraph.'\n\n    Args:\n       text: A string to unwrap.\n       ending (str): The string to join all unwrapped paragraphs\n          by. Pass ``None`` to get the list. Defaults to '\\n\\n' for\n          compatibility with Markdown and RST.\n\n    \"\"\"\n    all_grafs = []\n    cur_graf = []\n    for line in text.splitlines():\n        line = line.strip()\n        if line:\n            cur_graf.append(line)\n        else:\n            all_grafs.append(' '.join(cur_graf))\n            cur_graf = []\n    if cur_graf:\n        all_grafs.append(' '.join(cur_graf))\n    if ending is None:\n        return all_grafs\n    return ending.join(all_grafs)\n2: def softplus(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the Softplus activation function.\n\n    Parameters:\n        vector (np.ndarray): The input array for the Softplus activation.\n\n    Returns:\n        np.ndarray: The input array after applying the Softplus activation.\n\n    Formula: f(x) = ln(1 + e^x)\n\n    Examples:\n    >>> softplus(np.array([2.3, 0.6, -2, -3.8]))\n    array([2.39554546, 1.03748795, 0.12692801, 0.02212422])\n\n    >>> softplus(np.array([-9.2, -0.3, 0.45, -4.56]))\n    array([1.01034298e-04, 5.54355244e-01, 9.43248946e-01, 1.04077103e-02])\n    \"\"\"\n    return np.log(1 + np.exp(vector))", "output": "0"}
{"input": "search code:\nCombine the term frequency and inverse document frequency functions to calculate the originality of a term. This 'originality' is calculated by multiplying the term frequency and the inverse document frequency : tf-idf = TF * IDF @params : tf, the term frequency, and idf, the inverse document frequency @examples : >>> tf_idf(2, 0.477) 0.954\nChoices:\n0: def factorial(number: int) -> int:\n    \"\"\"\n    Calculate the factorial of specified number (n!).\n\n    >>> import math\n    >>> all(factorial(i) == math.factorial(i) for i in range(20))\n    True\n    >>> factorial(0.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() only accepts integral values\n    >>> factorial(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() not defined for negative values\n    >>> factorial(1)\n    1\n    >>> factorial(6)\n    720\n    >>> factorial(0)\n    1\n    \"\"\"\n    if number != int(number):\n        raise ValueError(\"factorial() only accepts integral values\")\n    if number < 0:\n        raise ValueError(\"factorial() not defined for negative values\")\n    value = 1\n    for i in range(1, number + 1):\n        value *= i\n    return value\n1: def breadth_first_search(\n    level: list[int],\n    parent: list[list[int]],\n    max_node: int,\n    graph: dict[int, list[int]],\n    root: int = 1,\n) -> tuple[list[int], list[list[int]]]:\n    \"\"\"\n    sets every nodes direct parent\n    parent of root node is set to 0\n    calculates depth of each node from root node\n    >>> level = [-1] * 7\n    >>> parent = [[0] * 7 for _ in range(20)]\n    >>> graph = {1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [], 6: []}\n    >>> level, parent = breadth_first_search(\n    ...     level=level, parent=parent, max_node=6, graph=graph, root=1)\n    >>> level\n    [-1, 0, 1, 1, 2, 2, 2]\n    >>> parent[0]\n    [0, 0, 1, 1, 2, 2, 3]\n\n\n    >>> level = [-1] * 2\n    >>> parent = [[0] * 2 for _ in range(20)]\n    >>> graph = {1: []}\n    >>> level, parent = breadth_first_search(\n    ...     level=level, parent=parent, max_node=1, graph=graph, root=1)\n    >>> level\n    [-1, 0]\n    >>> parent[0]\n    [0, 0]\n    \"\"\"\n    level[root] = 0\n    q: Queue[int] = Queue(maxsize=max_node)\n    q.put(root)\n    while q.qsize() != 0:\n        u = q.get()\n        for v in graph[u]:\n            if level[v] == -1:\n                level[v] = level[u] + 1\n                q.put(v)\n                parent[0][v] = u\n    return level, parent\n2: def tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)", "output": "2"}
{"input": "search code:\nGenerates a list of images of subsequent Game of Life states.\nChoices:\n0: def is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True\n1: def solution(exponent: int = 30) -> int:\n    \"\"\"\n    For any given exponent x >= 0, 1 <= n <= 2^x.\n    This function returns how many Nim games are lost given that\n    each Nim game has three heaps of the form (n, 2*n, 3*n).\n    >>> solution(0)\n    1\n    >>> solution(2)\n    3\n    >>> solution(10)\n    144\n    \"\"\"\n    # To find how many total games were lost for a given exponent x,\n    # we need to find the Fibonacci number F(x+2).\n    fibonacci_index = exponent + 2\n    phi = (1 + 5**0.5) / 2\n    fibonacci = (phi**fibonacci_index - (phi - 1) ** fibonacci_index) / 5**0.5\n\n    return int(fibonacci)\n2: def generate_images(cells: list[list[int]], frames: int) -> list[Image.Image]:\n    \"\"\"\n    Generates a list of images of subsequent Game of Life states.\n    \"\"\"\n    images = []\n    for _ in range(frames):\n        # Create output image\n        img = Image.new(\"RGB\", (len(cells[0]), len(cells)))\n        pixels = img.load()\n\n        # Save cells to image\n        for x in range(len(cells)):\n            for y in range(len(cells[0])):\n                colour = 255 - cells[y][x] * 255\n                pixels[x, y] = (colour, colour, colour)\n\n        # Save image\n        images.append(img)\n        cells = new_generation(cells)\n    return images", "output": "2"}
{"input": "search code:\nReturns the last 8 digits of the hyperexponentiation of base by height, i.e. the number baseâ†‘â†‘height:\nChoices:\n0: def factorial(number: int) -> int:\n    \"\"\"\n    Calculate the factorial of specified number (n!).\n\n    >>> import math\n    >>> all(factorial(i) == math.factorial(i) for i in range(20))\n    True\n    >>> factorial(0.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() only accepts integral values\n    >>> factorial(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() not defined for negative values\n    >>> factorial(1)\n    1\n    >>> factorial(6)\n    720\n    >>> factorial(0)\n    1\n    \"\"\"\n    if number != int(number):\n        raise ValueError(\"factorial() only accepts integral values\")\n    if number < 0:\n        raise ValueError(\"factorial() not defined for negative values\")\n    value = 1\n    for i in range(1, number + 1):\n        value *= i\n    return value\n1: def hubble_parameter(\n    hubble_constant: float,\n    radiation_density: float,\n    matter_density: float,\n    dark_energy: float,\n    redshift: float,\n) -> float:\n    \"\"\"\n    Input Parameters\n    ----------------\n    hubble_constant: Hubble constante is the expansion rate today usually\n    given in km/(s*Mpc)\n\n    radiation_density: relative radiation density today\n\n    matter_density: relative mass density today\n\n    dark_energy: relative dark energy density today\n\n    redshift: the light redshift\n\n    Returns\n    -------\n    result : Hubble parameter in and the unit km/s/Mpc (the unit can be\n    changed if you want, just need to change the unit of the Hubble constant)\n\n    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n    ... matter_density=-0.3, dark_energy=0.7, redshift=1)\n    Traceback (most recent call last):\n    ...\n    ValueError: All input parameters must be positive\n\n    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n    ... matter_density= 1.2, dark_energy=0.7, redshift=1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Relative densities cannot be greater than one\n\n    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n    ... matter_density= 0.3, dark_energy=0.7, redshift=0)\n    68.3\n    \"\"\"\n    parameters = [redshift, radiation_density, matter_density, dark_energy]\n    if any(p < 0 for p in parameters):\n        raise ValueError(\"All input parameters must be positive\")\n\n    if any(p > 1 for p in parameters[1:4]):\n        raise ValueError(\"Relative densities cannot be greater than one\")\n    else:\n        curvature = 1 - (matter_density + radiation_density + dark_energy)\n\n        e_2 = (\n            radiation_density * (redshift + 1) ** 4\n            + matter_density * (redshift + 1) ** 3\n            + curvature * (redshift + 1) ** 2\n            + dark_energy\n        )\n\n        hubble = hubble_constant * e_2 ** (1 / 2)\n        return hubble\n2: def solution(base: int = 1777, height: int = 1855, digits: int = 8) -> int:\n    \"\"\"\n    Returns the last 8 digits of the hyperexponentiation of base by\n    height, i.e. the number baseâ†‘â†‘height:\n\n    >>> solution(base=3, height=2)\n    27\n    >>> solution(base=3, height=3)\n    97484987\n    >>> solution(base=123, height=456, digits=4)\n    2547\n    \"\"\"\n\n    # calculate baseâ†‘â†‘height by right-assiciative repeated modular\n    # exponentiation\n    result = base\n    for _ in range(1, height):\n        result = _modexpt(base, result, 10**digits)\n\n    return result", "output": "2"}
{"input": "summarize code:\ndef speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20Â°C: bulk_modulus= 2.15MPa, density=998kg/mÂ³\n    Example 2 --> Mercury 20Â°C: bulk_modulus= 28.5MPa, density=13600kg/mÂ³\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5", "output": "Calculates the speed of sound in a fluid from its density and bulk modulus"}
{"input": "summarize code:\ndef get_rotation(\n    img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int\n) -> np.ndarray:\n    \"\"\"\n    Get image rotation\n    :param img: np.ndarray\n    :param pt1: 3x2 list\n    :param pt2: 3x2 list\n    :param rows: columns image shape\n    :param cols: rows image shape\n    :return: np.ndarray\n    \"\"\"\n    matrix = cv2.getAffineTransform(pt1, pt2)\n    return cv2.warpAffine(img, matrix, (rows, cols))", "output": "Get image rotation :param img: np.ndarray :param pt1: 3x2 list :param pt2: 3x2 list :param rows: columns image shape :param cols: rows image shape :return: np.ndarray"}
{"input": "summarize code:\ndef sentinel_linear_search(sequence, target):\n    \"\"\"Pure implementation of sentinel linear search algorithm in Python\n\n    :param sequence: some sequence with comparable items\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    sequence.append(target)\n\n    index = 0\n    while sequence[index] != target:\n        index += 1\n\n    sequence.pop()\n\n    if index == len(sequence):\n        return None\n\n    return index", "output": "Pure implementation of sentinel linear search algorithm in Python"}
{"input": "summarize code:\ndef get_module_callables(mod, ignore=None):\n    \"\"\"Returns two maps of (*types*, *funcs*) from *mod*, optionally\n    ignoring based on the :class:`bool` return value of the *ignore*\n    callable. *mod* can be a string name of a module in\n    :data:`sys.modules` or the module instance itself.\n    \"\"\"\n    if isinstance(mod, str):\n        mod = sys.modules[mod]\n    types, funcs = {}, {}\n    for attr_name in dir(mod):\n        if ignore and ignore(attr_name):\n            continue\n        try:\n            attr = getattr(mod, attr_name)\n        except Exception:\n            continue\n        try:\n            attr_mod_name = attr.__module__\n        except AttributeError:\n            continue\n        if attr_mod_name != mod.__name__:\n            continue\n        if isinstance(attr, type):\n            types[attr_name] = attr\n        elif callable(attr):\n            funcs[attr_name] = attr\n    return types, funcs", "output": "Returns two maps of (*types*, *funcs*) from *mod*, optionally ignoring based on the :class:`bool` return value of the *ignore* callable. *mod* can be a string name of a module in :data:`sys.modules` or the module instance itself."}
{"input": "summarize code:\ndef value_chain(*args):\n    \"\"\"Yield all arguments passed to the function in the same order in which\n    they were passed. If an argument itself is iterable then iterate over its\n    values.\n\n        >>> list(value_chain(1, 2, 3, [4, 5, 6]))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and are emitted\n    as-is:\n\n        >>> list(value_chain('12', '34', ['56', '78']))\n        ['12', '34', '56', '78']\n\n    Pre- or postpend a single element to an iterable:\n\n        >>> list(value_chain(1, [2, 3, 4, 5, 6]))\n        [1, 2, 3, 4, 5, 6]\n        >>> list(value_chain([1, 2, 3, 4, 5], 6))\n        [1, 2, 3, 4, 5, 6]\n\n    Multiple levels of nesting are not flattened.\n\n    \"\"\"\n    scalar_types = (str, bytes)\n    for value in args:\n        if isinstance(value, scalar_types):\n            yield value\n            continue\n        try:\n            yield from value\n        except TypeError:\n            yield value", "output": "Yield all arguments passed to the function in the same order in which they were passed. If an argument itself is iterable then iterate over its values."}
{"input": "summarize code:\ndef solution(num: int = 100) -> int:\n    \"\"\"Returns the sum of the digits in the factorial of num\n    >>> solution(100)\n    648\n    >>> solution(50)\n    216\n    >>> solution(10)\n    27\n    >>> solution(5)\n    3\n    >>> solution(3)\n    6\n    >>> solution(2)\n    2\n    >>> solution(1)\n    1\n    \"\"\"\n    fact = 1\n    result = 0\n    for i in range(1, num + 1):\n        fact *= i\n\n    for j in str(fact):\n        result += int(j)\n\n    return result", "output": "Returns the sum of the digits in the factorial of num >>> solution(100) 648 >>> solution(50) 216 >>> solution(10) 27 >>> solution(5) 3 >>> solution(3) 6 >>> solution(2) 2 >>> solution(1) 1"}
{"input": "search code:\nReturn the sum of the factorial of the digits of n. >>> sum_digit_factorials(145) 145 >>> sum_digit_factorials(45361) 871 >>> sum_digit_factorials(540) 145\nChoices:\n0: def sum_digit_factorials(n: int) -> int:\n    \"\"\"\n    Return the sum of the factorial of the digits of n.\n    >>> sum_digit_factorials(145)\n    145\n    >>> sum_digit_factorials(45361)\n    871\n    >>> sum_digit_factorials(540)\n    145\n    \"\"\"\n    if n in CACHE_SUM_DIGIT_FACTORIALS:\n        return CACHE_SUM_DIGIT_FACTORIALS[n]\n    ret = sum(DIGIT_FACTORIALS[let] for let in str(n))\n    CACHE_SUM_DIGIT_FACTORIALS[n] = ret\n    return ret\n1: def generate_pascal_triangle_optimized(num_rows: int) -> list[list[int]]:\n    \"\"\"\n    This function returns a matrix representing the corresponding pascal's triangle\n    according to the given input of number of rows of Pascal's triangle to be generated.\n    It reduces the operations done to generate a row by half\n    by eliminating redundant calculations.\n\n    :param num_rows: Integer specifying the number of rows in the Pascal's triangle\n    :return: 2-D List (matrix) representing the Pascal's triangle\n\n    Return the Pascal's triangle of given rows\n    >>> generate_pascal_triangle_optimized(3)\n    [[1], [1, 1], [1, 2, 1]]\n    >>> generate_pascal_triangle_optimized(1)\n    [[1]]\n    >>> generate_pascal_triangle_optimized(0)\n    []\n    >>> generate_pascal_triangle_optimized(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value of 'num_rows' should be greater than or equal to 0\n    >>> generate_pascal_triangle_optimized(7.89)\n    Traceback (most recent call last):\n        ...\n    TypeError: The input value of 'num_rows' should be 'int'\n    \"\"\"\n\n    if not isinstance(num_rows, int):\n        raise TypeError(\"The input value of 'num_rows' should be 'int'\")\n\n    if num_rows == 0:\n        return []\n    elif num_rows < 0:\n        raise ValueError(\n            \"The input value of 'num_rows' should be greater than or equal to 0\"\n        )\n\n    result: list[list[int]] = [[1]]\n\n    for row_index in range(1, num_rows):\n        temp_row = [0] + result[-1] + [0]\n        row_length = row_index + 1\n        # Calculate the number of distinct elements in a row\n        distinct_elements = sum(divmod(row_length, 2))\n        row_first_half = [\n            temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)\n        ]\n        row_second_half = row_first_half[: (row_index + 1) // 2]\n        row_second_half.reverse()\n        row = row_first_half + row_second_half\n        result.append(row)\n\n    return result\n2: def unquote(string, encoding='utf-8', errors='replace'):\n    \"\"\"Percent-decode a string, by replacing %xx escapes with their\n    single-character equivalent. The optional *encoding* and *errors*\n    parameters specify how to decode percent-encoded sequences into\n    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By\n    default, percent-encoded sequences are decoded with UTF-8, and\n    invalid sequences are replaced by a placeholder character.\n\n    >>> unquote(u'abc%20def')\n    u'abc def'\n    \"\"\"\n    if '%' not in string:\n        string.split\n        return string\n    if encoding is None:\n        encoding = 'utf-8'\n    if errors is None:\n        errors = 'replace'\n    bits = _ASCII_RE.split(string)\n    res = [bits[0]]\n    append = res.append\n    for i in range(1, len(bits), 2):\n        append(unquote_to_bytes(bits[i]).decode(encoding, errors))\n        append(bits[i + 1])\n    return ''.join(res)", "output": "0"}
{"input": "summarize code:\ndef main() -> None:\n    \"\"\"\n    Get images list and annotations list from input dir.\n    Update new images and annotations.\n    Save images and annotations in output dir.\n    \"\"\"\n    img_paths, annos = get_dataset(LABEL_DIR, IMG_DIR)\n    for index in range(NUMBER_IMAGES):\n        idxs = random.sample(range(len(annos)), 4)\n        new_image, new_annos, path = update_image_and_anno(\n            img_paths,\n            annos,\n            idxs,\n            OUTPUT_SIZE,\n            SCALE_RANGE,\n            filter_scale=FILTER_TINY_SCALE,\n        )\n\n        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n        letter_code = random_chars(32)\n        file_name = path.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        file_root = f\"{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}\"\n        cv2.imwrite(f\"{file_root}.jpg\", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])\n        print(f\"Succeeded {index + 1}/{NUMBER_IMAGES} with {file_name}\")\n        annos_list = []\n        for anno in new_annos:\n            width = anno[3] - anno[1]\n            height = anno[4] - anno[2]\n            x_center = anno[1] + width / 2\n            y_center = anno[2] + height / 2\n            obj = f\"{anno[0]} {x_center} {y_center} {width} {height}\"\n            annos_list.append(obj)\n        with open(f\"{file_root}.txt\", \"w\") as outfile:\n            outfile.write(\"\\n\".join(line for line in annos_list))", "output": "Get images list and annotations list from input dir. Update new images and annotations. Save images and annotations in output dir."}
{"input": "summarize code:\ndef tabulate(function, start=0):\n    \"\"\"Return an iterator over the results of ``func(start)``,\n    ``func(start + 1)``, ``func(start + 2)``...\n\n    *func* should be a function that accepts one integer argument.\n\n    If *start* is not specified it defaults to 0. It will be incremented each\n    time the iterator is advanced.\n\n        >>> square = lambda x: x ** 2\n        >>> iterator = tabulate(square, -3)\n        >>> take(4, iterator)\n        [9, 4, 1, 0]\n\n    \"\"\"\n    return map(function, count(start))", "output": "Return an iterator over the results of ``func(start)``, ``func(start + 1)``, ``func(start + 2)``..."}
{"input": "summarize code:\ndef angle_comparer(point: tuple[int, int], minx: int, miny: int) -> float:\n    \"\"\"Return the angle toward to point from (minx, miny)\n\n    :param point: The target point\n           minx: The starting point's x\n           miny: The starting point's y\n    :return: the angle\n\n    Examples:\n    >>> angle_comparer((1,1), 0, 0)\n    45.0\n\n    >>> angle_comparer((100,1), 10, 10)\n    -5.710593137499642\n\n    >>> angle_comparer((5,5), 2, 3)\n    33.690067525979785\n    \"\"\"\n    # sort the points accorgind to the angle from the lowest and the most left point\n    x, y = point\n    return degrees(atan2(y - miny, x - minx))", "output": "Return the angle toward to point from (minx, miny)"}
{"input": "search code:\nCheck if number is a perfect square.\nChoices:\n0: def process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:\n    \"\"\"Processes the game logic for the given matrix and moves.\n\n    Args:\n        size (int): Size of the game board.\n        matrix (List[str]): Initial game matrix.\n        moves (List[Tuple[int, int]]): List of moves as (x, y) coordinates.\n\n    Returns:\n        int: The total score obtained.\n    >>> process_game(3, ['aaa', 'bbb', 'ccc'], [(0, 0)])\n    6\n    \"\"\"\n\n    game_matrix = [list(row) for row in matrix]\n    total_score = 0\n\n    for move in moves:\n        pos_x, pos_y = move\n        game_matrix, score = play(game_matrix, pos_x, pos_y, size)\n        total_score += score\n\n    return total_score\n1: def is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq\n2: def double_sort(collection: list[Any]) -> list[Any]:\n    \"\"\"This sorting algorithm sorts an array using the principle of bubble sort,\n    but does it both from left to right and right to left.\n    Hence, it's called \"Double sort\"\n    :param collection: mutable ordered sequence of elements\n    :return: the same collection in ascending order\n    Examples:\n    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6 ,-7])\n    [-7, -6, -5, -4, -3, -2, -1]\n    >>> double_sort([])\n    []\n    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6])\n    [-6, -5, -4, -3, -2, -1]\n    >>> double_sort([-3, 10, 16, -42, 29]) == sorted([-3, 10, 16, -42, 29])\n    True\n    \"\"\"\n    no_of_elements = len(collection)\n    for _ in range(\n        int(((no_of_elements - 1) / 2) + 1)\n    ):  # we don't need to traverse to end of list as\n        for j in range(no_of_elements - 1):\n            # apply the bubble sort algorithm from left to right (or forwards)\n            if collection[j + 1] < collection[j]:\n                collection[j], collection[j + 1] = collection[j + 1], collection[j]\n            # apply the bubble sort algorithm from right to left (or backwards)\n            if collection[no_of_elements - 1 - j] < collection[no_of_elements - 2 - j]:\n                (\n                    collection[no_of_elements - 1 - j],\n                    collection[no_of_elements - 2 - j],\n                ) = (\n                    collection[no_of_elements - 2 - j],\n                    collection[no_of_elements - 1 - j],\n                )\n    return collection", "output": "1"}
{"input": "search code:\nConstructs a bottom-up dynamic programming solution for the rod-cutting problem\nChoices:\n0: def main() -> None:\n    \"\"\"\n    Provides option 'string' or 'file' to take input\n    and prints the calculated SHA-256 hash\n    \"\"\"\n\n    # unittest.main()\n\n    import doctest\n\n    doctest.testmod()\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-s\",\n        \"--string\",\n        dest=\"input_string\",\n        default=\"Hello World!! Welcome to Cryptography\",\n        help=\"Hash the string\",\n    )\n    parser.add_argument(\n        \"-f\", \"--file\", dest=\"input_file\", help=\"Hash contents of a file\"\n    )\n\n    args = parser.parse_args()\n\n    input_string = args.input_string\n\n    # hash input should be a bytestring\n    if args.input_file:\n        with open(args.input_file, \"rb\") as f:\n            hash_input = f.read()\n    else:\n        hash_input = bytes(input_string, \"utf-8\")\n\n    print(SHA256(hash_input).hash)\n1: def sin(\n    angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10\n) -> float:\n    \"\"\"\n    Implement sin function.\n\n    >>> sin(0.0)\n    0.0\n    >>> sin(90.0)\n    1.0\n    >>> sin(180.0)\n    0.0\n    >>> sin(270.0)\n    -1.0\n    >>> sin(0.68)\n    0.0118679603\n    >>> sin(1.97)\n    0.0343762121\n    >>> sin(64.0)\n    0.8987940463\n    >>> sin(9999.0)\n    -0.9876883406\n    >>> sin(-689.0)\n    0.5150380749\n    >>> sin(89.7)\n    0.9999862922\n    \"\"\"\n    # Simplify the angle to be between 360 and -360 degrees.\n    angle_in_degrees = angle_in_degrees - ((angle_in_degrees // 360.0) * 360.0)\n\n    # Converting from degrees to radians\n    angle_in_radians = radians(angle_in_degrees)\n\n    result = angle_in_radians\n    a = 3\n    b = -1\n\n    for _ in range(accuracy):\n        result += (b * (angle_in_radians**a)) / factorial(a)\n\n        b = -b  # One positive term and the next will be negative and so on...\n        a += 2  # Increased by 2 for every term.\n\n    return round(result, rounded_values_count)\n2: def bottom_up_cut_rod(n: int, prices: list):\n    \"\"\"\n    Constructs a bottom-up dynamic programming solution for the rod-cutting problem\n\n    Runtime: O(n^2)\n\n    Arguments\n    ---------\n\n    * `n`: int, the maximum length of the rod.\n    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n      price for a rod of length ``i``\n\n    Returns\n    -------\n\n    The maximum revenue obtainable from cutting a rod of length `n` given\n    the prices for each piece of rod p.\n\n    Examples\n    --------\n\n    >>> bottom_up_cut_rod(4, [1, 5, 8, 9])\n    10\n    >>> bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n    30\n    \"\"\"\n    _enforce_args(n, prices)\n\n    # length(max_rev) = n + 1, to accommodate for the revenue obtainable from a rod of\n    # length 0.\n    max_rev = [float(\"-inf\") for _ in range(n + 1)]\n    max_rev[0] = 0\n\n    for i in range(1, n + 1):\n        max_revenue_i = max_rev[i]\n        for j in range(1, i + 1):\n            max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])\n\n        max_rev[i] = max_revenue_i\n\n    return max_rev[n]", "output": "2"}
{"input": "summarize code:\ndef solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    \"\"\"\n\n    even_fibs = []\n    a, b = 0, 1\n    while b <= n:\n        if b % 2 == 0:\n            even_fibs.append(b)\n        a, b = b, a + b\n    return sum(even_fibs)", "output": "Returns the sum of all even fibonacci sequence elements that are lower or equal to n."}
{"input": "summarize code:\ndef fib_iterative(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using iteration\n    >>> fib_iterative(0)\n    [0]\n    >>> fib_iterative(1)\n    [0, 1]\n    >>> fib_iterative(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_iterative(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    if n == 0:\n        return [0]\n    fib = [0, 1]\n    for _ in range(n - 1):\n        fib.append(fib[-1] + fib[-2])\n    return fib", "output": "Calculates the first n (0-indexed) Fibonacci numbers using iteration >>> fib_iterative(0) [0] >>> fib_iterative(1) [0, 1] >>> fib_iterative(5) [0, 1, 1, 2, 3, 5] >>> fib_iterative(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> fib_iterative(-1) Traceback (most recent call last): ... ValueError: n is negative"}
{"input": "summarize code:\ndef radix_sort(list_of_ints: list[int]) -> list[int]:\n    \"\"\"\n    Examples:\n    >>> radix_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> radix_sort(list(range(15))) == sorted(range(15))\n    True\n    >>> radix_sort(list(range(14,-1,-1))) == sorted(range(15))\n    True\n    >>> radix_sort([1,100,10,1000]) == sorted([1,100,10,1000])\n    True\n    \"\"\"\n    placement = 1\n    max_digit = max(list_of_ints)\n    while placement <= max_digit:\n        # declare and initialize empty buckets\n        buckets: list[list] = [[] for _ in range(RADIX)]\n        # split list_of_ints between the buckets\n        for i in list_of_ints:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n        # put each buckets' contents into list_of_ints\n        a = 0\n        for b in range(RADIX):\n            for i in buckets[b]:\n                list_of_ints[a] = i\n                a += 1\n        # move to next\n        placement *= RADIX\n    return list_of_ints", "output": "Examples: >>> radix_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5]"}
{"input": "summarize code:\ndef maclaurin_sin(theta: float, accuracy: int = 30) -> float:\n    \"\"\"\n    Finds the maclaurin approximation of sin\n\n    :param theta: the angle to which sin is found\n    :param accuracy: the degree of accuracy wanted minimum\n    :return: the value of sine in radians\n\n\n    >>> from math import isclose, sin\n    >>> all(isclose(maclaurin_sin(x, 50), sin(x)) for x in range(-25, 25))\n    True\n    >>> maclaurin_sin(10)\n    -0.5440211108893691\n    >>> maclaurin_sin(-10)\n    0.5440211108893704\n    >>> maclaurin_sin(10, 15)\n    -0.544021110889369\n    >>> maclaurin_sin(-10, 15)\n    0.5440211108893704\n    >>> maclaurin_sin(\"10\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires either an int or float for theta\n    >>> maclaurin_sin(10, -30)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires a positive int for accuracy\n    >>> maclaurin_sin(10, 30.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires a positive int for accuracy\n    >>> maclaurin_sin(10, \"30\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires a positive int for accuracy\n    \"\"\"\n\n    if not isinstance(theta, (int, float)):\n        raise ValueError(\"maclaurin_sin() requires either an int or float for theta\")\n\n    if not isinstance(accuracy, int) or accuracy <= 0:\n        raise ValueError(\"maclaurin_sin() requires a positive int for accuracy\")\n\n    theta = float(theta)\n    div = theta // (2 * pi)\n    theta -= 2 * div * pi\n    return sum(\n        (-1) ** r * theta ** (2 * r + 1) / factorial(2 * r + 1) for r in range(accuracy)\n    )", "output": "Finds the maclaurin approximation of sin"}
{"input": "search code:\nThis function returns True if there is a node that has not iterated.\nChoices:\n0: def find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:\n    \"\"\"\n    find max value in list\n    :param nums: contains elements\n    :param left: index of first element\n    :param right: index of last element\n    :return: max in nums\n\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n    ...     find_max_recursive(nums, 0, len(nums) - 1) == max(nums)\n    True\n    True\n    True\n    True\n    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n    >>> find_max_recursive(nums, 0, len(nums) - 1) == max(nums)\n    True\n    >>> find_max_recursive([], 0, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: find_max_recursive() arg is an empty sequence\n    >>> find_max_recursive(nums, 0, len(nums)) == max(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    >>> find_max_recursive(nums, -len(nums), -1) == max(nums)\n    True\n    >>> find_max_recursive(nums, -len(nums) - 1, -1) == max(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"find_max_recursive() arg is an empty sequence\")\n    if (\n        left >= len(nums)\n        or left < -len(nums)\n        or right >= len(nums)\n        or right < -len(nums)\n    ):\n        raise IndexError(\"list index out of range\")\n    if left == right:\n        return nums[left]\n    mid = (left + right) >> 1  # the middle\n    left_max = find_max_recursive(nums, left, mid)  # find max in range[left, mid]\n    right_max = find_max_recursive(\n        nums, mid + 1, right\n    )  # find max in range[mid + 1, right]\n\n    return left_max if left_max >= right_max else right_max\n1: def luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0\n2: def breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:\n    \"\"\"\n    This function returns True if there is a node that has not iterated.\n\n    Args:\n        graph: Adjacency matrix of graph\n        source: Source\n        sink: Sink\n        parents: Parent list\n\n    Returns:\n        True if there is a node that has not iterated.\n\n    >>> breadth_first_search(graph, 0, 5, [-1, -1, -1, -1, -1, -1])\n    True\n    >>> breadth_first_search(graph, 0, 6, [-1, -1, -1, -1, -1, -1])\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n    visited = [False] * len(graph)  # Mark all nodes as not visited\n    queue = []  # breadth-first search queue\n\n    # Source node\n    queue.append(source)\n    visited[source] = True\n\n    while queue:\n        u = queue.pop(0)  # Pop the front node\n        # Traverse all adjacent nodes of u\n        for ind, node in enumerate(graph[u]):\n            if visited[ind] is False and node > 0:\n                queue.append(ind)\n                visited[ind] = True\n                parents[ind] = u\n    return visited[sink]", "output": "2"}
{"input": "summarize code:\ndef sum_of_digit_factorial(n: int) -> int:\n    \"\"\"\n    Returns the sum of the factorial of digits in n\n    >>> sum_of_digit_factorial(15)\n    121\n    >>> sum_of_digit_factorial(0)\n    1\n    \"\"\"\n    return sum(DIGIT_FACTORIAL[d] for d in str(n))", "output": "Returns the sum of the factorial of digits in n >>> sum_of_digit_factorial(15) 121 >>> sum_of_digit_factorial(0) 1"}
{"input": "summarize code:\ndef solution(n: int = 2000000) -> int:\n    \"\"\"\n    Returns the sum of all the primes below n.\n\n    >>> solution(1000)\n    76127\n    >>> solution(5000)\n    1548136\n    >>> solution(10000)\n    5736396\n    >>> solution(7)\n    10\n    \"\"\"\n\n    return sum(takewhile(lambda x: x < n, prime_generator()))", "output": "Returns the sum of all the primes below n."}
{"input": "search code:\nBenchmark the Levenshtein distance function. :param str: The name of the function being benchmarked. :param func: The function to be benchmarked.\nChoices:\n0: def benchmark_levenshtein_distance(func: Callable) -> None:\n    \"\"\"\n    Benchmark the Levenshtein distance function.\n    :param str: The name of the function being benchmarked.\n    :param func: The function to be benchmarked.\n    \"\"\"\n    from timeit import timeit\n\n    stmt = f\"{func.__name__}('sitting', 'kitten')\"\n    setup = f\"from __main__ import {func.__name__}\"\n    number = 25_000\n    result = timeit(stmt=stmt, setup=setup, number=number)\n    print(f\"{func.__name__:<30} finished {number:,} runs in {result:.5f} seconds\")\n1: def score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch\n2: def printboard(board: list[list[int]]) -> None:\n    \"\"\"\n    Prints the boards that have a successful combination.\n    \"\"\"\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 1:\n                print(\"Q\", end=\" \")  # Queen is present\n            else:\n                print(\".\", end=\" \")  # Empty cell\n        print()", "output": "0"}
{"input": "search code:\nThis function calculates the waiting time of some processes that have a specified duration time. Return: The waiting time for each process. >>> calculate_waiting_times([5, 10, 15]) [0, 5, 15] >>> calculate_waiting_times([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10] >>> calculate_waiting_times([10, 3]) [0, 10]\nChoices:\n0: def update_image_and_anno(\n    img_list: list, anno_list: list, flip_type: int = 1\n) -> tuple[list, list, list]:\n    \"\"\"\n    - img_list <type: list>: list of all images\n    - anno_list <type: list>: list of all annotations of specific image\n    - flip_type <type: int>: 0 is vertical, 1 is horizontal\n    Return:\n        - new_imgs_list <type: narray>: image after resize\n        - new_annos_lists <type: list>: list of new annotation after scale\n        - path_list <type: list>: list the name of image file\n    \"\"\"\n    new_annos_lists = []\n    path_list = []\n    new_imgs_list = []\n    for idx in range(len(img_list)):\n        new_annos = []\n        path = img_list[idx]\n        path_list.append(path)\n        img_annos = anno_list[idx]\n        img = cv2.imread(path)\n        if flip_type == 1:\n            new_img = cv2.flip(img, flip_type)\n            for bbox in img_annos:\n                x_center_new = 1 - bbox[1]\n                new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])\n        elif flip_type == 0:\n            new_img = cv2.flip(img, flip_type)\n            for bbox in img_annos:\n                y_center_new = 1 - bbox[2]\n                new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])\n        new_annos_lists.append(new_annos)\n        new_imgs_list.append(new_img)\n    return new_imgs_list, new_annos_lists, path_list\n1: def get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:\n    \"\"\"\n    Generate filters for audio processing.\n\n    Args:\n        filter_points: A list of filter points.\n        ftt_size: The size of the FFT.\n\n    Returns:\n        A matrix of filters.\n\n    Examples:\n    >>> get_filters(np.array([0, 20, 51, 95, 161, 256], dtype=int), 512).shape\n    (4, 257)\n    \"\"\"\n    num_filters = len(filter_points) - 2\n    filters = np.zeros((num_filters, int(ftt_size / 2) + 1))\n\n    for n in range(num_filters):\n        start = filter_points[n]\n        mid = filter_points[n + 1]\n        end = filter_points[n + 2]\n\n        # Linearly increase values from 0 to 1\n        filters[n, start:mid] = np.linspace(0, 1, mid - start)\n\n        # Linearly decrease values from 1 to 0\n        filters[n, mid:end] = np.linspace(1, 0, end - mid)\n\n    return filters\n2: def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times", "output": "2"}
{"input": "summarize code:\ndef eliminate(values, s, d):\n    \"\"\"\n    Eliminate d from values[s]; propagate when values or places <= 2.\n    Return values, except return False if a contradiction is detected.\n    \"\"\"\n    if d not in values[s]:\n        return values  ## Already eliminated\n    values[s] = values[s].replace(d, \"\")\n    ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.\n    if len(values[s]) == 0:\n        return False  ## Contradiction: removed last value\n    elif len(values[s]) == 1:\n        d2 = values[s]\n        if not all(eliminate(values, s2, d2) for s2 in peers[s]):\n            return False\n    ## (2) If a unit u is reduced to only one place for a value d, then put it there.\n    for u in units[s]:\n        dplaces = [s for s in u if d in values[s]]\n        if len(dplaces) == 0:\n            return False  ## Contradiction: no place for this value\n        # d can only be in one place in unit; assign it there\n        elif len(dplaces) == 1 and not assign(values, dplaces[0], d):\n            return False\n    return values", "output": "Eliminate d from values[s]; propagate when values or places <= 2. Return values, except return False if a contradiction is detected."}
{"input": "summarize code:\ndef create_sparse(max_node: int, parent: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    creating sparse table which saves each nodes 2^i-th parent\n    >>> max_node = 6\n    >>> parent = [[0, 0, 1, 1, 2, 2, 3]] + [[0] * 7 for _ in range(19)]\n    >>> parent = create_sparse(max_node=max_node, parent=parent)\n    >>> parent[0]\n    [0, 0, 1, 1, 2, 2, 3]\n    >>> parent[1]\n    [0, 0, 0, 0, 1, 1, 1]\n    >>> parent[2]\n    [0, 0, 0, 0, 0, 0, 0]\n\n    >>> max_node = 1\n    >>> parent = [[0, 0]] + [[0] * 2 for _ in range(19)]\n    >>> parent = create_sparse(max_node=max_node, parent=parent)\n    >>> parent[0]\n    [0, 0]\n    >>> parent[1]\n    [0, 0]\n    \"\"\"\n    j = 1\n    while (1 << j) < max_node:\n        for i in range(1, max_node + 1):\n            parent[j][i] = parent[j - 1][parent[j - 1][i]]\n        j += 1\n    return parent", "output": "creating sparse table which saves each nodes 2^i-th parent >>> max_node = 6 >>> parent = [[0, 0, 1, 1, 2, 2, 3]] + [[0] * 7 for _ in range(19)] >>> parent = create_sparse(max_node=max_node, parent=parent) >>> parent[0] [0, 0, 1, 1, 2, 2, 3] >>> parent[1] [0, 0, 0, 0, 1, 1, 1] >>> parent[2] [0, 0, 0, 0, 0, 0, 0]"}
{"input": "search code:\nImplements the Damerau-Levenshtein distance algorithm that measures the edit distance between two strings.\nChoices:\n0: def damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    \"\"\"\n    Implements the Damerau-Levenshtein distance algorithm that measures\n    the edit distance between two strings.\n\n    Parameters:\n        first_string: The first string to compare\n        second_string: The second string to compare\n\n    Returns:\n        distance: The edit distance between the first and second strings\n\n    >>> damerau_levenshtein_distance(\"cat\", \"cut\")\n    1\n    >>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n    3\n    >>> damerau_levenshtein_distance(\"hello\", \"world\")\n    4\n    >>> damerau_levenshtein_distance(\"book\", \"back\")\n    2\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    \"\"\"\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]\n1: def emitter_converter(size_par, data):\n    \"\"\"\n    :param size_par: how many parity bits the message must have\n    :param data:  information bits\n    :return: message to be transmitted by unreliable medium\n            - bits of information merged with parity bits\n\n    >>> emitter_converter(4, \"101010111111\")\n    ['1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1']\n    >>> emitter_converter(5, \"101010111111\")\n    Traceback (most recent call last):\n        ...\n    ValueError: size of parity don't match with size of data\n    \"\"\"\n    if size_par + len(data) <= 2**size_par - (len(data) - 1):\n        raise ValueError(\"size of parity don't match with size of data\")\n\n    data_out = []\n    parity = []\n    bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]\n\n    # sorted information data for the size of the output data\n    data_ord = []\n    # data position template + parity\n    data_out_gab = []\n    # parity bit counter\n    qtd_bp = 0\n    # counter position of data bits\n    cont_data = 0\n\n    for x in range(1, size_par + len(data) + 1):\n        # Performs a template of bit positions - who should be given,\n        # and who should be parity\n        if qtd_bp < size_par:\n            if (np.log(x) / np.log(2)).is_integer():\n                data_out_gab.append(\"P\")\n                qtd_bp = qtd_bp + 1\n            else:\n                data_out_gab.append(\"D\")\n        else:\n            data_out_gab.append(\"D\")\n\n        # Sorts the data to the new output size\n        if data_out_gab[-1] == \"D\":\n            data_ord.append(data[cont_data])\n            cont_data += 1\n        else:\n            data_ord.append(None)\n\n    # Calculates parity\n    qtd_bp = 0  # parity bit counter\n    for bp in range(1, size_par + 1):\n        # Bit counter one for a given parity\n        cont_bo = 0\n        # counter to control the loop reading\n        for cont_loop, x in enumerate(data_ord):\n            if x is not None:\n                try:\n                    aux = (bin_pos[cont_loop])[-1 * (bp)]\n                except IndexError:\n                    aux = \"0\"\n                if aux == \"1\" and x == \"1\":\n                    cont_bo += 1\n        parity.append(cont_bo % 2)\n\n        qtd_bp += 1\n\n    # Mount the message\n    cont_bp = 0  # parity bit counter\n    for x in range(size_par + len(data)):\n        if data_ord[x] is None:\n            data_out.append(str(parity[cont_bp]))\n            cont_bp += 1\n        else:\n            data_out.append(data_ord[x])\n\n    return data_out\n2: def dp_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Dynamic programming matching algorithm.\n\n    | Time complexity: O(\\|text\\| * \\|pattern\\|)\n    | Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]", "output": "0"}
{"input": "summarize code:\ndef random_pivot(lst):\n    \"\"\"\n    Choose a random pivot for the list.\n    We can use a more sophisticated algorithm here, such as the median-of-medians\n    algorithm.\n    \"\"\"\n    return choice(lst)", "output": "Choose a random pivot for the list. We can use a more sophisticated algorithm here, such as the median-of-medians algorithm."}
{"input": "summarize code:\ndef kth_largest_element(arr: list[int], position: int) -> int:\n    \"\"\"\n    Finds the kth largest element in a list.\n    Should deliver similar results to:\n    ```python\n    def kth_largest_element(arr, position):\n        return sorted(arr)[-position]\n    ```\n\n    Args:\n        nums: The list of numbers.\n        k: The position of the desired kth largest element.\n\n    Returns:\n        int: The kth largest element.\n\n    Examples:\n        >>> kth_largest_element([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3)\n        5\n        >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], 1)\n        9\n        >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], -2)\n        Traceback (most recent call last):\n        ...\n        ValueError: Invalid value of 'position'\n        >>> kth_largest_element([9, 1, 3, 6, 7, 9, 8, 4, 2, 4, 9], 110)\n        Traceback (most recent call last):\n        ...\n        ValueError: Invalid value of 'position'\n        >>> kth_largest_element([1, 2, 4, 3, 5, 9, 7, 6, 5, 9, 3], 0)\n        Traceback (most recent call last):\n        ...\n        ValueError: Invalid value of 'position'\n        >>> kth_largest_element(['apple', 'cherry', 'date', 'banana'], 2)\n        'cherry'\n        >>> kth_largest_element([3.1, 1.2, 5.6, 4.7,7.9,5,0], 2)\n        5.6\n        >>> kth_largest_element([-2, -5, -4, -1], 1)\n        -1\n        >>> kth_largest_element([], 1)\n        -1\n        >>> kth_largest_element([3.1, 1.2, 5.6, 4.7, 7.9, 5, 0], 1.5)\n        Traceback (most recent call last):\n        ...\n        ValueError: The position should be an integer\n        >>> kth_largest_element((4, 6, 1, 2), 4)\n        Traceback (most recent call last):\n        ...\n        TypeError: 'tuple' object does not support item assignment\n    \"\"\"\n    if not arr:\n        return -1\n    if not isinstance(position, int):\n        raise ValueError(\"The position should be an integer\")\n    if not 1 <= position <= len(arr):\n        raise ValueError(\"Invalid value of 'position'\")\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        if low > len(arr) - 1 or high < 0:\n            return -1\n        pivot_index = partition(arr, low, high)\n        if pivot_index == position - 1:\n            return arr[pivot_index]\n        elif pivot_index > position - 1:\n            high = pivot_index - 1\n        else:\n            low = pivot_index + 1\n    return -1", "output": "Finds the kth largest element in a list. Should deliver similar results to: ```python def kth_largest_element(arr, position): return sorted(arr)[-position] ```"}
{"input": "summarize code:\ndef solution(chain_length: int = 60, number_limit: int = 1000000) -> int:\n    \"\"\"\n    Returns the number of numbers below number_limit that produce chains with exactly\n    chain_length non repeating elements.\n\n    >>> solution(10.0, 1000)\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameters chain_length and number_limit must be int\n\n    >>> solution(10, 1000.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameters chain_length and number_limit must be int\n\n    >>> solution(0, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameters chain_length and number_limit must be greater than 0\n\n    >>> solution(10, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameters chain_length and number_limit must be greater than 0\n\n    >>> solution(10, 1000)\n    26\n    \"\"\"\n\n    if not isinstance(chain_length, int) or not isinstance(number_limit, int):\n        raise TypeError(\"Parameters chain_length and number_limit must be int\")\n\n    if chain_length <= 0 or number_limit <= 0:\n        raise ValueError(\n            \"Parameters chain_length and number_limit must be greater than 0\"\n        )\n\n    # the counter for the chains with the exact desired length\n    chains_counter = 0\n    # the cached sizes of the previous chains\n    chain_sets_lengths: dict[int, int] = {}\n\n    for start_chain_element in range(1, number_limit):\n        # The temporary set will contain the elements of the chain\n        chain_set = set()\n        chain_set_length = 0\n\n        # Stop computing the chain when you find a cached size, a repeating item or the\n        # length is greater then the desired one.\n        chain_element = start_chain_element\n        while (\n            chain_element not in chain_sets_lengths\n            and chain_element not in chain_set\n            and chain_set_length <= chain_length\n        ):\n            chain_set.add(chain_element)\n            chain_set_length += 1\n            chain_element = digit_factorial_sum(chain_element)\n\n        if chain_element in chain_sets_lengths:\n            chain_set_length += chain_sets_lengths[chain_element]\n\n        chain_sets_lengths[start_chain_element] = chain_set_length\n\n        # If chain contains the exact amount of elements increase the counter\n        if chain_set_length == chain_length:\n            chains_counter += 1\n\n    return chains_counter", "output": "Returns the number of numbers below number_limit that produce chains with exactly chain_length non repeating elements."}
{"input": "search code:\nCalculate the Surface Area of a Cube.\nChoices:\n0: def sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum\n1: def surface_area_cube(side_length: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Cube.\n\n    >>> surface_area_cube(1)\n    6\n    >>> surface_area_cube(1.6)\n    15.360000000000003\n    >>> surface_area_cube(0)\n    0\n    >>> surface_area_cube(3)\n    54\n    >>> surface_area_cube(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cube() only accepts non-negative values\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"surface_area_cube() only accepts non-negative values\")\n    return 6 * side_length**2\n2: def check_bouncy(n: int) -> bool:\n    \"\"\"\n    Returns True if number is bouncy, False otherwise\n    >>> check_bouncy(6789)\n    False\n    >>> check_bouncy(-12345)\n    False\n    >>> check_bouncy(0)\n    False\n    >>> check_bouncy(6.74)\n    Traceback (most recent call last):\n        ...\n    ValueError: check_bouncy() accepts only integer arguments\n    >>> check_bouncy(132475)\n    True\n    >>> check_bouncy(34)\n    False\n    >>> check_bouncy(341)\n    True\n    >>> check_bouncy(47)\n    False\n    >>> check_bouncy(-12.54)\n    Traceback (most recent call last):\n        ...\n    ValueError: check_bouncy() accepts only integer arguments\n    >>> check_bouncy(-6548)\n    True\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"check_bouncy() accepts only integer arguments\")\n    str_n = str(n)\n    sorted_str_n = \"\".join(sorted(str_n))\n    return str_n not in {sorted_str_n, sorted_str_n[::-1]}", "output": "1"}
{"input": "summarize code:\ndef strip(iterable, strip_value=None):\n    \"\"\"Strips values from the beginning and end of an iterable. Stripped items\n    will match the value of the argument strip_value. Functionality is\n    analogous to that of the method str.strip. Returns a list.\n\n    >>> strip(['Fu', 'Foo', 'Bar', 'Bam', 'Fu'], 'Fu')\n    ['Foo', 'Bar', 'Bam']\n\n    \"\"\"\n    return list(strip_iter(iterable, strip_value))", "output": "Strips values from the beginning and end of an iterable. Stripped items will match the value of the argument strip_value. Functionality is analogous to that of the method str.strip. Returns a list."}
{"input": "search code:\nheap helper function get the position of the right child of the current node\nChoices:\n0: def local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:\n    \"\"\"\n    It takes an image, an x and y coordinate, and returns the\n    decimal value of the local binary patternof the pixel\n    at that coordinate\n\n    :param image: the image to be processed\n    :param x_coordinate: x coordinate of the pixel\n    :param y_coordinate: the y coordinate of the pixel\n    :return: The decimal value of the binary value of the pixels\n    around the center pixel.\n    \"\"\"\n    center = image[x_coordinate][y_coordinate]\n    powers = [1, 2, 4, 8, 16, 32, 64, 128]\n\n    # skip get_neighbors_pixel if center is null\n    if center is None:\n        return 0\n\n    # Starting from the top right, assigning value to pixels clockwise\n    binary_values = [\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),\n        get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),\n    ]\n\n    # Converting the binary value to decimal.\n    return sum(\n        binary_value * power for binary_value, power in zip(binary_values, powers)\n    )\n1: def _maybe_download(filename, work_directory, source_url):\n    \"\"\"Download the data from source url, unless it's already here.\n\n    Args:\n        filename: string, name of the file in the directory.\n        work_directory: string, path to working directory.\n        source_url: url to download from if file doesn't exist.\n\n    Returns:\n        Path to resulting file.\n    \"\"\"\n    if not gfile.Exists(work_directory):\n        gfile.MakeDirs(work_directory)\n    filepath = os.path.join(work_directory, filename)\n    if not gfile.Exists(filepath):\n        urllib.request.urlretrieve(source_url, filepath)  # noqa: S310\n        with gfile.GFile(filepath) as f:\n            size = f.size()\n        print(\"Successfully downloaded\", filename, size, \"bytes.\")\n    return filepath\n2: def get_child_right_position(position: int) -> int:\n    \"\"\"\n    heap helper function get the position of the right child of the current node\n\n    >>> get_child_right_position(0)\n    2\n    \"\"\"\n    return (2 * position) + 2", "output": "2"}
{"input": "search code:\nReturns the week-day name out of a given date.\nChoices:\n0: def is_isogram(string: str) -> bool:\n    \"\"\"\n    An isogram is a word in which no letter is repeated.\n    Examples of isograms are uncopyrightable and ambidextrously.\n    >>> is_isogram('Uncopyrightable')\n    True\n    >>> is_isogram('allowance')\n    False\n    >>> is_isogram('copy1')\n    Traceback (most recent call last):\n     ...\n    ValueError: String must only contain alphabetic characters.\n    \"\"\"\n    if not all(x.isalpha() for x in string):\n        raise ValueError(\"String must only contain alphabetic characters.\")\n\n    letters = sorted(string.lower())\n    return len(letters) == len(set(letters))\n1: def is_palindrome(n: int) -> bool:\n    \"\"\"\n    Check if an integer is palindromic.\n    >>> is_palindrome(12521)\n    True\n    >>> is_palindrome(12522)\n    False\n    >>> is_palindrome(12210)\n    False\n    \"\"\"\n    if n % 10 == 0:\n        return False\n    s = str(n)\n    return s == s[::-1]\n2: def get_week_day(year: int, month: int, day: int) -> str:\n    \"\"\"Returns the week-day name out of a given date.\n\n    >>> get_week_day(2020, 10, 24)\n    'Saturday'\n    >>> get_week_day(2017, 10, 24)\n    'Tuesday'\n    >>> get_week_day(2019, 5, 3)\n    'Friday'\n    >>> get_week_day(1970, 9, 16)\n    'Wednesday'\n    >>> get_week_day(1870, 8, 13)\n    'Saturday'\n    >>> get_week_day(2040, 3, 14)\n    'Wednesday'\n\n    \"\"\"\n    # minimal input check:\n    assert len(str(year)) > 2, \"year should be in YYYY format\"\n    assert 1 <= month <= 12, \"month should be between 1 to 12\"\n    assert 1 <= day <= 31, \"day should be between 1 to 31\"\n\n    # Doomsday algorithm:\n    century = year // 100\n    century_anchor = (5 * (century % 4) + 2) % 7\n    centurian = year % 100\n    centurian_m = centurian % 12\n    dooms_day = (\n        (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor\n    ) % 7\n    day_anchor = (\n        DOOMSDAY_NOT_LEAP[month - 1]\n        if year % 4 != 0 or (centurian == 0 and year % 400 != 0)\n        else DOOMSDAY_LEAP[month - 1]\n    )\n    week_day = (dooms_day + day - day_anchor) % 7\n    return WEEK_DAY_NAMES[week_day]", "output": "2"}
{"input": "summarize code:\ndef next_number(number: int) -> int:\n    \"\"\"\n    Returns the next number of the chain by adding the square of each digit\n    to form a new number.\n    For example, if number = 12, next_number() will return 1^2 + 2^2 = 5.\n    Therefore, 5 is the next number of the chain.\n    >>> next_number(44)\n    32\n    >>> next_number(10)\n    1\n    >>> next_number(32)\n    13\n    \"\"\"\n\n    sum_of_digits_squared = 0\n    while number:\n        # Increased Speed Slightly by checking every 5 digits together.\n        sum_of_digits_squared += DIGITS_SQUARED[number % 100000]\n        number //= 100000\n\n    return sum_of_digits_squared", "output": "Returns the next number of the chain by adding the square of each digit to form a new number. For example, if number = 12, next_number() will return 1^2 + 2^2 = 5. Therefore, 5 is the next number of the chain. >>> next_number(44) 32 >>> next_number(10) 1 >>> next_number(32) 13"}
{"input": "search code:\nAsk for user value and validate that it fulfill a condition.\nChoices:\n0: def create_edge(nodes, graph, cluster, c1):\n    \"\"\"\n    create edge between the nodes\n    \"\"\"\n    for i in cluster[c1]:\n        count = 0\n        c2 = c1 + 1\n        while c2 < max(cluster.keys()):\n            for j in cluster[c2]:\n                \"\"\"\n                creates edge only if the condition satisfies\n                \"\"\"\n                if int(i, 2) & int(j, 2) == int(i, 2):\n                    if tuple(nodes[i]) in graph:\n                        graph[tuple(nodes[i])].append(nodes[j])\n                    else:\n                        graph[tuple(nodes[i])] = [nodes[j]]\n                    count += 1\n            if count == 0:\n                c2 = c2 + 1\n            else:\n                break\n1: def valid_input(\n    input_type: Callable[[object], num],  # Usually float or int\n    input_msg: str,\n    err_msg: str,\n    condition: Callable[[num], bool] = lambda _: True,\n    default: str | None = None,\n) -> num:\n    \"\"\"\n    Ask for user value and validate that it fulfill a condition.\n\n    :input_type: user input expected type of value\n    :input_msg: message to show user in the screen\n    :err_msg: message to show in the screen in case of error\n    :condition: function that represents the condition that user input is valid.\n    :default: Default value in case the user does not type anything\n    :return: user's input\n    \"\"\"\n    while True:\n        try:\n            user_input = input_type(input(input_msg).strip() or default)\n            if condition(user_input):\n                return user_input\n            else:\n                print(f\"{user_input}: {err_msg}\")\n                continue\n        except ValueError:\n            print(\n                f\"{user_input}: Incorrect input type, expected {input_type.__name__!r}\"\n            )\n2: def remove_digit(num: int) -> int:\n    \"\"\"\n\n    returns the biggest possible result\n    that can be achieved by removing\n    one digit from the given number\n\n    >>> remove_digit(152)\n    52\n    >>> remove_digit(6385)\n    685\n    >>> remove_digit(-11)\n    1\n    >>> remove_digit(2222222)\n    222222\n    >>> remove_digit(\"2222222\")\n    Traceback (most recent call last):\n    TypeError: only integers accepted as input\n    >>> remove_digit(\"string input\")\n    Traceback (most recent call last):\n    TypeError: only integers accepted as input\n    \"\"\"\n\n    if not isinstance(num, int):\n        raise TypeError(\"only integers accepted as input\")\n    else:\n        num_str = str(abs(num))\n        num_transpositions = [list(num_str) for char in range(len(num_str))]\n        for index in range(len(num_str)):\n            num_transpositions[index].pop(index)\n        return max(\n            int(\"\".join(list(transposition))) for transposition in num_transpositions\n        )", "output": "1"}
{"input": "search code:\nCalculate the number of non-bouncy numbers less than a googol. >>> solution(6) 12951 >>> solution(10) 277032\nChoices:\n0: def benchmark() -> None:\n    \"\"\"\n    Benchmark multiple functions, with three different length int values.\n    \"\"\"\n    from collections.abc import Callable\n    from timeit import timeit\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        # print(f\"{call:38} = {func(value)} -- {timing:.4f} seconds\")\n        print(f\"{call:38} -- {timing:.4f} seconds\")\n\n    for value in range(15):  # (1, 7, 14):\n        for func in (generate_pascal_triangle, generate_pascal_triangle_optimized):\n            benchmark_a_function(func, value)\n        print()\n1: def wheatstone_solver(\n    resistance_1: float, resistance_2: float, resistance_3: float\n) -> float:\n    \"\"\"\n    This function can calculate the unknown resistance in an wheatstone network,\n    given that the three other resistances in the network are known.\n    The formula to calculate the same is:\n\n    ---------------\n    |Rx=(R2/R1)*R3|\n    ---------------\n\n    Usage examples:\n    >>> wheatstone_solver(resistance_1=2, resistance_2=4, resistance_3=5)\n    10.0\n    >>> wheatstone_solver(resistance_1=356, resistance_2=234, resistance_3=976)\n    641.5280898876405\n    >>> wheatstone_solver(resistance_1=2, resistance_2=-1, resistance_3=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: All resistance values must be positive\n    >>> wheatstone_solver(resistance_1=0, resistance_2=0, resistance_3=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: All resistance values must be positive\n    \"\"\"\n\n    if resistance_1 <= 0 or resistance_2 <= 0 or resistance_3 <= 0:\n        raise ValueError(\"All resistance values must be positive\")\n    else:\n        return float((resistance_2 / resistance_1) * resistance_3)\n2: def solution(num_digits: int = 100) -> int:\n    \"\"\"\n    Calculate the number of non-bouncy numbers less than a googol.\n    >>> solution(6)\n    12951\n    >>> solution(10)\n    277032\n    \"\"\"\n    return non_bouncy_upto(num_digits)", "output": "2"}
{"input": "summarize code:\ndef evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))", "output": "Evaluate how similar the item is with the target by just counting each char in the right position >>> evaluate(\"Helxo Worlx\", \"Hello World\") ('Helxo Worlx', 9.0)"}
{"input": "summarize code:\ndef solution() -> int | None:\n    \"\"\"\n    Return the largest 1 to 9 pandigital 9-digital number that can be formed as the\n    concatenated product of an integer with (1,2,...,n) where n > 1.\n    \"\"\"\n    for base_num in range(9999, 4999, -1):\n        candidate = 100002 * base_num\n        if is_9_pandigital(candidate):\n            return candidate\n\n    for base_num in range(333, 99, -1):\n        candidate = 1002003 * base_num\n        if is_9_pandigital(candidate):\n            return candidate\n\n    return None", "output": "Return the largest 1 to 9 pandigital 9-digital number that can be formed as the concatenated product of an integer with (1,2,...,n) where n > 1."}
{"input": "search code:\nReturns a list of *count* chunks, each with *size* elements, generated from iterable *src*. If *src* is not evenly divisible by *size*, the final chunk will have fewer than *size* elements. Provide the *fill* keyword argument to provide a pad value and enable padding, otherwise no padding will take place.\nChoices:\n0: def get_all(type_obj, include_subtypes=True):\n    \"\"\"Get a list containing all instances of a given type.  This will\n    work for the vast majority of types out there.\n\n    >>> class Ratking(object): pass\n    >>> wiki, hak, sport = Ratking(), Ratking(), Ratking()\n    >>> len(get_all(Ratking))\n    3\n\n    However, there are some exceptions. For example, ``get_all(bool)``\n    returns an empty list because ``True`` and ``False`` are\n    themselves built-in and not tracked.\n\n    >>> get_all(bool)\n    []\n\n    Still, it's not hard to see how this functionality can be used to\n    find all instances of a leaking type and track them down further\n    using :func:`gc.get_referrers` and :func:`gc.get_referents`.\n\n    ``get_all()`` is optimized such that getting instances of\n    user-created types is quite fast. Setting *include_subtypes* to\n    ``False`` will further increase performance in cases where\n    instances of subtypes aren't required.\n\n    .. note::\n\n      There are no guarantees about the state of objects returned by\n      ``get_all()``, especially in concurrent environments. For\n      instance, it is possible for an object to be in the middle of\n      executing its ``__init__()`` and be only partially constructed.\n    \"\"\"\n    # TODO: old-style classes\n    if not isinstance(type_obj, type):\n        raise TypeError('expected a type, not %r' % type_obj)\n    try:\n        type_is_tracked = gc.is_tracked(type_obj)\n    except AttributeError:\n        type_is_tracked = False  # Python 2.6 and below don't get the speedup\n    if type_is_tracked:\n        to_check = gc.get_referrers(type_obj)\n    else:\n        to_check = gc.get_objects()\n\n    if include_subtypes:\n        ret = [x for x in to_check if isinstance(x, type_obj)]\n    else:\n        ret = [x for x in to_check if type(x) is type_obj]\n    return ret\n1: def solution(n: int = 10000) -> int:\n    \"\"\"Returns the sum of all the amicable numbers under n.\n\n    >>> solution(10000)\n    31626\n    >>> solution(5000)\n    8442\n    >>> solution(1000)\n    504\n    >>> solution(100)\n    0\n    >>> solution(50)\n    0\n    \"\"\"\n    total = sum(\n        i\n        for i in range(1, n)\n        if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i\n    )\n    return total\n2: def chunked(src, size, count=None, **kw):\n    \"\"\"Returns a list of *count* chunks, each with *size* elements,\n    generated from iterable *src*. If *src* is not evenly divisible by\n    *size*, the final chunk will have fewer than *size* elements.\n    Provide the *fill* keyword argument to provide a pad value and\n    enable padding, otherwise no padding will take place.\n\n    >>> chunked(range(10), 3)\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n    >>> chunked(range(10), 3, fill=None)\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, None, None]]\n    >>> chunked(range(10), 3, count=2)\n    [[0, 1, 2], [3, 4, 5]]\n\n    See :func:`chunked_iter` for more info.\n    \"\"\"\n    chunk_iter = chunked_iter(src, size, **kw)\n    if count is None:\n        return list(chunk_iter)\n    else:\n        return list(itertools.islice(chunk_iter, count))", "output": "2"}
{"input": "summarize code:\ndef _extract_labels(f, one_hot=False, num_classes=10):\n    \"\"\"Extract the labels into a 1D uint8 numpy array [index].\n\n    Args:\n      f: A file object that can be passed into a gzip reader.\n      one_hot: Does one hot encoding for the result.\n      num_classes: Number of classes for the one hot encoding.\n\n    Returns:\n      labels: a 1D uint8 numpy array.\n\n    Raises:\n      ValueError: If the bystream doesn't start with 2049.\n    \"\"\"\n    print(\"Extracting\", f.name)\n    with gzip.GzipFile(fileobj=f) as bytestream:\n        magic = _read32(bytestream)\n        if magic != 2049:\n            msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"\n            raise ValueError(msg)\n        num_items = _read32(bytestream)\n        buf = bytestream.read(num_items)\n        labels = np.frombuffer(buf, dtype=np.uint8)\n        if one_hot:\n            return _dense_to_one_hot(labels, num_classes)\n        return labels", "output": "Extract the labels into a 1D uint8 numpy array [index]."}
{"input": "summarize code:\ndef is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:\n    \"\"\"\n    This function checks the grid to see if each row,\n    column, and the 3x3 subgrids contain the digit 'n'.\n    It returns False if it is not 'safe' (a duplicate digit\n    is found) else returns True if it is 'safe'\n    \"\"\"\n    for i in range(9):\n        if n in {grid[row][i], grid[i][column]}:\n            return False\n\n    for i in range(3):\n        for j in range(3):\n            if grid[(row - row % 3) + i][(column - column % 3) + j] == n:\n                return False\n\n    return True", "output": "This function checks the grid to see if each row, column, and the 3x3 subgrids contain the digit 'n'. It returns False if it is not 'safe' (a duplicate digit is found) else returns True if it is 'safe'"}
{"input": "summarize code:\ndef validate_credit_card_number(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to validate the given credit card number.\n    >>> validate_credit_card_number('4111111111111111')\n    4111111111111111 is a valid credit card number.\n    True\n    >>> validate_credit_card_number('helloworld$')\n    helloworld$ is an invalid credit card number because it has nonnumerical characters.\n    False\n    >>> validate_credit_card_number('32323')\n    32323 is an invalid credit card number because of its length.\n    False\n    >>> validate_credit_card_number('32323323233232332323')\n    32323323233232332323 is an invalid credit card number because of its length.\n    False\n    >>> validate_credit_card_number('36111111111111')\n    36111111111111 is an invalid credit card number because of its first two digits.\n    False\n    >>> validate_credit_card_number('41111111111111')\n    41111111111111 is an invalid credit card number because it fails the Luhn check.\n    False\n    \"\"\"\n    error_message = f\"{credit_card_number} is an invalid credit card number because\"\n    if not credit_card_number.isdigit():\n        print(f\"{error_message} it has nonnumerical characters.\")\n        return False\n\n    if not 13 <= len(credit_card_number) <= 16:\n        print(f\"{error_message} of its length.\")\n        return False\n\n    if not validate_initial_digits(credit_card_number):\n        print(f\"{error_message} of its first two digits.\")\n        return False\n\n    if not luhn_validation(credit_card_number):\n        print(f\"{error_message} it fails the Luhn check.\")\n        return False\n\n    print(f\"{credit_card_number} is a valid credit card number.\")\n    return True", "output": "Function to validate the given credit card number. >>> validate_credit_card_number('4111111111111111') 4111111111111111 is a valid credit card number. True >>> validate_credit_card_number('helloworld$') helloworld$ is an invalid credit card number because it has nonnumerical characters. False >>> validate_credit_card_number('32323') 32323 is an invalid credit card number because of its length. False >>> validate_credit_card_number('32323323233232332323') 32323323233232332323 is an invalid credit card number because of its length. False >>> validate_credit_card_number('36111111111111') 36111111111111 is an invalid credit card number because of its first two digits. False >>> validate_credit_card_number('41111111111111') 41111111111111 is an invalid credit card number because it fails the Luhn check. False"}
{"input": "summarize code:\ndef convex_hull_bf(points: list[Point]) -> list[Point]:\n    \"\"\"\n    Constructs the convex hull of a set of 2D points using a brute force algorithm.\n    The algorithm basically considers all combinations of points (i, j) and uses the\n    definition of convexity to determine whether (i, j) is part of the convex hull or\n    not.  (i, j) is part of the convex hull if and only iff there are no points on both\n    sides of the line segment connecting the ij, and there is no point k such that k is\n    on either end of the ij.\n\n    Runtime: O(n^3) - definitely horrible\n\n    Parameters\n    ---------\n    points: array-like of object of Points, lists or tuples.\n    The set of  2d points for which the convex-hull is needed\n\n    Returns\n    ------\n    convex_set: list, the convex-hull of points sorted in non-decreasing order.\n\n    See Also\n    --------\n    convex_hull_recursive,\n\n     Examples\n     ---------\n     >>> convex_hull_bf([[0, 0], [1, 0], [10, 1]])\n     [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\n     >>> convex_hull_bf([[0, 0], [1, 0], [10, 0]])\n     [(0.0, 0.0), (10.0, 0.0)]\n     >>> convex_hull_bf([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\n     ...                 [-0.75, 1]])\n     [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n     >>> convex_hull_bf([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\n     ...                 (2, -1), (2, -4), (1, -3)])\n     [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]\n    \"\"\"\n\n    points = sorted(_validate_input(points))\n    n = len(points)\n    convex_set = set()\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            points_left_of_ij = points_right_of_ij = False\n            ij_part_of_convex_hull = True\n            for k in range(n):\n                if k not in {i, j}:\n                    det_k = _det(points[i], points[j], points[k])\n\n                    if det_k > 0:\n                        points_left_of_ij = True\n                    elif det_k < 0:\n                        points_right_of_ij = True\n                    # point[i], point[j], point[k] all lie on a straight line\n                    # if point[k] is to the left of point[i] or it's to the\n                    # right of point[j], then point[i], point[j] cannot be\n                    # part of the convex hull of A\n                    elif points[k] < points[i] or points[k] > points[j]:\n                        ij_part_of_convex_hull = False\n                        break\n\n                if points_left_of_ij and points_right_of_ij:\n                    ij_part_of_convex_hull = False\n                    break\n\n            if ij_part_of_convex_hull:\n                convex_set.update([points[i], points[j]])\n\n    return sorted(convex_set)", "output": "Constructs the convex hull of a set of 2D points using a brute force algorithm. The algorithm basically considers all combinations of points (i, j) and uses the definition of convexity to determine whether (i, j) is part of the convex hull or not. (i, j) is part of the convex hull if and only iff there are no points on both sides of the line segment connecting the ij, and there is no point k such that k is on either end of the ij."}
{"input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\nChoices:\n0: def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n1: def open_knight_tour_helper(\n    board: list[list[int]], pos: tuple[int, int], curr: int\n) -> bool:\n    \"\"\"\n    Helper function to solve knight tour problem.\n    \"\"\"\n\n    if is_complete(board):\n        return True\n\n    for position in get_valid_pos(pos, len(board)):\n        y, x = position\n\n        if board[y][x] == 0:\n            board[y][x] = curr + 1\n            if open_knight_tour_helper(board, position, curr + 1):\n                return True\n            board[y][x] = 0\n\n    return False\n2: def vol_cuboid(width: float, height: float, length: float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cuboid.\n\n    :return: multiple of `width`, `length` and `height`\n\n    >>> vol_cuboid(1, 1, 1)\n    1.0\n    >>> vol_cuboid(1, 2, 3)\n    6.0\n    >>> vol_cuboid(1.6, 2.6, 3.6)\n    14.976\n    >>> vol_cuboid(0, 0, 0)\n    0.0\n    >>> vol_cuboid(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    >>> vol_cuboid(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    >>> vol_cuboid(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    \"\"\"\n    if width < 0 or height < 0 or length < 0:\n        raise ValueError(\"vol_cuboid() only accepts non-negative values\")\n    return float(width * height * length)", "output": "0"}
{"input": "search code:\nCalculate the score for a character pair based on whether they match or mismatch. Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the characters is a gap. >>> score_function('A', 'A') 1 >>> score_function('A', 'C') -1 >>> score_function('-', 'A') -2 >>> score_function('A', '-') -2 >>> score_function('-', '-') -2\nChoices:\n0: def score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch\n1: def solution():\n    \"\"\"\n    Finds the sum of all products whose multiplicand/multiplier/product identity\n    can be written as a 1 through 9 pandigital\n\n    >>> solution()\n    45228\n    \"\"\"\n\n    return sum(\n        {\n            int(\"\".join(pandigital[5:9]))\n            for pandigital in itertools.permutations(\"123456789\")\n            if is_combination_valid(pandigital)\n        }\n    )\n2: def count_vowels(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a given string.\n\n    :param s: Input string to count vowels in.\n    :return: Number of vowels in the input string.\n\n    Examples:\n    >>> count_vowels(\"hello world\")\n    3\n    >>> count_vowels(\"HELLO WORLD\")\n    3\n    >>> count_vowels(\"123 hello world\")\n    3\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a quick brown fox\")\n    5\n    >>> count_vowels(\"the quick BROWN fox\")\n    5\n    >>> count_vowels(\"PYTHON\")\n    1\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)", "output": "0"}
{"input": "summarize code:\ndef main():\n    \"\"\"Call Modular Exponential Function.\"\"\"\n    print(modular_exponential(3, 200, 13))", "output": "Call Modular Exponential Function."}
{"input": "search code:\nreturns a square zero-matrix of dimension NxN\nChoices:\n0: def square_zero_matrix(n: int) -> Matrix:\n    \"\"\"\n    returns a square zero-matrix of dimension NxN\n    \"\"\"\n    ans: list[list[float]] = [[0] * n for _ in range(n)]\n    return Matrix(ans, n, n)\n1: def solution(num: int = 100) -> int:\n    \"\"\"Returns the sum of the digits in the factorial of num\n    >>> solution(100)\n    648\n    >>> solution(50)\n    216\n    >>> solution(10)\n    27\n    >>> solution(5)\n    3\n    >>> solution(3)\n    6\n    >>> solution(2)\n    2\n    >>> solution(1)\n    1\n    \"\"\"\n    fact = 1\n    result = 0\n    for i in range(1, num + 1):\n        fact *= i\n\n    for j in str(fact):\n        result += int(j)\n\n    return result\n2: def plot_partition_boundary(\n    model, train_data, ax, resolution=100, colors=(\"b\", \"k\", \"r\")\n):\n    \"\"\"\n    We cannot get the optimal w of our kernel SVM model, which is different from a\n    linear SVM.  For this reason, we generate randomly distributed points with high\n    density, and predicted values of these points are calculated using our trained\n    model. Then we could use this predicted values to draw contour map, and this contour\n    map represents the SVM's partition boundary.\n    \"\"\"\n    train_data_x = train_data[:, 1]\n    train_data_y = train_data[:, 2]\n    train_data_tags = train_data[:, 0]\n    xrange = np.linspace(train_data_x.min(), train_data_x.max(), resolution)\n    yrange = np.linspace(train_data_y.min(), train_data_y.max(), resolution)\n    test_samples = np.array([(x, y) for x in xrange for y in yrange]).reshape(\n        resolution * resolution, 2\n    )\n\n    test_tags = model.predict(test_samples, classify=False)\n    grid = test_tags.reshape((len(xrange), len(yrange)))\n\n    # Plot contour map which represents the partition boundary\n    ax.contour(\n        xrange,\n        yrange,\n        np.asmatrix(grid).T,\n        levels=(-1, 0, 1),\n        linestyles=(\"--\", \"-\", \"--\"),\n        linewidths=(1, 1, 1),\n        colors=colors,\n    )\n    # Plot all train samples\n    ax.scatter(\n        train_data_x,\n        train_data_y,\n        c=train_data_tags,\n        cmap=plt.cm.Dark2,\n        lw=0,\n        alpha=0.5,\n    )\n\n    # Plot support vectors\n    support = model.support\n    ax.scatter(\n        train_data_x[support],\n        train_data_y[support],\n        c=train_data_tags[support],\n        cmap=plt.cm.Dark2,\n    )", "output": "0"}
{"input": "summarize code:\ndef find_unique_number(arr: list[int]) -> int:\n    \"\"\"\n    Given a list of integers where every element appears twice except for one,\n    this function returns the element that appears only once using bitwise XOR.\n\n    >>> find_unique_number([1, 1, 2, 2, 3])\n    3\n    >>> find_unique_number([4, 5, 4, 6, 6])\n    5\n    >>> find_unique_number([7])\n    7\n    >>> find_unique_number([10, 20, 10])\n    20\n    >>> find_unique_number([])\n    Traceback (most recent call last):\n        ...\n    ValueError: input list must not be empty\n    >>> find_unique_number([1, 'a', 1])\n    Traceback (most recent call last):\n        ...\n    TypeError: all elements must be integers\n    \"\"\"\n    if not arr:\n        raise ValueError(\"input list must not be empty\")\n    if not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"all elements must be integers\")\n\n    result = 0\n    for num in arr:\n        result ^= num\n    return result", "output": "Given a list of integers where every element appears twice except for one, this function returns the element that appears only once using bitwise XOR."}
{"input": "summarize code:\ndef add_file_length(source_path: str, compressed: str) -> str:\n    \"\"\"\n    Adds given file's length in front (using Elias  gamma coding) of the compressed\n    string\n    \"\"\"\n    file_length = os.path.getsize(source_path)\n    file_length_binary = bin(file_length)[2:]\n    length_length = len(file_length_binary)\n\n    return \"0\" * (length_length - 1) + file_length_binary + compressed", "output": "Adds given file's length in front (using Elias gamma coding) of the compressed string"}
{"input": "search code:\nCalculate the distance between the two endpoints of two vectors without numpy. A vector is defined as a list, tuple, or numpy 1D array. >>> euclidean_distance_no_np((0, 0), (2, 2)) 2.8284271247461903 >>> euclidean_distance_no_np([1, 2, 3, 4], [5, 6, 7, 8]) 8.0\nChoices:\n0: def euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:\n    \"\"\"\n    Calculate the distance between the two endpoints of two vectors without numpy.\n    A vector is defined as a list, tuple, or numpy 1D array.\n    >>> euclidean_distance_no_np((0, 0), (2, 2))\n    2.8284271247461903\n    >>> euclidean_distance_no_np([1, 2, 3, 4], [5, 6, 7, 8])\n    8.0\n    \"\"\"\n    return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)\n1: def while_solution(max_number: int = 10**8) -> int:\n    \"\"\"\n    Returns the number of composite integers below max_number have precisely two,\n    not necessarily distinct, prime factors.\n\n    >>> while_solution(30)\n    10\n    \"\"\"\n\n    prime_numbers = calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left <= right:\n        while prime_numbers[left] * prime_numbers[right] >= max_number:\n            right -= 1\n        semiprimes_count += right - left + 1\n        left += 1\n\n    return semiprimes_count\n2: def locate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(locate([0, 1, 1, 0, 1, 0, 0]))\n        [1, 2, 4]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item.\n\n        >>> list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b'))\n        [1, 3]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(locate(iterable, pred=pred, window_size=3))\n        [1, 5, 9]\n\n    Use with :func:`seekable` to find indexes and then retrieve the associated\n    items:\n\n        >>> from itertools import count\n        >>> from more_itertools import seekable\n        >>> source = (3 * n + 1 if (n % 2) else n // 2 for n in count())\n        >>> it = seekable(source)\n        >>> pred = lambda x: x > 100\n        >>> indexes = locate(it, pred=pred)\n        >>> i = next(indexes)\n        >>> it.seek(i)\n        >>> next(it)\n        106\n\n    \"\"\"\n    if window_size is None:\n        return compress(count(), map(pred, iterable))\n\n    if window_size < 1:\n        raise ValueError('window size must be at least 1')\n\n    it = windowed(iterable, window_size, fillvalue=_marker)\n    return compress(count(), starmap(pred, it))", "output": "0"}
{"input": "search code:\nCalculate a Lorentz transformation for movement in the x direction given a velocity and a four-vector for an inertial reference frame\nChoices:\n0: def solution(pence: int = 200) -> int:\n    \"\"\"Returns the number of different ways to make X pence using any number of coins.\n    The solution is based on dynamic programming paradigm in a bottom-up fashion.\n\n    >>> solution(500)\n    6295434\n    >>> solution(200)\n    73682\n    >>> solution(50)\n    451\n    >>> solution(10)\n    11\n    \"\"\"\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    number_of_ways = [0] * (pence + 1)\n    number_of_ways[0] = 1  # base case: 1 way to make 0 pence\n\n    for coin in coins:\n        for i in range(coin, pence + 1, 1):\n            number_of_ways[i] += number_of_ways[i - coin]\n    return number_of_ways[pence]\n1: def calculate_prime_numbers(max_number: int) -> list[int]:\n    \"\"\"\n    Returns prime numbers below max_number\n\n    >>> calculate_prime_numbers(10)\n    [2, 3, 5, 7]\n    \"\"\"\n\n    is_prime = [True] * max_number\n    for i in range(2, isqrt(max_number - 1) + 1):\n        if is_prime[i]:\n            for j in range(i**2, max_number, i):\n                is_prime[j] = False\n\n    return [i for i in range(2, max_number) if is_prime[i]]\n2: def transform(velocity: float, event: np.ndarray | None = None) -> np.ndarray:\n    \"\"\"\n    Calculate a Lorentz transformation for movement in the x direction given a\n    velocity and a four-vector for an inertial reference frame\n\n    If no four-vector is given, then calculate the transformation symbolically\n    with variables\n    >>> transform(29979245, np.array([1, 2, 3, 4]))\n    array([ 3.01302757e+08, -3.01302729e+07,  3.00000000e+00,  4.00000000e+00])\n    >>> transform(29979245)\n    array([1.00503781498831*ct - 0.100503778816875*x,\n           -0.100503778816875*ct + 1.00503781498831*x, 1.0*y, 1.0*z],\n          dtype=object)\n    >>> transform(19879210.2)\n    array([1.0022057787097*ct - 0.066456172618675*x,\n           -0.066456172618675*ct + 1.0022057787097*x, 1.0*y, 1.0*z],\n          dtype=object)\n    >>> transform(299792459, np.array([1, 1, 1, 1]))\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must not exceed light speed 299,792,458 [m/s]!\n    >>> transform(-1, np.array([1, 1, 1, 1]))\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must be greater than or equal to 1!\n    \"\"\"\n    # Ensure event is not empty\n    if event is None:\n        event = np.array([ct, x, y, z])  # Symbolic four vector\n    else:\n        event[0] *= c  # x0 is ct (speed of light * time)\n\n    return transformation_matrix(velocity) @ event", "output": "2"}
{"input": "search code:\nUtility-function to check that two hsv-colors are approximately equal\nChoices:\n0: def euler_phi(n: int) -> int:\n    \"\"\"Calculate Euler's Phi Function.\n    >>> euler_phi(100)\n    40\n    >>> euler_phi(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    >>> euler_phi(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    s = n\n    for x in set(prime_factors(n)):\n        s *= (x - 1) / x\n    return int(s)\n1: def iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:\n    \"\"\"\n    Go through the number of iterations determined by the argument \"steps\".\n    Be careful with high values (above 5) since the time to calculate increases\n    exponentially.\n    >>> iterate([np.array([0, 0]), np.array([1, 0])], 1)\n    [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , \\\n0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]\n    \"\"\"\n    vectors = initial_vectors\n    for _ in range(steps):\n        vectors = iteration_step(vectors)\n    return vectors\n2: def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value", "output": "2"}
{"input": "summarize code:\ndef pairwise_iter(src, end=_UNSET):\n    \"\"\"Convenience function for calling :func:`windowed_iter` on *src*,\n    with *size* set to 2.\n\n    >>> list(pairwise_iter(range(5)))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n    >>> list(pairwise_iter([]))\n    []\n\n    Unless *end* is set, the number of pairs is always one less \n    than the number of elements in the iterable passed in, \n    or zero, when *src* is empty.\n\n    With *end* set, a number of pairs equal to the length of *src* is returned,\n    with the last item of the last pair being equal to *end*. \n\n    >>> list(pairwise_iter(range(3), end=None))\n    [(0, 1), (1, 2), (2, None)]    \n\n    This way, *end* values can be useful as sentinels to signal the end\n    of the iterable. For infinite iterators, setting *end* has no effect.\n    \"\"\"\n    return windowed_iter(src, 2, fill=end)", "output": "Convenience function for calling :func:`windowed_iter` on *src*, with *size* set to 2."}
{"input": "summarize code:\ndef get_set_bits_count_using_brian_kernighans_algorithm(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(25)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(37)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(21)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(58)\n    4\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(0)\n    0\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(256)\n    1\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must not be negative\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"the value of input must not be negative\")\n    result = 0\n    while number:\n        number &= number - 1\n        result += 1\n    return result", "output": "Count the number of set bits in a 32 bit integer >>> get_set_bits_count_using_brian_kernighans_algorithm(25) 3 >>> get_set_bits_count_using_brian_kernighans_algorithm(37) 3 >>> get_set_bits_count_using_brian_kernighans_algorithm(21) 3 >>> get_set_bits_count_using_brian_kernighans_algorithm(58) 4 >>> get_set_bits_count_using_brian_kernighans_algorithm(0) 0 >>> get_set_bits_count_using_brian_kernighans_algorithm(256) 1 >>> get_set_bits_count_using_brian_kernighans_algorithm(-1) Traceback (most recent call last): ... ValueError: the value of input must not be negative"}
{"input": "search code:\nReturns the total of all the name scores in the file.\nChoices:\n0: def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times\n1: def solution():\n    \"\"\"Returns the total of all the name scores in the file.\n\n    >>> solution()\n    871198282\n    \"\"\"\n    total_sum = 0\n    temp_sum = 0\n    with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:\n        name = str(file.readlines()[0])\n        name = name.replace('\"', \"\").split(\",\")\n\n    name.sort()\n    for i in range(len(name)):\n        for j in name[i]:\n            temp_sum += ord(j) - ord(\"A\") + 1\n        total_sum += (i + 1) * temp_sum\n        temp_sum = 0\n    return total_sum\n2: def maclaurin_cos(theta: float, accuracy: int = 30) -> float:\n    \"\"\"\n    Finds the maclaurin approximation of cos\n\n    :param theta: the angle to which cos is found\n    :param accuracy: the degree of accuracy wanted\n    :return: the value of cosine in radians\n\n\n    >>> from math import isclose, cos\n    >>> all(isclose(maclaurin_cos(x, 50), cos(x)) for x in range(-25, 25))\n    True\n    >>> maclaurin_cos(5)\n    0.2836621854632268\n    >>> maclaurin_cos(-5)\n    0.2836621854632265\n    >>> maclaurin_cos(10, 15)\n    -0.8390715290764524\n    >>> maclaurin_cos(-10, 15)\n    -0.8390715290764521\n    >>> maclaurin_cos(\"10\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires either an int or float for theta\n    >>> maclaurin_cos(10, -30)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    >>> maclaurin_cos(10, 30.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    >>> maclaurin_cos(10, \"30\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    \"\"\"\n\n    if not isinstance(theta, (int, float)):\n        raise ValueError(\"maclaurin_cos() requires either an int or float for theta\")\n\n    if not isinstance(accuracy, int) or accuracy <= 0:\n        raise ValueError(\"maclaurin_cos() requires a positive int for accuracy\")\n\n    theta = float(theta)\n    div = theta // (2 * pi)\n    theta -= 2 * div * pi\n    return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))", "output": "1"}
{"input": "search code:\nConvert a decimal representation of an IP address to its IPv4 format.\nChoices:\n0: def to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word\n1: def decimal_to_ipv4(decimal_ipv4: int) -> str:\n    \"\"\"\n    Convert a decimal representation of an IP address to its IPv4 format.\n\n    Args:\n        decimal_ipv4: An integer representing the decimal IP address.\n\n    Returns:\n        The IPv4 representation of the decimal IP address.\n\n    >>> decimal_to_ipv4(3232235521)\n    '192.168.0.1'\n    >>> decimal_to_ipv4(167772415)\n    '10.0.0.255'\n    >>> decimal_to_ipv4(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid decimal IPv4 address\n    \"\"\"\n\n    if not (0 <= decimal_ipv4 <= 4294967295):\n        raise ValueError(\"Invalid decimal IPv4 address\")\n\n    ip_parts = []\n    for _ in range(4):\n        ip_parts.append(str(decimal_ipv4 & 255))\n        decimal_ipv4 >>= 8\n\n    return \".\".join(reversed(ip_parts))\n2: def check_partition_perfect(positive_integer: int) -> bool:\n    \"\"\"\n\n    Check if t = f(positive_integer) = log2(sqrt(4*positive_integer+1)/2 + 1/2) is a\n    real number.\n\n    >>> check_partition_perfect(2)\n    True\n\n    >>> check_partition_perfect(6)\n    False\n\n    \"\"\"\n\n    exponent = math.log2(math.sqrt(4 * positive_integer + 1) / 2 + 1 / 2)\n\n    return exponent == int(exponent)", "output": "1"}
{"input": "summarize code:\ndef solution(m: int = 100) -> int:\n    \"\"\"\n    Returns the number of different ways the number m can be written as a\n    sum of at least two positive integers.\n\n    >>> solution(100)\n    190569291\n    >>> solution(50)\n    204225\n    >>> solution(30)\n    5603\n    >>> solution(10)\n    41\n    >>> solution(5)\n    6\n    >>> solution(3)\n    2\n    >>> solution(2)\n    1\n    >>> solution(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1", "output": "Returns the number of different ways the number m can be written as a sum of at least two positive integers."}
{"input": "summarize code:\ndef dis_between_closest_pair(points, points_counts, min_dis=float(\"inf\")):\n    \"\"\"\n    brute force approach to find distance between closest pair points\n\n    Parameters :\n    points, points_count, min_dis (list(tuple(int, int)), int, int)\n\n    Returns :\n    min_dis (float):  distance between closest pair of points\n\n    >>> dis_between_closest_pair([[1,2],[2,4],[5,7],[8,9],[11,0]],5)\n    5\n\n    \"\"\"\n\n    for i in range(points_counts - 1):\n        for j in range(i + 1, points_counts):\n            current_dis = euclidean_distance_sqr(points[i], points[j])\n            min_dis = min(min_dis, current_dis)\n    return min_dis", "output": "brute force approach to find distance between closest pair points"}
{"input": "search code:\nYield the elements from *iterable*, followed by *fillvalue*, such that at least *n* items are emitted.\nChoices:\n0: def padded(iterable, fillvalue=None, n=None, next_multiple=False):\n    \"\"\"Yield the elements from *iterable*, followed by *fillvalue*, such that\n    at least *n* items are emitted.\n\n        >>> list(padded([1, 2, 3], '?', 5))\n        [1, 2, 3, '?', '?']\n\n    If *next_multiple* is ``True``, *fillvalue* will be emitted until the\n    number of items emitted is a multiple of *n*:\n\n        >>> list(padded([1, 2, 3, 4], n=3, next_multiple=True))\n        [1, 2, 3, 4, None, None]\n\n    If *n* is ``None``, *fillvalue* will be emitted indefinitely.\n\n    To create an *iterable* of exactly size *n*, you can truncate with\n    :func:`islice`.\n\n        >>> list(islice(padded([1, 2, 3], '?'), 5))\n        [1, 2, 3, '?', '?']\n        >>> list(islice(padded([1, 2, 3, 4, 5, 6, 7, 8], '?'), 5))\n        [1, 2, 3, 4, 5]\n\n    \"\"\"\n    iterator = iter(iterable)\n    iterator_with_repeat = chain(iterator, repeat(fillvalue))\n\n    if n is None:\n        return iterator_with_repeat\n    elif n < 1:\n        raise ValueError('n must be at least 1')\n    elif next_multiple:\n\n        def slice_generator():\n            for first in iterator:\n                yield (first,)\n                yield islice(iterator_with_repeat, n - 1)\n\n        # While elements exist produce slices of size n\n        return chain.from_iterable(slice_generator())\n    else:\n        # Ensure the first batch is at least size n then iterate\n        return chain(islice(iterator_with_repeat, n), iterator)\n1: def largest_rectangle_area(heights: list[int]) -> int:\n    \"\"\"\n    Inputs an array of integers representing the heights of bars,\n    and returns the area of the largest rectangle that can be formed\n\n    >>> largest_rectangle_area([2, 1, 5, 6, 2, 3])\n    10\n\n    >>> largest_rectangle_area([2, 4])\n    4\n\n    >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6])\n    12\n\n    >>> largest_rectangle_area([1])\n    1\n    \"\"\"\n    stack: list[int] = []\n    max_area = 0\n    heights = [*heights, 0]  # make a new list by appending the sentinel 0\n    n = len(heights)\n\n    for i in range(n):\n        # make sure the stack remains in increasing order\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]  # height of the bar\n            # if stack is empty, it means entire width can be taken from index 0 to i-1\n            w = i if not stack else i - stack[-1] - 1  # calculate width\n            max_area = max(max_area, h * w)\n\n        stack.append(i)\n\n    return max_area\n2: def fibonacci_generator() -> Generator[int]:\n    \"\"\"\n    A generator that produces numbers in the Fibonacci sequence\n\n    >>> generator = fibonacci_generator()\n    >>> next(generator)\n    1\n    >>> next(generator)\n    2\n    >>> next(generator)\n    3\n    >>> next(generator)\n    5\n    >>> next(generator)\n    8\n    \"\"\"\n    a, b = 0, 1\n    while True:\n        a, b = b, a + b\n        yield b", "output": "0"}
{"input": "summarize code:\ndef solution(n: int = 600851475143) -> int:\n    \"\"\"\n    Returns the largest prime factor of a given number n.\n\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    prime = 1\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        prime = n\n    return int(prime)", "output": "Returns the largest prime factor of a given number n."}
{"input": "summarize code:\ndef largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]", "output": "Function updates the largest_square_area[0], if recursive call found square with maximum area."}
{"input": "summarize code:\ndef solution(first_x_coord: float = 1.4, first_y_coord: float = -9.6) -> int:\n    \"\"\"\n    Return the number of times that the beam hits the interior wall of the\n    cell before exiting.\n    >>> solution(0.00001,-10)\n    1\n    >>> solution(5, 0)\n    287\n    \"\"\"\n    num_reflections: int = 0\n    point_x: float = first_x_coord\n    point_y: float = first_y_coord\n    gradient: float = (10.1 - point_y) / (0.0 - point_x)\n\n    while not (-0.01 <= point_x <= 0.01 and point_y > 0):\n        point_x, point_y, gradient = next_point(point_x, point_y, gradient)\n        num_reflections += 1\n\n    return num_reflections", "output": "Return the number of times that the beam hits the interior wall of the cell before exiting. >>> solution(0.00001,-10) 1 >>> solution(5, 0) 287"}
{"input": "summarize code:\ndef fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]", "output": "Calculates the first n (0-indexed) Fibonacci numbers using memoization >>> fib_memoization(0) [0] >>> fib_memoization(1) [0, 1] >>> fib_memoization(5) [0, 1, 1, 2, 3, 5] >>> fib_memoization(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> fib_iterative(-1) Traceback (most recent call last): ... ValueError: n is negative"}
{"input": "summarize code:\ndef orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    \"\"\"\n    Calculates the work required to move an object from one orbit to another in a\n    gravitational field based on the change in total mechanical energy.\n\n    The formula used is:\n        W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\n    where:\n        W = work done (Joules)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the central body (kg)\n        m = mass of the orbiting object (kg)\n        r_initial = initial orbit radius (m)\n        r_final = final orbit radius (m)\n\n    Args:\n        mass_central (float): Mass of the central body (kg)\n        mass_object (float): Mass of the object being moved (kg)\n        r_initial (float): Initial orbital radius (m)\n        r_final (float): Final orbital radius (m)\n\n    Returns:\n        str: Work done in Joules as a string in scientific notation (3 decimals)\n\n    Examples:\n        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n        '2.811e+09'\n        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n        '-1.405e+09'\n        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n        '1.514e+11'\n    \"\"\"\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\"", "output": "Calculates the work required to move an object from one orbit to another in a gravitational field based on the change in total mechanical energy."}
{"input": "summarize code:\ndef is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq", "output": "Check if number is a perfect square."}
{"input": "search code:\nImplementation of breadth first search using collection.queue.\nChoices:\n0: def activate(locale, path=None):\n    \"\"\"Activate internationalisation.\n\n    Set `locale` as current locale. Search for locale in directory `path`.\n\n    Args:\n        locale (str): Language name, e.g. `en_GB`.\n        path (str): Path to search for locales.\n\n    Returns:\n        dict: Translations.\n\n    Raises:\n        Exception: If humanize cannot find the locale folder.\n    \"\"\"\n    if path is None:\n        path = _get_default_locale_path()\n\n    if path is None:\n        raise Exception(\n            \"Humanize cannot determinate the default location of the 'locale' folder. \"\n            \"You need to pass the path explicitly.\"\n        )\n    if locale not in _TRANSLATIONS:\n        translation = gettext_module.translation(\"humanize\", path, [locale])\n        _TRANSLATIONS[locale] = translation\n    _CURRENT.locale = locale\n    return _TRANSLATIONS[locale]\n1: def not_32(i: int) -> int:\n    \"\"\"\n    Perform bitwise NOT on given int.\n\n    Arguments:\n        i {[int]} -- [given int]\n\n    Raises:\n        ValueError -- [input is negative]\n\n    Returns:\n        Result of bitwise NOT on i\n\n    >>> not_32(34)\n    4294967261\n    >>> not_32(1234)\n    4294966061\n    >>> not_32(4294966061)\n    1234\n    >>> not_32(0)\n    4294967295\n    >>> not_32(1)\n    4294967294\n    >>> not_32(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be non-negative\n    \"\"\"\n    if i < 0:\n        raise ValueError(\"Input must be non-negative\")\n\n    i_str = format(i, \"032b\")\n    new_str = \"\"\n    for c in i_str:\n        new_str += \"1\" if c == \"0\" else \"0\"\n    return int(new_str, 2)\n2: def breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:\n    \"\"\"\n    Implementation of breadth first search using collection.queue.\n\n    >>> ''.join(breadth_first_search_with_deque(G, 'A'))\n    'ABCDEF'\n    \"\"\"\n    visited = {start}\n    result = [start]\n    queue = deque([start])\n    while queue:\n        v = queue.popleft()\n        for child in graph[v]:\n            if child not in visited:\n                visited.add(child)\n                result.append(child)\n                queue.append(child)\n    return result", "output": "2"}
{"input": "search code:\nCalculates the first n (0-indexed) Fibonacci numbers using memoization >>> fib_memoization(0) [0] >>> fib_memoization(1) [0, 1] >>> fib_memoization(5) [0, 1, 1, 2, 3, 5] >>> fib_memoization(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> fib_iterative(-1) Traceback (most recent call last): ... ValueError: n is negative\nChoices:\n0: def fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]\n1: def combination_lists(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    Generates all possible combinations of k numbers out of 1 ... n using itertools.\n\n    >>> combination_lists(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    return [list(x) for x in combinations(range(1, n + 1), k)]\n2: def strip_iter(iterable, strip_value=None):\n    \"\"\"Strips values from the beginning and end of an iterable. Stripped items\n    will match the value of the argument strip_value. Functionality is\n    analogous to that of the method str.strip. Returns a generator.\n\n    >>> list(strip_iter(['Fu', 'Foo', 'Bar', 'Bam', 'Fu'], 'Fu'))\n    ['Foo', 'Bar', 'Bam']\n\n    \"\"\"\n    return rstrip_iter(lstrip_iter(iterable, strip_value), strip_value)", "output": "0"}
{"input": "search code:\nPure implementation of binary search algorithm in Python using recursion\nChoices:\n0: def binary_tree_left_side_view(root: TreeNode) -> list[int]:\n    r\"\"\"\n    Function returns the left side view of binary tree.\n\n    3  ->    3\n            / \\\n    9  ->  9   20\n              /  \\\n    15 ->    15   7\n\n    >>> binary_tree_left_side_view(make_tree())\n    [3, 9, 15]\n    >>> binary_tree_left_side_view(None)\n    []\n    \"\"\"\n\n    def depth_first_search(\n        root: TreeNode | None, depth: int, left_view: list[int]\n    ) -> None:\n        \"\"\"\n        A depth first search preorder traversal to append the values\n        at left side of tree.\n        \"\"\"\n        if not root:\n            return\n\n        if depth == len(left_view):\n            left_view.append(root.val)\n\n        depth_first_search(root.left, depth + 1, left_view)\n        depth_first_search(root.right, depth + 1, left_view)\n\n    left_view: list = []\n    if not root:\n        return left_view\n\n    depth_first_search(root, 0, left_view)\n    return left_view\n1: def fizz_buzz(number: int, iterations: int) -> str:\n    \"\"\"\n    | Plays FizzBuzz.\n    | Prints Fizz if number is a multiple of ``3``.\n    | Prints Buzz if its a multiple of ``5``.\n    | Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``.\n    | Else Prints The Number Itself.\n\n    >>> fizz_buzz(1,7)\n    '1 2 Fizz 4 Buzz Fizz 7 '\n    >>> fizz_buzz(1,0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(-5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(10,-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(1.5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(1,5.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: iterations must be defined as integers\n    \"\"\"\n    if not isinstance(iterations, int):\n        raise ValueError(\"iterations must be defined as integers\")\n    if not isinstance(number, int) or not number >= 1:\n        raise ValueError(\n            \"\"\"starting number must be\n                         and integer and be more than 0\"\"\"\n        )\n    if not iterations >= 1:\n        raise ValueError(\"Iterations must be done more than 0 times to play FizzBuzz\")\n\n    out = \"\"\n    while number <= iterations:\n        if number % 3 == 0:\n            out += \"Fizz\"\n        if number % 5 == 0:\n            out += \"Buzz\"\n        if 0 not in (number % 3, number % 5):\n            out += str(number)\n\n        # print(out)\n        number += 1\n        out += \" \"\n    return out\n2: def binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    \"\"\"Pure implementation of binary search algorithm in Python using recursion\n\n    Be careful: the collection must be ascending sorted otherwise, the result will be\n    unpredictable.\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :param left: starting index for the search\n    :param right: ending index for the search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n    -1\n    \"\"\"\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)", "output": "2"}
{"input": "search code:\nDepth-first iterator over scalars in a tensor.\nChoices:\n0: def perfect(number: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect number.\n\n    A perfect number is a positive integer that is equal to the sum of its proper\n    divisors (excluding itself).\n\n    Args:\n        number: The number to be checked.\n\n    Returns:\n        True if the number is a perfect number otherwise, False.\n    Start from 1 because dividing by 0 will raise ZeroDivisionError.\n    A number at most can be divisible by the half of the number except the number\n    itself. For example, 6 is at most can be divisible by 3 except by 6 itself.\n    Examples:\n    >>> perfect(27)\n    False\n    >>> perfect(28)\n    True\n    >>> perfect(29)\n    False\n    >>> perfect(6)\n    True\n    >>> perfect(12)\n    False\n    >>> perfect(496)\n    True\n    >>> perfect(8128)\n    True\n    >>> perfect(0)\n    False\n    >>> perfect(-1)\n    False\n    >>> perfect(33550336)  # Large perfect number\n    True\n    >>> perfect(33550337)  # Just above a large perfect number\n    False\n    >>> perfect(1)  # Edge case: 1 is not a perfect number\n    False\n    >>> perfect(\"123\")  # String representation of a number\n    Traceback (most recent call last):\n    ...\n    ValueError: number must be an integer\n    >>> perfect(12.34)\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    >>> perfect(\"Hello\")\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        raise ValueError(\"number must be an integer\")\n    if number <= 0:\n        return False\n    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number\n1: def breadth_first_search(graph: dict, start: str) -> list[str]:\n    \"\"\"\n    Implementation of breadth first search using queue.Queue.\n\n    >>> ''.join(breadth_first_search(G, 'A'))\n    'ABCDEF'\n    \"\"\"\n    explored = {start}\n    result = [start]\n    queue: Queue = Queue()\n    queue.put(start)\n    while not queue.empty():\n        v = queue.get()\n        for w in graph[v]:\n            if w not in explored:\n                explored.add(w)\n                result.append(w)\n                queue.put(w)\n    return result\n2: def _flatten_tensor(tensor):\n    \"Depth-first iterator over scalars in a tensor.\"\n    iterator = iter(tensor)\n    while True:\n        try:\n            value = next(iterator)\n        except StopIteration:\n            return iterator\n        iterator = chain((value,), iterator)\n        if _is_scalar(value):\n            return iterator\n        iterator = chain.from_iterable(iterator)", "output": "2"}
{"input": "summarize code:\ndef simulate(\n    highway: list, number_of_update: int, probability: float, max_speed: int\n) -> list:\n    \"\"\"\n    The main function, it will simulate the evolution of the highway\n    >>> simulate([[-1, 2, -1, -1, -1, 3]], 2, 0.0, 3)\n    [[-1, 2, -1, -1, -1, 3], [-1, -1, -1, 2, -1, 0], [1, -1, -1, 0, -1, -1]]\n    >>> simulate([[-1, 2, -1, 3]], 4, 0.0, 3)\n    [[-1, 2, -1, 3], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0]]\n    \"\"\"\n\n    number_of_cells = len(highway[0])\n\n    for i in range(number_of_update):\n        next_speeds_calculated = update(highway[i], probability, max_speed)\n        real_next_speeds = [-1] * number_of_cells\n\n        for car_index in range(number_of_cells):\n            speed = next_speeds_calculated[car_index]\n            if speed != -1:\n                # Change the position based on the speed (with % to create the loop)\n                index = (car_index + speed) % number_of_cells\n                # Commit the change of position\n                real_next_speeds[index] = speed\n        highway.append(real_next_speeds)\n\n    return highway", "output": "The main function, it will simulate the evolution of the highway >>> simulate([[-1, 2, -1, -1, -1, 3]], 2, 0.0, 3) [[-1, 2, -1, -1, -1, 3], [-1, -1, -1, 2, -1, 0], [1, -1, -1, 0, -1, -1]] >>> simulate([[-1, 2, -1, 3]], 4, 0.0, 3) [[-1, 2, -1, 3], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0]]"}
{"input": "search code:\nReturns total time of the motion\nChoices:\n0: def total_time(init_velocity: float, angle: float) -> float:\n    r\"\"\"\n    Returns total time of the motion\n\n    Formula:\n        .. math::\n            \\frac{2 v_0 \\cdot \\sin (\\alpha)}{g}\n\n            v_0 - \\text{initial velocity}\n\n            \\alpha - \\text{angle}\n\n    >>> total_time(30, 45)\n    4.33\n    >>> total_time(100, 78)\n    19.95\n    >>> total_time(-10, 40)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> total_time(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Should be an integer or float.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = deg_to_rad(angle)\n    return round(2 * init_velocity * sin(radians) / g, 2)\n1: def odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list\n2: def format_invocation(name='', args=(), kwargs=None, **kw):\n    \"\"\"Given a name, positional arguments, and keyword arguments, format\n    a basic Python-style function call.\n\n    >>> print(format_invocation('func', args=(1, 2), kwargs={'c': 3}))\n    func(1, 2, c=3)\n    >>> print(format_invocation('a_func', args=(1,)))\n    a_func(1)\n    >>> print(format_invocation('kw_func', kwargs=[('a', 1), ('b', 2)]))\n    kw_func(a=1, b=2)\n\n    \"\"\"\n    _repr = kw.pop('repr', repr)\n    if kw:\n        raise TypeError('unexpected keyword args: %r' % ', '.join(kw.keys()))\n    kwargs = kwargs or {}\n    a_text = ', '.join([_repr(a) for a in args])\n    if isinstance(kwargs, dict):\n        kwarg_items = [(k, kwargs[k]) for k in sorted(kwargs)]\n    else:\n        kwarg_items = kwargs\n    kw_text = ', '.join([f'{k}={_repr(v)}' for k, v in kwarg_items])\n\n    all_args_text = a_text\n    if all_args_text and kw_text:\n        all_args_text += ', '\n    all_args_text += kw_text\n\n    return f'{name}({all_args_text})'", "output": "0"}
{"input": "summarize code:\ndef exactly_n(iterable, n, predicate=bool):\n    \"\"\"Return ``True`` if exactly ``n`` items in the iterable are ``True``\n    according to the *predicate* function.\n\n        >>> exactly_n([True, True, False], 2)\n        True\n        >>> exactly_n([True, True, False], 1)\n        False\n        >>> exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x < 3)\n        True\n\n    The iterable will be advanced until ``n + 1`` truthy items are encountered,\n    so avoid calling it on infinite iterables.\n\n    \"\"\"\n    iterator = filter(predicate, iterable)\n    if n <= 0:\n        if n < 0:\n            return False\n        for _ in iterator:\n            return False\n        return True\n\n    iterator = islice(iterator, n - 1, None)\n    for _ in iterator:\n        for _ in iterator:\n            return False\n        return True\n    return False", "output": "Return ``True`` if exactly ``n`` items in the iterable are ``True`` according to the *predicate* function."}
{"input": "search code:\nExamples: >>> is_carmichael_number(4) False >>> is_carmichael_number(561) True >>> is_carmichael_number(562) False >>> is_carmichael_number(900) False >>> is_carmichael_number(1105) True >>> is_carmichael_number(8911) True >>> is_carmichael_number(5.1) Traceback (most recent call last): ... ValueError: Number 5.1 must instead be a positive integer\nChoices:\n0: def is_carmichael_number(n: int) -> bool:\n    \"\"\"\n    Examples:\n    >>> is_carmichael_number(4)\n    False\n    >>> is_carmichael_number(561)\n    True\n    >>> is_carmichael_number(562)\n    False\n    >>> is_carmichael_number(900)\n    False\n    >>> is_carmichael_number(1105)\n    True\n    >>> is_carmichael_number(8911)\n    True\n    >>> is_carmichael_number(5.1)\n    Traceback (most recent call last):\n         ...\n    ValueError: Number 5.1 must instead be a positive integer\n\n    >>> is_carmichael_number(-7)\n    Traceback (most recent call last):\n         ...\n    ValueError: Number -7 must instead be a positive integer\n\n    >>> is_carmichael_number(0)\n    Traceback (most recent call last):\n         ...\n    ValueError: Number 0 must instead be a positive integer\n    \"\"\"\n\n    if n <= 0 or not isinstance(n, int):\n        msg = f\"Number {n} must instead be a positive integer\"\n        raise ValueError(msg)\n\n    return all(\n        power(b, n - 1, n) == 1\n        for b in range(2, n)\n        if greatest_common_divisor(b, n) == 1\n    )\n1: def naturaldate(value) -> str:\n    \"\"\"Like `naturalday`, but append a year for dates more than ~five months away.\"\"\"\n    try:\n        value = dt.date(value.year, value.month, value.day)\n    except AttributeError:\n        # Passed value wasn't date-ish\n        return value\n    except (OverflowError, ValueError):\n        # Date arguments out of range\n        return value\n    delta = _abs_timedelta(value - dt.date.today())\n    if delta.days >= 5 * 365 / 12:\n        return naturalday(value, \"%b %d %Y\")\n    return naturalday(value)\n2: def solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i**2\n        sum_of_ints += i\n    return sum_of_ints**2 - sum_of_squares", "output": "0"}
{"input": "search code:\nCalculate the power of a base raised to an exponent.\nChoices:\n0: def capture_area(capture_radius: float) -> float:\n    \"\"\"\n    Input Param:\n    ------------\n    capture_radius: The radius of orbital capture and impact for a central body of\n    mass M and a projectile moving towards it with velocity v\n        SI units: meters | m\n    Returns:\n    --------\n    >>> capture_area(17209590691)\n    9.304455331329126e+20\n    >>> capture_area(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Cannot have a capture radius less than 0\n\n    Returned SI units:\n    ------------------\n    meters*meters | m**2\n    \"\"\"\n\n    if capture_radius < 0:\n        raise ValueError(\"Cannot have a capture radius less than 0\")\n    sigma = pi * pow(capture_radius, 2)\n    return round(sigma, 0)\n1: def power(base: int, exponent: int) -> float:\n    \"\"\"\n    Calculate the power of a base raised to an exponent.\n\n    >>> power(3, 4)\n    81\n    >>> power(2, 0)\n    1\n    >>> all(power(base, exponent) == pow(base, exponent)\n    ...     for base in range(-10, 10) for exponent in range(10))\n    True\n    >>> power('a', 1)\n    'a'\n    >>> power('a', 2)\n    Traceback (most recent call last):\n        ...\n    TypeError: can't multiply sequence by non-int of type 'str'\n    >>> power('a', 'b')\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'str' and 'int'\n    >>> power(2, -1)\n    Traceback (most recent call last):\n        ...\n    RecursionError: maximum recursion depth exceeded\n    >>> power(0, 0)\n    1\n    >>> power(0, 1)\n    0\n    >>> power(5,6)\n    15625\n    >>> power(23, 12)\n    21914624432020321\n    \"\"\"\n    return base * power(base, (exponent - 1)) if exponent else 1\n2: def flatten(root: TreeNode | None) -> None:\n    \"\"\"\n    Flatten a binary tree into a linked list in-place, where the linked list is\n    represented using the right pointers of the tree nodes.\n\n    Args:\n        root (TreeNode): The root of the binary tree to be flattened.\n\n    Examples:\n        >>> root = TreeNode(1)\n        >>> root.left = TreeNode(2)\n        >>> root.right = TreeNode(5)\n        >>> root.left.left = TreeNode(3)\n        >>> root.left.right = TreeNode(4)\n        >>> root.right.right = TreeNode(6)\n        >>> flatten(root)\n        >>> root.data\n        1\n        >>> root.right.right is None\n        False\n        >>> root.right.right = TreeNode(3)\n        >>> root.right.right.right is None\n        True\n    \"\"\"\n    if not root:\n        return\n\n    # Flatten the left subtree\n    flatten(root.left)\n\n    # Save the right subtree\n    right_subtree = root.right\n\n    # Make the left subtree the new right subtree\n    root.right = root.left\n    root.left = None\n\n    # Find the end of the new right subtree\n    current = root\n    while current.right:\n        current = current.right\n\n    # Append the original right subtree to the end\n    current.right = right_subtree\n\n    # Flatten the updated right subtree\n    flatten(right_subtree)", "output": "1"}
{"input": "summarize code:\ndef exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:\n    \"\"\"\n         Implements the ELU activation function.\n         Parameters:\n             vector: the array containing input of elu activation\n             alpha: hyper-parameter\n         return:\n         elu (np.array): The input numpy array after applying elu.\n\n         Mathematically, f(x) = x, x>0 else (alpha * (e^x -1)), x<=0, alpha >=0\n\n    Examples:\n    >>> exponential_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)\n    array([ 2.3       ,  0.6       , -0.25939942, -0.29328877])\n\n    >>> exponential_linear_unit(vector=np.array([-9.2,-0.3,0.45,-4.56]), alpha=0.067)\n    array([-0.06699323, -0.01736518,  0.45      , -0.06629904])\n\n\n    \"\"\"\n    return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))", "output": "Implements the ELU activation function. Parameters: vector: the array containing input of elu activation alpha: hyper-parameter return: elu (np.array): The input numpy array after applying elu."}
{"input": "search code:\nFind the winner of the Josephus problem for num_people and a step_size.\nChoices:\n0: def slow_reversible_numbers(\n    remaining_length: int, remainder: int, digits: list[int], length: int\n) -> int:\n    \"\"\"\n    Count the number of reversible numbers of given length.\n    Iterate over possible digits considering parity of current sum remainder.\n    >>> slow_reversible_numbers(1, 0, [0], 1)\n    0\n    >>> slow_reversible_numbers(2, 0, [0] * 2, 2)\n    20\n    >>> slow_reversible_numbers(3, 0, [0] * 3, 3)\n    100\n    \"\"\"\n    if remaining_length == 0:\n        if digits[0] == 0 or digits[-1] == 0:\n            return 0\n\n        for i in range(length // 2 - 1, -1, -1):\n            remainder += digits[i] + digits[length - i - 1]\n\n            if remainder % 2 == 0:\n                return 0\n\n            remainder //= 10\n\n        return 1\n\n    if remaining_length == 1:\n        if remainder % 2 == 0:\n            return 0\n\n        result = 0\n        for digit in range(10):\n            digits[length // 2] = digit\n            result += slow_reversible_numbers(\n                0, (remainder + 2 * digit) // 10, digits, length\n            )\n        return result\n\n    result = 0\n    for digit1 in range(10):\n        digits[(length + remaining_length) // 2 - 1] = digit1\n\n        if (remainder + digit1) % 2 == 0:\n            other_parity_digits = ODD_DIGITS\n        else:\n            other_parity_digits = EVEN_DIGITS\n\n        for digit2 in other_parity_digits:\n            digits[(length - remaining_length) // 2] = digit2\n            result += slow_reversible_numbers(\n                remaining_length - 2,\n                (remainder + digit1 + digit2) // 10,\n                digits,\n                length,\n            )\n    return result\n1: def find_winner(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Find the winner of the Josephus problem for num_people and a step_size.\n\n    Args:\n        num_people (int): Number of people.\n        step_size (int): Step size for elimination.\n\n    Returns:\n        int: The position of the last person remaining (1-based index).\n\n    Examples:\n        >>> find_winner(7, 3)\n        4\n        >>> find_winner(10, 2)\n        5\n    \"\"\"\n    return josephus_recursive(num_people, step_size) + 1\n2: def clear_bit(number: int, position: int) -> int:\n    \"\"\"\n    Set the bit at position to 0.\n\n    Details: perform bitwise and for given number and X.\n    Where X is a number with all the bits - ones and bit on given\n    position - zero.\n\n    >>> clear_bit(0b10010, 1) # 0b10000\n    16\n    >>> clear_bit(0b0, 5) # 0b0\n    0\n    \"\"\"\n    return number & ~(1 << position)", "output": "1"}
{"input": "summarize code:\ndef main() -> None:\n    \"\"\"After each command, program prints treap\"\"\"\n    root = None\n    print(\n        \"enter numbers to create a tree, + value to add value into treap, \"\n        \"- value to erase all nodes with value. 'q' to quit. \"\n    )\n\n    args = input()\n    while args != \"q\":\n        root = interact_treap(root, args)\n        print(root)\n        args = input()\n\n    print(\"good by!\")", "output": "After each command, program prints treap"}
{"input": "search code:\nEvaluate each item from *iterable* using *pred*. If the result is equivalent to ``True``, transform the item with *func* and yield it. Otherwise, transform the item with *func_else* and yield it.\nChoices:\n0: def bell_numbers(max_set_length: int) -> list[int]:\n    \"\"\"\n    Calculate Bell numbers for the sets of lengths from 0 to max_set_length.\n    In other words, calculate first (max_set_length + 1) Bell numbers.\n\n    Args:\n        max_set_length (int): The maximum length of the sets for which\n        Bell numbers are calculated.\n\n    Returns:\n        list: A list of Bell numbers for sets of lengths from 0 to max_set_length.\n\n    Examples:\n    >>> bell_numbers(-2)\n    Traceback (most recent call last):\n        ...\n    ValueError: max_set_length must be non-negative\n    >>> bell_numbers(0)\n    [1]\n    >>> bell_numbers(1)\n    [1, 1]\n    >>> bell_numbers(5)\n    [1, 1, 2, 5, 15, 52]\n    \"\"\"\n    if max_set_length < 0:\n        raise ValueError(\"max_set_length must be non-negative\")\n\n    bell = [0] * (max_set_length + 1)\n    bell[0] = 1\n\n    for i in range(1, max_set_length + 1):\n        for j in range(i):\n            bell[i] += _binomial_coefficient(i - 1, j) * bell[j]\n\n    return bell\n1: def map_if(iterable, pred, func, func_else=None):\n    \"\"\"Evaluate each item from *iterable* using *pred*. If the result is\n    equivalent to ``True``, transform the item with *func* and yield it.\n    Otherwise, transform the item with *func_else* and yield it.\n\n    *pred*, *func*, and *func_else* should each be functions that accept\n    one argument. By default, *func_else* is the identity function.\n\n    >>> from math import sqrt\n    >>> iterable = list(range(-5, 5))\n    >>> iterable\n    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n    >>> list(map_if(iterable, lambda x: x > 3, lambda x: 'toobig'))\n    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']\n    >>> list(map_if(iterable, lambda x: x >= 0,\n    ... lambda x: f'{sqrt(x):.2f}', lambda x: None))\n    [None, None, None, None, None, '0.00', '1.00', '1.41', '1.73', '2.00']\n    \"\"\"\n\n    if func_else is None:\n        for item in iterable:\n            yield func(item) if pred(item) else item\n\n    else:\n        for item in iterable:\n            yield func(item) if pred(item) else func_else(item)\n2: def indian_phone_validator(phone: str) -> bool:\n    \"\"\"\n    Determine whether the string is a valid phone number or not\n    :param phone:\n    :return: Boolean\n    >>> indian_phone_validator(\"+91123456789\")\n    False\n    >>> indian_phone_validator(\"+919876543210\")\n    True\n    >>> indian_phone_validator(\"01234567896\")\n    False\n    >>> indian_phone_validator(\"919876543218\")\n    True\n    >>> indian_phone_validator(\"+91-1234567899\")\n    False\n    >>> indian_phone_validator(\"+91-9876543218\")\n    True\n    \"\"\"\n    pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")\n    if match := re.search(pat, phone):\n        return match.string == phone\n    return False", "output": "1"}
{"input": "summarize code:\ndef is_harshad_number_in_base(num: int, base: int) -> bool:\n    \"\"\"\n    Determines whether n in base 'base' is a harshad number.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> is_harshad_number_in_base(18, 10)\n    True\n    >>> is_harshad_number_in_base(21, 10)\n    True\n    >>> is_harshad_number_in_base(-21, 5)\n    False\n    >>> # bases below 2 and beyond 36 will error\n    >>> is_harshad_number_in_base(45, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> is_harshad_number_in_base(45, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    if num < 0:\n        return False\n\n    n = int_to_base(num, base)\n    d = sum_of_digits(num, base)\n    return int(n, base) % int(d, base) == 0", "output": "Determines whether n in base 'base' is a harshad number. Where 'base' ranges from 2 to 36."}
{"input": "summarize code:\ndef solve(board: list[list[int]], row: int) -> bool:\n    \"\"\"\n    This function creates a state space tree and calls the safe function until it\n    receives a False Boolean and terminates that branch and backtracks to the next\n    possible solution branch.\n    \"\"\"\n    if row >= len(board):\n        \"\"\"\n        If the row number exceeds N, we have a board with a successful combination\n        and that combination is appended to the solution list and the board is printed.\n        \"\"\"\n        solution.append(board)\n        printboard(board)\n        print()\n        return True\n    for i in range(len(board)):\n        \"\"\"\n        For every row, it iterates through each column to check if it is feasible to\n        place a queen there.\n        If all the combinations for that particular branch are successful, the board is\n        reinitialized for the next possible combination.\n        \"\"\"\n        if is_safe(board, row, i):\n            board[row][i] = 1\n            solve(board, row + 1)\n            board[row][i] = 0\n    return False", "output": "This function creates a state space tree and calls the safe function until it receives a False Boolean and terminates that branch and backtracks to the next possible solution branch."}
{"input": "search code:\nThis function creates an ordered list of n length as requested, and afterwards returns the last value of the list. It must be given a positive integer.\nChoices:\n0: def is_magic_gon(numbers: list[int]) -> bool:\n    \"\"\"\n    Check if the solution set is a magic n-gon ring\n    Check that the first number is the smallest number on the outer ring\n    Take a list, and check if the sum of each 3 numbers chunk is equal to the same total\n\n    >>> is_magic_gon([4, 2, 3, 5, 3, 1, 6, 1, 2])\n    True\n    >>> is_magic_gon([4, 3, 2, 6, 2, 1, 5, 1, 3])\n    True\n    >>> is_magic_gon([2, 3, 5, 4, 5, 1, 6, 1, 3])\n    True\n    >>> is_magic_gon([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    False\n    >>> is_magic_gon([1])\n    Traceback (most recent call last):\n    ValueError: a gon ring should have a length that is a multiple of 3\n    \"\"\"\n    if len(numbers) % 3 != 0:\n        raise ValueError(\"a gon ring should have a length that is a multiple of 3\")\n\n    if min(numbers[::3]) != numbers[0]:\n        return False\n\n    total = sum(numbers[:3])\n\n    return all(sum(numbers[i : i + 3]) == total for i in range(3, len(numbers), 3))\n1: def digital_differential_analyzer_line(\n    p1: tuple[int, int], p2: tuple[int, int]\n) -> list[tuple[int, int]]:\n    \"\"\"\n    Draws a line between two points using the DDA algorithm.\n\n    Args:\n    - p1: Coordinates of the starting point.\n    - p2: Coordinates of the ending point.\n    Returns:\n    - List of coordinate points that form the line.\n\n    >>> digital_differential_analyzer_line((1, 1), (4, 4))\n    [(2, 2), (3, 3), (4, 4)]\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    dx = x2 - x1\n    dy = y2 - y1\n    steps = max(abs(dx), abs(dy))\n    x_increment = dx / float(steps)\n    y_increment = dy / float(steps)\n    coordinates = []\n    x: float = x1\n    y: float = y1\n    for _ in range(steps):\n        x += x_increment\n        y += y_increment\n        coordinates.append((round(x), round(y)))\n    return coordinates\n2: def hamming(n_element: int) -> list:\n    \"\"\"\n    This function creates an ordered list of n length as requested, and afterwards\n    returns the last value of the list. It must be given a positive integer.\n\n    :param n_element: The number of elements on the list\n    :return: The nth element of the list\n\n    >>> hamming(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: n_element should be a positive number\n    >>> hamming(5)\n    [1, 2, 3, 4, 5]\n    >>> hamming(10)\n    [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]\n    >>> hamming(15)\n    [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]\n    \"\"\"\n    n_element = int(n_element)\n    if n_element < 1:\n        my_error = ValueError(\"n_element should be a positive number\")\n        raise my_error\n\n    hamming_list = [1]\n    i, j, k = (0, 0, 0)\n    index = 1\n    while index < n_element:\n        while hamming_list[i] * 2 <= hamming_list[-1]:\n            i += 1\n        while hamming_list[j] * 3 <= hamming_list[-1]:\n            j += 1\n        while hamming_list[k] * 5 <= hamming_list[-1]:\n            k += 1\n        hamming_list.append(\n            min(hamming_list[i] * 2, hamming_list[j] * 3, hamming_list[k] * 5)\n        )\n        index += 1\n    return hamming_list", "output": "2"}
{"input": "summarize code:\ndef run_maze(\n    maze: list[list[int]],\n    i: int,\n    j: int,\n    destination_row: int,\n    destination_column: int,\n    solutions: list[list[int]],\n) -> bool:\n    \"\"\"\n    This method is recursive starting from (i, j) and going in one of four directions:\n    up, down, left, right.\n    If a path is found to destination it returns True otherwise it returns False.\n    Parameters\n        maze: A two dimensional matrix of zeros and ones.\n        i, j : coordinates of matrix\n        solutions: A two dimensional matrix of solutions.\n    Returns:\n        Boolean if path is found True, Otherwise False.\n    \"\"\"\n    size = len(maze)\n    # Final check point.\n    if i == destination_row and j == destination_column and maze[i][j] == 0:\n        solutions[i][j] = 0\n        return True\n\n    lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds\n    upper_flag = (i < size) and (j < size)  # Check upper bounds\n\n    if lower_flag and upper_flag:\n        # check for already visited and block points.\n        block_flag = (solutions[i][j]) and (not maze[i][j])\n        if block_flag:\n            # check visited\n            solutions[i][j] = 0\n\n            # check for directions\n            if (\n                run_maze(maze, i + 1, j, destination_row, destination_column, solutions)\n                or run_maze(\n                    maze, i, j + 1, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i - 1, j, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i, j - 1, destination_row, destination_column, solutions\n                )\n            ):\n                return True\n\n            solutions[i][j] = 1\n            return False\n    return False", "output": "This method is recursive starting from (i, j) and going in one of four directions: up, down, left, right. If a path is found to destination it returns True otherwise it returns False. Parameters maze: A two dimensional matrix of zeros and ones. i, j : coordinates of matrix solutions: A two dimensional matrix of solutions. Returns: Boolean if path is found True, Otherwise False."}
{"input": "summarize code:\ndef example(wav_file_path: str = \"./path-to-file/sample.wav\") -> np.ndarray:\n    \"\"\"\n    Example function to calculate Mel Frequency Cepstral Coefficients\n    (MFCCs) from an audio file.\n\n    Args:\n        wav_file_path: The path to the WAV audio file.\n\n    Returns:\n        np.ndarray: The computed MFCCs for the audio.\n    \"\"\"\n    from scipy.io import wavfile\n\n    # Load the audio from the WAV file\n    sample_rate, audio = wavfile.read(wav_file_path)\n\n    # Calculate MFCCs\n    return mfcc(audio, sample_rate)", "output": "Example function to calculate Mel Frequency Cepstral Coefficients (MFCCs) from an audio file."}
{"input": "summarize code:\ndef xor_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    calculate xor of the input values\n\n    >>> xor_gate(0, 0)\n    0\n    >>> xor_gate(0, 1)\n    1\n    >>> xor_gate(1, 0)\n    1\n    >>> xor_gate(1, 1)\n    0\n    \"\"\"\n    return (input_1, input_2).count(0) % 2", "output": "calculate xor of the input values"}
{"input": "search code:\nCeq = 1/ (1/C1 + 1/C2 + ... + 1/Cn) >>> capacitor_series([5.71389, 12, 3]) 1.6901062252507735 >>> capacitor_series([5.71389, 12, -3]) Traceback (most recent call last): ... ValueError: Capacitor at index 2 has a negative or zero value! >>> capacitor_series([5.71389, 12, 0.000]) Traceback (most recent call last): ... ValueError: Capacitor at index 2 has a negative or zero value!\nChoices:\n0: def print_binary_search_tree(root, key, i, j, parent, is_left):\n    \"\"\"\n    Recursive function to print a BST from a root table.\n\n    >>> key = [3, 8, 9, 10, 17, 21]\n    >>> root = [[0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 3], [0, 0, 2, 3, 3, 3], \\\n                [0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 5]]\n    >>> print_binary_search_tree(root, key, 0, 5, -1, False)\n    8 is the root of the binary search tree.\n    3 is the left child of key 8.\n    10 is the right child of key 8.\n    9 is the left child of key 10.\n    21 is the right child of key 10.\n    17 is the left child of key 21.\n    \"\"\"\n    if i > j or i < 0 or j > len(root) - 1:\n        return\n\n    node = root[i][j]\n    if parent == -1:  # root does not have a parent\n        print(f\"{key[node]} is the root of the binary search tree.\")\n    elif is_left:\n        print(f\"{key[node]} is the left child of key {parent}.\")\n    else:\n        print(f\"{key[node]} is the right child of key {parent}.\")\n\n    print_binary_search_tree(root, key, i, node - 1, key[node], True)\n    print_binary_search_tree(root, key, node + 1, j, key[node], False)\n1: def dijk(g, s):\n    \"\"\"\n    dijk({1: [(2, 7), (3, 9), (6, 14)],\n        2: [(1, 7), (3, 10), (4, 15)],\n        3: [(1, 9), (2, 10), (4, 11), (6, 2)],\n        4: [(2, 15), (3, 11), (5, 6)],\n        5: [(4, 6), (6, 9)],\n        6: [(1, 14), (3, 2), (5, 9)]}, 1)\n    7\n    9\n    11\n    20\n    20\n    \"\"\"\n    dist, known, path = {s: 0}, set(), {s: 0}\n    while True:\n        if len(known) == len(g) - 1:\n            break\n        mini = 100000\n        for key, value in dist:\n            if key not in known and value < mini:\n                mini = value\n                u = key\n        known.add(u)\n        for v in g[u]:\n            if v[0] not in known and dist[u] + v[1] < dist.get(v[0], 100000):\n                dist[v[0]] = dist[u] + v[1]\n                path[v[0]] = u\n    for key, value in dist.items():\n        if key != s:\n            print(value)\n2: def capacitor_series(capacitors: list[float]) -> float:\n    \"\"\"\n    Ceq = 1/ (1/C1 + 1/C2 + ... + 1/Cn)\n    >>> capacitor_series([5.71389, 12, 3])\n    1.6901062252507735\n    >>> capacitor_series([5.71389, 12, -3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitor at index 2 has a negative or zero value!\n    >>> capacitor_series([5.71389, 12, 0.000])\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitor at index 2 has a negative or zero value!\n    \"\"\"\n\n    first_sum = 0.0\n    for index, capacitor in enumerate(capacitors):\n        if capacitor <= 0:\n            msg = f\"Capacitor at index {index} has a negative or zero value!\"\n            raise ValueError(msg)\n        first_sum += 1 / capacitor\n    return 1 / first_sum", "output": "2"}
{"input": "summarize code:\ndef polynomial_from_roots(roots):\n    \"\"\"Compute a polynomial's coefficients from its roots.\n\n    >>> roots = [5, -4, 3]            # (x - 5) * (x + 4) * (x - 3)\n    >>> polynomial_from_roots(roots)  # xÂ³ - 4 xÂ² - 17 x + 60\n    [1, -4, -17, 60]\n\n    Note that polynomial coefficients are specified in descending power order.\n\n    Supports all numeric types: int, float, complex, Decimal, Fraction.\n    \"\"\"\n\n    # This recipe differs from the one in itertools docs in that it\n    # applies list() after each call to convolve().  This avoids\n    # hitting stack limits with nested generators.\n\n    poly = [1]\n    for root in roots:\n        poly = list(convolve(poly, (1, -root)))\n    return poly", "output": "Compute a polynomial's coefficients from its roots."}
{"input": "summarize code:\ndef draw_fractal_recursive(x: float, y: float, length: float, depth: float):\n    \"\"\"\n    Recursively draw the Vicsek fractal at the specified position, with the\n    specified length and depth.\n    \"\"\"\n    if depth == 0:\n        draw_cross(x, y, length)\n        return\n\n    draw_fractal_recursive(x, y, length / 3, depth - 1)\n    draw_fractal_recursive(x + length / 3, y, length / 3, depth - 1)\n    draw_fractal_recursive(x - length / 3, y, length / 3, depth - 1)\n    draw_fractal_recursive(x, y + length / 3, length / 3, depth - 1)\n    draw_fractal_recursive(x, y - length / 3, length / 3, depth - 1)", "output": "Recursively draw the Vicsek fractal at the specified position, with the specified length and depth."}
{"input": "search code:\nFind the minimum change from the given denominations and value >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745) [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5] >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987) [500, 100, 100, 100, 100, 50, 20, 10, 5, 2] >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0) [] >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98) [] >>> find_minimum_change([1, 5, 100, 500, 1000], 456) [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\nChoices:\n0: def _extract_labels(f, one_hot=False, num_classes=10):\n    \"\"\"Extract the labels into a 1D uint8 numpy array [index].\n\n    Args:\n      f: A file object that can be passed into a gzip reader.\n      one_hot: Does one hot encoding for the result.\n      num_classes: Number of classes for the one hot encoding.\n\n    Returns:\n      labels: a 1D uint8 numpy array.\n\n    Raises:\n      ValueError: If the bystream doesn't start with 2049.\n    \"\"\"\n    print(\"Extracting\", f.name)\n    with gzip.GzipFile(fileobj=f) as bytestream:\n        magic = _read32(bytestream)\n        if magic != 2049:\n            msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"\n            raise ValueError(msg)\n        num_items = _read32(bytestream)\n        buf = bytestream.read(num_items)\n        labels = np.frombuffer(buf, dtype=np.uint8)\n        if one_hot:\n            return _dense_to_one_hot(labels, num_classes)\n        return labels\n1: def find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer\n2: def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:\n    \"\"\"\n    Iterate through the array to find the index of key using recursion.\n    :param list_data: the list to be searched\n    :param key: the key to be searched\n    :param left: the index of first element\n    :param right: the index of last element\n    :return: the index of key value if found, -1 otherwise.\n\n    >>> search(list(range(0, 11)), 5)\n    5\n    >>> search([1, 2, 4, 5, 3], 4)\n    2\n    >>> search([1, 2, 4, 5, 3], 6)\n    -1\n    >>> search([5], 5)\n    0\n    >>> search([], 1)\n    -1\n    \"\"\"\n    right = right or len(list_data) - 1\n    if left > right:\n        return -1\n    elif list_data[left] == key:\n        return left\n    elif list_data[right] == key:\n        return right\n    else:\n        return search(list_data, key, left + 1, right - 1)", "output": "1"}
{"input": "search code:\nSolves the maximum subarray sum problem using Kadane's algorithm. :param arr: the given array of numbers :param allow_empty_subarrays: if True, then the algorithm considers empty subarrays\nChoices:\n0: def max_subarray_sum(\n    arr: Sequence[float], allow_empty_subarrays: bool = False\n) -> float:\n    \"\"\"\n    Solves the maximum subarray sum problem using Kadane's algorithm.\n    :param arr: the given array of numbers\n    :param allow_empty_subarrays: if True, then the algorithm considers empty subarrays\n\n    >>> max_subarray_sum([2, 8, 9])\n    19\n    >>> max_subarray_sum([0, 0])\n    0\n    >>> max_subarray_sum([-1.0, 0.0, 1.0])\n    1.0\n    >>> max_subarray_sum([1, 2, 3, 4, -2])\n    10\n    >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n    >>> max_subarray_sum([2, 3, -9, 8, -2])\n    8\n    >>> max_subarray_sum([-2, -3, -1, -4, -6])\n    -1\n    >>> max_subarray_sum([-2, -3, -1, -4, -6], allow_empty_subarrays=True)\n    0\n    >>> max_subarray_sum([])\n    0\n    \"\"\"\n    if not arr:\n        return 0\n\n    max_sum = 0 if allow_empty_subarrays else float(\"-inf\")\n    curr_sum = 0.0\n    for num in arr:\n        curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n1: def solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n    A straightforward pythonic solution using list comprehension.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)\n2: def norm_squared(vector: ndarray) -> float:\n    \"\"\"\n    Return the squared second norm of vector\n    norm_squared(v) = sum(x * x for x in v)\n\n    Args:\n        vector (ndarray): input vector\n\n    Returns:\n        float: squared second norm of vector\n\n    >>> int(norm_squared([1, 2]))\n    5\n    >>> int(norm_squared(np.asarray([1, 2])))\n    5\n    >>> int(norm_squared([0, 0]))\n    0\n    \"\"\"\n    return np.dot(vector, vector)", "output": "0"}
{"input": "search code:\nReturn the lowest common ancestor between u and v\nChoices:\n0: def open_knight_tour_helper(\n    board: list[list[int]], pos: tuple[int, int], curr: int\n) -> bool:\n    \"\"\"\n    Helper function to solve knight tour problem.\n    \"\"\"\n\n    if is_complete(board):\n        return True\n\n    for position in get_valid_pos(pos, len(board)):\n        y, x = position\n\n        if board[y][x] == 0:\n            board[y][x] = curr + 1\n            if open_knight_tour_helper(board, position, curr + 1):\n                return True\n            board[y][x] = 0\n\n    return False\n1: def lowest_common_ancestor(\n    u: int, v: int, level: list[int], parent: list[list[int]]\n) -> int:\n    \"\"\"\n    Return the lowest common ancestor between u and v\n\n    >>> level = [-1, 0, 1, 1, 2, 2, 2]\n    >>> parent = [[0, 0, 1, 1, 2, 2, 3],[0, 0, 0, 0, 1, 1, 1]] + \\\n                    [[0] * 7 for _ in range(17)]\n    >>> lowest_common_ancestor(u=4, v=5, level=level, parent=parent)\n    2\n    >>> lowest_common_ancestor(u=4, v=6, level=level, parent=parent)\n    1\n    >>> lowest_common_ancestor(u=2, v=3, level=level, parent=parent)\n    1\n    >>> lowest_common_ancestor(u=6, v=6, level=level, parent=parent)\n    6\n    \"\"\"\n    # u must be deeper in the tree than v\n    if level[u] < level[v]:\n        u, v = swap(u, v)\n    # making depth of u same as depth of v\n    for i in range(18, -1, -1):\n        if level[u] - (1 << i) >= level[v]:\n            u = parent[i][u]\n    # at the same depth if u==v that mean lca is found\n    if u == v:\n        return u\n    # moving both nodes upwards till lca in found\n    for i in range(18, -1, -1):\n        if parent[i][u] not in [0, parent[i][v]]:\n            u, v = parent[i][u], parent[i][v]\n    # returning longest common ancestor of u,v\n    return parent[0][u]\n2: def unquote_to_bytes(string):\n    \"\"\"unquote_to_bytes('abc%20def') -> b'abc def'.\"\"\"\n    # Note: strings are encoded as UTF-8. This is only an issue if it contains\n    # unescaped non-ASCII characters, which URIs should not.\n    if not string:\n        # Is it a string-like object?\n        string.split\n        return b''\n    if isinstance(string, str):\n        string = string.encode('utf-8')\n    bits = string.split(b'%')\n    if len(bits) == 1:\n        return string\n    # import pdb;pdb.set_trace()\n    res = [bits[0]]\n    append = res.append\n\n    for item in bits[1:]:\n        try:\n            append(_HEX_CHAR_MAP[item[:2]])\n            append(item[2:])\n        except KeyError:\n            append(b'%')\n            append(item)\n    return b''.join(res)", "output": "1"}
{"input": "search code:\nFind the sum of digits of a number >>> sum_of_digits_compact(12345) 15 >>> sum_of_digits_compact(123) 6 >>> sum_of_digits_compact(-123) 6 >>> sum_of_digits_compact(0) 0\nChoices:\n0: def map_except(function, iterable, *exceptions):\n    \"\"\"Transform each item from *iterable* with *function* and yield the\n    result, unless *function* raises one of the specified *exceptions*.\n\n    *function* is called to transform each item in *iterable*.\n    It should accept one argument.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(map_except(int, iterable, ValueError, TypeError))\n    [1, 2, 4]\n\n    If an exception other than one given by *exceptions* is raised by\n    *function*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            yield function(item)\n        except exceptions:\n            pass\n1: def method_2(boundary: list[int], steps: int) -> float:\n    # \"Simpson Rule\"\n    # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)\n    \"\"\"\n    Calculate the definite integral of a function using Simpson's Rule.\n    :param boundary: A list containing the lower and upper bounds of integration.\n    :param steps: The number of steps or resolution for the integration.\n    :return: The approximate integral value.\n\n    >>> round(method_2([0, 2, 4], 10), 10)\n    2.6666666667\n    >>> round(method_2([2, 0], 10), 10)\n    -0.2666666667\n    >>> round(method_2([-2, -1], 10), 10)\n    2.172\n    >>> round(method_2([0, 1], 10), 10)\n    0.3333333333\n    >>> round(method_2([0, 2], 10), 10)\n    2.6666666667\n    >>> round(method_2([0, 2], 100), 10)\n    2.5621226667\n    >>> round(method_2([0, 1], 1000), 10)\n    0.3320026653\n    >>> round(method_2([0, 2], 0), 10)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: Number of steps must be greater than zero\n    >>> round(method_2([0, 2], -10), 10)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: Number of steps must be greater than zero\n    \"\"\"\n    if steps <= 0:\n        raise ZeroDivisionError(\"Number of steps must be greater than zero\")\n\n    h = (boundary[1] - boundary[0]) / steps\n    a = boundary[0]\n    b = boundary[1]\n    x_i = make_points(a, b, h)\n    y = 0.0\n    y += (h / 3.0) * f(a)\n    cnt = 2\n    for i in x_i:\n        y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)\n        cnt += 1\n    y += (h / 3.0) * f(b)\n    return y\n2: def sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))", "output": "2"}
{"input": "summarize code:\ndef synchronized(func):\n    \"\"\"Wrap an iterator-returning callable to make its iterators thread-safe.\n\n    Existing itertools and more-itertools can be wrapped so that their\n    iterator instances are serialized.\n\n    For example, ``itertools.count`` does not make thread-safe instances,\n    but that is easily fixed with::\n\n        atomic_counter = synchronized(itertools.count)\n\n    Can also be used as a decorator for generator functions definitions\n    so that the generator instances are serialized::\n\n        @synchronized\n        def enumerate_and_timestamp(iterable):\n            for count, value in enumerate(iterable):\n                yield count, time_ns(), value\n\n    \"\"\"\n\n    @wraps(func)\n    def inner(*args, **kwargs):\n        iterator = func(*args, **kwargs)\n        return serialize(iterator)\n\n    return inner", "output": "Wrap an iterator-returning callable to make its iterators thread-safe."}
{"input": "summarize code:\ndef sieve(n):\n    \"\"\"Yield the primes less than n.\n\n    >>> list(sieve(30))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n    \"\"\"\n    # This implementation comes from an older version of the itertools\n    # documentation.  The newer implementation is easier to read but is\n    # less lazy.\n    if n > 2:\n        yield 2\n    start = 3\n    data = bytearray((0, 1)) * (n // 2)\n    for p in iter_index(data, 1, start, stop=isqrt(n) + 1):\n        yield from iter_index(data, 1, start, p * p)\n        data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))\n        start = p * p\n    yield from iter_index(data, 1, start)", "output": "Yield the primes less than n."}
{"input": "summarize code:\ndef solution(n_limit: int = 50 * 10**6) -> int:\n    \"\"\"\n    Define n count list and loop over delta, y to get the counts, then check\n    which n has count == 1.\n\n    >>> solution(3)\n    0\n    >>> solution(10)\n    3\n    >>> solution(100)\n    25\n    >>> solution(110)\n    27\n    \"\"\"\n    n_sol = [0] * n_limit\n\n    for delta in range(1, (n_limit + 1) // 4 + 1):\n        for y in range(4 * delta - 1, delta, -1):\n            n = y * (4 * delta - y)\n            if n >= n_limit:\n                break\n            n_sol[n] += 1\n\n    ans = 0\n    for i in range(n_limit):\n        if n_sol[i] == 1:\n            ans += 1\n\n    return ans", "output": "Define n count list and loop over delta, y to get the counts, then check which n has count == 1."}
{"input": "summarize code:\ndef _running_median_windowed(iterator, maxlen):\n    \"Yield median of values in a sliding window.\"\n\n    window = deque()\n    ordered = []\n\n    for x in iterator:\n        window.append(x)\n        insort(ordered, x)\n\n        if len(ordered) > maxlen:\n            i = bisect_left(ordered, window.popleft())\n            del ordered[i]\n\n        n = len(ordered)\n        m = n // 2\n        yield ordered[m] if n & 1 else (ordered[m - 1] + ordered[m]) / 2", "output": "Yield median of values in a sliding window."}
{"input": "search code:\nRuns k-means on given data and initial set of centroids. maxiter: maximum number of iterations to run.(default=500) record_heterogeneity: (optional) a list, to store the history of heterogeneity as function of iterations if None, do not store the history. verbose: if True, print how many data points changed their cluster labels in each iteration\nChoices:\n0: def kmeans(\n    data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False\n):\n    \"\"\"Runs k-means on given data and initial set of centroids.\n    maxiter: maximum number of iterations to run.(default=500)\n    record_heterogeneity: (optional) a list, to store the history of heterogeneity\n                          as function of iterations\n                          if None, do not store the history.\n    verbose: if True, print how many data points changed their cluster labels in\n                          each iteration\"\"\"\n    centroids = initial_centroids[:]\n    prev_cluster_assignment = None\n\n    for itr in range(maxiter):\n        if verbose:\n            print(itr, end=\"\")\n\n        # 1. Make cluster assignments using nearest centroids\n        cluster_assignment = assign_clusters(data, centroids)\n\n        # 2. Compute a new centroid for each of the k clusters, averaging all data\n        #    points assigned to that cluster.\n        centroids = revise_centroids(data, k, cluster_assignment)\n\n        # Check for convergence: if none of the assignments changed, stop\n        if (\n            prev_cluster_assignment is not None\n            and (prev_cluster_assignment == cluster_assignment).all()\n        ):\n            break\n\n        # Print number of new assignments\n        if prev_cluster_assignment is not None:\n            num_changed = np.sum(prev_cluster_assignment != cluster_assignment)\n            if verbose:\n                print(\n                    f\"    {num_changed:5d} elements changed their cluster assignment.\"\n                )\n\n        # Record heterogeneity convergence metric\n        if record_heterogeneity is not None:\n            # YOUR CODE HERE\n            score = compute_heterogeneity(data, k, centroids, cluster_assignment)\n            record_heterogeneity.append(score)\n\n        prev_cluster_assignment = cluster_assignment[:]\n\n    return centroids, cluster_assignment\n1: def find_max_area(mat: list[list[int]]) -> int:\n    \"\"\"\n    Finds the area of all islands and returns the maximum area.\n\n    >>> find_max_area(matrix)\n    6\n    \"\"\"\n    seen: set = set()\n\n    max_area = 0\n    for row, line in enumerate(mat):\n        for col, item in enumerate(line):\n            if item == 1 and (row, col) not in seen:\n                # Maximizing the area\n                max_area = max(max_area, depth_first_search(row, col, seen, mat))\n    return max_area\n2: def real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor", "output": "0"}
{"input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\nChoices:\n0: def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    >>> is_prime(16.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: is_prime() only accepts positive integers\n    >>> is_prime(-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: is_prime() only accepts positive integers\n    \"\"\"\n\n    # precondition\n    if not isinstance(number, int) or not number >= 0:\n        raise ValueError(\"is_prime() only accepts positive integers\")\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n1: def hypercube_points(\n    num_points: int, hypercube_size: float, num_dimensions: int\n) -> np.ndarray:\n    \"\"\"\n    Generates random points uniformly distributed within an n-dimensional hypercube.\n\n    Args:\n        num_points: Number of points to generate.\n        hypercube_size: Size of the hypercube.\n        num_dimensions: Number of dimensions of the hypercube.\n\n    Returns:\n        An array of shape (num_points, num_dimensions)\n                    with generated points.\n    \"\"\"\n    rng = np.random.default_rng()\n    shape = (num_points, num_dimensions)\n    return hypercube_size * rng.random(shape)\n2: def is_collection(obj):\n    \"\"\"The opposite of :func:`is_scalar`.  Returns ``True`` if an object\n    is an iterable other than a string.\n\n    >>> is_collection(object())\n    False\n    >>> is_collection(range(10))\n    True\n    >>> is_collection('hello')\n    False\n    \"\"\"\n    return is_iterable(obj) and not isinstance(obj, (str, bytes))", "output": "0"}
{"input": "summarize code:\ndef reshape(matrix, shape):\n    \"\"\"Change the shape of a *matrix*.\n\n    If *shape* is an integer, the matrix must be two dimensional\n    and the shape is interpreted as the desired number of columns:\n\n        >>> matrix = [(0, 1), (2, 3), (4, 5)]\n        >>> cols = 3\n        >>> list(reshape(matrix, cols))\n        [(0, 1, 2), (3, 4, 5)]\n\n    If *shape* is a tuple (or other iterable), the input matrix can have\n    any number of dimensions. It will first be flattened and then rebuilt\n    to the desired shape which can also be multidimensional:\n\n        >>> matrix = [(0, 1), (2, 3), (4, 5)]    # Start with a 3 x 2 matrix\n\n        >>> list(reshape(matrix, (2, 3)))        # Make a 2 x 3 matrix\n        [(0, 1, 2), (3, 4, 5)]\n\n        >>> list(reshape(matrix, (6,)))          # Make a vector of length six\n        [0, 1, 2, 3, 4, 5]\n\n        >>> list(reshape(matrix, (2, 1, 3, 1)))  # Make 2 x 1 x 3 x 1 tensor\n        [(((0,), (1,), (2,)),), (((3,), (4,), (5,)),)]\n\n    Each dimension is assumed to be uniform, either all arrays or all scalars.\n    Flattening stops when the first value in a dimension is a scalar.\n    Scalars are bytes, strings, and non-iterables.\n    The reshape iterator stops when the requested shape is complete\n    or when the input is exhausted, whichever comes first.\n\n    \"\"\"\n    if isinstance(shape, int):\n        return batched(chain.from_iterable(matrix), shape)\n    first_dim, *dims = shape\n    scalar_stream = _flatten_tensor(matrix)\n    reshaped = reduce(batched, reversed(dims), scalar_stream)\n    return islice(reshaped, first_dim)", "output": "Change the shape of a *matrix*."}
{"input": "summarize code:\ndef evaluate_poly(poly: Sequence[float], x: float) -> float:\n    \"\"\"Evaluate a polynomial f(x) at specified point x and return the value.\n\n    Arguments:\n    poly -- the coefficients of a polynomial as an iterable in order of\n            ascending degree\n    x -- the point at which to evaluate the polynomial\n\n    >>> evaluate_poly((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)\n    79800.0\n    \"\"\"\n    return sum(c * (x**i) for i, c in enumerate(poly))", "output": "Evaluate a polynomial f(x) at specified point x and return the value."}
{"input": "summarize code:\ndef get_totients(max_one: int) -> list[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = np.arange(max_one)\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            x = np.arange(i, max_one, i)  # array of indexes to select\n            totients[x] -= totients[x] // i\n\n    return totients.tolist()", "output": "Calculates a list of totients from 0 to max_one exclusive, using the definition of Euler's product formula."}
{"input": "summarize code:\ndef term_frequency(term: str, document: str) -> int:\n    \"\"\"\n    Return the number of times a term occurs within\n    a given document.\n    @params: term, the term to search a document for, and document,\n            the document to search within\n    @returns: an integer representing the number of times a term is\n            found within the document\n\n    @examples:\n    >>> term_frequency(\"to\", \"To be, or not to be\")\n    2\n    \"\"\"\n    # strip all punctuation and newlines and replace it with ''\n    document_without_punctuation = document.translate(\n        str.maketrans(\"\", \"\", string.punctuation)\n    ).replace(\"\\n\", \"\")\n    tokenize_document = document_without_punctuation.split(\" \")  # word tokenization\n    return len([word for word in tokenize_document if word.lower() == term.lower()])", "output": "Return the number of times a term occurs within a given document. @params: term, the term to search a document for, and document, the document to search within @returns: an integer representing the number of times a term is found within the document"}
{"input": "summarize code:\ndef show_results(\n    function_label: str,\n    function_params: Any,\n    escape_radius: float,\n    z_final: np.ndarray,\n) -> None:\n    \"\"\"\n    Plots of whether the absolute value of z_final is greater than\n    the value of escape_radius. Adds the function_label and function_params to\n    the title.\n\n    >>> show_results('80', 0, 1, np.array([[0,1,.5],[.4,2,1.1],[.2,1,1.3]]))\n    \"\"\"\n\n    abs_z_final = (abs(z_final)).transpose()\n    abs_z_final[:, :] = abs_z_final[::-1, :]\n    plt.matshow(abs_z_final < escape_radius)\n    plt.title(f\"Julia set of ${function_label}$, $c={function_params}$\")\n    plt.show()", "output": "Plots of whether the absolute value of z_final is greater than the value of escape_radius. Adds the function_label and function_params to the title."}
{"input": "search code:\nReturn True if the given char c is an operand, e.g. it is a number\nChoices:\n0: def _norm_args_typeerror(other):\n    '''normalize args and raise type-error if there is a problem'''\n    if type(other) in (set, frozenset):\n        inc, exc = other, None\n    elif type(other) is _ComplementSet:\n        inc, exc = other._included, other._excluded\n    else:\n        raise TypeError('argument must be another set or complement(set)')\n    return inc, exc\n1: def get_initial_centroids(data, k, seed=None):\n    \"\"\"Randomly choose k data points as initial centroids\"\"\"\n    # useful for obtaining consistent results\n    rng = np.random.default_rng(seed)\n    n = data.shape[0]  # number of data points\n\n    # Pick K indices from range [0, N).\n    rand_indices = rng.integers(0, n, k)\n\n    # Keep centroids as dense format, as many entries will be nonzero due to averaging.\n    # As long as at least one document in a cluster contains a word,\n    # it will carry a nonzero weight in the TF-IDF vector of the centroid.\n    centroids = data[rand_indices, :]\n\n    return centroids\n2: def is_operand(c):\n    \"\"\"\n    Return True if the given char c is an operand, e.g. it is a number\n\n    >>> is_operand(\"1\")\n    True\n    >>> is_operand(\"+\")\n    False\n    \"\"\"\n    return c.isdigit()", "output": "2"}
{"input": "search code:\nCalculate the area of a square.\nChoices:\n0: def solution(n: int = 15) -> int:\n    \"\"\"\n    Calculate sum of |_ P_m _| for m from 2 to n.\n\n    >>> solution(2)\n    1\n    >>> solution(3)\n    2\n    >>> solution(4)\n    4\n    >>> solution(5)\n    10\n    \"\"\"\n    total = 0\n    for m in range(2, n + 1):\n        x1 = 2 / (m + 1)\n        p = 1.0\n        for i in range(1, m + 1):\n            xi = i * x1\n            p *= xi**i\n        total += int(p)\n    return total\n1: def benchmark() -> None:\n    \"\"\"\n    Benchmark multiple functions, with three different length int values.\n    \"\"\"\n    from collections.abc import Callable\n    from timeit import timeit\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        # print(f\"{call:38} = {func(value)} -- {timing:.4f} seconds\")\n        print(f\"{call:38} -- {timing:.4f} seconds\")\n\n    for value in range(15):  # (1, 7, 14):\n        for func in (generate_pascal_triangle, generate_pascal_triangle_optimized):\n            benchmark_a_function(func, value)\n        print()\n2: def area_square(side_length: float) -> float:\n    \"\"\"\n    Calculate the area of a square.\n\n    >>> area_square(10)\n    100\n    >>> area_square(0)\n    0\n    >>> area_square(1.6)\n    2.5600000000000005\n    >>> area_square(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_square() only accepts non-negative values\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"area_square() only accepts non-negative values\")\n    return side_length**2", "output": "2"}
{"input": "search code:\nShow phase response of a filter\nChoices:\n0: def show_phase_response(filter_type: FilterType, samplerate: int) -> None:\n    \"\"\"\n    Show phase response of a filter\n\n    >>> from audio_filters.iir_filter import IIRFilter\n    >>> filt = IIRFilter(4)\n    >>> show_phase_response(filt, 48000)\n    \"\"\"\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\n\n    filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.angle(np.fft.fft(outputs))\n\n    # Frequencies on log scale from 24 to nyquist frequency\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\n\n    plt.ylim(-2 * pi, 2 * pi)\n    plt.ylabel(\"Phase shift (Radians)\")\n    plt.plot(np.unwrap(fft_out, -2 * pi))\n    plt.show()\n1: def intword(value, format=\"%.1f\"):\n    \"\"\"Converts a large integer to a friendly text representation.\n\n    Works best for numbers over 1 million. For example, 1_000_000 becomes \"1.0 million\",\n    1200000 becomes \"1.2 million\" and \"1_200_000_000\" becomes \"1.2 billion\". Supports up\n    to decillion (33 digits) and googol (100 digits).\n\n    Examples:\n        ```pycon\n        >>> intword(\"100\")\n        '100'\n        >>> intword(\"12400\")\n        '12.4 thousand'\n        >>> intword(\"1000000\")\n        '1.0 million'\n        >>> intword(1_200_000_000)\n        '1.2 billion'\n        >>> intword(8100000000000000000000000000000000)\n        '8.1 decillion'\n        >>> intword(None) is None\n        True\n        >>> intword(\"1234000\", \"%0.3f\")\n        '1.234 million'\n\n        ```\n    Args:\n        value (int, float, str): Integer to convert.\n        format (str): To change the number of decimal or general format of the number\n            portion.\n\n    Returns:\n        str: Friendly text representation as a string, unless the value passed could not\n        be coaxed into an `int`.\n    \"\"\"\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n\n    if value < powers[0]:\n        return str(value)\n    for ordinal, power in enumerate(powers[1:], 1):\n        if value < power:\n            chopped = value / float(powers[ordinal - 1])\n            if float(format % chopped) == float(10**3):\n                chopped = value / float(powers[ordinal])\n                singular, plural = human_powers[ordinal]\n                return (\n                    \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])\n                ) % chopped\n            else:\n                singular, plural = human_powers[ordinal - 1]\n                return (\n                    \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])\n                ) % chopped\n    return str(value)\n2: def run_length_encode(text: str) -> list:\n    \"\"\"\n    Performs Run Length Encoding\n    >>> run_length_encode(\"AAAABBBCCDAA\")\n    [('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]\n    >>> run_length_encode(\"A\")\n    [('A', 1)]\n    >>> run_length_encode(\"AA\")\n    [('A', 2)]\n    >>> run_length_encode(\"AAADDDDDDFFFCCCAAVVVV\")\n    [('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]\n    \"\"\"\n    encoded = []\n    count = 1\n\n    for i in range(len(text)):\n        if i + 1 < len(text) and text[i] == text[i + 1]:\n            count += 1\n        else:\n            encoded.append((text[i], count))\n            count = 1\n\n    return encoded", "output": "0"}
{"input": "summarize code:\ndef pythagorean_triple(max_perimeter: int) -> typing.Counter[int]:\n    \"\"\"\n    Returns a dictionary with keys as the perimeter of a right angled triangle\n    and value as the number of corresponding triplets.\n    >>> pythagorean_triple(15)\n    Counter({12: 1})\n    >>> pythagorean_triple(40)\n    Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1})\n    >>> pythagorean_triple(50)\n    Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1, 48: 1})\n    \"\"\"\n    triplets: typing.Counter[int] = Counter()\n    for base in range(1, max_perimeter + 1):\n        for perpendicular in range(base, max_perimeter + 1):\n            hypotenuse = (base * base + perpendicular * perpendicular) ** 0.5\n            if hypotenuse == int(hypotenuse):\n                perimeter = int(base + perpendicular + hypotenuse)\n                if perimeter > max_perimeter:\n                    continue\n                triplets[perimeter] += 1\n    return triplets", "output": "Returns a dictionary with keys as the perimeter of a right angled triangle and value as the number of corresponding triplets. >>> pythagorean_triple(15) Counter({12: 1}) >>> pythagorean_triple(40) Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1}) >>> pythagorean_triple(50) Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1, 48: 1})"}
{"input": "search code:\nConvert a binary value to its decimal equivalent\nChoices:\n0: def sum_of_divisors(n: int) -> int:\n    \"\"\"Calculate Sum of Divisors.\n    >>> sum_of_divisors(100)\n    217\n    >>> sum_of_divisors(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    >>> sum_of_divisors(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    s = 1\n    temp = 1\n    while n % 2 == 0:\n        temp += 1\n        n = int(n / 2)\n    if temp > 1:\n        s *= (2**temp - 1) / (2 - 1)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        temp = 1\n        while n % i == 0:\n            temp += 1\n            n = int(n / i)\n        if temp > 1:\n            s *= (i**temp - 1) / (i - 1)\n    return int(s)\n1: def make_tree() -> Node | None:\n    r\"\"\"\n    The below tree\n        1\n       / \\\n      2   3\n     / \\\n    4   5\n    \"\"\"\n    tree = Node(1)\n    tree.left = Node(2)\n    tree.right = Node(3)\n    tree.left.left = Node(4)\n    tree.left.right = Node(5)\n    return tree\n2: def bin_to_decimal(bin_string: str) -> int:\n    \"\"\"\n    Convert a binary value to its decimal equivalent\n\n    >>> bin_to_decimal(\"101\")\n    5\n    >>> bin_to_decimal(\" 1010   \")\n    10\n    >>> bin_to_decimal(\"-11101\")\n    -29\n    >>> bin_to_decimal(\"0\")\n    0\n    >>> bin_to_decimal(\"a\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    >>> bin_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> bin_to_decimal(\"39\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    \"\"\"\n    bin_string = str(bin_string).strip()\n    if not bin_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = bin_string[0] == \"-\"\n    if is_negative:\n        bin_string = bin_string[1:]\n    if not all(char in \"01\" for char in bin_string):\n        raise ValueError(\"Non-binary value was passed to the function\")\n    decimal_number = 0\n    for char in bin_string:\n        decimal_number = 2 * decimal_number + int(char)\n    return -decimal_number if is_negative else decimal_number", "output": "2"}
{"input": "summarize code:\ndef solution(n: int = 600851475143) -> int:\n    \"\"\"\n    Returns the largest prime factor of a given number n.\n\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    max_number = 0\n    if is_prime(n):\n        return n\n    while n % 2 == 0:\n        n //= 2\n    if is_prime(n):\n        return n\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            if is_prime(n // i):\n                max_number = n // i\n                break\n            elif is_prime(i):\n                max_number = i\n    return max_number", "output": "Returns the largest prime factor of a given number n."}
{"input": "search code:\nReturn the first item of *iterable*, or *default* if *iterable* is empty.\nChoices:\n0: def first(iterable, default=_marker):\n    \"\"\"Return the first item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> first([0, 1, 2, 3])\n        0\n        >>> first([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n\n    :func:`first` is useful when you have a generator of expensive-to-retrieve\n    values and want any arbitrary one. It is marginally shorter than\n    ``next(iter(iterable), default)``.\n\n    \"\"\"\n    for item in iterable:\n        return item\n    if default is _marker:\n        raise ValueError(\n            'first() was called on an empty iterable, '\n            'and no default value was provided.'\n        )\n    return default\n1: def unquote_to_bytes(string):\n    \"\"\"unquote_to_bytes('abc%20def') -> b'abc def'.\"\"\"\n    # Note: strings are encoded as UTF-8. This is only an issue if it contains\n    # unescaped non-ASCII characters, which URIs should not.\n    if not string:\n        # Is it a string-like object?\n        string.split\n        return b''\n    if isinstance(string, str):\n        string = string.encode('utf-8')\n    bits = string.split(b'%')\n    if len(bits) == 1:\n        return string\n    # import pdb;pdb.set_trace()\n    res = [bits[0]]\n    append = res.append\n\n    for item in bits[1:]:\n        try:\n            append(_HEX_CHAR_MAP[item[:2]])\n            append(item[2:])\n        except KeyError:\n            append(b'%')\n            append(item)\n    return b''.join(res)\n2: def to_complex_case(text: str, upper: bool, separator: str) -> str:\n    \"\"\"\n    Returns the string concatenated with the delimiter we provide.\n\n    Parameters:\n    @text: The string on which we want to perform operation\n    @upper: Boolean value to determine whether we want capitalized result or not\n    @separator: The delimiter with which we want to concatenate words\n\n    Examples:\n    >>> to_complex_case(\"one two 31235three4four\", True, \"_\")\n    'ONE_TWO_31235THREE4FOUR'\n    >>> to_complex_case(\"one two 31235three4four\", False, \"-\")\n    'one-two-31235three4four'\n    \"\"\"\n    try:\n        string_split = split_input(text)\n        if upper:\n            res_str = \"\".join(\n                [\n                    separator.join([char.upper() for char in sub_str])\n                    for sub_str in string_split\n                ]\n            )\n        else:\n            res_str = \"\".join(\n                [\n                    separator.join([char.lower() for char in sub_str])\n                    for sub_str in string_split\n                ]\n            )\n        return res_str\n    except IndexError:\n        return \"not valid string\"", "output": "0"}
{"input": "summarize code:\ndef construct_format_field_str(fname, fspec, conv):\n    \"\"\"\n    Constructs a format field string from the field name, spec, and\n    conversion character (``fname``, ``fspec``, ``conv``). See Python\n    String Formatting for more info.\n    \"\"\"\n    if fname is None:\n        return ''\n    ret = '{' + fname\n    if conv:\n        ret += '!' + conv\n    if fspec:\n        ret += ':' + fspec\n    ret += '}'\n    return ret", "output": "Constructs a format field string from the field name, spec, and conversion character (``fname``, ``fspec``, ``conv``). See Python String Formatting for more info."}
{"input": "search code:\nTransform a string of ranges (*range_string*) into a tuple of tuples.\nChoices:\n0: def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n1: def first(iterable, default=_marker):\n    \"\"\"Return the first item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> first([0, 1, 2, 3])\n        0\n        >>> first([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n\n    :func:`first` is useful when you have a generator of expensive-to-retrieve\n    values and want any arbitrary one. It is marginally shorter than\n    ``next(iter(iterable), default)``.\n\n    \"\"\"\n    for item in iterable:\n        return item\n    if default is _marker:\n        raise ValueError(\n            'first() was called on an empty iterable, '\n            'and no default value was provided.'\n        )\n    return default\n2: def int_ranges_from_int_list(range_string, delim=',', range_delim='-'):\n    \"\"\" Transform a string of ranges (*range_string*) into a tuple of tuples.\n\n    Args:\n        range_string (str): String of comma separated positive integers or\n           ranges (e.g. '1,2,4-6,8'). Typical of a custom page range string\n           used in printer dialogs.\n        delim (char): Defaults to ','. Separates integers and contiguous ranges\n           of integers.\n        range_delim (char): Defaults to '-'. Indicates a contiguous range of\n           integers.\n\n    >>> int_ranges_from_int_list('1,3,5-8,10-11,15')\n    ((1, 1), (3, 3), (5, 8), (10, 11), (15, 15))\n\n    >>> int_ranges_from_int_list('1')\n    ((1, 1),)\n\n    >>> int_ranges_from_int_list('')\n    ()\n    \"\"\"\n    int_tuples = []\n    # Normalize the range string to our internal format for processing.\n    range_string = format_int_list(\n        parse_int_list(range_string, delim, range_delim))\n    if range_string:\n        for bounds in range_string.split(','):\n            if '-' in bounds:\n                start, end = bounds.split('-')\n            else:\n                start, end = bounds, bounds\n            int_tuples.append((int(start), int(end)))\n    return tuple(int_tuples)", "output": "2"}
{"input": "summarize code:\ndef create_edge(nodes, graph, cluster, c1):\n    \"\"\"\n    create edge between the nodes\n    \"\"\"\n    for i in cluster[c1]:\n        count = 0\n        c2 = c1 + 1\n        while c2 < max(cluster.keys()):\n            for j in cluster[c2]:\n                \"\"\"\n                creates edge only if the condition satisfies\n                \"\"\"\n                if int(i, 2) & int(j, 2) == int(i, 2):\n                    if tuple(nodes[i]) in graph:\n                        graph[tuple(nodes[i])].append(nodes[j])\n                    else:\n                        graph[tuple(nodes[i])] = [nodes[j]]\n                    count += 1\n            if count == 0:\n                c2 = c2 + 1\n            else:\n                break", "output": "create edge between the nodes"}
{"input": "summarize code:\ndef matmul(m1, m2):\n    \"\"\"Multiply two matrices.\n\n    >>> list(matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]))\n    [(49, 80), (41, 60)]\n\n    The caller should ensure that the dimensions of the input matrices are\n    compatible with each other.\n\n    Supports all numeric types: int, float, complex, Decimal, Fraction.\n    \"\"\"\n    n = len(m2[0])\n    return batched(starmap(_sumprod, product(m1, transpose(m2))), n)", "output": "Multiply two matrices."}
{"input": "search code:\nYield the circular shifts of *iterable*.\nChoices:\n0: def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result\n1: def decimal_to_negative_base_2(num: int) -> int:\n    \"\"\"\n    This function returns the number negative base 2\n        of the decimal number of the input data.\n\n    Args:\n        int: The decimal number to convert.\n\n    Returns:\n        int: The negative base 2 number.\n\n    Examples:\n        >>> decimal_to_negative_base_2(0)\n        0\n        >>> decimal_to_negative_base_2(-19)\n        111101\n        >>> decimal_to_negative_base_2(4)\n        100\n        >>> decimal_to_negative_base_2(7)\n        11011\n    \"\"\"\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)\n2: def circular_shifts(iterable, steps=1):\n    \"\"\"Yield the circular shifts of *iterable*.\n\n    >>> list(circular_shifts(range(4)))\n    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n\n    Set *steps* to the number of places to rotate to the left\n    (or to the right if negative).  Defaults to 1.\n\n    >>> list(circular_shifts(range(4), 2))\n    [(0, 1, 2, 3), (2, 3, 0, 1)]\n\n    >>> list(circular_shifts(range(4), -1))\n    [(0, 1, 2, 3), (3, 0, 1, 2), (2, 3, 0, 1), (1, 2, 3, 0)]\n\n    \"\"\"\n    buffer = deque(iterable)\n    if steps == 0:\n        raise ValueError('Steps should be a non-zero integer')\n\n    buffer.rotate(steps)\n    steps = -steps\n    n = len(buffer)\n    n //= math.gcd(n, steps)\n\n    for _ in repeat(None, n):\n        buffer.rotate(steps)\n        yield tuple(buffer)", "output": "2"}
{"input": "summarize code:\ndef area_under_curve_estimator(\n    iterations: int,\n    function_to_integrate: Callable[[float], float],\n    min_value: float = 0.0,\n    max_value: float = 1.0,\n) -> float:\n    \"\"\"\n    An implementation of the Monte Carlo method to find area under\n       a single variable non-negative real-valued continuous function,\n       say f(x), where x lies within a continuous bounded interval,\n       say [min_value, max_value], where min_value and max_value are\n       finite numbers\n    1. Let x be a uniformly distributed random variable between min_value to\n       max_value\n    2. Expected value of f(x) =\n       (integrate f(x) from min_value to max_value)/(max_value - min_value)\n    3. Finding expected value of f(x):\n        a. Repeatedly draw x from uniform distribution\n        b. Evaluate f(x) at each of the drawn x values\n        c. Expected value = average of the function evaluations\n    4. Estimated value of integral = Expected value * (max_value - min_value)\n    5. Returns estimated value\n    \"\"\"\n\n    return mean(\n        function_to_integrate(uniform(min_value, max_value)) for _ in range(iterations)\n    ) * (max_value - min_value)", "output": "An implementation of the Monte Carlo method to find area under a single variable non-negative real-valued continuous function, say f(x), where x lies within a continuous bounded interval, say [min_value, max_value], where min_value and max_value are finite numbers 1. Let x be a uniformly distributed random variable between min_value to max_value 2. Expected value of f(x) = (integrate f(x) from min_value to max_value)/(max_value - min_value) 3. Finding expected value of f(x): a. Repeatedly draw x from uniform distribution b. Evaluate f(x) at each of the drawn x values c. Expected value = average of the function evaluations 4. Estimated value of integral = Expected value * (max_value - min_value) 5. Returns estimated value"}
{"input": "search code:\nMake x as a set.\nChoices:\n0: def make_set(x: Node) -> None:\n    \"\"\"\n    Make x as a set.\n    \"\"\"\n    # rank is the distance from x to its' parent\n    # root's rank is 0\n    x.rank = 0\n    x.parent = x\n1: def solution(percent: float = 99) -> int:\n    \"\"\"\n    Returns the least number for which the proportion of bouncy numbers is\n    exactly 'percent'\n    >>> solution(50)\n    538\n    >>> solution(90)\n    21780\n    >>> solution(80)\n    4770\n    >>> solution(105)\n    Traceback (most recent call last):\n        ...\n    ValueError: solution() only accepts values from 0 to 100\n    >>> solution(100.011)\n    Traceback (most recent call last):\n        ...\n    ValueError: solution() only accepts values from 0 to 100\n    \"\"\"\n    if not 0 < percent < 100:\n        raise ValueError(\"solution() only accepts values from 0 to 100\")\n    bouncy_num = 0\n    num = 1\n\n    while True:\n        if check_bouncy(num):\n            bouncy_num += 1\n        if (bouncy_num / num) * 100 >= percent:\n            return num\n        num += 1\n2: def evaluate_poly(poly: Sequence[float], x: float) -> float:\n    \"\"\"Evaluate a polynomial f(x) at specified point x and return the value.\n\n    Arguments:\n    poly -- the coefficients of a polynomial as an iterable in order of\n            ascending degree\n    x -- the point at which to evaluate the polynomial\n\n    >>> evaluate_poly((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)\n    79800.0\n    \"\"\"\n    return sum(c * (x**i) for i, c in enumerate(poly))", "output": "0"}
{"input": "search code:\nUse a stack to check if a string of parentheses is balanced. >>> balanced_parentheses(\"([]{})\") True >>> balanced_parentheses(\"[()]{}{[()()]()}\") True >>> balanced_parentheses(\"[(])\") False >>> balanced_parentheses(\"1+2*3-4\") True >>> balanced_parentheses(\"\") True\nChoices:\n0: def solution():\n    \"\"\"Returns the number of mondays that fall on the first of the month during\n    the twentieth century (1 Jan 1901 to 31 Dec 2000)?\n\n    >>> solution()\n    171\n    \"\"\"\n    days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    day = 6\n    month = 1\n    year = 1901\n\n    sundays = 0\n\n    while year < 2001:\n        day += 7\n\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            if day > days_per_month[month - 1] and month != 2:\n                month += 1\n                day = day - days_per_month[month - 2]\n            elif day > 29 and month == 2:\n                month += 1\n                day = day - 29\n        elif day > days_per_month[month - 1]:\n            month += 1\n            day = day - days_per_month[month - 2]\n\n        if month > 12:\n            year += 1\n            month = 1\n\n        if year < 2001 and day == 1:\n            sundays += 1\n    return sundays\n1: def balanced_parentheses(parentheses: str) -> bool:\n    \"\"\"Use a stack to check if a string of parentheses is balanced.\n    >>> balanced_parentheses(\"([]{})\")\n    True\n    >>> balanced_parentheses(\"[()]{}{[()()]()}\")\n    True\n    >>> balanced_parentheses(\"[(])\")\n    False\n    >>> balanced_parentheses(\"1+2*3-4\")\n    True\n    >>> balanced_parentheses(\"\")\n    True\n    \"\"\"\n    stack: Stack[str] = Stack()\n    bracket_pairs = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}\n    for bracket in parentheses:\n        if bracket in bracket_pairs:\n            stack.push(bracket)\n        elif bracket in (\")\", \"]\", \"}\") and (\n            stack.is_empty() or bracket_pairs[stack.pop()] != bracket\n        ):\n            return False\n    return stack.is_empty()\n2: def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number num (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True", "output": "1"}
{"input": "search code:\nBreak *iterable* into lists of approximately length *n*. Items are distributed such the lengths of the lists differ by at most 1 item.\nChoices:\n0: def chunked_even(iterable, n):\n    \"\"\"Break *iterable* into lists of approximately length *n*.\n    Items are distributed such the lengths of the lists differ by at most\n    1 item.\n\n    >>> iterable = [1, 2, 3, 4, 5, 6, 7]\n    >>> n = 3\n    >>> list(chunked_even(iterable, n))  # List lengths: 3, 2, 2\n    [[1, 2, 3], [4, 5], [6, 7]]\n    >>> list(chunked(iterable, n))  # List lengths: 3, 3, 1\n    [[1, 2, 3], [4, 5, 6], [7]]\n\n    \"\"\"\n    iterator = iter(iterable)\n\n    # Initialize a buffer to process the chunks while keeping\n    # some back to fill any underfilled chunks\n    min_buffer = (n - 1) * (n - 2)\n    buffer = list(islice(iterator, min_buffer))\n\n    # Append items until we have a completed chunk\n    for _ in islice(map(buffer.append, iterator), n, None, n):\n        yield buffer[:n]\n        del buffer[:n]\n\n    # Check if any chunks need addition processing\n    if not buffer:\n        return\n    length = len(buffer)\n\n    # Chunks are either size `full_size <= n` or `partial_size = full_size - 1`\n    q, r = divmod(length, n)\n    num_lists = q + (1 if r > 0 else 0)\n    q, r = divmod(length, num_lists)\n    full_size = q + (1 if r > 0 else 0)\n    partial_size = full_size - 1\n    num_full = length - partial_size * num_lists\n\n    # Yield chunks of full size\n    partial_start_idx = num_full * full_size\n    if full_size > 0:\n        for i in range(0, partial_start_idx, full_size):\n            yield buffer[i : i + full_size]\n\n    # Yield chunks of partial size\n    if partial_size > 0:\n        for i in range(partial_start_idx, length, partial_size):\n            yield buffer[i : i + partial_size]\n1: def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])\n2: def swap_odd_even_bits(num: int) -> int:\n    \"\"\"\n    1. We use bitwise AND operations to separate the even bits (0, 2, 4, 6, etc.) and\n       odd bits (1, 3, 5, 7, etc.) in the input number.\n    2. We then right-shift the even bits by 1 position and left-shift the odd bits by\n       1 position to swap them.\n    3. Finally, we combine the swapped even and odd bits using a bitwise OR operation\n       to obtain the final result.\n    >>> print(show_bits(0, swap_odd_even_bits(0)))\n        0: 00000000\n        0: 00000000\n    >>> print(show_bits(1, swap_odd_even_bits(1)))\n        1: 00000001\n        2: 00000010\n    >>> print(show_bits(2, swap_odd_even_bits(2)))\n        2: 00000010\n        1: 00000001\n    >>> print(show_bits(3, swap_odd_even_bits(3)))\n        3: 00000011\n        3: 00000011\n    >>> print(show_bits(4, swap_odd_even_bits(4)))\n        4: 00000100\n        8: 00001000\n    >>> print(show_bits(5, swap_odd_even_bits(5)))\n        5: 00000101\n       10: 00001010\n    >>> print(show_bits(6, swap_odd_even_bits(6)))\n        6: 00000110\n        9: 00001001\n    >>> print(show_bits(23, swap_odd_even_bits(23)))\n       23: 00010111\n       43: 00101011\n    \"\"\"\n    # Get all even bits - 0xAAAAAAAA is a 32-bit number with all even bits set to 1\n    even_bits = num & 0xAAAAAAAA\n\n    # Get all odd bits - 0x55555555 is a 32-bit number with all odd bits set to 1\n    odd_bits = num & 0x55555555\n\n    # Right shift even bits and left shift odd bits and swap them\n    return even_bits >> 1 | odd_bits << 1", "output": "0"}
{"input": "summarize code:\ndef multiply_matrix_vector(\n    graph: list[list[int | None]], vector: np.ndarray\n) -> np.ndarray:\n    \"\"\"Performs multiplication of a graph's adjacency list representation with a vector.\n\n    Args:\n        graph: The adjacency list of the graph.\n        vector: A 1D numpy array representing the vector to multiply.\n\n    Returns:\n        A numpy array representing the product of the adjacency list and the vector.\n\n    Raises:\n        ValueError: If the vector's length does not match the number of nodes in the\n                    graph.\n\n    >>> multiply_matrix_vector([[1, 2], [0, 2], [0, 1]], np.array([1, 1, 1]))\n    array([2., 2., 2.])\n    >>> multiply_matrix_vector([[1, 2], [0, 2], [0, 1]], np.array([0, 1, 0]))\n    array([1., 0., 1.])\n    \"\"\"\n    num_nodes: int = len(graph)\n    if vector.shape[0] != num_nodes:\n        raise ValueError(\"Vector length must match the number of nodes in the graph.\")\n\n    result: np.ndarray = np.zeros(num_nodes)\n    for node_index, neighbors in enumerate(graph):\n        for neighbor_index in neighbors:\n            result[node_index] += vector[neighbor_index]\n    return result", "output": "Performs multiplication of a graph's adjacency list representation with a vector."}
{"input": "summarize code:\ndef triangular_number(position: int) -> int:\n    \"\"\"\n    Generate the triangular number at the specified position.\n\n    Args:\n        position (int): The position of the triangular number to generate.\n\n    Returns:\n        int: The triangular number at the specified position.\n\n    Raises:\n        ValueError: If `position` is negative.\n\n    Examples:\n    >>> triangular_number(1)\n    1\n    >>> triangular_number(3)\n    6\n    >>> triangular_number(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: param `position` must be non-negative\n    \"\"\"\n    if position < 0:\n        raise ValueError(\"param `position` must be non-negative\")\n\n    return position * (position + 1) // 2", "output": "Generate the triangular number at the specified position."}
{"input": "summarize code:\ndef avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:\n    \"\"\"\n    This function is used to perform avgpooling on the input array of 2D matrix(image)\n    Args:\n        arr: numpy array\n        size: size of pooling matrix\n        stride: the number of pixels shifts over the input matrix\n    Returns:\n        numpy array of avgpooled matrix\n    Sample Input Output:\n    >>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)\n    array([[ 3.,  5.],\n           [11., 13.]])\n    >>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)\n    array([[161., 102.],\n           [114.,  69.]])\n    \"\"\"\n    arr = np.array(arr)\n    if arr.shape[0] != arr.shape[1]:\n        raise ValueError(\"The input array is not a square matrix\")\n    i = 0\n    j = 0\n    mat_i = 0\n    mat_j = 0\n\n    # compute the shape of the output matrix\n    avgpool_shape = (arr.shape[0] - size) // stride + 1\n    # initialize the output matrix with zeros of shape avgpool_shape\n    updated_arr = np.zeros((avgpool_shape, avgpool_shape))\n\n    while i < arr.shape[0]:\n        # if the end of the matrix is reached, break\n        if i + size > arr.shape[0]:\n            break\n        while j < arr.shape[1]:\n            # if the end of the matrix is reached, break\n            if j + size > arr.shape[1]:\n                break\n            # compute the average of the pooling matrix\n            updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))\n            # shift the pooling matrix by stride of column pixels\n            j += stride\n            mat_j += 1\n\n        # shift the pooling matrix by stride of row pixels\n        i += stride\n        mat_i += 1\n        # reset the column index to 0\n        j = 0\n        mat_j = 0\n\n    return updated_arr", "output": "This function is used to perform avgpooling on the input array of 2D matrix(image) Args: arr: numpy array size: size of pooling matrix stride: the number of pixels shifts over the input matrix Returns: numpy array of avgpooled matrix Sample Input Output: >>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2) array([[ 3., 5.], [11., 13.]]) >>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1) array([[161., 102.], [114., 69.]])"}
{"input": "summarize code:\ndef unit_len(sized_iterable, unit_noun='item'):  # TODO: len_units()/unitize()?\n    \"\"\"Returns a plain-English description of an iterable's\n    :func:`len()`, conditionally pluralized with :func:`cardinalize`,\n    detailed below.\n\n    >>> print(unit_len(range(10), 'number'))\n    10 numbers\n    >>> print(unit_len('aeiou', 'vowel'))\n    5 vowels\n    >>> print(unit_len([], 'worry'))\n    No worries\n    \"\"\"\n    count = len(sized_iterable)\n    units = cardinalize(unit_noun, count)\n    if count:\n        return f'{count} {units}'\n    return f'No {units}'", "output": "Returns a plain-English description of an iterable's :func:`len()`, conditionally pluralized with :func:`cardinalize`, detailed below."}
{"input": "search code:\nFunction to compute the covariance matrix inside each class. >>> features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> labels = np.array([0, 1, 0]) >>> covariance_within_classes(features, labels, 2) array([[0.66666667, 0.66666667, 0.66666667], [0.66666667, 0.66666667, 0.66666667], [0.66666667, 0.66666667, 0.66666667]])\nChoices:\n0: def abs_val(num: float) -> float:\n    \"\"\"\n    Find the absolute value of a number.\n\n    >>> abs_val(-5.1)\n    5.1\n    >>> abs_val(-5) == abs_val(5)\n    True\n    >>> abs_val(0)\n    0\n    \"\"\"\n    return -num if num < 0 else num\n1: def covariance_within_classes(\n    features: np.ndarray, labels: np.ndarray, classes: int\n) -> np.ndarray:\n    \"\"\"Function to compute the covariance matrix inside each class.\n    >>> features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> labels = np.array([0, 1, 0])\n    >>> covariance_within_classes(features, labels, 2)\n    array([[0.66666667, 0.66666667, 0.66666667],\n           [0.66666667, 0.66666667, 0.66666667],\n           [0.66666667, 0.66666667, 0.66666667]])\n    \"\"\"\n\n    covariance_sum = np.nan\n    for i in range(classes):\n        data = features[:, labels == i]\n        data_mean = data.mean(1)\n        # Centralize the data of class i\n        centered_data = data - column_reshape(data_mean)\n        if i > 0:\n            # If covariance_sum is not None\n            covariance_sum += np.dot(centered_data, centered_data.T)\n        else:\n            # If covariance_sum is np.nan (i.e. first loop)\n            covariance_sum = np.dot(centered_data, centered_data.T)\n\n    return covariance_sum / features.shape[1]\n2: def is_collection(obj):\n    \"\"\"The opposite of :func:`is_scalar`.  Returns ``True`` if an object\n    is an iterable other than a string.\n\n    >>> is_collection(object())\n    False\n    >>> is_collection(range(10))\n    True\n    >>> is_collection('hello')\n    False\n    \"\"\"\n    return is_iterable(obj) and not isinstance(obj, (str, bytes))", "output": "1"}
{"input": "search code:\nReturns the solution of the problem\nChoices:\n0: def charging_inductor(\n    source_voltage: float,  # source_voltage should be in volts.\n    resistance: float,  # resistance should be in ohms.\n    inductance: float,  # inductance should be in henrys.\n    time: float,  # time should in seconds.\n) -> float:\n    \"\"\"\n    Find inductor current at any nth second after initiating its charging.\n\n    Examples\n    --------\n    >>> charging_inductor(source_voltage=5.8,resistance=1.5,inductance=2.3,time=2)\n    2.817\n\n    >>> charging_inductor(source_voltage=8,resistance=5,inductance=3,time=2)\n    1.543\n\n    >>> charging_inductor(source_voltage=8,resistance=5*pow(10,2),inductance=3,time=2)\n    0.016\n\n    >>> charging_inductor(source_voltage=-8,resistance=100,inductance=15,time=12)\n    Traceback (most recent call last):\n        ...\n    ValueError: Source voltage must be positive.\n\n    >>> charging_inductor(source_voltage=80,resistance=-15,inductance=100,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistance must be positive.\n\n    >>> charging_inductor(source_voltage=12,resistance=200,inductance=-20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductance must be positive.\n\n    >>> charging_inductor(source_voltage=0,resistance=200,inductance=20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Source voltage must be positive.\n\n    >>> charging_inductor(source_voltage=10,resistance=0,inductance=20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistance must be positive.\n\n    >>> charging_inductor(source_voltage=15, resistance=25, inductance=0, time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductance must be positive.\n    \"\"\"\n\n    if source_voltage <= 0:\n        raise ValueError(\"Source voltage must be positive.\")\n    if resistance <= 0:\n        raise ValueError(\"Resistance must be positive.\")\n    if inductance <= 0:\n        raise ValueError(\"Inductance must be positive.\")\n    return round(\n        source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3\n    )\n1: def solution(family_length: int = 8) -> int:\n    \"\"\"\n    Returns the solution of the problem\n\n    >>> solution(2)\n    229399\n\n    >>> solution(3)\n    221311\n    \"\"\"\n    numbers_checked = set()\n\n    # Filter primes with less than 3 replaceable digits\n    primes = {\n        x for x in set(prime_sieve(1_000_000)) if len(str(x)) - len(set(str(x))) >= 3\n    }\n\n    for prime in primes:\n        if prime in numbers_checked:\n            continue\n\n        replacements = digit_replacements(prime)\n\n        for family in replacements:\n            numbers_checked.update(family)\n            primes_in_family = primes.intersection(family)\n\n            if len(primes_in_family) != family_length:\n                continue\n\n            return min(primes_in_family)\n\n    return -1\n2: def alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)", "output": "1"}
{"input": "summarize code:\ndef take(n, iterable):\n    \"\"\"Return first *n* items of the *iterable* as a list.\n\n        >>> take(3, range(10))\n        [0, 1, 2]\n\n    If there are fewer than *n* items in the iterable, all of them are\n    returned.\n\n        >>> take(10, range(3))\n        [0, 1, 2]\n\n    \"\"\"\n    return list(islice(iterable, n))", "output": "Return first *n* items of the *iterable* as a list."}
{"input": "summarize code:\ndef bwt_transform(s: str) -> BWTTransformDict:\n    \"\"\"\n    :param s: The string that will be used at bwt algorithm\n    :return: the string composed of the last char of each row of the ordered\n    rotations and the index of the original string at ordered rotations list\n    :raises TypeError: If the s parameter type is not str\n    :raises ValueError: If the s parameter is empty\n    Examples:\n\n    >>> bwt_transform(\"^BANANA\")\n    {'bwt_string': 'BNN^AAA', 'idx_original_string': 6}\n    >>> bwt_transform(\"a_asa_da_casa\")\n    {'bwt_string': 'aaaadss_c__aa', 'idx_original_string': 3}\n    >>> bwt_transform(\"panamabanana\")\n    {'bwt_string': 'mnpbnnaaaaaa', 'idx_original_string': 11}\n    >>> bwt_transform(4)\n    Traceback (most recent call last):\n        ...\n    TypeError: The parameter s type must be str.\n    >>> bwt_transform('')\n    Traceback (most recent call last):\n        ...\n    ValueError: The parameter s must not be empty.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"The parameter s type must be str.\")\n    if not s:\n        raise ValueError(\"The parameter s must not be empty.\")\n\n    rotations = all_rotations(s)\n    rotations.sort()  # sort the list of rotations in alphabetically order\n    # make a string composed of the last char of each rotation\n    response: BWTTransformDict = {\n        \"bwt_string\": \"\".join([word[-1] for word in rotations]),\n        \"idx_original_string\": rotations.index(s),\n    }\n    return response", "output": ":param s: The string that will be used at bwt algorithm :return: the string composed of the last char of each row of the ordered rotations and the index of the original string at ordered rotations list :raises TypeError: If the s parameter type is not str :raises ValueError: If the s parameter is empty Examples:"}
{"input": "search code:\nCompute low-dimensional affinities (Q matrix) using a Student-t distribution.\nChoices:\n0: def resolve_path_parts(path_parts):\n    \"\"\"Normalize the URL path by resolving segments of '.' and '..',\n    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove\n    Dot Segments.\n    \"\"\"\n    # TODO: what to do with multiple slashes\n    ret = []\n\n    for part in path_parts:\n        if part == '.':\n            pass\n        elif part == '..':\n            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting\n                ret.pop()\n        else:\n            ret.append(part)\n\n    if list(path_parts[-1:]) in (['.'], ['..']):\n        ret.append('')\n\n    return ret\n1: def reactive_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate reactive power from apparent power and power factor.\n\n    Examples:\n    >>> reactive_power(100, 0.9)\n    43.58898943540673\n    >>> reactive_power(0, 0.8)\n    0.0\n    >>> reactive_power(100, -0.9)\n    43.58898943540673\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * math.sqrt(1 - power_factor**2)\n2: def compute_low_dim_affinities(embedding_matrix: ndarray) -> tuple[ndarray, ndarray]:\n    \"\"\"\n    Compute low-dimensional affinities (Q matrix) using a Student-t distribution.\n\n    Args:\n        embedding_matrix: Low-dimensional embedding of shape (n_samples, n_components).\n\n    Returns:\n        tuple[ndarray, ndarray]: (Q probability matrix, numerator matrix).\n\n    >>> y = np.array([[0.0, 0.0], [1.0, 0.0]])\n    >>> q_matrix, numerators = compute_low_dim_affinities(y)\n    >>> q_matrix.shape\n    (2, 2)\n    \"\"\"\n    squared_sum = np.sum(np.square(embedding_matrix), axis=1)\n    numerator_matrix = 1 / (\n        1\n        + np.add(\n            np.add(-2 * np.dot(embedding_matrix, embedding_matrix.T), squared_sum).T,\n            squared_sum,\n        )\n    )\n    np.fill_diagonal(numerator_matrix, 0)\n\n    q_matrix = numerator_matrix / np.sum(numerator_matrix)\n    return q_matrix, numerator_matrix", "output": "2"}
{"input": "search code:\nConvert the cells into a greyscale PIL.Image.Image and return it to the caller. >>> from random import random >>> cells = [[random() for w in range(31)] for h in range(16)] >>> img = generate_image(cells) >>> isinstance(img, Image.Image) True >>> img.width, img.height (31, 16)\nChoices:\n0: def first_true(iterable, default=None, pred=None):\n    \"\"\"\n    Returns the first true value in the iterable.\n\n    If no true value is found, returns *default*\n\n    If *pred* is not None, returns the first item for which\n    ``pred(item) == True`` .\n\n        >>> first_true(range(10))\n        1\n        >>> first_true(range(10), pred=lambda x: x > 5)\n        6\n        >>> first_true(range(10), default='missing', pred=lambda x: x > 9)\n        'missing'\n\n    \"\"\"\n    return next(filter(pred, iterable), default)\n1: def create_cipher_map(key: str) -> dict[str, str]:\n    \"\"\"\n    Returns a cipher map given a keyword.\n\n    :param key: keyword to use\n    :return: dictionary cipher map\n    \"\"\"\n    # Create a list of the letters in the alphabet\n    alphabet = [chr(i + 65) for i in range(26)]\n    # Remove duplicate characters from key\n    key = remove_duplicates(key.upper())\n    offset = len(key)\n    # First fill cipher with key characters\n    cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}\n    # Then map remaining characters in alphabet to\n    # the alphabet from the beginning\n    for i in range(len(cipher_alphabet), 26):\n        char = alphabet[i - offset]\n        # Ensure we are not mapping letters to letters previously mapped\n        while char in key:\n            offset -= 1\n            char = alphabet[i - offset]\n        cipher_alphabet[alphabet[i]] = char\n    return cipher_alphabet\n2: def generate_image(cells: list[list[int]]) -> Image.Image:\n    \"\"\"\n    Convert the cells into a greyscale PIL.Image.Image and return it to the caller.\n    >>> from random import random\n    >>> cells = [[random() for w in range(31)] for h in range(16)]\n    >>> img = generate_image(cells)\n    >>> isinstance(img, Image.Image)\n    True\n    >>> img.width, img.height\n    (31, 16)\n    \"\"\"\n    # Create the output image\n    img = Image.new(\"RGB\", (len(cells[0]), len(cells)))\n    pixels = img.load()\n    # Generates image\n    for w in range(img.width):\n        for h in range(img.height):\n            color = 255 - int(255 * cells[h][w])\n            pixels[w, h] = (color, color, color)\n    return img", "output": "2"}
{"input": "summarize code:\ndef reverse_bit(number: int) -> int:\n    \"\"\"\n    Take in a 32 bit integer, reverse its bits, return a 32 bit integer result\n\n    >>> reverse_bit(25)\n    2550136832\n    >>> reverse_bit(37)\n    2751463424\n    >>> reverse_bit(21)\n    2818572288\n    >>> reverse_bit(58)\n    1543503872\n    >>> reverse_bit(0)\n    0\n    >>> reverse_bit(256)\n    8388608\n    >>> reverse_bit(2550136832)\n    25\n    >>> reverse_bit(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The value of input must be non-negative\n\n    >>> reverse_bit(1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be an 'int' type\n\n    >>> reverse_bit(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be an 'int' type\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Input value must be an 'int' type\")\n    if number < 0:\n        raise ValueError(\"The value of input must be non-negative\")\n\n    result = 0\n    # iterator over [0 to 31], since we are dealing with a 32 bit integer\n    for _ in range(32):\n        # left shift the bits by unity\n        result <<= 1\n        # get the end bit\n        end_bit = number & 1\n        # right shift the bits by unity\n        number >>= 1\n        # add that bit to our answer\n        result |= end_bit\n    return result", "output": "Take in a 32 bit integer, reverse its bits, return a 32 bit integer result"}
{"input": "summarize code:\ndef find_pure_symbols(\n    clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]\n) -> tuple[list[str], dict[str, bool | None]]:\n    \"\"\"\n    | Return pure symbols and their values to satisfy clause.\n    | Pure symbols are symbols in a formula that exist only in one form,\n    | either complemented or otherwise.\n    | For example,\n    |   {{A4 , A3 , A5' , A1 , A3'} , {A4} , {A3}} has pure symbols A4, A5' and A1.\n\n    This has the following steps:\n      1. Ignore clauses that have already evaluated to be ``True``.\n      2. Find symbols that occur only in one form in the rest of the clauses.\n      3. Assign value ``True`` or ``False`` depending on whether the symbols occurs\n         in normal or complemented form respectively.\n\n    >>> formula = Formula([Clause([\"A1\", \"A2'\", \"A3\"]), Clause([\"A5'\", \"A2'\", \"A1\"])])\n    >>> clauses, symbols = generate_parameters(formula)\n    >>> pure_symbols, values = find_pure_symbols(clauses, symbols, {})\n    >>> pure_symbols\n    ['A1', 'A2', 'A3', 'A5']\n    >>> values\n    {'A1': True, 'A2': False, 'A3': True, 'A5': False}\n    \"\"\"\n    pure_symbols = []\n    assignment: dict[str, bool | None] = {}\n    literals = []\n\n    for clause in clauses:\n        if clause.evaluate(model):\n            continue\n        for literal in clause.literals:\n            literals.append(literal)\n\n    for s in symbols:\n        sym = s + \"'\"\n        if (s in literals and sym not in literals) or (\n            s not in literals and sym in literals\n        ):\n            pure_symbols.append(s)\n    for p in pure_symbols:\n        assignment[p] = None\n    for s in pure_symbols:\n        sym = s + \"'\"\n        if s in literals:\n            assignment[s] = True\n        elif sym in literals:\n            assignment[s] = False\n    return pure_symbols, assignment", "output": "| Return pure symbols and their values to satisfy clause. | Pure symbols are symbols in a formula that exist only in one form, | either complemented or otherwise. | For example, | {{A4 , A3 , A5' , A1 , A3'} , {A4} , {A3}} has pure symbols A4, A5' and A1."}
{"input": "search code:\nRemoves size prefix, that compressed file should have Returns the result\nChoices:\n0: def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n1: def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:\n    \"\"\"\n    Returns a triplet in the array with sum equal to target,\n    else (0, 0, 0).\n    >>> triplet_sum2([13, 29, 7, 23, 5], 35)\n    (5, 7, 23)\n    >>> triplet_sum2([37, 9, 19, 50, 44], 65)\n    (9, 19, 37)\n    >>> arr = [6, 47, 27, 1, 15]\n    >>> target = 11\n    >>> triplet_sum2(arr, target)\n    (0, 0, 0)\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n - 1):\n        left, right = i + 1, n - 1\n        while left < right:\n            if arr[i] + arr[left] + arr[right] == target:\n                return (arr[i], arr[left], arr[right])\n            elif arr[i] + arr[left] + arr[right] < target:\n                left += 1\n            elif arr[i] + arr[left] + arr[right] > target:\n                right -= 1\n    return (0, 0, 0)\n2: def remove_prefix(data_bits: str) -> str:\n    \"\"\"\n    Removes size prefix, that compressed file should have\n    Returns the result\n    \"\"\"\n    counter = 0\n    for letter in data_bits:\n        if letter == \"1\":\n            break\n        counter += 1\n\n    data_bits = data_bits[counter:]\n    data_bits = data_bits[counter + 1 :]\n    return data_bits", "output": "2"}
{"input": "search code:\nReturns the next number of the chain by adding the square of each digit to form a new number. For example, if number = 12, next_number() will return 1^2 + 2^2 = 5. Therefore, 5 is the next number of the chain. >>> next_number(44) 32 >>> next_number(10) 1 >>> next_number(32) 13\nChoices:\n0: def get_tolerance(color: str) -> float:\n    \"\"\"\n    Function returns the tolerance value associated with the color.\n    Function takes color as input and returns tolerance value.\n\n    >>> get_tolerance('Green')\n    0.5\n\n    >>> get_tolerance('Indigo')\n    Traceback (most recent call last):\n      ...\n    ValueError: Indigo is not a valid color for tolerance band\n\n    \"\"\"\n    if color not in tolerance_color_values:\n        msg = f\"{color} is not a valid color for tolerance band\"\n        raise ValueError(msg)\n    return tolerance_color_values[color]\n1: def rec_insertion_sort(collection: list, n: int):\n    \"\"\"\n    Given a collection of numbers and its length, sorts the collections\n    in ascending order\n\n    :param collection: A mutable collection of comparable elements\n    :param n: The length of collections\n\n    >>> col = [1, 2, 1]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [1, 1, 2]\n\n    >>> col = [2, 1, 0, -1, -2]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [-2, -1, 0, 1, 2]\n\n    >>> col = [1]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [1]\n    \"\"\"\n    # Checks if the entire collection has been sorted\n    if len(collection) <= 1 or n <= 1:\n        return\n\n    insert_next(collection, n - 1)\n    rec_insertion_sort(collection, n - 1)\n2: def next_number(number: int) -> int:\n    \"\"\"\n    Returns the next number of the chain by adding the square of each digit\n    to form a new number.\n    For example, if number = 12, next_number() will return 1^2 + 2^2 = 5.\n    Therefore, 5 is the next number of the chain.\n    >>> next_number(44)\n    32\n    >>> next_number(10)\n    1\n    >>> next_number(32)\n    13\n    \"\"\"\n\n    sum_of_digits_squared = 0\n    while number:\n        # Increased Speed Slightly by checking every 5 digits together.\n        sum_of_digits_squared += DIGITS_SQUARED[number % 100000]\n        number //= 100000\n\n    return sum_of_digits_squared", "output": "2"}
{"input": "summarize code:\ndef normalize(audio: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Normalize an audio signal by scaling it to have values between -1 and 1.\n\n    Args:\n        audio: The input audio signal.\n\n    Returns:\n        The normalized audio signal.\n\n    Examples:\n    >>> audio = np.array([1, 2, 3, 4, 5])\n    >>> normalized_audio = normalize(audio)\n    >>> float(np.max(normalized_audio))\n    1.0\n    >>> float(np.min(normalized_audio))\n    0.2\n    \"\"\"\n    # Divide the entire audio signal by the maximum absolute value\n    return audio / np.max(np.abs(audio))", "output": "Normalize an audio signal by scaling it to have values between -1 and 1."}
{"input": "search code:\n[summary]\nChoices:\n0: def search_anime_episode_list(episode_endpoint: str) -> list:\n    \"\"\"[summary]\n\n    Take an url and\n    return list of episodes after scraping the site\n    for an url.\n\n    >>> type(search_anime_episode_list(\"/anime/kimetsu-no-yaiba\"))\n    <class 'list'>\n\n    Args:\n        episode_endpoint (str): [Endpoint of episode]\n\n    Raises:\n        e: [description]\n\n    Returns:\n        [list]: [List of episodes]\n    \"\"\"\n\n    request_url = f\"{BASE_URL}{episode_endpoint}\"\n\n    response = httpx.get(\n        url=request_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10\n    )\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    # With this id. get the episode list.\n    episode_page_ul = soup.find(\"ul\", {\"id\": \"episode_related\"})\n    if episode_page_ul is None or isinstance(episode_page_ul, NavigableString):\n        msg = f\"Could not find any anime eposiodes with name {anime_name}\"\n        raise ValueError(msg)\n    episode_page_li = episode_page_ul.children\n\n    episode_list = []\n    for episode in episode_page_li:\n        if isinstance(episode, Tag):\n            url = episode.find(\"a\")\n            if url is None or isinstance(url, NavigableString):\n                continue\n            title = episode.find(\"div\", {\"class\": \"name\"})\n            if title is None or isinstance(title, NavigableString):\n                continue\n\n            episode_list.append(\n                {\"title\": title.text.replace(\" \", \"\"), \"url\": url[\"href\"]}\n            )\n\n    return episode_list\n1: def solution(max_d: int = 12_000) -> int:\n    \"\"\"\n    Returns number of fractions lie between 1/3 and 1/2 in the sorted set\n    of reduced proper fractions for d â‰¤ max_d\n\n    >>> solution(4)\n    0\n\n    >>> solution(5)\n    1\n\n    >>> solution(8)\n    3\n    \"\"\"\n\n    fractions_number = 0\n    for d in range(max_d + 1):\n        n_start = d // 3 + 1\n        n_step = 1\n        if d % 2 == 0:\n            n_start += 1 - n_start % 2\n            n_step = 2\n        for n in range(n_start, (d + 1) // 2, n_step):\n            if gcd(n, d) == 1:\n                fractions_number += 1\n    return fractions_number\n2: def shell_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # Marcin Ciura's gap sequence\n\n    gaps = [701, 301, 132, 57, 23, 10, 4, 1]\n    for gap in gaps:\n        for i in range(gap, len(collection)):\n            insert_value = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > insert_value:\n                collection[j] = collection[j - gap]\n                j -= gap\n            if j != i:\n                collection[j] = insert_value\n    return collection", "output": "0"}
{"input": "summarize code:\ndef longest_subsequence(array: list[int]) -> list[int]:\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 50, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [7, 7]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    n = len(array)\n    # The longest increasing subsequence ending at array[i]\n    longest_increasing_subsequence = []\n    for i in range(n):\n        longest_increasing_subsequence.append([array[i]])\n\n    for i in range(1, n):\n        for prev in range(i):\n            # If array[prev] is less than or equal to array[i], then\n            # longest_increasing_subsequence[prev] + array[i]\n            # is a valid increasing subsequence\n\n            # longest_increasing_subsequence[i] is only set to\n            # longest_increasing_subsequence[prev] + array[i] if the length is longer.\n\n            if array[prev] <= array[i] and len(\n                longest_increasing_subsequence[prev]\n            ) + 1 > len(longest_increasing_subsequence[i]):\n                longest_increasing_subsequence[i] = copy.copy(\n                    longest_increasing_subsequence[prev]\n                )\n                longest_increasing_subsequence[i].append(array[i])\n\n    result: list[int] = []\n    for i in range(n):\n        if len(longest_increasing_subsequence[i]) > len(result):\n            result = longest_increasing_subsequence[i]\n\n    return result", "output": "Some examples"}
{"input": "search code:\nReturns a cipher map given a keyword.\nChoices:\n0: def generate_parenthesis(n: int) -> list[str]:\n    \"\"\"\n    Generate valid combinations of balanced parentheses for a given n.\n\n    :param n: An integer representing the number of pairs of parentheses.\n    :return: A list of strings with valid combinations.\n\n    This function uses a recursive approach to generate the combinations.\n\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\n    Space Complexity: O(n) - where 'n' is the number of pairs.\n\n    Example 1:\n    >>> generate_parenthesis(3)\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Example 2:\n    >>> generate_parenthesis(1)\n    ['()']\n    \"\"\"\n\n    result: list[str] = []\n    backtrack(\"\", 0, 0, n, result)\n    return result\n1: def mae(predict, actual):\n    \"\"\"\n    Examples(rounded for precision):\n    >>> actual = [1,2,3];predict = [1,4,3]\n    >>> float(np.around(mae(predict,actual),decimals = 2))\n    0.67\n\n    >>> actual = [1,1,1];predict = [1,1,1]\n    >>> float(mae(predict,actual))\n    0.0\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = abs(predict - actual)\n    score = difference.mean()\n\n    return score\n2: def create_cipher_map(key: str) -> dict[str, str]:\n    \"\"\"\n    Returns a cipher map given a keyword.\n\n    :param key: keyword to use\n    :return: dictionary cipher map\n    \"\"\"\n    # Create a list of the letters in the alphabet\n    alphabet = [chr(i + 65) for i in range(26)]\n    # Remove duplicate characters from key\n    key = remove_duplicates(key.upper())\n    offset = len(key)\n    # First fill cipher with key characters\n    cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}\n    # Then map remaining characters in alphabet to\n    # the alphabet from the beginning\n    for i in range(len(cipher_alphabet), 26):\n        char = alphabet[i - offset]\n        # Ensure we are not mapping letters to letters previously mapped\n        while char in key:\n            offset -= 1\n            char = alphabet[i - offset]\n        cipher_alphabet[alphabet[i]] = char\n    return cipher_alphabet", "output": "2"}
{"input": "search code:\nFunction to validate initial digits of a given credit card number. >>> valid = \"4111111111111111 41111111111111 34 35 37 412345 523456 634567\" >>> all(validate_initial_digits(cc) for cc in valid.split()) True >>> invalid = \"14 25 76 32323 36111111111111\" >>> all(validate_initial_digits(cc) is False for cc in invalid.split()) True\nChoices:\n0: def combination_with_replacement_index(element, iterable):\n    \"\"\"Equivalent to\n    ``list(combinations_with_replacement(iterable, r)).index(element)``\n\n    The subsequences with repetition of *iterable* that are of length *r* can\n    be ordered lexicographically. :func:`combination_with_replacement_index`\n    computes the index of the first *element*, without computing the previous\n    combinations with replacement.\n\n        >>> combination_with_replacement_index('adf', 'abcdefg')\n        20\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations with replacement of *iterable*.\n    \"\"\"\n    element = tuple(element)\n    l = len(element)\n    element = enumerate(element)\n\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = tuple(iterable)\n    for n, x in enumerate(pool):\n        while x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n        if y is None:\n            break\n    else:\n        raise ValueError(\n            'element is not a combination with replacement of iterable'\n        )\n\n    n = len(pool)\n    occupations = [0] * n\n    for p in indexes:\n        occupations[p] += 1\n\n    index = 0\n    cumulative_sum = 0\n    for k in range(1, n):\n        cumulative_sum += occupations[k - 1]\n        j = l + n - 1 - k - cumulative_sum\n        i = n - k\n        if i <= j:\n            index += comb(j, i)\n\n    return index\n1: def validate_initial_digits(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to validate initial digits of a given credit card number.\n    >>> valid = \"4111111111111111 41111111111111 34 35 37 412345 523456 634567\"\n    >>> all(validate_initial_digits(cc) for cc in valid.split())\n    True\n    >>> invalid = \"14 25 76 32323 36111111111111\"\n    >>> all(validate_initial_digits(cc) is False for cc in invalid.split())\n    True\n    \"\"\"\n    return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))\n2: def prime_sieve(num: int) -> list[int]:\n    \"\"\"\n    Returns a list with all prime numbers up to n.\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    >>> prime_sieve(25)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    >>> prime_sieve(10)\n    [2, 3, 5, 7]\n    >>> prime_sieve(9)\n    [2, 3, 5, 7]\n    >>> prime_sieve(2)\n    [2]\n    >>> prime_sieve(1)\n    []\n    \"\"\"\n\n    if num <= 0:\n        msg = f\"{num}: Invalid input, please enter a positive integer.\"\n        raise ValueError(msg)\n\n    sieve = [True] * (num + 1)\n    prime = []\n    start = 2\n    end = int(math.sqrt(num))\n\n    while start <= end:\n        # If start is a prime\n        if sieve[start] is True:\n            prime.append(start)\n\n            # Set multiples of start be False\n            for i in range(start * start, num + 1, start):\n                if sieve[i] is True:\n                    sieve[i] = False\n\n        start += 1\n\n    for j in range(end + 1, num + 1):\n        if sieve[j] is True:\n            prime.append(j)\n\n    return prime", "output": "1"}
{"input": "search code:\nReturns the number of different ways the number m can be written as a sum of at least two positive integers.\nChoices:\n0: def unzip(iterable):\n    \"\"\"The inverse of :func:`zip`, this function disaggregates the elements\n    of the zipped *iterable*.\n\n    The ``i``-th iterable contains the ``i``-th element from each element\n    of the zipped iterable. The first element is used to determine the\n    length of the remaining elements.\n\n        >>> iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> letters, numbers = unzip(iterable)\n        >>> list(letters)\n        ['a', 'b', 'c', 'd']\n        >>> list(numbers)\n        [1, 2, 3, 4]\n\n    This is similar to using ``zip(*iterable)``, but it avoids reading\n    *iterable* into memory. Note, however, that this function uses\n    :func:`itertools.tee` and thus may require significant storage.\n\n    \"\"\"\n    head, iterable = spy(iterable)\n    if not head:\n        # empty iterable, e.g. zip([], [], [])\n        return ()\n    # spy returns a one-length iterable as head\n    head = head[0]\n    iterables = tee(iterable, len(head))\n\n    # If we have an iterable like iter([(1, 2, 3), (4, 5), (6,)]),\n    # the second unzipped iterable fails at the third tuple since\n    # it tries to access (6,)[1].\n    # Same with the third unzipped iterable and the second tuple.\n    # To support these \"improperly zipped\" iterables, we suppress\n    # the IndexError, which just stops the unzipped iterables at\n    # first length mismatch.\n    return tuple(\n        iter_suppress(map(itemgetter(i), it), IndexError)\n        for i, it in enumerate(iterables)\n    )\n1: def log_difference(number: int) -> float:\n    \"\"\"\n    This function returns the decimal value of a number multiplied with log(2)\n    Since the problem is on powers of two, finding the powers of two with\n    large exponents is time consuming. Hence we use log to reduce compute time.\n\n    We can find out that the first power of 2 with starting digits 123 is 90.\n    Computing 2^90 is time consuming.\n    Hence we find log(2^90) = 90*log(2) = 27.092699609758302\n    But we require only the decimal part to determine whether the power starts with 123.\n    So we just return the decimal part of the log product.\n    Therefore we return 0.092699609758302\n\n    >>> log_difference(90)\n    0.092699609758302\n    >>> log_difference(379)\n    0.090368356648852\n\n    \"\"\"\n\n    log_number = math.log(2, 10) * number\n    difference = round((log_number - int(log_number)), 15)\n\n    return difference\n2: def solution(m: int = 100) -> int:\n    \"\"\"\n    Returns the number of different ways the number m can be written as a\n    sum of at least two positive integers.\n\n    >>> solution(100)\n    190569291\n    >>> solution(50)\n    204225\n    >>> solution(30)\n    5603\n    >>> solution(10)\n    41\n    >>> solution(5)\n    6\n    >>> solution(3)\n    2\n    >>> solution(2)\n    1\n    >>> solution(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1", "output": "2"}
{"input": "summarize code:\ndef interquartile_range_checker(train_user: list) -> float:\n    \"\"\"\n    Optional method: interquatile range\n    input : list of total user in float\n    output : low limit of input in float\n    this method can be used to check whether some data is outlier or not\n    >>> interquartile_range_checker([1,2,3,4,5,6,7,8,9,10])\n    2.8\n    \"\"\"\n    train_user.sort()\n    q1 = np.percentile(train_user, 25)\n    q3 = np.percentile(train_user, 75)\n    iqr = q3 - q1\n    low_lim = q1 - (iqr * 0.1)\n    return float(low_lim)", "output": "Optional method: interquatile range input : list of total user in float output : low limit of input in float this method can be used to check whether some data is outlier or not >>> interquartile_range_checker([1,2,3,4,5,6,7,8,9,10]) 2.8"}
{"input": "summarize code:\ndef swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:\n    \"\"\"\n    Parameters:\n        vector (np.ndarray): A  numpy array consisting of real values\n        trainable_parameter: Use to implement various Swish Activation Functions\n\n    Returns:\n        swish_vec (np.ndarray): The input numpy array, after applying swish\n\n    Examples:\n    >>> swish(np.array([-1.0, 1.0, 2.0]), 2)\n    array([-0.11920292,  0.88079708,  1.96402758])\n\n    >>> swish(np.array([-2]), 1)\n    array([-0.23840584])\n    \"\"\"\n    return vector * sigmoid(trainable_parameter * vector)", "output": "Parameters: vector (np.ndarray): A numpy array consisting of real values trainable_parameter: Use to implement various Swish Activation Functions"}
{"input": "summarize code:\ndef right_rotation(node: MyNode) -> MyNode:\n    r\"\"\"\n            A                      B\n           / \\                    / \\\n          B   C                  Bl  A\n         / \\       -->          /   / \\\n        Bl  Br                 UB Br  C\n       /\n     UB\n    UB = unbalanced node\n    \"\"\"\n    print(\"left rotation node:\", node.get_data())\n    ret = node.get_left()\n    assert ret is not None\n    node.set_left(ret.get_right())\n    ret.set_right(node)\n    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1\n    node.set_height(h1)\n    h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1\n    ret.set_height(h2)\n    return ret", "output": "A B / \\ / \\ B C Bl A / \\ --> / / \\ Bl Br UB Br C / UB UB = unbalanced node"}
{"input": "summarize code:\ndef sort(array: list) -> list:\n    \"\"\"\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n    >>> sort([-1, -5, -3, -13, -44])\n    [-44, -13, -5, -3, -1]\n    >>> sort([])\n    []\n    >>> sort([5])\n    [5]\n    >>> sort([-3, 0, -7, 6, 23, -34])\n    [-34, -7, -3, 0, 6, 23]\n    >>> sort([1.7, 1.0, 3.3, 2.1, 0.3 ])\n    [0.3, 1.0, 1.7, 2.1, 3.3]\n    >>> sort(['d', 'a', 'b', 'e', 'c'])\n    ['a', 'b', 'c', 'd', 'e']\n    \"\"\"\n    if len(array) == 0:\n        return array\n    max_depth = 2 * math.ceil(math.log2(len(array)))\n    size_threshold = 16\n    return intro_sort(array, 0, len(array), size_threshold, max_depth)", "output": ":param collection: some mutable ordered collection with heterogeneous comparable items inside :return: the same collection ordered by ascending"}
{"input": "search code:\nReturn ``True`` if all given *iterables* are equal to each other, which means that they contain the same elements in the same order.\nChoices:\n0: def calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)\n1: def iequals(*iterables):\n    \"\"\"Return ``True`` if all given *iterables* are equal to each other,\n    which means that they contain the same elements in the same order.\n\n    The function is useful for comparing iterables of different data types\n    or iterables that do not support equality checks.\n\n    >>> iequals(\"abc\", ['a', 'b', 'c'], ('a', 'b', 'c'), iter(\"abc\"))\n    True\n\n    >>> iequals(\"abc\", \"acb\")\n    False\n\n    Not to be confused with :func:`all_equal`, which checks whether all\n    elements of iterable are equal to each other.\n\n    \"\"\"\n    try:\n        return all(map(all_equal, zip(*iterables, strict=True)))\n    except ValueError:\n        return False\n2: def get_nodes_from_right_to_left(root: Node | None, level: int) -> Generator[int]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    >>> list(get_nodes_from_right_to_left(make_tree(), 1))\n    [1]\n    >>> list(get_nodes_from_right_to_left(make_tree(), 2))\n    [3, 2]\n    \"\"\"\n\n    def populate_output(root: Node | None, level: int) -> Generator[int]:\n        if not root:\n            return\n        if level == 1:\n            yield root.data\n        elif level > 1:\n            yield from populate_output(root.right, level - 1)\n            yield from populate_output(root.left, level - 1)\n\n    yield from populate_output(root, level)", "output": "1"}
{"input": "summarize code:\ndef _running_median_minheap_only(iterator):  # pragma: no cover\n    \"Backport of non-windowed running_median() for Python 3.13 and prior.\"\n\n    read = iterator.__next__\n    lo = []  # max-heap (actually a minheap with negated values)\n    hi = []  # min-heap (same size as or one smaller than lo)\n\n    with suppress(StopIteration):\n        while True:\n            heappush(lo, -heappushpop(hi, read()))\n            yield -lo[0]\n\n            heappush(hi, -heappushpop(lo, -read()))\n            yield (hi[0] - lo[0]) / 2", "output": "Backport of non-windowed running_median() for Python 3.13 and prior."}
{"input": "summarize code:\ndef build_tree(letters: list[Letter]) -> Letter | TreeNode:\n    \"\"\"\n    Run through the list of Letters and build the min heap\n    for the Huffman Tree.\n    \"\"\"\n    response: list[Letter | TreeNode] = list(letters)\n    while len(response) > 1:\n        left = response.pop(0)\n        right = response.pop(0)\n        total_freq = left.freq + right.freq\n        node = TreeNode(total_freq, left, right)\n        response.append(node)\n        response.sort(key=lambda x: x.freq)\n    return response[0]", "output": "Run through the list of Letters and build the min heap for the Huffman Tree."}
{"input": "search code:\nReturn the largest 1 to 9 pandigital 9-digital number that can be formed as the concatenated product of an integer with (1,2,...,n) where n > 1.\nChoices:\n0: def solution() -> int | None:\n    \"\"\"\n    Return the largest 1 to 9 pandigital 9-digital number that can be formed as the\n    concatenated product of an integer with (1,2,...,n) where n > 1.\n    \"\"\"\n    for base_num in range(9999, 4999, -1):\n        candidate = 100002 * base_num\n        if is_9_pandigital(candidate):\n            return candidate\n\n    for base_num in range(333, 99, -1):\n        candidate = 1002003 * base_num\n        if is_9_pandigital(candidate):\n            return candidate\n\n    return None\n1: def get_forbes_real_time_billionaires() -> list[dict[str, int | str]]:\n    \"\"\"\n    Get the top 10 real-time billionaires using Forbes API.\n\n    Returns:\n        List of top 10 realtime billionaires data.\n    \"\"\"\n    response_json = httpx.get(API_URL, timeout=10).json()\n    return [\n        {\n            \"Name\": person[\"personName\"],\n            \"Source\": person[\"source\"],\n            \"Country\": person[\"countryOfCitizenship\"],\n            \"Gender\": person[\"gender\"],\n            \"Worth ($)\": f\"{person['finalWorth'] / 1000:.1f} Billion\",\n            \"Age\": str(years_old(person[\"birthDate\"] / 1000)),\n        }\n        for person in response_json[\"personList\"][\"personsLists\"]\n    ]\n2: def world_covid19_stats(\n    url: str = \"https://www.worldometers.info/coronavirus/\",\n) -> dict:\n    \"\"\"\n    Return a dict of current worldwide COVID-19 statistics\n    \"\"\"\n    soup = BeautifulSoup(\n        httpx.get(url, timeout=10, follow_redirects=True).text, \"html.parser\"\n    )\n    keys = soup.find_all(\"h1\")\n    values = soup.find_all(\"div\", {\"class\": \"maincounter-number\"})\n    keys += soup.find_all(\"span\", {\"class\": \"panel-title\"})\n    values += soup.find_all(\"div\", {\"class\": \"number-table-main\"})\n    return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}", "output": "0"}
{"input": "search code:\nReturns the count of all lychrel numbers below limit. >>> solution(10000) 249 >>> solution(5000) 76 >>> solution(1000) 13\nChoices:\n0: def solution(limit: int = 10000) -> int:\n    \"\"\"\n    Returns the count of all lychrel numbers below limit.\n    >>> solution(10000)\n    249\n    >>> solution(5000)\n    76\n    >>> solution(1000)\n    13\n    \"\"\"\n    lychrel_nums = []\n    for num in range(1, limit):\n        iterations = 0\n        a = num\n        while iterations < 50:\n            num = sum_reverse(num)\n            iterations += 1\n            if is_palindrome(num):\n                break\n        else:\n            lychrel_nums.append(a)\n    return len(lychrel_nums)\n1: def _abs_timedelta(delta):\n    \"\"\"Return an \"absolute\" value for a timedelta, always representing a time distance.\n\n    Args:\n        delta (datetime.timedelta): Input timedelta.\n\n    Returns:\n        datetime.timedelta: Absolute timedelta.\n    \"\"\"\n    if delta.days < 0:\n        now = _now()\n        return now - (now + delta)\n    return delta\n2: def solution(num: int = 100) -> int:\n    \"\"\"Returns the sum of the digits in the factorial of num\n    >>> solution(100)\n    648\n    >>> solution(50)\n    216\n    >>> solution(10)\n    27\n    >>> solution(5)\n    3\n    >>> solution(3)\n    6\n    >>> solution(2)\n    2\n    >>> solution(1)\n    1\n    \"\"\"\n    nfact = factorial(num)\n    result = split_and_add(nfact)\n    return result", "output": "0"}
{"input": "summarize code:\ndef unique_everseen(iterable, key=None):\n    \"\"\"\n    Yield unique elements, preserving order.\n\n        >>> list(unique_everseen('AAAABBBCCDAABBB'))\n        ['A', 'B', 'C', 'D']\n        >>> list(unique_everseen('ABBCcAD', str.lower))\n        ['A', 'B', 'C', 'D']\n\n    Sequences with a mix of hashable and unhashable items can be used.\n    The function will be slower (i.e., `O(n^2)`) for unhashable items.\n\n    Remember that ``list`` objects are unhashable - you can use the *key*\n    parameter to transform the list to a tuple (which is hashable) to\n    avoid a slowdown.\n\n        >>> iterable = ([1, 2], [2, 3], [1, 2])\n        >>> list(unique_everseen(iterable))  # Slow\n        [[1, 2], [2, 3]]\n        >>> list(unique_everseen(iterable, key=tuple))  # Faster\n        [[1, 2], [2, 3]]\n\n    Similarly, you may want to convert unhashable ``set`` objects with\n    ``key=frozenset``. For ``dict`` objects,\n    ``key=lambda x: frozenset(x.items())`` can be used.\n\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seenset:\n                seenset_add(k)\n                yield element\n        except TypeError:\n            if k not in seenlist:\n                seenlist_add(k)\n                yield element", "output": "Yield unique elements, preserving order."}
{"input": "search code:\nPrecompute range minimum queries with power of two length and store the precomputed values in a table.\nChoices:\n0: def build_sparse_table(number_list: list[int]) -> list[list[int]]:\n    \"\"\"\n    Precompute range minimum queries with power of two length and store the precomputed\n    values in a table.\n\n    >>> build_sparse_table([8, 1, 0, 3, 4, 9, 3])\n    [[8, 1, 0, 3, 4, 9, 3], [1, 0, 0, 3, 4, 3, 0], [0, 0, 0, 3, 0, 0, 0]]\n    >>> build_sparse_table([3, 1, 9])\n    [[3, 1, 9], [1, 1, 0]]\n    >>> build_sparse_table([])\n    Traceback (most recent call last):\n    ...\n    ValueError: empty number list not allowed\n    \"\"\"\n    if not number_list:\n        raise ValueError(\"empty number list not allowed\")\n\n    length = len(number_list)\n    # Initialise sparse_table -- sparse_table[j][i] represents the minimum value of the\n    # subset of length (2 ** j) of number_list, starting from index i.\n\n    # smallest power of 2 subset length that fully covers number_list\n    row = int(log2(length)) + 1\n    sparse_table = [[0 for i in range(length)] for j in range(row)]\n\n    # minimum of subset of length 1 is that value itself\n    for i, value in enumerate(number_list):\n        sparse_table[0][i] = value\n    j = 1\n\n    # compute the minimum value for all intervals with size (2 ** j)\n    while (1 << j) <= length:\n        i = 0\n        # while subset starting from i still have at least (2 ** j) elements\n        while (i + (1 << j) - 1) < length:\n            # split range [i, i + 2 ** j] and find minimum of 2 halves\n            sparse_table[j][i] = min(\n                sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]\n            )\n            i += 1\n        j += 1\n    return sparse_table\n1: def display(values):\n    \"\"\"\n    Display these values as a 2-D grid.\n    \"\"\"\n    width = 1 + max(len(values[s]) for s in squares)\n    line = \"+\".join([\"-\" * (width * 3)] * 3)\n    for r in rows:\n        print(\n            \"\".join(\n                values[r + c].center(width) + (\"|\" if c in \"36\" else \"\") for c in cols\n            )\n        )\n        if r in \"CF\":\n            print(line)\n    print()\n2: def adler32(plain_text: str) -> int:\n    \"\"\"\n    Function implements adler-32 hash.\n    Iterates and evaluates a new value for each character\n\n    >>> adler32('Algorithms')\n    363791387\n\n    >>> adler32('go adler em all')\n    708642122\n    \"\"\"\n    a = 1\n    b = 0\n    for plain_chr in plain_text:\n        a = (a + ord(plain_chr)) % MOD_ADLER\n        b = (b + a) % MOD_ADLER\n    return (b << 16) | a", "output": "0"}
{"input": "search code:\nArbitrary index order, greedily consumed\nChoices:\n0: def solution(nth: int = 10001) -> int:\n    \"\"\"\n    Returns the n-th prime number.\n\n    >>> solution(6)\n    13\n    >>> solution(1)\n    2\n    >>> solution(3)\n    5\n    >>> solution(20)\n    71\n    >>> solution(50)\n    229\n    >>> solution(100)\n    541\n    \"\"\"\n\n    count = 0\n    number = 1\n    while count != nth and number < 3:\n        number += 1\n        if is_prime(number):\n            count += 1\n    while count != nth:\n        number += 2\n        if is_prime(number):\n            count += 1\n    return number\n1: def _shift_to_odd(n):\n    'Return s, d such that 2**s * d == n'\n    s = ((n - 1) ^ n).bit_length() - 1\n    d = n >> s\n    assert (1 << s) * d == n and d & 1 and s >= 0\n    return s, d\n2: def _extract_buffered(iterator, index_and_position):\n    'Arbitrary index order, greedily consumed'\n    buffer = {}\n    iterator_position = -1\n    next_to_emit = 0\n\n    for index, order in index_and_position:\n        advance = index - iterator_position\n        if advance:\n            try:\n                value = next(islice(iterator, advance - 1, None))\n            except StopIteration:\n                raise IndexError(index) from None\n            iterator_position = index\n\n        buffer[order] = value\n\n        while next_to_emit in buffer:\n            yield buffer.pop(next_to_emit)\n            next_to_emit += 1", "output": "2"}
{"input": "search code:\nGenerates all possible combinations of k numbers out of 1 ... n using backtracking.\nChoices:\n0: def split_punct_ws(text):\n    \"\"\"While :meth:`str.split` will split on whitespace,\n    :func:`split_punct_ws` will split on punctuation and\n    whitespace. This used internally by :func:`slugify`, above.\n\n    >>> split_punct_ws('First post! Hi!!!!~1    ')\n    ['First', 'post', 'Hi', '1']\n    \"\"\"\n    return [w for w in _punct_re.split(text) if w]\n1: def _running_median_minheap_only(iterator):  # pragma: no cover\n    \"Backport of non-windowed running_median() for Python 3.13 and prior.\"\n\n    read = iterator.__next__\n    lo = []  # max-heap (actually a minheap with negated values)\n    hi = []  # min-heap (same size as or one smaller than lo)\n\n    with suppress(StopIteration):\n        while True:\n            heappush(lo, -heappushpop(hi, read()))\n            yield -lo[0]\n\n            heappush(hi, -heappushpop(lo, -read()))\n            yield (hi[0] - lo[0]) / 2\n2: def generate_all_combinations(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    Generates all possible combinations of k numbers out of 1 ... n using backtracking.\n\n    >>> generate_all_combinations(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    >>> generate_all_combinations(n=0, k=0)\n    [[]]\n    >>> generate_all_combinations(n=10, k=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: k must not be negative\n    >>> generate_all_combinations(n=-1, k=10)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must not be negative\n    >>> generate_all_combinations(n=5, k=4)\n    [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]\n    >>> generate_all_combinations(n=3, k=3)\n    [[1, 2, 3]]\n    >>> generate_all_combinations(n=3, k=1)\n    [[1], [2], [3]]\n    >>> generate_all_combinations(n=1, k=0)\n    [[]]\n    >>> generate_all_combinations(n=1, k=1)\n    [[1]]\n    >>> from itertools import combinations\n    >>> all(generate_all_combinations(n, k) == combination_lists(n, k)\n    ...     for n in range(1, 6) for k in range(1, 6))\n    True\n    \"\"\"\n    if k < 0:\n        raise ValueError(\"k must not be negative\")\n    if n < 0:\n        raise ValueError(\"n must not be negative\")\n\n    result: list[list[int]] = []\n    create_all_state(1, n, k, [], result)\n    return result", "output": "2"}
{"input": "summarize code:\ndef split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n\n    >>> split(\";abbb;;c;\", separator=';')\n    ['', 'abbb', '', 'c', '']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "Will split the string up into all the values separated by the separator (defaults to spaces)"}
{"input": "search code:\nReturns the hash key of matrix indexes.\nChoices:\n0: def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column\n1: def make_linked_list(elements_list: list | tuple) -> Node:\n    \"\"\"\n    Creates a Linked List from the elements of the given sequence\n    (list/tuple) and returns the head of the Linked List.\n\n    >>> make_linked_list([])\n    Traceback (most recent call last):\n        ...\n    ValueError: The Elements List is empty\n    >>> make_linked_list(())\n    Traceback (most recent call last):\n        ...\n    ValueError: The Elements List is empty\n    >>> make_linked_list([1])\n    <1> ---> <END>\n    >>> make_linked_list((1,))\n    <1> ---> <END>\n    >>> make_linked_list([1, 3, 5, 32, 44, 12, 43])\n    <1> ---> <3> ---> <5> ---> <32> ---> <44> ---> <12> ---> <43> ---> <END>\n    >>> make_linked_list((1, 3, 5, 32, 44, 12, 43))\n    <1> ---> <3> ---> <5> ---> <32> ---> <44> ---> <12> ---> <43> ---> <END>\n    \"\"\"\n\n    # if elements_list is empty\n    if not elements_list:\n        raise ValueError(\"The Elements List is empty\")\n\n    # Set first element as Head\n    head = Node(elements_list[0])\n    current = head\n    # Loop through elements from position 1\n    for data in elements_list[1:]:\n        current.next = Node(data)\n        current = current.next\n    return head\n2: def solution(n: int = 600851475143) -> int:\n    \"\"\"\n    Returns the largest prime factor of a given number n.\n\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    i = 2\n    ans = 0\n    if n == 2:\n        return 2\n    while n > 2:\n        while n % i != 0:\n            i += 1\n        ans = i\n        while n % i == 0:\n            n = n // i\n        i += 1\n    return int(ans)", "output": "0"}
{"input": "search code:\nReturn the number of reduced proper fractions with denominator less than limit. >>> solution(8) 21 >>> solution(1000) 304191\nChoices:\n0: def polynomial_from_roots(roots):\n    \"\"\"Compute a polynomial's coefficients from its roots.\n\n    >>> roots = [5, -4, 3]            # (x - 5) * (x + 4) * (x - 3)\n    >>> polynomial_from_roots(roots)  # xÂ³ - 4 xÂ² - 17 x + 60\n    [1, -4, -17, 60]\n\n    Note that polynomial coefficients are specified in descending power order.\n\n    Supports all numeric types: int, float, complex, Decimal, Fraction.\n    \"\"\"\n\n    # This recipe differs from the one in itertools docs in that it\n    # applies list() after each call to convolve().  This avoids\n    # hitting stack limits with nested generators.\n\n    poly = [1]\n    for root in roots:\n        poly = list(convolve(poly, (1, -root)))\n    return poly\n1: def solution(limit: int = 1000000) -> int:\n    \"\"\"\n    Return the number of reduced proper fractions with denominator less than limit.\n    >>> solution(8)\n    21\n    >>> solution(1000)\n    304191\n    \"\"\"\n    primes = set(range(3, limit, 2))\n    primes.add(2)\n    for p in range(3, limit, 2):\n        if p not in primes:\n            continue\n        primes.difference_update(set(range(p * p, limit, p)))\n\n    phi = [float(n) for n in range(limit + 1)]\n\n    for p in primes:\n        for n in range(p, limit + 1, p):\n            phi[n] *= 1 - 1 / p\n\n    return int(sum(phi[2:]))\n2: def add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first", "output": "1"}
{"input": "summarize code:\ndef pressure_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between pressure units.\n    >>> pressure_conversion(4, \"atm\", \"pascal\")\n    405300\n    >>> pressure_conversion(1, \"pascal\", \"psi\")\n    0.00014401981999999998\n    >>> pressure_conversion(1, \"bar\", \"atm\")\n    0.986923\n    >>> pressure_conversion(3, \"kilopascal\", \"bar\")\n    0.029999991892499998\n    >>> pressure_conversion(2, \"megapascal\", \"psi\")\n    290.074434314\n    >>> pressure_conversion(4, \"psi\", \"torr\")\n    206.85984\n    >>> pressure_conversion(1, \"inHg\", \"atm\")\n    0.0334211\n    >>> pressure_conversion(1, \"torr\", \"psi\")\n    0.019336718261000002\n    >>> pressure_conversion(4, \"wrongUnit\", \"atm\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\n    atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr\n    \"\"\"\n    if from_type not in PRESSURE_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"\n            + \", \".join(PRESSURE_CONVERSION)\n        )\n    if to_type not in PRESSURE_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"\n            + \", \".join(PRESSURE_CONVERSION)\n        )\n    return (\n        value\n        * PRESSURE_CONVERSION[from_type].from_factor\n        * PRESSURE_CONVERSION[to_type].to_factor\n    )", "output": "Conversion between pressure units. >>> pressure_conversion(4, \"atm\", \"pascal\") 405300 >>> pressure_conversion(1, \"pascal\", \"psi\") 0.00014401981999999998 >>> pressure_conversion(1, \"bar\", \"atm\") 0.986923 >>> pressure_conversion(3, \"kilopascal\", \"bar\") 0.029999991892499998 >>> pressure_conversion(2, \"megapascal\", \"psi\") 290.074434314 >>> pressure_conversion(4, \"psi\", \"torr\") 206.85984 >>> pressure_conversion(1, \"inHg\", \"atm\") 0.0334211 >>> pressure_conversion(1, \"torr\", \"psi\") 0.019336718261000002 >>> pressure_conversion(4, \"wrongUnit\", \"atm\") Traceback (most recent call last): ... ValueError: Invalid 'from_type' value: 'wrongUnit' Supported values are: atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr"}
{"input": "summarize code:\ndef convert_small_number(num: int) -> str:\n    \"\"\"\n    Converts small, non-negative integers with irregular constructions in English (i.e.,\n    numbers under 100) into words.\n\n    >>> convert_small_number(0)\n    'zero'\n    >>> convert_small_number(5)\n    'five'\n    >>> convert_small_number(10)\n    'ten'\n    >>> convert_small_number(15)\n    'fifteen'\n    >>> convert_small_number(20)\n    'twenty'\n    >>> convert_small_number(25)\n    'twenty-five'\n    >>> convert_small_number(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: This function only accepts non-negative integers\n    >>> convert_small_number(123)\n    Traceback (most recent call last):\n    ...\n    ValueError: This function only converts numbers less than 100\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"This function only accepts non-negative integers\")\n    if num >= 100:\n        raise ValueError(\"This function only converts numbers less than 100\")\n    tens, ones = divmod(num, 10)\n    if tens == 0:\n        return NumberWords.ONES.value[ones] or \"zero\"\n    if tens == 1:\n        return NumberWords.TEENS.value[ones]\n    return (\n        NumberWords.TENS.value[tens]\n        + (\"-\" if NumberWords.ONES.value[ones] else \"\")\n        + NumberWords.ONES.value[ones]\n    )", "output": "Converts small, non-negative integers with irregular constructions in English (i.e., numbers under 100) into words."}
{"input": "summarize code:\ndef inverse_document_frequency(df: int, n: int, smoothing=False) -> float:\n    \"\"\"\n    Return an integer denoting the importance\n    of a word. This measure of importance is\n    calculated by log10(N/df), where N is the\n    number of documents and df is\n    the Document Frequency.\n    @params : df, the Document Frequency, N,\n    the number of documents in the corpus and\n    smoothing, if True return the idf-smooth\n    @returns : log10(N/df) or 1+log10(N/1+df)\n    @examples :\n    >>> inverse_document_frequency(3, 0)\n    Traceback (most recent call last):\n     ...\n    ValueError: log10(0) is undefined.\n    >>> inverse_document_frequency(1, 3)\n    0.477\n    >>> inverse_document_frequency(0, 3)\n    Traceback (most recent call last):\n     ...\n    ZeroDivisionError: df must be > 0\n    >>> inverse_document_frequency(0, 3,True)\n    1.477\n    \"\"\"\n    if smoothing:\n        if n == 0:\n            raise ValueError(\"log10(0) is undefined.\")\n        return round(1 + log10(n / (1 + df)), 3)\n\n    if df == 0:\n        raise ZeroDivisionError(\"df must be > 0\")\n    elif n == 0:\n        raise ValueError(\"log10(0) is undefined.\")\n    return round(log10(n / df), 3)", "output": "Return an integer denoting the importance of a word. This measure of importance is calculated by log10(N/df), where N is the number of documents and df is the Document Frequency. @params : df, the Document Frequency, N, the number of documents in the corpus and smoothing, if True return the idf-smooth @returns : log10(N/df) or 1+log10(N/1+df) @examples : >>> inverse_document_frequency(3, 0) Traceback (most recent call last): ... ValueError: log10(0) is undefined. >>> inverse_document_frequency(1, 3) 0.477 >>> inverse_document_frequency(0, 3) Traceback (most recent call last): ... ZeroDivisionError: df must be > 0 >>> inverse_document_frequency(0, 3,True) 1.477"}
{"input": "search code:\nYield duplicate elements after their first appearance.\nChoices:\n0: def duplicates_everseen(iterable, key=None):\n    \"\"\"Yield duplicate elements after their first appearance.\n\n    >>> list(duplicates_everseen('mississippi'))\n    ['s', 'i', 's', 's', 'i', 'p', 'i']\n    >>> list(duplicates_everseen('AaaBbbCccAaa', str.lower))\n    ['a', 'a', 'b', 'b', 'c', 'c', 'A', 'a', 'a']\n\n    This function is analogous to :func:`unique_everseen` and is subject to\n    the same performance considerations.\n\n    \"\"\"\n    seen_set = set()\n    seen_list = []\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seen_set:\n                seen_set.add(k)\n            else:\n                yield element\n        except TypeError:\n            if k not in seen_list:\n                seen_list.append(k)\n            else:\n                yield element\n1: def is_palindrome_stack(head: ListNode | None) -> bool:\n    \"\"\"\n    Check if a linked list is a palindrome using a stack.\n\n    Args:\n        head (ListNode): The head of the linked list.\n\n    Returns:\n        bool: True if the linked list is a palindrome, False otherwise.\n\n    Examples:\n        >>> is_palindrome_stack(None)\n        True\n\n        >>> is_palindrome_stack(ListNode(1))\n        True\n\n        >>> is_palindrome_stack(ListNode(1, ListNode(2)))\n        False\n\n        >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(1))))\n        True\n\n        >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))\n        True\n    \"\"\"\n    if not head or not head.next_node:\n        return True\n\n    # 1. Get the midpoint (slow)\n    slow: ListNode | None = head\n    fast: ListNode | None = head\n    while fast and fast.next_node:\n        fast = fast.next_node.next_node\n        slow = slow.next_node if slow else None\n\n    # slow will always be defined,\n    # adding this check to resolve mypy static check\n    if slow:\n        stack = [slow.val]\n\n        # 2. Push the second half into the stack\n        while slow.next_node:\n            slow = slow.next_node\n            stack.append(slow.val)\n\n        # 3. Comparison\n        cur: ListNode | None = head\n        while stack and cur:\n            if stack.pop() != cur.val:\n                return False\n            cur = cur.next_node\n\n    return True\n2: def breadth_first_search(graph: dict, start: str) -> list[str]:\n    \"\"\"\n    Implementation of breadth first search using queue.Queue.\n\n    >>> ''.join(breadth_first_search(G, 'A'))\n    'ABCDEF'\n    \"\"\"\n    explored = {start}\n    result = [start]\n    queue: Queue = Queue()\n    queue.put(start)\n    while not queue.empty():\n        v = queue.get()\n        for w in graph[v]:\n            if w not in explored:\n                explored.add(w)\n                result.append(w)\n                queue.put(w)\n    return result", "output": "0"}
{"input": "search code:\nReturns a list of nodes value from a whole binary tree in Level Order Traverse. Level Order traverse: Visit nodes of the tree level-by-level. >>> list(level_order(make_tree())) [1, 2, 3, 4, 5]\nChoices:\n0: def my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:\n    \"\"\"\n    :param src: the source image, which should be a grayscale or color image.\n    :param ksize: the size of the kernel used to compute the Laplacian filter,\n                  which can be 1, 3, 5, or 7.\n\n    >>> my_laplacian(src=np.array([]), ksize=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: ksize must be in (1, 3, 5, 7)\n    \"\"\"\n    kernels = {\n        1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),\n        3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),\n        5: np.array(\n            [\n                [0, 0, -1, 0, 0],\n                [0, -1, -2, -1, 0],\n                [-1, -2, 16, -2, -1],\n                [0, -1, -2, -1, 0],\n                [0, 0, -1, 0, 0],\n            ]\n        ),\n        7: np.array(\n            [\n                [0, 0, 0, -1, 0, 0, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, -2, -7, -10, -7, -2, 0],\n                [-1, -3, -10, 68, -10, -3, -1],\n                [0, -2, -7, -10, -7, -2, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, 0, 0, -1, 0, 0, 0],\n            ]\n        ),\n    }\n    if ksize not in kernels:\n        msg = f\"ksize must be in {tuple(kernels)}\"\n        raise ValueError(msg)\n\n    # Apply the Laplacian kernel using convolution\n    return filter2D(\n        src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)\n    )\n1: def level_order(root: Node | None) -> Generator[int]:\n    \"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    >>> list(level_order(make_tree()))\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    if root is None:\n        return\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        yield node.data\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)\n2: def pairwise_iter(src, end=_UNSET):\n    \"\"\"Convenience function for calling :func:`windowed_iter` on *src*,\n    with *size* set to 2.\n\n    >>> list(pairwise_iter(range(5)))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n    >>> list(pairwise_iter([]))\n    []\n\n    Unless *end* is set, the number of pairs is always one less \n    than the number of elements in the iterable passed in, \n    or zero, when *src* is empty.\n\n    With *end* set, a number of pairs equal to the length of *src* is returned,\n    with the last item of the last pair being equal to *end*. \n\n    >>> list(pairwise_iter(range(3), end=None))\n    [(0, 1), (1, 2), (2, None)]    \n\n    This way, *end* values can be useful as sentinels to signal the end\n    of the iterable. For infinite iterators, setting *end* has no effect.\n    \"\"\"\n    return windowed_iter(src, 2, fill=end)", "output": "1"}
{"input": "summarize code:\ndef generate_pascal_triangle(num_rows: int) -> list[list[int]]:\n    \"\"\"\n    Create Pascal's triangle for different number of rows\n    >>> generate_pascal_triangle(0)\n    []\n    >>> generate_pascal_triangle(1)\n    [[1]]\n    >>> generate_pascal_triangle(2)\n    [[1], [1, 1]]\n    >>> generate_pascal_triangle(3)\n    [[1], [1, 1], [1, 2, 1]]\n    >>> generate_pascal_triangle(4)\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]\n    >>> generate_pascal_triangle(5)\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    >>> generate_pascal_triangle(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value of 'num_rows' should be greater than or equal to 0\n    >>> generate_pascal_triangle(7.89)\n    Traceback (most recent call last):\n        ...\n    TypeError: The input value of 'num_rows' should be 'int'\n    \"\"\"\n\n    if not isinstance(num_rows, int):\n        raise TypeError(\"The input value of 'num_rows' should be 'int'\")\n\n    if num_rows == 0:\n        return []\n    elif num_rows < 0:\n        raise ValueError(\n            \"The input value of 'num_rows' should be greater than or equal to 0\"\n        )\n\n    triangle: list[list[int]] = []\n    for current_row_idx in range(num_rows):\n        current_row = populate_current_row(triangle, current_row_idx)\n        triangle.append(current_row)\n    return triangle", "output": "Create Pascal's triangle for different number of rows >>> generate_pascal_triangle(0) [] >>> generate_pascal_triangle(1) [[1]] >>> generate_pascal_triangle(2) [[1], [1, 1]] >>> generate_pascal_triangle(3) [[1], [1, 1], [1, 2, 1]] >>> generate_pascal_triangle(4) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] >>> generate_pascal_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> generate_pascal_triangle(-5) Traceback (most recent call last): ... ValueError: The input value of 'num_rows' should be greater than or equal to 0 >>> generate_pascal_triangle(7.89) Traceback (most recent call last): ... TypeError: The input value of 'num_rows' should be 'int'"}
{"input": "search code:\nRecursive function for calculating the height of the binary tree. >>> height(None) 0 >>> height(make_tree()) 3\nChoices:\n0: def choose(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n    >>> choose(4,2)\n    6\n    >>> choose(5,3)\n    10\n    >>> choose(20,6)\n    38760\n    \"\"\"\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)\n1: def height(root: Node | None) -> int:\n    \"\"\"\n    Recursive function for calculating the height of the binary tree.\n    >>> height(None)\n    0\n    >>> height(make_tree())\n    3\n    \"\"\"\n    return (max(height(root.left), height(root.right)) + 1) if root else 0\n2: def trapezoidal_rule(boundary, steps):\n    \"\"\"\n    Implements the extended trapezoidal rule for numerical integration.\n    The function f(x) is provided below.\n\n    :param boundary: List containing the lower and upper bounds of integration [a, b]\n    :param steps: The number of steps (intervals) used in the approximation\n    :return: The numerical approximation of the integral\n\n    >>> abs(trapezoidal_rule([0, 1], 10) - 0.33333) < 0.01\n    True\n    >>> abs(trapezoidal_rule([0, 1], 100) - 0.33333) < 0.01\n    True\n    >>> abs(trapezoidal_rule([0, 2], 1000) - 2.66667) < 0.01\n    True\n    >>> abs(trapezoidal_rule([1, 2], 1000) - 2.33333) < 0.01\n    True\n    \"\"\"\n    h = (boundary[1] - boundary[0]) / steps\n    a = boundary[0]\n    b = boundary[1]\n    x_i = make_points(a, b, h)\n    y = 0.0\n    y += (h / 2.0) * f(a)\n    for i in x_i:\n        y += h * f(i)\n    y += (h / 2.0) * f(b)\n    return y", "output": "1"}
{"input": "search code:\nFind the number of digits in a number. abs() is used for negative numbers\nChoices:\n0: def is_collection(obj):\n    \"\"\"The opposite of :func:`is_scalar`.  Returns ``True`` if an object\n    is an iterable other than a string.\n\n    >>> is_collection(object())\n    False\n    >>> is_collection(range(10))\n    True\n    >>> is_collection('hello')\n    False\n    \"\"\"\n    return is_iterable(obj) and not isinstance(obj, (str, bytes))\n1: def polynomial_derivative(coefficients):\n    \"\"\"Compute the first derivative of a polynomial.\n\n    Evaluate the derivative of ``xÂ³ - 4 xÂ² - 17 x + 60``:\n\n    >>> coefficients = [1, -4, -17, 60]\n    >>> derivative_coefficients = polynomial_derivative(coefficients)\n    >>> derivative_coefficients\n    [3, -8, -17]\n\n    Note that polynomial coefficients are specified in descending power order.\n\n    Supports all numeric types: int, float, complex, Decimal, Fraction.\n    \"\"\"\n    n = len(coefficients)\n    powers = reversed(range(1, n))\n    return list(map(mul, coefficients, powers))\n2: def num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))", "output": "2"}
{"input": "search code:\nThis functions takes an integer number as input. returns 1 if n has even number of prime factors and -1 otherwise. >>> liouville_lambda(10) 1 >>> liouville_lambda(11) -1 >>> liouville_lambda(0) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> liouville_lambda(-1) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> liouville_lambda(11.0) Traceback (most recent call last): ... TypeError: Input value of [number=11.0] must be an integer\nChoices:\n0: def insert_node(head: Node | None, data: int) -> Node:\n    \"\"\"\n    Insert a new node at the end of a linked list and return the new head.\n\n    Parameters:\n        head (Node | None): The head of the linked list.\n        data (int): The data to be inserted into the new node.\n\n    Returns:\n        Node: The new head of the linked list.\n\n    >>> head = insert_node(None, 10)\n    >>> head = insert_node(head, 9)\n    >>> head = insert_node(head, 8)\n    >>> print_linked_list(head)\n    10->9->8\n    \"\"\"\n    new_node = Node(data)\n    # If the linked list is empty, the new_node becomes the head\n    if head is None:\n        return new_node\n\n    temp_node = head\n    while temp_node.next_node:\n        temp_node = temp_node.next_node\n\n    temp_node.next_node = new_node\n    return head\n1: def solution(n: int = 10000) -> int:\n    \"\"\"Returns the sum of all the amicable numbers under n.\n\n    >>> solution(10000)\n    31626\n    >>> solution(5000)\n    8442\n    >>> solution(1000)\n    504\n    >>> solution(100)\n    0\n    >>> solution(50)\n    0\n    \"\"\"\n    total = sum(\n        i\n        for i in range(1, n)\n        if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i\n    )\n    return total\n2: def liouville_lambda(number: int) -> int:\n    \"\"\"\n    This functions takes an integer number as input.\n    returns 1 if n has even number of prime factors and -1 otherwise.\n    >>> liouville_lambda(10)\n    1\n    >>> liouville_lambda(11)\n    -1\n    >>> liouville_lambda(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer\n    >>> liouville_lambda(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer\n    >>> liouville_lambda(11.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=11.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    return -1 if len(prime_factors(number)) % 2 else 1", "output": "2"}
{"input": "summarize code:\ndef _det(a: Point, b: Point, c: Point) -> float:\n    \"\"\"\n    Computes the sign perpendicular distance of a 2d point c from a line segment\n    ab. The sign indicates the direction of c relative to ab.\n    A Positive value means c is above ab (to the left), while a negative value\n    means c is below ab (to the right). 0 means all three points are on a straight line.\n\n    As a side note, 0.5 * abs|det| is the area of triangle abc\n\n    Parameters\n    ----------\n    a: point, the point on the left end of line segment ab\n    b: point, the point on the right end of line segment ab\n    c: point, the point for which the direction and location is desired.\n\n    Returns\n    --------\n    det: float, abs(det) is the distance of c from ab. The sign\n    indicates which side of line segment ab c is. det is computed as\n    (a_xb_y + c_xa_y + b_xc_y) - (a_yb_x + c_ya_x + b_yc_x)\n\n    Examples\n    ----------\n    >>> _det(Point(1, 1), Point(1, 2), Point(1, 5))\n    0.0\n    >>> _det(Point(0, 0), Point(10, 0), Point(0, 10))\n    100.0\n    >>> _det(Point(0, 0), Point(10, 0), Point(0, -10))\n    -100.0\n    \"\"\"\n\n    det = (a.x * b.y + b.x * c.y + c.x * a.y) - (a.y * b.x + b.y * c.x + c.y * a.x)\n    return det", "output": "Computes the sign perpendicular distance of a 2d point c from a line segment ab. The sign indicates the direction of c relative to ab. A Positive value means c is above ab (to the left), while a negative value means c is below ab (to the right). 0 means all three points are on a straight line."}
{"input": "search code:\nReturns the value of 30th digit power sum. >>> solution(2) 512 >>> solution(5) 5832 >>> solution(10) 614656\nChoices:\n0: def unwrap_text(text, ending='\\n\\n'):\n    r\"\"\"\n    Unwrap text, the natural complement to :func:`textwrap.wrap`.\n\n    >>> text = \"Short \\n lines  \\nwrapped\\nsmall.\\n\\nAnother\\nparagraph.\"\n    >>> unwrap_text(text)\n    'Short lines wrapped small.\\n\\nAnother paragraph.'\n\n    Args:\n       text: A string to unwrap.\n       ending (str): The string to join all unwrapped paragraphs\n          by. Pass ``None`` to get the list. Defaults to '\\n\\n' for\n          compatibility with Markdown and RST.\n\n    \"\"\"\n    all_grafs = []\n    cur_graf = []\n    for line in text.splitlines():\n        line = line.strip()\n        if line:\n            cur_graf.append(line)\n        else:\n            all_grafs.append(' '.join(cur_graf))\n            cur_graf = []\n    if cur_graf:\n        all_grafs.append(' '.join(cur_graf))\n    if ending is None:\n        return all_grafs\n    return ending.join(all_grafs)\n1: def solution(n: int = 30) -> int:\n    \"\"\"\n    Returns the value of 30th digit power sum.\n    >>> solution(2)\n    512\n    >>> solution(5)\n    5832\n    >>> solution(10)\n    614656\n    \"\"\"\n    digit_to_powers = []\n    for digit in range(2, 100):\n        for power in range(2, 100):\n            number = int(math.pow(digit, power))\n            if digit == digit_sum(number):\n                digit_to_powers.append(number)\n\n    digit_to_powers.sort()\n    return digit_to_powers[n - 1]\n2: def split_and_add(number: int) -> int:\n    \"\"\"Split number digits and add them.\"\"\"\n    sum_of_digits = 0\n    while number > 0:\n        last_digit = number % 10\n        sum_of_digits += last_digit\n        number = number // 10  # Removing the last_digit from the given number\n    return sum_of_digits", "output": "1"}
{"input": "summarize code:\ndef pi_estimator_using_area_under_curve(iterations: int) -> None:\n    \"\"\"\n    Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi\n    \"\"\"\n\n    def function_to_integrate(x: float) -> float:\n        \"\"\"\n        Represents semi-circle with radius 2\n        >>> [function_to_integrate(x) for x in [-2.0, 0.0, 2.0]]\n        [0.0, 2.0, 0.0]\n        \"\"\"\n        return sqrt(4.0 - x * x)\n\n    estimated_value = area_under_curve_estimator(\n        iterations, function_to_integrate, 0.0, 2.0\n    )\n\n    print(\"******************\")\n    print(\"Estimating pi using area_under_curve_estimator\")\n    print(f\"Estimated value is {estimated_value}\")\n    print(f\"Expected value is {pi}\")\n    print(f\"Total error is {abs(estimated_value - pi)}\")\n    print(\"******************\")", "output": "Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi"}
{"input": "search code:\nRotate a linked list to the right by places times.\nChoices:\n0: def knapsack(\n    capacity: int,\n    weights: list[int],\n    values: list[int],\n    counter: int,\n    allow_repetition=False,\n) -> int:\n    \"\"\"\n    Returns the maximum value that can be put in a knapsack of a capacity cap,\n    whereby each weight w has a specific value val\n    with option to allow repetitive selection of items\n\n    >>> cap = 50\n    >>> val = [60, 100, 120]\n    >>> w = [10, 20, 30]\n    >>> c = len(val)\n    >>> knapsack(cap, w, val, c)\n    220\n\n    Given the repetition is NOT allowed,\n    the result is 220 cause the values of 100 and 120 got the weight of 50\n    which is the limit of the capacity.\n    >>> knapsack(cap, w, val, c, True)\n    300\n\n    Given the repetition is allowed,\n    the result is 300 cause the values of 60*5 (pick 5 times)\n    got the weight of 10*5 which is the limit of the capacity.\n    \"\"\"\n\n    @lru_cache\n    def knapsack_recur(capacity: int, counter: int) -> int:\n        # Base Case\n        if counter == 0 or capacity == 0:\n            return 0\n\n        # If weight of the nth item is more than Knapsack of capacity,\n        #   then this item cannot be included in the optimal solution,\n        # else return the maximum of two cases:\n        #   (1) nth item included only once (0-1), if allow_repetition is False\n        #       nth item included one or more times (0-N), if allow_repetition is True\n        #   (2) not included\n        if weights[counter - 1] > capacity:\n            return knapsack_recur(capacity, counter - 1)\n        else:\n            left_capacity = capacity - weights[counter - 1]\n            new_value_included = values[counter - 1] + knapsack_recur(\n                left_capacity, counter - 1 if not allow_repetition else counter\n            )\n            without_new_value = knapsack_recur(capacity, counter - 1)\n            return max(new_value_included, without_new_value)\n\n    return knapsack_recur(capacity, counter)\n1: def generate_first_solution(path, dict_of_neighbours):\n    \"\"\"\n    Pure implementation of generating the first solution for the Tabu search to start,\n    with the redundant resolution strategy. That means that we start from the starting\n    node (e.g. node 'a'), then we go to the city nearest (lowest distance) to this node\n    (let's assume is node 'c'), then we go to the nearest city of the node 'c', etc.\n    till we have visited all cities and return to the starting node.\n\n    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n    :return first_solution: The solution for the first iteration of Tabu search using\n        the redundant resolution strategy in a list.\n    :return distance_of_first_solution: The total distance that Travelling Salesman\n        will travel, if he follows the path in first_solution.\n    \"\"\"\n\n    with open(path) as f:\n        start_node = f.read(1)\n    end_node = start_node\n\n    first_solution = []\n\n    visiting = start_node\n\n    distance_of_first_solution = 0\n    while visiting not in first_solution:\n        minim = 10000\n        for k in dict_of_neighbours[visiting]:\n            if int(k[1]) < int(minim) and k[0] not in first_solution:\n                minim = k[1]\n                best_node = k[0]\n\n        first_solution.append(visiting)\n        distance_of_first_solution = distance_of_first_solution + int(minim)\n        visiting = best_node\n\n    first_solution.append(end_node)\n\n    position = 0\n    for k in dict_of_neighbours[first_solution[-2]]:\n        if k[0] == start_node:\n            break\n        position += 1\n\n    distance_of_first_solution = (\n        distance_of_first_solution\n        + int(dict_of_neighbours[first_solution[-2]][position][1])\n        - 10000\n    )\n    return first_solution, distance_of_first_solution\n2: def rotate_to_the_right(head: Node, places: int) -> Node:\n    \"\"\"\n    Rotate a linked list to the right by places times.\n\n    Parameters:\n        head: The head of the linked list.\n        places: The number of places to rotate.\n\n    Returns:\n        Node: The head of the rotated linked list.\n\n    >>> rotate_to_the_right(None, places=1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The linked list is empty.\n    >>> head = insert_node(None, 1)\n    >>> rotate_to_the_right(head, places=1) == head\n    True\n    >>> head = insert_node(None, 1)\n    >>> head = insert_node(head, 2)\n    >>> head = insert_node(head, 3)\n    >>> head = insert_node(head, 4)\n    >>> head = insert_node(head, 5)\n    >>> new_head = rotate_to_the_right(head, places=2)\n    >>> print_linked_list(new_head)\n    4->5->1->2->3\n    \"\"\"\n    # Check if the list is empty or has only one element\n    if not head:\n        raise ValueError(\"The linked list is empty.\")\n\n    if head.next_node is None:\n        return head\n\n    # Calculate the length of the linked list\n    length = 1\n    temp_node = head\n    while temp_node.next_node is not None:\n        length += 1\n        temp_node = temp_node.next_node\n\n    # Adjust the value of places to avoid places longer than the list.\n    places %= length\n\n    if places == 0:\n        return head  # As no rotation is needed.\n\n    # Find the new head position after rotation.\n    new_head_index = length - places\n\n    # Traverse to the new head position\n    temp_node = head\n    for _ in range(new_head_index - 1):\n        assert temp_node.next_node\n        temp_node = temp_node.next_node\n\n    # Update pointers to perform rotation\n    assert temp_node.next_node\n    new_head = temp_node.next_node\n    temp_node.next_node = None\n    temp_node = new_head\n    while temp_node.next_node:\n        temp_node = temp_node.next_node\n    temp_node.next_node = head\n\n    assert new_head\n    return new_head", "output": "2"}
{"input": "summarize code:\ndef fibonacci_digits_index(n: int) -> int:\n    \"\"\"\n    Computes incrementing Fibonacci numbers starting from 3 until the length\n    of the resulting Fibonacci result is the input value n. Returns the term\n    of the Fibonacci sequence where this occurs.\n\n    >>> fibonacci_digits_index(1000)\n    4782\n    >>> fibonacci_digits_index(100)\n    476\n    >>> fibonacci_digits_index(50)\n    237\n    >>> fibonacci_digits_index(3)\n    12\n    \"\"\"\n    digits = 0\n    index = 2\n\n    while digits < n:\n        index += 1\n        digits = len(str(fibonacci(index)))\n\n    return index", "output": "Computes incrementing Fibonacci numbers starting from 3 until the length of the resulting Fibonacci result is the input value n. Returns the term of the Fibonacci sequence where this occurs."}
{"input": "summarize code:\ndef depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:\n    \"\"\"\n    Recursive Backtracking Depth First Search Algorithm\n\n    Starting from top left of a matrix, count the number of\n    paths that can reach the bottom right of a matrix.\n    1 represents a block (inaccessible)\n    0 represents a valid space (accessible)\n\n    0  0  0  0\n    1  1  0  0\n    0  0  0  1\n    0  1  0  0\n    >>> grid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n\n    0  0  0  0  0\n    0  1  1  1  0\n    0  1  1  1  0\n    0  0  0  0  0\n    >>> grid = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n    \"\"\"\n    row_length, col_length = len(grid), len(grid[0])\n    if (\n        min(row, col) < 0\n        or row == row_length\n        or col == col_length\n        or (row, col) in visit\n        or grid[row][col] == 1\n    ):\n        return 0\n    if row == row_length - 1 and col == col_length - 1:\n        return 1\n\n    visit.add((row, col))\n\n    count = 0\n    count += depth_first_search(grid, row + 1, col, visit)\n    count += depth_first_search(grid, row - 1, col, visit)\n    count += depth_first_search(grid, row, col + 1, visit)\n    count += depth_first_search(grid, row, col - 1, visit)\n\n    visit.remove((row, col))\n    return count", "output": "Recursive Backtracking Depth First Search Algorithm"}
{"input": "search code:\nFormula for amortization amount per month: A = p * r * (1 + r)^n / ((1 + r)^n - 1) where p is the principal, r is the rate of interest per month and n is the number of payments\nChoices:\n0: def median_of_five(arr: list) -> int:\n    \"\"\"\n    Return the median of the input list\n    :param arr: Array to find median of\n    :return: median of arr\n\n    >>> median_of_five([2, 4, 5, 7, 899])\n    5\n    >>> median_of_five([5, 7, 899, 54, 32])\n    32\n    >>> median_of_five([5, 4, 3, 2])\n    4\n    >>> median_of_five([3, 5, 7, 10, 2])\n    5\n    \"\"\"\n    arr = sorted(arr)\n    return arr[len(arr) // 2]\n1: def equated_monthly_installments(\n    principal: float, rate_per_annum: float, years_to_repay: int\n) -> float:\n    \"\"\"\n    Formula for amortization amount per month:\n    A = p * r * (1 + r)^n / ((1 + r)^n - 1)\n    where p is the principal, r is the rate of interest per month\n    and n is the number of payments\n\n    >>> equated_monthly_installments(25000, 0.12, 3)\n    830.3577453212793\n    >>> equated_monthly_installments(25000, 0.12, 10)\n    358.67737100646826\n    >>> equated_monthly_installments(0, 0.12, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Principal borrowed must be > 0\n    >>> equated_monthly_installments(25000, -1, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Rate of interest must be >= 0\n    >>> equated_monthly_installments(25000, 0.12, 0)\n    Traceback (most recent call last):\n        ...\n    Exception: Years to repay must be an integer > 0\n    \"\"\"\n    if principal <= 0:\n        raise Exception(\"Principal borrowed must be > 0\")\n    if rate_per_annum < 0:\n        raise Exception(\"Rate of interest must be >= 0\")\n    if years_to_repay <= 0 or not isinstance(years_to_repay, int):\n        raise Exception(\"Years to repay must be an integer > 0\")\n\n    # Yearly rate is divided by 12 to get monthly rate\n    rate_per_month = rate_per_annum / 12\n\n    # Years to repay is multiplied by 12 to get number of payments as payment is monthly\n    number_of_payments = years_to_repay * 12\n\n    return (\n        principal\n        * rate_per_month\n        * (1 + rate_per_month) ** number_of_payments\n        / ((1 + rate_per_month) ** number_of_payments - 1)\n    )\n2: def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True", "output": "1"}
{"input": "search code:\nSolve the linear system of equations Ax = b (A = \"matrix\", b = \"vector\") for x using Gaussian elimination and back substitution. We assume that A is an invertible square matrix and that b is a column vector of the same height. >>> solve([[1, 0], [0, 1]], [[1],[2]]) [[1.0], [2.0]] >>> solve([[2, 1, -1],[-3, -1, 2],[-2, 1, 2]],[[8], [-11],[-3]]) [[2.0], [3.0], [-1.0]]\nChoices:\n0: def effusion_ratio(molar_mass_1: float, molar_mass_2: float) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> effusion_ratio(2.016, 4.002)\n    1.408943\n    >>> effusion_ratio(-2.016, 4.002)\n    ValueError('Input Error: Molar mass values must greater than 0.')\n    >>> effusion_ratio(2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: effusion_ratio() missing 1 required positional argument: 'molar_mass_2'\n    \"\"\"\n    return (\n        round(sqrt(molar_mass_2 / molar_mass_1), 6)\n        if validate(molar_mass_1, molar_mass_2)\n        else ValueError(\"Input Error: Molar mass values must greater than 0.\")\n    )\n1: def solve(matrix: Matrix, vector: Matrix) -> Matrix:\n    \"\"\"\n    Solve the linear system of equations Ax = b (A = \"matrix\", b = \"vector\")\n    for x using Gaussian elimination and back substitution. We assume that A\n    is an invertible square matrix and that b is a column vector of the\n    same height.\n    >>> solve([[1, 0], [0, 1]], [[1],[2]])\n    [[1.0], [2.0]]\n    >>> solve([[2, 1, -1],[-3, -1, 2],[-2, 1, 2]],[[8], [-11],[-3]])\n    [[2.0], [3.0], [-1.0]]\n    \"\"\"\n    size: int = len(matrix)\n    augmented: Matrix = [[0 for _ in range(size + 1)] for _ in range(size)]\n    row: int\n    row2: int\n    col: int\n    col2: int\n    pivot_row: int\n    ratio: float\n\n    for row in range(size):\n        for col in range(size):\n            augmented[row][col] = matrix[row][col]\n\n        augmented[row][size] = vector[row][0]\n\n    row = 0\n    col = 0\n    while row < size and col < size:\n        # pivoting\n        pivot_row = max((abs(augmented[row2][col]), row2) for row2 in range(col, size))[\n            1\n        ]\n        if augmented[pivot_row][col] == 0:\n            col += 1\n            continue\n        else:\n            augmented[row], augmented[pivot_row] = augmented[pivot_row], augmented[row]\n\n        for row2 in range(row + 1, size):\n            ratio = augmented[row2][col] / augmented[row][col]\n            augmented[row2][col] = 0\n            for col2 in range(col + 1, size + 1):\n                augmented[row2][col2] -= augmented[row][col2] * ratio\n\n        row += 1\n        col += 1\n\n    # back substitution\n    for col in range(1, size):\n        for row in range(col):\n            ratio = augmented[row][col] / augmented[col][col]\n            for col2 in range(col, size + 1):\n                augmented[row][col2] -= augmented[col][col2] * ratio\n\n    # round to get rid of numbers like 2.000000000000004\n    return [\n        [round(augmented[row][size] / augmented[row][row], 10)] for row in range(size)\n    ]\n2: def concave_triangle_area(circles_number: int) -> float:\n    \"\"\"\n    Returns area of concave triangle\n\n    >>> concave_triangle_area(1)\n    0.026825229575318944\n\n    >>> concave_triangle_area(2)\n    0.01956236140083944\n    \"\"\"\n\n    intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (\n        2 * (circles_number**2 + 1)\n    )\n    intersection_x = circles_number * intersection_y\n\n    triangle_area = intersection_x * intersection_y / 2\n    concave_region_area = circle_bottom_arc_integral(\n        1 / 2\n    ) - circle_bottom_arc_integral(intersection_x)\n\n    return triangle_area + concave_region_area", "output": "1"}
{"input": "summarize code:\ndef fibonacci(k: int) -> int:\n    \"\"\"Finds fibonacci number in index k.\n\n    Parameters\n    ----------\n    k :\n        Index of fibonacci.\n\n    Returns\n    -------\n    int\n        Fibonacci number in position k.\n\n    >>> fibonacci(0)\n    0\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(15)\n    610\n    >>> fibonacci('a')\n    Traceback (most recent call last):\n    TypeError: k must be an integer.\n    >>> fibonacci(-5)\n    Traceback (most recent call last):\n    ValueError: k integer must be greater or equal to zero.\n    \"\"\"\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer.\")\n    if k < 0:\n        raise ValueError(\"k integer must be greater or equal to zero.\")\n    if k == 0:\n        return 0\n    elif k == 1:\n        return 1\n    else:\n        return fibonacci(k - 1) + fibonacci(k - 2)", "output": "Finds fibonacci number in index k."}
{"input": "summarize code:\ndef unique_to_each(*iterables):\n    \"\"\"Return the elements from each of the input iterables that aren't in the\n    other input iterables.\n\n    For example, suppose you have a set of packages, each with a set of\n    dependencies::\n\n        {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}\n\n    If you remove one package, which dependencies can also be removed?\n\n    If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not\n    associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for\n    ``pkg_2``, and ``D`` is only needed for ``pkg_3``::\n\n        >>> unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})\n        [['A'], ['C'], ['D']]\n\n    If there are duplicates in one input iterable that aren't in the others\n    they will be duplicated in the output. Input order is preserved::\n\n        >>> unique_to_each(\"mississippi\", \"missouri\")\n        [['p', 'p'], ['o', 'u', 'r']]\n\n    It is assumed that the elements of each iterable are hashable.\n\n    \"\"\"\n    pool = [list(it) for it in iterables]\n    counts = Counter(chain.from_iterable(map(set, pool)))\n    uniques = {element for element in counts if counts[element] == 1}\n    return [list(filter(uniques.__contains__, it)) for it in pool]", "output": "Return the elements from each of the input iterables that aren't in the other input iterables."}
{"input": "summarize code:\ndef minimax(\n    depth: int, node_index: int, is_max: bool, scores: list[int], height: float\n) -> int:\n    \"\"\"\n    This function implements the minimax algorithm, which helps achieve the optimal\n    score for a player in a two-player game by checking all possible moves.\n    If the player is the maximizer, then the score is maximized.\n    If the player is the minimizer, then the score is minimized.\n\n    Parameters:\n    - depth: Current depth in the game tree.\n    - node_index: Index of the current node in the scores list.\n    - is_max: A boolean indicating whether the current move\n              is for the maximizer (True) or minimizer (False).\n    - scores: A list containing the scores of the leaves of the game tree.\n    - height: The maximum height of the game tree.\n\n    Returns:\n    - An integer representing the optimal score for the current player.\n\n    >>> import math\n    >>> scores = [90, 23, 6, 33, 21, 65, 123, 34423]\n    >>> height = math.log(len(scores), 2)\n    >>> minimax(0, 0, True, scores, height)\n    65\n    >>> minimax(-1, 0, True, scores, height)\n    Traceback (most recent call last):\n        ...\n    ValueError: Depth cannot be less than 0\n    >>> minimax(0, 0, True, [], 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Scores cannot be empty\n    >>> scores = [3, 5, 2, 9, 12, 5, 23, 23]\n    >>> height = math.log(len(scores), 2)\n    >>> minimax(0, 0, True, scores, height)\n    12\n    \"\"\"\n\n    if depth < 0:\n        raise ValueError(\"Depth cannot be less than 0\")\n    if len(scores) == 0:\n        raise ValueError(\"Scores cannot be empty\")\n\n    # Base case: If the current depth equals the height of the tree,\n    # return the score of the current node.\n    if depth == height:\n        return scores[node_index]\n\n    # If it's the maximizer's turn, choose the maximum score\n    # between the two possible moves.\n    if is_max:\n        return max(\n            minimax(depth + 1, node_index * 2, False, scores, height),\n            minimax(depth + 1, node_index * 2 + 1, False, scores, height),\n        )\n\n    # If it's the minimizer's turn, choose the minimum score\n    # between the two possible moves.\n    return min(\n        minimax(depth + 1, node_index * 2, True, scores, height),\n        minimax(depth + 1, node_index * 2 + 1, True, scores, height),\n    )", "output": "This function implements the minimax algorithm, which helps achieve the optimal score for a player in a two-player game by checking all possible moves. If the player is the maximizer, then the score is maximized. If the player is the minimizer, then the score is minimized."}
{"input": "summarize code:\ndef trapezoidal_area(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    \"\"\"\n    Treats curve as a collection of linear lines and sums the area of the\n    trapezium shape they form\n    :param fnc: a function which defines a curve\n    :param x_start: left end point to indicate the start of line segment\n    :param x_end: right end point to indicate end of line segment\n    :param steps: an accuracy gauge; more steps increases the accuracy\n    :return: a float representing the length of the curve\n\n    >>> def f(x):\n    ...    return 5\n    >>> '%.3f' % trapezoidal_area(f, 12.0, 14.0, 1000)\n    '10.000'\n\n    >>> def f(x):\n    ...    return 9*x**2\n    >>> '%.4f' % trapezoidal_area(f, -4.0, 0, 10000)\n    '192.0000'\n\n    >>> '%.4f' % trapezoidal_area(f, -4.0, 4.0, 10000)\n    '384.0000'\n    \"\"\"\n    x1 = x_start\n    fx1 = fnc(x_start)\n    area = 0.0\n\n    for _ in range(steps):\n        # Approximates small segments of curve as linear and solve\n        # for trapezoidal area\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\n\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n    return area", "output": "Treats curve as a collection of linear lines and sums the area of the trapezium shape they form :param fnc: a function which defines a curve :param x_start: left end point to indicate the start of line segment :param x_end: right end point to indicate end of line segment :param steps: an accuracy gauge; more steps increases the accuracy :return: a float representing the length of the curve"}
{"input": "summarize code:\ndef factor(n):\n    \"\"\"Yield the prime factors of n.\n\n    >>> list(factor(360))\n    [2, 2, 2, 3, 3, 5]\n\n    Finds small factors with trial division.  Larger factors are\n    either verified as prime with ``is_prime`` or split into\n    smaller factors with Pollard's rho algorithm.\n    \"\"\"\n\n    # Corner case reduction\n    if n < 2:\n        return\n\n    # Trial division reduction\n    for prime in _primes_below_211:\n        while not n % prime:\n            yield prime\n            n //= prime\n\n    # Pollard's rho reduction\n    primes = []\n    todo = [n] if n > 1 else []\n    for n in todo:\n        if n < 211**2 or is_prime(n):\n            primes.append(n)\n        else:\n            fact = _factor_pollard(n)\n            todo += (fact, n // fact)\n    yield from sorted(primes)", "output": "Yield the prime factors of n."}
{"input": "search code:\nReturns the product of a,b,c which are Pythagorean Triplet that satisfies the following: 1. a < b < c 2. a**2 + b**2 = c**2 3. a + b + c = 1000\nChoices:\n0: def windowed(src, size, fill=_UNSET):\n    \"\"\"Returns tuples with exactly length *size*. If *fill* is unset \n    and the iterable is too short to make a window of length *size*, \n    no tuples are returned. See :func:`windowed_iter` for more.\n    \"\"\"\n    return list(windowed_iter(src, size, fill=fill))\n1: def solution() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(a + 1, 400):\n            for c in range(b + 1, 500):\n                if (a + b + c) == 1000 and (a**2) + (b**2) == (c**2):\n                    return a * b * c\n\n    return -1\n2: def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:\n    \"\"\"\n    Calculate the distance between the two endpoints of two vectors.\n    A vector is defined as a list, tuple, or numpy 1D array.\n    >>> float(euclidean_distance((0, 0), (2, 2)))\n    2.8284271247461903\n    >>> float(euclidean_distance(np.array([0, 0, 0]), np.array([2, 2, 2])))\n    3.4641016151377544\n    >>> float(euclidean_distance(np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8])))\n    8.0\n    >>> float(euclidean_distance([1, 2, 3, 4], [5, 6, 7, 8]))\n    8.0\n    \"\"\"\n    return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))", "output": "1"}
{"input": "summarize code:\ndef binary_count_trailing_zeros(a: int) -> int:\n    \"\"\"\n    Take in 1 integer, return a number that is\n    the number of trailing zeros in binary representation of that number.\n\n    >>> binary_count_trailing_zeros(25)\n    0\n    >>> binary_count_trailing_zeros(36)\n    2\n    >>> binary_count_trailing_zeros(16)\n    4\n    >>> binary_count_trailing_zeros(58)\n    1\n    >>> binary_count_trailing_zeros(4294967296)\n    32\n    >>> binary_count_trailing_zeros(0)\n    0\n    >>> binary_count_trailing_zeros(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value must be a positive integer\n    >>> binary_count_trailing_zeros(0.8)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n    >>> binary_count_trailing_zeros(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if a < 0:\n        raise ValueError(\"Input value must be a positive integer\")\n    elif isinstance(a, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    return 0 if (a == 0) else int(log2(a & -a))", "output": "Take in 1 integer, return a number that is the number of trailing zeros in binary representation of that number."}
{"input": "summarize code:\ndef lstrip_iter(iterable, strip_value=None):\n    \"\"\"Strips values from the beginning of an iterable. Stripped items will\n    match the value of the argument strip_value. Functionality is analogous\n    to that of the method str.lstrip. Returns a generator.\n\n    >>> list(lstrip_iter(['Foo', 'Bar', 'Bam'], 'Foo'))\n    ['Bar', 'Bam']\n\n    \"\"\"\n    iterator = iter(iterable)\n    for i in iterator:\n        if i != strip_value:\n            yield i\n            break\n    for i in iterator:\n        yield i", "output": "Strips values from the beginning of an iterable. Stripped items will match the value of the argument strip_value. Functionality is analogous to that of the method str.lstrip. Returns a generator."}
{"input": "search code:\nTransforms a snake_case given string to camelCase (or PascalCase if indicated) (defaults to not use Pascal)\nChoices:\n0: def benchmark() -> None:\n    \"\"\"\n    Benchmark code for comparing 2 functions, with different length int values.\n    Brian Kernighan's algorithm is consistently faster than using modulo_operator.\n    \"\"\"\n\n    def do_benchmark(number: int) -> None:\n        setup = \"import __main__ as z\"\n        print(f\"Benchmark when {number = }:\")\n        print(f\"{get_set_bits_count_using_modulo_operator(number) = }\")\n        timing = timeit(\n            f\"z.get_set_bits_count_using_modulo_operator({number})\", setup=setup\n        )\n        print(f\"timeit() runs in {timing} seconds\")\n        print(f\"{get_set_bits_count_using_brian_kernighans_algorithm(number) = }\")\n        timing = timeit(\n            f\"z.get_set_bits_count_using_brian_kernighans_algorithm({number})\",\n            setup=setup,\n        )\n        print(f\"timeit() runs in {timing} seconds\")\n\n    for number in (25, 37, 58, 0):\n        do_benchmark(number)\n        print()\n1: def snake_to_camel_case(input_str: str, use_pascal: bool = False) -> str:\n    \"\"\"\n    Transforms a snake_case given string to camelCase (or PascalCase if indicated)\n    (defaults to not use Pascal)\n\n    >>> snake_to_camel_case(\"some_random_string\")\n    'someRandomString'\n\n    >>> snake_to_camel_case(\"some_random_string\", use_pascal=True)\n    'SomeRandomString'\n\n    >>> snake_to_camel_case(\"some_random_string_with_numbers_123\")\n    'someRandomStringWithNumbers123'\n\n    >>> snake_to_camel_case(\"some_random_string_with_numbers_123\", use_pascal=True)\n    'SomeRandomStringWithNumbers123'\n\n    >>> snake_to_camel_case(123)\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected string as input, found <class 'int'>\n\n    >>> snake_to_camel_case(\"some_string\", use_pascal=\"True\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected boolean as use_pascal parameter, found <class 'str'>\n    \"\"\"\n\n    if not isinstance(input_str, str):\n        msg = f\"Expected string as input, found {type(input_str)}\"\n        raise ValueError(msg)\n    if not isinstance(use_pascal, bool):\n        msg = f\"Expected boolean as use_pascal parameter, found {type(use_pascal)}\"\n        raise ValueError(msg)\n\n    words = input_str.split(\"_\")\n\n    start_index = 0 if use_pascal else 1\n\n    words_to_capitalize = words[start_index:]\n\n    capitalized_words = [word[0].upper() + word[1:] for word in words_to_capitalize]\n\n    initial_word = \"\" if use_pascal else words[0]\n\n    return \"\".join([initial_word, *capitalized_words])\n2: def naturaldate(value) -> str:\n    \"\"\"Like `naturalday`, but append a year for dates more than ~five months away.\"\"\"\n    try:\n        value = dt.date(value.year, value.month, value.day)\n    except AttributeError:\n        # Passed value wasn't date-ish\n        return value\n    except (OverflowError, ValueError):\n        # Date arguments out of range\n        return value\n    delta = _abs_timedelta(value - dt.date.today())\n    if delta.days >= 5 * 365 / 12:\n        return naturalday(value, \"%b %d %Y\")\n    return naturalday(value)", "output": "1"}
{"input": "search code:\nArgs: function : the function which's integration is desired a : the lower limit of integration b : upper limit of integration precision : precision of the result,error required default is 4\nChoices:\n0: def harmonic_series(n_term: str) -> list:\n    \"\"\"Pure Python implementation of Harmonic Series algorithm\n\n    :param n_term: The last (nth) term of Harmonic Series\n    :return: The Harmonic Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> harmonic_series(5)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.0)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.1)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(-5)\n    []\n    >>> harmonic_series(0)\n    []\n    >>> harmonic_series(1)\n    ['1']\n    \"\"\"\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series\n1: def simpson_integration(function, a: float, b: float, precision: int = 4) -> float:\n    \"\"\"\n    Args:\n        function : the function which's integration is desired\n        a : the lower limit of integration\n        b : upper limit of integration\n        precision : precision of the result,error required default is 4\n\n    Returns:\n        result : the value of the approximated integration of function in range a to b\n\n    Raises:\n        AssertionError: function is not callable\n        AssertionError: a is not float or integer\n        AssertionError: function should return float or integer\n        AssertionError: b is not float or integer\n        AssertionError: precision is not positive integer\n\n    >>> simpson_integration(lambda x : x*x,1,2,3)\n    2.333\n\n    >>> simpson_integration(lambda x : x*x,'wrong_input',2,3)\n    Traceback (most recent call last):\n        ...\n    AssertionError: a should be float or integer your input : wrong_input\n\n    >>> simpson_integration(lambda x : x*x,1,'wrong_input',3)\n    Traceback (most recent call last):\n        ...\n    AssertionError: b should be float or integer your input : wrong_input\n\n    >>> simpson_integration(lambda x : x*x,1,2,'wrong_input')\n    Traceback (most recent call last):\n        ...\n    AssertionError: precision should be positive integer your input : wrong_input\n    >>> simpson_integration('wrong_input',2,3,4)\n    Traceback (most recent call last):\n        ...\n    AssertionError: the function(object) passed should be callable your input : ...\n\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,1)\n    -2.8\n\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,0)\n    Traceback (most recent call last):\n        ...\n    AssertionError: precision should be positive integer your input : 0\n\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: precision should be positive integer your input : -1\n\n    \"\"\"\n    assert callable(function), (\n        f\"the function(object) passed should be callable your input : {function}\"\n    )\n    assert isinstance(a, (float, int)), f\"a should be float or integer your input : {a}\"\n    assert isinstance(function(a), (float, int)), (\n        \"the function should return integer or float return type of your function, \"\n        f\"{type(a)}\"\n    )\n    assert isinstance(b, (float, int)), f\"b should be float or integer your input : {b}\"\n    assert isinstance(precision, int) and precision > 0, (\n        f\"precision should be positive integer your input : {precision}\"\n    )\n\n    # just applying the formula of simpson for approximate integration written in\n    # mentioned article in first comment of this file and above this function\n\n    h = (b - a) / N_STEPS\n    result = function(a) + function(b)\n\n    for i in range(1, N_STEPS):\n        a1 = a + h * i\n        result += function(a1) * (4 if i % 2 else 2)\n\n    result *= h / 3\n    return round(result, precision)\n2: def iter_suppress(iterable, *exceptions):\n    \"\"\"Yield each of the items from *iterable*. If the iteration raises one of\n    the specified *exceptions*, that exception will be suppressed and iteration\n    will stop.\n\n    >>> from itertools import chain\n    >>> def breaks_at_five(x):\n    ...     while True:\n    ...         if x >= 5:\n    ...             raise RuntimeError\n    ...         yield x\n    ...         x += 1\n    >>> it_1 = iter_suppress(breaks_at_five(1), RuntimeError)\n    >>> it_2 = iter_suppress(breaks_at_five(2), RuntimeError)\n    >>> list(chain(it_1, it_2))\n    [1, 2, 3, 4, 2, 3, 4]\n    \"\"\"\n    try:\n        yield from iterable\n    except exceptions:\n        return", "output": "1"}
{"input": "summarize code:\ndef is_geometric_series(series: list) -> bool:\n    \"\"\"\n    checking whether the input series is geometric series or not\n    >>> is_geometric_series([2, 4, 8])\n    True\n    >>> is_geometric_series([3, 6, 12, 24])\n    True\n    >>> is_geometric_series([1, 2, 3])\n    False\n    >>> is_geometric_series([0, 0, 3])\n    False\n    >>> is_geometric_series([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n    >>> is_geometric_series(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 8]\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    if len(series) == 1:\n        return True\n    try:\n        common_ratio = series[1] / series[0]\n        for index in range(len(series) - 1):\n            if series[index + 1] / series[index] != common_ratio:\n                return False\n    except ZeroDivisionError:\n        return False\n    return True", "output": "checking whether the input series is geometric series or not >>> is_geometric_series([2, 4, 8]) True >>> is_geometric_series([3, 6, 12, 24]) True >>> is_geometric_series([1, 2, 3]) False >>> is_geometric_series([0, 0, 3]) False >>> is_geometric_series([]) Traceback (most recent call last): ... ValueError: Input list must be a non empty list >>> is_geometric_series(4) Traceback (most recent call last): ... ValueError: Input series is not valid, valid series - [2, 4, 8]"}
{"input": "search code:\nFind the absolute value of a number.\nChoices:\n0: def chain_length(n: int, previous: set | None = None) -> int:\n    \"\"\"\n    Calculate the length of the chain of non-repeating terms starting with n.\n    Previous is a set containing the previous member of the chain.\n    >>> chain_length(10101)\n    11\n    >>> chain_length(555)\n    20\n    >>> chain_length(178924)\n    39\n    \"\"\"\n    previous = previous or set()\n    if n in CHAIN_LENGTH_CACHE:\n        return CHAIN_LENGTH_CACHE[n]\n    next_number = sum_digit_factorials(n)\n    if next_number in previous:\n        CHAIN_LENGTH_CACHE[n] = 0\n        return 0\n    else:\n        previous.add(n)\n        ret = 1 + chain_length(next_number, previous)\n        CHAIN_LENGTH_CACHE[n] = ret\n        return ret\n1: def area_rectangle(length: float, width: float) -> float:\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    >>> area_rectangle(10, 20)\n    200\n    >>> area_rectangle(1.6, 2.6)\n    4.16\n    >>> area_rectangle(0, 0)\n    0\n    >>> area_rectangle(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rectangle() only accepts non-negative values\n    >>> area_rectangle(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rectangle() only accepts non-negative values\n    >>> area_rectangle(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rectangle() only accepts non-negative values\n    \"\"\"\n    if length < 0 or width < 0:\n        raise ValueError(\"area_rectangle() only accepts non-negative values\")\n    return length * width\n2: def abs_val(num: float) -> float:\n    \"\"\"\n    Find the absolute value of a number.\n\n    >>> abs_val(-5.1)\n    5.1\n    >>> abs_val(-5) == abs_val(5)\n    True\n    >>> abs_val(0)\n    0\n    \"\"\"\n    return -num if num < 0 else num", "output": "2"}
{"input": "search code:\nfinds where function becomes 0 in [a,b] using bolzano >>> bisection(lambda x: x ** 3 - 1, -5, 5) 1.0000000149011612 >>> bisection(lambda x: x ** 3 - 1, 2, 1000) Traceback (most recent call last): ... ValueError: could not find root in given interval. >>> bisection(lambda x: x ** 2 - 4 * x + 3, 0, 2) 1.0 >>> bisection(lambda x: x ** 2 - 4 * x + 3, 2, 4) 3.0 >>> bisection(lambda x: x ** 2 - 4 * x + 3, 4, 1000) Traceback (most recent call last): ... ValueError: could not find root in given interval.\nChoices:\n0: def fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]\n1: def vol_spheres_union(\n    radius_1: float, radius_2: float, centers_distance: float\n) -> float:\n    r\"\"\"\n    Calculate the volume of the union of two spheres that possibly intersect.\n\n    It is the sum of sphere :math:`A` and sphere :math:`B` minus their intersection.\n    First, it calculates the volumes :math:`(v_1, v_2)` of the spheres,\n    then the volume of the intersection :math:`i` and\n    it returns the sum :math:`v_1 + v_2 - i`.\n    If `centers_distance` is 0 then it returns the volume of the larger sphere\n\n    :return: ``vol_sphere`` (:math:`radius_1`) + ``vol_sphere`` (:math:`radius_2`)\n             - ``vol_spheres_intersect``\n             (:math:`radius_1`, :math:`radius_2`, :math:`centers\\_distance`)\n\n    >>> vol_spheres_union(2, 2, 1)\n    45.814892864851146\n    >>> vol_spheres_union(1.56, 2.2, 1.4)\n    48.77802773671288\n    >>> vol_spheres_union(0, 2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spheres_union() only accepts non-negative values, non-zero radius\n    >>> vol_spheres_union('1.56', '2.2', '1.4')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'str' and 'int'\n    >>> vol_spheres_union(1, None, 1)\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'NoneType' and 'int'\n    \"\"\"\n\n    if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:\n        raise ValueError(\n            \"vol_spheres_union() only accepts non-negative values, non-zero radius\"\n        )\n\n    if centers_distance == 0:\n        return vol_sphere(max(radius_1, radius_2))\n\n    return (\n        vol_sphere(radius_1)\n        + vol_sphere(radius_2)\n        - vol_spheres_intersect(radius_1, radius_2, centers_distance)\n    )\n2: def bisection(function: Callable[[float], float], a: float, b: float) -> float:\n    \"\"\"\n    finds where function becomes 0 in [a,b] using bolzano\n    >>> bisection(lambda x: x ** 3 - 1, -5, 5)\n    1.0000000149011612\n    >>> bisection(lambda x: x ** 3 - 1, 2, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 0, 2)\n    1.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 2, 4)\n    3.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    \"\"\"\n    start: float = a\n    end: float = b\n    if function(a) == 0:  # one of the a or b is a root for the function\n        return a\n    elif function(b) == 0:\n        return b\n    elif (\n        function(a) * function(b) > 0\n    ):  # if none of these are root and they are both positive or negative,\n        # then this algorithm can't find the root\n        raise ValueError(\"could not find root in given interval.\")\n    else:\n        mid: float = start + (end - start) / 2.0\n        while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7\n            if function(mid) == 0:\n                return mid\n            elif function(mid) * function(start) < 0:\n                end = mid\n            else:\n                start = mid\n            mid = start + (end - start) / 2.0\n        return mid", "output": "2"}
{"input": "summarize code:\ndef quote_query_part(text, full_quote=True):\n    \"\"\"\n    Percent-encode a single query string key or value.\n    \"\"\"\n    if full_quote:\n        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')\n        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])\n    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t\n                     for t in text])", "output": "Percent-encode a single query string key or value."}
{"input": "summarize code:\ndef dutch_national_flag_sort(sequence: list) -> list:\n    \"\"\"\n    A pure Python implementation of Dutch National Flag sort algorithm.\n    :param data: 3 unique integer values (e.g., 0, 1, 2) in an sequence\n    :return: The same collection in ascending order\n\n    >>> dutch_national_flag_sort([])\n    []\n    >>> dutch_national_flag_sort([0])\n    [0]\n    >>> dutch_national_flag_sort([2, 1, 0, 0, 1, 2])\n    [0, 0, 1, 1, 2, 2]\n    >>> dutch_national_flag_sort([0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2]\n    >>> dutch_national_flag_sort(\"abacab\")\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort(\"Abacab\")\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort([3, 2, 3, 1, 3, 0, 3])\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort([-1, 2, -1, 1, -1, 0, -1])\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort([1.1, 2, 1.1, 1, 1.1, 0, 1.1])\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    \"\"\"\n    if not sequence:\n        return []\n    if len(sequence) == 1:\n        return list(sequence)\n    low = 0\n    high = len(sequence) - 1\n    mid = 0\n    while mid <= high:\n        if sequence[mid] == colors[0]:\n            sequence[low], sequence[mid] = sequence[mid], sequence[low]\n            low += 1\n            mid += 1\n        elif sequence[mid] == colors[1]:\n            mid += 1\n        elif sequence[mid] == colors[2]:\n            sequence[mid], sequence[high] = sequence[high], sequence[mid]\n            high -= 1\n        else:\n            msg = f\"The elements inside the sequence must contains only {colors} values\"\n            raise ValueError(msg)\n    return sequence", "output": "A pure Python implementation of Dutch National Flag sort algorithm. :param data: 3 unique integer values (e.g., 0, 1, 2) in an sequence :return: The same collection in ascending order"}
{"input": "summarize code:\ndef is_valid(\n    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool\n) -> bool:\n    \"\"\"\n    Check if a word can be placed at the given position.\n\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n    >>> is_valid(puzzle, 'word', 0, 0, True)\n    True\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n    >>> is_valid(puzzle, 'word', 0, 0, False)\n    True\n    \"\"\"\n    for i in range(len(word)):\n        if vertical:\n            if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":\n                return False\n        elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":\n            return False\n    return True", "output": "Check if a word can be placed at the given position."}
{"input": "summarize code:\ndef f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2", "output": "This is the function to integrate, f(x) = (x - 0)^2 = x^2."}
{"input": "summarize code:\ndef softplus(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the Softplus activation function.\n\n    Parameters:\n        vector (np.ndarray): The input array for the Softplus activation.\n\n    Returns:\n        np.ndarray: The input array after applying the Softplus activation.\n\n    Formula: f(x) = ln(1 + e^x)\n\n    Examples:\n    >>> softplus(np.array([2.3, 0.6, -2, -3.8]))\n    array([2.39554546, 1.03748795, 0.12692801, 0.02212422])\n\n    >>> softplus(np.array([-9.2, -0.3, 0.45, -4.56]))\n    array([1.01034298e-04, 5.54355244e-01, 9.43248946e-01, 1.04077103e-02])\n    \"\"\"\n    return np.log(1 + np.exp(vector))", "output": "Implements the Softplus activation function."}
{"input": "summarize code:\ndef find_python_set(node: Node) -> set:\n    \"\"\"\n    Return a Python Standard Library set that contains i.\n    \"\"\"\n    sets = ({0, 1, 2}, {3, 4, 5})\n    for s in sets:\n        if node.data in s:\n            return s\n    msg = f\"{node.data} is not in {sets}\"\n    raise ValueError(msg)", "output": "Return a Python Standard Library set that contains i."}
{"input": "search code:\nNormalizes a 1D array, between ranges 0-cap.\nChoices:\n0: def zero_vector(dimension: int) -> Vector:\n    \"\"\"\n    returns a zero-vector of size 'dimension'\n    \"\"\"\n    # precondition\n    assert isinstance(dimension, int)\n    return Vector([0] * dimension)\n1: def normalize_array(array: np.ndarray, cap: float = 1) -> np.ndarray:\n    \"\"\"Normalizes a 1D array, between ranges 0-cap.\n\n    Args:\n        array: List containing values to be normalized between cap range.\n        cap: Maximum cap amount for normalization.\n    Returns:\n        return 1D numpy array, corresponding to limited range array\n\n    Examples:\n        >>> normalize_array(np.array([2, 3, 5, 7]))\n        array([0. , 0.2, 0.6, 1. ])\n        >>> normalize_array(np.array([[5], [7], [11], [13]]))\n        array([[0.  ],\n               [0.25],\n               [0.75],\n               [1.  ]])\n    \"\"\"\n    diff = np.max(array) - np.min(array)\n    return (array - np.min(array)) / (1 if diff == 0 else diff) * cap\n2: def find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer", "output": "1"}
{"input": "search code:\nColor-coding taking the relative distance into account. The Mandelbrot set is black.\nChoices:\n0: def get_color_coded_rgb(distance: float) -> tuple:\n    \"\"\"\n    Color-coding taking the relative distance into account. The Mandelbrot set\n    is black.\n\n    >>> get_color_coded_rgb(0)\n    (255, 0, 0)\n    >>> get_color_coded_rgb(0.5)\n    (0, 255, 255)\n    >>> get_color_coded_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return tuple(round(i * 255) for i in colorsys.hsv_to_rgb(distance, 1, 1))\n1: def is_proth_number(number: int) -> bool:\n    \"\"\"\n    :param number: positive integer number\n    :return: true if number is a Proth number, false otherwise\n    >>> is_proth_number(1)\n    False\n    >>> is_proth_number(2)\n    False\n    >>> is_proth_number(3)\n    True\n    >>> is_proth_number(4)\n    False\n    >>> is_proth_number(5)\n    True\n    >>> is_proth_number(34)\n    False\n    >>> is_proth_number(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=-1] must be > 0\n    >>> is_proth_number(6.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=6.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        message = f\"Input value of [{number=}] must be an integer\"\n        raise TypeError(message)\n\n    if number <= 0:\n        message = f\"Input value of [{number=}] must be > 0\"\n        raise ValueError(message)\n\n    if number == 1:\n        return False\n\n    number -= 1\n    n = 0\n    while number % 2 == 0:\n        n += 1\n        number //= 2\n    return number < 2**n\n2: def split_into(iterable, sizes):\n    \"\"\"Yield a list of sequential items from *iterable* of length 'n' for each\n    integer 'n' in *sizes*.\n\n        >>> list(split_into([1,2,3,4,5,6], [1,2,3]))\n        [[1], [2, 3], [4, 5, 6]]\n\n    If the sum of *sizes* is smaller than the length of *iterable*, then the\n    remaining items of *iterable* will not be returned.\n\n        >>> list(split_into([1,2,3,4,5,6], [2,3]))\n        [[1, 2], [3, 4, 5]]\n\n    If the sum of *sizes* is larger than the length of *iterable*, fewer items\n    will be returned in the iteration that overruns the *iterable* and further\n    lists will be empty:\n\n        >>> list(split_into([1,2,3,4], [1,2,3,4]))\n        [[1], [2, 3], [4], []]\n\n    When a ``None`` object is encountered in *sizes*, the returned list will\n    contain items up to the end of *iterable* the same way that\n    :func:`itertools.slice` does:\n\n        >>> list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))\n        [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]\n\n    :func:`split_into` can be useful for grouping a series of items where the\n    sizes of the groups are not uniform. An example would be where in a row\n    from a table, multiple columns represent elements of the same feature\n    (e.g. a point represented by x,y,z) but, the format is not the same for\n    all columns.\n    \"\"\"\n    # convert the iterable argument into an iterator so its contents can\n    # be consumed by islice in case it is a generator\n    it = iter(iterable)\n\n    for size in sizes:\n        if size is None:\n            yield list(it)\n            return\n        else:\n            yield list(islice(it, size))", "output": "0"}
{"input": "search code:\nLemma : if n|ab and gcd(a,n) = 1, then n|b.\nChoices:\n0: def diophantine_all_soln(a: int, b: int, c: int, n: int = 2) -> None:\n    \"\"\"\n    Lemma : if n|ab and gcd(a,n) = 1, then n|b.\n\n    Finding All solutions of Diophantine Equations:\n\n    Theorem : Let gcd(a,b) = d, a = d*p, b = d*q. If (x0,y0) is a solution of\n    Diophantine Equation a*x + b*y = c.  a*x0 + b*y0 = c, then all the\n    solutions have the form a(x0 + t*q) + b(y0 - t*p) = c,\n    where t is an arbitrary integer.\n\n    n is the number of solution you want, n = 2 by default\n\n    >>> diophantine_all_soln(10, 6, 14)\n    -7.0 14.0\n    -4.0 9.0\n\n    >>> diophantine_all_soln(10, 6, 14, 4)\n    -7.0 14.0\n    -4.0 9.0\n    -1.0 4.0\n    2.0 -1.0\n\n    >>> diophantine_all_soln(391, 299, -69, n = 4)\n    9.0 -12.0\n    22.0 -29.0\n    35.0 -46.0\n    48.0 -63.0\n\n    \"\"\"\n    (x0, y0) = diophantine(a, b, c)  # Initial value\n    d = greatest_common_divisor(a, b)\n    p = a // d\n    q = b // d\n\n    for i in range(n):\n        x = x0 + i * q\n        y = y0 - i * p\n        print(x, y)\n1: def double_sort(collection: list[Any]) -> list[Any]:\n    \"\"\"This sorting algorithm sorts an array using the principle of bubble sort,\n    but does it both from left to right and right to left.\n    Hence, it's called \"Double sort\"\n    :param collection: mutable ordered sequence of elements\n    :return: the same collection in ascending order\n    Examples:\n    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6 ,-7])\n    [-7, -6, -5, -4, -3, -2, -1]\n    >>> double_sort([])\n    []\n    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6])\n    [-6, -5, -4, -3, -2, -1]\n    >>> double_sort([-3, 10, 16, -42, 29]) == sorted([-3, 10, 16, -42, 29])\n    True\n    \"\"\"\n    no_of_elements = len(collection)\n    for _ in range(\n        int(((no_of_elements - 1) / 2) + 1)\n    ):  # we don't need to traverse to end of list as\n        for j in range(no_of_elements - 1):\n            # apply the bubble sort algorithm from left to right (or forwards)\n            if collection[j + 1] < collection[j]:\n                collection[j], collection[j + 1] = collection[j + 1], collection[j]\n            # apply the bubble sort algorithm from right to left (or backwards)\n            if collection[no_of_elements - 1 - j] < collection[no_of_elements - 2 - j]:\n                (\n                    collection[no_of_elements - 1 - j],\n                    collection[no_of_elements - 2 - j],\n                ) = (\n                    collection[no_of_elements - 2 - j],\n                    collection[no_of_elements - 1 - j],\n                )\n    return collection\n2: def unique_everseen(iterable, key=None):\n    \"\"\"\n    Yield unique elements, preserving order.\n\n        >>> list(unique_everseen('AAAABBBCCDAABBB'))\n        ['A', 'B', 'C', 'D']\n        >>> list(unique_everseen('ABBCcAD', str.lower))\n        ['A', 'B', 'C', 'D']\n\n    Sequences with a mix of hashable and unhashable items can be used.\n    The function will be slower (i.e., `O(n^2)`) for unhashable items.\n\n    Remember that ``list`` objects are unhashable - you can use the *key*\n    parameter to transform the list to a tuple (which is hashable) to\n    avoid a slowdown.\n\n        >>> iterable = ([1, 2], [2, 3], [1, 2])\n        >>> list(unique_everseen(iterable))  # Slow\n        [[1, 2], [2, 3]]\n        >>> list(unique_everseen(iterable, key=tuple))  # Faster\n        [[1, 2], [2, 3]]\n\n    Similarly, you may want to convert unhashable ``set`` objects with\n    ``key=frozenset``. For ``dict`` objects,\n    ``key=lambda x: frozenset(x.items())`` can be used.\n\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seenset:\n                seenset_add(k)\n                yield element\n        except TypeError:\n            if k not in seenlist:\n                seenlist_add(k)\n                yield element", "output": "0"}
{"input": "search code:\nRetrieve a value from a nested object via a tuple representing the lookup path.\nChoices:\n0: def get_path(root, path, default=_UNSET):\n    \"\"\"Retrieve a value from a nested object via a tuple representing the\n    lookup path.\n\n    >>> root = {'a': {'b': {'c': [[1], [2], [3]]}}}\n    >>> get_path(root, ('a', 'b', 'c', 2, 0))\n    3\n\n    The path tuple format is intentionally consistent with that of\n    :func:`remap`, but a single dotted string can also be passed.\n\n    One of get_path's chief aims is improved error messaging. EAFP is\n    great, but the error messages are not.\n\n    For instance, ``root['a']['b']['c'][2][1]`` gives back\n    ``IndexError: list index out of range``\n\n    What went out of range where? get_path currently raises\n    ``PathAccessError: could not access 2 from path ('a', 'b', 'c', 2,\n    1), got error: IndexError('list index out of range',)``, a\n    subclass of IndexError and KeyError.\n\n    You can also pass a default that covers the entire operation,\n    should the lookup fail at any level.\n\n    Args:\n       root: The target nesting of dictionaries, lists, or other\n          objects supporting ``__getitem__``.\n       path (tuple): A sequence of strings and integers to be successively\n          looked up within *root*. A dot-separated (``a.b``) string may \n          also be passed.\n       default: The value to be returned should any\n          ``PathAccessError`` exceptions be raised.\n    \"\"\"\n    if isinstance(path, str):\n        path = path.split('.')\n    cur = root\n    try:\n        for seg in path:\n            try:\n                cur = cur[seg]\n            except (KeyError, IndexError) as exc:\n                raise PathAccessError(exc, seg, path)\n            except TypeError as exc:\n                # either string index in a list, or a parent that\n                # doesn't support indexing\n                try:\n                    seg = int(seg)\n                    cur = cur[seg]\n                except (ValueError, KeyError, IndexError, TypeError):\n                    if not is_iterable(cur):\n                        exc = TypeError('%r object is not indexable'\n                                        % type(cur).__name__)\n                    raise PathAccessError(exc, seg, path)\n    except PathAccessError:\n        if default is _UNSET:\n            raise\n        return default\n    return cur\n1: def zigzag(root: Node | None) -> Generator[int]:\n    \"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    >>> list(zigzag(make_tree()))\n    [1, 3, 2, 4, 5]\n    \"\"\"\n    if root is None:\n        return\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        if not flag:\n            yield from get_nodes_from_left_to_right(root, h)\n            flag = 1\n        else:\n            yield from get_nodes_from_right_to_left(root, h)\n            flag = 0\n2: def insert_node(head: Node | None, data: int) -> Node:\n    \"\"\"\n    Insert a new node at the end of a linked list and return the new head.\n\n    Parameters:\n        head (Node | None): The head of the linked list.\n        data (int): The data to be inserted into the new node.\n\n    Returns:\n        Node: The new head of the linked list.\n\n    >>> head = insert_node(None, 10)\n    >>> head = insert_node(head, 9)\n    >>> head = insert_node(head, 8)\n    >>> print_linked_list(head)\n    10->9->8\n    \"\"\"\n    new_node = Node(data)\n    # If the linked list is empty, the new_node becomes the head\n    if head is None:\n        return new_node\n\n    temp_node = head\n    while temp_node.next_node:\n        temp_node = temp_node.next_node\n\n    temp_node.next_node = new_node\n    return head", "output": "0"}
{"input": "search code:\nConverts a string to capitalized case, preserving the input as is\nChoices:\n0: def in_reverse(linked_list: LinkedList) -> str:\n    \"\"\"Prints the elements of the given Linked List in reverse order\n    >>> in_reverse(LinkedList())\n    ''\n    >>> in_reverse(make_linked_list([69, 88, 73]))\n    '73 <- 88 <- 69'\n    \"\"\"\n    return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))\n1: def softmax(vector):\n    \"\"\"\n    Implements the softmax function\n\n    Parameters:\n        vector (np.array,list,tuple): A  numpy array of shape (1,n)\n        consisting of real values or a similar list,tuple\n\n\n    Returns:\n        softmax_vec (np.array): The input numpy array  after applying\n        softmax.\n\n    The softmax vector adds up to one. We need to ceil to mitigate for\n    precision\n    >>> float(np.ceil(np.sum(softmax([1,2,3,4]))))\n    1.0\n\n    >>> vec = np.array([5,5])\n    >>> softmax(vec)\n    array([0.5, 0.5])\n\n    >>> softmax([0])\n    array([1.])\n    \"\"\"\n\n    # Calculate e^x for each x in your vector where e is Euler's\n    # number (approximately 2.718)\n    exponent_vector = np.exp(vector)\n\n    # Add up the all the exponentials\n    sum_of_exponents = np.sum(exponent_vector)\n\n    # Divide every exponent by the sum of all exponents\n    softmax_vector = exponent_vector / sum_of_exponents\n\n    return softmax_vector\n2: def to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word", "output": "2"}
{"input": "search code:\nYield elements of the longest common prefix among given *iterables*.\nChoices:\n0: def solution(limit: int = 10000) -> int:\n    \"\"\"\n    Returns the count of all lychrel numbers below limit.\n    >>> solution(10000)\n    249\n    >>> solution(5000)\n    76\n    >>> solution(1000)\n    13\n    \"\"\"\n    lychrel_nums = []\n    for num in range(1, limit):\n        iterations = 0\n        a = num\n        while iterations < 50:\n            num = sum_reverse(num)\n            iterations += 1\n            if is_palindrome(num):\n                break\n        else:\n            lychrel_nums.append(a)\n    return len(lychrel_nums)\n1: def area_triangle(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle given the base and height.\n\n    >>> area_triangle(10, 10)\n    50.0\n    >>> area_triangle(1.6, 2.6)\n    2.08\n    >>> area_triangle(0, 0)\n    0.0\n    >>> area_triangle(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    >>> area_triangle(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    >>> area_triangle(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    \"\"\"\n    if base < 0 or height < 0:\n        raise ValueError(\"area_triangle() only accepts non-negative values\")\n    return (base * height) / 2\n2: def longest_common_prefix(iterables):\n    \"\"\"Yield elements of the longest common prefix among given *iterables*.\n\n    >>> ''.join(longest_common_prefix(['abcd', 'abc', 'abf']))\n    'ab'\n\n    \"\"\"\n    return (c[0] for c in takewhile(all_equal, zip(*iterables)))", "output": "2"}
{"input": "summarize code:\ndef solution(limit: float = 1e10) -> int:\n    \"\"\"\n    Returns the least value of n for which the remainder first exceeds 10^10.\n    >>> solution(1e8)\n    2371\n    >>> solution(1e9)\n    7037\n    \"\"\"\n    primes = sieve()\n\n    n = 1\n    while True:\n        prime = next(primes)\n        if (2 * prime * n) > limit:\n            return n\n        # Ignore the next prime as the reminder will be 2.\n        next(primes)\n        n += 2", "output": "Returns the least value of n for which the remainder first exceeds 10^10. >>> solution(1e8) 2371 >>> solution(1e9) 7037"}
{"input": "summarize code:\ndef decimal_isolate(number: float, digit_amount: int) -> float:\n    \"\"\"\n    Isolates the decimal part of a number.\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\n    >>> decimal_isolate(1.53, 0)\n    0.53\n    >>> decimal_isolate(35.345, 1)\n    0.3\n    >>> decimal_isolate(35.345, 2)\n    0.34\n    >>> decimal_isolate(35.345, 3)\n    0.345\n    >>> decimal_isolate(-14.789, 3)\n    -0.789\n    >>> decimal_isolate(0, 2)\n    0\n    >>> decimal_isolate(-14.123, 1)\n    -0.1\n    >>> decimal_isolate(-14.123, 2)\n    -0.12\n    >>> decimal_isolate(-14.123, 3)\n    -0.123\n    \"\"\"\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)", "output": "Isolates the decimal part of a number. If digitAmount > 0 round to that decimal place, else print the entire decimal. >>> decimal_isolate(1.53, 0) 0.53 >>> decimal_isolate(35.345, 1) 0.3 >>> decimal_isolate(35.345, 2) 0.34 >>> decimal_isolate(35.345, 3) 0.345 >>> decimal_isolate(-14.789, 3) -0.789 >>> decimal_isolate(0, 2) 0 >>> decimal_isolate(-14.123, 1) -0.1 >>> decimal_isolate(-14.123, 2) -0.12 >>> decimal_isolate(-14.123, 3) -0.123"}
{"input": "search code:\nPrune candidate itemsets that are not frequent. The goal of pruning is to filter out candidate itemsets that are not frequent. This is done by checking if all the (k-1) subsets of a candidate itemset are present in the frequent itemsets of the previous iteration (valid subsequences of the frequent itemsets from the previous iteration).\nChoices:\n0: def unique_in_window(iterable, n, key=None):\n    \"\"\"Yield the items from *iterable* that haven't been seen recently.\n    *n* is the size of the sliding window.\n\n        >>> iterable = [0, 1, 0, 2, 3, 0]\n        >>> n = 3\n        >>> list(unique_in_window(iterable, n))\n        [0, 1, 2, 3, 0]\n\n    The *key* function, if provided, will be used to determine uniqueness:\n\n        >>> list(unique_in_window('abAcda', 3, key=lambda x: x.lower()))\n        ['a', 'b', 'c', 'd', 'a']\n\n    Updates a sliding window no larger than n and yields a value\n    if the item only occurs once in the updated window.\n\n    When `n == 1`, *unique_in_window* is memoryless:\n\n        >>> list(unique_in_window('aab', n=1))\n        ['a', 'a', 'b']\n\n    The items in *iterable* must be hashable.\n\n    \"\"\"\n    if n <= 0:\n        raise ValueError('n must be greater than 0')\n\n    window = deque(maxlen=n)\n    counts = Counter()\n    use_key = key is not None\n\n    for item in iterable:\n        if len(window) == n:\n            to_discard = window[0]\n            if counts[to_discard] == 1:\n                del counts[to_discard]\n            else:\n                counts[to_discard] -= 1\n\n        k = key(item) if use_key else item\n        if k not in counts:\n            yield item\n        counts[k] += 1\n        window.append(k)\n1: def prune(itemset: list, candidates: list, length: int) -> list:\n    \"\"\"\n    Prune candidate itemsets that are not frequent.\n    The goal of pruning is to filter out candidate itemsets that are not frequent.  This\n    is done by checking if all the (k-1) subsets of a candidate itemset are present in\n    the frequent itemsets of the previous iteration (valid subsequences of the frequent\n    itemsets from the previous iteration).\n\n    Prunes candidate itemsets that are not frequent.\n\n    >>> itemset = ['X', 'Y', 'Z']\n    >>> candidates = [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]\n    >>> prune(itemset, candidates, 2)\n    [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]\n\n    >>> itemset = ['1', '2', '3', '4']\n    >>> candidates = ['1', '2', '4']\n    >>> prune(itemset, candidates, 3)\n    []\n    \"\"\"\n    itemset_counter = Counter(tuple(item) for item in itemset)\n    pruned = []\n    for candidate in candidates:\n        is_subsequence = True\n        for item in candidate:\n            item_tuple = tuple(item)\n            if (\n                item_tuple not in itemset_counter\n                or itemset_counter[item_tuple] < length - 1\n            ):\n                is_subsequence = False\n                break\n        if is_subsequence:\n            pruned.append(candidate)\n    return pruned\n2: def infer_positional_format_args(fstr):\n    \"\"\"Takes format strings with anonymous positional arguments, (e.g.,\n    \"{}\" and {:d}), and converts them into numbered ones for explicitness and\n    compatibility with 2.6.\n\n    Returns a string with the inferred positional arguments.\n    \"\"\"\n    # TODO: memoize\n    ret, max_anon = '', 0\n    # look for {: or {! or {. or {[ or {}\n    start, end, prev_end = 0, 0, 0\n    for match in _pos_farg_re.finditer(fstr):\n        start, end, group = match.start(), match.end(), match.group()\n        if prev_end < start:\n            ret += fstr[prev_end:start]\n        prev_end = end\n        if group == '{{' or group == '}}':\n            ret += group\n            continue\n        ret += f'{{{max_anon}{group[1:]}'\n        max_anon += 1\n    ret += fstr[prev_end:]\n    return ret", "output": "1"}
{"input": "summarize code:\ndef max_sum_in_array(array: list[int], k: int) -> int:\n    \"\"\"\n    Returns the maximum sum of k consecutive elements\n    >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]\n    >>> k = 4\n    >>> max_sum_in_array(arr, k)\n    24\n    >>> k = 10\n    >>> max_sum_in_array(arr,k)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid Input\n    >>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2]\n    >>> k = 4\n    >>> max_sum_in_array(arr, k)\n    27\n    \"\"\"\n    if len(array) < k or k < 0:\n        raise ValueError(\"Invalid Input\")\n    max_sum = current_sum = sum(array[:k])\n    for i in range(len(array) - k):\n        current_sum = current_sum - array[i] + array[i + k]\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "output": "Returns the maximum sum of k consecutive elements >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20] >>> k = 4 >>> max_sum_in_array(arr, k) 24 >>> k = 10 >>> max_sum_in_array(arr,k) Traceback (most recent call last): ... ValueError: Invalid Input >>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2] >>> k = 4 >>> max_sum_in_array(arr, k) 27"}
{"input": "search code:\nGenerates all possible combinations of k numbers out of 1 ... n using itertools.\nChoices:\n0: def _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):\n    \"\"\"\n    Constructs a top-down dynamic programming solution for the rod-cutting problem\n    via memoization.\n\n    Runtime: O(n^2)\n\n    Arguments\n    ---------\n\n    * `n`: int, the length of the rod\n    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n      price for a rod of length ``i``\n    * `max_rev`: list, the computed maximum revenue for a piece of rod.\n      ``max_rev[i]`` is the maximum revenue obtainable for a rod of length ``i``\n\n    Returns\n    -------\n\n    The maximum revenue obtainable for a rod of length `n` given the list of prices\n    for each piece.\n    \"\"\"\n    if max_rev[n] >= 0:\n        return max_rev[n]\n    elif n == 0:\n        return 0\n    else:\n        max_revenue = float(\"-inf\")\n        for i in range(1, n + 1):\n            max_revenue = max(\n                max_revenue,\n                prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),\n            )\n\n        max_rev[n] = max_revenue\n\n    return max_rev[n]\n1: def benchmark():\n    \"\"\"\n    Let's benchmark our functions side-by-side...\n    \"\"\"\n    from timeit import timeit\n\n    setup = \"from __main__ import slow_primes, primes, fast_primes\"\n    print(timeit(\"slow_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n    print(timeit(\"primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n    print(timeit(\"fast_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n2: def combination_lists(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    Generates all possible combinations of k numbers out of 1 ... n using itertools.\n\n    >>> combination_lists(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    return [list(x) for x in combinations(range(1, n + 1), k)]", "output": "2"}
{"input": "search code:\nProvides the derivative value of the sigmoid function.\nChoices:\n0: def ugly_numbers(n: int) -> int:\n    \"\"\"\n    Returns the nth ugly number.\n    >>> ugly_numbers(100)\n    1536\n    >>> ugly_numbers(0)\n    1\n    >>> ugly_numbers(20)\n    36\n    >>> ugly_numbers(-5)\n    1\n    >>> ugly_numbers(-5.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    \"\"\"\n    ugly_nums = [1]\n\n    i2, i3, i5 = 0, 0, 0\n    next_2 = ugly_nums[i2] * 2\n    next_3 = ugly_nums[i3] * 3\n    next_5 = ugly_nums[i5] * 5\n\n    for _ in range(1, n):\n        next_num = min(next_2, next_3, next_5)\n        ugly_nums.append(next_num)\n        if next_num == next_2:\n            i2 += 1\n            next_2 = ugly_nums[i2] * 2\n        if next_num == next_3:\n            i3 += 1\n            next_3 = ugly_nums[i3] * 3\n        if next_num == next_5:\n            i5 += 1\n            next_5 = ugly_nums[i5] * 5\n    return ugly_nums[-1]\n1: def sigmoid_derivative(value: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Provides the derivative value of the sigmoid function.\n\n    returns derivative of the sigmoid value\n\n    >>> sigmoid_derivative(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64))\n    array([[ 0.,  0., -2.],\n           [ 0.,  0.,  0.]])\n    \"\"\"\n    return (value) * (1 - (value))\n2: def transpose(it):\n    \"\"\"Swap the rows and columns of the input matrix.\n\n    >>> list(transpose([(1, 2, 3), (11, 22, 33)]))\n    [(1, 11), (2, 22), (3, 33)]\n\n    The caller should ensure that the dimensions of the input are compatible.\n    If the input is empty, no output will be produced.\n    \"\"\"\n    return zip(*it, strict=True)", "output": "1"}
{"input": "search code:\nComputes the largest eigenvalues and their corresponding eigenvectors using the Lanczos method.\nChoices:\n0: def netstring_server(server_socket):\n    \"A basic netstring server loop, supporting a few operations\"\n    try:\n        while True:\n            clientsock, addr = server_socket.accept()\n            client = NetstringSocket(clientsock)\n            while 1:\n                request = client.read_ns()\n                if request == b'close':\n                    clientsock.close()\n                    break\n                elif request == b'shutdown':\n                    return\n                elif request == b'reply4k':\n                    client.write_ns(b'a' * 4096)\n                elif request == b'ping':\n                    client.write_ns(b'pong')\n                elif request == b'reply128k':\n                    client.setmaxsize(128 * 1024)\n                    client.write_ns(b'huge' * 32 * 1024)  # 128kb\n                    client.setmaxsize(32768)  # back to default\n    except Exception as e:\n        print('netstring_server exiting with error: %r' % e)\n        raise\n1: def integer_square_root(num: int) -> int:\n    \"\"\"\n    Returns the integer square root of a non-negative integer num.\n    Args:\n        num: A non-negative integer.\n    Returns:\n        The integer square root of num.\n    Raises:\n        ValueError: If num is not an integer or is negative.\n    >>> [integer_square_root(i) for i in range(18)]\n    [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4]\n    >>> integer_square_root(625)\n    25\n    >>> integer_square_root(2_147_483_647)\n    46340\n    >>> from math import isqrt\n    >>> all(integer_square_root(i) == isqrt(i) for i in range(20))\n    True\n    >>> integer_square_root(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: num must be non-negative integer\n    >>> integer_square_root(1.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: num must be non-negative integer\n    >>> integer_square_root(\"0\")\n    Traceback (most recent call last):\n        ...\n    ValueError: num must be non-negative integer\n    \"\"\"\n    if not isinstance(num, int) or num < 0:\n        raise ValueError(\"num must be non-negative integer\")\n\n    if num < 2:\n        return num\n\n    left_bound = 0\n    right_bound = num // 2\n\n    while left_bound <= right_bound:\n        mid = left_bound + (right_bound - left_bound) // 2\n        mid_squared = mid * mid\n        if mid_squared == num:\n            return mid\n\n        if mid_squared < num:\n            left_bound = mid + 1\n        else:\n            right_bound = mid - 1\n\n    return right_bound\n2: def find_lanczos_eigenvectors(\n    graph: list[list[int | None]], num_eigenvectors: int\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"Computes the largest eigenvalues and their corresponding eigenvectors using the\n    Lanczos method.\n\n    Args:\n        graph: The graph as a list of adjacency lists.\n        num_eigenvectors: Number of largest eigenvalues and eigenvectors to compute.\n\n    Returns:\n        A tuple containing:\n            - eigenvalues: 1D array of the largest eigenvalues in descending order.\n            - eigenvectors: 2D array where each column is an eigenvector corresponding\n                            to an eigenvalue.\n\n    Raises:\n        ValueError: If the graph format is invalid or num_eigenvectors is out of bounds.\n\n    >>> eigenvalues, eigenvectors = find_lanczos_eigenvectors(\n    ...     [[1, 2], [0, 2], [0, 1]], 2\n    ... )\n    >>> len(eigenvalues) == 2 and eigenvectors.shape[1] == 2\n    True\n    \"\"\"\n    validate_adjacency_list(graph)\n    tridiagonal_matrix, orthonormal_basis = lanczos_iteration(graph, num_eigenvectors)\n    eigenvalues, eigenvectors = np.linalg.eigh(tridiagonal_matrix)\n    return eigenvalues[::-1], np.dot(orthonormal_basis, eigenvectors[:, ::-1])", "output": "2"}
{"input": "summarize code:\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True", "output": "Checks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number (i.e., if the result is true, then the number is indeed prime else it is not)."}
{"input": "summarize code:\ndef find_freq_subgraph_given_support(s, cluster, graph):\n    \"\"\"\n    find edges of multiple frequent subgraphs\n    \"\"\"\n    k = int(s / 100 * (len(cluster) - 1))\n    for i in cluster[k]:\n        my_dfs(graph, tuple(cluster[k][i]), ([\"Header\"],))", "output": "find edges of multiple frequent subgraphs"}
{"input": "search code:\nReturn the squared second norm of vector norm_squared(v) = sum(x * x for x in v)\nChoices:\n0: def f(x: float) -> float:\n    \"\"\"\n    function is f(x) = x^3 - 2x - 5\n    >>> f(2)\n    -1.0\n    \"\"\"\n    return math.pow(x, 3) - (2 * x) - 5\n1: def partition(arr: list[int], low: int, high: int) -> int:\n    \"\"\"\n    Partitions list based on the pivot element.\n\n    This function rearranges the elements in the input list 'elements' such that\n    all elements greater than or equal to the chosen pivot are on the right side\n    of the pivot, and all elements smaller than the pivot are on the left side.\n\n    Args:\n        arr: The list to be partitioned\n        low: The lower index of the list\n        high: The higher index of the list\n\n    Returns:\n        int: The index of pivot element after partitioning\n\n        Examples:\n        >>> partition([3, 1, 4, 5, 9, 2, 6, 5, 3, 5], 0, 9)\n        4\n        >>> partition([7, 1, 4, 5, 9, 2, 6, 5, 8], 0, 8)\n        1\n        >>> partition(['apple', 'cherry', 'date', 'banana'], 0, 3)\n        2\n        >>> partition([3.1, 1.2, 5.6, 4.7], 0, 3)\n        1\n    \"\"\"\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] >= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n2: def norm_squared(vector: ndarray) -> float:\n    \"\"\"\n    Return the squared second norm of vector\n    norm_squared(v) = sum(x * x for x in v)\n\n    Args:\n        vector (ndarray): input vector\n\n    Returns:\n        float: squared second norm of vector\n\n    >>> int(norm_squared([1, 2]))\n    5\n    >>> int(norm_squared(np.asarray([1, 2])))\n    5\n    >>> int(norm_squared([0, 0]))\n    0\n    \"\"\"\n    return np.dot(vector, vector)", "output": "2"}
{"input": "search code:\nFlatten a binary tree into a linked list in-place, where the linked list is represented using the right pointers of the tree nodes.\nChoices:\n0: def find_winner(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Find the winner of the Josephus problem for num_people and a step_size.\n\n    Args:\n        num_people (int): Number of people.\n        step_size (int): Step size for elimination.\n\n    Returns:\n        int: The position of the last person remaining (1-based index).\n\n    Examples:\n        >>> find_winner(7, 3)\n        4\n        >>> find_winner(10, 2)\n        5\n    \"\"\"\n    return josephus_recursive(num_people, step_size) + 1\n1: def flatten(root: TreeNode | None) -> None:\n    \"\"\"\n    Flatten a binary tree into a linked list in-place, where the linked list is\n    represented using the right pointers of the tree nodes.\n\n    Args:\n        root (TreeNode): The root of the binary tree to be flattened.\n\n    Examples:\n        >>> root = TreeNode(1)\n        >>> root.left = TreeNode(2)\n        >>> root.right = TreeNode(5)\n        >>> root.left.left = TreeNode(3)\n        >>> root.left.right = TreeNode(4)\n        >>> root.right.right = TreeNode(6)\n        >>> flatten(root)\n        >>> root.data\n        1\n        >>> root.right.right is None\n        False\n        >>> root.right.right = TreeNode(3)\n        >>> root.right.right.right is None\n        True\n    \"\"\"\n    if not root:\n        return\n\n    # Flatten the left subtree\n    flatten(root.left)\n\n    # Save the right subtree\n    right_subtree = root.right\n\n    # Make the left subtree the new right subtree\n    root.right = root.left\n    root.left = None\n\n    # Find the end of the new right subtree\n    current = root\n    while current.right:\n        current = current.right\n\n    # Append the original right subtree to the end\n    current.right = right_subtree\n\n    # Flatten the updated right subtree\n    flatten(right_subtree)\n2: def solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns perimeter with maximum solutions.\n    >>> solution(100)\n    90\n    >>> solution(200)\n    180\n    >>> solution(1000)\n    840\n    \"\"\"\n    triplets = pythagorean_triple(n)\n    return triplets.most_common(1)[0][0]", "output": "1"}
{"input": "search code:\nCalculate the length of the chain of non-repeating terms starting with n. Previous is a set containing the previous member of the chain. >>> chain_length(10101) 11 >>> chain_length(555) 20 >>> chain_length(178924) 39\nChoices:\n0: def first_molar_mass(\n    molar_mass: float, effusion_rate_1: float, effusion_rate_2: float\n) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    molar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n\n    Returns:\n    --------\n    >>> first_molar_mass(2, 1.408943, 0.709752)\n    0.507524\n    >>> first_molar_mass(-1, 2.016, 4.002)\n    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n    >>> first_molar_mass(1)\n    Traceback (most recent call last):\n      ...\n    TypeError: first_molar_mass() missing 2 required positional arguments: \\\n'effusion_rate_1' and 'effusion_rate_2'\n    >>> first_molar_mass(1, 2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: first_molar_mass() missing 1 required positional argument: \\\n'effusion_rate_2'\n    \"\"\"\n    return (\n        round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)\n        if validate(molar_mass, effusion_rate_1, effusion_rate_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )\n1: def chain_length(n: int, previous: set | None = None) -> int:\n    \"\"\"\n    Calculate the length of the chain of non-repeating terms starting with n.\n    Previous is a set containing the previous member of the chain.\n    >>> chain_length(10101)\n    11\n    >>> chain_length(555)\n    20\n    >>> chain_length(178924)\n    39\n    \"\"\"\n    previous = previous or set()\n    if n in CHAIN_LENGTH_CACHE:\n        return CHAIN_LENGTH_CACHE[n]\n    next_number = sum_digit_factorials(n)\n    if next_number in previous:\n        CHAIN_LENGTH_CACHE[n] = 0\n        return 0\n    else:\n        previous.add(n)\n        ret = 1 + chain_length(next_number, previous)\n        CHAIN_LENGTH_CACHE[n] = ret\n        return ret\n2: def pheromone_update(\n    pheromone: list[list[float]],\n    cities: dict[int, list[int]],\n    pheromone_evaporation: float,\n    ants_route: list[list[int]],\n    q: float,  # Pheromone system parameters Q, which is a constant\n    best_path: list[int],\n    best_distance: float,\n) -> tuple[list[list[float]], list[int], float]:\n    \"\"\"\n    Update pheromones on the route and update the best route\n    >>>\n    >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],\n    ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    ([[0.7, 4.235533905932737], [4.235533905932737, 0.7]], [0, 1, 0], 5.656854249492381)\n    >>> pheromone_update(pheromone=[],\n    ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    Traceback (most recent call last):\n      ...\n    IndexError: list index out of range\n    >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],\n    ...                  cities={}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    Traceback (most recent call last):\n      ...\n    KeyError: 0\n    \"\"\"\n    for a in range(len(cities)):  # Update the volatilization of pheromone on all routes\n        for b in range(len(cities)):\n            pheromone[a][b] *= pheromone_evaporation\n    for ant_route in ants_route:\n        total_distance = 0.0\n        for i in range(len(ant_route) - 1):  # Calculate total distance\n            total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])\n        delta_pheromone = q / total_distance\n        for i in range(len(ant_route) - 1):  # Update pheromones\n            pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone\n            pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][\n                ant_route[i + 1]\n            ]\n\n        if total_distance < best_distance:\n            best_path = ant_route\n            best_distance = total_distance\n\n    return pheromone, best_path, best_distance", "output": "1"}
{"input": "summarize code:\ndef my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:\n    \"\"\"\n    :param src: the source image, which should be a grayscale or color image.\n    :param ksize: the size of the kernel used to compute the Laplacian filter,\n                  which can be 1, 3, 5, or 7.\n\n    >>> my_laplacian(src=np.array([]), ksize=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: ksize must be in (1, 3, 5, 7)\n    \"\"\"\n    kernels = {\n        1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),\n        3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),\n        5: np.array(\n            [\n                [0, 0, -1, 0, 0],\n                [0, -1, -2, -1, 0],\n                [-1, -2, 16, -2, -1],\n                [0, -1, -2, -1, 0],\n                [0, 0, -1, 0, 0],\n            ]\n        ),\n        7: np.array(\n            [\n                [0, 0, 0, -1, 0, 0, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, -2, -7, -10, -7, -2, 0],\n                [-1, -3, -10, 68, -10, -3, -1],\n                [0, -2, -7, -10, -7, -2, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, 0, 0, -1, 0, 0, 0],\n            ]\n        ),\n    }\n    if ksize not in kernels:\n        msg = f\"ksize must be in {tuple(kernels)}\"\n        raise ValueError(msg)\n\n    # Apply the Laplacian kernel using convolution\n    return filter2D(\n        src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)\n    )", "output": ":param src: the source image, which should be a grayscale or color image. :param ksize: the size of the kernel used to compute the Laplacian filter, which can be 1, 3, 5, or 7."}
{"input": "summarize code:\ndef evaluate(expression):\n    \"\"\"\n    Evaluate a given expression in prefix notation.\n    Asserts that the given expression is valid.\n\n    >>> evaluate(\"+ 9 * 2 6\")\n    21\n    >>> evaluate(\"/ * 10 2 + 4 1 \")\n    4.0\n    >>> evaluate(\"2\")\n    2\n    >>> evaluate(\"+ * 2 3 / 8 4\")\n    8.0\n    \"\"\"\n    stack = []\n\n    # iterate over the string in reverse order\n    for c in expression.split()[::-1]:\n        # push operand to stack\n        if is_operand(c):\n            stack.append(int(c))\n\n        else:\n            # pop values from stack can calculate the result\n            # push the result onto the stack again\n            o1 = stack.pop()\n            o2 = stack.pop()\n            stack.append(operators[c](o1, o2))\n\n    return stack.pop()", "output": "Evaluate a given expression in prefix notation. Asserts that the given expression is valid."}
{"input": "search code:\nImplementation of ElfHash Algorithm, a variant of PJW hash function.\nChoices:\n0: def elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_\n1: def is_hermitian(matrix: np.ndarray) -> bool:\n    \"\"\"\n    Checks if a matrix is Hermitian.\n    >>> import numpy as np\n    >>> A = np.array([\n    ... [2,    2+1j, 4],\n    ... [2-1j,  3,  1j],\n    ... [4,    -1j,  1]])\n    >>> is_hermitian(A)\n    True\n    >>> A = np.array([\n    ... [2,    2+1j, 4+1j],\n    ... [2-1j,  3,  1j],\n    ... [4,    -1j,  1]])\n    >>> is_hermitian(A)\n    False\n    \"\"\"\n    return np.array_equal(matrix, matrix.conjugate().T)\n2: def count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions", "output": "0"}
{"input": "summarize code:\ndef print_solution(grid: Matrix) -> None:\n    \"\"\"\n    A function to print the solution in the form\n    of a 9x9 grid\n    \"\"\"\n    for row in grid:\n        for cell in row:\n            print(cell, end=\" \")\n        print()", "output": "A function to print the solution in the form of a 9x9 grid"}
{"input": "search code:\nInputs an array of integers representing the heights of bars, and returns the area of the largest rectangle that can be formed\nChoices:\n0: def wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]\n1: def main() -> None:\n    \"\"\"\n    Main function to create and simplify a K-Map.\n\n    >>> main()\n    [0, 1]\n    [1, 1]\n    Simplified Expression:\n    A'B + AB' + AB\n    \"\"\"\n    kmap = [[0, 1], [1, 1]]\n\n    # Manually generate the product of [0, 1] and [0, 1]\n\n    for row in kmap:\n        print(row)\n\n    print(\"Simplified Expression:\")\n    print(simplify_kmap(kmap))\n2: def largest_rectangle_area(heights: list[int]) -> int:\n    \"\"\"\n    Inputs an array of integers representing the heights of bars,\n    and returns the area of the largest rectangle that can be formed\n\n    >>> largest_rectangle_area([2, 1, 5, 6, 2, 3])\n    10\n\n    >>> largest_rectangle_area([2, 4])\n    4\n\n    >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6])\n    12\n\n    >>> largest_rectangle_area([1])\n    1\n    \"\"\"\n    stack: list[int] = []\n    max_area = 0\n    heights = [*heights, 0]  # make a new list by appending the sentinel 0\n    n = len(heights)\n\n    for i in range(n):\n        # make sure the stack remains in increasing order\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]  # height of the bar\n            # if stack is empty, it means entire width can be taken from index 0 to i-1\n            w = i if not stack else i - stack[-1] - 1  # calculate width\n            max_area = max(max_area, h * w)\n\n        stack.append(i)\n\n    return max_area", "output": "2"}
{"input": "summarize code:\ndef decode(ciphertext: str, key: str) -> str:\n    \"\"\"\n    Decode the input string using the provided key.\n\n    >>> decode(\"BMZFAZRZDH\", \"HAZARD\")\n    'FIREHAZARD'\n    >>> decode(\"HNBWBPQT\", \"AUTOMOBILE\")\n    'DRIVINGX'\n    >>> decode(\"SLYSSAQS\", \"CASTLE\")\n    'ATXTACKX'\n    \"\"\"\n\n    table = generate_table(key)\n    plaintext = \"\"\n\n    for char1, char2 in chunker(ciphertext, 2):\n        row1, col1 = divmod(table.index(char1), 5)\n        row2, col2 = divmod(table.index(char2), 5)\n\n        if row1 == row2:\n            plaintext += table[row1 * 5 + (col1 - 1) % 5]\n            plaintext += table[row2 * 5 + (col2 - 1) % 5]\n        elif col1 == col2:\n            plaintext += table[((row1 - 1) % 5) * 5 + col1]\n            plaintext += table[((row2 - 1) % 5) * 5 + col2]\n        else:  # rectangle\n            plaintext += table[row1 * 5 + col2]\n            plaintext += table[row2 * 5 + col1]\n\n    return plaintext", "output": "Decode the input string using the provided key."}
{"input": "search code:\nCapitalizes the first letter of a sentence or word.\nChoices:\n0: def solution(max_n: int = 100) -> int:\n    \"\"\"\n    Returns the sum of the digits in the numerator of the max-th convergent of\n    the continued fraction for e.\n\n    >>> solution(9)\n    13\n    >>> solution(10)\n    17\n    >>> solution(50)\n    91\n    \"\"\"\n    pre_numerator = 1\n    cur_numerator = 2\n\n    for i in range(2, max_n + 1):\n        temp = pre_numerator\n        e_cont = 2 * i // 3 if i % 3 == 0 else 1\n        pre_numerator = cur_numerator\n        cur_numerator = e_cont * pre_numerator + temp\n\n    return sum_digits(cur_numerator)\n1: def capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    return sentence[0].upper() + sentence[1:]\n2: def chain_length(n: int, previous: set | None = None) -> int:\n    \"\"\"\n    Calculate the length of the chain of non-repeating terms starting with n.\n    Previous is a set containing the previous member of the chain.\n    >>> chain_length(10101)\n    11\n    >>> chain_length(555)\n    20\n    >>> chain_length(178924)\n    39\n    \"\"\"\n    previous = previous or set()\n    if n in CHAIN_LENGTH_CACHE:\n        return CHAIN_LENGTH_CACHE[n]\n    next_number = sum_digit_factorials(n)\n    if next_number in previous:\n        CHAIN_LENGTH_CACHE[n] = 0\n        return 0\n    else:\n        previous.add(n)\n        ret = 1 + chain_length(next_number, previous)\n        CHAIN_LENGTH_CACHE[n] = ret\n        return ret", "output": "1"}
{"input": "search code:\nPure implementation of Tabu search algorithm for a Travelling Salesman Problem in Python.\nChoices:\n0: def main() -> None:\n    r\"\"\"\n    Mirror binary trees with the given root and returns the root\n\n    >>> tree = make_tree_nine()\n    >>> tuple(tree)\n    (7, 4, 8, 2, 5, 9, 1, 3, 6)\n    >>> tuple(tree.mirror())\n    (6, 3, 1, 9, 5, 2, 8, 4, 7)\n\n    nine_tree::\n\n            1\n           / \\\n          2   3\n         / \\   \\\n        4   5   6\n       / \\   \\\n      7   8   9\n\n    The mirrored tree looks like this::\n\n          1\n         / \\\n        3   2\n       /   / \\\n      6   5   4\n         /   / \\\n        9   8   7\n    \"\"\"\n    trees = {\"zero\": Node(0), \"seven\": make_tree_seven(), \"nine\": make_tree_nine()}\n    for name, tree in trees.items():\n        print(f\"      The {name} tree: {tuple(tree)}\")\n        # (0,)\n        # (4, 2, 5, 1, 6, 3, 7)\n        # (7, 4, 8, 2, 5, 9, 1, 3, 6)\n        print(f\"Mirror of {name} tree: {tuple(tree.mirror())}\")\n1: def compress_data(data_bits: str) -> str:\n    \"\"\"\n    Compresses given data_bits using Lempel-Ziv-Welch compression algorithm\n    and returns the result as a string\n    \"\"\"\n    lexicon = {\"0\": \"0\", \"1\": \"1\"}\n    result, curr_string = \"\", \"\"\n    index = len(lexicon)\n\n    for i in range(len(data_bits)):\n        curr_string += data_bits[i]\n        if curr_string not in lexicon:\n            continue\n\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n        add_key_to_lexicon(lexicon, curr_string, index, last_match_id)\n        index += 1\n        curr_string = \"\"\n\n    while curr_string != \"\" and curr_string not in lexicon:\n        curr_string += \"0\"\n\n    if curr_string != \"\":\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n\n    return result\n2: def tabu_search(\n    first_solution, distance_of_first_solution, dict_of_neighbours, iters, size\n):\n    \"\"\"\n    Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in\n    Python.\n\n    :param first_solution: The solution for the first iteration of Tabu search using\n        the redundant resolution strategy in a list.\n    :param distance_of_first_solution: The total distance that Travelling Salesman will\n        travel, if he follows the path in first_solution.\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n    :param iters: The number of iterations that Tabu search will execute.\n    :param size: The size of Tabu List.\n    :return best_solution_ever: The solution with the lowest distance that occurred\n        during the execution of Tabu search.\n    :return best_cost: The total distance that Travelling Salesman will travel, if he\n        follows the path in best_solution ever.\n    \"\"\"\n    count = 1\n    solution = first_solution\n    tabu_list = []\n    best_cost = distance_of_first_solution\n    best_solution_ever = solution\n\n    while count <= iters:\n        neighborhood = find_neighborhood(solution, dict_of_neighbours)\n        index_of_best_solution = 0\n        best_solution = neighborhood[index_of_best_solution]\n        best_cost_index = len(best_solution) - 1\n\n        found = False\n        while not found:\n            i = 0\n            while i < len(best_solution):\n                if best_solution[i] != solution[i]:\n                    first_exchange_node = best_solution[i]\n                    second_exchange_node = solution[i]\n                    break\n                i = i + 1\n\n            if [first_exchange_node, second_exchange_node] not in tabu_list and [\n                second_exchange_node,\n                first_exchange_node,\n            ] not in tabu_list:\n                tabu_list.append([first_exchange_node, second_exchange_node])\n                found = True\n                solution = best_solution[:-1]\n                cost = neighborhood[index_of_best_solution][best_cost_index]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_solution_ever = solution\n            else:\n                index_of_best_solution = index_of_best_solution + 1\n                best_solution = neighborhood[index_of_best_solution]\n\n        if len(tabu_list) >= size:\n            tabu_list.pop(0)\n\n        count = count + 1\n\n    return best_solution_ever, best_cost", "output": "2"}
{"input": "summarize code:\ndef process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:\n    \"\"\"Processes the game logic for the given matrix and moves.\n\n    Args:\n        size (int): Size of the game board.\n        matrix (List[str]): Initial game matrix.\n        moves (List[Tuple[int, int]]): List of moves as (x, y) coordinates.\n\n    Returns:\n        int: The total score obtained.\n    >>> process_game(3, ['aaa', 'bbb', 'ccc'], [(0, 0)])\n    6\n    \"\"\"\n\n    game_matrix = [list(row) for row in matrix]\n    total_score = 0\n\n    for move in moves:\n        pos_x, pos_y = move\n        game_matrix, score = play(game_matrix, pos_x, pos_y, size)\n        total_score += score\n\n    return total_score", "output": "Processes the game logic for the given matrix and moves."}
{"input": "summarize code:\ndef _is_scalar(value, stringlike=(str, bytes)):\n    \"Scalars are bytes, strings, and non-iterables.\"\n    try:\n        iter(value)\n    except TypeError:\n        return True\n    return isinstance(value, stringlike)", "output": "Scalars are bytes, strings, and non-iterables."}
{"input": "summarize code:\ndef validate_matrix_content(matrix: list[str], size: int) -> None:\n    \"\"\"\n    Validates that the number of elements in the matrix matches the given size.\n\n    >>> validate_matrix_content(['aaaa', 'aaaa', 'aaaa', 'aaaa'], 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: The matrix dont match with size.\n    >>> validate_matrix_content(['aa%', 'aaa', 'aaa'], 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Matrix rows can only contain letters and numbers.\n    >>> validate_matrix_content(['aaa', 'aaa', 'aaaa'], 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Each row in the matrix must have exactly 3 characters.\n    \"\"\"\n    print(matrix)\n    if len(matrix) != size:\n        raise ValueError(\"The matrix dont match with size.\")\n    for row in matrix:\n        if len(row) != size:\n            msg = f\"Each row in the matrix must have exactly {size} characters.\"\n            raise ValueError(msg)\n        if not all(char.isalnum() for char in row):\n            raise ValueError(\"Matrix rows can only contain letters and numbers.\")", "output": "Validates that the number of elements in the matrix matches the given size."}
{"input": "summarize code:\ndef check_bouncy(n: int) -> bool:\n    \"\"\"\n    Returns True if number is bouncy, False otherwise\n    >>> check_bouncy(6789)\n    False\n    >>> check_bouncy(-12345)\n    False\n    >>> check_bouncy(0)\n    False\n    >>> check_bouncy(6.74)\n    Traceback (most recent call last):\n        ...\n    ValueError: check_bouncy() accepts only integer arguments\n    >>> check_bouncy(132475)\n    True\n    >>> check_bouncy(34)\n    False\n    >>> check_bouncy(341)\n    True\n    >>> check_bouncy(47)\n    False\n    >>> check_bouncy(-12.54)\n    Traceback (most recent call last):\n        ...\n    ValueError: check_bouncy() accepts only integer arguments\n    >>> check_bouncy(-6548)\n    True\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"check_bouncy() accepts only integer arguments\")\n    str_n = str(n)\n    sorted_str_n = \"\".join(sorted(str_n))\n    return str_n not in {sorted_str_n, sorted_str_n[::-1]}", "output": "Returns True if number is bouncy, False otherwise >>> check_bouncy(6789) False >>> check_bouncy(-12345) False >>> check_bouncy(0) False >>> check_bouncy(6.74) Traceback (most recent call last): ... ValueError: check_bouncy() accepts only integer arguments >>> check_bouncy(132475) True >>> check_bouncy(34) False >>> check_bouncy(341) True >>> check_bouncy(47) False >>> check_bouncy(-12.54) Traceback (most recent call last): ... ValueError: check_bouncy() accepts only integer arguments >>> check_bouncy(-6548) True"}
{"input": "search code:\nIf *filename.ext* exists, it will be moved to *filename.1.ext*, with all conflicting filenames being moved up by one, dropping any files beyond *keep*.\nChoices:\n0: def get_module_callables(mod, ignore=None):\n    \"\"\"Returns two maps of (*types*, *funcs*) from *mod*, optionally\n    ignoring based on the :class:`bool` return value of the *ignore*\n    callable. *mod* can be a string name of a module in\n    :data:`sys.modules` or the module instance itself.\n    \"\"\"\n    if isinstance(mod, str):\n        mod = sys.modules[mod]\n    types, funcs = {}, {}\n    for attr_name in dir(mod):\n        if ignore and ignore(attr_name):\n            continue\n        try:\n            attr = getattr(mod, attr_name)\n        except Exception:\n            continue\n        try:\n            attr_mod_name = attr.__module__\n        except AttributeError:\n            continue\n        if attr_mod_name != mod.__name__:\n            continue\n        if isinstance(attr, type):\n            types[attr_name] = attr\n        elif callable(attr):\n            funcs[attr_name] = attr\n    return types, funcs\n1: def xnor_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate XOR of the input values\n    >>> xnor_gate(0, 0)\n    1\n    >>> xnor_gate(0, 1)\n    0\n    >>> xnor_gate(1, 0)\n    0\n    >>> xnor_gate(1, 1)\n    1\n    \"\"\"\n    return 1 if input_1 == input_2 else 0\n2: def rotate_file(filename, *, keep: int = 5):\n    \"\"\"\n    If *filename.ext* exists, it will be moved to *filename.1.ext*, \n    with all conflicting filenames being moved up by one, dropping any files beyond *keep*.\n\n    After rotation, *filename* will be available for creation as a new file.\n\n    Fails if *filename* is not a file or if *keep* is not > 0.\n    \"\"\"\n    if keep < 1:\n        raise ValueError(f'expected \"keep\" to be >=1, not {keep}')\n    if not os.path.exists(filename):\n        return\n    if not os.path.isfile(filename):\n        raise ValueError(f'expected {filename} to be a file')\n\n    fn_root, fn_ext = os.path.splitext(filename)\n    kept_names = []\n    for i in range(1, keep + 1):\n        if fn_ext:\n            kept_names.append(f'{fn_root}.{i}{fn_ext}')\n        else:\n            kept_names.append(f'{fn_root}.{i}')\n\n    fns = [filename] + kept_names\n    for orig_name, kept_name in reversed(list(zip(fns, fns[1:]))):\n        if not os.path.exists(orig_name):\n            continue\n        os.rename(orig_name, kept_name)\n\n    if os.path.exists(kept_names[-1]):\n        os.remove(kept_names[-1])\n\n    return", "output": "2"}
{"input": "summarize code:\ndef level_order(root: Node | None) -> Generator[int]:\n    \"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    >>> list(level_order(make_tree()))\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    if root is None:\n        return\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        yield node.data\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)", "output": "Returns a list of nodes value from a whole binary tree in Level Order Traverse. Level Order traverse: Visit nodes of the tree level-by-level. >>> list(level_order(make_tree())) [1, 2, 3, 4, 5]"}
{"input": "summarize code:\ndef fix_print_exception():\n    \"\"\"\n    Sets the default exception hook :func:`sys.excepthook` to the\n    :func:`tbutils.print_exception` that uses all the ``tbutils``\n    facilities to provide a consistent output behavior.\n    \"\"\"\n    sys.excepthook = print_exception", "output": "Sets the default exception hook :func:`sys.excepthook` to the :func:`tbutils.print_exception` that uses all the ``tbutils`` facilities to provide a consistent output behavior."}
{"input": "search code:\nHigh-Low threshold detection. If an edge pixel's gradient value is higher than the high threshold value, it is marked as a strong edge pixel. If an edge pixel's gradient value is smaller than the high threshold value and larger than the low threshold value, it is marked as a weak edge pixel. If an edge pixel's value is smaller than the low threshold value, it will be suppressed.\nChoices:\n0: def detect_high_low_threshold(\n    image_shape, destination, threshold_low, threshold_high, weak, strong\n):\n    \"\"\"\n    High-Low threshold detection. If an edge pixel's gradient value is higher\n    than the high threshold value, it is marked as a strong edge pixel. If an\n    edge pixel's gradient value is smaller than the high threshold value and\n    larger than the low threshold value, it is marked as a weak edge pixel. If\n    an edge pixel's value is smaller than the low threshold value, it will be\n    suppressed.\n    \"\"\"\n    for row in range(1, image_shape[0] - 1):\n        for col in range(1, image_shape[1] - 1):\n            if destination[row, col] >= threshold_high:\n                destination[row, col] = strong\n            elif destination[row, col] <= threshold_low:\n                destination[row, col] = 0\n            else:\n                destination[row, col] = weak\n1: def beta(velocity: float) -> float:\n    \"\"\"\n    Calculates Î² = v/c, the given velocity as a fraction of c\n    >>> beta(c)\n    1.0\n    >>> beta(199792458)\n    0.666435904801848\n    >>> beta(1e5)\n    0.00033356409519815205\n    >>> beta(0.2)\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must be greater than or equal to 1!\n    \"\"\"\n    if velocity > c:\n        raise ValueError(\"Speed must not exceed light speed 299,792,458 [m/s]!\")\n    elif velocity < 1:\n        # Usually the speed should be much higher than 1 (c order of magnitude)\n        raise ValueError(\"Speed must be greater than or equal to 1!\")\n\n    return velocity / c\n2: def combination_lists(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    Generates all possible combinations of k numbers out of 1 ... n using itertools.\n\n    >>> combination_lists(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    return [list(x) for x in combinations(range(1, n + 1), k)]", "output": "0"}
{"input": "summarize code:\ndef solution(base: int = 800800, degree: int = 800800) -> int:\n    \"\"\"\n    Returns the number of hybrid-integers less than or equal to base^degree\n\n    >>> solution(800, 1)\n    2\n\n    >>> solution(800, 800)\n    10790\n    \"\"\"\n\n    upper_bound = degree * log2(base)\n    max_prime = int(upper_bound)\n    prime_numbers = calculate_prime_numbers(max_prime)\n\n    hybrid_integers_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left < right:\n        while (\n            prime_numbers[right] * log2(prime_numbers[left])\n            + prime_numbers[left] * log2(prime_numbers[right])\n            > upper_bound\n        ):\n            right -= 1\n        hybrid_integers_count += right - left\n        left += 1\n\n    return hybrid_integers_count", "output": "Returns the number of hybrid-integers less than or equal to base^degree"}
{"input": "search code:\nRecursive Backtracking Depth First Search Algorithm\nChoices:\n0: def _partition(data: list, pivot) -> tuple:\n    \"\"\"\n    Three way partition the data into smaller, equal and greater lists,\n    in relationship to the pivot\n    :param data: The data to be sorted (a list)\n    :param pivot: The value to partition the data on\n    :return: Three list: smaller, equal and greater\n    \"\"\"\n    less, equal, greater = [], [], []\n    for element in data:\n        if element < pivot:\n            less.append(element)\n        elif element > pivot:\n            greater.append(element)\n        else:\n            equal.append(element)\n    return less, equal, greater\n1: def height(root: Node | None) -> int:\n    \"\"\"\n    Recursive function for calculating the height of the binary tree.\n    >>> height(None)\n    0\n    >>> height(make_tree())\n    3\n    \"\"\"\n    return (max(height(root.left), height(root.right)) + 1) if root else 0\n2: def depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:\n    \"\"\"\n    Recursive Backtracking Depth First Search Algorithm\n\n    Starting from top left of a matrix, count the number of\n    paths that can reach the bottom right of a matrix.\n    1 represents a block (inaccessible)\n    0 represents a valid space (accessible)\n\n    0  0  0  0\n    1  1  0  0\n    0  0  0  1\n    0  1  0  0\n    >>> grid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n\n    0  0  0  0  0\n    0  1  1  1  0\n    0  1  1  1  0\n    0  0  0  0  0\n    >>> grid = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n    \"\"\"\n    row_length, col_length = len(grid), len(grid[0])\n    if (\n        min(row, col) < 0\n        or row == row_length\n        or col == col_length\n        or (row, col) in visit\n        or grid[row][col] == 1\n    ):\n        return 0\n    if row == row_length - 1 and col == col_length - 1:\n        return 1\n\n    visit.add((row, col))\n\n    count = 0\n    count += depth_first_search(grid, row + 1, col, visit)\n    count += depth_first_search(grid, row - 1, col, visit)\n    count += depth_first_search(grid, row, col + 1, visit)\n    count += depth_first_search(grid, row, col - 1, visit)\n\n    visit.remove((row, col))\n    return count", "output": "2"}
{"input": "summarize code:\ndef pdb_on_exception(limit=100):\n    \"\"\"Installs a handler which, instead of exiting, attaches a\n    post-mortem pdb console whenever an unhandled exception is\n    encountered.\n\n    Args:\n        limit (int): the max number of stack frames to display when\n            printing the traceback\n\n    A similar effect can be achieved from the command-line using the\n    following command::\n\n      python -m pdb your_code.py\n\n    But ``pdb_on_exception`` allows you to do this conditionally and within\n    your application. To restore default behavior, just do::\n\n      sys.excepthook = sys.__excepthook__\n    \"\"\"\n    import pdb\n    import sys\n    import traceback\n\n    def pdb_excepthook(exc_type, exc_val, exc_tb):\n        traceback.print_tb(exc_tb, limit=limit)\n        pdb.post_mortem(exc_tb)\n\n    sys.excepthook = pdb_excepthook\n    return", "output": "Installs a handler which, instead of exiting, attaches a post-mortem pdb console whenever an unhandled exception is encountered."}
{"input": "search code:\nSolve the Fractional Cover Problem.\nChoices:\n0: def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])\n1: def fractional_cover(items: list[Item], capacity: int) -> float:\n    \"\"\"\n    Solve the Fractional Cover Problem.\n\n    Args:\n        items: A list of items, where each item has weight and value attributes.\n        capacity: The maximum weight capacity of the knapsack.\n\n    Returns:\n        The maximum value that can be obtained by selecting fractions of items to cover\n        the knapsack's capacity.\n\n    Raises:\n        ValueError: If capacity is negative.\n\n    Examples:\n    >>> fractional_cover((Item(10, 60), Item(20, 100), Item(30, 120)), capacity=50)\n    240.0\n\n    >>> fractional_cover([Item(20, 100), Item(30, 120), Item(10, 60)], capacity=25)\n    135.0\n\n    >>> fractional_cover([Item(10, 60), Item(20, 100), Item(30, 120)], capacity=60)\n    280.0\n\n    >>> fractional_cover(items=[Item(5, 30), Item(10, 60), Item(15, 90)], capacity=30)\n    180.0\n\n    >>> fractional_cover(items=[], capacity=50)\n    0.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=5)\n    30.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=1)\n    6.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=0)\n    0.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacity cannot be negative\n    \"\"\"\n    if capacity < 0:\n        raise ValueError(\"Capacity cannot be negative\")\n\n    total_value = 0.0\n    remaining_capacity = capacity\n\n    # Sort the items by their value-to-weight ratio in descending order\n    for item in sorted(items, key=attrgetter(\"ratio\"), reverse=True):\n        if remaining_capacity == 0:\n            break\n\n        weight_taken = min(item.weight, remaining_capacity)\n        total_value += weight_taken * item.ratio\n        remaining_capacity -= weight_taken\n\n    return total_value\n2: def split_after(iterable, pred, maxsplit=-1):\n    \"\"\"Yield lists of items from *iterable*, where each list ends with an\n    item where callable *pred* returns ``True``:\n\n        >>> list(split_after('one1two2', lambda s: s.isdigit()))\n        [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0))\n        [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        buf.append(item)\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                buf = list(it)\n                if buf:\n                    yield buf\n                return\n            buf = []\n            maxsplit -= 1\n    if buf:\n        yield buf", "output": "1"}
{"input": "search code:\nReturns a list of frequent itemsets and their support counts.\nChoices:\n0: def max_subarray(\n    arr: Sequence[float], low: int, high: int\n) -> tuple[int | None, int | None, float]:\n    \"\"\"\n    Solves the maximum subarray problem using divide and conquer.\n    :param arr:     the given array of numbers\n    :param low:     the start index\n    :param high:    the end index\n    :return:        the start index of the maximum subarray, the end index of the\n                    maximum subarray, and the maximum subarray sum\n\n    >>> nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (3, 6, 6)\n    >>> nums = [2, 8, 9]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (0, 2, 19)\n    >>> nums = [0, 0]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (0, 0, 0)\n    >>> nums = [-1.0, 0.0, 1.0]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (2, 2, 1.0)\n    >>> nums = [-2, -3, -1, -4, -6]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (2, 2, -1)\n    >>> max_subarray([], 0, 0)\n    (None, None, 0)\n    \"\"\"\n    if not arr:\n        return None, None, 0\n    if low == high:\n        return low, high, arr[low]\n\n    mid = (low + high) // 2\n    left_low, left_high, left_sum = max_subarray(arr, low, mid)\n    right_low, right_high, right_sum = max_subarray(arr, mid + 1, high)\n    cross_left, cross_right, cross_sum = max_cross_sum(arr, low, mid, high)\n    if left_sum >= right_sum and left_sum >= cross_sum:\n        return left_low, left_high, left_sum\n    elif right_sum >= left_sum and right_sum >= cross_sum:\n        return right_low, right_high, right_sum\n    return cross_left, cross_right, cross_sum\n1: def apriori(data: list[list[str]], min_support: int) -> list[tuple[list[str], int]]:\n    \"\"\"\n    Returns a list of frequent itemsets and their support counts.\n\n    >>> data = [['A', 'B', 'C'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C']]\n    >>> apriori(data, 2)\n    [(['A', 'B'], 1), (['A', 'C'], 2), (['B', 'C'], 2)]\n\n    >>> data = [['1', '2', '3'], ['1', '2'], ['1', '3'], ['1', '4'], ['2', '3']]\n    >>> apriori(data, 3)\n    []\n    \"\"\"\n    itemset = [list(transaction) for transaction in data]\n    frequent_itemsets = []\n    length = 1\n\n    while itemset:\n        # Count itemset support\n        counts = [0] * len(itemset)\n        for transaction in data:\n            for j, candidate in enumerate(itemset):\n                if all(item in transaction for item in candidate):\n                    counts[j] += 1\n\n        # Prune infrequent itemsets\n        itemset = [item for i, item in enumerate(itemset) if counts[i] >= min_support]\n\n        # Append frequent itemsets (as a list to maintain order)\n        for i, item in enumerate(itemset):\n            frequent_itemsets.append((sorted(item), counts[i]))\n\n        length += 1\n        itemset = prune(itemset, list(combinations(itemset, length)), length)\n\n    return frequent_itemsets\n2: def summation_of_cost_derivative(index, end=m):\n    \"\"\"\n    Calculates the sum of cost function derivative\n    :param index: index wrt derivative is being calculated\n    :param end: value where summation ends, default is m, number of examples\n    :return: Returns the summation of cost derivative\n    Note: If index is -1, this means we are calculating summation wrt to biased\n        parameter.\n    \"\"\"\n    summation_value = 0\n    for i in range(end):\n        if index == -1:\n            summation_value += _error(i)\n        else:\n            summation_value += _error(i) * train_data[i][0][index]\n    return summation_value", "output": "1"}
{"input": "summarize code:\ndef breadth_first_search(graph: dict, start: str) -> list[str]:\n    \"\"\"\n    Implementation of breadth first search using queue.Queue.\n\n    >>> ''.join(breadth_first_search(G, 'A'))\n    'ABCDEF'\n    \"\"\"\n    explored = {start}\n    result = [start]\n    queue: Queue = Queue()\n    queue.put(start)\n    while not queue.empty():\n        v = queue.get()\n        for w in graph[v]:\n            if w not in explored:\n                explored.add(w)\n                result.append(w)\n                queue.put(w)\n    return result", "output": "Implementation of breadth first search using queue.Queue."}
{"input": "search code:\nA version of :func:`sorted` which will happily sort an iterable of heterogeneous types and return a new list, similar to legacy Python's behavior.\nChoices:\n0: def make_tree() -> Node | None:\n    r\"\"\"\n    The below tree\n        1\n       / \\\n      2   3\n     / \\\n    4   5\n    \"\"\"\n    tree = Node(1)\n    tree.left = Node(2)\n    tree.right = Node(3)\n    tree.left.left = Node(4)\n    tree.left.right = Node(5)\n    return tree\n1: def untyped_sorted(iterable, key=None, reverse=False):\n    \"\"\"A version of :func:`sorted` which will happily sort an iterable of\n    heterogeneous types and return a new list, similar to legacy Python's\n    behavior.\n\n    >>> untyped_sorted(['abc', 2.0, 1, 2, 'def'])\n    [1, 2.0, 2, 'abc', 'def']\n\n    Note how mutually orderable types are sorted as expected, as in\n    the case of the integers and floats above.\n\n    .. note::\n\n       Results may vary across Python versions and builds, but the\n       function will produce a sorted list, except in the case of\n       explicitly unorderable objects.\n\n    \"\"\"\n    class _Wrapper:\n        slots = ('obj',)\n\n        def __init__(self, obj):\n            self.obj = obj\n\n        def __lt__(self, other):\n            obj = key(self.obj) if key is not None else self.obj\n            other = key(other.obj) if key is not None else other.obj\n            try:\n                ret = obj < other\n            except TypeError:\n                ret = ((type(obj).__name__, id(type(obj)), obj)\n                       < (type(other).__name__, id(type(other)), other))\n            return ret\n\n    if key is not None and not callable(key):\n        raise TypeError('expected function or callable object for key, not: %r'\n                        % key)\n\n    return sorted(iterable, key=_Wrapper, reverse=reverse)\n2: def solution(max_base: int = 10, max_power: int = 22) -> int:\n    \"\"\"\n    Returns the count of all n-digit numbers which are nth power\n    >>> solution(10, 22)\n    49\n    >>> solution(0, 0)\n    0\n    >>> solution(1, 1)\n    0\n    >>> solution(-1, -1)\n    0\n    \"\"\"\n    bases = range(1, max_base)\n    powers = range(1, max_power)\n    return sum(\n        1 for power in powers for base in bases if len(str(base**power)) == power\n    )", "output": "1"}
{"input": "search code:\nThis function calculates the average of the waiting & turnaround times Prints: Average Waiting time & Average Turn Around Time >>> calculate_average_times([0,3,5,0],[3,6,10,1],4) Average waiting time = 2.00000 Average turn around time = 5.0 >>> calculate_average_times([2,3],[3,6],2) Average waiting time = 2.50000 Average turn around time = 4.5 >>> calculate_average_times([10,4,3],[2,7,6],3) Average waiting time = 5.66667 Average turn around time = 5.0\nChoices:\n0: def calculate_average_times(\n    waiting_time: list[int], turn_around_time: list[int], no_of_processes: int\n) -> None:\n    \"\"\"\n    This function calculates the average of the waiting & turnaround times\n    Prints: Average Waiting time & Average Turn Around Time\n    >>> calculate_average_times([0,3,5,0],[3,6,10,1],4)\n    Average waiting time = 2.00000\n    Average turn around time = 5.0\n    >>> calculate_average_times([2,3],[3,6],2)\n    Average waiting time = 2.50000\n    Average turn around time = 4.5\n    >>> calculate_average_times([10,4,3],[2,7,6],3)\n    Average waiting time = 5.66667\n    Average turn around time = 5.0\n    \"\"\"\n    total_waiting_time = 0\n    total_turn_around_time = 0\n    for i in range(no_of_processes):\n        total_waiting_time = total_waiting_time + waiting_time[i]\n        total_turn_around_time = total_turn_around_time + turn_around_time[i]\n    print(f\"Average waiting time = {total_waiting_time / no_of_processes:.5f}\")\n    print(\"Average turn around time =\", total_turn_around_time / no_of_processes)\n1: def solution() -> int:\n    \"\"\"\n    Returns the first integer whose square is of the form 1_2_3_4_5_6_7_8_9_0\n    \"\"\"\n    num = 138902663\n\n    while not is_square_form(num * num):\n        if num % 10 == 3:\n            num -= 6  # (3 - 6) % 10 = 7\n        else:\n            num -= 4  # (7 - 4) % 10 = 3\n\n    return num * 10\n2: def relu(vector: list[float]):\n    \"\"\"\n    Implements the relu function\n\n    Parameters:\n        vector (np.array,list,tuple): A  numpy array of shape (1,n)\n        consisting of real values or a similar list,tuple\n\n\n    Returns:\n        relu_vec (np.array): The input numpy array, after applying\n        relu.\n\n    >>> vec = np.array([-1, 0, 5])\n    >>> relu(vec)\n    array([0, 0, 5])\n    \"\"\"\n\n    # compare two arrays and then return element-wise maxima.\n    return np.maximum(0, vector)", "output": "0"}
{"input": "search code:\nReturns the `k_value` most frequently occurring words, in non-increasing order of occurrence. In this context, a word is defined as an element in the provided list.\nChoices:\n0: def top_k_frequent_words(words: list[str], k_value: int) -> list[str]:\n    \"\"\"\n    Returns the `k_value` most frequently occurring words,\n    in non-increasing order of occurrence.\n    In this context, a word is defined as an element in the provided list.\n\n    In case `k_value` is greater than the number of distinct words, a value of k equal\n    to the number of distinct words will be considered, instead.\n\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 3)\n    ['c', 'a', 'b']\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 2)\n    ['c', 'a']\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 1)\n    ['c']\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 0)\n    []\n    >>> top_k_frequent_words([], 1)\n    []\n    >>> top_k_frequent_words(['a', 'a'], 2)\n    ['a']\n    \"\"\"\n    heap: Heap[WordCount] = Heap()\n    count_by_word = Counter(words)\n    heap.build_max_heap(\n        [WordCount(word, count) for word, count in count_by_word.items()]\n    )\n    return [heap.extract_max().word for _ in range(min(k_value, len(count_by_word)))]\n1: def quick_select(arr: list, target: int) -> int:\n    \"\"\"\n    Two way partition the data into smaller and greater lists,\n    in relationship to the pivot\n    :param arr: The data to be searched (a list)\n    :param target: The rank to be searched\n    :return: element at rank target\n\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)\n    32\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)\n    2\n    >>> quick_select([5, 4, 3, 2], 2)\n    3\n    >>> quick_select([3, 5, 7, 10, 2, 12], 3)\n    5\n    \"\"\"\n\n    # Invalid Input\n    if target > len(arr):\n        return -1\n\n    # x is the estimated pivot by median of medians algorithm\n    x = median_of_medians(arr)\n    left = []\n    right = []\n    check = False\n    for i in range(len(arr)):\n        if arr[i] < x:\n            left.append(arr[i])\n        elif arr[i] > x:\n            right.append(arr[i])\n        elif arr[i] == x and not check:\n            check = True\n        else:\n            right.append(arr[i])\n    rank_x = len(left) + 1\n    if rank_x == target:\n        answer = x\n    elif rank_x > target:\n        answer = quick_select(left, target)\n    elif rank_x < target:\n        answer = quick_select(right, target - rank_x)\n    return answer\n2: def newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    Calculates force from `mass` and `acceleration`\n\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force", "output": "0"}
{"input": "search code:\nImplements the Softplus activation function.\nChoices:\n0: def surface_area_cube(side_length: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Cube.\n\n    >>> surface_area_cube(1)\n    6\n    >>> surface_area_cube(1.6)\n    15.360000000000003\n    >>> surface_area_cube(0)\n    0\n    >>> surface_area_cube(3)\n    54\n    >>> surface_area_cube(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cube() only accepts non-negative values\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"surface_area_cube() only accepts non-negative values\")\n    return 6 * side_length**2\n1: def softplus(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the Softplus activation function.\n\n    Parameters:\n        vector (np.ndarray): The input array for the Softplus activation.\n\n    Returns:\n        np.ndarray: The input array after applying the Softplus activation.\n\n    Formula: f(x) = ln(1 + e^x)\n\n    Examples:\n    >>> softplus(np.array([2.3, 0.6, -2, -3.8]))\n    array([2.39554546, 1.03748795, 0.12692801, 0.02212422])\n\n    >>> softplus(np.array([-9.2, -0.3, 0.45, -4.56]))\n    array([1.01034298e-04, 5.54355244e-01, 9.43248946e-01, 1.04077103e-02])\n    \"\"\"\n    return np.log(1 + np.exp(vector))\n2: def mps_speed_of_molecule(temperature: float, molar_mass: float) -> float:\n    \"\"\"\n    Takes the temperature (in K) and molar mass (in kg/mol) of a gas\n    and returns the most probable speed of a molecule in the gas (in m/s).\n\n    Examples:\n\n    >>> mps_speed_of_molecule(273, 0.028) # nitrogen at 273 K\n    402.65620702280023\n    >>> mps_speed_of_molecule(300, 0.032) # oxygen at 300 K\n    394.8368955535605\n    >>> mps_speed_of_molecule(-273, 0.028) # invalid temperature\n    Traceback (most recent call last):\n        ...\n    Exception: Absolute temperature cannot be less than 0 K\n    >>> mps_speed_of_molecule(273, 0) # invalid molar mass\n    Traceback (most recent call last):\n        ...\n    Exception: Molar mass should be greater than 0 kg/mol\n    \"\"\"\n\n    if temperature < 0:\n        raise Exception(\"Absolute temperature cannot be less than 0 K\")\n    if molar_mass <= 0:\n        raise Exception(\"Molar mass should be greater than 0 kg/mol\")\n    return (2 * R * temperature / molar_mass) ** 0.5", "output": "1"}
{"input": "search code:\nReturns the first integer whose square is of the form 1_2_3_4_5_6_7_8_9_0\nChoices:\n0: def chain(number: int) -> bool:\n    \"\"\"\n    The function generates the chain of numbers until the next number is 1 or 89.\n    For example, if starting number is 44, then the function generates the\n    following chain of numbers:\n    44 â†’ 32 â†’ 13 â†’ 10 â†’ 1 â†’ 1.\n    Once the next number generated is 1 or 89, the function returns whether\n    or not the next number generated by next_number() is 1.\n    >>> chain(10)\n    True\n    >>> chain(58)\n    False\n    >>> chain(1)\n    True\n    \"\"\"\n\n    if CHAINS[number - 1] is not None:\n        return CHAINS[number - 1]  # type: ignore[return-value]\n\n    number_chain = chain(next_number(number))\n    CHAINS[number - 1] = number_chain\n\n    while number < 10000000:\n        CHAINS[number - 1] = number_chain\n        number *= 10\n\n    return number_chain\n1: def solution() -> int:\n    \"\"\"\n    Returns the first integer whose square is of the form 1_2_3_4_5_6_7_8_9_0\n    \"\"\"\n    num = 138902663\n\n    while not is_square_form(num * num):\n        if num % 10 == 3:\n            num -= 6  # (3 - 6) % 10 = 7\n        else:\n            num -= 4  # (7 - 4) % 10 = 3\n\n    return num * 10\n2: def power_of_4(number: int) -> bool:\n    \"\"\"\n    Return True if this number is power of 4 or False otherwise.\n\n    >>> power_of_4(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: number must be positive\n    >>> power_of_4(1)\n    True\n    >>> power_of_4(2)\n    False\n    >>> power_of_4(4)\n    True\n    >>> power_of_4(6)\n    False\n    >>> power_of_4(8)\n    False\n    >>> power_of_4(17)\n    False\n    >>> power_of_4(64)\n    True\n    >>> power_of_4(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number must be positive\n    >>> power_of_4(1.2)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be an integer\n\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"number must be an integer\")\n    if number <= 0:\n        raise ValueError(\"number must be positive\")\n    if number & (number - 1) == 0:\n        c = 0\n        while number:\n            c += 1\n            number >>= 1\n        return c % 2 == 1\n    else:\n        return False", "output": "1"}
{"input": "search code:\nReturns the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9.\nChoices:\n0: def or_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate OR of the input values\n    >>> or_gate(0, 0)\n    0\n    >>> or_gate(0, 1)\n    1\n    >>> or_gate(1, 0)\n    1\n    >>> or_gate(1, 1)\n    1\n    \"\"\"\n    return int((input_1, input_2).count(1) != 0)\n1: def solution():\n    \"\"\"Returns the millionth lexicographic permutation of the digits 0, 1, 2,\n    3, 4, 5, 6, 7, 8 and 9.\n\n    >>> solution()\n    '2783915460'\n    \"\"\"\n    result = list(map(\"\".join, permutations(\"0123456789\")))\n    return result[999999]\n2: def all_equal(iterable, key=None):\n    \"\"\"\n    Returns ``True`` if all the elements are equal to each other.\n\n        >>> all_equal('aaaa')\n        True\n        >>> all_equal('aaab')\n        False\n\n    A function that accepts a single argument and returns a transformed version\n    of each input item can be specified with *key*:\n\n        >>> all_equal('AaaA', key=str.casefold)\n        True\n        >>> all_equal([1, 2, 3], key=lambda x: x < 10)\n        True\n\n    \"\"\"\n    iterator = groupby(iterable, key)\n    for first in iterator:\n        for second in iterator:\n            return False\n        return True\n    return True", "output": "1"}
{"input": "summarize code:\ndef sum_digit_factorials(n: int) -> int:\n    \"\"\"\n    Return the sum of the factorial of the digits of n.\n    >>> sum_digit_factorials(145)\n    145\n    >>> sum_digit_factorials(45361)\n    871\n    >>> sum_digit_factorials(540)\n    145\n    \"\"\"\n    if n in CACHE_SUM_DIGIT_FACTORIALS:\n        return CACHE_SUM_DIGIT_FACTORIALS[n]\n    ret = sum(DIGIT_FACTORIALS[let] for let in str(n))\n    CACHE_SUM_DIGIT_FACTORIALS[n] = ret\n    return ret", "output": "Return the sum of the factorial of the digits of n. >>> sum_digit_factorials(145) 145 >>> sum_digit_factorials(45361) 871 >>> sum_digit_factorials(540) 145"}
{"input": "search code:\nReturns the sum of all even fibonacci sequence elements that are lower or equal to n.\nChoices:\n0: def example(wav_file_path: str = \"./path-to-file/sample.wav\") -> np.ndarray:\n    \"\"\"\n    Example function to calculate Mel Frequency Cepstral Coefficients\n    (MFCCs) from an audio file.\n\n    Args:\n        wav_file_path: The path to the WAV audio file.\n\n    Returns:\n        np.ndarray: The computed MFCCs for the audio.\n    \"\"\"\n    from scipy.io import wavfile\n\n    # Load the audio from the WAV file\n    sample_rate, audio = wavfile.read(wav_file_path)\n\n    # Calculate MFCCs\n    return mfcc(audio, sample_rate)\n1: def gray_to_binary(gray: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return binary image from gray image\n\n    >>> gray_to_binary(np.array([[127, 255, 0]]))\n    array([[False,  True, False]])\n    >>> gray_to_binary(np.array([[0]]))\n    array([[False]])\n    >>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]]))\n    array([[False, False, False]])\n    >>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]]))\n    array([[False,  True, False],\n           [False,  True, False],\n           [False,  True, False]])\n    \"\"\"\n    return (gray > 127) & (gray <= 255)\n2: def solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    a = 0\n    b = 2\n    count = 0\n    while 4 * b + a <= n:\n        a, b = b, 4 * b + a\n        count += a\n    return count + b", "output": "2"}
{"input": "summarize code:\ndef parse_grid(grid):\n    \"\"\"\n    Convert grid to a dict of possible values, {square: digits}, or\n    return False if a contradiction is detected.\n    \"\"\"\n    ## To start, every square can be any digit; then assign values from the grid.\n    values = dict.fromkeys(squares, digits)\n    for s, d in grid_values(grid).items():\n        if d in digits and not assign(values, s, d):\n            return False  ## (Fail if we can't assign d to square s.)\n    return values", "output": "Convert grid to a dict of possible values, {square: digits}, or return False if a contradiction is detected."}
{"input": "search code:\nCeq = C1 + C2 + ... + Cn Calculate the equivalent resistance for any number of capacitors in parallel. >>> capacitor_parallel([5.71389, 12, 3]) 20.71389 >>> capacitor_parallel([5.71389, 12, -3]) Traceback (most recent call last): ... ValueError: Capacitor at index 2 has a negative value!\nChoices:\n0: def capacitor_parallel(capacitors: list[float]) -> float:\n    \"\"\"\n    Ceq = C1 + C2 + ... + Cn\n    Calculate the equivalent resistance for any number of capacitors in parallel.\n    >>> capacitor_parallel([5.71389, 12, 3])\n    20.71389\n    >>> capacitor_parallel([5.71389, 12, -3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitor at index 2 has a negative value!\n    \"\"\"\n    sum_c = 0.0\n    for index, capacitor in enumerate(capacitors):\n        if capacitor < 0:\n            msg = f\"Capacitor at index {index} has a negative value!\"\n            raise ValueError(msg)\n        sum_c += capacitor\n    return sum_c\n1: def calculate_turn_around_time(\n    process_name: list, arrival_time: list, burst_time: list, no_of_process: int\n) -> list:\n    \"\"\"\n    Calculate the turn around time of each processes\n\n    Return: The turn around time time for each process.\n    >>> calculate_turn_around_time([\"A\", \"B\", \"C\"], [3, 5, 8], [2, 4, 6], 3)\n    [2, 4, 7]\n    >>> calculate_turn_around_time([\"A\", \"B\", \"C\"], [0, 2, 4], [3, 5, 7], 3)\n    [3, 6, 11]\n    \"\"\"\n\n    current_time = 0\n    # Number of processes finished\n    finished_process_count = 0\n    # Displays the finished process.\n    # If it is 0, the performance is completed if it is 1, before the performance.\n    finished_process = [0] * no_of_process\n    # List to include calculation results\n    turn_around_time = [0] * no_of_process\n\n    # Sort by arrival time.\n    burst_time = [burst_time[i] for i in np.argsort(arrival_time)]\n    process_name = [process_name[i] for i in np.argsort(arrival_time)]\n    arrival_time.sort()\n\n    while no_of_process > finished_process_count:\n        \"\"\"\n        If the current time is less than the arrival time of\n        the process that arrives first among the processes that have not been performed,\n        change the current time.\n        \"\"\"\n        i = 0\n        while finished_process[i] == 1:\n            i += 1\n        current_time = max(current_time, arrival_time[i])\n\n        response_ratio = 0\n        # Index showing the location of the process being performed\n        loc = 0\n        # Saves the current response ratio.\n        temp = 0\n        for i in range(no_of_process):\n            if finished_process[i] == 0 and arrival_time[i] <= current_time:\n                temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[\n                    i\n                ]\n            if response_ratio < temp:\n                response_ratio = temp\n                loc = i\n\n        # Calculate the turn around time\n        turn_around_time[loc] = current_time + burst_time[loc] - arrival_time[loc]\n        current_time += burst_time[loc]\n        # Indicates that the process has been performed.\n        finished_process[loc] = 1\n        # Increase finished_process_count by 1\n        finished_process_count += 1\n\n    return turn_around_time\n2: def largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up approach.\n\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n    0\n\n    \"\"\"\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area", "output": "0"}
{"input": "summarize code:\ndef astar(world, start, goal):\n    \"\"\"\n    Implementation of a start algorithm.\n    world : Object of the world object.\n    start : Object of the cell as  start position.\n    stop  : Object of the cell as goal position.\n\n    >>> p = Gridworld()\n    >>> start = Cell()\n    >>> start.position = (0,0)\n    >>> goal = Cell()\n    >>> goal.position = (4,4)\n    >>> astar(p, start, goal)\n    [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\n    \"\"\"\n    _open = []\n    _closed = []\n    _open.append(start)\n\n    while _open:\n        min_f = np.argmin([n.f for n in _open])\n        current = _open[min_f]\n        _closed.append(_open.pop(min_f))\n        if current == goal:\n            break\n        for n in world.get_neighbours(current):\n            for c in _closed:\n                if c == n:\n                    continue\n            n.g = current.g + 1\n            x1, y1 = n.position\n            x2, y2 = goal.position\n            n.h = (y2 - y1) ** 2 + (x2 - x1) ** 2\n            n.f = n.h + n.g\n\n            for c in _open:\n                if c == n and c.f < n.f:\n                    continue\n            _open.append(n)\n    path = []\n    while current.parent is not None:\n        path.append(current.position)\n        current = current.parent\n    path.append(current.position)\n    return path[::-1]", "output": "Implementation of a start algorithm. world : Object of the world object. start : Object of the cell as start position. stop : Object of the cell as goal position."}
{"input": "search code:\nFinds the longest common subsequence between two strings. Also returns the The subsequence found\nChoices:\n0: def world_covid19_stats(\n    url: str = \"https://www.worldometers.info/coronavirus/\",\n) -> dict:\n    \"\"\"\n    Return a dict of current worldwide COVID-19 statistics\n    \"\"\"\n    soup = BeautifulSoup(\n        httpx.get(url, timeout=10, follow_redirects=True).text, \"html.parser\"\n    )\n    keys = soup.find_all(\"h1\")\n    values = soup.find_all(\"div\", {\"class\": \"maincounter-number\"})\n    keys += soup.find_all(\"span\", {\"class\": \"panel-title\"})\n    values += soup.find_all(\"div\", {\"class\": \"number-table-main\"})\n    return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}\n1: def intword(value, format=\"%.1f\"):\n    \"\"\"Converts a large integer to a friendly text representation.\n\n    Works best for numbers over 1 million. For example, 1_000_000 becomes \"1.0 million\",\n    1200000 becomes \"1.2 million\" and \"1_200_000_000\" becomes \"1.2 billion\". Supports up\n    to decillion (33 digits) and googol (100 digits).\n\n    Examples:\n        ```pycon\n        >>> intword(\"100\")\n        '100'\n        >>> intword(\"12400\")\n        '12.4 thousand'\n        >>> intword(\"1000000\")\n        '1.0 million'\n        >>> intword(1_200_000_000)\n        '1.2 billion'\n        >>> intword(8100000000000000000000000000000000)\n        '8.1 decillion'\n        >>> intword(None) is None\n        True\n        >>> intword(\"1234000\", \"%0.3f\")\n        '1.234 million'\n\n        ```\n    Args:\n        value (int, float, str): Integer to convert.\n        format (str): To change the number of decimal or general format of the number\n            portion.\n\n    Returns:\n        str: Friendly text representation as a string, unless the value passed could not\n        be coaxed into an `int`.\n    \"\"\"\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n\n    if value < powers[0]:\n        return str(value)\n    for ordinal, power in enumerate(powers[1:], 1):\n        if value < power:\n            chopped = value / float(powers[ordinal - 1])\n            if float(format % chopped) == float(10**3):\n                chopped = value / float(powers[ordinal])\n                singular, plural = human_powers[ordinal]\n                return (\n                    \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])\n                ) % chopped\n            else:\n                singular, plural = human_powers[ordinal - 1]\n                return (\n                    \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])\n                ) % chopped\n    return str(value)\n2: def longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq", "output": "2"}
{"input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    a = 3\n    result = 0\n    while a < n:\n        if a % 3 == 0 or a % 5 == 0:\n            result += a\n        elif a % 15 == 0:\n            result -= a\n        a += 1\n    return result", "output": "Returns the sum of all the multiples of 3 or 5 below n."}
{"input": "summarize code:\ndef inspect_formatargspec(\n        args, varargs=None, varkw=None, defaults=None,\n        kwonlyargs=(), kwonlydefaults={}, annotations={},\n        formatarg=str,\n        formatvarargs=lambda name: '*' + name,\n        formatvarkw=lambda name: '**' + name,\n        formatvalue=lambda value: '=' + repr(value),\n        formatreturns=lambda text: ' -> ' + text,\n        formatannotation=formatannotation):\n    \"\"\"Copy formatargspec from python 3.7 standard library.\n    Python 3 has deprecated formatargspec and requested that Signature\n    be used instead, however this requires a full reimplementation\n    of formatargspec() in terms of creating Parameter objects and such.\n    Instead of introducing all the object-creation overhead and having\n    to reinvent from scratch, just copy their compatibility routine.\n    \"\"\"\n\n    def formatargandannotation(arg):\n        result = formatarg(arg)\n        if arg in annotations:\n            result += ': ' + formatannotation(annotations[arg])\n        return result\n    specs = []\n    if defaults:\n        firstdefault = len(args) - len(defaults)\n    for i, arg in enumerate(args):\n        spec = formatargandannotation(arg)\n        if defaults and i >= firstdefault:\n            spec = spec + formatvalue(defaults[i - firstdefault])\n        specs.append(spec)\n    if varargs is not None:\n        specs.append(formatvarargs(formatargandannotation(varargs)))\n    else:\n        if kwonlyargs:\n            specs.append('*')\n    if kwonlyargs:\n        for kwonlyarg in kwonlyargs:\n            spec = formatargandannotation(kwonlyarg)\n            if kwonlydefaults and kwonlyarg in kwonlydefaults:\n                spec += formatvalue(kwonlydefaults[kwonlyarg])\n            specs.append(spec)\n    if varkw is not None:\n        specs.append(formatvarkw(formatargandannotation(varkw)))\n    result = '(' + ', '.join(specs) + ')'\n    if 'return' in annotations:\n        result += formatreturns(formatannotation(annotations['return']))\n    return result", "output": "Copy formatargspec from python 3.7 standard library. Python 3 has deprecated formatargspec and requested that Signature be used instead, however this requires a full reimplementation of formatargspec() in terms of creating Parameter objects and such. Instead of introducing all the object-creation overhead and having to reinvent from scratch, just copy their compatibility routine."}
{"input": "search code:\n- label_dir <type: str>: Path to label include annotation of images - img_dir <type: str>: Path to folder contain images Return <type: list>: List of images path and labels\nChoices:\n0: def interpolation_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"\n    Searches for an item in a sorted collection by interpolation search algorithm.\n\n    Args:\n        sorted_collection: sorted list of integers\n        item: item value to search\n\n    Returns:\n        int: The index of the found item, or None if the item is not found.\n    Examples:\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([1, 2, 3, 4, 5], 4)\n    3\n    >>> interpolation_search([1, 2, 3, 4, 5], 6) is None\n    True\n    >>> interpolation_search([], 1) is None\n    True\n    >>> interpolation_search([100], 100)\n    0\n    >>> interpolation_search([1, 2, 3, 4, 5], 0) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 7) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([1, 2, 3, 4, 5], 0) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 7) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([5, 5, 5, 5, 5], 3) is None\n    True\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        # avoid divided by 0 during interpolation\n        if sorted_collection[left] == sorted_collection[right]:\n            if sorted_collection[left] == item:\n                return left\n            return None\n\n        point = left + ((item - sorted_collection[left]) * (right - left)) // (\n            sorted_collection[right] - sorted_collection[left]\n        )\n\n        # out of range check\n        if point < 0 or point >= len(sorted_collection):\n            return None\n\n        current_item = sorted_collection[point]\n        if current_item == item:\n            return point\n        if point < left:\n            right = left\n            left = point\n        elif point > right:\n            left = right\n            right = point\n        elif item < current_item:\n            right = point - 1\n        else:\n            left = point + 1\n    return None\n1: def get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:\n    \"\"\"\n    - label_dir <type: str>: Path to label include annotation of images\n    - img_dir <type: str>: Path to folder contain images\n    Return <type: list>: List of images path and labels\n    \"\"\"\n    img_paths = []\n    labels = []\n    for label_file in glob.glob(os.path.join(label_dir, \"*.txt\")):\n        label_name = label_file.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        with open(label_file) as in_file:\n            obj_lists = in_file.readlines()\n        img_path = os.path.join(img_dir, f\"{label_name}.jpg\")\n\n        boxes = []\n        for obj_list in obj_lists:\n            obj = obj_list.rstrip(\"\\n\").split(\" \")\n            xmin = float(obj[1]) - float(obj[3]) / 2\n            ymin = float(obj[2]) - float(obj[4]) / 2\n            xmax = float(obj[1]) + float(obj[3]) / 2\n            ymax = float(obj[2]) + float(obj[4]) / 2\n\n            boxes.append([int(obj[0]), xmin, ymin, xmax, ymax])\n        if not boxes:\n            continue\n        img_paths.append(img_path)\n        labels.append(boxes)\n    return img_paths, labels\n2: def invert_modulo(a: int, n: int) -> int:\n    \"\"\"\n    This function find the inverses of a i.e., a^(-1)\n\n    >>> invert_modulo(2, 5)\n    3\n\n    >>> invert_modulo(8,7)\n    1\n\n    \"\"\"\n    (b, _x) = extended_euclid(a, n)  # Implemented below\n    if b < 0:\n        b = (b % n + n) % n\n    return b", "output": "1"}
{"input": "summarize code:\ndef crossover(parent_1: str, parent_2: str) -> tuple[str, str]:\n    \"\"\"\n    Slice and combine two strings at a random point.\n    >>> random.seed(42)\n    >>> crossover(\"123456\", \"abcdef\")\n    ('12345f', 'abcde6')\n    \"\"\"\n    random_slice = random.randint(0, len(parent_1) - 1)\n    child_1 = parent_1[:random_slice] + parent_2[random_slice:]\n    child_2 = parent_2[:random_slice] + parent_1[random_slice:]\n    return (child_1, child_2)", "output": "Slice and combine two strings at a random point. >>> random.seed(42) >>> crossover(\"123456\", \"abcdef\") ('12345f', 'abcde6')"}
{"input": "search code:\nTakes in an integer n and returns a n-bit gray code sequence An n-bit gray code sequence is a sequence of 2^n integers where:\nChoices:\n0: def random_vector(n: int, a: int, b: int) -> Vector:\n    \"\"\"\n    input: size (N) of the vector.\n           random range (a,b)\n    output: returns a random vector of size N, with\n            random integer components between 'a' and 'b'.\n    \"\"\"\n    random.seed(None)\n    ans = [random.randint(a, b) for _ in range(n)]\n    return Vector(ans)\n1: def gray_code(bit_count: int) -> list:\n    \"\"\"\n    Takes in an integer n and returns a n-bit\n    gray code sequence\n    An n-bit gray code sequence is a sequence of 2^n\n    integers where:\n\n    a) Every integer is between [0,2^n -1] inclusive\n    b) The sequence begins with 0\n    c) An integer appears at most one times in the sequence\n    d)The binary representation of every pair of integers differ\n       by exactly one bit\n    e) The binary representation of first and last bit also\n       differ by exactly one bit\n\n    >>> gray_code(2)\n    [0, 1, 3, 2]\n\n    >>> gray_code(1)\n    [0, 1]\n\n    >>> gray_code(3)\n    [0, 1, 3, 2, 6, 7, 5, 4]\n\n    >>> gray_code(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The given input must be positive\n\n    >>> gray_code(10.6)\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for <<: 'int' and 'float'\n    \"\"\"\n\n    # bit count represents no. of bits in the gray code\n    if bit_count < 0:\n        raise ValueError(\"The given input must be positive\")\n\n    # get the generated string sequence\n    sequence = gray_code_sequence_string(bit_count)\n    #\n    # convert them to integers\n    for i in range(len(sequence)):\n        sequence[i] = int(sequence[i], 2)\n\n    return sequence\n2: def multiply(\n    chain: list[int],\n    primes: list[int],\n    min_prime_idx: int,\n    prev_num: int,\n    max_num: int,\n    prev_sum: int,\n    primes_degrees: dict[int, int],\n) -> None:\n    \"\"\"\n    Run over all prime combinations to generate non-prime numbers.\n\n    >>> chain = [0] * 3\n    >>> primes_degrees = {}\n    >>> multiply(\n    ...     chain=chain,\n    ...     primes=[2],\n    ...     min_prime_idx=0,\n    ...     prev_num=1,\n    ...     max_num=2,\n    ...     prev_sum=0,\n    ...     primes_degrees=primes_degrees,\n    ... )\n    >>> chain\n    [0, 0, 1]\n    >>> primes_degrees\n    {2: 1}\n    \"\"\"\n\n    min_prime = primes[min_prime_idx]\n    num = prev_num * min_prime\n\n    min_prime_degree = primes_degrees.get(min_prime, 0)\n    min_prime_degree += 1\n    primes_degrees[min_prime] = min_prime_degree\n\n    new_sum = prev_sum * min_prime + (prev_sum + prev_num) * (min_prime - 1) // (\n        min_prime**min_prime_degree - 1\n    )\n    chain[num] = new_sum\n\n    for prime_idx in range(min_prime_idx, len(primes)):\n        if primes[prime_idx] * num > max_num:\n            break\n\n        multiply(\n            chain=chain,\n            primes=primes,\n            min_prime_idx=prime_idx,\n            prev_num=num,\n            max_num=max_num,\n            prev_sum=new_sum,\n            primes_degrees=primes_degrees.copy(),\n        )", "output": "1"}
{"input": "summarize code:\ndef try_key(ciphertext: list[int], key: tuple[int, ...]) -> str | None:\n    \"\"\"\n    Given an encrypted message and a possible 3-character key, decrypt the message.\n    If the decrypted message contains a invalid character, i.e. not an ASCII letter,\n    a digit, punctuation or whitespace, then we know the key is incorrect, so return\n    None.\n    >>> try_key([0, 17, 20, 4, 27], (104, 116, 120))\n    'hello'\n    >>> try_key([68, 10, 300, 4, 27], (104, 116, 120)) is None\n    True\n    \"\"\"\n    decoded: str = \"\"\n    keychar: int\n    cipherchar: int\n    decodedchar: int\n\n    for keychar, cipherchar in zip(cycle(key), ciphertext):\n        decodedchar = cipherchar ^ keychar\n        if decodedchar not in VALID_INTS:\n            return None\n        decoded += chr(decodedchar)\n\n    return decoded", "output": "Given an encrypted message and a possible 3-character key, decrypt the message. If the decrypted message contains a invalid character, i.e. not an ASCII letter, a digit, punctuation or whitespace, then we know the key is incorrect, so return None. >>> try_key([0, 17, 20, 4, 27], (104, 116, 120)) 'hello' >>> try_key([68, 10, 300, 4, 27], (104, 116, 120)) is None True"}
{"input": "search code:\nGiven Open Library book data, return a summary as a Python dict.\nChoices:\n0: def solution(n: int = 1000000):\n    \"\"\"Return the sum of all numbers, less than n , which are palindromic in\n    base 10 and base 2.\n\n    >>> solution(1000000)\n    872187\n    >>> solution(500000)\n    286602\n    >>> solution(100000)\n    286602\n    >>> solution(1000)\n    1772\n    >>> solution(100)\n    157\n    >>> solution(10)\n    25\n    >>> solution(2)\n    1\n    >>> solution(1)\n    0\n    \"\"\"\n    total = 0\n\n    for i in range(1, n):\n        if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):\n            total += i\n    return total\n1: def avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:\n    \"\"\"\n    This function is used to perform avgpooling on the input array of 2D matrix(image)\n    Args:\n        arr: numpy array\n        size: size of pooling matrix\n        stride: the number of pixels shifts over the input matrix\n    Returns:\n        numpy array of avgpooled matrix\n    Sample Input Output:\n    >>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)\n    array([[ 3.,  5.],\n           [11., 13.]])\n    >>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)\n    array([[161., 102.],\n           [114.,  69.]])\n    \"\"\"\n    arr = np.array(arr)\n    if arr.shape[0] != arr.shape[1]:\n        raise ValueError(\"The input array is not a square matrix\")\n    i = 0\n    j = 0\n    mat_i = 0\n    mat_j = 0\n\n    # compute the shape of the output matrix\n    avgpool_shape = (arr.shape[0] - size) // stride + 1\n    # initialize the output matrix with zeros of shape avgpool_shape\n    updated_arr = np.zeros((avgpool_shape, avgpool_shape))\n\n    while i < arr.shape[0]:\n        # if the end of the matrix is reached, break\n        if i + size > arr.shape[0]:\n            break\n        while j < arr.shape[1]:\n            # if the end of the matrix is reached, break\n            if j + size > arr.shape[1]:\n                break\n            # compute the average of the pooling matrix\n            updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))\n            # shift the pooling matrix by stride of column pixels\n            j += stride\n            mat_j += 1\n\n        # shift the pooling matrix by stride of row pixels\n        i += stride\n        mat_i += 1\n        # reset the column index to 0\n        j = 0\n        mat_j = 0\n\n    return updated_arr\n2: def summarize_book(ol_book_data: dict) -> dict:\n    \"\"\"\n    Given Open Library book data, return a summary as a Python dict.\n    \"\"\"\n    desired_keys = {\n        \"title\": \"Title\",\n        \"publish_date\": \"Publish date\",\n        \"authors\": \"Authors\",\n        \"number_of_pages\": \"Number of pages\",\n        \"isbn_10\": \"ISBN (10)\",\n        \"isbn_13\": \"ISBN (13)\",\n    }\n    data = {better_key: ol_book_data[key] for key, better_key in desired_keys.items()}\n    data[\"Authors\"] = [\n        get_openlibrary_data(author[\"key\"])[\"name\"] for author in data[\"Authors\"]\n    ]\n    for key, value in data.items():\n        if isinstance(value, list):\n            data[key] = \", \".join(value)\n    return data", "output": "2"}
{"input": "search code:\nFinds the most cost efficient sequence for converting one string into another.\nChoices:\n0: def pheromone_update(\n    pheromone: list[list[float]],\n    cities: dict[int, list[int]],\n    pheromone_evaporation: float,\n    ants_route: list[list[int]],\n    q: float,  # Pheromone system parameters Q, which is a constant\n    best_path: list[int],\n    best_distance: float,\n) -> tuple[list[list[float]], list[int], float]:\n    \"\"\"\n    Update pheromones on the route and update the best route\n    >>>\n    >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],\n    ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    ([[0.7, 4.235533905932737], [4.235533905932737, 0.7]], [0, 1, 0], 5.656854249492381)\n    >>> pheromone_update(pheromone=[],\n    ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    Traceback (most recent call last):\n      ...\n    IndexError: list index out of range\n    >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],\n    ...                  cities={}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    Traceback (most recent call last):\n      ...\n    KeyError: 0\n    \"\"\"\n    for a in range(len(cities)):  # Update the volatilization of pheromone on all routes\n        for b in range(len(cities)):\n            pheromone[a][b] *= pheromone_evaporation\n    for ant_route in ants_route:\n        total_distance = 0.0\n        for i in range(len(ant_route) - 1):  # Calculate total distance\n            total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])\n        delta_pheromone = q / total_distance\n        for i in range(len(ant_route) - 1):  # Update pheromones\n            pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone\n            pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][\n                ant_route[i + 1]\n            ]\n\n        if total_distance < best_distance:\n            best_path = ant_route\n            best_distance = total_distance\n\n    return pheromone, best_path, best_distance\n1: def compute_transform_tables(\n    source_string: str,\n    destination_string: str,\n    copy_cost: int,\n    replace_cost: int,\n    delete_cost: int,\n    insert_cost: int,\n) -> tuple[list[list[int]], list[list[str]]]:\n    \"\"\"\n    Finds the most cost efficient sequence\n    for converting one string into another.\n\n    >>> costs, operations = compute_transform_tables(\"cat\", \"cut\", 1, 2, 3, 3)\n    >>> costs[0][:4]\n    [0, 3, 6, 9]\n    >>> costs[2][:4]\n    [6, 4, 3, 6]\n    >>> operations[0][:4]\n    ['0', 'Ic', 'Iu', 'It']\n    >>> operations[3][:4]\n    ['Dt', 'Dt', 'Rtu', 'Ct']\n\n    >>> compute_transform_tables(\"\", \"\", 1, 2, 3, 3)\n    ([[0]], [['0']])\n    \"\"\"\n    source_seq = list(source_string)\n    destination_seq = list(destination_string)\n    len_source_seq = len(source_seq)\n    len_destination_seq = len(destination_seq)\n    costs = [\n        [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n    ops = [\n        [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n\n    for i in range(1, len_source_seq + 1):\n        costs[i][0] = i * delete_cost\n        ops[i][0] = f\"D{source_seq[i - 1]}\"\n\n    for i in range(1, len_destination_seq + 1):\n        costs[0][i] = i * insert_cost\n        ops[0][i] = f\"I{destination_seq[i - 1]}\"\n\n    for i in range(1, len_source_seq + 1):\n        for j in range(1, len_destination_seq + 1):\n            if source_seq[i - 1] == destination_seq[j - 1]:\n                costs[i][j] = costs[i - 1][j - 1] + copy_cost\n                ops[i][j] = f\"C{source_seq[i - 1]}\"\n            else:\n                costs[i][j] = costs[i - 1][j - 1] + replace_cost\n                ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])\n\n            if costs[i - 1][j] + delete_cost < costs[i][j]:\n                costs[i][j] = costs[i - 1][j] + delete_cost\n                ops[i][j] = f\"D{source_seq[i - 1]}\"\n\n            if costs[i][j - 1] + insert_cost < costs[i][j]:\n                costs[i][j] = costs[i][j - 1] + insert_cost\n                ops[i][j] = f\"I{destination_seq[j - 1]}\"\n\n    return costs, ops\n2: def bin_to_decimal(bin_string: str) -> int:\n    \"\"\"\n    Convert a binary value to its decimal equivalent\n\n    >>> bin_to_decimal(\"101\")\n    5\n    >>> bin_to_decimal(\" 1010   \")\n    10\n    >>> bin_to_decimal(\"-11101\")\n    -29\n    >>> bin_to_decimal(\"0\")\n    0\n    >>> bin_to_decimal(\"a\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    >>> bin_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> bin_to_decimal(\"39\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    \"\"\"\n    bin_string = str(bin_string).strip()\n    if not bin_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = bin_string[0] == \"-\"\n    if is_negative:\n        bin_string = bin_string[1:]\n    if not all(char in \"01\" for char in bin_string):\n        raise ValueError(\"Non-binary value was passed to the function\")\n    decimal_number = 0\n    for char in bin_string:\n        decimal_number = 2 * decimal_number + int(char)\n    return -decimal_number if is_negative else decimal_number", "output": "1"}
{"input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number num (i.e., if the result is true, then the number is indeed prime else it is not).\nChoices:\n0: def interpolation_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"\n    Searches for an item in a sorted collection by interpolation search algorithm.\n\n    Args:\n        sorted_collection: sorted list of integers\n        item: item value to search\n\n    Returns:\n        int: The index of the found item, or None if the item is not found.\n    Examples:\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([1, 2, 3, 4, 5], 4)\n    3\n    >>> interpolation_search([1, 2, 3, 4, 5], 6) is None\n    True\n    >>> interpolation_search([], 1) is None\n    True\n    >>> interpolation_search([100], 100)\n    0\n    >>> interpolation_search([1, 2, 3, 4, 5], 0) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 7) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([1, 2, 3, 4, 5], 0) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 7) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([5, 5, 5, 5, 5], 3) is None\n    True\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        # avoid divided by 0 during interpolation\n        if sorted_collection[left] == sorted_collection[right]:\n            if sorted_collection[left] == item:\n                return left\n            return None\n\n        point = left + ((item - sorted_collection[left]) * (right - left)) // (\n            sorted_collection[right] - sorted_collection[left]\n        )\n\n        # out of range check\n        if point < 0 or point >= len(sorted_collection):\n            return None\n\n        current_item = sorted_collection[point]\n        if current_item == item:\n            return point\n        if point < left:\n            right = left\n            left = point\n        elif point > right:\n            left = right\n            right = point\n        elif item < current_item:\n            right = point - 1\n        else:\n            left = point + 1\n    return None\n1: def perfect_square(num: int) -> bool:\n    \"\"\"\n    Check if a number is perfect square number or not\n    :param num: the number to be checked\n    :return: True if number is square number, otherwise False\n\n    >>> perfect_square(9)\n    True\n    >>> perfect_square(16)\n    True\n    >>> perfect_square(1)\n    True\n    >>> perfect_square(0)\n    True\n    >>> perfect_square(10)\n    False\n    \"\"\"\n    return math.sqrt(num) * math.sqrt(num) == num\n2: def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number num (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(-10)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True", "output": "2"}
{"input": "summarize code:\ndef solution(n: int = 20) -> int:\n    \"\"\"\n    Returns the smallest positive number that is evenly divisible (divisible\n    with no remainder) by all of the numbers from 1 to n.\n\n    >>> solution(10)\n    2520\n    >>> solution(15)\n    360360\n    >>> solution(22)\n    232792560\n    \"\"\"\n\n    g = 1\n    for i in range(1, n + 1):\n        g = lcm(g, i)\n    return g", "output": "Returns the smallest positive number that is evenly divisible (divisible with no remainder) by all of the numbers from 1 to n."}
{"input": "search code:\nreturns a unit basis vector with a One at index 'pos' (indexing at 0)\nChoices:\n0: def chain(number: int) -> bool:\n    \"\"\"\n    The function generates the chain of numbers until the next number is 1 or 89.\n    For example, if starting number is 44, then the function generates the\n    following chain of numbers:\n    44 â†’ 32 â†’ 13 â†’ 10 â†’ 1 â†’ 1.\n    Once the next number generated is 1 or 89, the function returns whether\n    or not the next number generated by next_number() is 1.\n    >>> chain(10)\n    True\n    >>> chain(58)\n    False\n    >>> chain(1)\n    True\n    \"\"\"\n\n    if CHAINS[number - 1] is not None:\n        return CHAINS[number - 1]  # type: ignore[return-value]\n\n    number_chain = chain(next_number(number))\n    CHAINS[number - 1] = number_chain\n\n    while number < 10000000:\n        CHAINS[number - 1] = number_chain\n        number *= 10\n\n    return number_chain\n1: def solution(limit: int = 100) -> int:\n    \"\"\"\n    Count the number of distinct ways a player can checkout with a score\n    less than limit.\n    >>> solution(171)\n    42336\n    >>> solution(50)\n    12577\n    \"\"\"\n    singles: list[int] = [*list(range(1, 21)), 25]\n    doubles: list[int] = [2 * x for x in range(1, 21)] + [50]\n    triples: list[int] = [3 * x for x in range(1, 21)]\n    all_values: list[int] = singles + doubles + triples + [0]\n\n    num_checkouts: int = 0\n    double: int\n    throw1: int\n    throw2: int\n    checkout_total: int\n\n    for double in doubles:\n        for throw1, throw2 in combinations_with_replacement(all_values, 2):\n            checkout_total = double + throw1 + throw2\n            if checkout_total < limit:\n                num_checkouts += 1\n\n    return num_checkouts\n2: def unit_basis_vector(dimension: int, pos: int) -> Vector:\n    \"\"\"\n    returns a unit basis vector with a One\n    at index 'pos' (indexing at 0)\n    \"\"\"\n    # precondition\n    assert isinstance(dimension, int)\n    assert isinstance(pos, int)\n    ans = [0] * dimension\n    ans[pos] = 1\n    return Vector(ans)", "output": "2"}
{"input": "search code:\nFind m for which the proportion of perfect partitions to total partitions is lower than max_proportion\nChoices:\n0: def graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:\n    \"\"\"Pure implementation of graham scan algorithm in Python\n\n    :param points: The unique points on coordinates.\n    :return: The points on convex hell.\n\n    Examples:\n    >>> graham_scan([(9, 6), (3, 1), (0, 0), (5, 5), (5, 2), (7, 0), (3, 3), (1, 4)])\n    [(0, 0), (7, 0), (9, 6), (5, 5), (1, 4)]\n\n    >>> graham_scan([(0, 0), (1, 0), (1, 1), (0, 1)])\n    [(0, 0), (1, 0), (1, 1), (0, 1)]\n\n    >>> graham_scan([(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)])\n    [(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)]\n\n    >>> graham_scan([(-100, 20), (99, 3), (1, 10000001), (5133186, -25), (-66, -4)])\n    [(5133186, -25), (1, 10000001), (-100, 20), (-66, -4)]\n    \"\"\"\n\n    if len(points) <= 2:\n        # There is no convex hull\n        raise ValueError(\"graham_scan: argument must contain more than 3 points.\")\n    if len(points) == 3:\n        return points\n    # find the lowest and the most left point\n    minidx = 0\n    miny, minx = maxsize, maxsize\n    for i, point in enumerate(points):\n        x = point[0]\n        y = point[1]\n        if y < miny:\n            miny = y\n            minx = x\n            minidx = i\n        if y == miny and x < minx:\n            minx = x\n            minidx = i\n\n    # remove the lowest and the most left point from points for preparing for sort\n    points.pop(minidx)\n\n    sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))\n    # This insert actually costs complexity,\n    # and you should instead add (minx, miny) into stack later.\n    # I'm using insert just for easy understanding.\n    sorted_points.insert(0, (minx, miny))\n\n    stack: deque[tuple[int, int]] = deque()\n    stack.append(sorted_points[0])\n    stack.append(sorted_points[1])\n    stack.append(sorted_points[2])\n    # The first 3 points lines are towards the left because we sort them by their angle\n    # from minx, miny.\n    current_direction = Direction.left\n\n    for i in range(3, len(sorted_points)):\n        while True:\n            starting = stack[-2]\n            via = stack[-1]\n            target = sorted_points[i]\n            next_direction = check_direction(starting, via, target)\n\n            if next_direction == Direction.left:\n                current_direction = Direction.left\n                break\n            if next_direction == Direction.straight:\n                if current_direction == Direction.left:\n                    # We keep current_direction as left.\n                    # Because if the straight line keeps as straight,\n                    # we want to know if this straight line is towards left.\n                    break\n                elif current_direction == Direction.right:\n                    # If the straight line is towards right,\n                    # every previous points on that straight line is not convex hull.\n                    stack.pop()\n            if next_direction == Direction.right:\n                stack.pop()\n        stack.append(sorted_points[i])\n    return list(stack)\n1: def solution(max_proportion: float = 1 / 12345) -> int:\n    \"\"\"\n    Find m for which the proportion of perfect partitions to total partitions is lower\n    than max_proportion\n\n    >>> solution(1) > 5\n    True\n\n    >>> solution(1/2) > 10\n    True\n\n    >>> solution(3 / 13) > 185\n    True\n\n    \"\"\"\n\n    total_partitions = 0\n    perfect_partitions = 0\n\n    integer = 3\n    while True:\n        partition_candidate = (integer**2 - 1) / 4\n        # if candidate is an integer, then there is a partition for k\n        if partition_candidate == int(partition_candidate):\n            partition_candidate = int(partition_candidate)\n            total_partitions += 1\n            if check_partition_perfect(partition_candidate):\n                perfect_partitions += 1\n        if (\n            perfect_partitions > 0\n            and perfect_partitions / total_partitions < max_proportion\n        ):\n            return int(partition_candidate)\n        integer += 1\n2: def solution(n: int = 600851475143) -> int:\n    \"\"\"\n    Returns the largest prime factor of a given number n.\n\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    i = 2\n    ans = 0\n    if n == 2:\n        return 2\n    while n > 2:\n        while n % i != 0:\n            i += 1\n        ans = i\n        while n % i == 0:\n            n = n // i\n        i += 1\n    return int(ans)", "output": "1"}
{"input": "summarize code:\ndef floor_ceiling(root: Node | None, key: int) -> tuple[int | None, int | None]:\n    \"\"\"\n    Find the floor and ceiling values for a given key in a Binary Search Tree (BST).\n\n    Args:\n        root: The root of the binary search tree.\n        key: The key for which to find the floor and ceiling.\n\n    Returns:\n        A tuple containing the floor and ceiling values, respectively.\n\n    Examples:\n        >>> root = Node(10)\n        >>> root.left = Node(5)\n        >>> root.right = Node(20)\n        >>> root.left.left = Node(3)\n        >>> root.left.right = Node(7)\n        >>> root.right.left = Node(15)\n        >>> root.right.right = Node(25)\n        >>> tuple(root)\n        (3, 5, 7, 10, 15, 20, 25)\n        >>> floor_ceiling(root, 8)\n        (7, 10)\n        >>> floor_ceiling(root, 14)\n        (10, 15)\n        >>> floor_ceiling(root, -1)\n        (None, 3)\n        >>> floor_ceiling(root, 30)\n        (25, None)\n    \"\"\"\n    floor_val = None\n    ceiling_val = None\n\n    while root:\n        if root.key == key:\n            floor_val = root.key\n            ceiling_val = root.key\n            break\n\n        if key < root.key:\n            ceiling_val = root.key\n            root = root.left\n        else:\n            floor_val = root.key\n            root = root.right\n\n    return floor_val, ceiling_val", "output": "Find the floor and ceiling values for a given key in a Binary Search Tree (BST)."}
{"input": "search code:\nReturns the sum of squarefrees for a given Pascal's Triangle of depth n.\nChoices:\n0: def base16_decode(data: str) -> bytes:\n    \"\"\"\n    Decodes the given base16 encoded data into bytes.\n\n    >>> base16_decode('48656C6C6F20576F726C6421')\n    b'Hello World!'\n    >>> base16_decode('48454C4C4F20574F524C4421')\n    b'HELLO WORLD!'\n    >>> base16_decode('')\n    b''\n    >>> base16_decode('486')\n    Traceback (most recent call last):\n      ...\n    ValueError: Base16 encoded data is invalid:\n    Data does not have an even number of hex digits.\n    >>> base16_decode('48656c6c6f20576f726c6421')\n    Traceback (most recent call last):\n      ...\n    ValueError: Base16 encoded data is invalid:\n    Data is not uppercase hex or it contains invalid characters.\n    >>> base16_decode('This is not base64 encoded data.')\n    Traceback (most recent call last):\n      ...\n    ValueError: Base16 encoded data is invalid:\n    Data is not uppercase hex or it contains invalid characters.\n    \"\"\"\n    # Check data validity, following RFC3548\n    # https://www.ietf.org/rfc/rfc3548.txt\n    if (len(data) % 2) != 0:\n        raise ValueError(\n            \"\"\"Base16 encoded data is invalid:\nData does not have an even number of hex digits.\"\"\"\n        )\n    # Check the character set - the standard base16 alphabet\n    # is uppercase according to RFC3548 section 6\n    if not set(data) <= set(\"0123456789ABCDEF\"):\n        raise ValueError(\n            \"\"\"Base16 encoded data is invalid:\nData is not uppercase hex or it contains invalid characters.\"\"\"\n        )\n    # For every two hexadecimal digits (= a byte), turn it into an integer.\n    # Then, string the result together into bytes, and return it.\n    return bytes(int(data[i] + data[i + 1], 16) for i in range(0, len(data), 2))\n1: def solution(n: int = 51) -> int:\n    \"\"\"\n    Returns the sum of squarefrees for a given Pascal's Triangle of depth n.\n\n    >>> solution(1)\n    1\n    >>> solution(8)\n    105\n    >>> solution(9)\n    175\n    \"\"\"\n    unique_coefficients = get_pascal_triangle_unique_coefficients(n)\n    squarefrees = get_squarefrees(unique_coefficients)\n    return sum(squarefrees)\n2: def rec_insertion_sort(collection: list, n: int):\n    \"\"\"\n    Given a collection of numbers and its length, sorts the collections\n    in ascending order\n\n    :param collection: A mutable collection of comparable elements\n    :param n: The length of collections\n\n    >>> col = [1, 2, 1]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [1, 1, 2]\n\n    >>> col = [2, 1, 0, -1, -2]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [-2, -1, 0, 1, 2]\n\n    >>> col = [1]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [1]\n    \"\"\"\n    # Checks if the entire collection has been sorted\n    if len(collection) <= 1 or n <= 1:\n        return\n\n    insert_next(collection, n - 1)\n    rec_insertion_sort(collection, n - 1)", "output": "1"}
{"input": "summarize code:\ndef redundant(src, key=None, groups=False):\n    \"\"\"The complement of :func:`unique()`.\n\n    By default returns non-unique/duplicate values as a list of the\n    *first* redundant value in *src*. Pass ``groups=True`` to get\n    groups of all values with redundancies, ordered by position of the\n    first redundant value. This is useful in conjunction with some\n    normalizing *key* function.\n\n    >>> redundant([1, 2, 3, 4])\n    []\n    >>> redundant([1, 2, 3, 2, 3, 3, 4])\n    [2, 3]\n    >>> redundant([1, 2, 3, 2, 3, 3, 4], groups=True)\n    [[2, 2], [3, 3, 3]]\n\n    An example using a *key* function to do case-insensitive\n    redundancy detection.\n\n    >>> redundant(['hi', 'Hi', 'HI', 'hello'], key=str.lower)\n    ['Hi']\n    >>> redundant(['hi', 'Hi', 'HI', 'hello'], groups=True, key=str.lower)\n    [['hi', 'Hi', 'HI']]\n\n    *key* should also be used when the values in *src* are not hashable.\n\n    .. note::\n\n       This output of this function is designed for reporting\n       duplicates in contexts when a unique input is desired. Due to\n       the grouped return type, there is no streaming equivalent of\n       this function for the time being.\n\n    \"\"\"\n    if key is None:\n        pass\n    elif callable(key):\n        key_func = key\n    elif isinstance(key, (str, bytes)):\n        def key_func(x): return getattr(x, key, x)\n    else:\n        raise TypeError('\"key\" expected a string or callable, not %r' % key)\n    seen = {}  # key to first seen item\n    redundant_order = []\n    redundant_groups = {}\n    for i in src:\n        k = key_func(i) if key else i\n        if k not in seen:\n            seen[k] = i\n        else:\n            if k in redundant_groups:\n                if groups:\n                    redundant_groups[k].append(i)\n            else:\n                redundant_order.append(k)\n                redundant_groups[k] = [seen[k], i]\n    if not groups:\n        ret = [redundant_groups[k][1] for k in redundant_order]\n    else:\n        ret = [redundant_groups[k] for k in redundant_order]\n    return ret", "output": "The complement of :func:`unique()`."}
{"input": "search code:\nCalculate the local weights at a given prediction point using the weight matrix for that point\nChoices:\n0: def local_weight(\n    point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float\n) -> np.ndarray:\n    \"\"\"\n    Calculate the local weights at a given prediction point using the weight\n    matrix for that point\n\n    Args:\n        point: x-value at which the prediction is being made\n        x_train: ndarray of x-values for training\n        y_train: ndarray of y-values for training\n        tau: bandwidth value, controls how quickly the weight of training values\n            decreases as the distance from the prediction point increases\n    Returns:\n        ndarray of local weights\n    >>> local_weight(\n    ...     np.array([1., 1.]),\n    ...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),\n    ...     np.array([[1.01, 1.66, 3.5]]),\n    ...     0.6\n    ... )\n    array([[0.00873174],\n           [0.08272556]])\n    \"\"\"\n    weight_mat = weight_matrix(point, x_train, tau)\n    weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (\n        x_train.T @ weight_mat @ y_train.T\n    )\n\n    return weight\n1: def runge_kutta_gills(\n    func: Callable[[float, float], float],\n    x_initial: float,\n    y_initial: float,\n    step_size: float,\n    x_final: float,\n) -> np.ndarray:\n    \"\"\"\n    Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4.\n\n    args:\n    func: An ordinary differential equation (ODE) as function of x and y.\n    x_initial: The initial value of x.\n    y_initial: The initial value of y.\n    step_size: The increment value of x.\n    x_final: The final value of x.\n\n    Returns:\n        Solution of y at each nodal point\n\n    >>> def f(x, y):\n    ...     return (x-y)/2\n    >>> y = runge_kutta_gills(f, 0, 3, 0.2, 5)\n    >>> float(y[-1])\n    3.4104259225717537\n\n    >>> def f(x,y):\n    ...     return x\n    >>> y = runge_kutta_gills(f, -1, 0, 0.2, 0)\n    >>> y\n    array([ 0.  , -0.18, -0.32, -0.42, -0.48, -0.5 ])\n\n    >>> def f(x, y):\n    ...     return x + y\n    >>> y = runge_kutta_gills(f, 0, 0, 0.2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The final value of x must be greater than initial value of x.\n\n    >>> def f(x, y):\n    ...     return x\n    >>> y = runge_kutta_gills(f, -1, 0, -0.2, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Step size must be positive.\n    \"\"\"\n    if x_initial >= x_final:\n        raise ValueError(\n            \"The final value of x must be greater than initial value of x.\"\n        )\n\n    if step_size <= 0:\n        raise ValueError(\"Step size must be positive.\")\n\n    n = int((x_final - x_initial) / step_size)\n    y = np.zeros(n + 1)\n    y[0] = y_initial\n    for i in range(n):\n        k1 = step_size * func(x_initial, y[i])\n        k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)\n        k3 = step_size * func(\n            x_initial + step_size / 2,\n            y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,\n        )\n        k4 = step_size * func(\n            x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3\n        )\n\n        y[i + 1] = y[i] + (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4) / 6\n        x_initial += step_size\n    return y\n2: def build_tree(letters: list[Letter]) -> Letter | TreeNode:\n    \"\"\"\n    Run through the list of Letters and build the min heap\n    for the Huffman Tree.\n    \"\"\"\n    response: list[Letter | TreeNode] = list(letters)\n    while len(response) > 1:\n        left = response.pop(0)\n        right = response.pop(0)\n        total_freq = left.freq + right.freq\n        node = TreeNode(total_freq, left, right)\n        response.append(node)\n        response.sort(key=lambda x: x.freq)\n    return response[0]", "output": "0"}
{"input": "summarize code:\ndef check_direction(\n    starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int]\n) -> Direction:\n    \"\"\"Return the direction toward to the line from via to target from starting\n\n    :param starting: The starting point\n           via: The via point\n           target: The target point\n    :return: the Direction\n\n    Examples:\n    >>> check_direction((1,1), (2,2), (3,3))\n    Direction.straight\n\n    >>> check_direction((60,1), (-50,199), (30,2))\n    Direction.left\n\n    >>> check_direction((0,0), (5,5), (10,0))\n    Direction.right\n    \"\"\"\n    x0, y0 = starting\n    x1, y1 = via\n    x2, y2 = target\n    via_angle = degrees(atan2(y1 - y0, x1 - x0))\n    via_angle %= 360\n    target_angle = degrees(atan2(y2 - y0, x2 - x0))\n    target_angle %= 360\n    # t-\n    #  \\ \\\n    #   \\ v\n    #    \\|\n    #     s\n    # via_angle is always lower than target_angle, if direction is left.\n    # If they are same, it means they are on a same line of convex hull.\n    if target_angle > via_angle:\n        return Direction.left\n    elif target_angle == via_angle:\n        return Direction.straight\n    else:\n        return Direction.right", "output": "Return the direction toward to the line from via to target from starting"}
{"input": "search code:\nPrim's Algorithm.\nChoices:\n0: def geometric_series(\n    nth_term: float,\n    start_term_a: float,\n    common_ratio_r: float,\n) -> list[float]:\n    \"\"\"\n    Pure Python implementation of Geometric Series algorithm\n\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\n    >>> geometric_series(4, 2, -2)\n    [2, -4.0, 8.0, -16.0]\n    >>> geometric_series(4, -2, 2)\n    [-2, -4.0, -8.0, -16.0]\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if not series:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series\n1: def base64_decode(encoded_data: str) -> bytes:\n    \"\"\"Decodes data according to RFC4648.\n\n    This does the reverse operation of base64_encode.\n    We first transform the encoded data back to a binary stream, take off the\n    previously appended binary digits according to the padding, at this point we\n    would have a binary stream whose length is multiple of 8, the last step is\n    to convert every 8 bits to a byte.\n\n    >>> from base64 import b64decode\n    >>> a = \"VGhpcyBwdWxsIHJlcXVlc3QgaXMgcGFydCBvZiBIYWNrdG9iZXJmZXN0MjAh\"\n    >>> b = \"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2NDg=\"\n    >>> c = \"QQ==\"\n    >>> base64_decode(a) == b64decode(a)\n    True\n    >>> base64_decode(b) == b64decode(b)\n    True\n    >>> base64_decode(c) == b64decode(c)\n    True\n    >>> base64_decode(\"abc\")\n    Traceback (most recent call last):\n      ...\n    AssertionError: Incorrect padding\n    \"\"\"\n    # Make sure encoded_data is either a string or a bytes-like object\n    if not isinstance(encoded_data, bytes) and not isinstance(encoded_data, str):\n        msg = (\n            \"argument should be a bytes-like object or ASCII string, \"\n            f\"not '{encoded_data.__class__.__name__}'\"\n        )\n        raise TypeError(msg)\n\n    # In case encoded_data is a bytes-like object, make sure it contains only\n    # ASCII characters so we convert it to a string object\n    if isinstance(encoded_data, bytes):\n        try:\n            encoded_data = encoded_data.decode(\"utf-8\")\n        except UnicodeDecodeError:\n            raise ValueError(\"base64 encoded data should only contain ASCII characters\")\n\n    padding = encoded_data.count(\"=\")\n\n    # Check if the encoded string contains non base64 characters\n    if padding:\n        assert all(char in B64_CHARSET for char in encoded_data[:-padding]), (\n            \"Invalid base64 character(s) found.\"\n        )\n    else:\n        assert all(char in B64_CHARSET for char in encoded_data), (\n            \"Invalid base64 character(s) found.\"\n        )\n\n    # Check the padding\n    assert len(encoded_data) % 4 == 0 and padding < 3, \"Incorrect padding\"\n\n    if padding:\n        # Remove padding if there is one\n        encoded_data = encoded_data[:-padding]\n\n        binary_stream = \"\".join(\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\n        )[: -padding * 2]\n    else:\n        binary_stream = \"\".join(\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\n        )\n\n    data = [\n        int(binary_stream[index : index + 8], 2)\n        for index in range(0, len(binary_stream), 8)\n    ]\n\n    return bytes(data)\n2: def prim(graph: list, root: Vertex) -> list:\n    \"\"\"Prim's Algorithm.\n\n    Runtime:\n        O(mn) with `m` edges and `n` vertices\n\n    Return:\n        List with the edges of a Minimum Spanning Tree\n\n    Usage:\n        prim(graph, graph[0])\n    \"\"\"\n    a = []\n    for u in graph:\n        u.key = math.inf\n        u.pi = None\n    root.key = 0\n    q = graph[:]\n    while q:\n        u = min(q)\n        q.remove(u)\n        for v in u.neighbors:\n            if (v in q) and (u.edges[v.id] < v.key):\n                v.pi = u\n                v.key = u.edges[v.id]\n    for i in range(1, len(graph)):\n        a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))\n    return a", "output": "2"}
{"input": "search code:\nEliminate d from values[s]; propagate when values or places <= 2. Return values, except return False if a contradiction is detected.\nChoices:\n0: def bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1\n1: def normalize_array(array: np.ndarray, cap: float = 1) -> np.ndarray:\n    \"\"\"Normalizes a 1D array, between ranges 0-cap.\n\n    Args:\n        array: List containing values to be normalized between cap range.\n        cap: Maximum cap amount for normalization.\n    Returns:\n        return 1D numpy array, corresponding to limited range array\n\n    Examples:\n        >>> normalize_array(np.array([2, 3, 5, 7]))\n        array([0. , 0.2, 0.6, 1. ])\n        >>> normalize_array(np.array([[5], [7], [11], [13]]))\n        array([[0.  ],\n               [0.25],\n               [0.75],\n               [1.  ]])\n    \"\"\"\n    diff = np.max(array) - np.min(array)\n    return (array - np.min(array)) / (1 if diff == 0 else diff) * cap\n2: def eliminate(values, s, d):\n    \"\"\"\n    Eliminate d from values[s]; propagate when values or places <= 2.\n    Return values, except return False if a contradiction is detected.\n    \"\"\"\n    if d not in values[s]:\n        return values  ## Already eliminated\n    values[s] = values[s].replace(d, \"\")\n    ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.\n    if len(values[s]) == 0:\n        return False  ## Contradiction: removed last value\n    elif len(values[s]) == 1:\n        d2 = values[s]\n        if not all(eliminate(values, s2, d2) for s2 in peers[s]):\n            return False\n    ## (2) If a unit u is reduced to only one place for a value d, then put it there.\n    for u in units[s]:\n        dplaces = [s for s in u if d in values[s]]\n        if len(dplaces) == 0:\n            return False  ## Contradiction: no place for this value\n        # d can only be in one place in unit; assign it there\n        elif len(dplaces) == 1 and not assign(values, dplaces[0], d):\n            return False\n    return values", "output": "2"}
{"input": "search code:\nCalculate the sum of digit values in a positive integer converted to the given 'base'. Where 'base' ranges from 2 to 36.\nChoices:\n0: def sum_of_digits(num: int, base: int) -> str:\n    \"\"\"\n    Calculate the sum of digit values in a positive integer\n    converted to the given 'base'.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> sum_of_digits(103, 12)\n    '13'\n    >>> sum_of_digits(1275, 4)\n    '30'\n    >>> sum_of_digits(6645, 2)\n    '1001'\n    >>> # bases below 2 and beyond 36 will error\n    >>> sum_of_digits(543, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> sum_of_digits(543, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    num_str = int_to_base(num, base)\n    res = sum(int(char, base) for char in num_str)\n    res_str = int_to_base(res, base)\n    return res_str\n1: def gaussian_error_linear_unit(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the Gaussian Error Linear Unit (GELU) function\n\n    Parameters:\n        vector (np.ndarray): A  numpy array of shape (1, n) consisting of real values\n\n    Returns:\n        gelu_vec (np.ndarray): The input numpy array, after applying gelu\n\n    Examples:\n    >>> gaussian_error_linear_unit(np.array([-1.0, 1.0, 2.0]))\n    array([-0.15420423,  0.84579577,  1.93565862])\n\n    >>> gaussian_error_linear_unit(np.array([-3]))\n    array([-0.01807131])\n    \"\"\"\n    return vector * sigmoid(1.702 * vector)\n2: def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number num (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True", "output": "0"}
{"input": "search code:\nRecursively finds and returns a :class:`list` of all types inherited from *cls*.\nChoices:\n0: def get_all_subclasses(cls):\n    \"\"\"Recursively finds and returns a :class:`list` of all types\n    inherited from *cls*.\n\n    >>> class A(object):\n    ...     pass\n    ...\n    >>> class B(A):\n    ...     pass\n    ...\n    >>> class C(B):\n    ...     pass\n    ...\n    >>> class D(A):\n    ...     pass\n    ...\n    >>> [t.__name__ for t in get_all_subclasses(A)]\n    ['B', 'D', 'C']\n    >>> [t.__name__ for t in get_all_subclasses(B)]\n    ['C']\n\n    \"\"\"\n    try:\n        to_check = deque(cls.__subclasses__())\n    except (AttributeError, TypeError):\n        raise TypeError('expected type object, not %r' % cls)\n    seen, ret = set(), []\n    while to_check:\n        cur = to_check.popleft()\n        if cur in seen:\n            continue\n        ret.append(cur)\n        seen.add(cur)\n        to_check.extend(cur.__subclasses__())\n    return ret\n1: def always_iterable(obj, base_type=(str, bytes)):\n    \"\"\"If *obj* is iterable, return an iterator over its items::\n\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n\n    If *obj* is ``None``, return an empty iterable:\n\n        >>> obj = None\n        >>> list(always_iterable(None))\n        []\n\n    By default, binary and text strings are not considered iterable::\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj))\n        ['foo']\n\n    If *base_type* is set, objects for which ``isinstance(obj, base_type)``\n    returns ``True`` won't be considered iterable.\n\n        >>> obj = {'a': 1}\n        >>> list(always_iterable(obj))  # Iterate over the dict's keys\n        ['a']\n        >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n        [{'a': 1}]\n\n    Set *base_type* to ``None`` to avoid any special handling and treat objects\n    Python considers iterable as iterable:\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj, base_type=None))\n        ['f', 'o', 'o']\n    \"\"\"\n    if obj is None:\n        return iter(())\n\n    if (base_type is not None) and isinstance(obj, base_type):\n        return iter((obj,))\n\n    try:\n        return iter(obj)\n    except TypeError:\n        return iter((obj,))\n2: def mutate(child: str, genes: list[str]) -> str:\n    \"\"\"\n    Mutate a random gene of a child with another one from the list.\n    >>> random.seed(123)\n    >>> mutate(\"123456\", list(\"ABCDEF\"))\n    '12345A'\n    \"\"\"\n    child_list = list(child)\n    if random.uniform(0, 1) < MUTATION_PROBABILITY:\n        child_list[random.randint(0, len(child)) - 1] = random.choice(genes)\n    return \"\".join(child_list)", "output": "0"}
{"input": "search code:\nGet translation.\nChoices:\n0: def _gettext(message):\n    \"\"\"Get translation.\n\n    Args:\n        message (str): Text to translate.\n\n    Returns:\n        str: Translated text.\n    \"\"\"\n    return get_translation().gettext(message)\n1: def unquote_to_bytes(string):\n    \"\"\"unquote_to_bytes('abc%20def') -> b'abc def'.\"\"\"\n    # Note: strings are encoded as UTF-8. This is only an issue if it contains\n    # unescaped non-ASCII characters, which URIs should not.\n    if not string:\n        # Is it a string-like object?\n        string.split\n        return b''\n    if isinstance(string, str):\n        string = string.encode('utf-8')\n    bits = string.split(b'%')\n    if len(bits) == 1:\n        return string\n    # import pdb;pdb.set_trace()\n    res = [bits[0]]\n    append = res.append\n\n    for item in bits[1:]:\n        try:\n            append(_HEX_CHAR_MAP[item[:2]])\n            append(item[2:])\n        except KeyError:\n            append(b'%')\n            append(item)\n    return b''.join(res)\n2: def rotate_file(filename, *, keep: int = 5):\n    \"\"\"\n    If *filename.ext* exists, it will be moved to *filename.1.ext*, \n    with all conflicting filenames being moved up by one, dropping any files beyond *keep*.\n\n    After rotation, *filename* will be available for creation as a new file.\n\n    Fails if *filename* is not a file or if *keep* is not > 0.\n    \"\"\"\n    if keep < 1:\n        raise ValueError(f'expected \"keep\" to be >=1, not {keep}')\n    if not os.path.exists(filename):\n        return\n    if not os.path.isfile(filename):\n        raise ValueError(f'expected {filename} to be a file')\n\n    fn_root, fn_ext = os.path.splitext(filename)\n    kept_names = []\n    for i in range(1, keep + 1):\n        if fn_ext:\n            kept_names.append(f'{fn_root}.{i}{fn_ext}')\n        else:\n            kept_names.append(f'{fn_root}.{i}')\n\n    fns = [filename] + kept_names\n    for orig_name, kept_name in reversed(list(zip(fns, fns[1:]))):\n        if not os.path.exists(orig_name):\n            continue\n        os.rename(orig_name, kept_name)\n\n    if os.path.exists(kept_names[-1]):\n        os.remove(kept_names[-1])\n\n    return", "output": "0"}
{"input": "summarize code:\ndef color(graph: list[list[int]], max_colors: int) -> list[int]:\n    \"\"\"\n    Wrapper function to call subroutine called util_color\n    which will either return True or False.\n    If True is returned colored_vertices list is filled with correct colorings\n\n    >>> graph = [[0, 1, 0, 0, 0],\n    ...          [1, 0, 1, 0, 1],\n    ...          [0, 1, 0, 1, 0],\n    ...          [0, 1, 1, 0, 0],\n    ...          [0, 1, 0, 0, 0]]\n\n    >>> max_colors = 3\n    >>> color(graph, max_colors)\n    [0, 1, 0, 2, 0]\n\n    >>> max_colors = 2\n    >>> color(graph, max_colors)\n    []\n    \"\"\"\n    colored_vertices = [-1] * len(graph)\n\n    if util_color(graph, max_colors, colored_vertices, 0):\n        return colored_vertices\n\n    return []", "output": "Wrapper function to call subroutine called util_color which will either return True or False. If True is returned colored_vertices list is filled with correct colorings"}
{"input": "search code:\nDetermines whether n in base 'base' is a harshad number. Where 'base' ranges from 2 to 36.\nChoices:\n0: def solution(target: int = 2000000) -> int:\n    \"\"\"\n    Find the area of the grid which contains as close to two million rectangles\n    as possible.\n    >>> solution(20)\n    6\n    >>> solution(2000)\n    72\n    >>> solution(2000000000)\n    86595\n    \"\"\"\n    triangle_numbers: list[int] = [0]\n    idx: int\n\n    for idx in range(1, ceil(sqrt(target * 2) * 1.1)):\n        triangle_numbers.append(triangle_numbers[-1] + idx)\n\n    # we want this to be as close as possible to target\n    best_product: int = 0\n    # the area corresponding to the grid that gives the product closest to target\n    area: int = 0\n    # an estimate of b, using the quadratic formula\n    b_estimate: float\n    # the largest integer less than b_estimate\n    b_floor: int\n    # the largest integer less than b_estimate\n    b_ceil: int\n    # the triangle number corresponding to b_floor\n    triangle_b_first_guess: int\n    # the triangle number corresponding to b_ceil\n    triangle_b_second_guess: int\n\n    for idx_a, triangle_a in enumerate(triangle_numbers[1:], 1):\n        b_estimate = (-1 + sqrt(1 + 8 * target / triangle_a)) / 2\n        b_floor = floor(b_estimate)\n        b_ceil = ceil(b_estimate)\n        triangle_b_first_guess = triangle_numbers[b_floor]\n        triangle_b_second_guess = triangle_numbers[b_ceil]\n\n        if abs(target - triangle_b_first_guess * triangle_a) < abs(\n            target - best_product\n        ):\n            best_product = triangle_b_first_guess * triangle_a\n            area = idx_a * b_floor\n\n        if abs(target - triangle_b_second_guess * triangle_a) < abs(\n            target - best_product\n        ):\n            best_product = triangle_b_second_guess * triangle_a\n            area = idx_a * b_ceil\n\n    return area\n1: def is_harshad_number_in_base(num: int, base: int) -> bool:\n    \"\"\"\n    Determines whether n in base 'base' is a harshad number.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> is_harshad_number_in_base(18, 10)\n    True\n    >>> is_harshad_number_in_base(21, 10)\n    True\n    >>> is_harshad_number_in_base(-21, 5)\n    False\n    >>> # bases below 2 and beyond 36 will error\n    >>> is_harshad_number_in_base(45, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> is_harshad_number_in_base(45, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    if num < 0:\n        return False\n\n    n = int_to_base(num, base)\n    d = sum_of_digits(num, base)\n    return int(n, base) % int(d, base) == 0\n2: def merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:\n    \"\"\"\n    Returns root node of the merged tree.\n\n    >>> tree1 = Node(5)\n    >>> tree1.left = Node(6)\n    >>> tree1.right = Node(7)\n    >>> tree1.left.left = Node(2)\n    >>> tree2 = Node(4)\n    >>> tree2.left = Node(5)\n    >>> tree2.right = Node(8)\n    >>> tree2.left.right = Node(1)\n    >>> tree2.right.right = Node(4)\n    >>> merged_tree = merge_two_binary_trees(tree1, tree2)\n    >>> print_preorder(merged_tree)\n    9\n    11\n    2\n    1\n    15\n    4\n    \"\"\"\n    if tree1 is None:\n        return tree2\n    if tree2 is None:\n        return tree1\n\n    tree1.value = tree1.value + tree2.value\n    tree1.left = merge_two_binary_trees(tree1.left, tree2.left)\n    tree1.right = merge_two_binary_trees(tree1.right, tree2.right)\n    return tree1", "output": "1"}
{"input": "search code:\nReturn a random derangement of elements in the iterable.\nChoices:\n0: def binary_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1\n1: def random_derangement(iterable):\n    \"\"\"Return a random derangement of elements in the iterable.\n\n    Equivalent to but much faster than ``choice(list(derangements(iterable)))``.\n\n    \"\"\"\n    seq = tuple(iterable)\n    if len(seq) < 2:\n        if len(seq) == 0:\n            return ()\n        raise IndexError('No derangments to choose from')\n    perm = list(range(len(seq)))\n    start = tuple(perm)\n    while True:\n        shuffle(perm)\n        if not any(map(is_, start, perm)):\n            return itemgetter(*perm)(seq)\n2: def solution(n: int = 2000000) -> int:\n    \"\"\"\n    Returns the sum of all the primes below n.\n\n    >>> solution(1000)\n    76127\n    >>> solution(5000)\n    1548136\n    >>> solution(10000)\n    5736396\n    >>> solution(7)\n    10\n    \"\"\"\n\n    return sum(num for num in range(3, n, 2) if is_prime(num)) + 2 if n > 2 else 0", "output": "1"}
{"input": "search code:\nReturns frequency distribution of total\nChoices:\n0: def sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum\n1: def total_frequency_distribution(sides_number: int, dice_number: int) -> list[int]:\n    \"\"\"\n    Returns frequency distribution of total\n\n    >>> total_frequency_distribution(sides_number=6, dice_number=1)\n    [0, 1, 1, 1, 1, 1, 1]\n\n    >>> total_frequency_distribution(sides_number=4, dice_number=2)\n    [0, 0, 1, 2, 3, 4, 3, 2, 1]\n    \"\"\"\n\n    max_face_number = sides_number\n    max_total = max_face_number * dice_number\n    totals_frequencies = [0] * (max_total + 1)\n\n    min_face_number = 1\n    faces_numbers = range(min_face_number, max_face_number + 1)\n    for dice_numbers in product(faces_numbers, repeat=dice_number):\n        total = sum(dice_numbers)\n        totals_frequencies[total] += 1\n\n    return totals_frequencies\n2: def solution(max_d: int = 12_000) -> int:\n    \"\"\"\n    Returns number of fractions lie between 1/3 and 1/2 in the sorted set\n    of reduced proper fractions for d â‰¤ max_d\n\n    >>> solution(4)\n    0\n\n    >>> solution(5)\n    1\n\n    >>> solution(8)\n    3\n    \"\"\"\n\n    fractions_number = 0\n    for d in range(max_d + 1):\n        n_start = d // 3 + 1\n        n_step = 1\n        if d % 2 == 0:\n            n_start += 1 - n_start % 2\n            n_step = 2\n        for n in range(n_start, (d + 1) // 2, n_step):\n            if gcd(n, d) == 1:\n                fractions_number += 1\n    return fractions_number", "output": "1"}
{"input": "summarize code:\ndef distance(city1: list[int], city2: list[int]) -> float:\n    \"\"\"\n    Calculate the distance between two coordinate points\n    >>> distance([0, 0], [3, 4] )\n    5.0\n    >>> distance([0, 0], [-3, 4] )\n    5.0\n    >>> distance([0, 0], [-3, -4] )\n    5.0\n    \"\"\"\n    return (((city1[0] - city2[0]) ** 2) + ((city1[1] - city2[1]) ** 2)) ** 0.5", "output": "Calculate the distance between two coordinate points >>> distance([0, 0], [3, 4] ) 5.0 >>> distance([0, 0], [-3, 4] ) 5.0 >>> distance([0, 0], [-3, -4] ) 5.0"}
{"input": "search code:\nReturns the smallest positive number that is evenly divisible (divisible with no remainder) by all of the numbers from 1 to n.\nChoices:\n0: def _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value\n1: def solution(n: int = 20) -> int:\n    \"\"\"\n    Returns the smallest positive number that is evenly divisible (divisible\n    with no remainder) by all of the numbers from 1 to n.\n\n    >>> solution(10)\n    2520\n    >>> solution(15)\n    360360\n    >>> solution(22)\n    232792560\n    >>> solution(3.4)\n    6\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    i = 0\n    while 1:\n        i += n * (n - 1)\n        nfound = 0\n        for j in range(2, n):\n            if i % j != 0:\n                nfound = 1\n                break\n        if nfound == 0:\n            if i == 0:\n                i = 1\n            return i\n    return None\n2: def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2", "output": "1"}
{"input": "summarize code:\ndef equated_monthly_installments(\n    principal: float, rate_per_annum: float, years_to_repay: int\n) -> float:\n    \"\"\"\n    Formula for amortization amount per month:\n    A = p * r * (1 + r)^n / ((1 + r)^n - 1)\n    where p is the principal, r is the rate of interest per month\n    and n is the number of payments\n\n    >>> equated_monthly_installments(25000, 0.12, 3)\n    830.3577453212793\n    >>> equated_monthly_installments(25000, 0.12, 10)\n    358.67737100646826\n    >>> equated_monthly_installments(0, 0.12, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Principal borrowed must be > 0\n    >>> equated_monthly_installments(25000, -1, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Rate of interest must be >= 0\n    >>> equated_monthly_installments(25000, 0.12, 0)\n    Traceback (most recent call last):\n        ...\n    Exception: Years to repay must be an integer > 0\n    \"\"\"\n    if principal <= 0:\n        raise Exception(\"Principal borrowed must be > 0\")\n    if rate_per_annum < 0:\n        raise Exception(\"Rate of interest must be >= 0\")\n    if years_to_repay <= 0 or not isinstance(years_to_repay, int):\n        raise Exception(\"Years to repay must be an integer > 0\")\n\n    # Yearly rate is divided by 12 to get monthly rate\n    rate_per_month = rate_per_annum / 12\n\n    # Years to repay is multiplied by 12 to get number of payments as payment is monthly\n    number_of_payments = years_to_repay * 12\n\n    return (\n        principal\n        * rate_per_month\n        * (1 + rate_per_month) ** number_of_payments\n        / ((1 + rate_per_month) ** number_of_payments - 1)\n    )", "output": "Formula for amortization amount per month: A = p * r * (1 + r)^n / ((1 + r)^n - 1) where p is the principal, r is the rate of interest per month and n is the number of payments"}
{"input": "summarize code:\ndef lr_rotation(node: MyNode) -> MyNode:\n    r\"\"\"\n            A              A                    Br\n           / \\            / \\                  /  \\\n          B   C    LR    Br  C       RR       B    A\n         / \\       -->  /  \\         -->    /     / \\\n        Bl  Br         B   UB              Bl    UB  C\n             \\        /\n             UB     Bl\n    RR = right_rotation   LR = left_rotation\n    \"\"\"\n    left_child = node.get_left()\n    assert left_child is not None\n    node.set_left(left_rotation(left_child))\n    return right_rotation(node)", "output": "A A Br / \\ / \\ / \\ B C LR Br C RR B A / \\ --> / \\ --> / / \\ Bl Br B UB Bl UB C \\ / UB Bl RR = right_rotation LR = left_rotation"}
{"input": "summarize code:\ndef outer_product(func, xs, ys, *args, **kwargs):\n    \"\"\"A generalized outer product that applies a binary function to all\n    pairs of items. Returns a 2D matrix with ``len(xs)`` rows and ``len(ys)``\n    columns.\n    Also accepts ``*args`` and ``**kwargs`` that are passed to ``func``.\n\n    Multiplication table:\n\n    >>> list(outer_product(mul, range(1, 4), range(1, 6)))\n    [(1, 2, 3, 4, 5), (2, 4, 6, 8, 10), (3, 6, 9, 12, 15)]\n\n    Cross tabulation:\n\n    >>> xs = ['A', 'B', 'A', 'A', 'B', 'B', 'A', 'A', 'B', 'B']\n    >>> ys = ['X', 'X', 'X', 'Y', 'Z', 'Z', 'Y', 'Y', 'Z', 'Z']\n    >>> pair_counts = Counter(zip(xs, ys))\n    >>> count_rows = lambda x, y: pair_counts[x, y]\n    >>> list(outer_product(count_rows, sorted(set(xs)), sorted(set(ys))))\n    [(2, 3, 0), (1, 0, 4)]\n\n    Usage with ``*args`` and ``**kwargs``:\n\n    >>> animals = ['cat', 'wolf', 'mouse']\n    >>> list(outer_product(min, animals, animals, key=len))\n    [('cat', 'cat', 'cat'), ('cat', 'wolf', 'wolf'), ('cat', 'wolf', 'mouse')]\n    \"\"\"\n    ys = tuple(ys)\n    return batched(\n        starmap(lambda x, y: func(x, y, *args, **kwargs), product(xs, ys)),\n        n=len(ys),\n    )", "output": "A generalized outer product that applies a binary function to all pairs of items. Returns a 2D matrix with ``len(xs)`` rows and ``len(ys)`` columns. Also accepts ``*args`` and ``**kwargs`` that are passed to ``func``."}
{"input": "summarize code:\ndef transform(\n    image: np.ndarray, kind: str, kernel: np.ndarray | None = None\n) -> np.ndarray:\n    \"\"\"\n    Simple image transformation using one of two available filter functions:\n    Erosion and Dilation.\n\n    Args:\n        image: binarized input image, onto which to apply transformation\n        kind: Can be either 'erosion', in which case the :func:np.max\n              function is called, or 'dilation', when :func:np.min is used instead.\n        kernel: n x n kernel with shape < :attr:image.shape,\n              to be used when applying convolution to original image\n\n    Returns:\n        returns a numpy array with same shape as input image,\n        corresponding to applied binary transformation.\n\n    Examples:\n        >>> img = np.array([[1, 0.5], [0.2, 0.7]])\n        >>> img = binarize(img, threshold=0.5)\n        >>> transform(img, 'erosion')\n        array([[1, 1],\n               [1, 1]], dtype=uint8)\n        >>> transform(img, 'dilation')\n        array([[0, 0],\n               [0, 0]], dtype=uint8)\n    \"\"\"\n    if kernel is None:\n        kernel = np.ones((3, 3))\n\n    if kind == \"erosion\":\n        constant = 1\n        apply = np.max\n    else:\n        constant = 0\n        apply = np.min\n\n    center_x, center_y = (x // 2 for x in kernel.shape)\n\n    # Use padded image when applying convolution\n    # to not go out of bounds of the original the image\n    transformed = np.zeros(image.shape, dtype=np.uint8)\n    padded = np.pad(image, 1, \"constant\", constant_values=constant)\n\n    for x in range(center_x, padded.shape[0] - center_x):\n        for y in range(center_y, padded.shape[1] - center_y):\n            center = padded[\n                x - center_x : x + center_x + 1, y - center_y : y + center_y + 1\n            ]\n            # Apply transformation method to the centered section of the image\n            transformed[x - center_x, y - center_y] = apply(center[kernel == 1])\n\n    return transformed", "output": "Simple image transformation using one of two available filter functions: Erosion and Dilation."}
{"input": "search code:\nConstructs the convex hull of a set of 2D points using a brute force algorithm. The algorithm basically considers all combinations of points (i, j) and uses the definition of convexity to determine whether (i, j) is part of the convex hull or not. (i, j) is part of the convex hull if and only iff there are no points on both sides of the line segment connecting the ij, and there is no point k such that k is on either end of the ij.\nChoices:\n0: def idft(Xarr):\n    \"\"\"Inverse Discrete Fourier Transform. *Xarr* is a sequence of\n    complex numbers. Yields the components of the corresponding\n    inverse-transformed output vector.\n\n    >>> import cmath\n    >>> xarr = [1, 2-1j, -1j, -1+2j]  # time domain\n    >>> Xarr = [2, -2-2j, -2j, 4+4j]  # frequency domain\n    >>> all(map(cmath.isclose, idft(Xarr), xarr))\n    True\n\n    Inputs are restricted to numeric types that can add and multiply\n    with a complex number.  This includes int, float, complex, and\n    Fraction, but excludes Decimal.\n\n    See :func:`dft` for the Discrete Fourier Transform.\n    \"\"\"\n    N = len(Xarr)\n    roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]\n    for k in range(N):\n        coeffs = [roots_of_unity[k * n % N] for n in range(N)]\n        yield _complex_sumprod(Xarr, coeffs) / N\n1: def convex_hull_bf(points: list[Point]) -> list[Point]:\n    \"\"\"\n    Constructs the convex hull of a set of 2D points using a brute force algorithm.\n    The algorithm basically considers all combinations of points (i, j) and uses the\n    definition of convexity to determine whether (i, j) is part of the convex hull or\n    not.  (i, j) is part of the convex hull if and only iff there are no points on both\n    sides of the line segment connecting the ij, and there is no point k such that k is\n    on either end of the ij.\n\n    Runtime: O(n^3) - definitely horrible\n\n    Parameters\n    ---------\n    points: array-like of object of Points, lists or tuples.\n    The set of  2d points for which the convex-hull is needed\n\n    Returns\n    ------\n    convex_set: list, the convex-hull of points sorted in non-decreasing order.\n\n    See Also\n    --------\n    convex_hull_recursive,\n\n     Examples\n     ---------\n     >>> convex_hull_bf([[0, 0], [1, 0], [10, 1]])\n     [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\n     >>> convex_hull_bf([[0, 0], [1, 0], [10, 0]])\n     [(0.0, 0.0), (10.0, 0.0)]\n     >>> convex_hull_bf([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\n     ...                 [-0.75, 1]])\n     [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n     >>> convex_hull_bf([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\n     ...                 (2, -1), (2, -4), (1, -3)])\n     [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]\n    \"\"\"\n\n    points = sorted(_validate_input(points))\n    n = len(points)\n    convex_set = set()\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            points_left_of_ij = points_right_of_ij = False\n            ij_part_of_convex_hull = True\n            for k in range(n):\n                if k not in {i, j}:\n                    det_k = _det(points[i], points[j], points[k])\n\n                    if det_k > 0:\n                        points_left_of_ij = True\n                    elif det_k < 0:\n                        points_right_of_ij = True\n                    # point[i], point[j], point[k] all lie on a straight line\n                    # if point[k] is to the left of point[i] or it's to the\n                    # right of point[j], then point[i], point[j] cannot be\n                    # part of the convex hull of A\n                    elif points[k] < points[i] or points[k] > points[j]:\n                        ij_part_of_convex_hull = False\n                        break\n\n                if points_left_of_ij and points_right_of_ij:\n                    ij_part_of_convex_hull = False\n                    break\n\n            if ij_part_of_convex_hull:\n                convex_set.update([points[i], points[j]])\n\n    return sorted(convex_set)\n2: def ordinal(value, gender=\"male\"):\n    \"\"\"Converts an integer to its ordinal as a string.\n\n    For example, 1 is \"1st\", 2 is \"2nd\", 3 is \"3rd\", etc. Works for any integer or\n    anything `int()` will turn into an integer. Anything other value will have nothing\n    done to it.\n\n    Examples:\n        ```pycon\n        >>> ordinal(1)\n        '1st'\n        >>> ordinal(1002)\n        '1002nd'\n        >>> ordinal(103)\n        '103rd'\n        >>> ordinal(4)\n        '4th'\n        >>> ordinal(12)\n        '12th'\n        >>> ordinal(101)\n        '101st'\n        >>> ordinal(111)\n        '111th'\n        >>> ordinal(\"something else\")\n        'something else'\n        >>> ordinal(None) is None\n        True\n\n        ```\n    Args:\n        value (int, str, float): Integer to convert.\n        gender (str): Gender for translations. Accepts either \"male\" or \"female\".\n\n    Returns:\n        str: Ordinal string.\n    \"\"\"\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n    if gender == \"male\":\n        t = (\n            P_(\"0 (male)\", \"th\"),\n            P_(\"1 (male)\", \"st\"),\n            P_(\"2 (male)\", \"nd\"),\n            P_(\"3 (male)\", \"rd\"),\n            P_(\"4 (male)\", \"th\"),\n            P_(\"5 (male)\", \"th\"),\n            P_(\"6 (male)\", \"th\"),\n            P_(\"7 (male)\", \"th\"),\n            P_(\"8 (male)\", \"th\"),\n            P_(\"9 (male)\", \"th\"),\n        )\n    else:\n        t = (\n            P_(\"0 (female)\", \"th\"),\n            P_(\"1 (female)\", \"st\"),\n            P_(\"2 (female)\", \"nd\"),\n            P_(\"3 (female)\", \"rd\"),\n            P_(\"4 (female)\", \"th\"),\n            P_(\"5 (female)\", \"th\"),\n            P_(\"6 (female)\", \"th\"),\n            P_(\"7 (female)\", \"th\"),\n            P_(\"8 (female)\", \"th\"),\n            P_(\"9 (female)\", \"th\"),\n        )\n    if value % 100 in (11, 12, 13):  # special case\n        return f\"{value}{t[0]}\"\n    return f\"{value}{t[value % 10]}\"", "output": "1"}
{"input": "search code:\nThis function can calculate any one of the three (voltage, current, power), fundamental value of electrical system. examples are below: >>> electric_power(voltage=0, current=2, power=5) Result(name='voltage', value=2.5) >>> electric_power(voltage=2, current=2, power=0) Result(name='power', value=4.0) >>> electric_power(voltage=-2, current=3, power=0) Result(name='power', value=6.0) >>> electric_power(voltage=2, current=4, power=2) Traceback (most recent call last): ... ValueError: Exactly one argument must be 0 >>> electric_power(voltage=0, current=0, power=2) Traceback (most recent call last): ... ValueError: Exactly one argument must be 0 >>> electric_power(voltage=0, current=2, power=-4) Traceback (most recent call last): ... ValueError: Power cannot be negative in any electrical/electronics system >>> electric_power(voltage=2.2, current=2.2, power=0) Result(name='power', value=4.84) >>> electric_power(current=0, power=6, voltage=2) Result(name='current', value=3.0)\nChoices:\n0: def open_knight_tour(n: int) -> list[list[int]]:\n    \"\"\"\n    Find the solution for the knight tour problem for a board of size n. Raises\n    ValueError if the tour cannot be performed for the given size.\n\n    >>> open_knight_tour(1)\n    [[1]]\n\n    >>> open_knight_tour(2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Open Knight Tour cannot be performed on a board of size 2\n    \"\"\"\n\n    board = [[0 for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 1\n            if open_knight_tour_helper(board, (i, j), 1):\n                return board\n            board[i][j] = 0\n\n    msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"\n    raise ValueError(msg)\n1: def electric_power(voltage: float, current: float, power: float) -> tuple:\n    \"\"\"\n    This function can calculate any one of the three (voltage, current, power),\n    fundamental value of electrical system.\n    examples are below:\n    >>> electric_power(voltage=0, current=2, power=5)\n    Result(name='voltage', value=2.5)\n    >>> electric_power(voltage=2, current=2, power=0)\n    Result(name='power', value=4.0)\n    >>> electric_power(voltage=-2, current=3, power=0)\n    Result(name='power', value=6.0)\n    >>> electric_power(voltage=2, current=4, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=0, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=2, power=-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Power cannot be negative in any electrical/electronics system\n    >>> electric_power(voltage=2.2, current=2.2, power=0)\n    Result(name='power', value=4.84)\n    >>> electric_power(current=0, power=6, voltage=2)\n    Result(name='current', value=3.0)\n    \"\"\"\n    if (voltage, current, power).count(0) != 1:\n        raise ValueError(\"Exactly one argument must be 0\")\n    elif power < 0:\n        raise ValueError(\n            \"Power cannot be negative in any electrical/electronics system\"\n        )\n    elif voltage == 0:\n        return Result(\"voltage\", power / current)\n    elif current == 0:\n        return Result(\"current\", power / voltage)\n    elif power == 0:\n        return Result(\"power\", float(round(abs(voltage * current), 2)))\n    else:\n        raise AssertionError\n2: def main() -> None:\n    \"\"\"\n    starting point or function of script\n    \"\"\"\n    lower = int(input(\"Enter lower value : \").strip())\n    higher = int(input(\"Enter high value : \").strip())\n    guess = int(input(\"Enter value to guess : \").strip())\n    guess_the_number(lower, higher, guess)", "output": "1"}
{"input": "summarize code:\ndef fizz_buzz(number: int, iterations: int) -> str:\n    \"\"\"\n    | Plays FizzBuzz.\n    | Prints Fizz if number is a multiple of ``3``.\n    | Prints Buzz if its a multiple of ``5``.\n    | Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``.\n    | Else Prints The Number Itself.\n\n    >>> fizz_buzz(1,7)\n    '1 2 Fizz 4 Buzz Fizz 7 '\n    >>> fizz_buzz(1,0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(-5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(10,-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(1.5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(1,5.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: iterations must be defined as integers\n    \"\"\"\n    if not isinstance(iterations, int):\n        raise ValueError(\"iterations must be defined as integers\")\n    if not isinstance(number, int) or not number >= 1:\n        raise ValueError(\n            \"\"\"starting number must be\n                         and integer and be more than 0\"\"\"\n        )\n    if not iterations >= 1:\n        raise ValueError(\"Iterations must be done more than 0 times to play FizzBuzz\")\n\n    out = \"\"\n    while number <= iterations:\n        if number % 3 == 0:\n            out += \"Fizz\"\n        if number % 5 == 0:\n            out += \"Buzz\"\n        if 0 not in (number % 3, number % 5):\n            out += str(number)\n\n        # print(out)\n        number += 1\n        out += \" \"\n    return out", "output": "| Plays FizzBuzz. | Prints Fizz if number is a multiple of ``3``. | Prints Buzz if its a multiple of ``5``. | Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``. | Else Prints The Number Itself."}
{"input": "summarize code:\ndef benchmark():\n    \"\"\"\n    Let's benchmark our functions side-by-side...\n    \"\"\"\n    from timeit import timeit\n\n    setup = \"from __main__ import slow_primes, primes, fast_primes\"\n    print(timeit(\"slow_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n    print(timeit(\"primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n    print(timeit(\"fast_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))", "output": "Let's benchmark our functions side-by-side..."}
{"input": "search code:\nCompute the \"subdictionary\" of a dict, *d*.\nChoices:\n0: def cardinalize(unit_noun, count):\n    \"\"\"Conditionally pluralizes a singular word *unit_noun* if\n    *count* is not one, preserving case when possible.\n\n    >>> vowels = 'aeiou'\n    >>> print(len(vowels), cardinalize('vowel', len(vowels)))\n    5 vowels\n    >>> print(3, cardinalize('Wish', 3))\n    3 Wishes\n    \"\"\"\n    if count == 1:\n        return unit_noun\n    return pluralize(unit_noun)\n1: def subdict(d, keep=None, drop=None):\n    \"\"\"Compute the \"subdictionary\" of a dict, *d*.\n\n    A subdict is to a dict what a subset is a to set. If *A* is a\n    subdict of *B*, that means that all keys of *A* are present in\n    *B*.\n\n    Returns a new dict with any keys in *drop* removed, and any keys\n    in *keep* still present, provided they were in the original\n    dict. *keep* defaults to all keys, *drop* defaults to empty, so\n    without one of these arguments, calling this function is\n    equivalent to calling ``dict()``.\n\n    >>> from pprint import pprint as pp\n    >>> pp(subdict({'a': 1, 'b': 2}))\n    {'a': 1, 'b': 2}\n    >>> subdict({'a': 1, 'b': 2, 'c': 3}, drop=['b', 'c'])\n    {'a': 1}\n    >>> pp(subdict({'a': 1, 'b': 2, 'c': 3}, keep=['a', 'c']))\n    {'a': 1, 'c': 3}\n\n    \"\"\"\n    if keep is None:\n        keep = d.keys()\n    if drop is None:\n        drop = []\n\n    keys = set(keep) - set(drop)\n\n    return type(d)([(k, v) for k, v in d.items() if k in keys])\n2: def gunzip_bytes(bytestring):\n    \"\"\"The :mod:`gzip` module is great if you have a file or file-like\n    object, but what if you just have bytes. StringIO is one\n    possibility, but it's often faster, easier, and simpler to just\n    use this one-liner. Use this tried-and-true utility function to\n    decompress gzip from bytes.\n\n    >>> gunzip_bytes(_EMPTY_GZIP_BYTES) == b''\n    True\n    >>> gunzip_bytes(_NON_EMPTY_GZIP_BYTES).rstrip() == b'bytesahoy!'\n    True\n    \"\"\"\n    return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)", "output": "1"}
{"input": "search code:\nYield the items from *iterable*, but strip any from the beginning for which *pred* returns ``True``.\nChoices:\n0: def lstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the beginning\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the start of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(lstrip(iterable, pred))\n        [1, 2, None, 3, False, None]\n\n    This function is analogous to to :func:`str.lstrip`, and is essentially\n    an wrapper for :func:`itertools.dropwhile`.\n\n    \"\"\"\n    return dropwhile(pred, iterable)\n1: def compute_nums(n: int) -> list[int]:\n    \"\"\"\n    Returns a list of first n odd composite numbers which do\n    not follow the conjecture.\n    >>> compute_nums(1)\n    [5777]\n    >>> compute_nums(2)\n    [5777, 5993]\n    >>> compute_nums(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be >= 0\n    >>> compute_nums(\"a\")\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be an integer\n    >>> compute_nums(1.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be an integer\n\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be >= 0\")\n\n    list_nums = []\n    for num in range(len(odd_composites)):\n        i = 0\n        while 2 * i * i <= odd_composites[num]:\n            rem = odd_composites[num] - 2 * i * i\n            if is_prime(rem):\n                break\n            i += 1\n        else:\n            list_nums.append(odd_composites[num])\n            if len(list_nums) == n:\n                return list_nums\n\n    return []\n2: def tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)", "output": "0"}
{"input": "search code:\nFind the sum of digits of a number. >>> sum_of_digits(12345) 15 >>> sum_of_digits(123) 6 >>> sum_of_digits(-123) 6 >>> sum_of_digits(0) 0\nChoices:\n0: def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [5, 7]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = array[i:]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq\n1: def sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(-123)\n    6\n    >>> sum_of_digits(0)\n    0\n    \"\"\"\n    n = abs(n)\n    res = 0\n    while n > 0:\n        res += n % 10\n        n //= 10\n    return res\n2: def wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]", "output": "1"}
{"input": "search code:\nDetermine if a given pattern matches a string using backtracking.\nChoices:\n0: def mark_ends(iterable):\n    \"\"\"Yield 3-tuples of the form ``(is_first, is_last, item)``.\n\n    >>> list(mark_ends('ABC'))\n    [(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]\n\n    Use this when looping over an iterable to take special action on its first\n    and/or last items:\n\n    >>> iterable = ['Header', 100, 200, 'Footer']\n    >>> total = 0\n    >>> for is_first, is_last, item in mark_ends(iterable):\n    ...     if is_first:\n    ...         continue  # Skip the header\n    ...     if is_last:\n    ...         continue  # Skip the footer\n    ...     total += item\n    >>> print(total)\n    300\n    \"\"\"\n    it = iter(iterable)\n    for a in it:\n        first = True\n        for b in it:\n            yield first, False, a\n            a = b\n            first = False\n        yield first, True, a\n1: def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)\n2: def harshad_numbers_in_base(limit: int, base: int) -> list[str]:\n    \"\"\"\n    Finds all Harshad numbers smaller than num in base 'base'.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> harshad_numbers_in_base(15, 2)\n    ['1', '10', '100', '110', '1000', '1010', '1100']\n    >>> harshad_numbers_in_base(12, 34)\n    ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B']\n    >>> harshad_numbers_in_base(12, 4)\n    ['1', '2', '3', '10', '12', '20', '21']\n    >>> # bases below 2 and beyond 36 will error\n    >>> harshad_numbers_in_base(234, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> harshad_numbers_in_base(234, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> harshad_numbers_in_base(-12, 6)\n    []\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    if limit < 0:\n        return []\n\n    numbers = [\n        int_to_base(i, base)\n        for i in range(1, limit)\n        if i % int(sum_of_digits(i, base), base) == 0\n    ]\n\n    return numbers", "output": "1"}
{"input": "search code:\n\" Return the sum of n terms in a geometric progression. >>> sum_of_geometric_progression(1, 2, 10) 1023.0 >>> sum_of_geometric_progression(1, 10, 5) 11111.0 >>> sum_of_geometric_progression(0, 2, 10) 0.0 >>> sum_of_geometric_progression(1, 0, 10) 1.0 >>> sum_of_geometric_progression(1, 2, 0) -0.0 >>> sum_of_geometric_progression(-1, 2, 10) -1023.0 >>> sum_of_geometric_progression(1, -2, 10) -341.0 >>> sum_of_geometric_progression(1, 2, -10) -0.9990234375\nChoices:\n0: def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result\n1: def mark_ends(iterable):\n    \"\"\"Yield 3-tuples of the form ``(is_first, is_last, item)``.\n\n    >>> list(mark_ends('ABC'))\n    [(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]\n\n    Use this when looping over an iterable to take special action on its first\n    and/or last items:\n\n    >>> iterable = ['Header', 100, 200, 'Footer']\n    >>> total = 0\n    >>> for is_first, is_last, item in mark_ends(iterable):\n    ...     if is_first:\n    ...         continue  # Skip the header\n    ...     if is_last:\n    ...         continue  # Skip the footer\n    ...     total += item\n    >>> print(total)\n    300\n    \"\"\"\n    it = iter(iterable)\n    for a in it:\n        first = True\n        for b in it:\n            yield first, False, a\n            a = b\n            first = False\n        yield first, True, a\n2: def sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)", "output": "2"}
{"input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    xmulti = []\n    zmulti = []\n    z = 3\n    x = 5\n    temp = 1\n    while True:\n        result = z * temp\n        if result < n:\n            zmulti.append(result)\n            temp += 1\n        else:\n            temp = 1\n            break\n    while True:\n        result = x * temp\n        if result < n:\n            xmulti.append(result)\n            temp += 1\n        else:\n            break\n    collection = list(set(xmulti + zmulti))\n    return sum(collection)", "output": "Returns the sum of all the multiples of 3 or 5 below n."}
{"input": "search code:\nReturns a sample transaction dataset.\nChoices:\n0: def load_data() -> list[list[str]]:\n    \"\"\"\n    Returns a sample transaction dataset.\n\n    >>> load_data()\n    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]\n    \"\"\"\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]\n1: def area_triangle(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle given the base and height.\n\n    >>> area_triangle(10, 10)\n    50.0\n    >>> area_triangle(1.6, 2.6)\n    2.08\n    >>> area_triangle(0, 0)\n    0.0\n    >>> area_triangle(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    >>> area_triangle(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    >>> area_triangle(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    \"\"\"\n    if base < 0 or height < 0:\n        raise ValueError(\"area_triangle() only accepts non-negative values\")\n    return (base * height) / 2\n2: def mutate(child: str, genes: list[str]) -> str:\n    \"\"\"\n    Mutate a random gene of a child with another one from the list.\n    >>> random.seed(123)\n    >>> mutate(\"123456\", list(\"ABCDEF\"))\n    '12345A'\n    \"\"\"\n    child_list = list(child)\n    if random.uniform(0, 1) < MUTATION_PROBABILITY:\n        child_list[random.randint(0, len(child)) - 1] = random.choice(genes)\n    return \"\".join(child_list)", "output": "0"}
{"input": "search code:\nReturn the ceiling of x as an Integral.\nChoices:\n0: def count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions\n1: def solution():\n    \"\"\"\n    Finds the amount of triangular words in the words file.\n\n    >>> solution()\n    162\n    \"\"\"\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    words_file_path = os.path.join(script_dir, \"words.txt\")\n\n    words = \"\"\n    with open(words_file_path) as f:\n        words = f.readline()\n\n    words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]\n    words = [\n        word\n        for word in [sum(ord(x) - 64 for x in word) for word in words]\n        if word in TRIANGULAR_NUMBERS\n    ]\n    return len(words)\n2: def ceil(x: float) -> int:\n    \"\"\"\n    Return the ceiling of x as an Integral.\n\n    :param x: the number\n    :return: the smallest integer >= x.\n\n    >>> import math\n    >>> all(ceil(n) == math.ceil(n) for n\n    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))\n    True\n    \"\"\"\n    return int(x) if x - int(x) <= 0 else int(x) + 1", "output": "2"}
{"input": "summarize code:\ndef leaky_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:\n    \"\"\"\n        Implements the LeakyReLU activation function.\n\n        Parameters:\n            vector (np.ndarray): The input array for LeakyReLU activation.\n            alpha (float): The slope for negative values.\n\n        Returns:\n            np.ndarray: The input array after applying the LeakyReLU activation.\n\n        Formula: f(x) = x if x > 0 else f(x) = alpha * x\n\n    Examples:\n    >>> leaky_rectified_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)\n    array([ 2.3 ,  0.6 , -0.6 , -1.14])\n\n    >>> leaky_rectified_linear_unit(np.array([-9.2, -0.3, 0.45, -4.56]), alpha=0.067)\n    array([-0.6164 , -0.0201 ,  0.45   , -0.30552])\n\n    \"\"\"\n    return np.where(vector > 0, vector, alpha * vector)", "output": "Implements the LeakyReLU activation function."}
{"input": "search code:\nDownload an image from a given URL by scraping the 'og:image' meta tag.\nChoices:\n0: def solution(n: int = 1000) -> int:\n    \"\"\"Returns the index of the first term in the Fibonacci sequence to contain\n    n digits.\n\n    >>> solution(1000)\n    4782\n    >>> solution(100)\n    476\n    >>> solution(50)\n    237\n    >>> solution(3)\n    12\n    \"\"\"\n    answer = 1\n    gen = fibonacci_generator()\n    while len(str(next(gen))) < n:\n        answer += 1\n    return answer + 1\n1: def download_image(url: str) -> str:\n    \"\"\"\n    Download an image from a given URL by scraping the 'og:image' meta tag.\n\n    Parameters:\n        url: The URL to scrape.\n\n    Returns:\n        A message indicating the result of the operation.\n    \"\"\"\n    try:\n        response = httpx.get(url, timeout=10)\n        response.raise_for_status()\n    except httpx.RequestError as e:\n        return f\"An error occurred during the HTTP request to {url}: {e!r}\"\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n    image_meta_tag = soup.find(\"meta\", {\"property\": \"og:image\"})\n    if not image_meta_tag:\n        return \"No meta tag with property 'og:image' was found.\"\n\n    image_url = image_meta_tag.get(\"content\")\n    if not image_url:\n        return f\"Image URL not found in meta tag {image_meta_tag}.\"\n\n    try:\n        image_data = httpx.get(image_url, timeout=10).content\n    except httpx.RequestError as e:\n        return f\"An error occurred during the HTTP request to {image_url}: {e!r}\"\n    if not image_data:\n        return f\"Failed to download the image from {image_url}.\"\n\n    file_name = f\"{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H-%M-%S}.jpg\"\n    with open(file_name, \"wb\") as out_file:\n        out_file.write(image_data)\n    return f\"Image downloaded and saved in the file {file_name}\"\n2: def add(digits, k, addend):\n    \"\"\"\n    adds addend to digit array given in digits\n    starting at index k\n    \"\"\"\n    for j in range(k, len(digits)):\n        s = digits[j] + addend\n        if s >= 10:\n            quotient, digits[j] = divmod(s, 10)\n            addend = addend // 10 + quotient\n        else:\n            digits[j] = s\n            addend = addend // 10\n\n        if addend == 0:\n            break\n\n    while addend > 0:\n        addend, digit = divmod(addend, 10)\n        digits.append(digit)", "output": "1"}
{"input": "summarize code:\ndef solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    \"\"\"\n\n    fib = [0, 1]\n    i = 0\n    while fib[i] <= n:\n        fib.append(fib[i] + fib[i + 1])\n        if fib[i + 2] > n:\n            break\n        i += 1\n    total = 0\n    for j in range(len(fib) - 1):\n        if fib[j] % 2 == 0:\n            total += fib[j]\n\n    return total", "output": "Returns the sum of all even fibonacci sequence elements that are lower or equal to n."}
{"input": "summarize code:\ndef find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]", "output": "Returns the minimum cuts needed for a palindrome partitioning of string"}
{"input": "search code:\nConversion between volume units. >>> volume_conversion(4, \"cubic meter\", \"litre\") 4000 >>> volume_conversion(1, \"litre\", \"gallon\") 0.264172 >>> volume_conversion(1, \"kilolitre\", \"cubic meter\") 1 >>> volume_conversion(3, \"gallon\", \"cubic yard\") 0.017814279 >>> volume_conversion(2, \"cubic yard\", \"litre\") 1529.1 >>> volume_conversion(4, \"cubic foot\", \"cup\") 473.396 >>> volume_conversion(1, \"cup\", \"kilolitre\") 0.000236588 >>> volume_conversion(4, \"wrongUnit\", \"litre\") Traceback (most recent call last): ... ValueError: Invalid 'from_type' value: 'wrongUnit' Supported values are: cubic meter, litre, kilolitre, gallon, cubic yard, cubic foot, cup\nChoices:\n0: def slow_solution(max_number: int = 10**8) -> int:\n    \"\"\"\n    Returns the number of composite integers below max_number have precisely two,\n    not necessarily distinct, prime factors.\n\n    >>> slow_solution(30)\n    10\n    \"\"\"\n\n    prime_numbers = slow_calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left <= right:\n        while prime_numbers[left] * prime_numbers[right] >= max_number:\n            right -= 1\n        semiprimes_count += right - left + 1\n        left += 1\n\n    return semiprimes_count\n1: def volume_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between volume units.\n    >>> volume_conversion(4, \"cubic meter\", \"litre\")\n    4000\n    >>> volume_conversion(1, \"litre\", \"gallon\")\n    0.264172\n    >>> volume_conversion(1, \"kilolitre\", \"cubic meter\")\n    1\n    >>> volume_conversion(3, \"gallon\", \"cubic yard\")\n    0.017814279\n    >>> volume_conversion(2, \"cubic yard\", \"litre\")\n    1529.1\n    >>> volume_conversion(4, \"cubic foot\", \"cup\")\n    473.396\n    >>> volume_conversion(1, \"cup\", \"kilolitre\")\n    0.000236588\n    >>> volume_conversion(4, \"wrongUnit\", \"litre\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\n    cubic meter, litre, kilolitre, gallon, cubic yard, cubic foot, cup\n    \"\"\"\n    if from_type not in METRIC_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"\n            + \", \".join(METRIC_CONVERSION)\n        )\n    if to_type not in METRIC_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"\n            + \", \".join(METRIC_CONVERSION)\n        )\n    return (\n        value\n        * METRIC_CONVERSION[from_type].from_factor\n        * METRIC_CONVERSION[to_type].to_factor\n    )\n2: def centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius", "output": "1"}
{"input": "search code:\nReturns the sum of the factorial of digits in n >>> sum_of_digit_factorial(15) 121 >>> sum_of_digit_factorial(0) 1\nChoices:\n0: def sum_of_digit_factorial(n: int) -> int:\n    \"\"\"\n    Returns the sum of the factorial of digits in n\n    >>> sum_of_digit_factorial(15)\n    121\n    >>> sum_of_digit_factorial(0)\n    1\n    \"\"\"\n    return sum(DIGIT_FACTORIAL[d] for d in str(n))\n1: def sumset(set_a: set, set_b: set) -> set:\n    \"\"\"\n    :param first set: a set of numbers\n    :param second set: a set of numbers\n    :return: the nth number in Sylvester's sequence\n\n    >>> sumset({1, 2, 3}, {4, 5, 6})\n    {5, 6, 7, 8, 9}\n\n    >>> sumset({1, 2, 3}, {4, 5, 6, 7})\n    {5, 6, 7, 8, 9, 10}\n\n    >>> sumset({1, 2, 3, 4}, 3)\n    Traceback (most recent call last):\n    ...\n    AssertionError: The input value of [set_b=3] is not a set\n    \"\"\"\n    assert isinstance(set_a, set), f\"The input value of [set_a={set_a}] is not a set\"\n    assert isinstance(set_b, set), f\"The input value of [set_b={set_b}] is not a set\"\n\n    return {a + b for a in set_a for b in set_b}\n2: def is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0", "output": "0"}
{"input": "search code:\nYield a list of sequential items from *iterable* of length 'n' for each integer 'n' in *sizes*.\nChoices:\n0: def split_into(iterable, sizes):\n    \"\"\"Yield a list of sequential items from *iterable* of length 'n' for each\n    integer 'n' in *sizes*.\n\n        >>> list(split_into([1,2,3,4,5,6], [1,2,3]))\n        [[1], [2, 3], [4, 5, 6]]\n\n    If the sum of *sizes* is smaller than the length of *iterable*, then the\n    remaining items of *iterable* will not be returned.\n\n        >>> list(split_into([1,2,3,4,5,6], [2,3]))\n        [[1, 2], [3, 4, 5]]\n\n    If the sum of *sizes* is larger than the length of *iterable*, fewer items\n    will be returned in the iteration that overruns the *iterable* and further\n    lists will be empty:\n\n        >>> list(split_into([1,2,3,4], [1,2,3,4]))\n        [[1], [2, 3], [4], []]\n\n    When a ``None`` object is encountered in *sizes*, the returned list will\n    contain items up to the end of *iterable* the same way that\n    :func:`itertools.slice` does:\n\n        >>> list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))\n        [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]\n\n    :func:`split_into` can be useful for grouping a series of items where the\n    sizes of the groups are not uniform. An example would be where in a row\n    from a table, multiple columns represent elements of the same feature\n    (e.g. a point represented by x,y,z) but, the format is not the same for\n    all columns.\n    \"\"\"\n    # convert the iterable argument into an iterator so its contents can\n    # be consumed by islice in case it is a generator\n    it = iter(iterable)\n\n    for size in sizes:\n        if size is None:\n            yield list(it)\n            return\n        else:\n            yield list(islice(it, size))\n1: def count_vowels(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a given string.\n\n    :param s: Input string to count vowels in.\n    :return: Number of vowels in the input string.\n\n    Examples:\n    >>> count_vowels(\"hello world\")\n    3\n    >>> count_vowels(\"HELLO WORLD\")\n    3\n    >>> count_vowels(\"123 hello world\")\n    3\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a quick brown fox\")\n    5\n    >>> count_vowels(\"the quick BROWN fox\")\n    5\n    >>> count_vowels(\"PYTHON\")\n    1\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)\n2: def kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is Â½mvÂ²\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)", "output": "0"}
{"input": "search code:\nreturn F(n) >>> [fibonacci(i) for i in range(13)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\nChoices:\n0: def mode(input_list: list) -> list[Any]:\n    \"\"\"This function returns the mode(Mode as in the measures of\n    central tendency) of the input data.\n\n    The input list may contain any Datastructure or any Datatype.\n\n    >>> mode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])\n    [2]\n    >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])\n    [2]\n    >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])\n    [2, 4]\n    >>> mode([\"x\", \"y\", \"y\", \"z\"])\n    ['y']\n    >>> mode([\"x\", \"x\" , \"y\", \"y\", \"z\"])\n    ['x', 'y']\n    \"\"\"\n    if not input_list:\n        return []\n    result = [input_list.count(value) for value in input_list]\n    y = max(result)  # Gets the maximum count in the input list.\n    # Gets values of modes\n    return sorted({input_list[i] for i, value in enumerate(result) if value == y})\n1: def non_bouncy_upto(n: int) -> int:\n    \"\"\"\n    Calculate the number of non-bouncy numbers with at most n digits.\n    >>> non_bouncy_upto(1)\n    9\n    >>> non_bouncy_upto(6)\n    12951\n    >>> non_bouncy_upto(10)\n    277032\n    \"\"\"\n    return sum(non_bouncy_exact(i) for i in range(1, n + 1))\n2: def fibonacci(n: int) -> int:\n    \"\"\"\n    return F(n)\n    >>> [fibonacci(i) for i in range(13)]\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Negative arguments are not supported\")\n    return _fib(n)[0]", "output": "2"}
{"input": "search code:\nComputes the sorted sequence of digits of the cube of num.\nChoices:\n0: def generate_parenthesis(n: int) -> list[str]:\n    \"\"\"\n    Generate valid combinations of balanced parentheses for a given n.\n\n    :param n: An integer representing the number of pairs of parentheses.\n    :return: A list of strings with valid combinations.\n\n    This function uses a recursive approach to generate the combinations.\n\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\n    Space Complexity: O(n) - where 'n' is the number of pairs.\n\n    Example 1:\n    >>> generate_parenthesis(3)\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Example 2:\n    >>> generate_parenthesis(1)\n    ['()']\n    \"\"\"\n\n    result: list[str] = []\n    backtrack(\"\", 0, 0, n, result)\n    return result\n1: def new_generation(cells: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Generates the next generation for a given state of Conway's Game of Life.\n    >>> new_generation(BLINKER)\n    [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    \"\"\"\n    next_generation = []\n    for i in range(len(cells)):\n        next_generation_row = []\n        for j in range(len(cells[i])):\n            # Get the number of live neighbours\n            neighbour_count = 0\n            if i > 0 and j > 0:\n                neighbour_count += cells[i - 1][j - 1]\n            if i > 0:\n                neighbour_count += cells[i - 1][j]\n            if i > 0 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i - 1][j + 1]\n            if j > 0:\n                neighbour_count += cells[i][j - 1]\n            if j < len(cells[i]) - 1:\n                neighbour_count += cells[i][j + 1]\n            if i < len(cells) - 1 and j > 0:\n                neighbour_count += cells[i + 1][j - 1]\n            if i < len(cells) - 1:\n                neighbour_count += cells[i + 1][j]\n            if i < len(cells) - 1 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i + 1][j + 1]\n\n            # Rules of the game of life (excerpt from Wikipedia):\n            # 1. Any live cell with two or three live neighbours survives.\n            # 2. Any dead cell with three live neighbours becomes a live cell.\n            # 3. All other live cells die in the next generation.\n            #    Similarly, all other dead cells stay dead.\n            alive = cells[i][j] == 1\n            if (alive and 2 <= neighbour_count <= 3) or (\n                not alive and neighbour_count == 3\n            ):\n                next_generation_row.append(1)\n            else:\n                next_generation_row.append(0)\n\n        next_generation.append(next_generation_row)\n    return next_generation\n2: def get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))", "output": "2"}
{"input": "summarize code:\ndef modular_division2(a: int, b: int, n: int) -> int:\n    \"\"\"\n    This function used the above inversion of a to find x = (b*a^(-1))mod n\n\n    >>> modular_division2(4,8,5)\n    2\n\n    >>> modular_division2(3,8,5)\n    1\n\n    >>> modular_division2(4, 11, 5)\n    4\n\n    \"\"\"\n    s = invert_modulo(a, n)\n    x = (b * s) % n\n    return x", "output": "This function used the above inversion of a to find x = (b*a^(-1))mod n"}
{"input": "summarize code:\ndef slow_solution(max_power: int = 9) -> int:\n    \"\"\"\n    To evaluate the solution, use solution()\n    >>> slow_solution(3)\n    120\n    >>> slow_solution(6)\n    18720\n    >>> slow_solution(7)\n    68720\n    \"\"\"\n    result = 0\n    for length in range(1, max_power + 1):\n        result += slow_reversible_numbers(length, 0, [0] * length, length)\n    return result", "output": "To evaluate the solution, use solution() >>> slow_solution(3) 120 >>> slow_solution(6) 18720 >>> slow_solution(7) 68720"}
{"input": "search code:\nthis is a recursive function for get all factors of number >>> get_factors(45) Counter({3: 2, 5: 1}) >>> get_factors(2520) Counter({2: 3, 3: 2, 5: 1, 7: 1}) >>> get_factors(23) Counter({23: 1}) >>> get_factors(0) Traceback (most recent call last): ... TypeError: number must be integer and greater than zero >>> get_factors(-1) Traceback (most recent call last): ... TypeError: number must be integer and greater than zero >>> get_factors(1.5) Traceback (most recent call last): ... TypeError: number must be integer and greater than zero\nChoices:\n0: def always_reversible(iterable):\n    \"\"\"An extension of :func:`reversed` that supports all iterables, not\n    just those which implement the ``Reversible`` or ``Sequence`` protocols.\n\n        >>> print(*always_reversible(x for x in range(3)))\n        2 1 0\n\n    If the iterable is already reversible, this function returns the\n    result of :func:`reversed()`. If the iterable is not reversible,\n    this function will cache the remaining items in the iterable and\n    yield them in reverse order, which may require significant storage.\n    \"\"\"\n    try:\n        return reversed(iterable)\n    except TypeError:\n        return reversed(list(iterable))\n1: def get_factors(\n    number: int, factors: Counter | None = None, factor: int = 2\n) -> Counter:\n    \"\"\"\n    this is a recursive function for get all factors of number\n    >>> get_factors(45)\n    Counter({3: 2, 5: 1})\n    >>> get_factors(2520)\n    Counter({2: 3, 3: 2, 5: 1, 7: 1})\n    >>> get_factors(23)\n    Counter({23: 1})\n    >>> get_factors(0)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be integer and greater than zero\n    >>> get_factors(-1)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be integer and greater than zero\n    >>> get_factors(1.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be integer and greater than zero\n\n    factor can be all numbers from 2 to number that we check if number % factor == 0\n    if it is equal to zero, we check again with number // factor\n    else we increase factor by one\n    \"\"\"\n\n    match number:\n        case int(number) if number == 1:\n            return Counter({1: 1})\n        case int(num) if number > 0:\n            number = num\n        case _:\n            raise TypeError(\"number must be integer and greater than zero\")\n\n    factors = factors or Counter()\n\n    if number == factor:  # break condition\n        # all numbers are factors of itself\n        factors[factor] += 1\n        return factors\n\n    if number % factor > 0:\n        # if it is greater than zero\n        # so it is not a factor of number and we check next number\n        return get_factors(number, factors, factor + 1)\n\n    factors[factor] += 1\n    # else we update factors (that is Counter(dict-like) type) and check again\n    return get_factors(number // factor, factors, factor)\n2: def largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]", "output": "1"}
{"input": "summarize code:\ndef manhattan_distance_one_liner(point_a: list, point_b: list) -> float:\n    \"\"\"\n    Version with one liner\n\n    >>> manhattan_distance_one_liner([1,1], [2,2])\n    2.0\n    >>> manhattan_distance_one_liner([1.5,1.5], [2,2])\n    1.0\n    >>> manhattan_distance_one_liner([1.5,1.5], [2.5,2])\n    1.5\n    >>> manhattan_distance_one_liner([-3, -3, -3], [0, 0, 0])\n    9.0\n    >>> manhattan_distance_one_liner([1,1], None)\n    Traceback (most recent call last):\n         ...\n    ValueError: Missing an input\n    >>> manhattan_distance_one_liner([1,1], [2, 2, 2])\n    Traceback (most recent call last):\n         ...\n    ValueError: Both points must be in the same n-dimensional space\n    >>> manhattan_distance_one_liner([1,\"one\"], [2, 2, 2])\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    >>> manhattan_distance_one_liner(1, [2, 2, 2])\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found int\n    >>> manhattan_distance_one_liner([1,1], \"not_a_list\")\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    \"\"\"\n\n    _validate_point(point_a)\n    _validate_point(point_b)\n    if len(point_a) != len(point_b):\n        raise ValueError(\"Both points must be in the same n-dimensional space\")\n\n    return float(sum(abs(x - y) for x, y in zip(point_a, point_b)))", "output": "Version with one liner"}
{"input": "summarize code:\ndef get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for inner_position in positions:\n        y_test, x_test = inner_position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(inner_position)\n\n    return permissible_positions", "output": "Find all the valid positions a knight can move to from the current position."}
{"input": "summarize code:\ndef solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)", "output": "Returns the difference between the sum of the squares of the first n natural numbers and the square of the sum."}
{"input": "search code:\nReturn a dictionary that maps the items in *iterable* to categories defined by *keyfunc*, transforms them with *valuefunc*, and then summarizes them by category with *reducefunc*.\nChoices:\n0: def map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):\n    \"\"\"Return a dictionary that maps the items in *iterable* to categories\n    defined by *keyfunc*, transforms them with *valuefunc*, and\n    then summarizes them by category with *reducefunc*.\n\n    *valuefunc* defaults to the identity function if it is unspecified.\n    If *reducefunc* is unspecified, no summarization takes place:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> result = map_reduce('abbccc', keyfunc)\n        >>> sorted(result.items())\n        [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    Specifying *valuefunc* transforms the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc)\n        >>> sorted(result.items())\n        [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    Specifying *reducefunc* summarizes the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> reducefunc = sum\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)\n        >>> sorted(result.items())\n        [('A', 1), ('B', 2), ('C', 3)]\n\n    You may want to filter the input iterable before applying the map/reduce\n    procedure:\n\n        >>> all_items = range(30)\n        >>> items = [x for x in all_items if 10 <= x <= 20]  # Filter\n        >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n        >>> categories = map_reduce(items, keyfunc=keyfunc)\n        >>> sorted(categories.items())\n        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n        >>> summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)\n        >>> sorted(summaries.items())\n        [(0, 90), (1, 75)]\n\n    Note that all items in the iterable are gathered into a list before the\n    summarization step, which may require significant storage.\n\n    The returned object is a :obj:`collections.defaultdict` with the\n    ``default_factory`` set to ``None``, such that it behaves like a normal\n    dictionary.\n\n    \"\"\"\n\n    ret = defaultdict(list)\n\n    if valuefunc is None:\n        for item in iterable:\n            key = keyfunc(item)\n            ret[key].append(item)\n\n    else:\n        for item in iterable:\n            key = keyfunc(item)\n            value = valuefunc(item)\n            ret[key].append(value)\n\n    if reducefunc is not None:\n        for key, value_list in ret.items():\n            ret[key] = reducefunc(value_list)\n\n    ret.default_factory = None\n    return ret\n1: def filter_except(validator, iterable, *exceptions):\n    \"\"\"Yield the items from *iterable* for which the *validator* function does\n    not raise one of the specified *exceptions*.\n\n    *validator* is called for each item in *iterable*.\n    It should be a function that accepts one argument and raises an exception\n    if that item is not valid.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(filter_except(int, iterable, ValueError, TypeError))\n    ['1', '2', '4']\n\n    If an exception other than one given by *exceptions* is raised by\n    *validator*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            validator(item)\n        except exceptions:\n            pass\n        else:\n            yield item\n2: def solution(matrix_str: list[str] = MATRIX_2) -> int:\n    \"\"\"\n    Takes list of strings `matrix_str` to parse the matrix and calculates the max sum.\n\n    >>> solution([\"1 2\", \"3 4\"])\n    5\n    >>> solution(MATRIX_1)\n    3315\n    \"\"\"\n\n    n = len(matrix_str)\n    arr = np.empty(shape=(n, n), dtype=int)\n    for row, matrix_row_str in enumerate(matrix_str):\n        matrix_row_list_str = matrix_row_str.split()\n        for col, elem_str in enumerate(matrix_row_list_str):\n            arr[row, col] = int(elem_str)\n\n    cache: dict[str, int] = {}\n    return solve(arr=arr, row=0, cols=set(range(n)), cache=cache)", "output": "0"}
{"input": "summarize code:\ndef solution(n_digits: int = 20) -> int:\n    \"\"\"\n    Solves the problem for n_digits number of digits.\n\n    >>> solution(2)\n    45\n    >>> solution(10)\n    21838806\n    \"\"\"\n    cache: dict[str, int] = {}\n    return solve(digit=n_digits, prev1=0, prev2=0, sum_max=9, first=True, cache=cache)", "output": "Solves the problem for n_digits number of digits."}
{"input": "summarize code:\ndef spy(iterable, n=1):\n    \"\"\"Return a 2-tuple with a list containing the first *n* elements of\n    *iterable*, and an iterator with the same items as *iterable*.\n    This allows you to \"look ahead\" at the items in the iterable without\n    advancing it.\n\n    There is one item in the list by default:\n\n        >>> iterable = 'abcdefg'\n        >>> head, iterable = spy(iterable)\n        >>> head\n        ['a']\n        >>> list(iterable)\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\n    You may use unpacking to retrieve items instead of lists:\n\n        >>> (head,), iterable = spy('abcdefg')\n        >>> head\n        'a'\n        >>> (first, second), iterable = spy('abcdefg', 2)\n        >>> first\n        'a'\n        >>> second\n        'b'\n\n    The number of items requested can be larger than the number of items in\n    the iterable:\n\n        >>> iterable = [1, 2, 3, 4, 5]\n        >>> head, iterable = spy(iterable, 10)\n        >>> head\n        [1, 2, 3, 4, 5]\n        >>> list(iterable)\n        [1, 2, 3, 4, 5]\n\n    \"\"\"\n    p, q = tee(iterable)\n    return take(n, q), p", "output": "Return a 2-tuple with a list containing the first *n* elements of *iterable*, and an iterator with the same items as *iterable*. This allows you to \"look ahead\" at the items in the iterable without advancing it."}
{"input": "summarize code:\ndef runge_kutta_gills(\n    func: Callable[[float, float], float],\n    x_initial: float,\n    y_initial: float,\n    step_size: float,\n    x_final: float,\n) -> np.ndarray:\n    \"\"\"\n    Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4.\n\n    args:\n    func: An ordinary differential equation (ODE) as function of x and y.\n    x_initial: The initial value of x.\n    y_initial: The initial value of y.\n    step_size: The increment value of x.\n    x_final: The final value of x.\n\n    Returns:\n        Solution of y at each nodal point\n\n    >>> def f(x, y):\n    ...     return (x-y)/2\n    >>> y = runge_kutta_gills(f, 0, 3, 0.2, 5)\n    >>> float(y[-1])\n    3.4104259225717537\n\n    >>> def f(x,y):\n    ...     return x\n    >>> y = runge_kutta_gills(f, -1, 0, 0.2, 0)\n    >>> y\n    array([ 0.  , -0.18, -0.32, -0.42, -0.48, -0.5 ])\n\n    >>> def f(x, y):\n    ...     return x + y\n    >>> y = runge_kutta_gills(f, 0, 0, 0.2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The final value of x must be greater than initial value of x.\n\n    >>> def f(x, y):\n    ...     return x\n    >>> y = runge_kutta_gills(f, -1, 0, -0.2, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Step size must be positive.\n    \"\"\"\n    if x_initial >= x_final:\n        raise ValueError(\n            \"The final value of x must be greater than initial value of x.\"\n        )\n\n    if step_size <= 0:\n        raise ValueError(\"Step size must be positive.\")\n\n    n = int((x_final - x_initial) / step_size)\n    y = np.zeros(n + 1)\n    y[0] = y_initial\n    for i in range(n):\n        k1 = step_size * func(x_initial, y[i])\n        k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)\n        k3 = step_size * func(\n            x_initial + step_size / 2,\n            y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,\n        )\n        k4 = step_size * func(\n            x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3\n        )\n\n        y[i + 1] = y[i] + (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4) / 6\n        x_initial += step_size\n    return y", "output": "Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4."}
{"input": "summarize code:\ndef triplewise(iterable):\n    \"\"\"Return overlapping triplets from *iterable*.\n\n    >>> list(triplewise('ABCDE'))\n    [('A', 'B', 'C'), ('B', 'C', 'D'), ('C', 'D', 'E')]\n\n    \"\"\"\n    # This deviates from the itertools documentation recipe - see\n    # https://github.com/more-itertools/more-itertools/issues/889\n    t1, t2, t3 = tee(iterable, 3)\n    next(t3, None)\n    next(t3, None)\n    next(t2, None)\n    return zip(t1, t2, t3)", "output": "Return overlapping triplets from *iterable*."}
{"input": "summarize code:\ndef quantum_fourier_transform(number_of_qubits: int = 3) -> qiskit.result.counts.Counts:\n    \"\"\"\n    # >>> quantum_fourier_transform(2)\n    # {'00': 2500, '01': 2500, '11': 2500, '10': 2500}\n    # quantum circuit for number_of_qubits = 3:\n                                               â”Œâ”€â”€â”€â”\n    qr_0: â”€â”€â”€â”€â”€â”€â– â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â– â”€â”€â”€â”€â”€â”€â”€â”¤ H â”œâ”€Xâ”€\n                â”‚                â”Œâ”€â”€â”€â” â”‚P(Ï€/2) â””â”€â”€â”€â”˜ â”‚\n    qr_1: â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â– â”€â”€â”€â”€â”€â”€â”€â”¤ H â”œâ”€â– â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€\n          â”Œâ”€â”€â”€â” â”‚P(Ï€/4)  â”‚P(Ï€/2) â””â”€â”€â”€â”˜               â”‚\n    qr_2: â”¤ H â”œâ”€â– â”€â”€â”€â”€â”€â”€â”€â”€â– â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Xâ”€\n          â””â”€â”€â”€â”˜\n    cr: 3/â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    Args:\n        n : number of qubits\n    Returns:\n        qiskit.result.counts.Counts: distribute counts.\n\n    >>> quantum_fourier_transform(2)\n    {'00': 2500, '01': 2500, '10': 2500, '11': 2500}\n    >>> quantum_fourier_transform(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number of qubits must be > 0.\n    >>> quantum_fourier_transform('a')\n    Traceback (most recent call last):\n        ...\n    TypeError: number of qubits must be a integer.\n    >>> quantum_fourier_transform(100)\n    Traceback (most recent call last):\n        ...\n    ValueError: number of qubits too large to simulate(>10).\n    >>> quantum_fourier_transform(0.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: number of qubits must be exact integer.\n    \"\"\"\n    if isinstance(number_of_qubits, str):\n        raise TypeError(\"number of qubits must be a integer.\")\n    if number_of_qubits <= 0:\n        raise ValueError(\"number of qubits must be > 0.\")\n    if math.floor(number_of_qubits) != number_of_qubits:\n        raise ValueError(\"number of qubits must be exact integer.\")\n    if number_of_qubits > 10:\n        raise ValueError(\"number of qubits too large to simulate(>10).\")\n\n    qr = QuantumRegister(number_of_qubits, \"qr\")\n    cr = ClassicalRegister(number_of_qubits, \"cr\")\n\n    quantum_circuit = QuantumCircuit(qr, cr)\n\n    counter = number_of_qubits\n\n    for i in range(counter):\n        quantum_circuit.h(number_of_qubits - i - 1)\n        counter -= 1\n        for j in range(counter):\n            quantum_circuit.cp(np.pi / 2 ** (counter - j), j, counter)\n\n    for k in range(number_of_qubits // 2):\n        quantum_circuit.swap(k, number_of_qubits - k - 1)\n\n    # measure all the qubits\n    quantum_circuit.measure(qr, cr)\n    # simulate with 10000 shots\n    backend = Aer.get_backend(\"qasm_simulator\")\n    job = execute(quantum_circuit, backend, shots=10000)\n\n    return job.result().get_counts(quantum_circuit)", "output": "# >>> quantum_fourier_transform(2) # {'00': 2500, '01': 2500, '11': 2500, '10': 2500} # quantum circuit for number_of_qubits = 3: â”Œâ”€â”€â”€â” qr_0: â”€â”€â”€â”€â”€â”€â– â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â– â”€â”€â”€â”€â”€â”€â”€â”¤ H â”œâ”€Xâ”€ â”‚ â”Œâ”€â”€â”€â” â”‚P(Ï€/2) â””â”€â”€â”€â”˜ â”‚ qr_1: â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â– â”€â”€â”€â”€â”€â”€â”€â”¤ H â”œâ”€â– â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€ â”Œâ”€â”€â”€â” â”‚P(Ï€/4) â”‚P(Ï€/2) â””â”€â”€â”€â”˜ â”‚ qr_2: â”¤ H â”œâ”€â– â”€â”€â”€â”€â”€â”€â”€â”€â– â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Xâ”€ â””â”€â”€â”€â”˜ cr: 3/â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Args: n : number of qubits Returns: qiskit.result.counts.Counts: distribute counts."}
{"input": "search code:\nThis function returns the decimal value of a number multiplied with log(2) Since the problem is on powers of two, finding the powers of two with large exponents is time consuming. Hence we use log to reduce compute time.\nChoices:\n0: def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)\n1: def max_tasks(tasks_info: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    Create a list of Task objects that are sorted so the highest rewards come first.\n    Return a list of those task ids that can be completed before i becomes too high.\n    >>> max_tasks([(4, 20), (1, 10), (1, 40), (1, 30)])\n    [2, 0]\n    >>> max_tasks([(1, 10), (2, 20), (3, 30), (2, 40)])\n    [3, 2]\n    >>> max_tasks([(9, 10)])\n    [0]\n    >>> max_tasks([(-9, 10)])\n    []\n    >>> max_tasks([])\n    []\n    >>> max_tasks([(0, 10), (0, 20), (0, 30), (0, 40)])\n    []\n    >>> max_tasks([(-1, 10), (-2, 20), (-3, 30), (-4, 40)])\n    []\n    \"\"\"\n    tasks = sorted(\n        (\n            Task(task_id, deadline, reward)\n            for task_id, (deadline, reward) in enumerate(tasks_info)\n        ),\n        key=attrgetter(\"reward\"),\n        reverse=True,\n    )\n    return [task.task_id for i, task in enumerate(tasks, start=1) if task.deadline >= i]\n2: def log_difference(number: int) -> float:\n    \"\"\"\n    This function returns the decimal value of a number multiplied with log(2)\n    Since the problem is on powers of two, finding the powers of two with\n    large exponents is time consuming. Hence we use log to reduce compute time.\n\n    We can find out that the first power of 2 with starting digits 123 is 90.\n    Computing 2^90 is time consuming.\n    Hence we find log(2^90) = 90*log(2) = 27.092699609758302\n    But we require only the decimal part to determine whether the power starts with 123.\n    So we just return the decimal part of the log product.\n    Therefore we return 0.092699609758302\n\n    >>> log_difference(90)\n    0.092699609758302\n    >>> log_difference(379)\n    0.090368356648852\n\n    \"\"\"\n\n    log_number = math.log(2, 10) * number\n    difference = round((log_number - int(log_number)), 15)\n\n    return difference", "output": "2"}
{"input": "summarize code:\ndef prime_sieve_eratosthenes(num: int) -> list[int]:\n    \"\"\"\n    Print the prime numbers up to n\n\n    >>> prime_sieve_eratosthenes(10)\n    [2, 3, 5, 7]\n    >>> prime_sieve_eratosthenes(20)\n    [2, 3, 5, 7, 11, 13, 17, 19]\n    >>> prime_sieve_eratosthenes(2)\n    [2]\n    >>> prime_sieve_eratosthenes(1)\n    []\n    >>> prime_sieve_eratosthenes(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be a positive integer\n    \"\"\"\n\n    if num <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    primes = [True] * (num + 1)\n\n    p = 2\n    while p * p <= num:\n        if primes[p]:\n            for i in range(p * p, num + 1, p):\n                primes[i] = False\n        p += 1\n\n    return [prime for prime in range(2, num + 1) if primes[prime]]", "output": "Print the prime numbers up to n"}
{"input": "search code:\nCalculate the area of a ellipse.\nChoices:\n0: def is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )\n1: def pretty_print(n):\n    \"\"\"\n    Print a complete diamond pattern with '*' characters.\n\n    Args:\n        n (int): Size of the pattern.\n\n    Examples:\n        >>> pretty_print(0)\n        '       ...       ....        nothing printing :('\n\n        >>> pretty_print(3)\n        '  * \\\\n * * \\\\n* * * \\\\n* * * \\\\n * * \\\\n  * \\\\n   '\n    \"\"\"\n    if n <= 0:\n        return \"       ...       ....        nothing printing :(\"\n    upper_half = floyd(n)  # upper half\n    lower_half = reverse_floyd(n)  # lower half\n    return upper_half + lower_half\n2: def area_ellipse(radius_x: float, radius_y: float) -> float:\n    \"\"\"\n    Calculate the area of a ellipse.\n\n    >>> area_ellipse(10, 10)\n    314.1592653589793\n    >>> area_ellipse(10, 20)\n    628.3185307179587\n    >>> area_ellipse(0, 0)\n    0.0\n    >>> area_ellipse(1.6, 2.6)\n    13.06902543893354\n    >>> area_ellipse(-10, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_ellipse() only accepts non-negative values\n    >>> area_ellipse(10, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_ellipse() only accepts non-negative values\n    >>> area_ellipse(-10, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_ellipse() only accepts non-negative values\n    \"\"\"\n    if radius_x < 0 or radius_y < 0:\n        raise ValueError(\"area_ellipse() only accepts non-negative values\")\n    return pi * radius_x * radius_y", "output": "2"}
{"input": "search code:\nCalculate the waiting times of a list of processes that have a specified duration.\nChoices:\n0: def circular_shifts(iterable, steps=1):\n    \"\"\"Yield the circular shifts of *iterable*.\n\n    >>> list(circular_shifts(range(4)))\n    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n\n    Set *steps* to the number of places to rotate to the left\n    (or to the right if negative).  Defaults to 1.\n\n    >>> list(circular_shifts(range(4), 2))\n    [(0, 1, 2, 3), (2, 3, 0, 1)]\n\n    >>> list(circular_shifts(range(4), -1))\n    [(0, 1, 2, 3), (3, 0, 1, 2), (2, 3, 0, 1), (1, 2, 3, 0)]\n\n    \"\"\"\n    buffer = deque(iterable)\n    if steps == 0:\n        raise ValueError('Steps should be a non-zero integer')\n\n    buffer.rotate(steps)\n    steps = -steps\n    n = len(buffer)\n    n //= math.gcd(n, steps)\n\n    for _ in repeat(None, n):\n        buffer.rotate(steps)\n        yield tuple(buffer)\n1: def get_filter_points(\n    sample_rate: int,\n    freq_min: int,\n    freq_high: int,\n    mel_filter_num: int = 10,\n    ftt_size: int = 1024,\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Calculate the filter points and frequencies for mel frequency filters.\n\n    Args:\n        sample_rate: The sample rate of the audio.\n        freq_min: The minimum frequency in Hertz.\n        freq_high: The maximum frequency in Hertz.\n        mel_filter_num: The number of mel filters (default is 10).\n        ftt_size: The size of the FFT (default is 1024).\n\n    Returns:\n        Filter points and corresponding frequencies.\n\n    Examples:\n    >>> filter_points = get_filter_points(8000, 0, 4000, mel_filter_num=4, ftt_size=512)\n    >>> filter_points[0]\n    array([  0,  20,  51,  95, 161, 256])\n    >>> filter_points[1]\n    array([   0.        ,  324.46707094,  799.33254207, 1494.30973963,\n           2511.42581671, 4000.        ])\n    \"\"\"\n    # Convert minimum and maximum frequencies to mel scale\n    fmin_mel = freq_to_mel(freq_min)\n    fmax_mel = freq_to_mel(freq_high)\n\n    logging.info(f\"MEL min: {fmin_mel}\")\n    logging.info(f\"MEL max: {fmax_mel}\")\n\n    # Generate equally spaced mel frequencies\n    mels = np.linspace(fmin_mel, fmax_mel, num=mel_filter_num + 2)\n\n    # Convert mel frequencies back to Hertz\n    freqs = mel_to_freq(mels)\n\n    # Calculate filter points as integer values\n    filter_points = np.floor((ftt_size + 1) / sample_rate * freqs).astype(int)\n\n    return filter_points, freqs\n2: def calculate_waiting_times(burst_times: list[int]) -> list[int]:\n    \"\"\"\n    Calculate the waiting times of a list of processes that have a specified duration.\n\n    Return: The waiting time for each process.\n    >>> calculate_waiting_times([10, 5, 8])\n    [13, 10, 13]\n    >>> calculate_waiting_times([4, 6, 3, 1])\n    [5, 8, 9, 6]\n    >>> calculate_waiting_times([12, 2, 10])\n    [12, 2, 12]\n    \"\"\"\n    quantum = 2\n    rem_burst_times = list(burst_times)\n    waiting_times = [0] * len(burst_times)\n    t = 0\n    while True:\n        done = True\n        for i, burst_time in enumerate(burst_times):\n            if rem_burst_times[i] > 0:\n                done = False\n                if rem_burst_times[i] > quantum:\n                    t += quantum\n                    rem_burst_times[i] -= quantum\n                else:\n                    t += rem_burst_times[i]\n                    waiting_times[i] = t - burst_time\n                    rem_burst_times[i] = 0\n        if done is True:\n            return waiting_times", "output": "2"}
{"input": "search code:\nA generator that produces numbers in the Fibonacci sequence\nChoices:\n0: def fibonacci_generator() -> Generator[int]:\n    \"\"\"\n    A generator that produces numbers in the Fibonacci sequence\n\n    >>> generator = fibonacci_generator()\n    >>> next(generator)\n    1\n    >>> next(generator)\n    2\n    >>> next(generator)\n    3\n    >>> next(generator)\n    5\n    >>> next(generator)\n    8\n    \"\"\"\n    a, b = 0, 1\n    while True:\n        a, b = b, a + b\n        yield b\n1: def subslices(iterable):\n    \"\"\"Return all contiguous non-empty subslices of *iterable*.\n\n        >>> list(subslices('ABC'))\n        [['A'], ['A', 'B'], ['A', 'B', 'C'], ['B'], ['B', 'C'], ['C']]\n\n    This is similar to :func:`substrings`, but emits items in a different\n    order.\n    \"\"\"\n    seq = list(iterable)\n    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n    return map(getitem, repeat(seq), slices)\n2: def gamma_iterative(num: float) -> float:\n    \"\"\"\n    Calculates the value of Gamma function of num\n    where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).\n\n    >>> gamma_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_iterative(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_iterative(9)\n    40320.0\n    >>> from math import gamma as math_gamma\n    >>> all(.99999999 < gamma_iterative(i) / math_gamma(i) <= 1.000000001\n    ...     for i in range(1, 50))\n    True\n    >>> gamma_iterative(-1)/math_gamma(-1) <= 1.000000001\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_iterative(3.3) - math_gamma(3.3) <= 0.00000001\n    True\n    \"\"\"\n    if num <= 0:\n        raise ValueError(\"math domain error\")\n\n    return quad(integrand, 0, inf, args=(num))[0]", "output": "0"}
{"input": "summarize code:\ndef solution() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(a + 1, 400):\n            for c in range(b + 1, 500):\n                if (a + b + c) == 1000 and (a**2) + (b**2) == (c**2):\n                    return a * b * c\n\n    return -1", "output": "Returns the product of a,b,c which are Pythagorean Triplet that satisfies the following: 1. a < b < c 2. a**2 + b**2 = c**2 3. a + b + c = 1000"}
{"input": "search code:\nUnwrap text, the natural complement to :func:`textwrap.wrap`.\nChoices:\n0: def solution(n: int = 600851475143) -> int:\n    \"\"\"\n    Returns the largest prime factor of a given number n.\n\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    i = 2\n    ans = 0\n    if n == 2:\n        return 2\n    while n > 2:\n        while n % i != 0:\n            i += 1\n        ans = i\n        while n % i == 0:\n            n = n // i\n        i += 1\n    return int(ans)\n1: def unwrap_text(text, ending='\\n\\n'):\n    r\"\"\"\n    Unwrap text, the natural complement to :func:`textwrap.wrap`.\n\n    >>> text = \"Short \\n lines  \\nwrapped\\nsmall.\\n\\nAnother\\nparagraph.\"\n    >>> unwrap_text(text)\n    'Short lines wrapped small.\\n\\nAnother paragraph.'\n\n    Args:\n       text: A string to unwrap.\n       ending (str): The string to join all unwrapped paragraphs\n          by. Pass ``None`` to get the list. Defaults to '\\n\\n' for\n          compatibility with Markdown and RST.\n\n    \"\"\"\n    all_grafs = []\n    cur_graf = []\n    for line in text.splitlines():\n        line = line.strip()\n        if line:\n            cur_graf.append(line)\n        else:\n            all_grafs.append(' '.join(cur_graf))\n            cur_graf = []\n    if cur_graf:\n        all_grafs.append(' '.join(cur_graf))\n    if ending is None:\n        return all_grafs\n    return ending.join(all_grafs)\n2: def graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:\n    \"\"\"Pure implementation of graham scan algorithm in Python\n\n    :param points: The unique points on coordinates.\n    :return: The points on convex hell.\n\n    Examples:\n    >>> graham_scan([(9, 6), (3, 1), (0, 0), (5, 5), (5, 2), (7, 0), (3, 3), (1, 4)])\n    [(0, 0), (7, 0), (9, 6), (5, 5), (1, 4)]\n\n    >>> graham_scan([(0, 0), (1, 0), (1, 1), (0, 1)])\n    [(0, 0), (1, 0), (1, 1), (0, 1)]\n\n    >>> graham_scan([(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)])\n    [(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)]\n\n    >>> graham_scan([(-100, 20), (99, 3), (1, 10000001), (5133186, -25), (-66, -4)])\n    [(5133186, -25), (1, 10000001), (-100, 20), (-66, -4)]\n    \"\"\"\n\n    if len(points) <= 2:\n        # There is no convex hull\n        raise ValueError(\"graham_scan: argument must contain more than 3 points.\")\n    if len(points) == 3:\n        return points\n    # find the lowest and the most left point\n    minidx = 0\n    miny, minx = maxsize, maxsize\n    for i, point in enumerate(points):\n        x = point[0]\n        y = point[1]\n        if y < miny:\n            miny = y\n            minx = x\n            minidx = i\n        if y == miny and x < minx:\n            minx = x\n            minidx = i\n\n    # remove the lowest and the most left point from points for preparing for sort\n    points.pop(minidx)\n\n    sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))\n    # This insert actually costs complexity,\n    # and you should instead add (minx, miny) into stack later.\n    # I'm using insert just for easy understanding.\n    sorted_points.insert(0, (minx, miny))\n\n    stack: deque[tuple[int, int]] = deque()\n    stack.append(sorted_points[0])\n    stack.append(sorted_points[1])\n    stack.append(sorted_points[2])\n    # The first 3 points lines are towards the left because we sort them by their angle\n    # from minx, miny.\n    current_direction = Direction.left\n\n    for i in range(3, len(sorted_points)):\n        while True:\n            starting = stack[-2]\n            via = stack[-1]\n            target = sorted_points[i]\n            next_direction = check_direction(starting, via, target)\n\n            if next_direction == Direction.left:\n                current_direction = Direction.left\n                break\n            if next_direction == Direction.straight:\n                if current_direction == Direction.left:\n                    # We keep current_direction as left.\n                    # Because if the straight line keeps as straight,\n                    # we want to know if this straight line is towards left.\n                    break\n                elif current_direction == Direction.right:\n                    # If the straight line is towards right,\n                    # every previous points on that straight line is not convex hull.\n                    stack.pop()\n            if next_direction == Direction.right:\n                stack.pop()\n        stack.append(sorted_points[i])\n    return list(stack)", "output": "1"}
{"input": "search code:\nWrites given to_write string (should only consist of 0's and 1's) as bytes in the file\nChoices:\n0: def solution():\n    \"\"\"\n    Return the solution of the problem.\n    >>> solution()\n    296962999629\n    \"\"\"\n    prime_list = [n for n in range(1001, 10000, 2) if is_prime(n)]\n    candidates = []\n\n    for number in prime_list:\n        tmp_numbers = []\n\n        for prime_member in permutations(list(str(number))):\n            prime = int(\"\".join(prime_member))\n\n            if prime % 2 == 0:\n                continue\n\n            if search(prime, prime_list):\n                tmp_numbers.append(prime)\n\n        tmp_numbers.sort()\n        if len(tmp_numbers) >= 3:\n            candidates.append(tmp_numbers)\n\n    passed = []\n    for candidate in candidates:\n        length = len(candidate)\n        found = False\n\n        for i in range(length):\n            for j in range(i + 1, length):\n                for k in range(j + 1, length):\n                    if (\n                        abs(candidate[i] - candidate[j])\n                        == abs(candidate[j] - candidate[k])\n                        and len({candidate[i], candidate[j], candidate[k]}) == 3\n                    ):\n                        passed.append(\n                            sorted([candidate[i], candidate[j], candidate[k]])\n                        )\n                        found = True\n\n                    if found:\n                        break\n                if found:\n                    break\n            if found:\n                break\n\n    answer = set()\n    for seq in passed:\n        answer.add(\"\".join([str(i) for i in seq]))\n\n    return max(int(x) for x in answer)\n1: def p_series(nth_term: float | str, power: float | str) -> list[str]:\n    \"\"\"\n    Pure Python implementation of P-Series algorithm\n    :return: The P-Series starting from 1 to last (nth) term\n    Examples:\n    >>> p_series(5, 2)\n    ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']\n    >>> p_series(\"\", 1000)\n    ['']\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    ['1']\n    \"\"\"\n    if nth_term == \"\":\n        return [\"\"]\n    nth_term = int(nth_term)\n    power = int(power)\n    series: list[str] = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")\n    return series\n2: def write_file_binary(file_path: str, to_write: str) -> None:\n    \"\"\"\n    Writes given to_write string (should only consist of 0's and 1's) as bytes in the\n    file\n    \"\"\"\n    byte_length = 8\n    try:\n        with open(file_path, \"wb\") as opened_file:\n            result_byte_array = [\n                to_write[i : i + byte_length]\n                for i in range(0, len(to_write), byte_length)\n            ]\n\n            if len(result_byte_array[-1]) % byte_length == 0:\n                result_byte_array.append(\"10000000\")\n            else:\n                result_byte_array[-1] += \"1\" + \"0\" * (\n                    byte_length - len(result_byte_array[-1]) - 1\n                )\n\n            for elem in result_byte_array[:-1]:\n                opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()", "output": "2"}
{"input": "summarize code:\ndef get_distinct_edge(edge_array):\n    \"\"\"\n    Return Distinct edges from edge array of multiple graphs\n    >>> sorted(get_distinct_edge(edge_array))\n    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n    \"\"\"\n    distinct_edge = set()\n    for row in edge_array:\n        for item in row:\n            distinct_edge.add(item[0])\n    return list(distinct_edge)", "output": "Return Distinct edges from edge array of multiple graphs >>> sorted(get_distinct_edge(edge_array)) ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']"}
{"input": "summarize code:\ndef sigmoid_function(value: float, deriv: bool = False) -> float:\n    \"\"\"Return the sigmoid function of a float.\n\n    >>> sigmoid_function(3.5)\n    0.9706877692486436\n    >>> sigmoid_function(3.5, True)\n    -8.75\n    \"\"\"\n    if deriv:\n        return value * (1 - value)\n    return 1 / (1 + math.exp(-value))", "output": "Return the sigmoid function of a float."}
{"input": "search code:\nRotate the bits of a given int left by a given amount.\nChoices:\n0: def ichunked(iterable, n):\n    \"\"\"Break *iterable* into sub-iterables with *n* elements each.\n    :func:`ichunked` is like :func:`chunked`, but it yields iterables\n    instead of lists.\n\n    If the sub-iterables are read in order, the elements of *iterable*\n    won't be stored in memory.\n    If they are read out of order, :func:`itertools.tee` is used to cache\n    elements as necessary.\n\n    >>> from itertools import count\n    >>> all_chunks = ichunked(count(), 4)\n    >>> c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)\n    >>> list(c_2)  # c_1's elements have been cached; c_3's haven't been\n    [4, 5, 6, 7]\n    >>> list(c_1)\n    [0, 1, 2, 3]\n    >>> list(c_3)\n    [8, 9, 10, 11]\n\n    \"\"\"\n    iterator = iter(iterable)\n    while True:\n        # Create new chunk\n        chunk, materialize_next = _ichunk(iterator, n)\n\n        # Check to see whether we're at the end of the source iterable\n        if not materialize_next():\n            return\n\n        yield chunk\n\n        # Fill previous chunk's cache\n        materialize_next(None)\n1: def left_rotate_32(i: int, shift: int) -> int:\n    \"\"\"\n    Rotate the bits of a given int left by a given amount.\n\n    Arguments:\n        i {[int]} -- [given int]\n        shift {[int]} -- [shift amount]\n\n    Raises:\n        ValueError -- [either given int or shift is negative]\n\n    Returns:\n        `i` rotated to the left by `shift` bits\n\n    >>> left_rotate_32(1234, 1)\n    2468\n    >>> left_rotate_32(1111, 4)\n    17776\n    >>> left_rotate_32(2147483648, 1)\n    1\n    >>> left_rotate_32(2147483648, 3)\n    4\n    >>> left_rotate_32(4294967295, 4)\n    4294967295\n    >>> left_rotate_32(1234, 0)\n    1234\n    >>> left_rotate_32(0, 0)\n    0\n    >>> left_rotate_32(-1, 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be non-negative\n    >>> left_rotate_32(0, -1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Shift must be non-negative\n    \"\"\"\n    if i < 0:\n        raise ValueError(\"Input must be non-negative\")\n    if shift < 0:\n        raise ValueError(\"Shift must be non-negative\")\n    return ((i << shift) ^ (i >> (32 - shift))) % 2**32\n2: def find_unit_clauses(\n    clauses: list[Clause],\n    model: dict[str, bool | None],  # noqa: ARG001\n) -> tuple[list[str], dict[str, bool | None]]:\n    \"\"\"\n    Returns the unit symbols and their values to satisfy clause.\n\n    Unit symbols are symbols in a formula that are:\n      - Either the only symbol in a clause\n      - Or all other literals in that clause have been assigned ``False``\n\n    This has the following steps:\n      1. Find symbols that are the only occurrences in a clause.\n      2. Find symbols in a clause where all other literals are assigned ``False``.\n      3. Assign ``True`` or ``False`` depending on whether the symbols occurs in\n         normal or complemented form respectively.\n\n    >>> clause1 = Clause([\"A4\", \"A3\", \"A5'\", \"A1\", \"A3'\"])\n    >>> clause2 = Clause([\"A4\"])\n    >>> clause3 = Clause([\"A3\"])\n    >>> clauses, symbols = generate_parameters(Formula([clause1, clause2, clause3]))\n    >>> unit_clauses, values = find_unit_clauses(clauses, {})\n    >>> unit_clauses\n    ['A4', 'A3']\n    >>> values\n    {'A4': True, 'A3': True}\n    \"\"\"\n    unit_symbols = []\n    for clause in clauses:\n        if len(clause) == 1:\n            unit_symbols.append(next(iter(clause.literals.keys())))\n        else:\n            f_count, n_count = 0, 0\n            for literal, value in clause.literals.items():\n                if value is False:\n                    f_count += 1\n                elif value is None:\n                    sym = literal\n                    n_count += 1\n            if f_count == len(clause) - 1 and n_count == 1:\n                unit_symbols.append(sym)\n    assignment: dict[str, bool | None] = {}\n    for i in unit_symbols:\n        symbol = i[:2]\n        assignment[symbol] = len(i) == 2\n    unit_symbols = [i[:2] for i in unit_symbols]\n\n    return unit_symbols, assignment", "output": "1"}
{"input": "summarize code:\ndef adler32(plain_text: str) -> int:\n    \"\"\"\n    Function implements adler-32 hash.\n    Iterates and evaluates a new value for each character\n\n    >>> adler32('Algorithms')\n    363791387\n\n    >>> adler32('go adler em all')\n    708642122\n    \"\"\"\n    a = 1\n    b = 0\n    for plain_chr in plain_text:\n        a = (a + ord(plain_chr)) % MOD_ADLER\n        b = (b + a) % MOD_ADLER\n    return (b << 16) | a", "output": "Function implements adler-32 hash. Iterates and evaluates a new value for each character"}
{"input": "search code:\nReturns the number under n that generates the longest Collatz sequence.\nChoices:\n0: def solution(n: int = 1000000) -> int:\n    \"\"\"Returns the number under n that generates the longest Collatz sequence.\n\n    >>> solution(1000000)\n    837799\n    >>> solution(200)\n    171\n    >>> solution(5000)\n    3711\n    >>> solution(15000)\n    13255\n    \"\"\"\n\n    result = max((collatz_sequence_length(i), i) for i in range(1, n))\n    return result[1]\n1: def xor_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    calculate xor of the input values\n\n    >>> xor_gate(0, 0)\n    0\n    >>> xor_gate(0, 1)\n    1\n    >>> xor_gate(1, 0)\n    1\n    >>> xor_gate(1, 1)\n    0\n    \"\"\"\n    return (input_1, input_2).count(0) % 2\n2: def charging_inductor(\n    source_voltage: float,  # source_voltage should be in volts.\n    resistance: float,  # resistance should be in ohms.\n    inductance: float,  # inductance should be in henrys.\n    time: float,  # time should in seconds.\n) -> float:\n    \"\"\"\n    Find inductor current at any nth second after initiating its charging.\n\n    Examples\n    --------\n    >>> charging_inductor(source_voltage=5.8,resistance=1.5,inductance=2.3,time=2)\n    2.817\n\n    >>> charging_inductor(source_voltage=8,resistance=5,inductance=3,time=2)\n    1.543\n\n    >>> charging_inductor(source_voltage=8,resistance=5*pow(10,2),inductance=3,time=2)\n    0.016\n\n    >>> charging_inductor(source_voltage=-8,resistance=100,inductance=15,time=12)\n    Traceback (most recent call last):\n        ...\n    ValueError: Source voltage must be positive.\n\n    >>> charging_inductor(source_voltage=80,resistance=-15,inductance=100,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistance must be positive.\n\n    >>> charging_inductor(source_voltage=12,resistance=200,inductance=-20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductance must be positive.\n\n    >>> charging_inductor(source_voltage=0,resistance=200,inductance=20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Source voltage must be positive.\n\n    >>> charging_inductor(source_voltage=10,resistance=0,inductance=20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistance must be positive.\n\n    >>> charging_inductor(source_voltage=15, resistance=25, inductance=0, time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductance must be positive.\n    \"\"\"\n\n    if source_voltage <= 0:\n        raise ValueError(\"Source voltage must be positive.\")\n    if resistance <= 0:\n        raise ValueError(\"Resistance must be positive.\")\n    if inductance <= 0:\n        raise ValueError(\"Inductance must be positive.\")\n    return round(\n        source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3\n    )", "output": "0"}
{"input": "search code:\nImplements the SquarePlus activation function.\nChoices:\n0: def solution():\n    \"\"\"\n    Finds the amount of triangular words in the words file.\n\n    >>> solution()\n    162\n    \"\"\"\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    words_file_path = os.path.join(script_dir, \"words.txt\")\n\n    words = \"\"\n    with open(words_file_path) as f:\n        words = f.readline()\n\n    words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]\n    words = [\n        word\n        for word in [sum(ord(x) - 64 for x in word) for word in words]\n        if word in TRIANGULAR_NUMBERS\n    ]\n    return len(words)\n1: def squareplus(vector: np.ndarray, beta: float) -> np.ndarray:\n    \"\"\"\n    Implements the SquarePlus activation function.\n\n    Parameters:\n        vector (np.ndarray): The input array for the SquarePlus activation.\n        beta (float): size of the curved region\n\n    Returns:\n        np.ndarray: The input array after applying the SquarePlus activation.\n\n    Formula: f(x) = ( x + sqrt(x^2 + b) ) / 2\n\n    Examples:\n    >>> squareplus(np.array([2.3, 0.6, -2, -3.8]), beta=2)\n    array([2.5       , 1.06811457, 0.22474487, 0.12731349])\n\n    >>> squareplus(np.array([-9.2, -0.3, 0.45, -4.56]), beta=3)\n    array([0.0808119 , 0.72891979, 1.11977651, 0.15893419])\n    \"\"\"\n    return (vector + np.sqrt(vector**2 + beta)) / 2\n2: def binary_tree_count(node_count: int) -> int:\n    \"\"\"\n    Return the number of possible of binary trees.\n    :param n: number of nodes\n    :return: Number of possible binary trees\n\n    >>> binary_tree_count(5)\n    5040\n    >>> binary_tree_count(6)\n    95040\n    \"\"\"\n    return catalan_number(node_count) * factorial(node_count)", "output": "1"}
{"input": "summarize code:\ndef logical_left_shift(number: int, shift_amount: int) -> str:\n    \"\"\"\n    Take in 2 positive integers.\n    'number' is the integer to be logically left shifted 'shift_amount' times.\n    i.e. (number << shift_amount)\n    Return the shifted binary representation.\n\n    >>> logical_left_shift(0, 1)\n    '0b00'\n    >>> logical_left_shift(1, 1)\n    '0b10'\n    >>> logical_left_shift(1, 5)\n    '0b100000'\n    >>> logical_left_shift(17, 2)\n    '0b1000100'\n    >>> logical_left_shift(1983, 4)\n    '0b111101111110000'\n    >>> logical_left_shift(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: both inputs must be positive integers\n    \"\"\"\n    if number < 0 or shift_amount < 0:\n        raise ValueError(\"both inputs must be positive integers\")\n\n    binary_number = str(bin(number))\n    binary_number += \"0\" * shift_amount\n    return binary_number", "output": "Take in 2 positive integers. 'number' is the integer to be logically left shifted 'shift_amount' times. i.e. (number << shift_amount) Return the shifted binary representation."}
{"input": "search code:\nReturns the minimum difference of two pentagonal numbers P1 and P2 such that P1 + P2 is pentagonal and P2 - P1 is pentagonal. >>> solution(5000) 5482660\nChoices:\n0: def encrypt_message(\n    message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5\n) -> str:\n    \"\"\"\n    encrypt_message\n    ===============\n\n    Encrypts a message using the trifid_cipher. Any punctuatuion chars that\n    would be used should be added to the alphabet.\n\n    PARAMETERS\n    ----------\n\n    *   `message`: The message you want to encrypt.\n    *   `alphabet` (optional): The characters to be used for the cipher .\n    *   `period` (optional): The number of characters you want in a group whilst\n        encrypting.\n\n    >>> encrypt_message('I am a boy')\n    'BCDGBQY'\n\n    >>> encrypt_message(' ')\n    ''\n\n    >>> encrypt_message('   aide toi le c  iel      ta id  era    ',\n    ... 'FELIXMARDSTBCGHJKNOPQUVWYZ+',5)\n    'FMJFVOISSUFTFPUFEQQC'\n\n    \"\"\"\n    message, alphabet, character_to_number, number_to_character = __prepare(\n        message, alphabet\n    )\n\n    encrypted_numeric = \"\"\n    for i in range(0, len(message) + 1, period):\n        encrypted_numeric += __encrypt_part(\n            message[i : i + period], character_to_number\n        )\n\n    encrypted = \"\"\n    for i in range(0, len(encrypted_numeric), 3):\n        encrypted += number_to_character[encrypted_numeric[i : i + 3]]\n    return encrypted\n1: def archimedes_principle(\n    fluid_density: float, volume: float, gravity: float = g\n) -> float:\n    \"\"\"\n    Args:\n        fluid_density: density of fluid (kg/m^3)\n        volume: volume of object/liquid being displaced by the object (m^3)\n        gravity: Acceleration from gravity. Gravitational force on the system,\n            The default is Earth Gravity\n    returns:\n        the buoyant force on an object in Newtons\n\n    >>> archimedes_principle(fluid_density=500, volume=4, gravity=9.8)\n    19600.0\n    >>> archimedes_principle(fluid_density=997, volume=0.5, gravity=9.8)\n    4885.3\n    >>> archimedes_principle(fluid_density=997, volume=0.7)\n    6844.061035\n    >>> archimedes_principle(fluid_density=997, volume=-0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible object volume\n    >>> archimedes_principle(fluid_density=0, volume=0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible fluid density\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=0)\n    0.0\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=-9.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible gravity\n    \"\"\"\n\n    if fluid_density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if volume <= 0:\n        raise ValueError(\"Impossible object volume\")\n    if gravity < 0:\n        raise ValueError(\"Impossible gravity\")\n\n    return fluid_density * gravity * volume\n2: def solution(limit: int = 5000) -> int:\n    \"\"\"\n    Returns the minimum difference of two pentagonal numbers P1 and P2 such that\n    P1 + P2 is pentagonal and P2 - P1 is pentagonal.\n    >>> solution(5000)\n    5482660\n    \"\"\"\n    pentagonal_nums = [(i * (3 * i - 1)) // 2 for i in range(1, limit)]\n    for i, pentagonal_i in enumerate(pentagonal_nums):\n        for j in range(i, len(pentagonal_nums)):\n            pentagonal_j = pentagonal_nums[j]\n            a = pentagonal_i + pentagonal_j\n            b = pentagonal_j - pentagonal_i\n            if is_pentagonal(a) and is_pentagonal(b):\n                return b\n\n    return -1", "output": "2"}
{"input": "search code:\nadds addend to digit array given in digits starting at index k\nChoices:\n0: def merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:\n    \"\"\"\n    Returns root node of the merged tree.\n\n    >>> tree1 = Node(5)\n    >>> tree1.left = Node(6)\n    >>> tree1.right = Node(7)\n    >>> tree1.left.left = Node(2)\n    >>> tree2 = Node(4)\n    >>> tree2.left = Node(5)\n    >>> tree2.right = Node(8)\n    >>> tree2.left.right = Node(1)\n    >>> tree2.right.right = Node(4)\n    >>> merged_tree = merge_two_binary_trees(tree1, tree2)\n    >>> print_preorder(merged_tree)\n    9\n    11\n    2\n    1\n    15\n    4\n    \"\"\"\n    if tree1 is None:\n        return tree2\n    if tree2 is None:\n        return tree1\n\n    tree1.value = tree1.value + tree2.value\n    tree1.left = merge_two_binary_trees(tree1.left, tree2.left)\n    tree1.right = merge_two_binary_trees(tree1.right, tree2.right)\n    return tree1\n1: def add(digits, k, addend):\n    \"\"\"\n    adds addend to digit array given in digits\n    starting at index k\n    \"\"\"\n    for j in range(k, len(digits)):\n        s = digits[j] + addend\n        if s >= 10:\n            quotient, digits[j] = divmod(s, 10)\n            addend = addend // 10 + quotient\n        else:\n            digits[j] = s\n            addend = addend // 10\n\n        if addend == 0:\n            break\n\n    while addend > 0:\n        addend, digit = divmod(addend, 10)\n        digits.append(digit)\n2: def distinct_combinations(iterable, r):\n    \"\"\"Yield the distinct combinations of *r* items taken from *iterable*.\n\n        >>> list(distinct_combinations([0, 0, 1], 2))\n        [(0, 0), (0, 1)]\n\n    Equivalent to ``set(combinations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    \"\"\"\n    if r < 0:\n        raise ValueError('r must be non-negative')\n    elif r == 0:\n        yield ()\n        return\n    pool = tuple(iterable)\n    generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]\n    current_combo = [None] * r\n    level = 0\n    while generators:\n        try:\n            cur_idx, p = next(generators[-1])\n        except StopIteration:\n            generators.pop()\n            level -= 1\n            continue\n        current_combo[level] = p\n        if level + 1 == r:\n            yield tuple(current_combo)\n        else:\n            generators.append(\n                unique_everseen(\n                    enumerate(pool[cur_idx + 1 :], cur_idx + 1),\n                    key=itemgetter(1),\n                )\n            )\n            level += 1", "output": "1"}
{"input": "search code:\nInplace implementation of the MSD radix sort algorithm. Sorts based on the binary representation of the integers. >>> lst = [1, 345, 23, 89, 0, 3] >>> msd_radix_sort_inplace(lst) >>> lst == sorted(lst) True >>> lst = [1, 43, 0, 0, 0, 24, 3, 3] >>> msd_radix_sort_inplace(lst) >>> lst == sorted(lst) True >>> lst = [] >>> msd_radix_sort_inplace(lst) >>> lst == [] True >>> lst = [-1, 34, 23, 4, -42] >>> msd_radix_sort_inplace(lst) Traceback (most recent call last): ... ValueError: All numbers must be positive\nChoices:\n0: def msd_radix_sort_inplace(list_of_ints: list[int]):\n    \"\"\"\n    Inplace implementation of the MSD radix sort algorithm.\n    Sorts based on the binary representation of the integers.\n    >>> lst = [1, 345, 23, 89, 0, 3]\n    >>> msd_radix_sort_inplace(lst)\n    >>> lst == sorted(lst)\n    True\n    >>> lst = [1, 43, 0, 0, 0, 24, 3, 3]\n    >>> msd_radix_sort_inplace(lst)\n    >>> lst == sorted(lst)\n    True\n    >>> lst = []\n    >>> msd_radix_sort_inplace(lst)\n    >>> lst == []\n    True\n    >>> lst = [-1, 34, 23, 4, -42]\n    >>> msd_radix_sort_inplace(lst)\n    Traceback (most recent call last):\n        ...\n    ValueError: All numbers must be positive\n    \"\"\"\n\n    length = len(list_of_ints)\n    if not list_of_ints or length == 1:\n        return\n\n    if min(list_of_ints) < 0:\n        raise ValueError(\"All numbers must be positive\")\n\n    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)\n    _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)\n1: def generate_pascal_triangle_optimized(num_rows: int) -> list[list[int]]:\n    \"\"\"\n    This function returns a matrix representing the corresponding pascal's triangle\n    according to the given input of number of rows of Pascal's triangle to be generated.\n    It reduces the operations done to generate a row by half\n    by eliminating redundant calculations.\n\n    :param num_rows: Integer specifying the number of rows in the Pascal's triangle\n    :return: 2-D List (matrix) representing the Pascal's triangle\n\n    Return the Pascal's triangle of given rows\n    >>> generate_pascal_triangle_optimized(3)\n    [[1], [1, 1], [1, 2, 1]]\n    >>> generate_pascal_triangle_optimized(1)\n    [[1]]\n    >>> generate_pascal_triangle_optimized(0)\n    []\n    >>> generate_pascal_triangle_optimized(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value of 'num_rows' should be greater than or equal to 0\n    >>> generate_pascal_triangle_optimized(7.89)\n    Traceback (most recent call last):\n        ...\n    TypeError: The input value of 'num_rows' should be 'int'\n    \"\"\"\n\n    if not isinstance(num_rows, int):\n        raise TypeError(\"The input value of 'num_rows' should be 'int'\")\n\n    if num_rows == 0:\n        return []\n    elif num_rows < 0:\n        raise ValueError(\n            \"The input value of 'num_rows' should be greater than or equal to 0\"\n        )\n\n    result: list[list[int]] = [[1]]\n\n    for row_index in range(1, num_rows):\n        temp_row = [0] + result[-1] + [0]\n        row_length = row_index + 1\n        # Calculate the number of distinct elements in a row\n        distinct_elements = sum(divmod(row_length, 2))\n        row_first_half = [\n            temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)\n        ]\n        row_second_half = row_first_half[: (row_index + 1) // 2]\n        row_second_half.reverse()\n        row = row_first_half + row_second_half\n        result.append(row)\n\n    return result\n2: def reactive_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate reactive power from apparent power and power factor.\n\n    Examples:\n    >>> reactive_power(100, 0.9)\n    43.58898943540673\n    >>> reactive_power(0, 0.8)\n    0.0\n    >>> reactive_power(100, -0.9)\n    43.58898943540673\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * math.sqrt(1 - power_factor**2)", "output": "0"}
{"input": "summarize code:\ndef solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i**2\n        sum_of_ints += i\n    return sum_of_ints**2 - sum_of_squares", "output": "Returns the difference between the sum of the squares of the first n natural numbers and the square of the sum."}
{"input": "search code:\nReturns for given minimum block length the least value of n for which the fill-count function first exceeds one million\nChoices:\n0: def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column\n1: def longest_subsequence(array: list[int]) -> list[int]:\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 50, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [7, 7]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    n = len(array)\n    # The longest increasing subsequence ending at array[i]\n    longest_increasing_subsequence = []\n    for i in range(n):\n        longest_increasing_subsequence.append([array[i]])\n\n    for i in range(1, n):\n        for prev in range(i):\n            # If array[prev] is less than or equal to array[i], then\n            # longest_increasing_subsequence[prev] + array[i]\n            # is a valid increasing subsequence\n\n            # longest_increasing_subsequence[i] is only set to\n            # longest_increasing_subsequence[prev] + array[i] if the length is longer.\n\n            if array[prev] <= array[i] and len(\n                longest_increasing_subsequence[prev]\n            ) + 1 > len(longest_increasing_subsequence[i]):\n                longest_increasing_subsequence[i] = copy.copy(\n                    longest_increasing_subsequence[prev]\n                )\n                longest_increasing_subsequence[i].append(array[i])\n\n    result: list[int] = []\n    for i in range(n):\n        if len(longest_increasing_subsequence[i]) > len(result):\n            result = longest_increasing_subsequence[i]\n\n    return result\n2: def solution(min_block_length: int = 50) -> int:\n    \"\"\"\n    Returns for given minimum block length the least value of n\n    for which the fill-count function first exceeds one million\n\n    >>> solution(3)\n    30\n\n    >>> solution(10)\n    57\n    \"\"\"\n\n    fill_count_functions = [1] * min_block_length\n\n    for n in count(min_block_length):\n        fill_count_functions.append(1)\n\n        for block_length in range(min_block_length, n + 1):\n            for block_start in range(n - block_length):\n                fill_count_functions[n] += fill_count_functions[\n                    n - block_start - block_length - 1\n                ]\n\n            fill_count_functions[n] += 1\n\n        if fill_count_functions[n] > 1_000_000:\n            break\n\n    return n", "output": "2"}
{"input": "summarize code:\ndef line_length(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    \"\"\"\n    Approximates the arc length of a line segment by treating the curve as a\n    sequence of linear lines and summing their lengths\n    :param fnc: a function which defines a curve\n    :param x_start: left end point to indicate the start of line segment\n    :param x_end: right end point to indicate end of line segment\n    :param steps: an accuracy gauge; more steps increases accuracy\n    :return: a float representing the length of the curve\n\n    >>> def f(x):\n    ...    return x\n    >>> f\"{line_length(f, 0, 1, 10):.6f}\"\n    '1.414214'\n\n    >>> def f(x):\n    ...    return 1\n    >>> f\"{line_length(f, -5.5, 4.5):.6f}\"\n    '10.000000'\n\n    >>> def f(x):\n    ...    return math.sin(5 * x) + math.cos(10 * x) + x * x/10\n    >>> f\"{line_length(f, 0.0, 10.0, 10000):.6f}\"\n    '69.534930'\n    \"\"\"\n\n    x1 = x_start\n    fx1 = fnc(x_start)\n    length = 0.0\n\n    for _ in range(steps):\n        # Approximates curve as a sequence of linear lines and sums their length\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        length += math.hypot(x2 - x1, fx2 - fx1)\n\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n\n    return length", "output": "Approximates the arc length of a line segment by treating the curve as a sequence of linear lines and summing their lengths :param fnc: a function which defines a curve :param x_start: left end point to indicate the start of line segment :param x_end: right end point to indicate end of line segment :param steps: an accuracy gauge; more steps increases accuracy :return: a float representing the length of the curve"}
{"input": "summarize code:\ndef sentence_to_title_case(input_str: str) -> str:\n    \"\"\"\n    Converts a string to title case, preserving the input as is\n\n    >>> sentence_to_title_case(\"Aakash Giri\")\n    'Aakash Giri'\n\n    >>> sentence_to_title_case(\"aakash giri\")\n    'Aakash Giri'\n\n    >>> sentence_to_title_case(\"AAKASH GIRI\")\n    'Aakash Giri'\n\n    >>> sentence_to_title_case(\"aAkAsH gIrI\")\n    'Aakash Giri'\n    \"\"\"\n\n    return \" \".join(to_title_case(word) for word in input_str.split())", "output": "Converts a string to title case, preserving the input as is"}
{"input": "search code:\nConvenience function for calling :func:`windowed` on *src*, with *size* set to 2.\nChoices:\n0: def bisection(function: Callable[[float], float], a: float, b: float) -> float:\n    \"\"\"\n    finds where function becomes 0 in [a,b] using bolzano\n    >>> bisection(lambda x: x ** 3 - 1, -5, 5)\n    1.0000000149011612\n    >>> bisection(lambda x: x ** 3 - 1, 2, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 0, 2)\n    1.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 2, 4)\n    3.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    \"\"\"\n    start: float = a\n    end: float = b\n    if function(a) == 0:  # one of the a or b is a root for the function\n        return a\n    elif function(b) == 0:\n        return b\n    elif (\n        function(a) * function(b) > 0\n    ):  # if none of these are root and they are both positive or negative,\n        # then this algorithm can't find the root\n        raise ValueError(\"could not find root in given interval.\")\n    else:\n        mid: float = start + (end - start) / 2.0\n        while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7\n            if function(mid) == 0:\n                return mid\n            elif function(mid) * function(start) < 0:\n                end = mid\n            else:\n                start = mid\n            mid = start + (end - start) / 2.0\n        return mid\n1: def copy_tree(src, dst, symlinks=False, ignore=None):\n    \"\"\"The ``copy_tree`` function is an exact copy of the built-in\n    :func:`shutil.copytree`, with one key difference: it will not\n    raise an exception if part of the tree already exists. It achieves\n    this by using :func:`mkdir_p`.\n\n    As of Python 3.8, you may pass :func:`shutil.copytree` the\n    `dirs_exist_ok=True` flag to achieve the same effect.\n\n    Args:\n        src (str): Path of the source directory to copy.\n        dst (str): Destination path. Existing directories accepted.\n        symlinks (bool): If ``True``, copy symlinks rather than their\n            contents.\n        ignore (callable): A callable that takes a path and directory\n            listing, returning the files within the listing to be ignored.\n\n    For more details, check out :func:`shutil.copytree` and\n    :func:`shutil.copy2`.\n\n    \"\"\"\n    names = os.listdir(src)\n    if ignore is not None:\n        ignored_names = ignore(src, names)\n    else:\n        ignored_names = set()\n\n    mkdir_p(dst)\n    errors = []\n    for name in names:\n        if name in ignored_names:\n            continue\n        srcname = os.path.join(src, name)\n        dstname = os.path.join(dst, name)\n        try:\n            if symlinks and os.path.islink(srcname):\n                linkto = os.readlink(srcname)\n                os.symlink(linkto, dstname)\n            elif os.path.isdir(srcname):\n                copytree(srcname, dstname, symlinks, ignore)\n            else:\n                # Will raise a SpecialFileError for unsupported file types\n                copy2(srcname, dstname)\n        # catch the Error from the recursive copytree so that we can\n        # continue with other files\n        except Error as e:\n            errors.extend(e.args[0])\n        except OSError as why:\n            errors.append((srcname, dstname, str(why)))\n    try:\n        copystat(src, dst)\n    except OSError as why:\n        errors.append((src, dst, str(why)))\n    if errors:\n        raise Error(errors)\n2: def pairwise(src, end=_UNSET):\n    \"\"\"Convenience function for calling :func:`windowed` on *src*, with\n    *size* set to 2.\n\n    >>> pairwise(range(5))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n    >>> pairwise([])\n    []\n\n    Unless *end* is set, the number of pairs is always one less than \n    the number of elements in the iterable passed in, except on an empty input, \n    which will return an empty list.\n\n    With *end* set, a number of pairs equal to the length of *src* is returned,\n    with the last item of the last pair being equal to *end*.\n\n    >>> list(pairwise(range(3), end=None))\n    [(0, 1), (1, 2), (2, None)]\n\n    This way, *end* values can be useful as sentinels to signal the end of the iterable.\n    \"\"\"\n    return windowed(src, 2, fill=end)", "output": "2"}
{"input": "summarize code:\ndef depth_first_search(graph: dict, start: str) -> set[str]:\n    \"\"\"Depth First Search on Graph\n    :param graph: directed graph in dictionary format\n    :param start: starting vertex as a string\n    :returns: the trace of the search\n    >>> input_G = { \"A\": [\"B\", \"C\", \"D\"], \"B\": [\"A\", \"D\", \"E\"],\n    ... \"C\": [\"A\", \"F\"], \"D\": [\"B\", \"D\"], \"E\": [\"B\", \"F\"],\n    ... \"F\": [\"C\", \"E\", \"G\"], \"G\": [\"F\"] }\n    >>> output_G = list({'A', 'B', 'C', 'D', 'E', 'F', 'G'})\n    >>> all(x in output_G for x in list(depth_first_search(input_G, \"A\")))\n    True\n    >>> all(x in output_G for x in list(depth_first_search(input_G, \"G\")))\n    True\n    \"\"\"\n    explored, stack = set(start), [start]\n\n    while stack:\n        v = stack.pop()\n        explored.add(v)\n        # Differences from BFS:\n        # 1) pop last element instead of first one\n        # 2) add adjacent elements to stack without exploring them\n        for adj in reversed(graph[v]):\n            if adj not in explored:\n                stack.append(adj)\n    return explored", "output": "Depth First Search on Graph :param graph: directed graph in dictionary format :param start: starting vertex as a string :returns: the trace of the search >>> input_G = { \"A\": [\"B\", \"C\", \"D\"], \"B\": [\"A\", \"D\", \"E\"], ... \"C\": [\"A\", \"F\"], \"D\": [\"B\", \"D\"], \"E\": [\"B\", \"F\"], ... \"F\": [\"C\", \"E\", \"G\"], \"G\": [\"F\"] } >>> output_G = list({'A', 'B', 'C', 'D', 'E', 'F', 'G'}) >>> all(x in output_G for x in list(depth_first_search(input_G, \"A\"))) True >>> all(x in output_G for x in list(depth_first_search(input_G, \"G\"))) True"}
{"input": "search code:\nTakes a type and returns an iterator over all class variables throughout the type hierarchy (respecting the MRO).\nChoices:\n0: def map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):\n    \"\"\"Return a dictionary that maps the items in *iterable* to categories\n    defined by *keyfunc*, transforms them with *valuefunc*, and\n    then summarizes them by category with *reducefunc*.\n\n    *valuefunc* defaults to the identity function if it is unspecified.\n    If *reducefunc* is unspecified, no summarization takes place:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> result = map_reduce('abbccc', keyfunc)\n        >>> sorted(result.items())\n        [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    Specifying *valuefunc* transforms the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc)\n        >>> sorted(result.items())\n        [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    Specifying *reducefunc* summarizes the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> reducefunc = sum\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)\n        >>> sorted(result.items())\n        [('A', 1), ('B', 2), ('C', 3)]\n\n    You may want to filter the input iterable before applying the map/reduce\n    procedure:\n\n        >>> all_items = range(30)\n        >>> items = [x for x in all_items if 10 <= x <= 20]  # Filter\n        >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n        >>> categories = map_reduce(items, keyfunc=keyfunc)\n        >>> sorted(categories.items())\n        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n        >>> summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)\n        >>> sorted(summaries.items())\n        [(0, 90), (1, 75)]\n\n    Note that all items in the iterable are gathered into a list before the\n    summarization step, which may require significant storage.\n\n    The returned object is a :obj:`collections.defaultdict` with the\n    ``default_factory`` set to ``None``, such that it behaves like a normal\n    dictionary.\n\n    \"\"\"\n\n    ret = defaultdict(list)\n\n    if valuefunc is None:\n        for item in iterable:\n            key = keyfunc(item)\n            ret[key].append(item)\n\n    else:\n        for item in iterable:\n            key = keyfunc(item)\n            value = valuefunc(item)\n            ret[key].append(value)\n\n    if reducefunc is not None:\n        for key, value_list in ret.items():\n            ret[key] = reducefunc(value_list)\n\n    ret.default_factory = None\n    return ret\n1: def mro_items(type_obj):\n    \"\"\"Takes a type and returns an iterator over all class variables\n    throughout the type hierarchy (respecting the MRO).\n\n    >>> sorted(set([k for k, v in mro_items(int) if not k.startswith('__') and 'bytes' not in k and not callable(v)]))\n    ['denominator', 'imag', 'numerator', 'real']\n    \"\"\"\n    # TODO: handle slots?\n    return itertools.chain.from_iterable(ct.__dict__.items()\n                                         for ct in type_obj.__mro__)\n2: def score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch", "output": "1"}
{"input": "search code:\nReturns the sum of the digits of the number 2^power.\nChoices:\n0: def nth_combination(iterable, r, index):\n    \"\"\"Equivalent to ``list(combinations(iterable, r))[index]``.\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`nth_combination` computes the subsequence at\n    sort position *index* directly, without computing the previous\n    subsequences.\n\n        >>> nth_combination(range(5), 3, 5)\n        (0, 3, 4)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = 1\n    k = min(r, n - r)\n    for i in range(1, k + 1):\n        c = c * (n - k + i) // i\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    while r:\n        c, n, r = c * r // n, n - 1, r - 1\n        while index >= c:\n            index -= c\n            c, n = c * (n - r) // n, n - 1\n        result.append(pool[-1 - n])\n\n    return tuple(result)\n1: def hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)\n2: def solution(power: int = 1000) -> int:\n    \"\"\"Returns the sum of the digits of the number 2^power.\n\n    >>> solution(1000)\n    1366\n    >>> solution(50)\n    76\n    >>> solution(20)\n    31\n    >>> solution(15)\n    26\n    \"\"\"\n    n = 2**power\n    r = 0\n    while n:\n        r, n = r + n % 10, n // 10\n    return r", "output": "2"}
{"input": "search code:\nGet images list and annotations list from input dir. Update new images and annotations. Save images and annotations in output dir.\nChoices:\n0: def counting_sort(collection):\n    \"\"\"Pure implementation of counting sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> counting_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> counting_sort([])\n    []\n    >>> counting_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered\n1: def main() -> None:\n    \"\"\"\n    Get images list and annotations list from input dir.\n    Update new images and annotations.\n    Save images and annotations in output dir.\n    \"\"\"\n    img_paths, annos = get_dataset(LABEL_DIR, IMG_DIR)\n    for index in range(NUMBER_IMAGES):\n        idxs = random.sample(range(len(annos)), 4)\n        new_image, new_annos, path = update_image_and_anno(\n            img_paths,\n            annos,\n            idxs,\n            OUTPUT_SIZE,\n            SCALE_RANGE,\n            filter_scale=FILTER_TINY_SCALE,\n        )\n\n        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n        letter_code = random_chars(32)\n        file_name = path.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        file_root = f\"{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}\"\n        cv2.imwrite(f\"{file_root}.jpg\", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])\n        print(f\"Succeeded {index + 1}/{NUMBER_IMAGES} with {file_name}\")\n        annos_list = []\n        for anno in new_annos:\n            width = anno[3] - anno[1]\n            height = anno[4] - anno[2]\n            x_center = anno[1] + width / 2\n            y_center = anno[2] + height / 2\n            obj = f\"{anno[0]} {x_center} {y_center} {width} {height}\"\n            annos_list.append(obj)\n        with open(f\"{file_root}.txt\", \"w\") as outfile:\n            outfile.write(\"\\n\".join(line for line in annos_list))\n2: def partitions(iterable):\n    \"\"\"Yield all possible order-preserving partitions of *iterable*.\n\n    >>> iterable = 'abc'\n    >>> for part in partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['a', 'b', 'c']\n\n    This is unrelated to :func:`partition`.\n\n    \"\"\"\n    sequence = list(iterable)\n    n = len(sequence)\n    for i in powerset(range(1, n)):\n        yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]", "output": "1"}
{"input": "search code:\nWill convert the entire string to lowercase letters\nChoices:\n0: def solution(length: int = 50) -> int:\n    \"\"\"\n    Returns the number of ways a row of the given length can be filled\n\n    >>> solution(7)\n    17\n    \"\"\"\n\n    ways_number = [1] * (length + 1)\n\n    for row_length in range(3, length + 1):\n        for block_length in range(3, row_length + 1):\n            for block_start in range(row_length - block_length):\n                ways_number[row_length] += ways_number[\n                    row_length - block_start - block_length - 1\n                ]\n\n            ways_number[row_length] += 1\n\n    return ways_number[length]\n1: def lower(word: str) -> str:\n    \"\"\"\n    Will convert the entire string to lowercase letters\n\n    >>> lower(\"wow\")\n    'wow'\n    >>> lower(\"HellZo\")\n    'hellzo'\n    >>> lower(\"WHAT\")\n    'what'\n    >>> lower(\"wh[]32\")\n    'wh[]32'\n    >>> lower(\"whAT\")\n    'what'\n    \"\"\"\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)\n2: def vol_cuboid(width: float, height: float, length: float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cuboid.\n\n    :return: multiple of `width`, `length` and `height`\n\n    >>> vol_cuboid(1, 1, 1)\n    1.0\n    >>> vol_cuboid(1, 2, 3)\n    6.0\n    >>> vol_cuboid(1.6, 2.6, 3.6)\n    14.976\n    >>> vol_cuboid(0, 0, 0)\n    0.0\n    >>> vol_cuboid(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    >>> vol_cuboid(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    >>> vol_cuboid(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    \"\"\"\n    if width < 0 or height < 0 or length < 0:\n        raise ValueError(\"vol_cuboid() only accepts non-negative values\")\n    return float(width * height * length)", "output": "1"}
{"input": "search code:\nAn isogram is a word in which no letter is repeated. Examples of isograms are uncopyrightable and ambidextrously. >>> is_isogram('Uncopyrightable') True >>> is_isogram('allowance') False >>> is_isogram('copy1') Traceback (most recent call last): ... ValueError: String must only contain alphabetic characters.\nChoices:\n0: def largest_rectangle_area(heights: list[int]) -> int:\n    \"\"\"\n    Inputs an array of integers representing the heights of bars,\n    and returns the area of the largest rectangle that can be formed\n\n    >>> largest_rectangle_area([2, 1, 5, 6, 2, 3])\n    10\n\n    >>> largest_rectangle_area([2, 4])\n    4\n\n    >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6])\n    12\n\n    >>> largest_rectangle_area([1])\n    1\n    \"\"\"\n    stack: list[int] = []\n    max_area = 0\n    heights = [*heights, 0]  # make a new list by appending the sentinel 0\n    n = len(heights)\n\n    for i in range(n):\n        # make sure the stack remains in increasing order\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]  # height of the bar\n            # if stack is empty, it means entire width can be taken from index 0 to i-1\n            w = i if not stack else i - stack[-1] - 1  # calculate width\n            max_area = max(max_area, h * w)\n\n        stack.append(i)\n\n    return max_area\n1: def update(highway_now: list, probability: float, max_speed: int) -> list:\n    \"\"\"\n    Update the speed of the cars\n    >>> update([-1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)\n    [-1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 4]\n    >>> update([-1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)\n    [-1, -1, 3, -1, -1, -1, -1, 1]\n    \"\"\"\n\n    number_of_cells = len(highway_now)\n    # Beforce calculations, the highway is empty\n    next_highway = [-1] * number_of_cells\n\n    for car_index in range(number_of_cells):\n        if highway_now[car_index] != -1:\n            # Add 1 to the current speed of the car and cap the speed\n            next_highway[car_index] = min(highway_now[car_index] + 1, max_speed)\n            # Number of empty cell before the next car\n            dn = get_distance(highway_now, car_index) - 1\n            # We can't have the car causing an accident\n            next_highway[car_index] = min(next_highway[car_index], dn)\n            if random() < probability:\n                # Randomly, a driver will slow down\n                next_highway[car_index] = max(next_highway[car_index] - 1, 0)\n    return next_highway\n2: def is_isogram(string: str) -> bool:\n    \"\"\"\n    An isogram is a word in which no letter is repeated.\n    Examples of isograms are uncopyrightable and ambidextrously.\n    >>> is_isogram('Uncopyrightable')\n    True\n    >>> is_isogram('allowance')\n    False\n    >>> is_isogram('copy1')\n    Traceback (most recent call last):\n     ...\n    ValueError: String must only contain alphabetic characters.\n    \"\"\"\n    if not all(x.isalpha() for x in string):\n        raise ValueError(\"String must only contain alphabetic characters.\")\n\n    letters = sorted(string.lower())\n    return len(letters) == len(set(letters))", "output": "2"}
{"input": "summarize code:\ndef decompress_data(data_bits: str) -> str:\n    \"\"\"\n    Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm\n    and returns the result as a string\n    \"\"\"\n    lexicon = {\"0\": \"0\", \"1\": \"1\"}\n    result, curr_string = \"\", \"\"\n    index = len(lexicon)\n\n    for i in range(len(data_bits)):\n        curr_string += data_bits[i]\n        if curr_string not in lexicon:\n            continue\n\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n        lexicon[curr_string] = last_match_id + \"0\"\n\n        if math.log2(index).is_integer():\n            new_lex = {}\n            for curr_key in list(lexicon):\n                new_lex[\"0\" + curr_key] = lexicon.pop(curr_key)\n            lexicon = new_lex\n\n        lexicon[bin(index)[2:]] = last_match_id + \"1\"\n        index += 1\n        curr_string = \"\"\n    return result", "output": "Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm and returns the result as a string"}
{"input": "summarize code:\ndef bell_numbers(max_set_length: int) -> list[int]:\n    \"\"\"\n    Calculate Bell numbers for the sets of lengths from 0 to max_set_length.\n    In other words, calculate first (max_set_length + 1) Bell numbers.\n\n    Args:\n        max_set_length (int): The maximum length of the sets for which\n        Bell numbers are calculated.\n\n    Returns:\n        list: A list of Bell numbers for sets of lengths from 0 to max_set_length.\n\n    Examples:\n    >>> bell_numbers(-2)\n    Traceback (most recent call last):\n        ...\n    ValueError: max_set_length must be non-negative\n    >>> bell_numbers(0)\n    [1]\n    >>> bell_numbers(1)\n    [1, 1]\n    >>> bell_numbers(5)\n    [1, 1, 2, 5, 15, 52]\n    \"\"\"\n    if max_set_length < 0:\n        raise ValueError(\"max_set_length must be non-negative\")\n\n    bell = [0] * (max_set_length + 1)\n    bell[0] = 1\n\n    for i in range(1, max_set_length + 1):\n        for j in range(i):\n            bell[i] += _binomial_coefficient(i - 1, j) * bell[j]\n\n    return bell", "output": "Calculate Bell numbers for the sets of lengths from 0 to max_set_length. In other words, calculate first (max_set_length + 1) Bell numbers."}
{"input": "summarize code:\ndef or_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate OR of the input values\n    >>> or_gate(0, 0)\n    0\n    >>> or_gate(0, 1)\n    1\n    >>> or_gate(1, 0)\n    1\n    >>> or_gate(1, 1)\n    1\n    \"\"\"\n    return int((input_1, input_2).count(1) != 0)", "output": "Calculate OR of the input values >>> or_gate(0, 0) 0 >>> or_gate(0, 1) 1 >>> or_gate(1, 0) 1 >>> or_gate(1, 1) 1"}
{"input": "summarize code:\ndef solution(n: int = 4) -> int | None:\n    \"\"\"Return the first value of the first four consecutive integers to have four\n    distinct prime factors each.\n    >>> solution()\n    134043\n    \"\"\"\n    results = run(n)\n    return results[0] if len(results) else None", "output": "Return the first value of the first four consecutive integers to have four distinct prime factors each. >>> solution() 134043"}
{"input": "summarize code:\ndef f(x: float) -> float:\n    \"\"\"\n    function is f(x) = x^3 - 2x - 5\n    >>> f(2)\n    -1.0\n    \"\"\"\n    return math.pow(x, 3) - (2 * x) - 5", "output": "function is f(x) = x^3 - 2x - 5 >>> f(2) -1.0"}
{"input": "search code:\nReturn a set of integers corresponding to unique prime partitions of n. The unique prime partitions can be represented as unique prime decompositions, e.g. (7+3) <-> 7*3 = 12, (3+3+2+2) = 3*3*2*2 = 36 >>> partition(10) {32, 36, 21, 25, 30} >>> partition(15) {192, 160, 105, 44, 112, 243, 180, 150, 216, 26, 125, 126} >>> len(partition(20)) 26\nChoices:\n0: def flatten_iter(iterable):\n    \"\"\"``flatten_iter()`` yields all the elements from *iterable* while\n    collapsing any nested iterables.\n\n    >>> nested = [[1, 2], [[3], [4, 5]]]\n    >>> list(flatten_iter(nested))\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    for item in iterable:\n        if isinstance(item, Iterable) and not isinstance(item, (str, bytes)):\n            yield from flatten_iter(item)\n        else:\n            yield item\n1: def is_arithmetic_series(series: list) -> bool:\n    \"\"\"\n    checking whether the input series is arithmetic series or not\n    >>> is_arithmetic_series([2, 4, 6])\n    True\n    >>> is_arithmetic_series([3, 6, 12, 24])\n    False\n    >>> is_arithmetic_series([1, 2, 3])\n    True\n    >>> is_arithmetic_series(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 6]\n    >>> is_arithmetic_series([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    if len(series) == 1:\n        return True\n    common_diff = series[1] - series[0]\n    for index in range(len(series) - 1):\n        if series[index + 1] - series[index] != common_diff:\n            return False\n    return True\n2: def partition(number_to_partition: int) -> set[int]:\n    \"\"\"\n    Return a set of integers corresponding to unique prime partitions of n.\n    The unique prime partitions can be represented as unique prime decompositions,\n    e.g. (7+3) <-> 7*3 = 12, (3+3+2+2) = 3*3*2*2 = 36\n    >>> partition(10)\n    {32, 36, 21, 25, 30}\n    >>> partition(15)\n    {192, 160, 105, 44, 112, 243, 180, 150, 216, 26, 125, 126}\n    >>> len(partition(20))\n    26\n    \"\"\"\n    if number_to_partition < 0:\n        return set()\n    elif number_to_partition == 0:\n        return {1}\n\n    ret: set[int] = set()\n    prime: int\n    sub: int\n\n    for prime in primes:\n        if prime > number_to_partition:\n            continue\n        for sub in partition(number_to_partition - prime):\n            ret.add(sub * prime)\n\n    return ret", "output": "2"}
{"input": "summarize code:\ndef unique_in_window(iterable, n, key=None):\n    \"\"\"Yield the items from *iterable* that haven't been seen recently.\n    *n* is the size of the sliding window.\n\n        >>> iterable = [0, 1, 0, 2, 3, 0]\n        >>> n = 3\n        >>> list(unique_in_window(iterable, n))\n        [0, 1, 2, 3, 0]\n\n    The *key* function, if provided, will be used to determine uniqueness:\n\n        >>> list(unique_in_window('abAcda', 3, key=lambda x: x.lower()))\n        ['a', 'b', 'c', 'd', 'a']\n\n    Updates a sliding window no larger than n and yields a value\n    if the item only occurs once in the updated window.\n\n    When `n == 1`, *unique_in_window* is memoryless:\n\n        >>> list(unique_in_window('aab', n=1))\n        ['a', 'a', 'b']\n\n    The items in *iterable* must be hashable.\n\n    \"\"\"\n    if n <= 0:\n        raise ValueError('n must be greater than 0')\n\n    window = deque(maxlen=n)\n    counts = Counter()\n    use_key = key is not None\n\n    for item in iterable:\n        if len(window) == n:\n            to_discard = window[0]\n            if counts[to_discard] == 1:\n                del counts[to_discard]\n            else:\n                counts[to_discard] -= 1\n\n        k = key(item) if use_key else item\n        if k not in counts:\n            yield item\n        counts[k] += 1\n        window.append(k)", "output": "Yield the items from *iterable* that haven't been seen recently. *n* is the size of the sliding window."}
{"input": "summarize code:\ndef generate_sum_of_subsets_solutions(nums: list[int], max_sum: int) -> list[list[int]]:\n    \"\"\"\n    The main function. For list of numbers 'nums' find the subsets with sum\n    equal to 'max_sum'\n\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=9)\n    [[3, 4, 2], [4, 5]]\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=3)\n    [[3]]\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=1)\n    []\n    \"\"\"\n\n    result: list[list[int]] = []\n    path: list[int] = []\n    num_index = 0\n    remaining_nums_sum = sum(nums)\n    create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)\n    return result", "output": "The main function. For list of numbers 'nums' find the subsets with sum equal to 'max_sum'"}
{"input": "search code:\nInserts the '(index-1)th' element into place\nChoices:\n0: def solution() -> int:\n    \"\"\"\n    Returns the first integer whose square is of the form 1_2_3_4_5_6_7_8_9_0\n    \"\"\"\n    num = 138902663\n\n    while not is_square_form(num * num):\n        if num % 10 == 3:\n            num -= 6  # (3 - 6) % 10 = 7\n        else:\n            num -= 4  # (7 - 4) % 10 = 3\n\n    return num * 10\n1: def insert_next(collection: list, index: int):\n    \"\"\"\n    Inserts the '(index-1)th' element into place\n\n    >>> col = [3, 2, 4, 2]\n    >>> insert_next(col, 1)\n    >>> col\n    [2, 3, 4, 2]\n\n    >>> col = [3, 2, 3]\n    >>> insert_next(col, 2)\n    >>> col\n    [3, 2, 3]\n\n    >>> col = []\n    >>> insert_next(col, 1)\n    >>> col\n    []\n    \"\"\"\n    # Checks order between adjacent elements\n    if index >= len(collection) or collection[index - 1] <= collection[index]:\n        return\n\n    # Swaps adjacent elements since they are not in ascending order\n    collection[index - 1], collection[index] = (\n        collection[index],\n        collection[index - 1],\n    )\n\n    insert_next(collection, index + 1)\n2: def random_graph(\n    vertices_number: int, probability: float, directed: bool = False\n) -> dict:\n    \"\"\"\n    Generate a random graph\n    @input: vertices_number (number of vertices),\n            probability (probability that a generic edge (u,v) exists),\n            directed (if True: graph will be a directed graph,\n                      otherwise it will be an undirected graph)\n    @examples:\n    >>> random.seed(1)\n    >>> random_graph(4, 0.5)\n    {0: [1], 1: [0, 2, 3], 2: [1, 3], 3: [1, 2]}\n    >>> random.seed(1)\n    >>> random_graph(4, 0.5, True)\n    {0: [1], 1: [2, 3], 2: [3], 3: []}\n    \"\"\"\n    graph: dict = {i: [] for i in range(vertices_number)}\n\n    # if probability is greater or equal than 1, then generate a complete graph\n    if probability >= 1:\n        return complete_graph(vertices_number)\n    # if probability is lower or equal than 0, then return a graph without edges\n    if probability <= 0:\n        return graph\n\n    # for each couple of nodes, add an edge from u to v\n    # if the number randomly generated is greater than probability probability\n    for i in range(vertices_number):\n        for j in range(i + 1, vertices_number):\n            if random.random() < probability:\n                graph[i].append(j)\n                if not directed:\n                    # if the graph is undirected, add an edge in from j to i, either\n                    graph[j].append(i)\n    return graph", "output": "1"}
{"input": "summarize code:\ndef local_weight(\n    point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float\n) -> np.ndarray:\n    \"\"\"\n    Calculate the local weights at a given prediction point using the weight\n    matrix for that point\n\n    Args:\n        point: x-value at which the prediction is being made\n        x_train: ndarray of x-values for training\n        y_train: ndarray of y-values for training\n        tau: bandwidth value, controls how quickly the weight of training values\n            decreases as the distance from the prediction point increases\n    Returns:\n        ndarray of local weights\n    >>> local_weight(\n    ...     np.array([1., 1.]),\n    ...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),\n    ...     np.array([[1.01, 1.66, 3.5]]),\n    ...     0.6\n    ... )\n    array([[0.00873174],\n           [0.08272556]])\n    \"\"\"\n    weight_mat = weight_matrix(point, x_train, tau)\n    weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (\n        x_train.T @ weight_mat @ y_train.T\n    )\n\n    return weight", "output": "Calculate the local weights at a given prediction point using the weight matrix for that point"}
{"input": "search code:\nCheck if a number is a perfect number.\nChoices:\n0: def factor(n):\n    \"\"\"Yield the prime factors of n.\n\n    >>> list(factor(360))\n    [2, 2, 2, 3, 3, 5]\n\n    Finds small factors with trial division.  Larger factors are\n    either verified as prime with ``is_prime`` or split into\n    smaller factors with Pollard's rho algorithm.\n    \"\"\"\n\n    # Corner case reduction\n    if n < 2:\n        return\n\n    # Trial division reduction\n    for prime in _primes_below_211:\n        while not n % prime:\n            yield prime\n            n //= prime\n\n    # Pollard's rho reduction\n    primes = []\n    todo = [n] if n > 1 else []\n    for n in todo:\n        if n < 211**2 or is_prime(n):\n            primes.append(n)\n        else:\n            fact = _factor_pollard(n)\n            todo += (fact, n // fact)\n    yield from sorted(primes)\n1: def perfect(number: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect number.\n\n    A perfect number is a positive integer that is equal to the sum of its proper\n    divisors (excluding itself).\n\n    Args:\n        number: The number to be checked.\n\n    Returns:\n        True if the number is a perfect number otherwise, False.\n    Start from 1 because dividing by 0 will raise ZeroDivisionError.\n    A number at most can be divisible by the half of the number except the number\n    itself. For example, 6 is at most can be divisible by 3 except by 6 itself.\n    Examples:\n    >>> perfect(27)\n    False\n    >>> perfect(28)\n    True\n    >>> perfect(29)\n    False\n    >>> perfect(6)\n    True\n    >>> perfect(12)\n    False\n    >>> perfect(496)\n    True\n    >>> perfect(8128)\n    True\n    >>> perfect(0)\n    False\n    >>> perfect(-1)\n    False\n    >>> perfect(33550336)  # Large perfect number\n    True\n    >>> perfect(33550337)  # Just above a large perfect number\n    False\n    >>> perfect(1)  # Edge case: 1 is not a perfect number\n    False\n    >>> perfect(\"123\")  # String representation of a number\n    Traceback (most recent call last):\n    ...\n    ValueError: number must be an integer\n    >>> perfect(12.34)\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    >>> perfect(\"Hello\")\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        raise ValueError(\"number must be an integer\")\n    if number <= 0:\n        return False\n    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number\n2: def unit_len(sized_iterable, unit_noun='item'):  # TODO: len_units()/unitize()?\n    \"\"\"Returns a plain-English description of an iterable's\n    :func:`len()`, conditionally pluralized with :func:`cardinalize`,\n    detailed below.\n\n    >>> print(unit_len(range(10), 'number'))\n    10 numbers\n    >>> print(unit_len('aeiou', 'vowel'))\n    5 vowels\n    >>> print(unit_len([], 'worry'))\n    No worries\n    \"\"\"\n    count = len(sized_iterable)\n    units = cardinalize(unit_noun, count)\n    if count:\n        return f'{count} {units}'\n    return f'No {units}'", "output": "1"}
{"input": "search code:\nInstalls a handler which, instead of exiting, attaches a post-mortem pdb console whenever an unhandled exception is encountered.\nChoices:\n0: def pdb_on_exception(limit=100):\n    \"\"\"Installs a handler which, instead of exiting, attaches a\n    post-mortem pdb console whenever an unhandled exception is\n    encountered.\n\n    Args:\n        limit (int): the max number of stack frames to display when\n            printing the traceback\n\n    A similar effect can be achieved from the command-line using the\n    following command::\n\n      python -m pdb your_code.py\n\n    But ``pdb_on_exception`` allows you to do this conditionally and within\n    your application. To restore default behavior, just do::\n\n      sys.excepthook = sys.__excepthook__\n    \"\"\"\n    import pdb\n    import sys\n    import traceback\n\n    def pdb_excepthook(exc_type, exc_val, exc_tb):\n        traceback.print_tb(exc_tb, limit=limit)\n        pdb.post_mortem(exc_tb)\n\n    sys.excepthook = pdb_excepthook\n    return\n1: def solution():\n    \"\"\"Returns the value of the first triangle number to have over five hundred\n    divisors.\n\n    >>> solution()\n    76576500\n    \"\"\"\n    return next(i for i in triangle_number_generator() if count_divisors(i) > 500)\n2: def heapify(unsorted: list[int], index: int, heap_size: int) -> None:\n    \"\"\"\n    :param unsorted: unsorted list containing integers numbers\n    :param index: index\n    :param heap_size: size of the heap\n    :return: None\n    >>> unsorted = [1, 4, 3, 5, 2]\n    >>> heapify(unsorted, 0, len(unsorted))\n    >>> unsorted\n    [4, 5, 3, 1, 2]\n    >>> heapify(unsorted, 0, len(unsorted))\n    >>> unsorted\n    [5, 4, 3, 1, 2]\n    \"\"\"\n    largest = index\n    left_index = 2 * index + 1\n    right_index = 2 * index + 2\n    if left_index < heap_size and unsorted[left_index] > unsorted[largest]:\n        largest = left_index\n\n    if right_index < heap_size and unsorted[right_index] > unsorted[largest]:\n        largest = right_index\n\n    if largest != index:\n        unsorted[largest], unsorted[index] = (unsorted[index], unsorted[largest])\n        heapify(unsorted, largest, heap_size)", "output": "0"}
{"input": "search code:\nCheck that the arguments are valid\nChoices:\n0: def solution(n: int = 7) -> int:\n    \"\"\"\n    Returns the maximum pandigital prime number of length n.\n    If there are none, then it will return 0.\n    >>> solution(2)\n    0\n    >>> solution(4)\n    4231\n    >>> solution(7)\n    7652413\n    \"\"\"\n    pandigital_str = \"\".join(str(i) for i in range(1, n + 1))\n    perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]\n    pandigitals = [num for num in perm_list if is_prime(num)]\n    return max(pandigitals) if pandigitals else 0\n1: def check_args(init_velocity: float, angle: float) -> None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n\n    # Ensure valid instance\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError(\"Invalid velocity. Should be an integer or float.\")\n\n    if not isinstance(angle, (int, float)):\n        raise TypeError(\"Invalid angle. Should be an integer or float.\")\n\n    # Ensure valid angle\n    if angle > 90 or angle < 1:\n        raise ValueError(\"Invalid angle. Range is 1-90 degrees.\")\n\n    # Ensure valid velocity\n    if init_velocity < 0:\n        raise ValueError(\"Invalid velocity. Should be a positive number.\")\n2: def get_distance(highway_now: list, car_index: int) -> int:\n    \"\"\"\n    Get the distance between a car (at index car_index) and the next car\n    >>> get_distance([6, -1, 6, -1, 6], 2)\n    1\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n    3\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n    4\n    \"\"\"\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)", "output": "1"}
{"input": "search code:\nReturns the difference between the sum of the squares of the first n natural numbers and the square of the sum.\nChoices:\n0: def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:\n    \"\"\"\n    Calculate the distance between the two endpoints of two vectors.\n    A vector is defined as a list, tuple, or numpy 1D array.\n    >>> float(euclidean_distance((0, 0), (2, 2)))\n    2.8284271247461903\n    >>> float(euclidean_distance(np.array([0, 0, 0]), np.array([2, 2, 2])))\n    3.4641016151377544\n    >>> float(euclidean_distance(np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8])))\n    8.0\n    >>> float(euclidean_distance([1, 2, 3, 4], [5, 6, 7, 8]))\n    8.0\n    \"\"\"\n    return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))\n1: def solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_of_squares = sum(i * i for i in range(1, n + 1))\n    square_of_sum = int(math.pow(sum(range(1, n + 1)), 2))\n    return square_of_sum - sum_of_squares\n2: def throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:\n    \"\"\"\n    Return probability list of all possible sums when throwing dice.\n\n    >>> random.seed(0)\n    >>> throw_dice(10, 1)\n    [10.0, 0.0, 30.0, 50.0, 10.0, 0.0]\n    >>> throw_dice(100, 1)\n    [19.0, 17.0, 17.0, 11.0, 23.0, 13.0]\n    >>> throw_dice(1000, 1)\n    [18.8, 15.5, 16.3, 17.6, 14.2, 17.6]\n    >>> throw_dice(10000, 1)\n    [16.35, 16.89, 16.93, 16.6, 16.52, 16.71]\n    >>> throw_dice(10000, 2)\n    [2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]\n    \"\"\"\n    dices = [Dice() for i in range(num_dice)]\n    count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)\n    for _ in range(num_throws):\n        count_of_sum[sum(dice.roll() for dice in dices)] += 1\n    probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]\n    return probability[num_dice:]  # remove probability of sums that never appear", "output": "1"}
{"input": "summarize code:\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True", "output": "Checks to see if a number is a prime in O(sqrt(n))."}
{"input": "search code:\nsecond method: Sarimax sarimax is a statistic method which using previous input and learn its pattern to predict future data input : training data (total_user, with exog data = total_event) in list of float output : list of total user prediction in float >>> sarimax_predictor([4,2,6,8], [3,1,2,4], [2]) 6.6666671111109626\nChoices:\n0: def split_punct_ws(text):\n    \"\"\"While :meth:`str.split` will split on whitespace,\n    :func:`split_punct_ws` will split on punctuation and\n    whitespace. This used internally by :func:`slugify`, above.\n\n    >>> split_punct_ws('First post! Hi!!!!~1    ')\n    ['First', 'post', 'Hi', '1']\n    \"\"\"\n    return [w for w in _punct_re.split(text) if w]\n1: def euler_phi(n: int) -> int:\n    \"\"\"Calculate Euler's Phi Function.\n    >>> euler_phi(100)\n    40\n    >>> euler_phi(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    >>> euler_phi(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    s = n\n    for x in set(prime_factors(n)):\n        s *= (x - 1) / x\n    return int(s)\n2: def sarimax_predictor(train_user: list, train_match: list, test_match: list) -> float:\n    \"\"\"\n    second method: Sarimax\n    sarimax is a statistic method which using previous input\n    and learn its pattern to predict future data\n    input : training data (total_user, with exog data = total_event) in list of float\n    output : list of total user prediction in float\n    >>> sarimax_predictor([4,2,6,8], [3,1,2,4], [2])\n    6.6666671111109626\n    \"\"\"\n    # Suppress the User Warning raised by SARIMAX due to insufficient observations\n    simplefilter(\"ignore\", UserWarning)\n    order = (1, 2, 1)\n    seasonal_order = (1, 1, 1, 7)\n    model = SARIMAX(\n        train_user, exog=train_match, order=order, seasonal_order=seasonal_order\n    )\n    model_fit = model.fit(disp=False, maxiter=600, method=\"nm\")\n    result = model_fit.predict(1, len(test_match), exog=[test_match])\n    return float(result[0])", "output": "2"}
{"input": "summarize code:\ndef main() -> None:\n    \"\"\"\n    Main function to create and simplify a K-Map.\n\n    >>> main()\n    [0, 1]\n    [1, 1]\n    Simplified Expression:\n    A'B + AB' + AB\n    \"\"\"\n    kmap = [[0, 1], [1, 1]]\n\n    # Manually generate the product of [0, 1] and [0, 1]\n\n    for row in kmap:\n        print(row)\n\n    print(\"Simplified Expression:\")\n    print(simplify_kmap(kmap))", "output": "Main function to create and simplify a K-Map."}
{"input": "search code:\nReturn a shell-escaped string version of *args*, separated by *sep*, using the same rules as the Microsoft C runtime.\nChoices:\n0: def max_sum_in_array(array: list[int], k: int) -> int:\n    \"\"\"\n    Returns the maximum sum of k consecutive elements\n    >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]\n    >>> k = 4\n    >>> max_sum_in_array(arr, k)\n    24\n    >>> k = 10\n    >>> max_sum_in_array(arr,k)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid Input\n    >>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2]\n    >>> k = 4\n    >>> max_sum_in_array(arr, k)\n    27\n    \"\"\"\n    if len(array) < k or k < 0:\n        raise ValueError(\"Invalid Input\")\n    max_sum = current_sum = sum(array[:k])\n    for i in range(len(array) - k):\n        current_sum = current_sum - array[i] + array[i + k]\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n1: def validate_initial_digits(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to validate initial digits of a given credit card number.\n    >>> valid = \"4111111111111111 41111111111111 34 35 37 412345 523456 634567\"\n    >>> all(validate_initial_digits(cc) for cc in valid.split())\n    True\n    >>> invalid = \"14 25 76 32323 36111111111111\"\n    >>> all(validate_initial_digits(cc) is False for cc in invalid.split())\n    True\n    \"\"\"\n    return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))\n2: def args2cmd(args, sep=' '):\n    r\"\"\"Return a shell-escaped string version of *args*, separated by\n    *sep*, using the same rules as the Microsoft C runtime.\n\n    >>> print(args2cmd(['aa', '[bb]', \"cc'cc\", 'dd\"dd']))\n    aa [bb] cc'cc dd\\\"dd\n\n    As you can see, escaping is through backslashing and not quoting,\n    and double quotes are the only special character. See the comment\n    in the code for more details. Based on internal code from the\n    :mod:`subprocess` module.\n\n    \"\"\"\n    # technique description from subprocess below\n    \"\"\"\n    1) Arguments are delimited by white space, which is either a\n       space or a tab.\n\n    2) A string surrounded by double quotation marks is\n       interpreted as a single argument, regardless of white space\n       contained within.  A quoted string can be embedded in an\n       argument.\n\n    3) A double quotation mark preceded by a backslash is\n       interpreted as a literal double quotation mark.\n\n    4) Backslashes are interpreted literally, unless they\n       immediately precede a double quotation mark.\n\n    5) If backslashes immediately precede a double quotation mark,\n       every pair of backslashes is interpreted as a literal\n       backslash.  If the number of backslashes is odd, the last\n       backslash escapes the next double quotation mark as\n       described in rule 3.\n\n    See http://msdn.microsoft.com/en-us/library/17w5ykft.aspx\n    or search http://msdn.microsoft.com for\n    \"Parsing C++ Command-Line Arguments\"\n    \"\"\"\n    result = []\n    needquote = False\n    for arg in args:\n        bs_buf = []\n\n        # Add a space to separate this argument from the others\n        if result:\n            result.append(' ')\n\n        needquote = (\" \" in arg) or (\"\\t\" in arg) or not arg\n        if needquote:\n            result.append('\"')\n\n        for c in arg:\n            if c == '\\\\':\n                # Don't know if we need to double yet.\n                bs_buf.append(c)\n            elif c == '\"':\n                # Double backslashes.\n                result.append('\\\\' * len(bs_buf)*2)\n                bs_buf = []\n                result.append('\\\\\"')\n            else:\n                # Normal char\n                if bs_buf:\n                    result.extend(bs_buf)\n                    bs_buf = []\n                result.append(c)\n\n        # Add remaining backslashes, if any.\n        if bs_buf:\n            result.extend(bs_buf)\n\n        if needquote:\n            result.extend(bs_buf)\n            result.append('\"')\n\n    return ''.join(result)", "output": "2"}
{"input": "summarize code:\ndef largest_rectangle_area(heights: list[int]) -> int:\n    \"\"\"\n    Inputs an array of integers representing the heights of bars,\n    and returns the area of the largest rectangle that can be formed\n\n    >>> largest_rectangle_area([2, 1, 5, 6, 2, 3])\n    10\n\n    >>> largest_rectangle_area([2, 4])\n    4\n\n    >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6])\n    12\n\n    >>> largest_rectangle_area([1])\n    1\n    \"\"\"\n    stack: list[int] = []\n    max_area = 0\n    heights = [*heights, 0]  # make a new list by appending the sentinel 0\n    n = len(heights)\n\n    for i in range(n):\n        # make sure the stack remains in increasing order\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]  # height of the bar\n            # if stack is empty, it means entire width can be taken from index 0 to i-1\n            w = i if not stack else i - stack[-1] - 1  # calculate width\n            max_area = max(max_area, h * w)\n\n        stack.append(i)\n\n    return max_area", "output": "Inputs an array of integers representing the heights of bars, and returns the area of the largest rectangle that can be formed"}
{"input": "search code:\nReturns True if input matrix is symmetric positive definite. Returns False otherwise.\nChoices:\n0: def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column\n1: def local_weight(\n    point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float\n) -> np.ndarray:\n    \"\"\"\n    Calculate the local weights at a given prediction point using the weight\n    matrix for that point\n\n    Args:\n        point: x-value at which the prediction is being made\n        x_train: ndarray of x-values for training\n        y_train: ndarray of y-values for training\n        tau: bandwidth value, controls how quickly the weight of training values\n            decreases as the distance from the prediction point increases\n    Returns:\n        ndarray of local weights\n    >>> local_weight(\n    ...     np.array([1., 1.]),\n    ...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),\n    ...     np.array([[1.01, 1.66, 3.5]]),\n    ...     0.6\n    ... )\n    array([[0.00873174],\n           [0.08272556]])\n    \"\"\"\n    weight_mat = weight_matrix(point, x_train, tau)\n    weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (\n        x_train.T @ weight_mat @ y_train.T\n    )\n\n    return weight\n2: def _is_matrix_spd(matrix: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if input matrix is symmetric positive definite.\n    Returns False otherwise.\n\n    For a matrix to be SPD, all eigenvalues must be positive.\n\n    >>> import numpy as np\n    >>> matrix = np.array([\n    ... [4.12401784, -5.01453636, -0.63865857],\n    ... [-5.01453636, 12.33347422, -3.40493586],\n    ... [-0.63865857, -3.40493586,  5.78591885]])\n    >>> _is_matrix_spd(matrix)\n    True\n    >>> matrix = np.array([\n    ... [0.34634879,  1.96165514,  2.18277744],\n    ... [0.74074469, -1.19648894, -1.34223498],\n    ... [-0.7687067 ,  0.06018373, -1.16315631]])\n    >>> _is_matrix_spd(matrix)\n    False\n    \"\"\"\n    # Ensure matrix is square.\n    assert np.shape(matrix)[0] == np.shape(matrix)[1]\n\n    # If matrix not symmetric, exit right away.\n    if np.allclose(matrix, matrix.T) is False:\n        return False\n\n    # Get eigenvalues and eignevectors for a symmetric matrix.\n    eigen_values, _ = np.linalg.eigh(matrix)\n\n    # Check sign of all eigenvalues.\n    # np.all returns a value of type np.bool_\n    return bool(np.all(eigen_values > 0))", "output": "2"}
{"input": "search code:\nRead the file and build a dict of all letters and their frequencies, then convert the dict into a list of Letters.\nChoices:\n0: def parse_file(file_path: str) -> list[Letter]:\n    \"\"\"\n    Read the file and build a dict of all letters and their\n    frequencies, then convert the dict into a list of Letters.\n    \"\"\"\n    chars: dict[str, int] = {}\n    with open(file_path) as f:\n        while True:\n            c = f.read(1)\n            if not c:\n                break\n            chars[c] = chars[c] + 1 if c in chars else 1\n    return sorted((Letter(c, f) for c, f in chars.items()), key=lambda x: x.freq)\n1: def consume(iterator, n=None):\n    \"\"\"Advance *iterable* by *n* steps. If *n* is ``None``, consume it\n    entirely.\n\n    Efficiently exhausts an iterator without returning values. Defaults to\n    consuming the whole iterator, but an optional second argument may be\n    provided to limit consumption.\n\n        >>> i = (x for x in range(10))\n        >>> next(i)\n        0\n        >>> consume(i, 3)\n        >>> next(i)\n        4\n        >>> consume(i)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    If the iterator has fewer items remaining than the provided limit, the\n    whole iterator will be consumed.\n\n        >>> i = (x for x in range(3))\n        >>> consume(i, 5)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    \"\"\"\n    # Use functions that consume iterators at C speed.\n    if n is None:\n        # feed the entire iterator into a zero-length deque\n        deque(iterator, maxlen=0)\n    else:\n        # advance to the empty slice starting at position n\n        next(islice(iterator, n, n), None)\n2: def deserialize(data: str) -> TreeNode | None:\n    \"\"\"\n    Deserialize a string to a binary tree.\n\n    Args:\n        data(str): The serialized string.\n\n    Returns:\n        The root of the binary tree.\n\n    >>> root = TreeNode.five_tree()\n    >>> serialzed_data = repr(root)\n    >>> deserialized = deserialize(serialzed_data)\n    >>> root == deserialized\n    True\n    >>> root is deserialized  # two separate trees\n    False\n    >>> root.right.right.value = 6\n    >>> root == deserialized\n    False\n    >>> serialzed_data = repr(root)\n    >>> deserialized = deserialize(serialzed_data)\n    >>> root == deserialized\n    True\n    >>> deserialize(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Data cannot be empty.\n    \"\"\"\n\n    if not data:\n        raise ValueError(\"Data cannot be empty.\")\n\n    # Split the serialized string by a comma to get node values\n    nodes = data.split(\",\")\n\n    def build_tree() -> TreeNode | None:\n        # Get the next value from the list\n        value = nodes.pop(0)\n\n        if value == \"null\":\n            return None\n\n        node = TreeNode(int(value))\n        node.left = build_tree()  # Recursively build left subtree\n        node.right = build_tree()  # Recursively build right subtree\n        return node\n\n    return build_tree()", "output": "0"}
{"input": "summarize code:\ndef nth_product(index, *args):\n    \"\"\"Equivalent to ``list(product(*args))[index]``.\n\n    The products of *args* can be ordered lexicographically.\n    :func:`nth_product` computes the product at sort position *index* without\n    computing the previous products.\n\n        >>> nth_product(8, range(2), range(2), range(2), range(2))\n        (1, 0, 0, 0)\n\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pools = list(map(tuple, reversed(args)))\n    ns = list(map(len, pools))\n\n    c = reduce(mul, ns)\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = []\n    for pool, n in zip(pools, ns):\n        result.append(pool[index % n])\n        index //= n\n\n    return tuple(reversed(result))", "output": "Equivalent to ``list(product(*args))[index]``."}
{"input": "summarize code:\ndef solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    >>> solution(3.4)\n    2\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    getcontext().prec = 100\n    phi = (Decimal(5) ** Decimal(\"0.5\") + 1) / Decimal(2)\n\n    index = (math.floor(math.log(n * (phi + 2), phi) - 1) // 3) * 3 + 2\n    num = Decimal(round(phi ** Decimal(index + 1))) / (phi + 2)\n    total = num // 2\n    return int(total)", "output": "Returns the sum of all even fibonacci sequence elements that are lower or equal to n."}
{"input": "search code:\nCalculate the median of a sorted matrix.\nChoices:\n0: def new_generation(cells: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Generates the next generation for a given state of Conway's Game of Life.\n    >>> new_generation(BLINKER)\n    [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    \"\"\"\n    next_generation = []\n    for i in range(len(cells)):\n        next_generation_row = []\n        for j in range(len(cells[i])):\n            # Get the number of live neighbours\n            neighbour_count = 0\n            if i > 0 and j > 0:\n                neighbour_count += cells[i - 1][j - 1]\n            if i > 0:\n                neighbour_count += cells[i - 1][j]\n            if i > 0 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i - 1][j + 1]\n            if j > 0:\n                neighbour_count += cells[i][j - 1]\n            if j < len(cells[i]) - 1:\n                neighbour_count += cells[i][j + 1]\n            if i < len(cells) - 1 and j > 0:\n                neighbour_count += cells[i + 1][j - 1]\n            if i < len(cells) - 1:\n                neighbour_count += cells[i + 1][j]\n            if i < len(cells) - 1 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i + 1][j + 1]\n\n            # Rules of the game of life (excerpt from Wikipedia):\n            # 1. Any live cell with two or three live neighbours survives.\n            # 2. Any dead cell with three live neighbours becomes a live cell.\n            # 3. All other live cells die in the next generation.\n            #    Similarly, all other dead cells stay dead.\n            alive = cells[i][j] == 1\n            if (alive and 2 <= neighbour_count <= 3) or (\n                not alive and neighbour_count == 3\n            ):\n                next_generation_row.append(1)\n            else:\n                next_generation_row.append(0)\n\n        next_generation.append(next_generation_row)\n    return next_generation\n1: def mbd(predict, actual):\n    \"\"\"\n    This value is Negative, if the model underpredicts,\n    positive, if it overpredicts.\n\n    Example(rounded for precision):\n\n    Here the model overpredicts\n    >>> actual = [1,2,3];predict = [2,3,4]\n    >>> float(np.around(mbd(predict,actual),decimals = 2))\n    50.0\n\n    Here the model underpredicts\n    >>> actual = [1,2,3];predict = [0,1,1]\n    >>> float(np.around(mbd(predict,actual),decimals = 2))\n    -66.67\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    numerator = np.sum(difference) / len(predict)\n    denumerator = np.sum(actual) / len(predict)\n    # print(numerator, denumerator)\n    score = float(numerator) / denumerator * 100\n\n    return score\n2: def median(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Calculate the median of a sorted matrix.\n\n    Args:\n        matrix: A 2D matrix of integers.\n\n    Returns:\n        The median value of the matrix.\n\n    Examples:\n        >>> matrix = [[1, 3, 5], [2, 6, 9], [3, 6, 9]]\n        >>> median(matrix)\n        5\n\n        >>> matrix = [[1, 2, 3], [4, 5, 6]]\n        >>> median(matrix)\n        3\n    \"\"\"\n    # Flatten the matrix into a sorted 1D list\n    linear = sorted(num for row in matrix for num in row)\n\n    # Calculate the middle index\n    mid = (len(linear) - 1) // 2\n\n    # Return the median\n    return linear[mid]", "output": "2"}
{"input": "summarize code:\ndef selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection", "output": "Sorts a list in ascending order using the selection sort algorithm."}
{"input": "summarize code:\ndef display_billionaires(forbes_billionaires: list[dict[str, int | str]]) -> None:\n    \"\"\"\n    Display Forbes real-time billionaires in a rich table.\n\n    Args:\n        forbes_billionaires (list): Forbes top 10 real-time billionaires\n    \"\"\"\n\n    table = rich_table.Table(\n        title=f\"Forbes Top {LIMIT} Real-Time Billionaires at {TODAY:%Y-%m-%d %H:%M}\",\n        style=\"green\",\n        highlight=True,\n        box=box.SQUARE,\n    )\n    for key in forbes_billionaires[0]:\n        table.add_column(key)\n\n    for billionaire in forbes_billionaires:\n        table.add_row(*billionaire.values())\n\n    rich_console.Console().print(table)", "output": "Display Forbes real-time billionaires in a rich table."}
{"input": "summarize code:\ndef oct_to_decimal(oct_string: str) -> int:\n    \"\"\"\n    Convert a octal value to its decimal equivalent\n\n    >>> oct_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> oct_to_decimal(\"-\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"e\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"8\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"-e\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"-8\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"1\")\n    1\n    >>> oct_to_decimal(\"-1\")\n    -1\n    >>> oct_to_decimal(\"12\")\n    10\n    >>> oct_to_decimal(\" 12   \")\n    10\n    >>> oct_to_decimal(\"-45\")\n    -37\n    >>> oct_to_decimal(\"-\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"0\")\n    0\n    >>> oct_to_decimal(\"-4055\")\n    -2093\n    >>> oct_to_decimal(\"2-0Fm\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> oct_to_decimal(\"19\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    \"\"\"\n    oct_string = str(oct_string).strip()\n    if not oct_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = oct_string[0] == \"-\"\n    if is_negative:\n        oct_string = oct_string[1:]\n    if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):\n        raise ValueError(\"Non-octal value was passed to the function\")\n    decimal_number = 0\n    for char in oct_string:\n        decimal_number = 8 * decimal_number + int(char)\n    if is_negative:\n        decimal_number = -decimal_number\n    return decimal_number", "output": "Convert a octal value to its decimal equivalent"}
{"input": "search code:\nFormat the exception part of a traceback.\nChoices:\n0: def split_when(iterable, pred, maxsplit=-1):\n    \"\"\"Split *iterable* into pieces based on the output of *pred*.\n    *pred* should be a function that takes successive pairs of items and\n    returns ``True`` if the iterable should be split in between them.\n\n    For example, to find runs of increasing numbers, split the iterable when\n    element ``i`` is larger than element ``i + 1``:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x > y))\n        [[1, 2, 3, 3], [2, 5], [2, 4], [2]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],\n        ...                 lambda x, y: x > y, maxsplit=2))\n        [[1, 2, 3, 3], [2, 5], [2, 4, 2]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    it = iter(iterable)\n    try:\n        cur_item = next(it)\n    except StopIteration:\n        return\n\n    buf = [cur_item]\n    for next_item in it:\n        if pred(cur_item, next_item):\n            yield buf\n            if maxsplit == 1:\n                yield [next_item, *it]\n                return\n            buf = []\n            maxsplit -= 1\n\n        buf.append(next_item)\n        cur_item = next_item\n\n    yield buf\n1: def solution(limit: int = 1_000_000) -> int:\n    \"\"\"\n    Returns an integer, the solution to the problem\n    >>> solution(10)\n    31\n    >>> solution(100)\n    3043\n    >>> solution(1_000)\n    304191\n    \"\"\"\n\n    # generating an array from -1 to limit\n    phi = np.arange(-1, limit)\n\n    for i in range(2, limit + 1):\n        if phi[i] == i - 1:\n            ind = np.arange(2 * i, limit + 1, i)  # indexes for selection\n            phi[ind] -= phi[ind] // i\n\n    return int(np.sum(phi[2 : limit + 1]))\n2: def format_exception_only(etype, value):\n    \"\"\"Format the exception part of a traceback.\n\n    The arguments are the exception type and value such as given by\n    sys.last_type and sys.last_value. The return value is a list of\n    strings, each ending in a newline.\n\n    Normally, the list contains a single string; however, for\n    SyntaxError exceptions, it contains several lines that (when\n    printed) display detailed information about where the syntax\n    error occurred.\n\n    The message indicating which exception occurred is always the last\n    string in the list.\n\n    \"\"\"\n    # Gracefully handle (the way Python 2.4 and earlier did) the case of\n    # being called with (None, None).\n    if etype is None:\n        return [_format_final_exc_line(etype, value)]\n\n    stype = etype.__name__\n    smod = etype.__module__\n    if smod not in (\"__main__\", \"builtins\", \"exceptions\"):\n        stype = smod + '.' + stype\n\n    if not issubclass(etype, SyntaxError):\n        return [_format_final_exc_line(stype, value)]\n\n    # It was a syntax error; show exactly where the problem was found.\n    lines = []\n    filename = value.filename or \"<string>\"\n    lineno = str(value.lineno) or '?'\n    lines.append(f'  File \"{filename}\", line {lineno}\\n')\n    badline = value.text\n    offset = value.offset\n    if badline is not None:\n        lines.append('    %s\\n' % badline.strip())\n        if offset is not None:\n            caretspace = badline.rstrip('\\n')[:offset].lstrip()\n            # non-space whitespace (likes tabs) must be kept for alignment\n            caretspace = ((c.isspace() and c or ' ') for c in caretspace)\n            # only three spaces to account for offset1 == pos 0\n            lines.append('   %s^\\n' % ''.join(caretspace))\n    msg = value.msg or \"<no detail available>\"\n    lines.append(f\"{stype}: {msg}\\n\")\n    return lines", "output": "2"}
{"input": "summarize code:\ndef get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:\n    \"\"\"\n    - label_dir <type: str>: Path to label include annotation of images\n    - img_dir <type: str>: Path to folder contain images\n    Return <type: list>: List of images path and labels\n    \"\"\"\n    img_paths = []\n    labels = []\n    for label_file in glob.glob(os.path.join(label_dir, \"*.txt\")):\n        label_name = label_file.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        with open(label_file) as in_file:\n            obj_lists = in_file.readlines()\n        img_path = os.path.join(img_dir, f\"{label_name}.jpg\")\n\n        boxes = []\n        for obj_list in obj_lists:\n            obj = obj_list.rstrip(\"\\n\").split(\" \")\n            xmin = float(obj[1]) - float(obj[3]) / 2\n            ymin = float(obj[2]) - float(obj[4]) / 2\n            xmax = float(obj[1]) + float(obj[3]) / 2\n            ymax = float(obj[2]) + float(obj[4]) / 2\n\n            boxes.append([int(obj[0]), xmin, ymin, xmax, ymax])\n        if not boxes:\n            continue\n        img_paths.append(img_path)\n        labels.append(boxes)\n    return img_paths, labels", "output": "- label_dir <type: str>: Path to label include annotation of images - img_dir <type: str>: Path to folder contain images Return <type: list>: List of images path and labels"}
{"input": "summarize code:\ndef run_length_decode(encoded: list) -> str:\n    \"\"\"\n    Performs Run Length Decoding\n    >>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)])\n    'AAAABBBCCDAA'\n    >>> run_length_decode([('A', 1)])\n    'A'\n    >>> run_length_decode([('A', 2)])\n    'AA'\n    >>> run_length_decode([('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)])\n    'AAADDDDDDFFFCCCAAVVVV'\n    \"\"\"\n    return \"\".join(char * length for char, length in encoded)", "output": "Performs Run Length Decoding >>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]) 'AAAABBBCCDAA' >>> run_length_decode([('A', 1)]) 'A' >>> run_length_decode([('A', 2)]) 'AA' >>> run_length_decode([('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]) 'AAADDDDDDFFFCCCAAVVVV'"}
{"input": "summarize code:\ndef circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection", "output": "A pure Python implementation of circle sort algorithm"}
{"input": "summarize code:\ndef num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))", "output": "Find the number of digits in a number. abs() is used for negative numbers"}
{"input": "summarize code:\ndef iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:\n    \"\"\"\n    Go through the number of iterations determined by the argument \"steps\".\n    Be careful with high values (above 5) since the time to calculate increases\n    exponentially.\n    >>> iterate([np.array([0, 0]), np.array([1, 0])], 1)\n    [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , \\\n0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]\n    \"\"\"\n    vectors = initial_vectors\n    for _ in range(steps):\n        vectors = iteration_step(vectors)\n    return vectors", "output": "Go through the number of iterations determined by the argument \"steps\". Be careful with high values (above 5) since the time to calculate increases exponentially. >>> iterate([np.array([0, 0]), np.array([1, 0])], 1) [array([0, 0]), array([0.33333333, 0. ]), array([0.5 , 0.28867513]), array([0.66666667, 0. ]), array([1, 0])]"}
{"input": "summarize code:\ndef solution():\n    \"\"\"Returns the millionth lexicographic permutation of the digits 0, 1, 2,\n    3, 4, 5, 6, 7, 8 and 9.\n\n    >>> solution()\n    '2783915460'\n    \"\"\"\n    result = list(map(\"\".join, permutations(\"0123456789\")))\n    return result[999999]", "output": "Returns the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9."}
{"input": "summarize code:\ndef msd_radix_sort(list_of_ints: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of the MSD radix sort algorithm. Only works\n    with positive integers\n    :param list_of_ints: A list of integers\n    :return: Returns the sorted list\n    >>> msd_radix_sort([40, 12, 1, 100, 4])\n    [1, 4, 12, 40, 100]\n    >>> msd_radix_sort([])\n    []\n    >>> msd_radix_sort([123, 345, 123, 80])\n    [80, 123, 123, 345]\n    >>> msd_radix_sort([1209, 834598, 1, 540402, 45])\n    [1, 45, 1209, 540402, 834598]\n    >>> msd_radix_sort([-1, 34, 45])\n    Traceback (most recent call last):\n        ...\n    ValueError: All numbers must be positive\n    \"\"\"\n    if not list_of_ints:\n        return []\n\n    if min(list_of_ints) < 0:\n        raise ValueError(\"All numbers must be positive\")\n\n    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)\n    return _msd_radix_sort(list_of_ints, most_bits)", "output": "Implementation of the MSD radix sort algorithm. Only works with positive integers :param list_of_ints: A list of integers :return: Returns the sorted list >>> msd_radix_sort([40, 12, 1, 100, 4]) [1, 4, 12, 40, 100] >>> msd_radix_sort([]) [] >>> msd_radix_sort([123, 345, 123, 80]) [80, 123, 123, 345] >>> msd_radix_sort([1209, 834598, 1, 540402, 45]) [1, 45, 1209, 540402, 834598] >>> msd_radix_sort([-1, 34, 45]) Traceback (most recent call last): ... ValueError: All numbers must be positive"}
{"input": "search code:\nShow frequency response of a filter\nChoices:\n0: def solution(limit: float = 1e10) -> int:\n    \"\"\"\n    Returns the least value of n for which the remainder first exceeds 10^10.\n    >>> solution(1e8)\n    2371\n    >>> solution(1e9)\n    7037\n    \"\"\"\n    primes = sieve()\n\n    n = 1\n    while True:\n        prime = next(primes)\n        if (2 * prime * n) > limit:\n            return n\n        # Ignore the next prime as the reminder will be 2.\n        next(primes)\n        n += 2\n1: def generate_formula() -> Formula:\n    \"\"\"\n    Randomly generate a formula.\n    \"\"\"\n    clauses: set[Clause] = set()\n    no_of_clauses = random.randint(1, 10)\n    while len(clauses) < no_of_clauses:\n        clauses.add(generate_clause())\n    return Formula(clauses)\n2: def show_frequency_response(filter_type: FilterType, samplerate: int) -> None:\n    \"\"\"\n    Show frequency response of a filter\n\n    >>> from audio_filters.iir_filter import IIRFilter\n    >>> filt = IIRFilter(4)\n    >>> show_frequency_response(filt, 48000)\n    \"\"\"\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\n\n    filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.abs(np.fft.fft(outputs))\n    fft_db = 20 * np.log10(fft_out)\n\n    # Frequencies on log scale from 24 to nyquist frequency\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\n\n    # Display within reasonable bounds\n    bounds = get_bounds(fft_db, samplerate)\n    plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))\n    plt.ylabel(\"Gain (dB)\")\n\n    plt.plot(fft_db)\n    plt.show()", "output": "2"}
{"input": "search code:\nPure implementation of comb sort algorithm in Python :param data: mutable collection with comparable items :return: the same collection in ascending order Examples: >>> comb_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> comb_sort([]) [] >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3]) [-15, -7, 0, 2, 3, 8, 45, 99]\nChoices:\n0: def newton_raphson(\n    f: RealFunc,\n    x0: float = 0,\n    max_iter: int = 100,\n    step: float = 1e-6,\n    max_error: float = 1e-6,\n    log_steps: bool = False,\n) -> tuple[float, float, list[float]]:\n    \"\"\"\n    Find a root of the given function f using the Newton-Raphson method.\n\n    :param f: A real-valued single-variable function\n    :param x0: Initial guess\n    :param max_iter: Maximum number of iterations\n    :param step: Step size of x, used to approximate f'(x)\n    :param max_error: Maximum approximation error\n    :param log_steps: bool denoting whether to log intermediate steps\n\n    :return: A tuple containing the approximation, the error, and the intermediate\n        steps. If log_steps is False, then an empty list is returned for the third\n        element of the tuple.\n\n    :raises ZeroDivisionError: The derivative approaches 0.\n    :raises ArithmeticError: No solution exists, or the solution isn't found before the\n        iteration limit is reached.\n\n    >>> import math\n    >>> tolerance = 1e-15\n    >>> root, *_ = newton_raphson(lambda x: x**2 - 5*x + 2, 0.4, max_error=tolerance)\n    >>> math.isclose(root, (5 - math.sqrt(17)) / 2, abs_tol=tolerance)\n    True\n    >>> root, *_ = newton_raphson(lambda x: math.log(x) - 1, 2, max_error=tolerance)\n    >>> math.isclose(root, math.e, abs_tol=tolerance)\n    True\n    >>> root, *_ = newton_raphson(math.sin, 1, max_error=tolerance)\n    >>> math.isclose(root, 0, abs_tol=tolerance)\n    True\n    >>> newton_raphson(math.cos, 0)\n    Traceback (most recent call last):\n    ...\n    ZeroDivisionError: No converging solution found, zero derivative\n    >>> newton_raphson(lambda x: x**2 + 1, 2)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No converging solution found, iteration limit reached\n    \"\"\"\n\n    def f_derivative(x: float) -> float:\n        return calc_derivative(f, x, step)\n\n    a = x0  # Set initial guess\n    steps = []\n    for _ in range(max_iter):\n        if log_steps:  # Log intermediate steps\n            steps.append(a)\n\n        error = abs(f(a))\n        if error < max_error:\n            return a, error, steps\n\n        if f_derivative(a) == 0:\n            raise ZeroDivisionError(\"No converging solution found, zero derivative\")\n        a -= f(a) / f_derivative(a)  # Calculate next estimate\n    raise ArithmeticError(\"No converging solution found, iteration limit reached\")\n1: def loops(n):\n    \"\"\"Returns an iterable with *n* elements for efficient looping.\n    Like ``range(n)`` but doesn't create integers.\n\n    >>> i = 0\n    >>> for _ in loops(5):\n    ...     i += 1\n    >>> i\n    5\n\n    \"\"\"\n    return repeat(None, n)\n2: def comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data", "output": "2"}
{"input": "summarize code:\ndef rotate(\n    x: float, y: float, z: float, axis: str, angle: float\n) -> tuple[float, float, float]:\n    \"\"\"\n    rotate a point around a certain axis with a certain angle\n    angle can be any integer between 1, 360 and axis can be any one of\n    'x', 'y', 'z'\n\n    >>> rotate(1.0, 2.0, 3.0, 'y', 90.0)\n    (3.130524675073759, 2.0, 0.4470070007889556)\n\n    >>> rotate(1, 2, 3, \"z\", 180)\n    (0.999736015495891, -2.0001319704760485, 3)\n\n    >>> rotate('1', 2, 3, \"z\", 90.0)  # '1' is str\n    Traceback (most recent call last):\n        ...\n    TypeError: Input values except axis must either be float or int: ['1', 2, 3, 90.0]\n\n    >>> rotate(1, 2, 3, \"n\", 90)  # 'n' is not a valid axis\n    Traceback (most recent call last):\n        ...\n    ValueError: not a valid axis, choose one of 'x', 'y', 'z'\n\n    >>> rotate(1, 2, 3, \"x\", -90)\n    (1, -2.5049096187183877, -2.5933429780983657)\n\n    >>> rotate(1, 2, 3, \"x\", 450)  # 450 wrap around to 90\n    (1, 3.5776792428178217, -0.44744970165427644)\n    \"\"\"\n    if not isinstance(axis, str):\n        raise TypeError(\"Axis must be a str\")\n    input_variables = locals()\n    del input_variables[\"axis\"]\n    if not all(isinstance(val, (float, int)) for val in input_variables.values()):\n        msg = (\n            \"Input values except axis must either be float or int: \"\n            f\"{list(input_variables.values())}\"\n        )\n        raise TypeError(msg)\n    angle = (angle % 360) / 450 * 180 / math.pi\n    if axis == \"z\":\n        new_x = x * math.cos(angle) - y * math.sin(angle)\n        new_y = y * math.cos(angle) + x * math.sin(angle)\n        new_z = z\n    elif axis == \"x\":\n        new_y = y * math.cos(angle) - z * math.sin(angle)\n        new_z = z * math.cos(angle) + y * math.sin(angle)\n        new_x = x\n    elif axis == \"y\":\n        new_x = x * math.cos(angle) - z * math.sin(angle)\n        new_z = z * math.cos(angle) + x * math.sin(angle)\n        new_y = y\n    else:\n        raise ValueError(\"not a valid axis, choose one of 'x', 'y', 'z'\")\n\n    return new_x, new_y, new_z", "output": "rotate a point around a certain axis with a certain angle angle can be any integer between 1, 360 and axis can be any one of 'x', 'y', 'z'"}
{"input": "summarize code:\ndef split(src, sep=None, maxsplit=None):\n    \"\"\"Splits an iterable based on a separator. Like :meth:`str.split`,\n    but for all iterables. Returns a list of lists.\n\n    >>> split(['hi', 'hello', None, None, 'sup', None, 'soap', None])\n    [['hi', 'hello'], ['sup'], ['soap']]\n\n    See :func:`split_iter` docs for more info.\n    \"\"\"\n    return list(split_iter(src, sep, maxsplit))", "output": "Splits an iterable based on a separator. Like :meth:`str.split`, but for all iterables. Returns a list of lists."}
{"input": "summarize code:\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]", "output": "Computes the Fibonacci number for input n by iterating through n numbers and creating an array of ints using the Fibonacci formula. Returns the nth element of the array."}
{"input": "search code:\nInterpolate and evaluate a polynomial using Neville's method. Arguments: x_points, y_points: Iterables of x and corresponding y points through which the polynomial passes. x0: The value of x to evaluate the polynomial for. Return Value: A list of the approximated value and the Neville iterations table respectively. >>> import pprint >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 5)[0] 10.0 >>> pprint.pprint(neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[1]) [[0, 6, 0, 0, 0], [0, 7, 0, 0, 0], [0, 8, 104.0, 0, 0], [0, 9, 104.0, 104.0, 0], [0, 11, 104.0, 104.0, 104.0]] >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[0] 104.0 >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), '') Traceback (most recent call last): ... TypeError: unsupported operand type(s) for -: 'str' and 'int'\nChoices:\n0: def solve(\n    digit: int, prev1: int, prev2: int, sum_max: int, first: bool, cache: dict[str, int]\n) -> int:\n    \"\"\"\n    Solve for remaining 'digit' digits, with previous 'prev1' digit, and\n    previous-previous 'prev2' digit, total sum of 'sum_max'.\n    Pass around 'cache' to store/reuse intermediate results.\n\n    >>> solve(digit=1, prev1=0, prev2=0, sum_max=9, first=True, cache={})\n    9\n    >>> solve(digit=1, prev1=0, prev2=0, sum_max=9, first=False, cache={})\n    10\n    \"\"\"\n    if digit == 0:\n        return 1\n\n    cache_str = f\"{digit},{prev1},{prev2}\"\n    if cache_str in cache:\n        return cache[cache_str]\n\n    comb = 0\n    for curr in range(sum_max - prev1 - prev2 + 1):\n        if first and curr == 0:\n            continue\n\n        comb += solve(\n            digit=digit - 1,\n            prev1=curr,\n            prev2=prev1,\n            sum_max=sum_max,\n            first=False,\n            cache=cache,\n        )\n\n    cache[cache_str] = comb\n    return comb\n1: def insert_next(collection: list, index: int):\n    \"\"\"\n    Inserts the '(index-1)th' element into place\n\n    >>> col = [3, 2, 4, 2]\n    >>> insert_next(col, 1)\n    >>> col\n    [2, 3, 4, 2]\n\n    >>> col = [3, 2, 3]\n    >>> insert_next(col, 2)\n    >>> col\n    [3, 2, 3]\n\n    >>> col = []\n    >>> insert_next(col, 1)\n    >>> col\n    []\n    \"\"\"\n    # Checks order between adjacent elements\n    if index >= len(collection) or collection[index - 1] <= collection[index]:\n        return\n\n    # Swaps adjacent elements since they are not in ascending order\n    collection[index - 1], collection[index] = (\n        collection[index],\n        collection[index - 1],\n    )\n\n    insert_next(collection, index + 1)\n2: def neville_interpolate(x_points: list, y_points: list, x0: int) -> list:\n    \"\"\"\n       Interpolate and evaluate a polynomial using Neville's method.\n       Arguments:\n           x_points, y_points: Iterables of x and corresponding y points through\n            which the polynomial passes.\n           x0: The value of x to evaluate the polynomial for.\n       Return Value: A list of the approximated value and the Neville iterations\n           table respectively.\n    >>> import pprint\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 5)[0]\n    10.0\n    >>> pprint.pprint(neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[1])\n    [[0, 6, 0, 0, 0],\n     [0, 7, 0, 0, 0],\n     [0, 8, 104.0, 0, 0],\n     [0, 9, 104.0, 104.0, 0],\n     [0, 11, 104.0, 104.0, 104.0]]\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[0]\n    104.0\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), '')\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'str' and 'int'\n    \"\"\"\n    n = len(x_points)\n    q = [[0] * n for i in range(n)]\n    for i in range(n):\n        q[i][1] = y_points[i]\n\n    for i in range(2, n):\n        for j in range(i, n):\n            q[j][i] = (\n                (x0 - x_points[j - i + 1]) * q[j][i - 1]\n                - (x0 - x_points[j]) * q[j - 1][i - 1]\n            ) / (x_points[j] - x_points[j - i + 1])\n\n    return [q[n - 1][n - 1], q]", "output": "2"}
{"input": "search code:\nDeciphers a message given a cipher map\nChoices:\n0: def bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:\n    \"\"\"\n    It recursively sorts a bitonic sequence in ascending order, if direction = 1, and in\n    descending if direction = 0.\n    The sequence to be sorted starts at index position low, the parameter length is the\n    number of elements to be sorted.\n\n    >>> arr = [12, 42, -21, 1]\n    >>> bitonic_merge(arr, 0, 4, 1)\n    >>> arr\n    [-21, 1, 12, 42]\n\n    >>> bitonic_merge(arr, 0, 4, 0)\n    >>> arr\n    [42, 12, 1, -21]\n    \"\"\"\n    if length > 1:\n        middle = int(length / 2)\n        for i in range(low, low + middle):\n            comp_and_swap(array, i, i + middle, direction)\n        bitonic_merge(array, low, middle, direction)\n        bitonic_merge(array, low + middle, middle, direction)\n1: def decipher(message: str, cipher_map: dict[str, str]) -> str:\n    \"\"\"\n    Deciphers a message given a cipher map\n\n    :param message: Message to decipher\n    :param cipher_map: Dictionary mapping to use\n    :return: Deciphered string\n\n    >>> cipher_map = create_cipher_map('Goodbye!!')\n    >>> decipher(encipher('Hello World!!', cipher_map), cipher_map)\n    'HELLO WORLD!!'\n    \"\"\"\n    # Reverse our cipher mappings\n    rev_cipher_map = {v: k for k, v in cipher_map.items()}\n    return \"\".join(rev_cipher_map.get(ch, ch) for ch in message.upper())\n2: def random_derangement(iterable):\n    \"\"\"Return a random derangement of elements in the iterable.\n\n    Equivalent to but much faster than ``choice(list(derangements(iterable)))``.\n\n    \"\"\"\n    seq = tuple(iterable)\n    if len(seq) < 2:\n        if len(seq) == 0:\n            return ()\n        raise IndexError('No derangments to choose from')\n    perm = list(range(len(seq)))\n    start = tuple(perm)\n    while True:\n        shuffle(perm)\n        if not any(map(is_, start, perm)):\n            return itemgetter(*perm)(seq)", "output": "1"}
{"input": "summarize code:\ndef remove_digit(num: int) -> int:\n    \"\"\"\n\n    returns the biggest possible result\n    that can be achieved by removing\n    one digit from the given number\n\n    >>> remove_digit(152)\n    52\n    >>> remove_digit(6385)\n    685\n    >>> remove_digit(-11)\n    1\n    >>> remove_digit(2222222)\n    222222\n    >>> remove_digit(\"2222222\")\n    Traceback (most recent call last):\n    TypeError: only integers accepted as input\n    >>> remove_digit(\"string input\")\n    Traceback (most recent call last):\n    TypeError: only integers accepted as input\n    \"\"\"\n\n    if not isinstance(num, int):\n        raise TypeError(\"only integers accepted as input\")\n    else:\n        num_str = str(abs(num))\n        num_transpositions = [list(num_str) for char in range(len(num_str))]\n        for index in range(len(num_str)):\n            num_transpositions[index].pop(index)\n        return max(\n            int(\"\".join(list(transposition))) for transposition in num_transpositions\n        )", "output": "returns the biggest possible result that can be achieved by removing one digit from the given number"}
{"input": "search code:\nChange the shape of a *matrix*.\nChoices:\n0: def unique_in_window(iterable, n, key=None):\n    \"\"\"Yield the items from *iterable* that haven't been seen recently.\n    *n* is the size of the sliding window.\n\n        >>> iterable = [0, 1, 0, 2, 3, 0]\n        >>> n = 3\n        >>> list(unique_in_window(iterable, n))\n        [0, 1, 2, 3, 0]\n\n    The *key* function, if provided, will be used to determine uniqueness:\n\n        >>> list(unique_in_window('abAcda', 3, key=lambda x: x.lower()))\n        ['a', 'b', 'c', 'd', 'a']\n\n    Updates a sliding window no larger than n and yields a value\n    if the item only occurs once in the updated window.\n\n    When `n == 1`, *unique_in_window* is memoryless:\n\n        >>> list(unique_in_window('aab', n=1))\n        ['a', 'a', 'b']\n\n    The items in *iterable* must be hashable.\n\n    \"\"\"\n    if n <= 0:\n        raise ValueError('n must be greater than 0')\n\n    window = deque(maxlen=n)\n    counts = Counter()\n    use_key = key is not None\n\n    for item in iterable:\n        if len(window) == n:\n            to_discard = window[0]\n            if counts[to_discard] == 1:\n                del counts[to_discard]\n            else:\n                counts[to_discard] -= 1\n\n        k = key(item) if use_key else item\n        if k not in counts:\n            yield item\n        counts[k] += 1\n        window.append(k)\n1: def reshape(matrix, shape):\n    \"\"\"Change the shape of a *matrix*.\n\n    If *shape* is an integer, the matrix must be two dimensional\n    and the shape is interpreted as the desired number of columns:\n\n        >>> matrix = [(0, 1), (2, 3), (4, 5)]\n        >>> cols = 3\n        >>> list(reshape(matrix, cols))\n        [(0, 1, 2), (3, 4, 5)]\n\n    If *shape* is a tuple (or other iterable), the input matrix can have\n    any number of dimensions. It will first be flattened and then rebuilt\n    to the desired shape which can also be multidimensional:\n\n        >>> matrix = [(0, 1), (2, 3), (4, 5)]    # Start with a 3 x 2 matrix\n\n        >>> list(reshape(matrix, (2, 3)))        # Make a 2 x 3 matrix\n        [(0, 1, 2), (3, 4, 5)]\n\n        >>> list(reshape(matrix, (6,)))          # Make a vector of length six\n        [0, 1, 2, 3, 4, 5]\n\n        >>> list(reshape(matrix, (2, 1, 3, 1)))  # Make 2 x 1 x 3 x 1 tensor\n        [(((0,), (1,), (2,)),), (((3,), (4,), (5,)),)]\n\n    Each dimension is assumed to be uniform, either all arrays or all scalars.\n    Flattening stops when the first value in a dimension is a scalar.\n    Scalars are bytes, strings, and non-iterables.\n    The reshape iterator stops when the requested shape is complete\n    or when the input is exhausted, whichever comes first.\n\n    \"\"\"\n    if isinstance(shape, int):\n        return batched(chain.from_iterable(matrix), shape)\n    first_dim, *dims = shape\n    scalar_stream = _flatten_tensor(matrix)\n    reshaped = reduce(batched, reversed(dims), scalar_stream)\n    return islice(reshaped, first_dim)\n2: def untyped_sorted(iterable, key=None, reverse=False):\n    \"\"\"A version of :func:`sorted` which will happily sort an iterable of\n    heterogeneous types and return a new list, similar to legacy Python's\n    behavior.\n\n    >>> untyped_sorted(['abc', 2.0, 1, 2, 'def'])\n    [1, 2.0, 2, 'abc', 'def']\n\n    Note how mutually orderable types are sorted as expected, as in\n    the case of the integers and floats above.\n\n    .. note::\n\n       Results may vary across Python versions and builds, but the\n       function will produce a sorted list, except in the case of\n       explicitly unorderable objects.\n\n    \"\"\"\n    class _Wrapper:\n        slots = ('obj',)\n\n        def __init__(self, obj):\n            self.obj = obj\n\n        def __lt__(self, other):\n            obj = key(self.obj) if key is not None else self.obj\n            other = key(other.obj) if key is not None else other.obj\n            try:\n                ret = obj < other\n            except TypeError:\n                ret = ((type(obj).__name__, id(type(obj)), obj)\n                       < (type(other).__name__, id(type(other)), other))\n            return ret\n\n    if key is not None and not callable(key):\n        raise TypeError('expected function or callable object for key, not: %r'\n                        % key)\n\n    return sorted(iterable, key=_Wrapper, reverse=reverse)", "output": "1"}
{"input": "search code:\nCalculate the Fast Fourier Transform (FFT) of windowed audio data.\nChoices:\n0: def add_file_length(source_path: str, compressed: str) -> str:\n    \"\"\"\n    Adds given file's length in front (using Elias  gamma coding) of the compressed\n    string\n    \"\"\"\n    file_length = os.path.getsize(source_path)\n    file_length_binary = bin(file_length)[2:]\n    length_length = len(file_length_binary)\n\n    return \"0\" * (length_length - 1) + file_length_binary + compressed\n1: def solution() -> int:\n    \"\"\"\n    Returns the sum of all numbers whose\n    sum of the factorials of all digits\n    add up to the number itself.\n    >>> solution()\n    40730\n    \"\"\"\n    limit = 7 * factorial(9) + 1\n    return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)\n2: def calculate_fft(audio_windowed: np.ndarray, ftt_size: int = 1024) -> np.ndarray:\n    \"\"\"\n    Calculate the Fast Fourier Transform (FFT) of windowed audio data.\n\n    Args:\n        audio_windowed: The windowed audio signal.\n        ftt_size: The size of the FFT (default is 1024).\n\n    Returns:\n        The FFT of the audio data.\n\n    Examples:\n    >>> audio_windowed = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n    >>> audio_fft = calculate_fft(audio_windowed, ftt_size=4)\n    >>> bool(np.allclose(audio_fft[0], np.array([6.0+0.j, -1.5+0.8660254j,\n    ...     -1.5-0.8660254j])))\n    True\n    \"\"\"\n    # Transpose the audio data to have time in rows and channels in columns\n    audio_transposed = np.transpose(audio_windowed)\n\n    # Initialize an array to store the FFT results\n    audio_fft = np.empty(\n        (int(1 + ftt_size // 2), audio_transposed.shape[1]),\n        dtype=np.complex64,\n        order=\"F\",\n    )\n\n    # Compute FFT for each channel\n    for n in range(audio_fft.shape[1]):\n        audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]\n\n    # Transpose the FFT results back to the original shape\n    return np.transpose(audio_fft)", "output": "2"}
{"input": "search code:\nImplementation of the MSD radix sort algorithm. Only works with positive integers :param list_of_ints: A list of integers :return: Returns the sorted list >>> msd_radix_sort([40, 12, 1, 100, 4]) [1, 4, 12, 40, 100] >>> msd_radix_sort([]) [] >>> msd_radix_sort([123, 345, 123, 80]) [80, 123, 123, 345] >>> msd_radix_sort([1209, 834598, 1, 540402, 45]) [1, 45, 1209, 540402, 834598] >>> msd_radix_sort([-1, 34, 45]) Traceback (most recent call last): ... ValueError: All numbers must be positive\nChoices:\n0: def msd_radix_sort(list_of_ints: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of the MSD radix sort algorithm. Only works\n    with positive integers\n    :param list_of_ints: A list of integers\n    :return: Returns the sorted list\n    >>> msd_radix_sort([40, 12, 1, 100, 4])\n    [1, 4, 12, 40, 100]\n    >>> msd_radix_sort([])\n    []\n    >>> msd_radix_sort([123, 345, 123, 80])\n    [80, 123, 123, 345]\n    >>> msd_radix_sort([1209, 834598, 1, 540402, 45])\n    [1, 45, 1209, 540402, 834598]\n    >>> msd_radix_sort([-1, 34, 45])\n    Traceback (most recent call last):\n        ...\n    ValueError: All numbers must be positive\n    \"\"\"\n    if not list_of_ints:\n        return []\n\n    if min(list_of_ints) < 0:\n        raise ValueError(\"All numbers must be positive\")\n\n    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)\n    return _msd_radix_sort(list_of_ints, most_bits)\n1: def main() -> None:\n    \"\"\"\n    Handles I/O\n\n    :return: void\n    \"\"\"\n    message = input(\"Enter message to encode or decode: \").strip()\n    key = input(\"Enter keyword: \").strip()\n    option = input(\"Encipher or decipher? E/D:\").strip()[0].lower()\n    try:\n        func = {\"e\": encipher, \"d\": decipher}[option]\n    except KeyError:\n        raise KeyError(\"invalid input option\")\n    cipher_map = create_cipher_map(key)\n    print(func(message, cipher_map))\n2: def maclaurin_cos(theta: float, accuracy: int = 30) -> float:\n    \"\"\"\n    Finds the maclaurin approximation of cos\n\n    :param theta: the angle to which cos is found\n    :param accuracy: the degree of accuracy wanted\n    :return: the value of cosine in radians\n\n\n    >>> from math import isclose, cos\n    >>> all(isclose(maclaurin_cos(x, 50), cos(x)) for x in range(-25, 25))\n    True\n    >>> maclaurin_cos(5)\n    0.2836621854632268\n    >>> maclaurin_cos(-5)\n    0.2836621854632265\n    >>> maclaurin_cos(10, 15)\n    -0.8390715290764524\n    >>> maclaurin_cos(-10, 15)\n    -0.8390715290764521\n    >>> maclaurin_cos(\"10\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires either an int or float for theta\n    >>> maclaurin_cos(10, -30)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    >>> maclaurin_cos(10, 30.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    >>> maclaurin_cos(10, \"30\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    \"\"\"\n\n    if not isinstance(theta, (int, float)):\n        raise ValueError(\"maclaurin_cos() requires either an int or float for theta\")\n\n    if not isinstance(accuracy, int) or accuracy <= 0:\n        raise ValueError(\"maclaurin_cos() requires a positive int for accuracy\")\n\n    theta = float(theta)\n    div = theta // (2 * pi)\n    theta -= 2 * div * pi\n    return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))", "output": "0"}
{"input": "search code:\nMemoize upf() length results for a given value. >>> upf_len(14) 2\nChoices:\n0: def compress(source_path: str, destination_path: str) -> None:\n    \"\"\"\n    Reads source file, compresses it and writes the compressed result in destination\n    file\n    \"\"\"\n    data_bits = read_file_binary(source_path)\n    compressed = compress_data(data_bits)\n    compressed = add_file_length(source_path, compressed)\n    write_file_binary(destination_path, compressed)\n1: def permute_backtrack(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Return all permutations of the given list.\n\n    >>> permute_backtrack([1, 2, 3])\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]\n    \"\"\"\n\n    def backtrack(start: int) -> None:\n        if start == len(nums) - 1:\n            output.append(nums[:])\n        else:\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack\n\n    output: list[list[int]] = []\n    backtrack(0)\n    return output\n2: def upf_len(num: int) -> int:\n    \"\"\"\n    Memoize upf() length results for a given value.\n    >>> upf_len(14)\n    2\n    \"\"\"\n    return len(unique_prime_factors(num))", "output": "2"}
{"input": "search code:\nRemove leading and trailing characters (whitespace by default) from a string.\nChoices:\n0: def strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]\n1: def emails_from_url(url: str = \"https://github.com\") -> list[str]:\n    \"\"\"\n    This function takes url and return all valid urls\n    \"\"\"\n    # Get the base domain from the url\n    domain = get_domain_name(url)\n\n    # Initialize the parser\n    parser = Parser(domain)\n\n    try:\n        # Open URL\n        r = httpx.get(url, timeout=10, follow_redirects=True)\n\n        # pass the raw HTML to the parser to get links\n        parser.feed(r.text)\n\n        # Get links and loop through\n        valid_emails = set()\n        for link in parser.urls:\n            # open URL.\n            # Check if the link is already absolute\n            if not link.startswith(\"http://\") and not link.startswith(\"https://\"):\n                # Prepend protocol only if link starts with domain, normalize otherwise\n                if link.startswith(domain):\n                    link = f\"https://{link}\"\n                else:\n                    link = parse.urljoin(f\"https://{domain}\", link)\n            try:\n                read = httpx.get(link, timeout=10, follow_redirects=True)\n                # Get the valid email.\n                emails = re.findall(\"[a-zA-Z0-9]+@\" + domain, read.text)\n                # If not in list then append it.\n                for email in emails:\n                    valid_emails.add(email)\n            except ValueError:\n                pass\n    except ValueError:\n        raise SystemExit(1)\n\n    # Finally return a sorted list of email addresses with no duplicates.\n    return sorted(valid_emails)\n2: def _running_median_windowed(iterator, maxlen):\n    \"Yield median of values in a sliding window.\"\n\n    window = deque()\n    ordered = []\n\n    for x in iterator:\n        window.append(x)\n        insort(ordered, x)\n\n        if len(ordered) > maxlen:\n            i = bisect_left(ordered, window.popleft())\n            del ordered[i]\n\n        n = len(ordered)\n        m = n // 2\n        yield ordered[m] if n & 1 else (ordered[m - 1] + ordered[m]) / 2", "output": "0"}
{"input": "summarize code:\ndef binary_exp_mod_recursive(base: float, exponent: int, modulus: int) -> float:\n    \"\"\"\n    Computes a^b % c recursively, where a is the base, b is the exponent, and c is the\n    modulus\n\n    >>> binary_exp_mod_recursive(3, 4, 5)\n    1\n    >>> binary_exp_mod_recursive(11, 13, 7)\n    4\n    >>> binary_exp_mod_recursive(1.5, 4, 3)\n    2.0625\n    >>> binary_exp_mod_recursive(7, -1, 10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exponent must be a non-negative integer\n    >>> binary_exp_mod_recursive(7, 13, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Modulus must be a positive integer\n    \"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer\")\n\n    if exponent == 0:\n        return 1\n\n    if exponent % 2 == 1:\n        return (binary_exp_mod_recursive(base, exponent - 1, modulus) * base) % modulus\n\n    r = binary_exp_mod_recursive(base, exponent // 2, modulus)\n    return (r * r) % modulus", "output": "Computes a^b % c recursively, where a is the base, b is the exponent, and c is the modulus"}
{"input": "search code:\nReturn probability of k successes out of n tries, with p probability for one success\nChoices:\n0: def breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:\n    \"\"\"\n    Implementation of breadth first search using collection.queue.\n\n    >>> ''.join(breadth_first_search_with_deque(G, 'A'))\n    'ABCDEF'\n    \"\"\"\n    visited = {start}\n    result = [start]\n    queue = deque([start])\n    while queue:\n        v = queue.popleft()\n        for child in graph[v]:\n            if child not in visited:\n                visited.add(child)\n                result.append(child)\n                queue.append(child)\n    return result\n1: def binomial_distribution(successes: int, trials: int, prob: float) -> float:\n    \"\"\"\n    Return probability of k successes out of n tries, with p probability for one\n    success\n\n    The function uses the factorial function in order to calculate the binomial\n    coefficient\n\n    >>> binomial_distribution(3, 5, 0.7)\n    0.30870000000000003\n    >>> binomial_distribution (2, 4, 0.5)\n    0.375\n    \"\"\"\n    if successes > trials:\n        raise ValueError(\"\"\"successes must be lower or equal to trials\"\"\")\n    if trials < 0 or successes < 0:\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not isinstance(successes, int) or not isinstance(trials, int):\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not 0 < prob < 1:\n        raise ValueError(\"prob has to be in range of 1 - 0\")\n    probability = (prob**successes) * ((1 - prob) ** (trials - successes))\n    # Calculate the binomial coefficient: n! / k!(n-k)!\n    coefficient = float(factorial(trials))\n    coefficient /= factorial(successes) * factorial(trials - successes)\n    return probability * coefficient\n2: def compute_transform_tables(\n    source_string: str,\n    destination_string: str,\n    copy_cost: int,\n    replace_cost: int,\n    delete_cost: int,\n    insert_cost: int,\n) -> tuple[list[list[int]], list[list[str]]]:\n    \"\"\"\n    Finds the most cost efficient sequence\n    for converting one string into another.\n\n    >>> costs, operations = compute_transform_tables(\"cat\", \"cut\", 1, 2, 3, 3)\n    >>> costs[0][:4]\n    [0, 3, 6, 9]\n    >>> costs[2][:4]\n    [6, 4, 3, 6]\n    >>> operations[0][:4]\n    ['0', 'Ic', 'Iu', 'It']\n    >>> operations[3][:4]\n    ['Dt', 'Dt', 'Rtu', 'Ct']\n\n    >>> compute_transform_tables(\"\", \"\", 1, 2, 3, 3)\n    ([[0]], [['0']])\n    \"\"\"\n    source_seq = list(source_string)\n    destination_seq = list(destination_string)\n    len_source_seq = len(source_seq)\n    len_destination_seq = len(destination_seq)\n    costs = [\n        [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n    ops = [\n        [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n\n    for i in range(1, len_source_seq + 1):\n        costs[i][0] = i * delete_cost\n        ops[i][0] = f\"D{source_seq[i - 1]}\"\n\n    for i in range(1, len_destination_seq + 1):\n        costs[0][i] = i * insert_cost\n        ops[0][i] = f\"I{destination_seq[i - 1]}\"\n\n    for i in range(1, len_source_seq + 1):\n        for j in range(1, len_destination_seq + 1):\n            if source_seq[i - 1] == destination_seq[j - 1]:\n                costs[i][j] = costs[i - 1][j - 1] + copy_cost\n                ops[i][j] = f\"C{source_seq[i - 1]}\"\n            else:\n                costs[i][j] = costs[i - 1][j - 1] + replace_cost\n                ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])\n\n            if costs[i - 1][j] + delete_cost < costs[i][j]:\n                costs[i][j] = costs[i - 1][j] + delete_cost\n                ops[i][j] = f\"D{source_seq[i - 1]}\"\n\n            if costs[i][j - 1] + insert_cost < costs[i][j]:\n                costs[i][j] = costs[i][j - 1] + insert_cost\n                ops[i][j] = f\"I{destination_seq[j - 1]}\"\n\n    return costs, ops", "output": "1"}
{"input": "summarize code:\ndef scientific(value, precision=2):\n    \"\"\"Return number in string scientific notation z.wq x 10â¿.\n\n    Examples:\n        ```pycon\n        >>> scientific(float(0.3))\n        '3.00 x 10â»Â¹'\n        >>> scientific(int(500))\n        '5.00 x 10Â²'\n        >>> scientific(-1000)\n        '1.00 x 10â»Â³'\n        >>> scientific(1000, 1)\n        '1.0 x 10Â³'\n        >>> scientific(1000, 3)\n        '1.000 x 10Â³'\n        >>> scientific(\"99\")\n        '9.90 x 10Â¹'\n        >>> scientific(\"foo\")\n        'foo'\n        >>> scientific(None) is None\n        True\n\n        ```\n\n    Args:\n        value (int, float, str): Input number.\n        precision (int): Number of decimal for first part of the number.\n\n    Returns:\n        str: Number in scientific notation z.wq x 10â¿.\n    \"\"\"\n    exponents = {\n        \"0\": \"â°\",\n        \"1\": \"Â¹\",\n        \"2\": \"Â²\",\n        \"3\": \"Â³\",\n        \"4\": \"â´\",\n        \"5\": \"âµ\",\n        \"6\": \"â¶\",\n        \"7\": \"â·\",\n        \"8\": \"â¸\",\n        \"9\": \"â¹\",\n        \"+\": \"âº\",\n        \"-\": \"â»\",\n    }\n    negative = False\n    try:\n        if \"-\" in str(value):\n            value = str(value).replace(\"-\", \"\")\n            negative = True\n\n        if isinstance(value, str):\n            value = float(value)\n\n        fmt = \"{:.%se}\" % str(int(precision))\n        n = fmt.format(value)\n\n    except (ValueError, TypeError):\n        return value\n\n    part1, part2 = n.split(\"e\")\n    if \"-0\" in part2:\n        part2 = part2.replace(\"-0\", \"-\")\n\n    if \"+0\" in part2:\n        part2 = part2.replace(\"+0\", \"\")\n\n    new_part2 = []\n    if negative:\n        new_part2.append(exponents[\"-\"])\n\n    for char in part2:\n        new_part2.append(exponents[char])\n\n    final_str = part1 + \" x 10\" + \"\".join(new_part2)\n\n    return final_str", "output": "Return number in string scientific notation z.wq x 10â¿."}
{"input": "search code:\nProcesses the game logic for the given matrix and moves.\nChoices:\n0: def _pgettext(msgctxt, message):\n    \"\"\"Fetches a particular translation.\n\n    It works with `msgctxt` .po modifiers and allows duplicate keys with different\n    translations.\n\n    Args:\n        msgctxt (str): Context of the translation.\n        message (str): Text to translate.\n\n    Returns:\n        str: Translated text.\n    \"\"\"\n    # This GNU gettext function was added in Python 3.8, so for older versions we\n    # reimplement it. It works by joining `msgctx` and `message` by '4' byte.\n    try:\n        # Python 3.8+\n        return get_translation().pgettext(msgctxt, message)\n    except AttributeError:\n        # Python 3.7 and older\n        key = msgctxt + \"\\x04\" + message\n        translation = get_translation().gettext(key)\n        return message if translation == key else translation\n1: def process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:\n    \"\"\"Processes the game logic for the given matrix and moves.\n\n    Args:\n        size (int): Size of the game board.\n        matrix (List[str]): Initial game matrix.\n        moves (List[Tuple[int, int]]): List of moves as (x, y) coordinates.\n\n    Returns:\n        int: The total score obtained.\n    >>> process_game(3, ['aaa', 'bbb', 'ccc'], [(0, 0)])\n    6\n    \"\"\"\n\n    game_matrix = [list(row) for row in matrix]\n    total_score = 0\n\n    for move in moves:\n        pos_x, pos_y = move\n        game_matrix, score = play(game_matrix, pos_x, pos_y, size)\n        total_score += score\n\n    return total_score\n2: def add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first", "output": "1"}
{"input": "search code:\nConstructs a top-down dynamic programming solution for the rod-cutting problem via memoization.\nChoices:\n0: def top_down_cut_rod(n: int, prices: list):\n    \"\"\"\n    Constructs a top-down dynamic programming solution for the rod-cutting\n    problem via memoization. This function serves as a wrapper for\n    ``_top_down_cut_rod_recursive``\n\n    Runtime: O(n^2)\n\n    Arguments\n    ---------\n\n    * `n`: int, the length of the rod\n    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n      price for a rod of length ``i``\n\n    .. note::\n      For convenience and because Python's lists using ``0``-indexing, ``length(max_rev)\n      = n + 1``, to accommodate for the revenue obtainable from a rod of length ``0``.\n\n    Returns\n    -------\n\n    The maximum revenue obtainable for a rod of length `n` given the list of prices\n    for each piece.\n\n    Examples\n    --------\n\n    >>> top_down_cut_rod(4, [1, 5, 8, 9])\n    10\n    >>> top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n    30\n    \"\"\"\n    _enforce_args(n, prices)\n    max_rev = [float(\"-inf\") for _ in range(n + 1)]\n    return _top_down_cut_rod_recursive(n, prices, max_rev)\n1: def quote_query_part(text, full_quote=True):\n    \"\"\"\n    Percent-encode a single query string key or value.\n    \"\"\"\n    if full_quote:\n        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')\n        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])\n    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t\n                     for t in text])\n2: def _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):\n    \"\"\"\n    Constructs a top-down dynamic programming solution for the rod-cutting problem\n    via memoization.\n\n    Runtime: O(n^2)\n\n    Arguments\n    ---------\n\n    * `n`: int, the length of the rod\n    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n      price for a rod of length ``i``\n    * `max_rev`: list, the computed maximum revenue for a piece of rod.\n      ``max_rev[i]`` is the maximum revenue obtainable for a rod of length ``i``\n\n    Returns\n    -------\n\n    The maximum revenue obtainable for a rod of length `n` given the list of prices\n    for each piece.\n    \"\"\"\n    if max_rev[n] >= 0:\n        return max_rev[n]\n    elif n == 0:\n        return 0\n    else:\n        max_revenue = float(\"-inf\")\n        for i in range(1, n + 1):\n            max_revenue = max(\n                max_revenue,\n                prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),\n            )\n\n        max_rev[n] = max_revenue\n\n    return max_rev[n]", "output": "2"}
{"input": "summarize code:\ndef main():\n    \"\"\"\n    Request that user input an integer and tell them if it is Armstrong number.\n    \"\"\"\n    num = int(input(\"Enter an integer to see if it is an Armstrong number: \").strip())\n    print(f\"{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number.\")\n    print(f\"{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number.\")\n    print(f\"{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number.\")", "output": "Request that user input an integer and tell them if it is Armstrong number."}
{"input": "summarize code:\ndef slow_primes(max_n: int) -> Generator[int]:\n    \"\"\"\n    Return a list of all primes numbers up to max.\n    >>> list(slow_primes(0))\n    []\n    >>> list(slow_primes(-1))\n    []\n    >>> list(slow_primes(-10))\n    []\n    >>> list(slow_primes(25))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    >>> list(slow_primes(11))\n    [2, 3, 5, 7, 11]\n    >>> list(slow_primes(33))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    >>> list(slow_primes(1000))[-1]\n    997\n    \"\"\"\n    numbers: Generator = (i for i in range(1, (max_n + 1)))\n    for i in (n for n in numbers if n > 1):\n        for j in range(2, i):\n            if (i % j) == 0:\n                break\n        else:\n            yield i", "output": "Return a list of all primes numbers up to max. >>> list(slow_primes(0)) [] >>> list(slow_primes(-1)) [] >>> list(slow_primes(-10)) [] >>> list(slow_primes(25)) [2, 3, 5, 7, 11, 13, 17, 19, 23] >>> list(slow_primes(11)) [2, 3, 5, 7, 11] >>> list(slow_primes(33)) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31] >>> list(slow_primes(1000))[-1] 997"}
{"input": "summarize code:\ndef length_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between astronomical length units.\n\n    >>> length_conversion(1, \"meter\", \"kilometer\")\n    0.001\n    >>> length_conversion(1, \"meter\", \"megametre\")\n    1e-06\n    >>> length_conversion(1, \"gigametre\", \"meter\")\n    1000000000\n    >>> length_conversion(1, \"gigametre\", \"terametre\")\n    0.001\n    >>> length_conversion(1, \"petametre\", \"terametre\")\n    1000\n    >>> length_conversion(1, \"petametre\", \"exametre\")\n    0.001\n    >>> length_conversion(1, \"terametre\", \"zettametre\")\n    1e-09\n    >>> length_conversion(1, \"yottametre\", \"zettametre\")\n    1000\n    >>> length_conversion(4, \"wrongUnit\", \"inch\")\n    Traceback (most recent call last):\n      ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'.\n    Conversion abbreviations are: m, km, Mm, Gm, Tm, Pm, Em, Zm, Ym\n    \"\"\"\n\n    from_sanitized = from_type.lower().strip(\"s\")\n    to_sanitized = to_type.lower().strip(\"s\")\n\n    from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)\n    to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)\n\n    if from_sanitized not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'from_type' value: {from_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    if to_sanitized not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'to_type' value: {to_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    from_exponent = METRIC_CONVERSION[from_sanitized]\n    to_exponent = METRIC_CONVERSION[to_sanitized]\n    exponent = 1\n\n    if from_exponent > to_exponent:\n        exponent = from_exponent - to_exponent\n    else:\n        exponent = -(to_exponent - from_exponent)\n\n    return value * pow(10, exponent)", "output": "Conversion between astronomical length units."}
{"input": "summarize code:\ndef nth_or_last(iterable, n, default=_marker):\n    \"\"\"Return the nth or the last item of *iterable*,\n    or *default* if *iterable* is empty.\n\n        >>> nth_or_last([0, 1, 2, 3], 2)\n        2\n        >>> nth_or_last([0, 1], 2)\n        1\n        >>> nth_or_last([], 0, 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    \"\"\"\n    return last(islice(iterable, n + 1), default=default)", "output": "Return the nth or the last item of *iterable*, or *default* if *iterable* is empty."}
{"input": "summarize code:\ndef substrings_indexes(seq, reverse=False):\n    \"\"\"Yield all substrings and their positions in *seq*\n\n    The items yielded will be a tuple of the form ``(substr, i, j)``, where\n    ``substr == seq[i:j]``.\n\n    This function only works for iterables that support slicing, such as\n    ``str`` objects.\n\n    >>> for item in substrings_indexes('more'):\n    ...    print(item)\n    ('m', 0, 1)\n    ('o', 1, 2)\n    ('r', 2, 3)\n    ('e', 3, 4)\n    ('mo', 0, 2)\n    ('or', 1, 3)\n    ('re', 2, 4)\n    ('mor', 0, 3)\n    ('ore', 1, 4)\n    ('more', 0, 4)\n\n    Set *reverse* to ``True`` to yield the same items in the opposite order.\n\n\n    \"\"\"\n    r = range(1, len(seq) + 1)\n    if reverse:\n        r = reversed(r)\n    return (\n        (seq[i : i + L], i, i + L) for L in r for i in range(len(seq) - L + 1)\n    )", "output": "Yield all substrings and their positions in *seq*"}
{"input": "search code:\nYield median of values in a sliding window.\nChoices:\n0: def _running_median_windowed(iterator, maxlen):\n    \"Yield median of values in a sliding window.\"\n\n    window = deque()\n    ordered = []\n\n    for x in iterator:\n        window.append(x)\n        insort(ordered, x)\n\n        if len(ordered) > maxlen:\n            i = bisect_left(ordered, window.popleft())\n            del ordered[i]\n\n        n = len(ordered)\n        m = n // 2\n        yield ordered[m] if n & 1 else (ordered[m - 1] + ordered[m]) / 2\n1: def check_cycle(graph: dict) -> bool:\n    \"\"\"\n    Returns True if graph is cyclic else False\n    >>> check_cycle(graph={0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]})\n    False\n    >>> check_cycle(graph={0:[1, 2], 1:[2], 2:[0, 3], 3:[3]})\n    True\n    \"\"\"\n    # Keep track of visited nodes\n    visited: set[int] = set()\n    # To detect a back edge, keep track of vertices currently in the recursion stack\n    rec_stk: set[int] = set()\n    return any(\n        node not in visited and depth_first_search(graph, node, visited, rec_stk)\n        for node in graph\n    )\n2: def _is_scalar(value, stringlike=(str, bytes)):\n    \"Scalars are bytes, strings, and non-iterables.\"\n    try:\n        iter(value)\n    except TypeError:\n        return True\n    return isinstance(value, stringlike)", "output": "0"}
{"input": "search code:\nCalculate the definite integral of a function using Simpson's Rule. :param boundary: A list containing the lower and upper bounds of integration. :param steps: The number of steps or resolution for the integration. :return: The approximate integral value.\nChoices:\n0: def hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)\n1: def perfect_square_binary_search(n: int) -> bool:\n    \"\"\"\n    Check if a number is perfect square using binary search.\n    Time complexity : O(Log(n))\n    Space complexity: O(1)\n\n    >>> perfect_square_binary_search(9)\n    True\n    >>> perfect_square_binary_search(16)\n    True\n    >>> perfect_square_binary_search(1)\n    True\n    >>> perfect_square_binary_search(0)\n    True\n    >>> perfect_square_binary_search(10)\n    False\n    >>> perfect_square_binary_search(-1)\n    False\n    >>> perfect_square_binary_search(1.1)\n    False\n    >>> perfect_square_binary_search(\"a\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> perfect_square_binary_search(None)\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'NoneType'\n    >>> perfect_square_binary_search([])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n    \"\"\"\n    left = 0\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        if mid**2 == n:\n            return True\n        elif mid**2 > n:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False\n2: def method_2(boundary: list[int], steps: int) -> float:\n    # \"Simpson Rule\"\n    # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)\n    \"\"\"\n    Calculate the definite integral of a function using Simpson's Rule.\n    :param boundary: A list containing the lower and upper bounds of integration.\n    :param steps: The number of steps or resolution for the integration.\n    :return: The approximate integral value.\n\n    >>> round(method_2([0, 2, 4], 10), 10)\n    2.6666666667\n    >>> round(method_2([2, 0], 10), 10)\n    -0.2666666667\n    >>> round(method_2([-2, -1], 10), 10)\n    2.172\n    >>> round(method_2([0, 1], 10), 10)\n    0.3333333333\n    >>> round(method_2([0, 2], 10), 10)\n    2.6666666667\n    >>> round(method_2([0, 2], 100), 10)\n    2.5621226667\n    >>> round(method_2([0, 1], 1000), 10)\n    0.3320026653\n    >>> round(method_2([0, 2], 0), 10)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: Number of steps must be greater than zero\n    >>> round(method_2([0, 2], -10), 10)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: Number of steps must be greater than zero\n    \"\"\"\n    if steps <= 0:\n        raise ZeroDivisionError(\"Number of steps must be greater than zero\")\n\n    h = (boundary[1] - boundary[0]) / steps\n    a = boundary[0]\n    b = boundary[1]\n    x_i = make_points(a, b, h)\n    y = 0.0\n    y += (h / 3.0) * f(a)\n    cnt = 2\n    for i in x_i:\n        y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)\n        cnt += 1\n    y += (h / 3.0) * f(b)\n    return y", "output": "2"}
{"input": "summarize code:\ndef running_key_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts the ciphertext using the Running Key Cipher.\n\n    :param key: The running key (long piece of text).\n    :param ciphertext: The ciphertext to be decrypted.\n    :return: The plaintext.\n    \"\"\"\n    ciphertext = ciphertext.replace(\" \", \"\").upper()\n    key = key.replace(\" \", \"\").upper()\n    key_length = len(key)\n    plaintext = []\n    ord_a = ord(\"A\")\n\n    for i, char in enumerate(ciphertext):\n        c = ord(char) - ord_a\n        k = ord(key[i % key_length]) - ord_a\n        p = (c - k) % 26\n        plaintext.append(chr(p + ord_a))\n\n    return \"\".join(plaintext)", "output": "Decrypts the ciphertext using the Running Key Cipher."}
{"input": "search code:\nCalculate the power of the audio signal from its FFT.\nChoices:\n0: def calculate_signal_power(audio_fft: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculate the power of the audio signal from its FFT.\n\n    Args:\n        audio_fft: The FFT of the audio signal.\n\n    Returns:\n        The power of the audio signal.\n\n    Examples:\n    >>> audio_fft = np.array([1+2j, 2+3j, 3+4j, 4+5j])\n    >>> power = calculate_signal_power(audio_fft)\n    >>> np.allclose(power, np.array([5, 13, 25, 41]))\n    True\n    \"\"\"\n    # Calculate the power by squaring the absolute values of the FFT coefficients\n    return np.square(np.abs(audio_fft))\n1: def solution():\n    \"\"\"Returns the number of mondays that fall on the first of the month during\n    the twentieth century (1 Jan 1901 to 31 Dec 2000)?\n\n    >>> solution()\n    171\n    \"\"\"\n    days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    day = 6\n    month = 1\n    year = 1901\n\n    sundays = 0\n\n    while year < 2001:\n        day += 7\n\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            if day > days_per_month[month - 1] and month != 2:\n                month += 1\n                day = day - days_per_month[month - 2]\n            elif day > 29 and month == 2:\n                month += 1\n                day = day - 29\n        elif day > days_per_month[month - 1]:\n            month += 1\n            day = day - days_per_month[month - 2]\n\n        if month > 12:\n            year += 1\n            month = 1\n\n        if year < 2001 and day == 1:\n            sundays += 1\n    return sundays\n2: def natural_sort(input_list: list[str]) -> list[str]:\n    \"\"\"\n    Sort the given list of strings in the way that humans expect.\n\n    The normal Python sort algorithm sorts lexicographically,\n    so you might not get the results that you expect...\n\n    >>> example1 = ['2 ft 7 in', '1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '7 ft 6 in']\n    >>> sorted(example1)\n    ['1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '2 ft 7 in', '7 ft 6 in']\n    >>> # The natural sort algorithm sort based on meaning and not computer code point.\n    >>> natural_sort(example1)\n    ['1 ft 5 in', '2 ft 7 in', '2 ft 11 in', '7 ft 6 in', '10 ft 2 in']\n\n    >>> example2 = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']\n    >>> sorted(example2)\n    ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']\n    >>> natural_sort(example2)\n    ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']\n    \"\"\"\n\n    def alphanum_key(key):\n        return [int(s) if s.isdigit() else s.lower() for s in re.split(\"([0-9]+)\", key)]\n\n    return sorted(input_list, key=alphanum_key)", "output": "0"}
{"input": "search code:\nSolves the problem for n_digits number of digits.\nChoices:\n0: def solution(n_digits: int = 20) -> int:\n    \"\"\"\n    Solves the problem for n_digits number of digits.\n\n    >>> solution(2)\n    45\n    >>> solution(10)\n    21838806\n    \"\"\"\n    cache: dict[str, int] = {}\n    return solve(digit=n_digits, prev1=0, prev2=0, sum_max=9, first=True, cache=cache)\n1: def avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:\n    \"\"\"\n    This function is used to perform avgpooling on the input array of 2D matrix(image)\n    Args:\n        arr: numpy array\n        size: size of pooling matrix\n        stride: the number of pixels shifts over the input matrix\n    Returns:\n        numpy array of avgpooled matrix\n    Sample Input Output:\n    >>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)\n    array([[ 3.,  5.],\n           [11., 13.]])\n    >>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)\n    array([[161., 102.],\n           [114.,  69.]])\n    \"\"\"\n    arr = np.array(arr)\n    if arr.shape[0] != arr.shape[1]:\n        raise ValueError(\"The input array is not a square matrix\")\n    i = 0\n    j = 0\n    mat_i = 0\n    mat_j = 0\n\n    # compute the shape of the output matrix\n    avgpool_shape = (arr.shape[0] - size) // stride + 1\n    # initialize the output matrix with zeros of shape avgpool_shape\n    updated_arr = np.zeros((avgpool_shape, avgpool_shape))\n\n    while i < arr.shape[0]:\n        # if the end of the matrix is reached, break\n        if i + size > arr.shape[0]:\n            break\n        while j < arr.shape[1]:\n            # if the end of the matrix is reached, break\n            if j + size > arr.shape[1]:\n                break\n            # compute the average of the pooling matrix\n            updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))\n            # shift the pooling matrix by stride of column pixels\n            j += stride\n            mat_j += 1\n\n        # shift the pooling matrix by stride of row pixels\n        i += stride\n        mat_i += 1\n        # reset the column index to 0\n        j = 0\n        mat_j = 0\n\n    return updated_arr\n2: def get_reverse_bit_string(number: int) -> str:\n    \"\"\"\n    Return the reverse bit string of a 32 bit integer\n\n    >>> get_reverse_bit_string(9)\n    '10010000000000000000000000000000'\n    >>> get_reverse_bit_string(43)\n    '11010100000000000000000000000000'\n    >>> get_reverse_bit_string(2873)\n    '10011100110100000000000000000000'\n    >>> get_reverse_bit_string(2550136832)\n    '00000000000000000000000000011001'\n    >>> get_reverse_bit_string(\"this is not a number\")\n    Traceback (most recent call last):\n        ...\n    TypeError: operation can not be conducted on an object of type str\n    \"\"\"\n    if not isinstance(number, int):\n        msg = (\n            \"operation can not be conducted on an object of type \"\n            f\"{type(number).__name__}\"\n        )\n        raise TypeError(msg)\n    bit_string = \"\"\n    for _ in range(32):\n        bit_string += str(number % 2)\n        number >>= 1\n    return bit_string", "output": "0"}
{"input": "summarize code:\ndef equilibrium_index(arr: list[int]) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5])\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1])\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3])\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i, value in enumerate(arr):\n        total_sum -= value\n        if left_sum == total_sum:\n            return i\n        left_sum += value\n\n    return -1", "output": "Find the equilibrium index of an array."}
{"input": "summarize code:\ndef longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq", "output": "Finds the longest common subsequence between two strings. Also returns the The subsequence found"}
{"input": "summarize code:\ndef benchmark() -> None:\n    \"\"\"\n    Benchmark multiple functions, with three different length int values.\n    \"\"\"\n    from collections.abc import Callable\n    from timeit import timeit\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")\n\n    for value in (262144, 1125899906842624, 1267650600228229401496703205376):\n        for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):\n            benchmark_a_function(func, value)\n        print()", "output": "Benchmark multiple functions, with three different length int values."}
{"input": "summarize code:\ndef forward_propagation(expected: int, number_propagations: int) -> float:\n    \"\"\"Return the value found after the forward propagation training.\n\n    >>> res = forward_propagation(32, 450_000)  # Was 10_000_000\n    >>> res > 31 and res < 33\n    True\n\n    >>> res = forward_propagation(32, 1000)\n    >>> res > 31 and res < 33\n    False\n    \"\"\"\n\n    # Random weight\n    weight = float(2 * (random.randint(1, 100)) - 1)\n\n    for _ in range(number_propagations):\n        # Forward propagation\n        layer_1 = sigmoid_function(INITIAL_VALUE * weight)\n        # How much did we miss?\n        layer_1_error = (expected / 100) - layer_1\n        # Error delta\n        layer_1_delta = layer_1_error * sigmoid_function(layer_1, True)\n        # Update weight\n        weight += INITIAL_VALUE * layer_1_delta\n\n    return layer_1 * 100", "output": "Return the value found after the forward propagation training."}
{"input": "summarize code:\ndef solution():\n    \"\"\"\n    Finds the maximum total in a triangle as described by the problem statement\n    above.\n\n    >>> solution()\n    1074\n    \"\"\"\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    triangle = os.path.join(script_dir, \"triangle.txt\")\n\n    with open(triangle) as f:\n        triangle = f.readlines()\n\n    a = [[int(y) for y in x.rstrip(\"\\r\\n\").split(\" \")] for x in triangle]\n\n    for i in range(1, len(a)):\n        for j in range(len(a[i])):\n            number1 = a[i - 1][j] if j != len(a[i - 1]) else 0\n            number2 = a[i - 1][j - 1] if j > 0 else 0\n            a[i][j] += max(number1, number2)\n    return max(a[-1])", "output": "Finds the maximum total in a triangle as described by the problem statement above."}
{"input": "summarize code:\ndef thousands_separator() -> str:\n    \"\"\"Return the thousands separator for a locale, default to comma.\n\n    Returns:\n         str: Thousands separator.\n    \"\"\"\n    try:\n        sep = _THOUSANDS_SEPARATOR[_CURRENT.locale]\n    except (AttributeError, KeyError):\n        sep = \",\"\n    return sep", "output": "Return the thousands separator for a locale, default to comma."}
{"input": "summarize code:\ndef reverse_inorder(root: Node | None) -> Generator[int]:\n    \"\"\"\n    Reverse in-order traversal visits right subtree, root node, left subtree.\n    >>> list(reverse_inorder(make_tree()))\n    [3, 1, 5, 2, 4]\n    \"\"\"\n    if not root:\n        return\n    yield from reverse_inorder(root.right)\n    yield root.data\n    yield from reverse_inorder(root.left)", "output": "Reverse in-order traversal visits right subtree, root node, left subtree. >>> list(reverse_inorder(make_tree())) [3, 1, 5, 2, 4]"}
{"input": "search code:\nComputes incrementing Fibonacci numbers starting from 3 until the length of the resulting Fibonacci result is the input value n. Returns the term of the Fibonacci sequence where this occurs.\nChoices:\n0: def fibonacci_digits_index(n: int) -> int:\n    \"\"\"\n    Computes incrementing Fibonacci numbers starting from 3 until the length\n    of the resulting Fibonacci result is the input value n. Returns the term\n    of the Fibonacci sequence where this occurs.\n\n    >>> fibonacci_digits_index(1000)\n    4782\n    >>> fibonacci_digits_index(100)\n    476\n    >>> fibonacci_digits_index(50)\n    237\n    >>> fibonacci_digits_index(3)\n    12\n    \"\"\"\n    digits = 0\n    index = 2\n\n    while digits < n:\n        index += 1\n        digits = len(str(fibonacci(index)))\n\n    return index\n1: def solution(func: Callable[[int], int] = question_function, order: int = 10) -> int:\n    \"\"\"\n    Find the sum of the FITs of the BOPS. For each interpolating polynomial of order\n    1, 2, ... , 10, find the first x such that the value of the polynomial at x does\n    not equal u(x).\n    >>> solution(lambda n: n ** 3, 3)\n    74\n    \"\"\"\n    data_points: list[int] = [func(x_val) for x_val in range(1, order + 1)]\n\n    polynomials: list[Callable[[int], int]] = [\n        interpolate(data_points[:max_coeff]) for max_coeff in range(1, order + 1)\n    ]\n\n    ret: int = 0\n    poly: Callable[[int], int]\n    x_val: int\n\n    for poly in polynomials:\n        x_val = 1\n        while func(x_val) == poly(x_val):\n            x_val += 1\n\n        ret += poly(x_val)\n\n    return ret\n2: def term_frequency(term: str, document: str) -> int:\n    \"\"\"\n    Return the number of times a term occurs within\n    a given document.\n    @params: term, the term to search a document for, and document,\n            the document to search within\n    @returns: an integer representing the number of times a term is\n            found within the document\n\n    @examples:\n    >>> term_frequency(\"to\", \"To be, or not to be\")\n    2\n    \"\"\"\n    # strip all punctuation and newlines and replace it with ''\n    document_without_punctuation = document.translate(\n        str.maketrans(\"\", \"\", string.punctuation)\n    ).replace(\"\\n\", \"\")\n    tokenize_document = document_without_punctuation.split(\" \")  # word tokenization\n    return len([word for word in tokenize_document if word.lower() == term.lower()])", "output": "0"}
