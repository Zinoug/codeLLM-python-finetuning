[
  {
    "function": "make_cache_key",
    "code": "def make_cache_key(args, kwargs, typed=False,\n                   kwarg_mark=_KWARG_MARK,\n                   fasttypes=frozenset([int, str, frozenset, type(None)])):\n    \"\"\"Make a generic key from a function's positional and keyword\n    arguments, suitable for use in caches. Arguments within *args* and\n    *kwargs* must be `hashable`_. If *typed* is ``True``, ``3`` and\n    ``3.0`` will be treated as separate keys.\n\n    The key is constructed in a way that is flat as possible rather than\n    as a nested structure that would take more memory.\n\n    If there is only a single argument and its data type is known to cache\n    its hash value, then that argument is returned without a wrapper.  This\n    saves space and improves lookup speed.\n\n    >>> tuple(make_cache_key(('a', 'b'), {'c': ('d')}))\n    ('a', 'b', _KWARG_MARK, ('c', 'd'))\n\n    .. _hashable: https://docs.python.org/2/glossary.html#term-hashable\n    \"\"\"\n\n    # key = [func_name] if func_name else []\n    # key.extend(args)\n    key = list(args)\n    if kwargs:\n        sorted_items = sorted(kwargs.items())\n        key.append(kwarg_mark)\n        key.extend(sorted_items)\n    if typed:\n        key.extend([type(v) for v in args])\n        if kwargs:\n            key.extend([type(v) for k, v in sorted_items])\n    elif len(key) == 1 and type(key[0]) in fasttypes:\n        return key[0]\n    return _HashedKey(key)",
    "docstring": "Make a generic key from a function's positional and keyword\narguments, suitable for use in caches. Arguments within *args* and\n*kwargs* must be `hashable`_. If *typed* is ``True``, ``3`` and\n``3.0`` will be treated as separate keys.\n\nThe key is constructed in a way that is flat as possible rather than\nas a nested structure that would take more memory.\n\nIf there is only a single argument and its data type is known to cache\nits hash value, then that argument is returned without a wrapper.  This\nsaves space and improves lookup speed.\n\n>>> tuple(make_cache_key(('a', 'b'), {'c': ('d')}))\n('a', 'b', _KWARG_MARK, ('c', 'd'))\n\n.. _hashable: https://docs.python.org/2/glossary.html#term-hashable"
  },
  {
    "function": "cached",
    "code": "def cached(cache, scoped=True, typed=False, key=None):\n    \"\"\"Cache any function with the cache object of your choosing. Note\n    that the function wrapped should take only `hashable`_ arguments.\n\n    Args:\n        cache (Mapping): Any :class:`dict`-like object suitable for\n            use as a cache. Instances of the :class:`LRU` and\n            :class:`LRI` are good choices, but a plain :class:`dict`\n            can work in some cases, as well. This argument can also be\n            a callable which accepts no arguments and returns a mapping.\n        scoped (bool): Whether the function itself is part of the\n            cache key.  ``True`` by default, different functions will\n            not read one another's cache entries, but can evict one\n            another's results. ``False`` can be useful for certain\n            shared cache use cases. More advanced behavior can be\n            produced through the *key* argument.\n        typed (bool): Whether to factor argument types into the cache\n            check. Default ``False``, setting to ``True`` causes the\n            cache keys for ``3`` and ``3.0`` to be considered unequal.\n\n    >>> my_cache = LRU()\n    >>> @cached(my_cache)\n    ... def cached_lower(x):\n    ...     return x.lower()\n    ...\n    >>> cached_lower(\"CaChInG's FuN AgAiN!\")\n    \"caching's fun again!\"\n    >>> len(my_cache)\n    1\n\n    .. _hashable: https://docs.python.org/2/glossary.html#term-hashable\n\n    \"\"\"\n    def cached_func_decorator(func):\n        return CachedFunction(func, cache, scoped=scoped, typed=typed, key=key)\n    return cached_func_decorator",
    "docstring": "Cache any function with the cache object of your choosing. Note\nthat the function wrapped should take only `hashable`_ arguments.\n\nArgs:\n    cache (Mapping): Any :class:`dict`-like object suitable for\n        use as a cache. Instances of the :class:`LRU` and\n        :class:`LRI` are good choices, but a plain :class:`dict`\n        can work in some cases, as well. This argument can also be\n        a callable which accepts no arguments and returns a mapping.\n    scoped (bool): Whether the function itself is part of the\n        cache key.  ``True`` by default, different functions will\n        not read one another's cache entries, but can evict one\n        another's results. ``False`` can be useful for certain\n        shared cache use cases. More advanced behavior can be\n        produced through the *key* argument.\n    typed (bool): Whether to factor argument types into the cache\n        check. Default ``False``, setting to ``True`` causes the\n        cache keys for ``3`` and ``3.0`` to be considered unequal.\n\n>>> my_cache = LRU()\n>>> @cached(my_cache)\n... def cached_lower(x):\n...     return x.lower()\n...\n>>> cached_lower(\"CaChInG's FuN AgAiN!\")\n\"caching's fun again!\"\n>>> len(my_cache)\n1\n\n.. _hashable: https://docs.python.org/2/glossary.html#term-hashable"
  },
  {
    "function": "cachedmethod",
    "code": "def cachedmethod(cache, scoped=True, typed=False, key=None):\n    \"\"\"Similar to :func:`cached`, ``cachedmethod`` is used to cache\n    methods based on their arguments, using any :class:`dict`-like\n    *cache* object.\n\n    Args:\n        cache (str/Mapping/callable): Can be the name of an attribute\n            on the instance, any Mapping/:class:`dict`-like object, or\n            a callable which returns a Mapping.\n        scoped (bool): Whether the method itself and the object it is\n            bound to are part of the cache keys. ``True`` by default,\n            different methods will not read one another's cache\n            results. ``False`` can be useful for certain shared cache\n            use cases. More advanced behavior can be produced through\n            the *key* arguments.\n        typed (bool): Whether to factor argument types into the cache\n            check. Default ``False``, setting to ``True`` causes the\n            cache keys for ``3`` and ``3.0`` to be considered unequal.\n        key (callable): A callable with a signature that matches\n            :func:`make_cache_key` that returns a tuple of hashable\n            values to be used as the key in the cache.\n\n    >>> class Lowerer(object):\n    ...     def __init__(self):\n    ...         self.cache = LRI()\n    ...\n    ...     @cachedmethod('cache')\n    ...     def lower(self, text):\n    ...         return text.lower()\n    ...\n    >>> lowerer = Lowerer()\n    >>> lowerer.lower('WOW WHO COULD GUESS CACHING COULD BE SO NEAT')\n    'wow who could guess caching could be so neat'\n    >>> len(lowerer.cache)\n    1\n\n    \"\"\"\n    def cached_method_decorator(func):\n        return CachedMethod(func, cache, scoped=scoped, typed=typed, key=key)\n    return cached_method_decorator",
    "docstring": "Similar to :func:`cached`, ``cachedmethod`` is used to cache\nmethods based on their arguments, using any :class:`dict`-like\n*cache* object.\n\nArgs:\n    cache (str/Mapping/callable): Can be the name of an attribute\n        on the instance, any Mapping/:class:`dict`-like object, or\n        a callable which returns a Mapping.\n    scoped (bool): Whether the method itself and the object it is\n        bound to are part of the cache keys. ``True`` by default,\n        different methods will not read one another's cache\n        results. ``False`` can be useful for certain shared cache\n        use cases. More advanced behavior can be produced through\n        the *key* arguments.\n    typed (bool): Whether to factor argument types into the cache\n        check. Default ``False``, setting to ``True`` causes the\n        cache keys for ``3`` and ``3.0`` to be considered unequal.\n    key (callable): A callable with a signature that matches\n        :func:`make_cache_key` that returns a tuple of hashable\n        values to be used as the key in the cache.\n\n>>> class Lowerer(object):\n...     def __init__(self):\n...         self.cache = LRI()\n...\n...     @cachedmethod('cache')\n...     def lower(self, text):\n...         return text.lower()\n...\n>>> lowerer = Lowerer()\n>>> lowerer.lower('WOW WHO COULD GUESS CACHING COULD BE SO NEAT')\n'wow who could guess caching could be so neat'\n>>> len(lowerer.cache)\n1"
  },
  {
    "function": "pdb_on_signal",
    "code": "def pdb_on_signal(signalnum=None):\n    \"\"\"Installs a signal handler for *signalnum*, which defaults to\n    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler\n    launches a :mod:`pdb` breakpoint. Results vary in concurrent\n    systems, but this technique can be useful for debugging infinite\n    loops, or easily getting into deep call stacks.\n\n    Args:\n        signalnum (int): The signal number of the signal to handle\n            with pdb. Defaults to :mod:`signal.SIGINT`, see\n            :mod:`signal` for more information.\n    \"\"\"\n    import pdb\n    import signal\n    if not signalnum:\n        signalnum = signal.SIGINT\n\n    old_handler = signal.getsignal(signalnum)\n\n    def pdb_int_handler(sig, frame):\n        signal.signal(signalnum, old_handler)\n        pdb.set_trace()\n        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help\n\n    signal.signal(signalnum, pdb_int_handler)\n    return",
    "docstring": "Installs a signal handler for *signalnum*, which defaults to\n``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler\nlaunches a :mod:`pdb` breakpoint. Results vary in concurrent\nsystems, but this technique can be useful for debugging infinite\nloops, or easily getting into deep call stacks.\n\nArgs:\n    signalnum (int): The signal number of the signal to handle\n        with pdb. Defaults to :mod:`signal.SIGINT`, see\n        :mod:`signal` for more information."
  },
  {
    "function": "pdb_on_exception",
    "code": "def pdb_on_exception(limit=100):\n    \"\"\"Installs a handler which, instead of exiting, attaches a\n    post-mortem pdb console whenever an unhandled exception is\n    encountered.\n\n    Args:\n        limit (int): the max number of stack frames to display when\n            printing the traceback\n\n    A similar effect can be achieved from the command-line using the\n    following command::\n\n      python -m pdb your_code.py\n\n    But ``pdb_on_exception`` allows you to do this conditionally and within\n    your application. To restore default behavior, just do::\n\n      sys.excepthook = sys.__excepthook__\n    \"\"\"\n    import pdb\n    import sys\n    import traceback\n\n    def pdb_excepthook(exc_type, exc_val, exc_tb):\n        traceback.print_tb(exc_tb, limit=limit)\n        pdb.post_mortem(exc_tb)\n\n    sys.excepthook = pdb_excepthook\n    return",
    "docstring": "Installs a handler which, instead of exiting, attaches a\npost-mortem pdb console whenever an unhandled exception is\nencountered.\n\nArgs:\n    limit (int): the max number of stack frames to display when\n        printing the traceback\n\nA similar effect can be achieved from the command-line using the\nfollowing command::\n\n  python -m pdb your_code.py\n\nBut ``pdb_on_exception`` allows you to do this conditionally and within\nyour application. To restore default behavior, just do::\n\n  sys.excepthook = sys.__excepthook__"
  },
  {
    "function": "wrap_trace",
    "code": "def wrap_trace(obj, hook=trace_print_hook,\n               which=None, events=None, label=None):\n    \"\"\"Monitor an object for interactions. Whenever code calls a method,\n    gets an attribute, or sets an attribute, an event is called. By\n    default the trace output is printed, but a custom tracing *hook*\n    can be passed.\n\n    Args:\n       obj (object): New- or old-style object to be traced. Built-in\n           objects like lists and dicts also supported.\n       hook (callable): A function called once for every event. See\n           below for details.\n       which (str): One or more attribute names to trace, or a\n           function accepting attribute name and value, and returning\n           True/False.\n       events (str): One or more kinds of events to call *hook*\n           on. Expected values are ``['get', 'set', 'del', 'call',\n           'raise', 'return']``. Defaults to all events.\n       label (str): A name to associate with the traced object\n           Defaults to hexadecimal memory address, similar to repr.\n\n    The object returned is not the same object as the one passed\n    in. It will not pass identity checks. However, it will pass\n    :func:`isinstance` checks, as it is a new instance of a new\n    subtype of the object passed.\n\n    \"\"\"\n    # other actions: pdb.set_trace, print, aggregate, aggregate_return\n    # (like aggregate but with the return value)\n\n    # TODO: test classmethod/staticmethod/property\n    # TODO: wrap __dict__ for old-style classes?\n\n    if isinstance(which, str):\n        which_func = lambda attr_name, attr_val: attr_name == which\n    elif callable(getattr(which, '__contains__', None)):\n        which_func = lambda attr_name, attr_val: attr_name in which\n    elif which is None or callable(which):\n        which_func = which\n    else:\n        raise TypeError('expected attr name(s) or callable, not: %r' % which)\n\n    label = label or hex(id(obj))\n\n    if isinstance(events, str):\n        events = [events]\n    do_get = not events or 'get' in events\n    do_set = not events or 'set' in events\n    do_del = not events or 'del' in events\n    do_call = not events or 'call' in events\n    do_raise = not events or 'raise' in events\n    do_return = not events or 'return' in events\n\n    def wrap_method(attr_name, func, _hook=hook, _label=label):\n        def wrapped(*a, **kw):\n            a = a[1:]\n            if do_call:\n                hook(event='call', label=_label, obj=obj,\n                     attr_name=attr_name, args=a, kwargs=kw)\n            if do_raise:\n                try:\n                    ret = func(*a, **kw)\n                except Exception:\n                    if not hook(event='raise', label=_label, obj=obj,\n                                attr_name=attr_name, args=a, kwargs=kw,\n                                result=sys.exc_info()):\n                        raise\n            else:\n                ret = func(*a, **kw)\n            if do_return:\n                hook(event='return', label=_label, obj=obj,\n                     attr_name=attr_name, args=a, kwargs=kw, result=ret)\n            return ret\n\n        wrapped.__name__ = func.__name__\n        wrapped.__doc__ = func.__doc__\n        try:\n            wrapped.__module__ = func.__module__\n        except Exception:\n            pass\n        try:\n            if func.__dict__:\n                wrapped.__dict__.update(func.__dict__)\n        except Exception:\n            pass\n        return wrapped\n\n    def __getattribute__(self, attr_name):\n        ret = type(obj).__getattribute__(obj, attr_name)\n        if callable(ret):  # wrap any bound methods\n            ret = type(obj).__getattribute__(self, attr_name)\n        if do_get:\n            hook('get', label, obj, attr_name, (), {}, result=ret)\n        return ret\n\n    def __setattr__(self, attr_name, value):\n        type(obj).__setattr__(obj, attr_name, value)\n        if do_set:\n            hook('set', label, obj, attr_name, (value,), {})\n        return\n\n    def __delattr__(self, attr_name):\n        type(obj).__delattr__(obj, attr_name)\n        if do_del:\n            hook('del', label, obj, attr_name, (), {})\n        return\n\n    attrs = {}\n    for attr_name in dir(obj):\n        try:\n            attr_val = getattr(obj, attr_name)\n        except Exception:\n            continue\n\n        if not callable(attr_val) or attr_name in ('__new__',):\n            continue\n        elif which_func and not which_func(attr_name, attr_val):\n            continue\n\n        if attr_name == '__getattribute__':\n            wrapped_method = __getattribute__\n        elif attr_name == '__setattr__':\n            wrapped_method = __setattr__\n        elif attr_name == '__delattr__':\n            wrapped_method = __delattr__\n        else:\n            wrapped_method = wrap_method(attr_name, attr_val)\n        attrs[attr_name] = wrapped_method\n\n    cls_name = obj.__class__.__name__\n    if cls_name == cls_name.lower():\n        type_name = 'traced_' + cls_name\n    else:\n        type_name = 'Traced' + cls_name\n\n    if hasattr(obj, '__mro__'):\n        bases = (obj.__class__,)\n    else:\n        # need new-style class for even basic wrapping of callables to\n        # work. getattribute won't work for old-style classes of course.\n        bases = (obj.__class__, object)\n\n    trace_type = type(type_name, bases, attrs)\n    for cls in trace_type.__mro__:\n        try:\n            return cls.__new__(trace_type)\n        except Exception:\n            pass\n    raise TypeError('unable to wrap_trace %r instance %r'\n                    % (obj.__class__, obj))",
    "docstring": "Monitor an object for interactions. Whenever code calls a method,\ngets an attribute, or sets an attribute, an event is called. By\ndefault the trace output is printed, but a custom tracing *hook*\ncan be passed.\n\nArgs:\n   obj (object): New- or old-style object to be traced. Built-in\n       objects like lists and dicts also supported.\n   hook (callable): A function called once for every event. See\n       below for details.\n   which (str): One or more attribute names to trace, or a\n       function accepting attribute name and value, and returning\n       True/False.\n   events (str): One or more kinds of events to call *hook*\n       on. Expected values are ``['get', 'set', 'del', 'call',\n       'raise', 'return']``. Defaults to all events.\n   label (str): A name to associate with the traced object\n       Defaults to hexadecimal memory address, similar to repr.\n\nThe object returned is not the same object as the one passed\nin. It will not pass identity checks. However, it will pass\n:func:`isinstance` checks, as it is a new instance of a new\nsubtype of the object passed."
  },
  {
    "function": "subdict",
    "code": "def subdict(d, keep=None, drop=None):\n    \"\"\"Compute the \"subdictionary\" of a dict, *d*.\n\n    A subdict is to a dict what a subset is a to set. If *A* is a\n    subdict of *B*, that means that all keys of *A* are present in\n    *B*.\n\n    Returns a new dict with any keys in *drop* removed, and any keys\n    in *keep* still present, provided they were in the original\n    dict. *keep* defaults to all keys, *drop* defaults to empty, so\n    without one of these arguments, calling this function is\n    equivalent to calling ``dict()``.\n\n    >>> from pprint import pprint as pp\n    >>> pp(subdict({'a': 1, 'b': 2}))\n    {'a': 1, 'b': 2}\n    >>> subdict({'a': 1, 'b': 2, 'c': 3}, drop=['b', 'c'])\n    {'a': 1}\n    >>> pp(subdict({'a': 1, 'b': 2, 'c': 3}, keep=['a', 'c']))\n    {'a': 1, 'c': 3}\n\n    \"\"\"\n    if keep is None:\n        keep = d.keys()\n    if drop is None:\n        drop = []\n\n    keys = set(keep) - set(drop)\n\n    return type(d)([(k, v) for k, v in d.items() if k in keys])",
    "docstring": "Compute the \"subdictionary\" of a dict, *d*.\n\nA subdict is to a dict what a subset is a to set. If *A* is a\nsubdict of *B*, that means that all keys of *A* are present in\n*B*.\n\nReturns a new dict with any keys in *drop* removed, and any keys\nin *keep* still present, provided they were in the original\ndict. *keep* defaults to all keys, *drop* defaults to empty, so\nwithout one of these arguments, calling this function is\nequivalent to calling ``dict()``.\n\n>>> from pprint import pprint as pp\n>>> pp(subdict({'a': 1, 'b': 2}))\n{'a': 1, 'b': 2}\n>>> subdict({'a': 1, 'b': 2, 'c': 3}, drop=['b', 'c'])\n{'a': 1}\n>>> pp(subdict({'a': 1, 'b': 2, 'c': 3}, keep=['a', 'c']))\n{'a': 1, 'c': 3}"
  },
  {
    "function": "gobs_program",
    "code": "def gobs_program():\n    \"\"\"\n    A pure-Python implementation of Gob's Algorithm (2006). A brief\n    explanation can be found here:\n    https://www.youtube.com/watch?v=JbnjusltDHk\n    \"\"\"\n    while True:\n        print(\"Penus\", end=\" \")",
    "docstring": "A pure-Python implementation of Gob's Algorithm (2006). A brief\nexplanation can be found here:\nhttps://www.youtube.com/watch?v=JbnjusltDHk"
  },
  {
    "function": "get_profile",
    "code": "def get_profile(**kwargs):\n    \"\"\"The main entrypoint to ecoutils. Calling this will return a\n    JSON-serializable dictionary of information about the current\n    process.\n\n    It is very unlikely that the information returned will change\n    during the lifetime of the process, and in most cases the majority\n    of the information stays the same between runs as well.\n\n    :func:`get_profile` takes one optional keyword argument, *scrub*,\n    a :class:`bool` that, if True, blanks out identifiable\n    information. This includes current working directory, hostname,\n    Python executable path, command-line arguments, and\n    username. Values are replaced with '-', but for compatibility keys\n    remain in place.\n\n    \"\"\"\n    scrub = kwargs.pop('scrub', False)\n    if kwargs:\n        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')\n    ret = {}\n    try:\n        ret['username'] = getpass.getuser()\n    except Exception:\n        ret['username'] = ''\n    ret['guid'] = str(INSTANCE_ID)\n    ret['hostname'] = socket.gethostname()\n    ret['hostfqdn'] = socket.getfqdn()\n    uname = platform.uname()\n    ret['uname'] = {'system': uname[0],\n                    'node': uname[1],\n                    'release': uname[2],  # linux: distro name\n                    'version': uname[3],  # linux: kernel version\n                    'machine': uname[4],\n                    'processor': uname[5]}\n    try:\n        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10\n        linux_dist = platform.linux_distribution()  \n    except Exception:\n        linux_dist = ('', '', '')\n    ret['linux_dist_name'] = linux_dist[0]\n    ret['linux_dist_version'] = linux_dist[1]\n    ret['cpu_count'] = CPU_COUNT\n\n    ret['fs_encoding'] = sys.getfilesystemencoding()\n    ret['ulimit_soft'] = RLIMIT_FDS_SOFT\n    ret['ulimit_hard'] = RLIMIT_FDS_HARD\n    ret['cwd'] = os.getcwd()\n    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')\n\n    ret['python'] = get_python_info()\n    ret.update(START_TIME_INFO)\n    ret['_eco_version'] = ECO_VERSION\n\n    if scrub:\n        # mask identifiable information\n        ret['cwd'] = '-'\n        ret['hostname'] = '-'\n        ret['hostfqdn'] = '-'\n        ret['python']['bin'] = '-'\n        ret['python']['argv'] = '-'\n        ret['uname']['node'] = '-'\n        ret['username'] = '-'\n\n    return ret",
    "docstring": "The main entrypoint to ecoutils. Calling this will return a\nJSON-serializable dictionary of information about the current\nprocess.\n\nIt is very unlikely that the information returned will change\nduring the lifetime of the process, and in most cases the majority\nof the information stays the same between runs as well.\n\n:func:`get_profile` takes one optional keyword argument, *scrub*,\na :class:`bool` that, if True, blanks out identifiable\ninformation. This includes current working directory, hostname,\nPython executable path, command-line arguments, and\nusername. Values are replaced with '-', but for compatibility keys\nremain in place."
  },
  {
    "function": "mkdir_p",
    "code": "def mkdir_p(path):\n    \"\"\"Creates a directory and any parent directories that may need to\n    be created along the way, without raising errors for any existing\n    directories. This function mimics the behavior of the ``mkdir -p``\n    command available in Linux/BSD environments, but also works on\n    Windows.\n    \"\"\"\n    try:\n        os.makedirs(path)\n    except OSError as exc:\n        if exc.errno == errno.EEXIST and os.path.isdir(path):\n            return\n        raise\n    return",
    "docstring": "Creates a directory and any parent directories that may need to\nbe created along the way, without raising errors for any existing\ndirectories. This function mimics the behavior of the ``mkdir -p``\ncommand available in Linux/BSD environments, but also works on\nWindows."
  },
  {
    "function": "atomic_save",
    "code": "def atomic_save(dest_path, **kwargs):\n    \"\"\"A convenient interface to the :class:`AtomicSaver` type. Example:\n\n    >>> try:\n    ...     with atomic_save(\"file.txt\", text_mode=True) as fo:\n    ...         _ = fo.write('bye')\n    ...         1/0  # will error\n    ...         fo.write('bye')\n    ... except ZeroDivisionError:\n    ...     pass  # at least our file.txt didn't get overwritten\n\n    See the :class:`AtomicSaver` documentation for details.\n    \"\"\"\n    return AtomicSaver(dest_path, **kwargs)",
    "docstring": "A convenient interface to the :class:`AtomicSaver` type. Example:\n\n>>> try:\n...     with atomic_save(\"file.txt\", text_mode=True) as fo:\n...         _ = fo.write('bye')\n...         1/0  # will error\n...         fo.write('bye')\n... except ZeroDivisionError:\n...     pass  # at least our file.txt didn't get overwritten\n\nSee the :class:`AtomicSaver` documentation for details."
  },
  {
    "function": "iter_find_files",
    "code": "def iter_find_files(directory, patterns, ignored=None, include_dirs=False, max_depth=None):\n    \"\"\"Returns a generator that yields file paths under a *directory*,\n    matching *patterns* using `glob`_ syntax (e.g., ``*.txt``). Also\n    supports *ignored* patterns.\n\n    Args:\n        directory (str): Path that serves as the root of the\n            search. Yielded paths will include this as a prefix.\n        patterns (str or list): A single pattern or list of\n            glob-formatted patterns to find under *directory*.\n        ignored (str or list): A single pattern or list of\n            glob-formatted patterns to ignore.\n        include_dirs (bool): Whether to include directories that match\n           patterns, as well. Defaults to ``False``.\n        max_depth (int): traverse up to this level of subdirectory.\n           I.e., 0 for the specified *directory* only, 1 for *directory* \n           and one level of subdirectory.\n\n    For example, finding Python files in the current directory:\n\n    >>> _CUR_DIR = os.path.dirname(os.path.abspath(__file__))\n    >>> filenames = sorted(iter_find_files(_CUR_DIR, '*.py'))\n    >>> os.path.basename(filenames[-1])\n    'urlutils.py'\n\n    Or, Python files while ignoring emacs lockfiles:\n\n    >>> filenames = iter_find_files(_CUR_DIR, '*.py', ignored='.#*')\n\n    .. _glob: https://en.wikipedia.org/wiki/Glob_%28programming%29\n\n    \"\"\"\n    if isinstance(patterns, str):\n        patterns = [patterns]\n    pats_re = re.compile('|'.join([fnmatch.translate(p) for p in patterns]))\n\n    if not ignored:\n        ignored = []\n    elif isinstance(ignored, str):\n        ignored = [ignored]\n    ign_re = re.compile('|'.join([fnmatch.translate(p) for p in ignored]))\n    start_depth = len(directory.split(os.path.sep))\n    for root, dirs, files in os.walk(directory):\n        if max_depth is not None and (len(root.split(os.path.sep)) - start_depth) > max_depth:\n            continue\n        if include_dirs:\n            for basename in dirs:\n                if pats_re.match(basename):\n                    if ignored and ign_re.match(basename):\n                        continue\n                    filename = os.path.join(root, basename)\n                    yield filename\n\n        for basename in files:\n            if pats_re.match(basename):\n                if ignored and ign_re.match(basename):\n                    continue\n                filename = os.path.join(root, basename)\n                yield filename\n    return",
    "docstring": "Returns a generator that yields file paths under a *directory*,\nmatching *patterns* using `glob`_ syntax (e.g., ``*.txt``). Also\nsupports *ignored* patterns.\n\nArgs:\n    directory (str): Path that serves as the root of the\n        search. Yielded paths will include this as a prefix.\n    patterns (str or list): A single pattern or list of\n        glob-formatted patterns to find under *directory*.\n    ignored (str or list): A single pattern or list of\n        glob-formatted patterns to ignore.\n    include_dirs (bool): Whether to include directories that match\n       patterns, as well. Defaults to ``False``.\n    max_depth (int): traverse up to this level of subdirectory.\n       I.e., 0 for the specified *directory* only, 1 for *directory* \n       and one level of subdirectory.\n\nFor example, finding Python files in the current directory:\n\n>>> _CUR_DIR = os.path.dirname(os.path.abspath(__file__))\n>>> filenames = sorted(iter_find_files(_CUR_DIR, '*.py'))\n>>> os.path.basename(filenames[-1])\n'urlutils.py'\n\nOr, Python files while ignoring emacs lockfiles:\n\n>>> filenames = iter_find_files(_CUR_DIR, '*.py', ignored='.#*')\n\n.. _glob: https://en.wikipedia.org/wiki/Glob_%28programming%29"
  },
  {
    "function": "copy_tree",
    "code": "def copy_tree(src, dst, symlinks=False, ignore=None):\n    \"\"\"The ``copy_tree`` function is an exact copy of the built-in\n    :func:`shutil.copytree`, with one key difference: it will not\n    raise an exception if part of the tree already exists. It achieves\n    this by using :func:`mkdir_p`.\n\n    As of Python 3.8, you may pass :func:`shutil.copytree` the\n    `dirs_exist_ok=True` flag to achieve the same effect.\n\n    Args:\n        src (str): Path of the source directory to copy.\n        dst (str): Destination path. Existing directories accepted.\n        symlinks (bool): If ``True``, copy symlinks rather than their\n            contents.\n        ignore (callable): A callable that takes a path and directory\n            listing, returning the files within the listing to be ignored.\n\n    For more details, check out :func:`shutil.copytree` and\n    :func:`shutil.copy2`.\n\n    \"\"\"\n    names = os.listdir(src)\n    if ignore is not None:\n        ignored_names = ignore(src, names)\n    else:\n        ignored_names = set()\n\n    mkdir_p(dst)\n    errors = []\n    for name in names:\n        if name in ignored_names:\n            continue\n        srcname = os.path.join(src, name)\n        dstname = os.path.join(dst, name)\n        try:\n            if symlinks and os.path.islink(srcname):\n                linkto = os.readlink(srcname)\n                os.symlink(linkto, dstname)\n            elif os.path.isdir(srcname):\n                copytree(srcname, dstname, symlinks, ignore)\n            else:\n                # Will raise a SpecialFileError for unsupported file types\n                copy2(srcname, dstname)\n        # catch the Error from the recursive copytree so that we can\n        # continue with other files\n        except Error as e:\n            errors.extend(e.args[0])\n        except OSError as why:\n            errors.append((srcname, dstname, str(why)))\n    try:\n        copystat(src, dst)\n    except OSError as why:\n        errors.append((src, dst, str(why)))\n    if errors:\n        raise Error(errors)",
    "docstring": "The ``copy_tree`` function is an exact copy of the built-in\n:func:`shutil.copytree`, with one key difference: it will not\nraise an exception if part of the tree already exists. It achieves\nthis by using :func:`mkdir_p`.\n\nAs of Python 3.8, you may pass :func:`shutil.copytree` the\n`dirs_exist_ok=True` flag to achieve the same effect.\n\nArgs:\n    src (str): Path of the source directory to copy.\n    dst (str): Destination path. Existing directories accepted.\n    symlinks (bool): If ``True``, copy symlinks rather than their\n        contents.\n    ignore (callable): A callable that takes a path and directory\n        listing, returning the files within the listing to be ignored.\n\nFor more details, check out :func:`shutil.copytree` and\n:func:`shutil.copy2`."
  },
  {
    "function": "rotate_file",
    "code": "def rotate_file(filename, *, keep: int = 5):\n    \"\"\"\n    If *filename.ext* exists, it will be moved to *filename.1.ext*, \n    with all conflicting filenames being moved up by one, dropping any files beyond *keep*.\n\n    After rotation, *filename* will be available for creation as a new file.\n\n    Fails if *filename* is not a file or if *keep* is not > 0.\n    \"\"\"\n    if keep < 1:\n        raise ValueError(f'expected \"keep\" to be >=1, not {keep}')\n    if not os.path.exists(filename):\n        return\n    if not os.path.isfile(filename):\n        raise ValueError(f'expected {filename} to be a file')\n\n    fn_root, fn_ext = os.path.splitext(filename)\n    kept_names = []\n    for i in range(1, keep + 1):\n        if fn_ext:\n            kept_names.append(f'{fn_root}.{i}{fn_ext}')\n        else:\n            kept_names.append(f'{fn_root}.{i}')\n\n    fns = [filename] + kept_names\n    for orig_name, kept_name in reversed(list(zip(fns, fns[1:]))):\n        if not os.path.exists(orig_name):\n            continue\n        os.rename(orig_name, kept_name)\n\n    if os.path.exists(kept_names[-1]):\n        os.remove(kept_names[-1])\n\n    return",
    "docstring": "If *filename.ext* exists, it will be moved to *filename.1.ext*, \nwith all conflicting filenames being moved up by one, dropping any files beyond *keep*.\n\nAfter rotation, *filename* will be available for creation as a new file.\n\nFails if *filename* is not a file or if *keep* is not > 0."
  },
  {
    "function": "construct_format_field_str",
    "code": "def construct_format_field_str(fname, fspec, conv):\n    \"\"\"\n    Constructs a format field string from the field name, spec, and\n    conversion character (``fname``, ``fspec``, ``conv``). See Python\n    String Formatting for more info.\n    \"\"\"\n    if fname is None:\n        return ''\n    ret = '{' + fname\n    if conv:\n        ret += '!' + conv\n    if fspec:\n        ret += ':' + fspec\n    ret += '}'\n    return ret",
    "docstring": "Constructs a format field string from the field name, spec, and\nconversion character (``fname``, ``fspec``, ``conv``). See Python\nString Formatting for more info."
  },
  {
    "function": "split_format_str",
    "code": "def split_format_str(fstr):\n    \"\"\"Does very basic splitting of a format string, returns a list of\n    strings. For full tokenization, see :func:`tokenize_format_str`.\n\n    \"\"\"\n    ret = []\n\n    for lit, fname, fspec, conv in Formatter().parse(fstr):\n        if fname is None:\n            ret.append((lit, None))\n            continue\n        field_str = construct_format_field_str(fname, fspec, conv)\n        ret.append((lit, field_str))\n    return ret",
    "docstring": "Does very basic splitting of a format string, returns a list of\nstrings. For full tokenization, see :func:`tokenize_format_str`."
  },
  {
    "function": "infer_positional_format_args",
    "code": "def infer_positional_format_args(fstr):\n    \"\"\"Takes format strings with anonymous positional arguments, (e.g.,\n    \"{}\" and {:d}), and converts them into numbered ones for explicitness and\n    compatibility with 2.6.\n\n    Returns a string with the inferred positional arguments.\n    \"\"\"\n    # TODO: memoize\n    ret, max_anon = '', 0\n    # look for {: or {! or {. or {[ or {}\n    start, end, prev_end = 0, 0, 0\n    for match in _pos_farg_re.finditer(fstr):\n        start, end, group = match.start(), match.end(), match.group()\n        if prev_end < start:\n            ret += fstr[prev_end:start]\n        prev_end = end\n        if group == '{{' or group == '}}':\n            ret += group\n            continue\n        ret += f'{{{max_anon}{group[1:]}'\n        max_anon += 1\n    ret += fstr[prev_end:]\n    return ret",
    "docstring": "Takes format strings with anonymous positional arguments, (e.g.,\n\"{}\" and {:d}), and converts them into numbered ones for explicitness and\ncompatibility with 2.6.\n\nReturns a string with the inferred positional arguments."
  },
  {
    "function": "get_format_args",
    "code": "def get_format_args(fstr):\n    \"\"\"\n    Turn a format string into two lists of arguments referenced by the\n    format string. One is positional arguments, and the other is named\n    arguments. Each element of the list includes the name and the\n    nominal type of the field.\n\n    # >>> get_format_args(\"{noun} is {1:d} years old{punct}\")\n    # ([(1, <type 'int'>)], [('noun', <type 'str'>), ('punct', <type 'str'>)])\n\n    # XXX: Py3k\n    >>> get_format_args(\"{noun} is {1:d} years old{punct}\") == \\\n        ([(1, int)], [('noun', str), ('punct', str)])\n    True\n    \"\"\"\n    # TODO: memoize\n    formatter = Formatter()\n    fargs, fkwargs, _dedup = [], [], set()\n\n    def _add_arg(argname, type_char='s'):\n        if argname not in _dedup:\n            _dedup.add(argname)\n            argtype = _TYPE_MAP.get(type_char, str)  # TODO: unicode\n            try:\n                fargs.append((int(argname), argtype))\n            except ValueError:\n                fkwargs.append((argname, argtype))\n\n    for lit, fname, fspec, conv in formatter.parse(fstr):\n        if fname is not None:\n            type_char = fspec[-1:]\n            fname_list = re.split('[.[]', fname)\n            if len(fname_list) > 1:\n                raise ValueError('encountered compound format arg: %r' % fname)\n            try:\n                base_fname = fname_list[0]\n                assert base_fname\n            except (IndexError, AssertionError):\n                raise ValueError('encountered anonymous positional argument')\n            _add_arg(fname, type_char)\n            for sublit, subfname, _, _ in formatter.parse(fspec):\n                # TODO: positional and anon args not allowed here.\n                if subfname is not None:\n                    _add_arg(subfname)\n    return fargs, fkwargs",
    "docstring": "Turn a format string into two lists of arguments referenced by the\nformat string. One is positional arguments, and the other is named\narguments. Each element of the list includes the name and the\nnominal type of the field.\n\n# >>> get_format_args(\"{noun} is {1:d} years old{punct}\")\n# ([(1, <type 'int'>)], [('noun', <type 'str'>), ('punct', <type 'str'>)])\n\n# XXX: Py3k\n>>> get_format_args(\"{noun} is {1:d} years old{punct}\") ==         ([(1, int)], [('noun', str), ('punct', str)])\nTrue"
  },
  {
    "function": "tokenize_format_str",
    "code": "def tokenize_format_str(fstr, resolve_pos=True):\n    \"\"\"Takes a format string, turns it into a list of alternating string\n    literals and :class:`BaseFormatField` tokens. By default, also\n    infers anonymous positional references into explicit, numbered\n    positional references. To disable this behavior set *resolve_pos*\n    to ``False``.\n    \"\"\"\n    ret = []\n    if resolve_pos:\n        fstr = infer_positional_format_args(fstr)\n    formatter = Formatter()\n    for lit, fname, fspec, conv in formatter.parse(fstr):\n        if lit:\n            ret.append(lit)\n        if fname is None:\n            continue\n        ret.append(BaseFormatField(fname, fspec, conv))\n    return ret",
    "docstring": "Takes a format string, turns it into a list of alternating string\nliterals and :class:`BaseFormatField` tokens. By default, also\ninfers anonymous positional references into explicit, numbered\npositional references. To disable this behavior set *resolve_pos*\nto ``False``."
  },
  {
    "function": "inspect_formatargspec",
    "code": "def inspect_formatargspec(\n        args, varargs=None, varkw=None, defaults=None,\n        kwonlyargs=(), kwonlydefaults={}, annotations={},\n        formatarg=str,\n        formatvarargs=lambda name: '*' + name,\n        formatvarkw=lambda name: '**' + name,\n        formatvalue=lambda value: '=' + repr(value),\n        formatreturns=lambda text: ' -> ' + text,\n        formatannotation=formatannotation):\n    \"\"\"Copy formatargspec from python 3.7 standard library.\n    Python 3 has deprecated formatargspec and requested that Signature\n    be used instead, however this requires a full reimplementation\n    of formatargspec() in terms of creating Parameter objects and such.\n    Instead of introducing all the object-creation overhead and having\n    to reinvent from scratch, just copy their compatibility routine.\n    \"\"\"\n\n    def formatargandannotation(arg):\n        result = formatarg(arg)\n        if arg in annotations:\n            result += ': ' + formatannotation(annotations[arg])\n        return result\n    specs = []\n    if defaults:\n        firstdefault = len(args) - len(defaults)\n    for i, arg in enumerate(args):\n        spec = formatargandannotation(arg)\n        if defaults and i >= firstdefault:\n            spec = spec + formatvalue(defaults[i - firstdefault])\n        specs.append(spec)\n    if varargs is not None:\n        specs.append(formatvarargs(formatargandannotation(varargs)))\n    else:\n        if kwonlyargs:\n            specs.append('*')\n    if kwonlyargs:\n        for kwonlyarg in kwonlyargs:\n            spec = formatargandannotation(kwonlyarg)\n            if kwonlydefaults and kwonlyarg in kwonlydefaults:\n                spec += formatvalue(kwonlydefaults[kwonlyarg])\n            specs.append(spec)\n    if varkw is not None:\n        specs.append(formatvarkw(formatargandannotation(varkw)))\n    result = '(' + ', '.join(specs) + ')'\n    if 'return' in annotations:\n        result += formatreturns(formatannotation(annotations['return']))\n    return result",
    "docstring": "Copy formatargspec from python 3.7 standard library.\nPython 3 has deprecated formatargspec and requested that Signature\nbe used instead, however this requires a full reimplementation\nof formatargspec() in terms of creating Parameter objects and such.\nInstead of introducing all the object-creation overhead and having\nto reinvent from scratch, just copy their compatibility routine."
  },
  {
    "function": "get_module_callables",
    "code": "def get_module_callables(mod, ignore=None):\n    \"\"\"Returns two maps of (*types*, *funcs*) from *mod*, optionally\n    ignoring based on the :class:`bool` return value of the *ignore*\n    callable. *mod* can be a string name of a module in\n    :data:`sys.modules` or the module instance itself.\n    \"\"\"\n    if isinstance(mod, str):\n        mod = sys.modules[mod]\n    types, funcs = {}, {}\n    for attr_name in dir(mod):\n        if ignore and ignore(attr_name):\n            continue\n        try:\n            attr = getattr(mod, attr_name)\n        except Exception:\n            continue\n        try:\n            attr_mod_name = attr.__module__\n        except AttributeError:\n            continue\n        if attr_mod_name != mod.__name__:\n            continue\n        if isinstance(attr, type):\n            types[attr_name] = attr\n        elif callable(attr):\n            funcs[attr_name] = attr\n    return types, funcs",
    "docstring": "Returns two maps of (*types*, *funcs*) from *mod*, optionally\nignoring based on the :class:`bool` return value of the *ignore*\ncallable. *mod* can be a string name of a module in\n:data:`sys.modules` or the module instance itself."
  },
  {
    "function": "mro_items",
    "code": "def mro_items(type_obj):\n    \"\"\"Takes a type and returns an iterator over all class variables\n    throughout the type hierarchy (respecting the MRO).\n\n    >>> sorted(set([k for k, v in mro_items(int) if not k.startswith('__') and 'bytes' not in k and not callable(v)]))\n    ['denominator', 'imag', 'numerator', 'real']\n    \"\"\"\n    # TODO: handle slots?\n    return itertools.chain.from_iterable(ct.__dict__.items()\n                                         for ct in type_obj.__mro__)",
    "docstring": "Takes a type and returns an iterator over all class variables\nthroughout the type hierarchy (respecting the MRO).\n\n>>> sorted(set([k for k, v in mro_items(int) if not k.startswith('__') and 'bytes' not in k and not callable(v)]))\n['denominator', 'imag', 'numerator', 'real']"
  },
  {
    "function": "dir_dict",
    "code": "def dir_dict(obj, raise_exc=False):\n    \"\"\"Return a dictionary of attribute names to values for a given\n    object. Unlike ``obj.__dict__``, this function returns all\n    attributes on the object, including ones on parent classes.\n    \"\"\"\n    # TODO: separate function for handling descriptors on types?\n    ret = {}\n    for k in dir(obj):\n        try:\n            ret[k] = getattr(obj, k)\n        except Exception:\n            if raise_exc:\n                raise\n    return ret",
    "docstring": "Return a dictionary of attribute names to values for a given\nobject. Unlike ``obj.__dict__``, this function returns all\nattributes on the object, including ones on parent classes."
  },
  {
    "function": "copy_function",
    "code": "def copy_function(orig, copy_dict=True):\n    \"\"\"Returns a shallow copy of the function, including code object,\n    globals, closure, etc.\n\n    >>> func = lambda: func\n    >>> func() is func\n    True\n    >>> func_copy = copy_function(func)\n    >>> func_copy() is func\n    True\n    >>> func_copy is not func\n    True\n\n    Args:\n        orig (function): The function to be copied. Must be a\n            function, not just any method or callable.\n        copy_dict (bool): Also copy any attributes set on the function\n            instance. Defaults to ``True``.\n    \"\"\"\n    ret = FunctionType(orig.__code__,\n                       orig.__globals__,\n                       name=orig.__name__,\n                       argdefs=getattr(orig, \"__defaults__\", None),\n                       closure=getattr(orig, \"__closure__\", None))\n    if hasattr(orig, \"__kwdefaults__\"):\n        ret.__kwdefaults__ = orig.__kwdefaults__\n    if copy_dict:\n        ret.__dict__.update(orig.__dict__)\n    return ret",
    "docstring": "Returns a shallow copy of the function, including code object,\nglobals, closure, etc.\n\n>>> func = lambda: func\n>>> func() is func\nTrue\n>>> func_copy = copy_function(func)\n>>> func_copy() is func\nTrue\n>>> func_copy is not func\nTrue\n\nArgs:\n    orig (function): The function to be copied. Must be a\n        function, not just any method or callable.\n    copy_dict (bool): Also copy any attributes set on the function\n        instance. Defaults to ``True``."
  },
  {
    "function": "partial_ordering",
    "code": "def partial_ordering(cls):\n    \"\"\"Class decorator, similar to :func:`functools.total_ordering`,\n    except it is used to define `partial orderings`_ (i.e., it is\n    possible that *x* is neither greater than, equal to, or less than\n    *y*). It assumes the presence of the ``__le__()`` and ``__ge__()``\n    method, but nothing else. It will not override any existing\n    additional comparison methods.\n\n    .. _partial orderings: https://en.wikipedia.org/wiki/Partially_ordered_set\n\n    >>> @partial_ordering\n    ... class MySet(set):\n    ...     def __le__(self, other):\n    ...         return self.issubset(other)\n    ...     def __ge__(self, other):\n    ...         return self.issuperset(other)\n    ...\n    >>> a = MySet([1,2,3])\n    >>> b = MySet([1,2])\n    >>> c = MySet([1,2,4])\n    >>> b < a\n    True\n    >>> b > a\n    False\n    >>> b < c\n    True\n    >>> a < c\n    False\n    >>> c > a\n    False\n    \"\"\"\n    def __lt__(self, other): return self <= other and not self >= other\n    def __gt__(self, other): return self >= other and not self <= other\n    def __eq__(self, other): return self >= other and self <= other\n\n    if not hasattr(cls, '__lt__'): cls.__lt__ = __lt__\n    if not hasattr(cls, '__gt__'): cls.__gt__ = __gt__\n    if not hasattr(cls, '__eq__'): cls.__eq__ = __eq__\n\n    return cls",
    "docstring": "Class decorator, similar to :func:`functools.total_ordering`,\nexcept it is used to define `partial orderings`_ (i.e., it is\npossible that *x* is neither greater than, equal to, or less than\n*y*). It assumes the presence of the ``__le__()`` and ``__ge__()``\nmethod, but nothing else. It will not override any existing\nadditional comparison methods.\n\n.. _partial orderings: https://en.wikipedia.org/wiki/Partially_ordered_set\n\n>>> @partial_ordering\n... class MySet(set):\n...     def __le__(self, other):\n...         return self.issubset(other)\n...     def __ge__(self, other):\n...         return self.issuperset(other)\n...\n>>> a = MySet([1,2,3])\n>>> b = MySet([1,2])\n>>> c = MySet([1,2,4])\n>>> b < a\nTrue\n>>> b > a\nFalse\n>>> b < c\nTrue\n>>> a < c\nFalse\n>>> c > a\nFalse"
  },
  {
    "function": "format_invocation",
    "code": "def format_invocation(name='', args=(), kwargs=None, **kw):\n    \"\"\"Given a name, positional arguments, and keyword arguments, format\n    a basic Python-style function call.\n\n    >>> print(format_invocation('func', args=(1, 2), kwargs={'c': 3}))\n    func(1, 2, c=3)\n    >>> print(format_invocation('a_func', args=(1,)))\n    a_func(1)\n    >>> print(format_invocation('kw_func', kwargs=[('a', 1), ('b', 2)]))\n    kw_func(a=1, b=2)\n\n    \"\"\"\n    _repr = kw.pop('repr', repr)\n    if kw:\n        raise TypeError('unexpected keyword args: %r' % ', '.join(kw.keys()))\n    kwargs = kwargs or {}\n    a_text = ', '.join([_repr(a) for a in args])\n    if isinstance(kwargs, dict):\n        kwarg_items = [(k, kwargs[k]) for k in sorted(kwargs)]\n    else:\n        kwarg_items = kwargs\n    kw_text = ', '.join([f'{k}={_repr(v)}' for k, v in kwarg_items])\n\n    all_args_text = a_text\n    if all_args_text and kw_text:\n        all_args_text += ', '\n    all_args_text += kw_text\n\n    return f'{name}({all_args_text})'",
    "docstring": "Given a name, positional arguments, and keyword arguments, format\na basic Python-style function call.\n\n>>> print(format_invocation('func', args=(1, 2), kwargs={'c': 3}))\nfunc(1, 2, c=3)\n>>> print(format_invocation('a_func', args=(1,)))\na_func(1)\n>>> print(format_invocation('kw_func', kwargs=[('a', 1), ('b', 2)]))\nkw_func(a=1, b=2)"
  },
  {
    "function": "format_exp_repr",
    "code": "def format_exp_repr(obj, pos_names, req_names=None, opt_names=None, opt_key=None):\n    \"\"\"Render an expression-style repr of an object, based on attribute\n    names, which are assumed to line up with arguments to an initializer.\n\n    >>> class Flag(object):\n    ...    def __init__(self, length, width, depth=None):\n    ...        self.length = length\n    ...        self.width = width\n    ...        self.depth = depth\n    ...\n\n    That's our Flag object, here are some example reprs for it:\n\n    >>> flag = Flag(5, 10)\n    >>> print(format_exp_repr(flag, ['length', 'width'], [], ['depth']))\n    Flag(5, 10)\n    >>> flag2 = Flag(5, 15, 2)\n    >>> print(format_exp_repr(flag2, ['length'], ['width', 'depth']))\n    Flag(5, width=15, depth=2)\n\n    By picking the pos_names, req_names, opt_names, and opt_key, you\n    can fine-tune how you want the repr to look.\n\n    Args:\n       obj (object): The object whose type name will be used and\n          attributes will be checked\n       pos_names (list): Required list of attribute names which will be\n          rendered as positional arguments in the output repr.\n       req_names (list): List of attribute names which will always\n          appear in the keyword arguments in the output repr. Defaults to None.\n       opt_names (list): List of attribute names which may appear in\n          the keyword arguments in the output repr, provided they pass\n          the *opt_key* check. Defaults to None.\n       opt_key (callable): A function or callable which checks whether\n          an opt_name should be in the repr. Defaults to a\n          ``None``-check.\n\n    \"\"\"\n    cn = type(obj).__name__\n    req_names = req_names or []\n    opt_names = opt_names or []\n    uniq_names, all_names = set(), []\n    for name in req_names + opt_names:\n        if name in uniq_names:\n            continue\n        uniq_names.add(name)\n        all_names.append(name)\n\n    if opt_key is None:\n        opt_key = lambda v: v is None\n    assert callable(opt_key)\n\n    args = [getattr(obj, name, None) for name in pos_names]\n\n    kw_items = [(name, getattr(obj, name, None)) for name in all_names]\n    kw_items = [(name, val) for name, val in kw_items\n                if not (name in opt_names and opt_key(val))]\n\n    return format_invocation(cn, args, kw_items)",
    "docstring": "Render an expression-style repr of an object, based on attribute\nnames, which are assumed to line up with arguments to an initializer.\n\n>>> class Flag(object):\n...    def __init__(self, length, width, depth=None):\n...        self.length = length\n...        self.width = width\n...        self.depth = depth\n...\n\nThat's our Flag object, here are some example reprs for it:\n\n>>> flag = Flag(5, 10)\n>>> print(format_exp_repr(flag, ['length', 'width'], [], ['depth']))\nFlag(5, 10)\n>>> flag2 = Flag(5, 15, 2)\n>>> print(format_exp_repr(flag2, ['length'], ['width', 'depth']))\nFlag(5, width=15, depth=2)\n\nBy picking the pos_names, req_names, opt_names, and opt_key, you\ncan fine-tune how you want the repr to look.\n\nArgs:\n   obj (object): The object whose type name will be used and\n      attributes will be checked\n   pos_names (list): Required list of attribute names which will be\n      rendered as positional arguments in the output repr.\n   req_names (list): List of attribute names which will always\n      appear in the keyword arguments in the output repr. Defaults to None.\n   opt_names (list): List of attribute names which may appear in\n      the keyword arguments in the output repr, provided they pass\n      the *opt_key* check. Defaults to None.\n   opt_key (callable): A function or callable which checks whether\n      an opt_name should be in the repr. Defaults to a\n      ``None``-check."
  },
  {
    "function": "format_nonexp_repr",
    "code": "def format_nonexp_repr(obj, req_names=None, opt_names=None, opt_key=None):\n    \"\"\"Format a non-expression-style repr\n\n    Some object reprs look like object instantiation, e.g., App(r=[], mw=[]).\n\n    This makes sense for smaller, lower-level objects whose state\n    roundtrips. But a lot of objects contain values that don't\n    roundtrip, like types and functions.\n\n    For those objects, there is the non-expression style repr, which\n    mimic's Python's default style to make a repr like so:\n\n    >>> class Flag(object):\n    ...    def __init__(self, length, width, depth=None):\n    ...        self.length = length\n    ...        self.width = width\n    ...        self.depth = depth\n    ...\n    >>> flag = Flag(5, 10)\n    >>> print(format_nonexp_repr(flag, ['length', 'width'], ['depth']))\n    <Flag length=5 width=10>\n\n    If no attributes are specified or set, utilizes the id, not unlike Python's\n    built-in behavior.\n\n    >>> print(format_nonexp_repr(flag))\n    <Flag id=...>\n    \"\"\"\n    cn = obj.__class__.__name__\n    req_names = req_names or []\n    opt_names = opt_names or []\n    uniq_names, all_names = set(), []\n    for name in req_names + opt_names:\n        if name in uniq_names:\n            continue\n        uniq_names.add(name)\n        all_names.append(name)\n\n    if opt_key is None:\n        opt_key = lambda v: v is None\n    assert callable(opt_key)\n\n    items = [(name, getattr(obj, name, None)) for name in all_names]\n    labels = [f'{name}={val!r}' for name, val in items\n              if not (name in opt_names and opt_key(val))]\n    if not labels:\n        labels = ['id=%s' % id(obj)]\n    ret = '<{} {}>'.format(cn, ' '.join(labels))\n    return ret",
    "docstring": "Format a non-expression-style repr\n\nSome object reprs look like object instantiation, e.g., App(r=[], mw=[]).\n\nThis makes sense for smaller, lower-level objects whose state\nroundtrips. But a lot of objects contain values that don't\nroundtrip, like types and functions.\n\nFor those objects, there is the non-expression style repr, which\nmimic's Python's default style to make a repr like so:\n\n>>> class Flag(object):\n...    def __init__(self, length, width, depth=None):\n...        self.length = length\n...        self.width = width\n...        self.depth = depth\n...\n>>> flag = Flag(5, 10)\n>>> print(format_nonexp_repr(flag, ['length', 'width'], ['depth']))\n<Flag length=5 width=10>\n\nIf no attributes are specified or set, utilizes the id, not unlike Python's\nbuilt-in behavior.\n\n>>> print(format_nonexp_repr(flag))\n<Flag id=...>"
  },
  {
    "function": "wraps",
    "code": "def wraps(func, injected=None, expected=None, **kw):\n    \"\"\"Decorator factory to apply update_wrapper() to a wrapper function.\n\n    Modeled after built-in :func:`functools.wraps`. Returns a decorator\n    that invokes update_wrapper() with the decorated function as the wrapper\n    argument and the arguments to wraps() as the remaining arguments.\n    Default arguments are as for update_wrapper(). This is a convenience\n    function to simplify applying partial() to update_wrapper().\n\n    Same example as in update_wrapper's doc but with wraps:\n\n        >>> from boltons.funcutils import wraps\n        >>>\n        >>> def print_return(func):\n        ...     @wraps(func)\n        ...     def wrapper(*args, **kwargs):\n        ...         ret = func(*args, **kwargs)\n        ...         print(ret)\n        ...         return ret\n        ...     return wrapper\n        ...\n        >>> @print_return\n        ... def example():\n        ...     '''docstring'''\n        ...     return 'example return value'\n        >>>\n        >>> val = example()\n        example return value\n        >>> example.__name__\n        'example'\n        >>> example.__doc__\n        'docstring'\n    \"\"\"\n    return partial(update_wrapper, func=func, build_from=None,\n                   injected=injected, expected=expected, **kw)",
    "docstring": "Decorator factory to apply update_wrapper() to a wrapper function.\n\nModeled after built-in :func:`functools.wraps`. Returns a decorator\nthat invokes update_wrapper() with the decorated function as the wrapper\nargument and the arguments to wraps() as the remaining arguments.\nDefault arguments are as for update_wrapper(). This is a convenience\nfunction to simplify applying partial() to update_wrapper().\n\nSame example as in update_wrapper's doc but with wraps:\n\n    >>> from boltons.funcutils import wraps\n    >>>\n    >>> def print_return(func):\n    ...     @wraps(func)\n    ...     def wrapper(*args, **kwargs):\n    ...         ret = func(*args, **kwargs)\n    ...         print(ret)\n    ...         return ret\n    ...     return wrapper\n    ...\n    >>> @print_return\n    ... def example():\n    ...     '''docstring'''\n    ...     return 'example return value'\n    >>>\n    >>> val = example()\n    example return value\n    >>> example.__name__\n    'example'\n    >>> example.__doc__\n    'docstring'"
  },
  {
    "function": "update_wrapper",
    "code": "def update_wrapper(wrapper, func, injected=None, expected=None, build_from=None, **kw):\n    \"\"\"Modeled after the built-in :func:`functools.update_wrapper`,\n    this function is used to make your wrapper function reflect the\n    wrapped function's:\n\n      * Name\n      * Documentation\n      * Module\n      * Signature\n\n    The built-in :func:`functools.update_wrapper` copies the first three, but\n    does not copy the signature. This version of ``update_wrapper`` can copy\n    the inner function's signature exactly, allowing seamless usage\n    and :mod:`introspection <inspect>`. Usage is identical to the\n    built-in version::\n\n        >>> from boltons.funcutils import update_wrapper\n        >>>\n        >>> def print_return(func):\n        ...     def wrapper(*args, **kwargs):\n        ...         ret = func(*args, **kwargs)\n        ...         print(ret)\n        ...         return ret\n        ...     return update_wrapper(wrapper, func)\n        ...\n        >>> @print_return\n        ... def example():\n        ...     '''docstring'''\n        ...     return 'example return value'\n        >>>\n        >>> val = example()\n        example return value\n        >>> example.__name__\n        'example'\n        >>> example.__doc__\n        'docstring'\n\n    In addition, the boltons version of update_wrapper supports\n    modifying the outer signature. By passing a list of\n    *injected* argument names, those arguments will be removed from\n    the outer wrapper's signature, allowing your decorator to provide\n    arguments that aren't passed in.\n\n    Args:\n\n        wrapper (function) : The callable to which the attributes of\n            *func* are to be copied.\n        func (function): The callable whose attributes are to be copied.\n        injected (list): An optional list of argument names which\n            should not appear in the new wrapper's signature.\n        expected (list): An optional list of argument names (or (name,\n            default) pairs) representing new arguments introduced by\n            the wrapper (the opposite of *injected*). See\n            :meth:`FunctionBuilder.add_arg()` for more details.\n        build_from (function): The callable from which the new wrapper\n            is built. Defaults to *func*, unless *wrapper* is partial object\n            built from *func*, in which case it defaults to *wrapper*.\n            Useful in some specific cases where *wrapper* and *func* have the\n            same arguments but differ on which are keyword-only and positional-only.\n        update_dict (bool): Whether to copy other, non-standard\n            attributes of *func* over to the wrapper. Defaults to True.\n        inject_to_varkw (bool): Ignore missing arguments when a\n            ``**kwargs``-type catch-all is present. Defaults to True.\n        hide_wrapped (bool): Remove reference to the wrapped function(s)\n            in the updated function.\n\n    In opposition to the built-in :func:`functools.update_wrapper` bolton's\n    version returns a copy of the function and does not modify anything in place.\n    For more in-depth wrapping of functions, see the\n    :class:`FunctionBuilder` type, on which update_wrapper was built.\n    \"\"\"\n    if injected is None:\n        injected = []\n    elif isinstance(injected, str):\n        injected = [injected]\n    else:\n        injected = list(injected)\n\n    expected_items = _parse_wraps_expected(expected)\n\n    if isinstance(func, (classmethod, staticmethod)):\n        raise TypeError('wraps does not support wrapping classmethods and'\n                        ' staticmethods, change the order of wrapping to'\n                        ' wrap the underlying function: %r'\n                        % (getattr(func, '__func__', None),))\n\n    update_dict = kw.pop('update_dict', True)\n    inject_to_varkw = kw.pop('inject_to_varkw', True)\n    hide_wrapped = kw.pop('hide_wrapped', False)\n    if kw:\n        raise TypeError('unexpected kwargs: %r' % kw.keys())\n\n    if isinstance(wrapper, functools.partial) and func is wrapper.func:\n        build_from = build_from or wrapper\n\n    fb = FunctionBuilder.from_func(build_from or func)\n\n    for arg in injected:\n        try:\n            fb.remove_arg(arg)\n        except MissingArgument:\n            if inject_to_varkw and fb.varkw is not None:\n                continue  # keyword arg will be caught by the varkw\n            raise\n\n    for arg, default in expected_items:\n        fb.add_arg(arg, default)  # may raise ExistingArgument\n\n    if fb.is_async:\n        fb.body = 'return await _call(%s)' % fb.get_invocation_str()\n    else:\n        fb.body = 'return _call(%s)' % fb.get_invocation_str()\n\n    execdict = dict(_call=wrapper, _func=func)\n    fully_wrapped = fb.get_func(execdict, with_dict=update_dict)\n\n    if hide_wrapped and hasattr(fully_wrapped, '__wrapped__'):\n        del fully_wrapped.__dict__['__wrapped__']\n    elif not hide_wrapped:\n        fully_wrapped.__wrapped__ = func  # ref to the original function (#115)\n\n    return fully_wrapped",
    "docstring": "Modeled after the built-in :func:`functools.update_wrapper`,\nthis function is used to make your wrapper function reflect the\nwrapped function's:\n\n  * Name\n  * Documentation\n  * Module\n  * Signature\n\nThe built-in :func:`functools.update_wrapper` copies the first three, but\ndoes not copy the signature. This version of ``update_wrapper`` can copy\nthe inner function's signature exactly, allowing seamless usage\nand :mod:`introspection <inspect>`. Usage is identical to the\nbuilt-in version::\n\n    >>> from boltons.funcutils import update_wrapper\n    >>>\n    >>> def print_return(func):\n    ...     def wrapper(*args, **kwargs):\n    ...         ret = func(*args, **kwargs)\n    ...         print(ret)\n    ...         return ret\n    ...     return update_wrapper(wrapper, func)\n    ...\n    >>> @print_return\n    ... def example():\n    ...     '''docstring'''\n    ...     return 'example return value'\n    >>>\n    >>> val = example()\n    example return value\n    >>> example.__name__\n    'example'\n    >>> example.__doc__\n    'docstring'\n\nIn addition, the boltons version of update_wrapper supports\nmodifying the outer signature. By passing a list of\n*injected* argument names, those arguments will be removed from\nthe outer wrapper's signature, allowing your decorator to provide\narguments that aren't passed in.\n\nArgs:\n\n    wrapper (function) : The callable to which the attributes of\n        *func* are to be copied.\n    func (function): The callable whose attributes are to be copied.\n    injected (list): An optional list of argument names which\n        should not appear in the new wrapper's signature.\n    expected (list): An optional list of argument names (or (name,\n        default) pairs) representing new arguments introduced by\n        the wrapper (the opposite of *injected*). See\n        :meth:`FunctionBuilder.add_arg()` for more details.\n    build_from (function): The callable from which the new wrapper\n        is built. Defaults to *func*, unless *wrapper* is partial object\n        built from *func*, in which case it defaults to *wrapper*.\n        Useful in some specific cases where *wrapper* and *func* have the\n        same arguments but differ on which are keyword-only and positional-only.\n    update_dict (bool): Whether to copy other, non-standard\n        attributes of *func* over to the wrapper. Defaults to True.\n    inject_to_varkw (bool): Ignore missing arguments when a\n        ``**kwargs``-type catch-all is present. Defaults to True.\n    hide_wrapped (bool): Remove reference to the wrapped function(s)\n        in the updated function.\n\nIn opposition to the built-in :func:`functools.update_wrapper` bolton's\nversion returns a copy of the function and does not modify anything in place.\nFor more in-depth wrapping of functions, see the\n:class:`FunctionBuilder` type, on which update_wrapper was built."
  },
  {
    "function": "_indent",
    "code": "def _indent(text, margin, newline='\\n', key=bool):\n    \"based on boltons.strutils.indent\"\n    indented_lines = [(margin + line if key(line) else line)\n                      for line in text.splitlines()]\n    return newline.join(indented_lines)",
    "docstring": "based on boltons.strutils.indent"
  },
  {
    "function": "noop",
    "code": "def noop(*args, **kwargs):\n    \"\"\"\n    Simple function that should be used when no effect is desired.\n    An alternative to checking for  an optional function type parameter.\n\n    e.g.\n    def decorate(func, pre_func=None, post_func=None):\n        if pre_func:\n            pre_func()\n        func()\n        if post_func:\n            post_func()\n\n    vs\n\n    def decorate(func, pre_func=noop, post_func=noop):\n        pre_func()\n        func()\n        post_func()\n    \"\"\"\n    return None",
    "docstring": "Simple function that should be used when no effect is desired.\nAn alternative to checking for  an optional function type parameter.\n\ne.g.\ndef decorate(func, pre_func=None, post_func=None):\n    if pre_func:\n        pre_func()\n    func()\n    if post_func:\n        post_func()\n\nvs\n\ndef decorate(func, pre_func=noop, post_func=noop):\n    pre_func()\n    func()\n    post_func()"
  },
  {
    "function": "get_all",
    "code": "def get_all(type_obj, include_subtypes=True):\n    \"\"\"Get a list containing all instances of a given type.  This will\n    work for the vast majority of types out there.\n\n    >>> class Ratking(object): pass\n    >>> wiki, hak, sport = Ratking(), Ratking(), Ratking()\n    >>> len(get_all(Ratking))\n    3\n\n    However, there are some exceptions. For example, ``get_all(bool)``\n    returns an empty list because ``True`` and ``False`` are\n    themselves built-in and not tracked.\n\n    >>> get_all(bool)\n    []\n\n    Still, it's not hard to see how this functionality can be used to\n    find all instances of a leaking type and track them down further\n    using :func:`gc.get_referrers` and :func:`gc.get_referents`.\n\n    ``get_all()`` is optimized such that getting instances of\n    user-created types is quite fast. Setting *include_subtypes* to\n    ``False`` will further increase performance in cases where\n    instances of subtypes aren't required.\n\n    .. note::\n\n      There are no guarantees about the state of objects returned by\n      ``get_all()``, especially in concurrent environments. For\n      instance, it is possible for an object to be in the middle of\n      executing its ``__init__()`` and be only partially constructed.\n    \"\"\"\n    # TODO: old-style classes\n    if not isinstance(type_obj, type):\n        raise TypeError('expected a type, not %r' % type_obj)\n    try:\n        type_is_tracked = gc.is_tracked(type_obj)\n    except AttributeError:\n        type_is_tracked = False  # Python 2.6 and below don't get the speedup\n    if type_is_tracked:\n        to_check = gc.get_referrers(type_obj)\n    else:\n        to_check = gc.get_objects()\n\n    if include_subtypes:\n        ret = [x for x in to_check if isinstance(x, type_obj)]\n    else:\n        ret = [x for x in to_check if type(x) is type_obj]\n    return ret",
    "docstring": "Get a list containing all instances of a given type.  This will\nwork for the vast majority of types out there.\n\n>>> class Ratking(object): pass\n>>> wiki, hak, sport = Ratking(), Ratking(), Ratking()\n>>> len(get_all(Ratking))\n3\n\nHowever, there are some exceptions. For example, ``get_all(bool)``\nreturns an empty list because ``True`` and ``False`` are\nthemselves built-in and not tracked.\n\n>>> get_all(bool)\n[]\n\nStill, it's not hard to see how this functionality can be used to\nfind all instances of a leaking type and track them down further\nusing :func:`gc.get_referrers` and :func:`gc.get_referents`.\n\n``get_all()`` is optimized such that getting instances of\nuser-created types is quite fast. Setting *include_subtypes* to\n``False`` will further increase performance in cases where\ninstances of subtypes aren't required.\n\n.. note::\n\n  There are no guarantees about the state of objects returned by\n  ``get_all()``, especially in concurrent environments. For\n  instance, it is possible for an object to be in the middle of\n  executing its ``__init__()`` and be only partially constructed."
  },
  {
    "function": "is_iterable",
    "code": "def is_iterable(obj):\n    \"\"\"Similar in nature to :func:`callable`, ``is_iterable`` returns\n    ``True`` if an object is `iterable`_, ``False`` if not.\n\n    >>> is_iterable([])\n    True\n    >>> is_iterable(object())\n    False\n\n    .. _iterable: https://docs.python.org/2/glossary.html#term-iterable\n    \"\"\"\n    try:\n        iter(obj)\n    except TypeError:\n        return False\n    return True",
    "docstring": "Similar in nature to :func:`callable`, ``is_iterable`` returns\n``True`` if an object is `iterable`_, ``False`` if not.\n\n>>> is_iterable([])\nTrue\n>>> is_iterable(object())\nFalse\n\n.. _iterable: https://docs.python.org/2/glossary.html#term-iterable"
  },
  {
    "function": "is_scalar",
    "code": "def is_scalar(obj):\n    \"\"\"A near-mirror of :func:`is_iterable`. Returns ``False`` if an\n    object is an iterable container type. Strings are considered\n    scalar as well, because strings are more often treated as whole\n    values as opposed to iterables of 1-character substrings.\n\n    >>> is_scalar(object())\n    True\n    >>> is_scalar(range(10))\n    False\n    >>> is_scalar('hello')\n    True\n    \"\"\"\n    return not is_iterable(obj) or isinstance(obj, (str, bytes))",
    "docstring": "A near-mirror of :func:`is_iterable`. Returns ``False`` if an\nobject is an iterable container type. Strings are considered\nscalar as well, because strings are more often treated as whole\nvalues as opposed to iterables of 1-character substrings.\n\n>>> is_scalar(object())\nTrue\n>>> is_scalar(range(10))\nFalse\n>>> is_scalar('hello')\nTrue"
  },
  {
    "function": "is_collection",
    "code": "def is_collection(obj):\n    \"\"\"The opposite of :func:`is_scalar`.  Returns ``True`` if an object\n    is an iterable other than a string.\n\n    >>> is_collection(object())\n    False\n    >>> is_collection(range(10))\n    True\n    >>> is_collection('hello')\n    False\n    \"\"\"\n    return is_iterable(obj) and not isinstance(obj, (str, bytes))",
    "docstring": "The opposite of :func:`is_scalar`.  Returns ``True`` if an object\nis an iterable other than a string.\n\n>>> is_collection(object())\nFalse\n>>> is_collection(range(10))\nTrue\n>>> is_collection('hello')\nFalse"
  },
  {
    "function": "split",
    "code": "def split(src, sep=None, maxsplit=None):\n    \"\"\"Splits an iterable based on a separator. Like :meth:`str.split`,\n    but for all iterables. Returns a list of lists.\n\n    >>> split(['hi', 'hello', None, None, 'sup', None, 'soap', None])\n    [['hi', 'hello'], ['sup'], ['soap']]\n\n    See :func:`split_iter` docs for more info.\n    \"\"\"\n    return list(split_iter(src, sep, maxsplit))",
    "docstring": "Splits an iterable based on a separator. Like :meth:`str.split`,\nbut for all iterables. Returns a list of lists.\n\n>>> split(['hi', 'hello', None, None, 'sup', None, 'soap', None])\n[['hi', 'hello'], ['sup'], ['soap']]\n\nSee :func:`split_iter` docs for more info."
  },
  {
    "function": "split_iter",
    "code": "def split_iter(src, sep=None, maxsplit=None):\n    \"\"\"Splits an iterable based on a separator, *sep*, a max of\n    *maxsplit* times (no max by default). *sep* can be:\n\n      * a single value\n      * an iterable of separators\n      * a single-argument callable that returns True when a separator is\n        encountered\n\n    ``split_iter()`` yields lists of non-separator values. A separator will\n    never appear in the output.\n\n    >>> list(split_iter(['hi', 'hello', None, None, 'sup', None, 'soap', None]))\n    [['hi', 'hello'], ['sup'], ['soap']]\n\n    Note that ``split_iter`` is based on :func:`str.split`, so if\n    *sep* is ``None``, ``split()`` **groups** separators. If empty lists\n    are desired between two contiguous ``None`` values, simply use\n    ``sep=[None]``:\n\n    >>> list(split_iter(['hi', 'hello', None, None, 'sup', None]))\n    [['hi', 'hello'], ['sup']]\n    >>> list(split_iter(['hi', 'hello', None, None, 'sup', None], sep=[None]))\n    [['hi', 'hello'], [], ['sup'], []]\n\n    Using a callable separator:\n\n    >>> falsy_sep = lambda x: not x\n    >>> list(split_iter(['hi', 'hello', None, '', 'sup', False], falsy_sep))\n    [['hi', 'hello'], [], ['sup'], []]\n\n    See :func:`split` for a list-returning version.\n\n    \"\"\"\n    if not is_iterable(src):\n        raise TypeError('expected an iterable')\n\n    if maxsplit is not None:\n        maxsplit = int(maxsplit)\n        if maxsplit == 0:\n            yield [src]\n            return\n\n    if callable(sep):\n        sep_func = sep\n    elif not is_scalar(sep):\n        sep = frozenset(sep)\n        def sep_func(x): return x in sep\n    else:\n        def sep_func(x): return x == sep\n\n    cur_group = []\n    split_count = 0\n    for s in src:\n        if maxsplit is not None and split_count >= maxsplit:\n            def sep_func(x): return False\n        if sep_func(s):\n            if sep is None and not cur_group:\n                # If sep is none, str.split() \"groups\" separators\n                # check the str.split() docs for more info\n                continue\n            split_count += 1\n            yield cur_group\n            cur_group = []\n        else:\n            cur_group.append(s)\n\n    if cur_group or sep is not None:\n        yield cur_group\n    return",
    "docstring": "Splits an iterable based on a separator, *sep*, a max of\n*maxsplit* times (no max by default). *sep* can be:\n\n  * a single value\n  * an iterable of separators\n  * a single-argument callable that returns True when a separator is\n    encountered\n\n``split_iter()`` yields lists of non-separator values. A separator will\nnever appear in the output.\n\n>>> list(split_iter(['hi', 'hello', None, None, 'sup', None, 'soap', None]))\n[['hi', 'hello'], ['sup'], ['soap']]\n\nNote that ``split_iter`` is based on :func:`str.split`, so if\n*sep* is ``None``, ``split()`` **groups** separators. If empty lists\nare desired between two contiguous ``None`` values, simply use\n``sep=[None]``:\n\n>>> list(split_iter(['hi', 'hello', None, None, 'sup', None]))\n[['hi', 'hello'], ['sup']]\n>>> list(split_iter(['hi', 'hello', None, None, 'sup', None], sep=[None]))\n[['hi', 'hello'], [], ['sup'], []]\n\nUsing a callable separator:\n\n>>> falsy_sep = lambda x: not x\n>>> list(split_iter(['hi', 'hello', None, '', 'sup', False], falsy_sep))\n[['hi', 'hello'], [], ['sup'], []]\n\nSee :func:`split` for a list-returning version."
  },
  {
    "function": "lstrip",
    "code": "def lstrip(iterable, strip_value=None):\n    \"\"\"Strips values from the beginning of an iterable. Stripped items will\n    match the value of the argument strip_value. Functionality is analogous\n    to that of the method str.lstrip. Returns a list.\n\n    >>> lstrip(['Foo', 'Bar', 'Bam'], 'Foo')\n    ['Bar', 'Bam']\n\n    \"\"\"\n    return list(lstrip_iter(iterable, strip_value))",
    "docstring": "Strips values from the beginning of an iterable. Stripped items will\nmatch the value of the argument strip_value. Functionality is analogous\nto that of the method str.lstrip. Returns a list.\n\n>>> lstrip(['Foo', 'Bar', 'Bam'], 'Foo')\n['Bar', 'Bam']"
  },
  {
    "function": "lstrip_iter",
    "code": "def lstrip_iter(iterable, strip_value=None):\n    \"\"\"Strips values from the beginning of an iterable. Stripped items will\n    match the value of the argument strip_value. Functionality is analogous\n    to that of the method str.lstrip. Returns a generator.\n\n    >>> list(lstrip_iter(['Foo', 'Bar', 'Bam'], 'Foo'))\n    ['Bar', 'Bam']\n\n    \"\"\"\n    iterator = iter(iterable)\n    for i in iterator:\n        if i != strip_value:\n            yield i\n            break\n    for i in iterator:\n        yield i",
    "docstring": "Strips values from the beginning of an iterable. Stripped items will\nmatch the value of the argument strip_value. Functionality is analogous\nto that of the method str.lstrip. Returns a generator.\n\n>>> list(lstrip_iter(['Foo', 'Bar', 'Bam'], 'Foo'))\n['Bar', 'Bam']"
  },
  {
    "function": "rstrip",
    "code": "def rstrip(iterable, strip_value=None):\n    \"\"\"Strips values from the end of an iterable. Stripped items will\n    match the value of the argument strip_value. Functionality is analogous\n    to that of the method str.rstrip. Returns a list.\n\n    >>> rstrip(['Foo', 'Bar', 'Bam'], 'Bam')\n    ['Foo', 'Bar']\n\n    \"\"\"\n    return list(rstrip_iter(iterable, strip_value))",
    "docstring": "Strips values from the end of an iterable. Stripped items will\nmatch the value of the argument strip_value. Functionality is analogous\nto that of the method str.rstrip. Returns a list.\n\n>>> rstrip(['Foo', 'Bar', 'Bam'], 'Bam')\n['Foo', 'Bar']"
  },
  {
    "function": "rstrip_iter",
    "code": "def rstrip_iter(iterable, strip_value=None):\n    \"\"\"Strips values from the end of an iterable. Stripped items will\n    match the value of the argument strip_value. Functionality is analogous\n    to that of the method str.rstrip. Returns a generator.\n\n    >>> list(rstrip_iter(['Foo', 'Bar', 'Bam'], 'Bam'))\n    ['Foo', 'Bar']\n\n    \"\"\"\n    iterator = iter(iterable)\n    for i in iterator:\n        if i == strip_value:\n            cache = list()\n            cache.append(i)\n            broken = False\n            for i in iterator:\n                if i == strip_value:\n                    cache.append(i)\n                else:\n                    broken = True\n                    break\n            if not broken:  # Return to caller here because the end of the\n                return     # iterator has been reached\n            yield from cache\n        yield i",
    "docstring": "Strips values from the end of an iterable. Stripped items will\nmatch the value of the argument strip_value. Functionality is analogous\nto that of the method str.rstrip. Returns a generator.\n\n>>> list(rstrip_iter(['Foo', 'Bar', 'Bam'], 'Bam'))\n['Foo', 'Bar']"
  },
  {
    "function": "strip",
    "code": "def strip(iterable, strip_value=None):\n    \"\"\"Strips values from the beginning and end of an iterable. Stripped items\n    will match the value of the argument strip_value. Functionality is\n    analogous to that of the method str.strip. Returns a list.\n\n    >>> strip(['Fu', 'Foo', 'Bar', 'Bam', 'Fu'], 'Fu')\n    ['Foo', 'Bar', 'Bam']\n\n    \"\"\"\n    return list(strip_iter(iterable, strip_value))",
    "docstring": "Strips values from the beginning and end of an iterable. Stripped items\nwill match the value of the argument strip_value. Functionality is\nanalogous to that of the method str.strip. Returns a list.\n\n>>> strip(['Fu', 'Foo', 'Bar', 'Bam', 'Fu'], 'Fu')\n['Foo', 'Bar', 'Bam']"
  },
  {
    "function": "strip_iter",
    "code": "def strip_iter(iterable, strip_value=None):\n    \"\"\"Strips values from the beginning and end of an iterable. Stripped items\n    will match the value of the argument strip_value. Functionality is\n    analogous to that of the method str.strip. Returns a generator.\n\n    >>> list(strip_iter(['Fu', 'Foo', 'Bar', 'Bam', 'Fu'], 'Fu'))\n    ['Foo', 'Bar', 'Bam']\n\n    \"\"\"\n    return rstrip_iter(lstrip_iter(iterable, strip_value), strip_value)",
    "docstring": "Strips values from the beginning and end of an iterable. Stripped items\nwill match the value of the argument strip_value. Functionality is\nanalogous to that of the method str.strip. Returns a generator.\n\n>>> list(strip_iter(['Fu', 'Foo', 'Bar', 'Bam', 'Fu'], 'Fu'))\n['Foo', 'Bar', 'Bam']"
  },
  {
    "function": "chunked",
    "code": "def chunked(src, size, count=None, **kw):\n    \"\"\"Returns a list of *count* chunks, each with *size* elements,\n    generated from iterable *src*. If *src* is not evenly divisible by\n    *size*, the final chunk will have fewer than *size* elements.\n    Provide the *fill* keyword argument to provide a pad value and\n    enable padding, otherwise no padding will take place.\n\n    >>> chunked(range(10), 3)\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n    >>> chunked(range(10), 3, fill=None)\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, None, None]]\n    >>> chunked(range(10), 3, count=2)\n    [[0, 1, 2], [3, 4, 5]]\n\n    See :func:`chunked_iter` for more info.\n    \"\"\"\n    chunk_iter = chunked_iter(src, size, **kw)\n    if count is None:\n        return list(chunk_iter)\n    else:\n        return list(itertools.islice(chunk_iter, count))",
    "docstring": "Returns a list of *count* chunks, each with *size* elements,\ngenerated from iterable *src*. If *src* is not evenly divisible by\n*size*, the final chunk will have fewer than *size* elements.\nProvide the *fill* keyword argument to provide a pad value and\nenable padding, otherwise no padding will take place.\n\n>>> chunked(range(10), 3)\n[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n>>> chunked(range(10), 3, fill=None)\n[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, None, None]]\n>>> chunked(range(10), 3, count=2)\n[[0, 1, 2], [3, 4, 5]]\n\nSee :func:`chunked_iter` for more info."
  },
  {
    "function": "chunked_iter",
    "code": "def chunked_iter(src, size, **kw):\n    \"\"\"Generates *size*-sized chunks from *src* iterable. Unless the\n    optional *fill* keyword argument is provided, iterables not evenly\n    divisible by *size* will have a final chunk that is smaller than\n    *size*.\n\n    >>> list(chunked_iter(range(10), 3))\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n    >>> list(chunked_iter(range(10), 3, fill=None))\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, None, None]]\n\n    Note that ``fill=None`` in fact uses ``None`` as the fill value.\n    \"\"\"\n    # TODO: add count kwarg?\n    if not is_iterable(src):\n        raise TypeError('expected an iterable')\n    size = _validate_positive_int(size, 'chunk size')\n    do_fill = True\n    try:\n        fill_val = kw.pop('fill')\n    except KeyError:\n        do_fill = False\n        fill_val = None\n    if kw:\n        raise ValueError('got unexpected keyword arguments: %r' % kw.keys())\n    if not src:\n        return\n\n    def postprocess(chk): return chk\n    if isinstance(src, (str, bytes)):\n        def postprocess(chk, _sep=type(src)()): return _sep.join(chk)\n        if isinstance(src, bytes):\n            def postprocess(chk): return bytes(chk)\n    src_iter = iter(src)\n    while True:\n        cur_chunk = list(itertools.islice(src_iter, size))\n        if not cur_chunk:\n            break\n        lc = len(cur_chunk)\n        if lc < size and do_fill:\n            cur_chunk[lc:] = [fill_val] * (size - lc)\n        yield postprocess(cur_chunk)\n    return",
    "docstring": "Generates *size*-sized chunks from *src* iterable. Unless the\noptional *fill* keyword argument is provided, iterables not evenly\ndivisible by *size* will have a final chunk that is smaller than\n*size*.\n\n>>> list(chunked_iter(range(10), 3))\n[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n>>> list(chunked_iter(range(10), 3, fill=None))\n[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, None, None]]\n\nNote that ``fill=None`` in fact uses ``None`` as the fill value."
  },
  {
    "function": "chunk_ranges",
    "code": "def chunk_ranges(input_size, chunk_size, input_offset=0, overlap_size=0, align=False):\n    \"\"\"Generates *chunk_size*-sized chunk ranges for an input with length *input_size*.\n    Optionally, a start of the input can be set via *input_offset*, and\n    and overlap between the chunks may be specified via *overlap_size*.\n    Also, if *align* is set to *True*, any items with *i % (chunk_size-overlap_size) == 0*\n    are always at the beginning of the chunk.\n\n    Returns an iterator of (start, end) tuples, one tuple per chunk.\n\n    >>> list(chunk_ranges(input_offset=10, input_size=10, chunk_size=5))\n    [(10, 15), (15, 20)]\n    >>> list(chunk_ranges(input_offset=10, input_size=10, chunk_size=5, overlap_size=1))\n    [(10, 15), (14, 19), (18, 20)]\n    >>> list(chunk_ranges(input_offset=10, input_size=10, chunk_size=5, overlap_size=2))\n    [(10, 15), (13, 18), (16, 20)]\n\n    >>> list(chunk_ranges(input_offset=4, input_size=15, chunk_size=5, align=False))\n    [(4, 9), (9, 14), (14, 19)]\n    >>> list(chunk_ranges(input_offset=4, input_size=15, chunk_size=5, align=True))\n    [(4, 5), (5, 10), (10, 15), (15, 19)]\n\n    >>> list(chunk_ranges(input_offset=2, input_size=15, chunk_size=5, overlap_size=1, align=False))\n    [(2, 7), (6, 11), (10, 15), (14, 17)]\n    >>> list(chunk_ranges(input_offset=2, input_size=15, chunk_size=5, overlap_size=1, align=True))\n    [(2, 5), (4, 9), (8, 13), (12, 17)]\n    >>> list(chunk_ranges(input_offset=3, input_size=15, chunk_size=5, overlap_size=1, align=True))\n    [(3, 5), (4, 9), (8, 13), (12, 17), (16, 18)]\n    \"\"\"\n    input_size = _validate_positive_int(\n        input_size, 'input_size', strictly_positive=False)\n    chunk_size = _validate_positive_int(chunk_size, 'chunk_size')\n    input_offset = _validate_positive_int(\n        input_offset, 'input_offset', strictly_positive=False)\n    overlap_size = _validate_positive_int(\n        overlap_size, 'overlap_size', strictly_positive=False)\n\n    input_stop = input_offset + input_size\n\n    if align:\n        initial_chunk_len = chunk_size - \\\n            input_offset % (chunk_size - overlap_size)\n        if initial_chunk_len != overlap_size:\n            yield (input_offset, min(input_offset + initial_chunk_len, input_stop))\n            if input_offset + initial_chunk_len >= input_stop:\n                return\n            input_offset = input_offset + initial_chunk_len - overlap_size\n\n    for i in range(input_offset, input_stop, chunk_size - overlap_size):\n        yield (i, min(i + chunk_size, input_stop))\n\n        if i + chunk_size >= input_stop:\n            return",
    "docstring": "Generates *chunk_size*-sized chunk ranges for an input with length *input_size*.\nOptionally, a start of the input can be set via *input_offset*, and\nand overlap between the chunks may be specified via *overlap_size*.\nAlso, if *align* is set to *True*, any items with *i % (chunk_size-overlap_size) == 0*\nare always at the beginning of the chunk.\n\nReturns an iterator of (start, end) tuples, one tuple per chunk.\n\n>>> list(chunk_ranges(input_offset=10, input_size=10, chunk_size=5))\n[(10, 15), (15, 20)]\n>>> list(chunk_ranges(input_offset=10, input_size=10, chunk_size=5, overlap_size=1))\n[(10, 15), (14, 19), (18, 20)]\n>>> list(chunk_ranges(input_offset=10, input_size=10, chunk_size=5, overlap_size=2))\n[(10, 15), (13, 18), (16, 20)]\n\n>>> list(chunk_ranges(input_offset=4, input_size=15, chunk_size=5, align=False))\n[(4, 9), (9, 14), (14, 19)]\n>>> list(chunk_ranges(input_offset=4, input_size=15, chunk_size=5, align=True))\n[(4, 5), (5, 10), (10, 15), (15, 19)]\n\n>>> list(chunk_ranges(input_offset=2, input_size=15, chunk_size=5, overlap_size=1, align=False))\n[(2, 7), (6, 11), (10, 15), (14, 17)]\n>>> list(chunk_ranges(input_offset=2, input_size=15, chunk_size=5, overlap_size=1, align=True))\n[(2, 5), (4, 9), (8, 13), (12, 17)]\n>>> list(chunk_ranges(input_offset=3, input_size=15, chunk_size=5, overlap_size=1, align=True))\n[(3, 5), (4, 9), (8, 13), (12, 17), (16, 18)]"
  },
  {
    "function": "pairwise",
    "code": "def pairwise(src, end=_UNSET):\n    \"\"\"Convenience function for calling :func:`windowed` on *src*, with\n    *size* set to 2.\n\n    >>> pairwise(range(5))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n    >>> pairwise([])\n    []\n\n    Unless *end* is set, the number of pairs is always one less than \n    the number of elements in the iterable passed in, except on an empty input, \n    which will return an empty list.\n\n    With *end* set, a number of pairs equal to the length of *src* is returned,\n    with the last item of the last pair being equal to *end*.\n\n    >>> list(pairwise(range(3), end=None))\n    [(0, 1), (1, 2), (2, None)]\n\n    This way, *end* values can be useful as sentinels to signal the end of the iterable.\n    \"\"\"\n    return windowed(src, 2, fill=end)",
    "docstring": "Convenience function for calling :func:`windowed` on *src*, with\n*size* set to 2.\n\n>>> pairwise(range(5))\n[(0, 1), (1, 2), (2, 3), (3, 4)]\n>>> pairwise([])\n[]\n\nUnless *end* is set, the number of pairs is always one less than \nthe number of elements in the iterable passed in, except on an empty input, \nwhich will return an empty list.\n\nWith *end* set, a number of pairs equal to the length of *src* is returned,\nwith the last item of the last pair being equal to *end*.\n\n>>> list(pairwise(range(3), end=None))\n[(0, 1), (1, 2), (2, None)]\n\nThis way, *end* values can be useful as sentinels to signal the end of the iterable."
  },
  {
    "function": "pairwise_iter",
    "code": "def pairwise_iter(src, end=_UNSET):\n    \"\"\"Convenience function for calling :func:`windowed_iter` on *src*,\n    with *size* set to 2.\n\n    >>> list(pairwise_iter(range(5)))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n    >>> list(pairwise_iter([]))\n    []\n\n    Unless *end* is set, the number of pairs is always one less \n    than the number of elements in the iterable passed in, \n    or zero, when *src* is empty.\n\n    With *end* set, a number of pairs equal to the length of *src* is returned,\n    with the last item of the last pair being equal to *end*. \n\n    >>> list(pairwise_iter(range(3), end=None))\n    [(0, 1), (1, 2), (2, None)]    \n\n    This way, *end* values can be useful as sentinels to signal the end\n    of the iterable. For infinite iterators, setting *end* has no effect.\n    \"\"\"\n    return windowed_iter(src, 2, fill=end)",
    "docstring": "Convenience function for calling :func:`windowed_iter` on *src*,\nwith *size* set to 2.\n\n>>> list(pairwise_iter(range(5)))\n[(0, 1), (1, 2), (2, 3), (3, 4)]\n>>> list(pairwise_iter([]))\n[]\n\nUnless *end* is set, the number of pairs is always one less \nthan the number of elements in the iterable passed in, \nor zero, when *src* is empty.\n\nWith *end* set, a number of pairs equal to the length of *src* is returned,\nwith the last item of the last pair being equal to *end*. \n\n>>> list(pairwise_iter(range(3), end=None))\n[(0, 1), (1, 2), (2, None)]    \n\nThis way, *end* values can be useful as sentinels to signal the end\nof the iterable. For infinite iterators, setting *end* has no effect."
  },
  {
    "function": "windowed",
    "code": "def windowed(src, size, fill=_UNSET):\n    \"\"\"Returns tuples with exactly length *size*. If *fill* is unset \n    and the iterable is too short to make a window of length *size*, \n    no tuples are returned. See :func:`windowed_iter` for more.\n    \"\"\"\n    return list(windowed_iter(src, size, fill=fill))",
    "docstring": "Returns tuples with exactly length *size*. If *fill* is unset \nand the iterable is too short to make a window of length *size*, \nno tuples are returned. See :func:`windowed_iter` for more."
  },
  {
    "function": "windowed_iter",
    "code": "def windowed_iter(src, size, fill=_UNSET):\n    \"\"\"Returns tuples with length *size* which represent a sliding\n    window over iterable *src*.\n\n    >>> list(windowed_iter(range(7), 3))\n    [(0, 1, 2), (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]\n\n    If *fill* is unset, and the iterable is too short to make a window \n    of length *size*, then no window tuples are returned.\n\n    >>> list(windowed_iter(range(3), 5))\n    []\n\n    With *fill* set, the iterator always yields a number of windows\n    equal to the length of the *src* iterable.\n\n    >>> windowed(range(4), 3, fill=None)\n    [(0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]\n\n    This way, *fill* values can be useful to signal the end of the iterable.\n    For infinite iterators, setting *fill* has no effect.\n    \"\"\"\n    tees = itertools.tee(src, size)\n    if fill is _UNSET:\n        try:\n            for i, t in enumerate(tees):\n                for _ in range(i):\n                    next(t)\n        except StopIteration:\n            return zip([])\n        return zip(*tees)\n\n    for i, t in enumerate(tees):\n        for _ in range(i):\n            try:\n                next(t)\n            except StopIteration:\n                continue\n    return zip_longest(*tees, fillvalue=fill)",
    "docstring": "Returns tuples with length *size* which represent a sliding\nwindow over iterable *src*.\n\n>>> list(windowed_iter(range(7), 3))\n[(0, 1, 2), (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]\n\nIf *fill* is unset, and the iterable is too short to make a window \nof length *size*, then no window tuples are returned.\n\n>>> list(windowed_iter(range(3), 5))\n[]\n\nWith *fill* set, the iterator always yields a number of windows\nequal to the length of the *src* iterable.\n\n>>> windowed(range(4), 3, fill=None)\n[(0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]\n\nThis way, *fill* values can be useful to signal the end of the iterable.\nFor infinite iterators, setting *fill* has no effect."
  },
  {
    "function": "xfrange",
    "code": "def xfrange(stop, start=None, step=1.0):\n    \"\"\"Same as :func:`frange`, but generator-based instead of returning a\n    list.\n\n    >>> tuple(xfrange(1, 3, step=0.75))\n    (1.0, 1.75, 2.5)\n\n    See :func:`frange` for more details.\n    \"\"\"\n    if not step:\n        raise ValueError('step must be non-zero')\n    if start is None:\n        start, stop = 0.0, stop * 1.0\n    else:\n        # swap when all args are used\n        stop, start = start * 1.0, stop * 1.0\n    cur = start\n    while cur < stop:\n        yield cur\n        cur += step",
    "docstring": "Same as :func:`frange`, but generator-based instead of returning a\nlist.\n\n>>> tuple(xfrange(1, 3, step=0.75))\n(1.0, 1.75, 2.5)\n\nSee :func:`frange` for more details."
  },
  {
    "function": "frange",
    "code": "def frange(stop, start=None, step=1.0):\n    \"\"\"A :func:`range` clone for float-based ranges.\n\n    >>> frange(5)\n    [0.0, 1.0, 2.0, 3.0, 4.0]\n    >>> frange(6, step=1.25)\n    [0.0, 1.25, 2.5, 3.75, 5.0]\n    >>> frange(100.5, 101.5, 0.25)\n    [100.5, 100.75, 101.0, 101.25]\n    >>> frange(5, 0)\n    []\n    >>> frange(5, 0, step=-1.25)\n    [5.0, 3.75, 2.5, 1.25]\n    \"\"\"\n    if not step:\n        raise ValueError('step must be non-zero')\n    if start is None:\n        start, stop = 0.0, stop * 1.0\n    else:\n        # swap when all args are used\n        stop, start = start * 1.0, stop * 1.0\n    count = int(math.ceil((stop - start) / step))\n    ret = [None] * count\n    if not ret:\n        return ret\n    ret[0] = start\n    for i in range(1, count):\n        ret[i] = ret[i - 1] + step\n    return ret",
    "docstring": "A :func:`range` clone for float-based ranges.\n\n>>> frange(5)\n[0.0, 1.0, 2.0, 3.0, 4.0]\n>>> frange(6, step=1.25)\n[0.0, 1.25, 2.5, 3.75, 5.0]\n>>> frange(100.5, 101.5, 0.25)\n[100.5, 100.75, 101.0, 101.25]\n>>> frange(5, 0)\n[]\n>>> frange(5, 0, step=-1.25)\n[5.0, 3.75, 2.5, 1.25]"
  },
  {
    "function": "backoff",
    "code": "def backoff(start, stop, count=None, factor=2.0, jitter=False):\n    \"\"\"Returns a list of geometrically-increasing floating-point numbers,\n    suitable for usage with `exponential backoff`_. Exactly like\n    :func:`backoff_iter`, but without the ``'repeat'`` option for\n    *count*. See :func:`backoff_iter` for more details.\n\n    .. _exponential backoff: https://en.wikipedia.org/wiki/Exponential_backoff\n\n    >>> backoff(1, 10)\n    [1.0, 2.0, 4.0, 8.0, 10.0]\n    \"\"\"\n    if count == 'repeat':\n        raise ValueError(\"'repeat' supported in backoff_iter, not backoff\")\n    return list(backoff_iter(start, stop, count=count,\n                             factor=factor, jitter=jitter))",
    "docstring": "Returns a list of geometrically-increasing floating-point numbers,\nsuitable for usage with `exponential backoff`_. Exactly like\n:func:`backoff_iter`, but without the ``'repeat'`` option for\n*count*. See :func:`backoff_iter` for more details.\n\n.. _exponential backoff: https://en.wikipedia.org/wiki/Exponential_backoff\n\n>>> backoff(1, 10)\n[1.0, 2.0, 4.0, 8.0, 10.0]"
  },
  {
    "function": "backoff_iter",
    "code": "def backoff_iter(start, stop, count=None, factor=2.0, jitter=False):\n    \"\"\"Generates a sequence of geometrically-increasing floats, suitable\n    for usage with `exponential backoff`_. Starts with *start*,\n    increasing by *factor* until *stop* is reached, optionally\n    stopping iteration once *count* numbers are yielded. *factor*\n    defaults to 2. In general retrying with properly-configured\n    backoff creates a better-behaved component for a larger service\n    ecosystem.\n\n    .. _exponential backoff: https://en.wikipedia.org/wiki/Exponential_backoff\n\n    >>> list(backoff_iter(1.0, 10.0, count=5))\n    [1.0, 2.0, 4.0, 8.0, 10.0]\n    >>> list(backoff_iter(1.0, 10.0, count=8))\n    [1.0, 2.0, 4.0, 8.0, 10.0, 10.0, 10.0, 10.0]\n    >>> list(backoff_iter(0.25, 100.0, factor=10))\n    [0.25, 2.5, 25.0, 100.0]\n\n    A simplified usage example:\n\n    .. code-block:: python\n\n      for timeout in backoff_iter(0.25, 5.0):\n          try:\n              res = network_call()\n              break\n          except Exception as e:\n              log(e)\n              time.sleep(timeout)\n\n    An enhancement for large-scale systems would be to add variation,\n    or *jitter*, to timeout values. This is done to avoid a thundering\n    herd on the receiving end of the network call.\n\n    Finally, for *count*, the special value ``'repeat'`` can be passed to\n    continue yielding indefinitely.\n\n    Args:\n\n        start (float): Positive number for baseline.\n        stop (float): Positive number for maximum.\n        count (int): Number of steps before stopping\n            iteration. Defaults to the number of steps between *start* and\n            *stop*. Pass the string, `'repeat'`, to continue iteration\n            indefinitely.\n        factor (float): Rate of exponential increase. Defaults to `2.0`,\n            e.g., `[1, 2, 4, 8, 16]`.\n        jitter (float): A factor between `-1.0` and `1.0`, used to\n            uniformly randomize and thus spread out timeouts in a distributed\n            system, avoiding rhythm effects. Positive values use the base\n            backoff curve as a maximum, negative values use the curve as a\n            minimum. Set to 1.0 or `True` for a jitter approximating\n            Ethernet's time-tested backoff solution. Defaults to `False`.\n\n    \"\"\"\n    start = float(start)\n    stop = float(stop)\n    factor = float(factor)\n    if start < 0.0:\n        raise ValueError('expected start >= 0, not %r' % start)\n    if factor < 1.0:\n        raise ValueError('expected factor >= 1.0, not %r' % factor)\n    if stop == 0.0:\n        raise ValueError('expected stop >= 0')\n    if stop < start:\n        raise ValueError('expected stop >= start, not %r' % stop)\n    if count is None:\n        denom = start if start else 1\n        count = 1 + math.ceil(math.log(stop/denom, factor))\n        count = count if start else count + 1\n    if count != 'repeat' and count < 0:\n        raise ValueError('count must be positive or \"repeat\", not %r' % count)\n    if jitter:\n        jitter = float(jitter)\n        if not (-1.0 <= jitter <= 1.0):\n            raise ValueError('expected jitter -1 <= j <= 1, not: %r' % jitter)\n\n    cur, i = start, 0\n    while count == 'repeat' or i < count:\n        if not jitter:\n            cur_ret = cur\n        elif jitter:\n            cur_ret = cur - (cur * jitter * random.random())\n        yield cur_ret\n        i += 1\n        if cur == 0:\n            cur = 1\n        elif cur < stop:\n            cur *= factor\n        if cur > stop:\n            cur = stop\n    return",
    "docstring": "Generates a sequence of geometrically-increasing floats, suitable\nfor usage with `exponential backoff`_. Starts with *start*,\nincreasing by *factor* until *stop* is reached, optionally\nstopping iteration once *count* numbers are yielded. *factor*\ndefaults to 2. In general retrying with properly-configured\nbackoff creates a better-behaved component for a larger service\necosystem.\n\n.. _exponential backoff: https://en.wikipedia.org/wiki/Exponential_backoff\n\n>>> list(backoff_iter(1.0, 10.0, count=5))\n[1.0, 2.0, 4.0, 8.0, 10.0]\n>>> list(backoff_iter(1.0, 10.0, count=8))\n[1.0, 2.0, 4.0, 8.0, 10.0, 10.0, 10.0, 10.0]\n>>> list(backoff_iter(0.25, 100.0, factor=10))\n[0.25, 2.5, 25.0, 100.0]\n\nA simplified usage example:\n\n.. code-block:: python\n\n  for timeout in backoff_iter(0.25, 5.0):\n      try:\n          res = network_call()\n          break\n      except Exception as e:\n          log(e)\n          time.sleep(timeout)\n\nAn enhancement for large-scale systems would be to add variation,\nor *jitter*, to timeout values. This is done to avoid a thundering\nherd on the receiving end of the network call.\n\nFinally, for *count*, the special value ``'repeat'`` can be passed to\ncontinue yielding indefinitely.\n\nArgs:\n\n    start (float): Positive number for baseline.\n    stop (float): Positive number for maximum.\n    count (int): Number of steps before stopping\n        iteration. Defaults to the number of steps between *start* and\n        *stop*. Pass the string, `'repeat'`, to continue iteration\n        indefinitely.\n    factor (float): Rate of exponential increase. Defaults to `2.0`,\n        e.g., `[1, 2, 4, 8, 16]`.\n    jitter (float): A factor between `-1.0` and `1.0`, used to\n        uniformly randomize and thus spread out timeouts in a distributed\n        system, avoiding rhythm effects. Positive values use the base\n        backoff curve as a maximum, negative values use the curve as a\n        minimum. Set to 1.0 or `True` for a jitter approximating\n        Ethernet's time-tested backoff solution. Defaults to `False`."
  },
  {
    "function": "bucketize",
    "code": "def bucketize(src, key=bool, value_transform=None, key_filter=None):\n    \"\"\"Group values in the *src* iterable by the value returned by *key*.\n\n    >>> bucketize(range(5))\n    {False: [0], True: [1, 2, 3, 4]}\n    >>> is_odd = lambda x: x % 2 == 1\n    >>> bucketize(range(5), is_odd)\n    {False: [0, 2, 4], True: [1, 3]}\n\n    *key* is :class:`bool` by default, but can either be a callable or a string or a list\n    if it is a string, it is the name of the attribute on which to bucketize objects.\n\n    >>> bucketize([1+1j, 2+2j, 1, 2], key='real')\n    {1.0: [(1+1j), 1], 2.0: [(2+2j), 2]}\n\n    if *key* is a list, it contains the buckets where to put each object\n\n    >>> bucketize([1,2,365,4,98],key=[0,1,2,0,2])\n    {0: [1, 4], 1: [2], 2: [365, 98]}\n\n\n    Value lists are not deduplicated:\n\n    >>> bucketize([None, None, None, 'hello'])\n    {False: [None, None, None], True: ['hello']}\n\n    Bucketize into more than 3 groups\n\n    >>> bucketize(range(10), lambda x: x % 3)\n    {0: [0, 3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8]}\n\n    ``bucketize`` has a couple of advanced options useful in certain\n    cases.  *value_transform* can be used to modify values as they are\n    added to buckets, and *key_filter* will allow excluding certain\n    buckets from being collected.\n\n    >>> bucketize(range(5), value_transform=lambda x: x*x)\n    {False: [0], True: [1, 4, 9, 16]}\n\n    >>> bucketize(range(10), key=lambda x: x % 3, key_filter=lambda k: k % 3 != 1)\n    {0: [0, 3, 6, 9], 2: [2, 5, 8]}\n\n    Note in some of these examples there were at most two keys, ``True`` and\n    ``False``, and each key present has a list with at least one\n    item. See :func:`partition` for a version specialized for binary\n    use cases.\n\n    \"\"\"\n    if not is_iterable(src):\n        raise TypeError('expected an iterable')\n    elif isinstance(key, list):\n        if len(key) != len(src):\n            raise ValueError(\"key and src have to be the same length\")\n        src = zip(key, src)\n\n    if isinstance(key, str):\n        def key_func(x): return getattr(x, key, x)\n    elif callable(key):\n        key_func = key\n    elif isinstance(key, list):\n        def key_func(x): return x[0]\n    else:\n        raise TypeError('expected key to be callable or a string or a list')\n\n    if value_transform is None:\n        def value_transform(x): return x\n    if not callable(value_transform):\n        raise TypeError('expected callable value transform function')\n    if isinstance(key, list):\n        f = value_transform\n        def value_transform(x): return f(x[1])\n\n    ret = {}\n    for val in src:\n        key_of_val = key_func(val)\n        if key_filter is None or key_filter(key_of_val):\n            ret.setdefault(key_of_val, []).append(value_transform(val))\n    return ret",
    "docstring": "Group values in the *src* iterable by the value returned by *key*.\n\n>>> bucketize(range(5))\n{False: [0], True: [1, 2, 3, 4]}\n>>> is_odd = lambda x: x % 2 == 1\n>>> bucketize(range(5), is_odd)\n{False: [0, 2, 4], True: [1, 3]}\n\n*key* is :class:`bool` by default, but can either be a callable or a string or a list\nif it is a string, it is the name of the attribute on which to bucketize objects.\n\n>>> bucketize([1+1j, 2+2j, 1, 2], key='real')\n{1.0: [(1+1j), 1], 2.0: [(2+2j), 2]}\n\nif *key* is a list, it contains the buckets where to put each object\n\n>>> bucketize([1,2,365,4,98],key=[0,1,2,0,2])\n{0: [1, 4], 1: [2], 2: [365, 98]}\n\n\nValue lists are not deduplicated:\n\n>>> bucketize([None, None, None, 'hello'])\n{False: [None, None, None], True: ['hello']}\n\nBucketize into more than 3 groups\n\n>>> bucketize(range(10), lambda x: x % 3)\n{0: [0, 3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8]}\n\n``bucketize`` has a couple of advanced options useful in certain\ncases.  *value_transform* can be used to modify values as they are\nadded to buckets, and *key_filter* will allow excluding certain\nbuckets from being collected.\n\n>>> bucketize(range(5), value_transform=lambda x: x*x)\n{False: [0], True: [1, 4, 9, 16]}\n\n>>> bucketize(range(10), key=lambda x: x % 3, key_filter=lambda k: k % 3 != 1)\n{0: [0, 3, 6, 9], 2: [2, 5, 8]}\n\nNote in some of these examples there were at most two keys, ``True`` and\n``False``, and each key present has a list with at least one\nitem. See :func:`partition` for a version specialized for binary\nuse cases."
  },
  {
    "function": "partition",
    "code": "def partition(src, key=bool):\n    \"\"\"No relation to :meth:`str.partition`, ``partition`` is like\n    :func:`bucketize`, but for added convenience returns a tuple of\n    ``(truthy_values, falsy_values)``.\n\n    >>> nonempty, empty = partition(['', '', 'hi', '', 'bye'])\n    >>> nonempty\n    ['hi', 'bye']\n\n    *key* defaults to :class:`bool`, but can be carefully overridden to\n    use either a function that returns either ``True`` or ``False`` or\n    a string name of the attribute on which to partition objects.\n\n    >>> import string\n    >>> is_digit = lambda x: x in string.digits\n    >>> decimal_digits, hexletters = partition(string.hexdigits, is_digit)\n    >>> ''.join(decimal_digits), ''.join(hexletters)\n    ('0123456789', 'abcdefABCDEF')\n    \"\"\"\n    bucketized = bucketize(src, key)\n    return bucketized.get(True, []), bucketized.get(False, [])",
    "docstring": "No relation to :meth:`str.partition`, ``partition`` is like\n:func:`bucketize`, but for added convenience returns a tuple of\n``(truthy_values, falsy_values)``.\n\n>>> nonempty, empty = partition(['', '', 'hi', '', 'bye'])\n>>> nonempty\n['hi', 'bye']\n\n*key* defaults to :class:`bool`, but can be carefully overridden to\nuse either a function that returns either ``True`` or ``False`` or\na string name of the attribute on which to partition objects.\n\n>>> import string\n>>> is_digit = lambda x: x in string.digits\n>>> decimal_digits, hexletters = partition(string.hexdigits, is_digit)\n>>> ''.join(decimal_digits), ''.join(hexletters)\n('0123456789', 'abcdefABCDEF')"
  },
  {
    "function": "unique",
    "code": "def unique(src, key=None):\n    \"\"\"``unique()`` returns a list of unique values, as determined by\n    *key*, in the order they first appeared in the input iterable,\n    *src*.\n\n    >>> ones_n_zeros = '11010110001010010101010'\n    >>> ''.join(unique(ones_n_zeros))\n    '10'\n\n    See :func:`unique_iter` docs for more details.\n    \"\"\"\n    return list(unique_iter(src, key))",
    "docstring": "``unique()`` returns a list of unique values, as determined by\n*key*, in the order they first appeared in the input iterable,\n*src*.\n\n>>> ones_n_zeros = '11010110001010010101010'\n>>> ''.join(unique(ones_n_zeros))\n'10'\n\nSee :func:`unique_iter` docs for more details."
  },
  {
    "function": "unique_iter",
    "code": "def unique_iter(src, key=None):\n    \"\"\"Yield unique elements from the iterable, *src*, based on *key*,\n    in the order in which they first appeared in *src*.\n\n    >>> repetitious = [1, 2, 3] * 10\n    >>> list(unique_iter(repetitious))\n    [1, 2, 3]\n\n    By default, *key* is the object itself, but *key* can either be a\n    callable or, for convenience, a string name of the attribute on\n    which to uniqueify objects, falling back on identity when the\n    attribute is not present.\n\n    >>> pleasantries = ['hi', 'hello', 'ok', 'bye', 'yes']\n    >>> list(unique_iter(pleasantries, key=lambda x: len(x)))\n    ['hi', 'hello', 'bye']\n    \"\"\"\n    if not is_iterable(src):\n        raise TypeError('expected an iterable, not %r' % type(src))\n    if key is None:\n        def key_func(x): return x\n    elif callable(key):\n        key_func = key\n    elif isinstance(key, str):\n        def key_func(x): return getattr(x, key, x)\n    else:\n        raise TypeError('\"key\" expected a string or callable, not %r' % key)\n    seen = set()\n    for i in src:\n        k = key_func(i)\n        if k not in seen:\n            seen.add(k)\n            yield i\n    return",
    "docstring": "Yield unique elements from the iterable, *src*, based on *key*,\nin the order in which they first appeared in *src*.\n\n>>> repetitious = [1, 2, 3] * 10\n>>> list(unique_iter(repetitious))\n[1, 2, 3]\n\nBy default, *key* is the object itself, but *key* can either be a\ncallable or, for convenience, a string name of the attribute on\nwhich to uniqueify objects, falling back on identity when the\nattribute is not present.\n\n>>> pleasantries = ['hi', 'hello', 'ok', 'bye', 'yes']\n>>> list(unique_iter(pleasantries, key=lambda x: len(x)))\n['hi', 'hello', 'bye']"
  },
  {
    "function": "redundant",
    "code": "def redundant(src, key=None, groups=False):\n    \"\"\"The complement of :func:`unique()`.\n\n    By default returns non-unique/duplicate values as a list of the\n    *first* redundant value in *src*. Pass ``groups=True`` to get\n    groups of all values with redundancies, ordered by position of the\n    first redundant value. This is useful in conjunction with some\n    normalizing *key* function.\n\n    >>> redundant([1, 2, 3, 4])\n    []\n    >>> redundant([1, 2, 3, 2, 3, 3, 4])\n    [2, 3]\n    >>> redundant([1, 2, 3, 2, 3, 3, 4], groups=True)\n    [[2, 2], [3, 3, 3]]\n\n    An example using a *key* function to do case-insensitive\n    redundancy detection.\n\n    >>> redundant(['hi', 'Hi', 'HI', 'hello'], key=str.lower)\n    ['Hi']\n    >>> redundant(['hi', 'Hi', 'HI', 'hello'], groups=True, key=str.lower)\n    [['hi', 'Hi', 'HI']]\n\n    *key* should also be used when the values in *src* are not hashable.\n\n    .. note::\n\n       This output of this function is designed for reporting\n       duplicates in contexts when a unique input is desired. Due to\n       the grouped return type, there is no streaming equivalent of\n       this function for the time being.\n\n    \"\"\"\n    if key is None:\n        pass\n    elif callable(key):\n        key_func = key\n    elif isinstance(key, (str, bytes)):\n        def key_func(x): return getattr(x, key, x)\n    else:\n        raise TypeError('\"key\" expected a string or callable, not %r' % key)\n    seen = {}  # key to first seen item\n    redundant_order = []\n    redundant_groups = {}\n    for i in src:\n        k = key_func(i) if key else i\n        if k not in seen:\n            seen[k] = i\n        else:\n            if k in redundant_groups:\n                if groups:\n                    redundant_groups[k].append(i)\n            else:\n                redundant_order.append(k)\n                redundant_groups[k] = [seen[k], i]\n    if not groups:\n        ret = [redundant_groups[k][1] for k in redundant_order]\n    else:\n        ret = [redundant_groups[k] for k in redundant_order]\n    return ret",
    "docstring": "The complement of :func:`unique()`.\n\nBy default returns non-unique/duplicate values as a list of the\n*first* redundant value in *src*. Pass ``groups=True`` to get\ngroups of all values with redundancies, ordered by position of the\nfirst redundant value. This is useful in conjunction with some\nnormalizing *key* function.\n\n>>> redundant([1, 2, 3, 4])\n[]\n>>> redundant([1, 2, 3, 2, 3, 3, 4])\n[2, 3]\n>>> redundant([1, 2, 3, 2, 3, 3, 4], groups=True)\n[[2, 2], [3, 3, 3]]\n\nAn example using a *key* function to do case-insensitive\nredundancy detection.\n\n>>> redundant(['hi', 'Hi', 'HI', 'hello'], key=str.lower)\n['Hi']\n>>> redundant(['hi', 'Hi', 'HI', 'hello'], groups=True, key=str.lower)\n[['hi', 'Hi', 'HI']]\n\n*key* should also be used when the values in *src* are not hashable.\n\n.. note::\n\n   This output of this function is designed for reporting\n   duplicates in contexts when a unique input is desired. Due to\n   the grouped return type, there is no streaming equivalent of\n   this function for the time being."
  },
  {
    "function": "one",
    "code": "def one(src, default=None, key=None):\n    \"\"\"Along the same lines as builtins, :func:`all` and :func:`any`, and\n    similar to :func:`first`, ``one()`` returns the single object in\n    the given iterable *src* that evaluates to ``True``, as determined\n    by callable *key*. If unset, *key* defaults to :class:`bool`. If\n    no such objects are found, *default* is returned. If *default* is\n    not passed, ``None`` is returned.\n\n    If *src* has more than one object that evaluates to ``True``, or\n    if there is no object that fulfills such condition, return\n    *default*. It's like an `XOR`_ over an iterable.\n\n    >>> one((True, False, False))\n    True\n    >>> one((True, False, True))\n    >>> one((0, 0, 'a'))\n    'a'\n    >>> one((0, False, None))\n    >>> one((True, True), default=False)\n    False\n    >>> bool(one(('', 1)))\n    True\n    >>> one((10, 20, 30, 42), key=lambda i: i > 40)\n    42\n\n    See `Mart\u00edn Gait\u00e1n's original repo`_ for further use cases.\n\n    .. _Mart\u00edn Gait\u00e1n's original repo: https://github.com/mgaitan/one\n    .. _XOR: https://en.wikipedia.org/wiki/Exclusive_or\n\n    \"\"\"\n    ones = list(itertools.islice(filter(key, src), 2))\n    return ones[0] if len(ones) == 1 else default",
    "docstring": "Along the same lines as builtins, :func:`all` and :func:`any`, and\nsimilar to :func:`first`, ``one()`` returns the single object in\nthe given iterable *src* that evaluates to ``True``, as determined\nby callable *key*. If unset, *key* defaults to :class:`bool`. If\nno such objects are found, *default* is returned. If *default* is\nnot passed, ``None`` is returned.\n\nIf *src* has more than one object that evaluates to ``True``, or\nif there is no object that fulfills such condition, return\n*default*. It's like an `XOR`_ over an iterable.\n\n>>> one((True, False, False))\nTrue\n>>> one((True, False, True))\n>>> one((0, 0, 'a'))\n'a'\n>>> one((0, False, None))\n>>> one((True, True), default=False)\nFalse\n>>> bool(one(('', 1)))\nTrue\n>>> one((10, 20, 30, 42), key=lambda i: i > 40)\n42\n\nSee `Mart\u00edn Gait\u00e1n's original repo`_ for further use cases.\n\n.. _Mart\u00edn Gait\u00e1n's original repo: https://github.com/mgaitan/one\n.. _XOR: https://en.wikipedia.org/wiki/Exclusive_or"
  },
  {
    "function": "first",
    "code": "def first(iterable, default=None, key=None):\n    \"\"\"Return first element of *iterable* that evaluates to ``True``, else\n    return ``None`` or optional *default*. Similar to :func:`one`.\n\n    >>> first([0, False, None, [], (), 42])\n    42\n    >>> first([0, False, None, [], ()]) is None\n    True\n    >>> first([0, False, None, [], ()], default='ohai')\n    'ohai'\n    >>> import re\n    >>> m = first(re.match(regex, 'abc') for regex in ['b.*', 'a(.*)'])\n    >>> m.group(1)\n    'bc'\n\n    The optional *key* argument specifies a one-argument predicate function\n    like that used for *filter()*.  The *key* argument, if supplied, should be\n    in keyword form. For example, finding the first even number in an iterable:\n\n    >>> first([1, 1, 3, 4, 5], key=lambda x: x % 2 == 0)\n    4\n\n    Contributed by Hynek Schlawack, author of `the original standalone module`_.\n\n    .. _the original standalone module: https://github.com/hynek/first\n    \"\"\"\n    return next(filter(key, iterable), default)",
    "docstring": "Return first element of *iterable* that evaluates to ``True``, else\nreturn ``None`` or optional *default*. Similar to :func:`one`.\n\n>>> first([0, False, None, [], (), 42])\n42\n>>> first([0, False, None, [], ()]) is None\nTrue\n>>> first([0, False, None, [], ()], default='ohai')\n'ohai'\n>>> import re\n>>> m = first(re.match(regex, 'abc') for regex in ['b.*', 'a(.*)'])\n>>> m.group(1)\n'bc'\n\nThe optional *key* argument specifies a one-argument predicate function\nlike that used for *filter()*.  The *key* argument, if supplied, should be\nin keyword form. For example, finding the first even number in an iterable:\n\n>>> first([1, 1, 3, 4, 5], key=lambda x: x % 2 == 0)\n4\n\nContributed by Hynek Schlawack, author of `the original standalone module`_.\n\n.. _the original standalone module: https://github.com/hynek/first"
  },
  {
    "function": "flatten_iter",
    "code": "def flatten_iter(iterable):\n    \"\"\"``flatten_iter()`` yields all the elements from *iterable* while\n    collapsing any nested iterables.\n\n    >>> nested = [[1, 2], [[3], [4, 5]]]\n    >>> list(flatten_iter(nested))\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    for item in iterable:\n        if isinstance(item, Iterable) and not isinstance(item, (str, bytes)):\n            yield from flatten_iter(item)\n        else:\n            yield item",
    "docstring": "``flatten_iter()`` yields all the elements from *iterable* while\ncollapsing any nested iterables.\n\n>>> nested = [[1, 2], [[3], [4, 5]]]\n>>> list(flatten_iter(nested))\n[1, 2, 3, 4, 5]"
  },
  {
    "function": "flatten",
    "code": "def flatten(iterable):\n    \"\"\"``flatten()`` returns a collapsed list of all the elements from\n    *iterable* while collapsing any nested iterables.\n\n    >>> nested = [[1, 2], [[3], [4, 5]]]\n    >>> flatten(nested)\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    return list(flatten_iter(iterable))",
    "docstring": "``flatten()`` returns a collapsed list of all the elements from\n*iterable* while collapsing any nested iterables.\n\n>>> nested = [[1, 2], [[3], [4, 5]]]\n>>> flatten(nested)\n[1, 2, 3, 4, 5]"
  },
  {
    "function": "same",
    "code": "def same(iterable, ref=_UNSET):\n    \"\"\"``same()`` returns ``True`` when all values in *iterable* are\n    equal to one another, or optionally a reference value,\n    *ref*. Similar to :func:`all` and :func:`any` in that it evaluates\n    an iterable and returns a :class:`bool`. ``same()`` returns\n    ``True`` for empty iterables.\n\n    >>> same([])\n    True\n    >>> same([1])\n    True\n    >>> same(['a', 'a', 'a'])\n    True\n    >>> same(range(20))\n    False\n    >>> same([[], []])\n    True\n    >>> same([[], []], ref='test')\n    False\n\n    \"\"\"\n    iterator = iter(iterable)\n    if ref is _UNSET:\n        ref = next(iterator, ref)\n    return all(val == ref for val in iterator)",
    "docstring": "``same()`` returns ``True`` when all values in *iterable* are\nequal to one another, or optionally a reference value,\n*ref*. Similar to :func:`all` and :func:`any` in that it evaluates\nan iterable and returns a :class:`bool`. ``same()`` returns\n``True`` for empty iterables.\n\n>>> same([])\nTrue\n>>> same([1])\nTrue\n>>> same(['a', 'a', 'a'])\nTrue\n>>> same(range(20))\nFalse\n>>> same([[], []])\nTrue\n>>> same([[], []], ref='test')\nFalse"
  },
  {
    "function": "remap",
    "code": "def remap(root, visit=default_visit, enter=default_enter, exit=default_exit,\n          **kwargs):\n    \"\"\"The remap (\"recursive map\") function is used to traverse and\n    transform nested structures. Lists, tuples, sets, and dictionaries\n    are just a few of the data structures nested into heterogeneous\n    tree-like structures that are so common in programming.\n    Unfortunately, Python's built-in ways to manipulate collections\n    are almost all flat. List comprehensions may be fast and succinct,\n    but they do not recurse, making it tedious to apply quick changes\n    or complex transforms to real-world data.\n\n    remap goes where list comprehensions cannot.\n\n    Here's an example of removing all Nones from some data:\n\n    >>> from pprint import pprint\n    >>> reviews = {'Star Trek': {'TNG': 10, 'DS9': 8.5, 'ENT': None},\n    ...            'Babylon 5': 6, 'Dr. Who': None}\n    >>> pprint(remap(reviews, lambda p, k, v: v is not None))\n    {'Babylon 5': 6, 'Star Trek': {'DS9': 8.5, 'TNG': 10}}\n\n    Notice how both Nones have been removed despite the nesting in the\n    dictionary. Not bad for a one-liner, and that's just the beginning.\n    See `this remap cookbook`_ for more delicious recipes.\n\n    .. _this remap cookbook: http://sedimental.org/remap.html\n\n    remap takes four main arguments: the object to traverse and three\n    optional callables which determine how the remapped object will be\n    created.\n\n    Args:\n\n        root: The target object to traverse. By default, remap\n            supports iterables like :class:`list`, :class:`tuple`,\n            :class:`dict`, and :class:`set`, but any object traversable by\n            *enter* will work.\n        visit (callable): This function is called on every item in\n            *root*. It must accept three positional arguments, *path*,\n            *key*, and *value*. *path* is simply a tuple of parents'\n            keys. *visit* should return the new key-value pair. It may\n            also return ``True`` as shorthand to keep the old item\n            unmodified, or ``False`` to drop the item from the new\n            structure. *visit* is called after *enter*, on the new parent.\n\n            The *visit* function is called for every item in root,\n            including duplicate items. For traversable values, it is\n            called on the new parent object, after all its children\n            have been visited. The default visit behavior simply\n            returns the key-value pair unmodified.\n        enter (callable): This function controls which items in *root*\n            are traversed. It accepts the same arguments as *visit*: the\n            path, the key, and the value of the current item. It returns a\n            pair of the blank new parent, and an iterator over the items\n            which should be visited. If ``False`` is returned instead of\n            an iterator, the value will not be traversed.\n\n            The *enter* function is only called once per unique value. The\n            default enter behavior support mappings, sequences, and\n            sets. Strings and all other iterables will not be traversed.\n        exit (callable): This function determines how to handle items\n            once they have been visited. It gets the same three\n            arguments as the other functions -- *path*, *key*, *value*\n            -- plus two more: the blank new parent object returned\n            from *enter*, and a list of the new items, as remapped by\n            *visit*.\n\n            Like *enter*, the *exit* function is only called once per\n            unique value. The default exit behavior is to simply add\n            all new items to the new parent, e.g., using\n            :meth:`list.extend` and :meth:`dict.update` to add to the\n            new parent. Immutable objects, such as a :class:`tuple` or\n            :class:`namedtuple`, must be recreated from scratch, but\n            use the same type as the new parent passed back from the\n            *enter* function.\n        reraise_visit (bool): A pragmatic convenience for the *visit*\n            callable. When set to ``False``, remap ignores any errors\n            raised by the *visit* callback. Items causing exceptions\n            are kept. See examples for more details.\n        trace (bool): Pass ``trace=True`` to print out the entire\n            traversal. Or pass a tuple of ``'visit'``, ``'enter'``,\n            or ``'exit'`` to print only the selected events.\n\n    remap is designed to cover the majority of cases with just the\n    *visit* callable. While passing in multiple callables is very\n    empowering, remap is designed so very few cases should require\n    passing more than one function.\n\n    When passing *enter* and *exit*, it's common and easiest to build\n    on the default behavior. Simply add ``from boltons.iterutils import\n    default_enter`` (or ``default_exit``), and have your enter/exit\n    function call the default behavior before or after your custom\n    logic. See `this example`_.\n\n    Duplicate and self-referential objects (aka reference loops) are\n    automatically handled internally, `as shown here`_.\n\n    .. _this example: http://sedimental.org/remap.html#sort_all_lists\n    .. _as shown here: http://sedimental.org/remap.html#corner_cases\n\n    \"\"\"\n    # TODO: improve argument formatting in sphinx doc\n    # TODO: enter() return (False, items) to continue traverse but cancel copy?\n    if not callable(visit):\n        raise TypeError('visit expected callable, not: %r' % visit)\n    if not callable(enter):\n        raise TypeError('enter expected callable, not: %r' % enter)\n    if not callable(exit):\n        raise TypeError('exit expected callable, not: %r' % exit)\n    reraise_visit = kwargs.pop('reraise_visit', True)\n    trace = kwargs.pop('trace', ())\n    if trace is True:\n        trace = ('visit', 'enter', 'exit')\n    elif isinstance(trace, str):\n        trace = (trace,)\n    if not isinstance(trace, (tuple, list, set)):\n        raise TypeError('trace expected tuple of event names, not: %r' % trace)\n    trace_enter, trace_exit, trace_visit = 'enter' in trace, 'exit' in trace, 'visit' in trace\n\n    if kwargs:\n        raise TypeError('unexpected keyword arguments: %r' % kwargs.keys())\n\n    path, registry, stack = (), {}, [(None, root)]\n    new_items_stack = []\n    while stack:\n        key, value = stack.pop()\n        id_value = id(value)\n        if key is _REMAP_EXIT:\n            key, new_parent, old_parent = value\n            id_value = id(old_parent)\n            path, new_items = new_items_stack.pop()\n            if trace_exit:\n                print(' .. remap exit:', path, '-', key, '-',\n                      old_parent, '-', new_parent, '-', new_items)\n            value = exit(path, key, old_parent, new_parent, new_items)\n            if trace_exit:\n                print(' .. remap exit result:', value)\n            registry[id_value] = value\n            if not new_items_stack:\n                continue\n        elif id_value in registry:\n            value = registry[id_value]\n        else:\n            if trace_enter:\n                print(' .. remap enter:', path, '-', key, '-', value)\n            res = enter(path, key, value)\n            if trace_enter:\n                print(' .. remap enter result:', res)\n            try:\n                new_parent, new_items = res\n            except TypeError:\n                # TODO: handle False?\n                raise TypeError('enter should return a tuple of (new_parent,'\n                                ' items_iterator), not: %r' % res)\n            if new_items is not False:\n                # traverse unless False is explicitly passed\n                registry[id_value] = new_parent\n                new_items_stack.append((path, []))\n                if value is not root:\n                    path += (key,)\n                stack.append((_REMAP_EXIT, (key, new_parent, value)))\n                if new_items:\n                    stack.extend(reversed(list(new_items)))\n                if trace_enter:\n                    print(' .. remap stack size now:', len(stack))\n                continue\n        if visit is _orig_default_visit:\n            # avoid function call overhead by inlining identity operation\n            visited_item = (key, value)\n        else:\n            try:\n                if trace_visit:\n                    print(' .. remap visit:', path, '-', key, '-', value)\n                visited_item = visit(path, key, value)\n            except Exception:\n                if reraise_visit:\n                    raise\n                visited_item = True\n            if visited_item is False:\n                if trace_visit:\n                    print(' .. remap visit result: <drop>')\n                continue  # drop\n            elif visited_item is True:\n                visited_item = (key, value)\n            if trace_visit:\n                print(' .. remap visit result:', visited_item)\n            # TODO: typecheck?\n            #    raise TypeError('expected (key, value) from visit(),'\n            #                    ' not: %r' % visited_item)\n        try:\n            new_items_stack[-1][1].append(visited_item)\n        except IndexError:\n            raise TypeError('expected remappable root, not: %r' % root)\n    return value",
    "docstring": "The remap (\"recursive map\") function is used to traverse and\ntransform nested structures. Lists, tuples, sets, and dictionaries\nare just a few of the data structures nested into heterogeneous\ntree-like structures that are so common in programming.\nUnfortunately, Python's built-in ways to manipulate collections\nare almost all flat. List comprehensions may be fast and succinct,\nbut they do not recurse, making it tedious to apply quick changes\nor complex transforms to real-world data.\n\nremap goes where list comprehensions cannot.\n\nHere's an example of removing all Nones from some data:\n\n>>> from pprint import pprint\n>>> reviews = {'Star Trek': {'TNG': 10, 'DS9': 8.5, 'ENT': None},\n...            'Babylon 5': 6, 'Dr. Who': None}\n>>> pprint(remap(reviews, lambda p, k, v: v is not None))\n{'Babylon 5': 6, 'Star Trek': {'DS9': 8.5, 'TNG': 10}}\n\nNotice how both Nones have been removed despite the nesting in the\ndictionary. Not bad for a one-liner, and that's just the beginning.\nSee `this remap cookbook`_ for more delicious recipes.\n\n.. _this remap cookbook: http://sedimental.org/remap.html\n\nremap takes four main arguments: the object to traverse and three\noptional callables which determine how the remapped object will be\ncreated.\n\nArgs:\n\n    root: The target object to traverse. By default, remap\n        supports iterables like :class:`list`, :class:`tuple`,\n        :class:`dict`, and :class:`set`, but any object traversable by\n        *enter* will work.\n    visit (callable): This function is called on every item in\n        *root*. It must accept three positional arguments, *path*,\n        *key*, and *value*. *path* is simply a tuple of parents'\n        keys. *visit* should return the new key-value pair. It may\n        also return ``True`` as shorthand to keep the old item\n        unmodified, or ``False`` to drop the item from the new\n        structure. *visit* is called after *enter*, on the new parent.\n\n        The *visit* function is called for every item in root,\n        including duplicate items. For traversable values, it is\n        called on the new parent object, after all its children\n        have been visited. The default visit behavior simply\n        returns the key-value pair unmodified.\n    enter (callable): This function controls which items in *root*\n        are traversed. It accepts the same arguments as *visit*: the\n        path, the key, and the value of the current item. It returns a\n        pair of the blank new parent, and an iterator over the items\n        which should be visited. If ``False`` is returned instead of\n        an iterator, the value will not be traversed.\n\n        The *enter* function is only called once per unique value. The\n        default enter behavior support mappings, sequences, and\n        sets. Strings and all other iterables will not be traversed.\n    exit (callable): This function determines how to handle items\n        once they have been visited. It gets the same three\n        arguments as the other functions -- *path*, *key*, *value*\n        -- plus two more: the blank new parent object returned\n        from *enter*, and a list of the new items, as remapped by\n        *visit*.\n\n        Like *enter*, the *exit* function is only called once per\n        unique value. The default exit behavior is to simply add\n        all new items to the new parent, e.g., using\n        :meth:`list.extend` and :meth:`dict.update` to add to the\n        new parent. Immutable objects, such as a :class:`tuple` or\n        :class:`namedtuple`, must be recreated from scratch, but\n        use the same type as the new parent passed back from the\n        *enter* function.\n    reraise_visit (bool): A pragmatic convenience for the *visit*\n        callable. When set to ``False``, remap ignores any errors\n        raised by the *visit* callback. Items causing exceptions\n        are kept. See examples for more details.\n    trace (bool): Pass ``trace=True`` to print out the entire\n        traversal. Or pass a tuple of ``'visit'``, ``'enter'``,\n        or ``'exit'`` to print only the selected events.\n\nremap is designed to cover the majority of cases with just the\n*visit* callable. While passing in multiple callables is very\nempowering, remap is designed so very few cases should require\npassing more than one function.\n\nWhen passing *enter* and *exit*, it's common and easiest to build\non the default behavior. Simply add ``from boltons.iterutils import\ndefault_enter`` (or ``default_exit``), and have your enter/exit\nfunction call the default behavior before or after your custom\nlogic. See `this example`_.\n\nDuplicate and self-referential objects (aka reference loops) are\nautomatically handled internally, `as shown here`_.\n\n.. _this example: http://sedimental.org/remap.html#sort_all_lists\n.. _as shown here: http://sedimental.org/remap.html#corner_cases"
  },
  {
    "function": "get_path",
    "code": "def get_path(root, path, default=_UNSET):\n    \"\"\"Retrieve a value from a nested object via a tuple representing the\n    lookup path.\n\n    >>> root = {'a': {'b': {'c': [[1], [2], [3]]}}}\n    >>> get_path(root, ('a', 'b', 'c', 2, 0))\n    3\n\n    The path tuple format is intentionally consistent with that of\n    :func:`remap`, but a single dotted string can also be passed.\n\n    One of get_path's chief aims is improved error messaging. EAFP is\n    great, but the error messages are not.\n\n    For instance, ``root['a']['b']['c'][2][1]`` gives back\n    ``IndexError: list index out of range``\n\n    What went out of range where? get_path currently raises\n    ``PathAccessError: could not access 2 from path ('a', 'b', 'c', 2,\n    1), got error: IndexError('list index out of range',)``, a\n    subclass of IndexError and KeyError.\n\n    You can also pass a default that covers the entire operation,\n    should the lookup fail at any level.\n\n    Args:\n       root: The target nesting of dictionaries, lists, or other\n          objects supporting ``__getitem__``.\n       path (tuple): A sequence of strings and integers to be successively\n          looked up within *root*. A dot-separated (``a.b``) string may \n          also be passed.\n       default: The value to be returned should any\n          ``PathAccessError`` exceptions be raised.\n    \"\"\"\n    if isinstance(path, str):\n        path = path.split('.')\n    cur = root\n    try:\n        for seg in path:\n            try:\n                cur = cur[seg]\n            except (KeyError, IndexError) as exc:\n                raise PathAccessError(exc, seg, path)\n            except TypeError as exc:\n                # either string index in a list, or a parent that\n                # doesn't support indexing\n                try:\n                    seg = int(seg)\n                    cur = cur[seg]\n                except (ValueError, KeyError, IndexError, TypeError):\n                    if not is_iterable(cur):\n                        exc = TypeError('%r object is not indexable'\n                                        % type(cur).__name__)\n                    raise PathAccessError(exc, seg, path)\n    except PathAccessError:\n        if default is _UNSET:\n            raise\n        return default\n    return cur",
    "docstring": "Retrieve a value from a nested object via a tuple representing the\nlookup path.\n\n>>> root = {'a': {'b': {'c': [[1], [2], [3]]}}}\n>>> get_path(root, ('a', 'b', 'c', 2, 0))\n3\n\nThe path tuple format is intentionally consistent with that of\n:func:`remap`, but a single dotted string can also be passed.\n\nOne of get_path's chief aims is improved error messaging. EAFP is\ngreat, but the error messages are not.\n\nFor instance, ``root['a']['b']['c'][2][1]`` gives back\n``IndexError: list index out of range``\n\nWhat went out of range where? get_path currently raises\n``PathAccessError: could not access 2 from path ('a', 'b', 'c', 2,\n1), got error: IndexError('list index out of range',)``, a\nsubclass of IndexError and KeyError.\n\nYou can also pass a default that covers the entire operation,\nshould the lookup fail at any level.\n\nArgs:\n   root: The target nesting of dictionaries, lists, or other\n      objects supporting ``__getitem__``.\n   path (tuple): A sequence of strings and integers to be successively\n      looked up within *root*. A dot-separated (``a.b``) string may \n      also be passed.\n   default: The value to be returned should any\n      ``PathAccessError`` exceptions be raised."
  },
  {
    "function": "research",
    "code": "def research(root, query=lambda p, k, v: True, reraise=False, enter=default_enter):\n    \"\"\"The :func:`research` function uses :func:`remap` to recurse over\n    any data nested in *root*, and find values which match a given\n    criterion, specified by the *query* callable.\n\n    Results are returned as a list of ``(path, value)`` pairs. The\n    paths are tuples in the same format accepted by\n    :func:`get_path`. This can be useful for comparing values nested\n    in two or more different structures.\n\n    Here's a simple example that finds all integers:\n\n    >>> root = {'a': {'b': 1, 'c': (2, 'd', 3)}, 'e': None}\n    >>> res = research(root, query=lambda p, k, v: isinstance(v, int))\n    >>> print(sorted(res))\n    [(('a', 'b'), 1), (('a', 'c', 0), 2), (('a', 'c', 2), 3)]\n\n    Note how *query* follows the same, familiar ``path, key, value``\n    signature as the ``visit`` and ``enter`` functions on\n    :func:`remap`, and returns a :class:`bool`.\n\n    Args:\n       root: The target object to search. Supports the same types of\n          objects as :func:`remap`, including :class:`list`,\n          :class:`tuple`, :class:`dict`, and :class:`set`.\n       query (callable): The function called on every object to\n          determine whether to include it in the search results. The\n          callable must accept three arguments, *path*, *key*, and\n          *value*, commonly abbreviated *p*, *k*, and *v*, same as\n          *enter* and *visit* from :func:`remap`.\n       reraise (bool): Whether to reraise exceptions raised by *query*\n          or to simply drop the result that caused the error.\n\n\n    With :func:`research` it's easy to inspect the details of a data\n    structure, like finding values that are at a certain depth (using\n    ``len(p)``) and much more. If more advanced functionality is\n    needed, check out the code and make your own :func:`remap`\n    wrapper, and consider `submitting a patch`_!\n\n    .. _submitting a patch: https://github.com/mahmoud/boltons/pulls\n    \"\"\"\n    ret = []\n\n    if not callable(query):\n        raise TypeError('query expected callable, not: %r' % query)\n\n    def _enter(path, key, value):\n        try:\n            if query(path, key, value):\n                ret.append((path + (key,), value))\n        except Exception:\n            if reraise:\n                raise\n        return enter(path, key, value)\n\n    remap(root, enter=_enter)\n    return ret",
    "docstring": "The :func:`research` function uses :func:`remap` to recurse over\nany data nested in *root*, and find values which match a given\ncriterion, specified by the *query* callable.\n\nResults are returned as a list of ``(path, value)`` pairs. The\npaths are tuples in the same format accepted by\n:func:`get_path`. This can be useful for comparing values nested\nin two or more different structures.\n\nHere's a simple example that finds all integers:\n\n>>> root = {'a': {'b': 1, 'c': (2, 'd', 3)}, 'e': None}\n>>> res = research(root, query=lambda p, k, v: isinstance(v, int))\n>>> print(sorted(res))\n[(('a', 'b'), 1), (('a', 'c', 0), 2), (('a', 'c', 2), 3)]\n\nNote how *query* follows the same, familiar ``path, key, value``\nsignature as the ``visit`` and ``enter`` functions on\n:func:`remap`, and returns a :class:`bool`.\n\nArgs:\n   root: The target object to search. Supports the same types of\n      objects as :func:`remap`, including :class:`list`,\n      :class:`tuple`, :class:`dict`, and :class:`set`.\n   query (callable): The function called on every object to\n      determine whether to include it in the search results. The\n      callable must accept three arguments, *path*, *key*, and\n      *value*, commonly abbreviated *p*, *k*, and *v*, same as\n      *enter* and *visit* from :func:`remap`.\n   reraise (bool): Whether to reraise exceptions raised by *query*\n      or to simply drop the result that caused the error.\n\n\nWith :func:`research` it's easy to inspect the details of a data\nstructure, like finding values that are at a certain depth (using\n``len(p)``) and much more. If more advanced functionality is\nneeded, check out the code and make your own :func:`remap`\nwrapper, and consider `submitting a patch`_!\n\n.. _submitting a patch: https://github.com/mahmoud/boltons/pulls"
  },
  {
    "function": "soft_sorted",
    "code": "def soft_sorted(iterable, first=None, last=None, key=None, reverse=False):\n    \"\"\"For when you care about the order of some elements, but not about\n    others.\n\n    Use this to float to the top and/or sink to the bottom a specific\n    ordering, while sorting the rest of the elements according to\n    normal :func:`sorted` rules.\n\n    >>> soft_sorted(['two', 'b', 'one', 'a'], first=['one', 'two'])\n    ['one', 'two', 'a', 'b']\n    >>> soft_sorted(range(7), first=[6, 15], last=[2, 4], reverse=True)\n    [6, 5, 3, 1, 0, 2, 4]\n    >>> import string\n    >>> ''.join(soft_sorted(string.hexdigits, first='za1', last='b', key=str.lower))\n    'aA1023456789cCdDeEfFbB'\n\n    Args:\n       iterable (list): A list or other iterable to sort.\n       first (list): A sequence to enforce for elements which should\n          appear at the beginning of the returned list.\n       last (list): A sequence to enforce for elements which should\n          appear at the end of the returned list.\n       key (callable): Callable used to generate a comparable key for\n          each item to be sorted, same as the key in\n          :func:`sorted`. Note that entries in *first* and *last*\n          should be the keys for the items. Defaults to\n          passthrough/the identity function.\n       reverse (bool): Whether or not elements not explicitly ordered\n          by *first* and *last* should be in reverse order or not.\n\n    Returns a new list in sorted order.\n    \"\"\"\n    first = first or []\n    last = last or []\n    key = key or (lambda x: x)\n    seq = list(iterable)\n    other = [x for x in seq if not (\n        (first and key(x) in first) or (last and key(x) in last))]\n    other.sort(key=key, reverse=reverse)\n\n    if first:\n        first = sorted([x for x in seq if key(x) in first],\n                       key=lambda x: first.index(key(x)))\n    if last:\n        last = sorted([x for x in seq if key(x) in last],\n                      key=lambda x: last.index(key(x)))\n    return first + other + last",
    "docstring": "For when you care about the order of some elements, but not about\nothers.\n\nUse this to float to the top and/or sink to the bottom a specific\nordering, while sorting the rest of the elements according to\nnormal :func:`sorted` rules.\n\n>>> soft_sorted(['two', 'b', 'one', 'a'], first=['one', 'two'])\n['one', 'two', 'a', 'b']\n>>> soft_sorted(range(7), first=[6, 15], last=[2, 4], reverse=True)\n[6, 5, 3, 1, 0, 2, 4]\n>>> import string\n>>> ''.join(soft_sorted(string.hexdigits, first='za1', last='b', key=str.lower))\n'aA1023456789cCdDeEfFbB'\n\nArgs:\n   iterable (list): A list or other iterable to sort.\n   first (list): A sequence to enforce for elements which should\n      appear at the beginning of the returned list.\n   last (list): A sequence to enforce for elements which should\n      appear at the end of the returned list.\n   key (callable): Callable used to generate a comparable key for\n      each item to be sorted, same as the key in\n      :func:`sorted`. Note that entries in *first* and *last*\n      should be the keys for the items. Defaults to\n      passthrough/the identity function.\n   reverse (bool): Whether or not elements not explicitly ordered\n      by *first* and *last* should be in reverse order or not.\n\nReturns a new list in sorted order."
  },
  {
    "function": "untyped_sorted",
    "code": "def untyped_sorted(iterable, key=None, reverse=False):\n    \"\"\"A version of :func:`sorted` which will happily sort an iterable of\n    heterogeneous types and return a new list, similar to legacy Python's\n    behavior.\n\n    >>> untyped_sorted(['abc', 2.0, 1, 2, 'def'])\n    [1, 2.0, 2, 'abc', 'def']\n\n    Note how mutually orderable types are sorted as expected, as in\n    the case of the integers and floats above.\n\n    .. note::\n\n       Results may vary across Python versions and builds, but the\n       function will produce a sorted list, except in the case of\n       explicitly unorderable objects.\n\n    \"\"\"\n    class _Wrapper:\n        slots = ('obj',)\n\n        def __init__(self, obj):\n            self.obj = obj\n\n        def __lt__(self, other):\n            obj = key(self.obj) if key is not None else self.obj\n            other = key(other.obj) if key is not None else other.obj\n            try:\n                ret = obj < other\n            except TypeError:\n                ret = ((type(obj).__name__, id(type(obj)), obj)\n                       < (type(other).__name__, id(type(other)), other))\n            return ret\n\n    if key is not None and not callable(key):\n        raise TypeError('expected function or callable object for key, not: %r'\n                        % key)\n\n    return sorted(iterable, key=_Wrapper, reverse=reverse)",
    "docstring": "A version of :func:`sorted` which will happily sort an iterable of\nheterogeneous types and return a new list, similar to legacy Python's\nbehavior.\n\n>>> untyped_sorted(['abc', 2.0, 1, 2, 'def'])\n[1, 2.0, 2, 'abc', 'def']\n\nNote how mutually orderable types are sorted as expected, as in\nthe case of the integers and floats above.\n\n.. note::\n\n   Results may vary across Python versions and builds, but the\n   function will produce a sorted list, except in the case of\n   explicitly unorderable objects."
  },
  {
    "function": "reverse_iter_lines",
    "code": "def reverse_iter_lines(file_obj, blocksize=DEFAULT_BLOCKSIZE, preseek=True, encoding=None):\n    \"\"\"Returns an iterator over the lines from a file object, in\n    reverse order, i.e., last line first, first line last. Uses the\n    :meth:`file.seek` method of file objects, and is tested compatible with\n    :class:`file` objects, as well as :class:`StringIO.StringIO`.\n\n    Args:\n        file_obj (file): An open file object. Note that\n            ``reverse_iter_lines`` mutably reads from the file and\n            other functions should not mutably interact with the file\n            object after being passed. Files can be opened in bytes or\n            text mode.\n        blocksize (int): The block size to pass to\n          :meth:`file.read()`. Warning: keep this a fairly large\n          multiple of 2, defaults to 4096.\n        preseek (bool): Tells the function whether or not to automatically\n            seek to the end of the file. Defaults to ``True``.\n            ``preseek=False`` is useful in cases when the\n            file cursor is already in position, either at the end of\n            the file or in the middle for relative reverse line\n            generation.\n\n    \"\"\"\n    # This function is a bit of a pain because it attempts to be byte/text agnostic\n    try:\n        encoding = encoding or file_obj.encoding\n    except AttributeError:\n        # BytesIO\n        encoding = None\n    else:\n        encoding = 'utf-8'\n\n    # need orig_obj to keep alive otherwise __del__ on the TextWrapper will close the file\n    orig_obj = file_obj\n    try:\n        file_obj = orig_obj.detach()\n    except (AttributeError, io.UnsupportedOperation):\n        pass\n\n    empty_bytes, newline_bytes, empty_text = b'', b'\\n', ''\n\n    if preseek:\n        file_obj.seek(0, os.SEEK_END)\n    buff = empty_bytes\n    cur_pos = file_obj.tell()\n    while 0 < cur_pos:\n        read_size = min(blocksize, cur_pos)\n        cur_pos -= read_size\n        file_obj.seek(cur_pos, os.SEEK_SET)\n        cur = file_obj.read(read_size)\n        buff = cur + buff\n        lines = buff.splitlines()\n\n        if len(lines) < 2 or lines[0] == empty_bytes:\n            continue\n        if buff[-1:] == newline_bytes:\n            yield empty_text if encoding else empty_bytes\n        for line in lines[:0:-1]:\n            yield line.decode(encoding) if encoding else line\n        buff = lines[0]\n    if buff:\n        yield buff.decode(encoding) if encoding else buff",
    "docstring": "Returns an iterator over the lines from a file object, in\nreverse order, i.e., last line first, first line last. Uses the\n:meth:`file.seek` method of file objects, and is tested compatible with\n:class:`file` objects, as well as :class:`StringIO.StringIO`.\n\nArgs:\n    file_obj (file): An open file object. Note that\n        ``reverse_iter_lines`` mutably reads from the file and\n        other functions should not mutably interact with the file\n        object after being passed. Files can be opened in bytes or\n        text mode.\n    blocksize (int): The block size to pass to\n      :meth:`file.read()`. Warning: keep this a fairly large\n      multiple of 2, defaults to 4096.\n    preseek (bool): Tells the function whether or not to automatically\n        seek to the end of the file. Defaults to ``True``.\n        ``preseek=False`` is useful in cases when the\n        file cursor is already in position, either at the end of\n        the file or in the middle for relative reverse line\n        generation."
  },
  {
    "function": "clamp",
    "code": "def clamp(x, lower=float('-inf'), upper=float('inf')):\n    \"\"\"Limit a value to a given range.\n\n    Args:\n        x (int or float): Number to be clamped.\n        lower (int or float): Minimum value for x.\n        upper (int or float): Maximum value for x.\n\n    The returned value is guaranteed to be between *lower* and\n    *upper*. Integers, floats, and other comparable types can be\n    mixed.\n\n    >>> clamp(1.0, 0, 5)\n    1.0\n    >>> clamp(-1.0, 0, 5)\n    0\n    >>> clamp(101.0, 0, 5)\n    5\n    >>> clamp(123, upper=5)\n    5\n\n    Similar to `numpy's clip`_ function.\n\n    .. _numpy's clip: http://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html\n\n    \"\"\"\n    if upper < lower:\n        raise ValueError('expected upper bound (%r) >= lower bound (%r)'\n                         % (upper, lower))\n    return min(max(x, lower), upper)",
    "docstring": "Limit a value to a given range.\n\nArgs:\n    x (int or float): Number to be clamped.\n    lower (int or float): Minimum value for x.\n    upper (int or float): Maximum value for x.\n\nThe returned value is guaranteed to be between *lower* and\n*upper*. Integers, floats, and other comparable types can be\nmixed.\n\n>>> clamp(1.0, 0, 5)\n1.0\n>>> clamp(-1.0, 0, 5)\n0\n>>> clamp(101.0, 0, 5)\n5\n>>> clamp(123, upper=5)\n5\n\nSimilar to `numpy's clip`_ function.\n\n.. _numpy's clip: http://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html"
  },
  {
    "function": "ceil",
    "code": "def ceil(x, options=None):\n    \"\"\"Return the ceiling of *x*. If *options* is set, return the smallest\n    integer or float from *options* that is greater than or equal to\n    *x*.\n\n    Args:\n        x (int or float): Number to be tested.\n        options (iterable): Optional iterable of arbitrary numbers\n          (ints or floats).\n\n    >>> VALID_CABLE_CSA = [1.5, 2.5, 4, 6, 10, 25, 35, 50]\n    >>> ceil(3.5, options=VALID_CABLE_CSA)\n    4\n    >>> ceil(4, options=VALID_CABLE_CSA)\n    4\n    \"\"\"\n    if options is None:\n        return _ceil(x)\n    options = sorted(options)\n    i = bisect.bisect_left(options, x)\n    if i == len(options):\n        raise ValueError(\"no ceil options greater than or equal to: %r\" % x)\n    return options[i]",
    "docstring": "Return the ceiling of *x*. If *options* is set, return the smallest\ninteger or float from *options* that is greater than or equal to\n*x*.\n\nArgs:\n    x (int or float): Number to be tested.\n    options (iterable): Optional iterable of arbitrary numbers\n      (ints or floats).\n\n>>> VALID_CABLE_CSA = [1.5, 2.5, 4, 6, 10, 25, 35, 50]\n>>> ceil(3.5, options=VALID_CABLE_CSA)\n4\n>>> ceil(4, options=VALID_CABLE_CSA)\n4"
  },
  {
    "function": "floor",
    "code": "def floor(x, options=None):\n    \"\"\"Return the floor of *x*. If *options* is set, return the largest\n    integer or float from *options* that is less than or equal to\n    *x*.\n\n    Args:\n        x (int or float): Number to be tested.\n        options (iterable): Optional iterable of arbitrary numbers\n          (ints or floats).\n\n    >>> VALID_CABLE_CSA = [1.5, 2.5, 4, 6, 10, 25, 35, 50]\n    >>> floor(3.5, options=VALID_CABLE_CSA)\n    2.5\n    >>> floor(2.5, options=VALID_CABLE_CSA)\n    2.5\n\n    \"\"\"\n    if options is None:\n        return _floor(x)\n    options = sorted(options)\n\n    i = bisect.bisect_right(options, x)\n    if not i:\n        raise ValueError(\"no floor options less than or equal to: %r\" % x)\n    return options[i - 1]",
    "docstring": "Return the floor of *x*. If *options* is set, return the largest\ninteger or float from *options* that is less than or equal to\n*x*.\n\nArgs:\n    x (int or float): Number to be tested.\n    options (iterable): Optional iterable of arbitrary numbers\n      (ints or floats).\n\n>>> VALID_CABLE_CSA = [1.5, 2.5, 4, 6, 10, 25, 35, 50]\n>>> floor(3.5, options=VALID_CABLE_CSA)\n2.5\n>>> floor(2.5, options=VALID_CABLE_CSA)\n2.5"
  },
  {
    "function": "namedtuple",
    "code": "def namedtuple(typename, field_names, verbose=False, rename=False):\n    \"\"\"Returns a new subclass of tuple with named fields.\n\n    >>> Point = namedtuple('Point', ['x', 'y'])\n    >>> Point.__doc__                   # docstring for the new class\n    'Point(x, y)'\n    >>> p = Point(11, y=22)             # instantiate with pos args or keywords\n    >>> p[0] + p[1]                     # indexable like a plain tuple\n    33\n    >>> x, y = p                        # unpack like a regular tuple\n    >>> x, y\n    (11, 22)\n    >>> p.x + p.y                       # fields also accessible by name\n    33\n    >>> d = p._asdict()                 # convert to a dictionary\n    >>> d['x']\n    11\n    >>> Point(**d)                      # convert from a dictionary\n    Point(x=11, y=22)\n    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\n    Point(x=100, y=22)\n    \"\"\"\n\n    # Validate the field names.  At the user's option, either generate an error\n    # message or automatically replace the field name with a valid name.\n    if isinstance(field_names, str):\n        field_names = field_names.replace(',', ' ').split()\n    field_names = [str(x) for x in field_names]\n    if rename:\n        seen = set()\n        for index, name in enumerate(field_names):\n            if (not all(c.isalnum() or c == '_' for c in name)\n                or _iskeyword(name)\n                or not name\n                or name[0].isdigit()\n                or name.startswith('_')\n                or name in seen):\n                field_names[index] = '_%d' % index\n            seen.add(name)\n    for name in [typename] + field_names:\n        if not all(c.isalnum() or c == '_' for c in name):\n            raise ValueError('Type names and field names can only contain '\n                             'alphanumeric characters and underscores: %r'\n                             % name)\n        if _iskeyword(name):\n            raise ValueError('Type names and field names cannot be a '\n                             'keyword: %r' % name)\n        if name[0].isdigit():\n            raise ValueError('Type names and field names cannot start with '\n                             'a number: %r' % name)\n    seen = set()\n    for name in field_names:\n        if name.startswith('_') and not rename:\n            raise ValueError('Field names cannot start with an underscore: '\n                             '%r' % name)\n        if name in seen:\n            raise ValueError('Encountered duplicate field name: %r' % name)\n        seen.add(name)\n\n    # Fill-in the class template\n    fmt_kw = {'typename': typename}\n    fmt_kw['field_names'] = tuple(field_names)\n    fmt_kw['num_fields'] = len(field_names)\n    fmt_kw['arg_list'] = repr(tuple(field_names)).replace(\"'\", \"\")[1:-1]\n    fmt_kw['repr_fmt'] = ', '.join(_repr_tmpl.format(name=name)\n                                   for name in field_names)\n    fmt_kw['field_defs'] = '\\n'.join(_imm_field_tmpl.format(index=index, name=name)\n                                     for index, name in enumerate(field_names))\n    class_definition = _namedtuple_tmpl.format(**fmt_kw)\n\n    if verbose:\n        print(class_definition)\n\n    # Execute the template string in a temporary namespace and support\n    # tracing utilities by setting a value for frame.f_globals['__name__']\n    namespace = dict(_itemgetter=_itemgetter,\n                     __name__='namedtuple_%s' % typename,\n                     OrderedDict=OrderedDict,\n                     _property=property,\n                     _tuple=tuple)\n    try:\n        exec(class_definition, namespace)\n    except SyntaxError as e:\n        raise SyntaxError(e.msg + ':\\n' + class_definition)\n    result = namespace[typename]\n\n    # For pickling to work, the __module__ variable needs to be set to the frame\n    # where the named tuple is created.  Bypass this step in environments where\n    # sys._getframe is not defined (Jython for example) or sys._getframe is not\n    # defined for arguments greater than 0 (IronPython).\n    try:\n        frame = _sys._getframe(1)\n        result.__module__ = frame.f_globals.get('__name__', '__main__')\n    except (AttributeError, ValueError):\n        pass\n\n    return result",
    "docstring": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with pos args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)"
  },
  {
    "function": "namedlist",
    "code": "def namedlist(typename, field_names, verbose=False, rename=False):\n    \"\"\"Returns a new subclass of list with named fields.\n\n    >>> Point = namedlist('Point', ['x', 'y'])\n    >>> Point.__doc__                   # docstring for the new class\n    'Point(x, y)'\n    >>> p = Point(11, y=22)             # instantiate with pos args or keywords\n    >>> p[0] + p[1]                     # indexable like a plain list\n    33\n    >>> x, y = p                        # unpack like a regular list\n    >>> x, y\n    (11, 22)\n    >>> p.x + p.y                       # fields also accessible by name\n    33\n    >>> d = p._asdict()                 # convert to a dictionary\n    >>> d['x']\n    11\n    >>> Point(**d)                      # convert from a dictionary\n    Point(x=11, y=22)\n    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\n    Point(x=100, y=22)\n    \"\"\"\n\n    # Validate the field names.  At the user's option, either generate an error\n    # message or automatically replace the field name with a valid name.\n    if isinstance(field_names, str):\n        field_names = field_names.replace(',', ' ').split()\n    field_names = [str(x) for x in field_names]\n    if rename:\n        seen = set()\n        for index, name in enumerate(field_names):\n            if (not all(c.isalnum() or c == '_' for c in name)\n                or _iskeyword(name)\n                or not name\n                or name[0].isdigit()\n                or name.startswith('_')\n                or name in seen):\n                field_names[index] = '_%d' % index\n            seen.add(name)\n    for name in [typename] + field_names:\n        if not all(c.isalnum() or c == '_' for c in name):\n            raise ValueError('Type names and field names can only contain '\n                             'alphanumeric characters and underscores: %r'\n                             % name)\n        if _iskeyword(name):\n            raise ValueError('Type names and field names cannot be a '\n                             'keyword: %r' % name)\n        if name[0].isdigit():\n            raise ValueError('Type names and field names cannot start with '\n                             'a number: %r' % name)\n    seen = set()\n    for name in field_names:\n        if name.startswith('_') and not rename:\n            raise ValueError('Field names cannot start with an underscore: '\n                             '%r' % name)\n        if name in seen:\n            raise ValueError('Encountered duplicate field name: %r' % name)\n        seen.add(name)\n\n    # Fill-in the class template\n    fmt_kw = {'typename': typename}\n    fmt_kw['field_names'] = tuple(field_names)\n    fmt_kw['num_fields'] = len(field_names)\n    fmt_kw['arg_list'] = repr(tuple(field_names)).replace(\"'\", \"\")[1:-1]\n    fmt_kw['repr_fmt'] = ', '.join(_repr_tmpl.format(name=name)\n                                   for name in field_names)\n    fmt_kw['field_defs'] = '\\n'.join(_m_field_tmpl.format(index=index, name=name)\n                                     for index, name in enumerate(field_names))\n    class_definition = _namedlist_tmpl.format(**fmt_kw)\n\n    if verbose:\n        print(class_definition)\n\n    def _itemsetter(key):\n        def _itemsetter(obj, value):\n            obj[key] = value\n        return _itemsetter\n\n    # Execute the template string in a temporary namespace and support\n    # tracing utilities by setting a value for frame.f_globals['__name__']\n    namespace = dict(_itemgetter=_itemgetter,\n                     _itemsetter=_itemsetter,\n                     __name__='namedlist_%s' % typename,\n                     OrderedDict=OrderedDict,\n                     _property=property,\n                     _list=list)\n    try:\n        exec(class_definition, namespace)\n    except SyntaxError as e:\n        raise SyntaxError(e.msg + ':\\n' + class_definition)\n    result = namespace[typename]\n\n    # For pickling to work, the __module__ variable needs to be set to\n    # the frame where the named list is created.  Bypass this step in\n    # environments where sys._getframe is not defined (Jython for\n    # example) or sys._getframe is not defined for arguments greater\n    # than 0 (IronPython).\n    try:\n        frame = _sys._getframe(1)\n        result.__module__ = frame.f_globals.get('__name__', '__main__')\n    except (AttributeError, ValueError):\n        pass\n\n    return result",
    "docstring": "Returns a new subclass of list with named fields.\n\n>>> Point = namedlist('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with pos args or keywords\n>>> p[0] + p[1]                     # indexable like a plain list\n33\n>>> x, y = p                        # unpack like a regular list\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)"
  },
  {
    "function": "augpath",
    "code": "def augpath(path, suffix='', prefix='', ext=None, base=None, dpath=None,\n            multidot=False):\n    \"\"\"\n    Augment a path by modifying its components.\n\n    Creates a new path with a different extension, basename, directory, prefix,\n    and/or suffix.\n\n    A prefix is inserted before the basename. A suffix is inserted\n    between the basename and the extension. The basename and extension can be\n    replaced with a new one. Essentially a path is broken down into components\n    (dpath, base, ext), and then recombined as (dpath, prefix, base, suffix,\n    ext) after replacing any specified component.\n\n    Args:\n        path (str | PathLike): a path to augment\n        suffix (str, default=''): placed between the basename and extension\n        prefix (str, default=''): placed in front of the basename\n        ext (str, default=None): if specified, replaces the extension\n        base (str, default=None): if specified, replaces the basename without\n            extension\n        dpath (str | PathLike, default=None): if specified, replaces the\n            directory\n        multidot (bool, default=False): Allows extensions to contain multiple\n            dots. Specifically, if False, everything after the last dot in the\n            basename is the extension. If True, everything after the first dot\n            in the basename is the extension.\n\n    Returns:\n        str: augmented path\n\n    Example:\n        >>> path = 'foo.bar'\n        >>> suffix = '_suff'\n        >>> prefix = 'pref_'\n        >>> ext = '.baz'\n        >>> newpath = augpath(path, suffix, prefix, ext=ext, base='bar')\n        >>> print('newpath = %s' % (newpath,))\n        newpath = pref_bar_suff.baz\n\n    Example:\n        >>> augpath('foo.bar')\n        'foo.bar'\n        >>> augpath('foo.bar', ext='.BAZ')\n        'foo.BAZ'\n        >>> augpath('foo.bar', suffix='_')\n        'foo_.bar'\n        >>> augpath('foo.bar', prefix='_')\n        '_foo.bar'\n        >>> augpath('foo.bar', base='baz')\n        'baz.bar'\n        >>> augpath('foo.tar.gz', ext='.zip', multidot=True)\n        'foo.zip'\n        >>> augpath('foo.tar.gz', ext='.zip', multidot=False)\n        'foo.tar.zip'\n        >>> augpath('foo.tar.gz', suffix='_new', multidot=True)\n        'foo_new.tar.gz'\n    \"\"\"\n    # Breakup path\n    orig_dpath, fname = split(path)\n    if multidot:\n        # The first dot defines the extension\n        parts = fname.split('.', 1)\n        orig_base = parts[0]\n        orig_ext = '' if len(parts) == 1 else '.' + parts[1]\n    else:\n        # The last dot defines the extension\n        orig_base, orig_ext = splitext(fname)\n    # Replace parts with specified augmentations\n    if dpath is None:\n        dpath = orig_dpath\n    if ext is None:\n        ext = orig_ext\n    if base is None:\n        base = orig_base\n    # Recombine into new path\n    new_fname = ''.join((prefix, base, suffix, ext))\n    newpath = join(dpath, new_fname)\n    return newpath",
    "docstring": "Augment a path by modifying its components.\n\nCreates a new path with a different extension, basename, directory, prefix,\nand/or suffix.\n\nA prefix is inserted before the basename. A suffix is inserted\nbetween the basename and the extension. The basename and extension can be\nreplaced with a new one. Essentially a path is broken down into components\n(dpath, base, ext), and then recombined as (dpath, prefix, base, suffix,\next) after replacing any specified component.\n\nArgs:\n    path (str | PathLike): a path to augment\n    suffix (str, default=''): placed between the basename and extension\n    prefix (str, default=''): placed in front of the basename\n    ext (str, default=None): if specified, replaces the extension\n    base (str, default=None): if specified, replaces the basename without\n        extension\n    dpath (str | PathLike, default=None): if specified, replaces the\n        directory\n    multidot (bool, default=False): Allows extensions to contain multiple\n        dots. Specifically, if False, everything after the last dot in the\n        basename is the extension. If True, everything after the first dot\n        in the basename is the extension.\n\nReturns:\n    str: augmented path\n\nExample:\n    >>> path = 'foo.bar'\n    >>> suffix = '_suff'\n    >>> prefix = 'pref_'\n    >>> ext = '.baz'\n    >>> newpath = augpath(path, suffix, prefix, ext=ext, base='bar')\n    >>> print('newpath = %s' % (newpath,))\n    newpath = pref_bar_suff.baz\n\nExample:\n    >>> augpath('foo.bar')\n    'foo.bar'\n    >>> augpath('foo.bar', ext='.BAZ')\n    'foo.BAZ'\n    >>> augpath('foo.bar', suffix='_')\n    'foo_.bar'\n    >>> augpath('foo.bar', prefix='_')\n    '_foo.bar'\n    >>> augpath('foo.bar', base='baz')\n    'baz.bar'\n    >>> augpath('foo.tar.gz', ext='.zip', multidot=True)\n    'foo.zip'\n    >>> augpath('foo.tar.gz', ext='.zip', multidot=False)\n    'foo.tar.zip'\n    >>> augpath('foo.tar.gz', suffix='_new', multidot=True)\n    'foo_new.tar.gz'"
  },
  {
    "function": "shrinkuser",
    "code": "def shrinkuser(path, home='~'):\n    \"\"\"\n    Inverse of :func:`os.path.expanduser`.\n\n    Args:\n        path (str | PathLike): path in system file structure\n        home (str, default='~'): symbol used to replace the home path.\n            Defaults to '~', but you might want to use '$HOME' or\n            '%USERPROFILE%' instead.\n\n    Returns:\n        str: path: shortened path replacing the home directory with a tilde\n\n    Example:\n        >>> path = expanduser('~')\n        >>> assert path != '~'\n        >>> assert shrinkuser(path) == '~'\n        >>> assert shrinkuser(path + '1') == path + '1'\n        >>> assert shrinkuser(path + '/1') == join('~', '1')\n        >>> assert shrinkuser(path + '/1', '$HOME') == join('$HOME', '1')\n    \"\"\"\n    path = normpath(path)\n    userhome_dpath = expanduser('~')\n    if path.startswith(userhome_dpath):\n        if len(path) == len(userhome_dpath):\n            path = home\n        elif path[len(userhome_dpath)] == os.path.sep:\n            path = home + path[len(userhome_dpath):]\n    return path",
    "docstring": "Inverse of :func:`os.path.expanduser`.\n\nArgs:\n    path (str | PathLike): path in system file structure\n    home (str, default='~'): symbol used to replace the home path.\n        Defaults to '~', but you might want to use '$HOME' or\n        '%USERPROFILE%' instead.\n\nReturns:\n    str: path: shortened path replacing the home directory with a tilde\n\nExample:\n    >>> path = expanduser('~')\n    >>> assert path != '~'\n    >>> assert shrinkuser(path) == '~'\n    >>> assert shrinkuser(path + '1') == path + '1'\n    >>> assert shrinkuser(path + '/1') == join('~', '1')\n    >>> assert shrinkuser(path + '/1', '$HOME') == join('$HOME', '1')"
  },
  {
    "function": "expandpath",
    "code": "def expandpath(path):\n    \"\"\"\n    Shell-like expansion of environment variables and tilde home directory.\n\n    Args:\n        path (str | PathLike): the path to expand\n\n    Returns:\n        str : expanded path\n\n    Example:\n        >>> import os\n        >>> os.environ['SPAM'] = 'eggs'\n        >>> assert expandpath('~/$SPAM') == expanduser('~/eggs')\n        >>> assert expandpath('foo') == 'foo'\n    \"\"\"\n    path = expanduser(path)\n    path = expandvars(path)\n    return path",
    "docstring": "Shell-like expansion of environment variables and tilde home directory.\n\nArgs:\n    path (str | PathLike): the path to expand\n\nReturns:\n    str : expanded path\n\nExample:\n    >>> import os\n    >>> os.environ['SPAM'] = 'eggs'\n    >>> assert expandpath('~/$SPAM') == expanduser('~/eggs')\n    >>> assert expandpath('foo') == 'foo'"
  },
  {
    "function": "complement",
    "code": "def complement(wrapped):\n    \"\"\"Given a :class:`set`, convert it to a **complement set**.\n\n    Whereas a :class:`set` keeps track of what it contains, a\n    `complement set\n    <https://en.wikipedia.org/wiki/Complement_(set_theory)>`_ keeps\n    track of what it does *not* contain. For example, look what\n    happens when we intersect a normal set with a complement set::\n\n    >>> list(set(range(5)) & complement(set([2, 3])))\n    [0, 1, 4]\n\n    We get the everything in the left that wasn't in the right,\n    because intersecting with a complement is the same as subtracting\n    a normal set.\n\n    Args:\n        wrapped (set): A set or any other iterable which should be\n           turned into a complement set.\n\n    All set methods and operators are supported by complement sets,\n    between other :func:`complement`-wrapped sets and/or regular\n    :class:`set` objects.\n\n    Because a complement set only tracks what elements are *not* in\n    the set, functionality based on set contents is unavailable:\n    :func:`len`, :func:`iter` (and for loops), and ``.pop()``. But a\n    complement set can always be turned back into a regular set by\n    complementing it again:\n\n    >>> s = set(range(5))\n    >>> complement(complement(s)) == s\n    True\n\n    .. note::\n\n       An empty complement set corresponds to the concept of a\n       `universal set <https://en.wikipedia.org/wiki/Universal_set>`_\n       from mathematics.\n\n    Complement sets by example\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n    Many uses of sets can be expressed more simply by using a\n    complement. Rather than trying to work out in your head the proper\n    way to invert an expression, you can just throw a complement on\n    the set. Consider this example of a name filter::\n\n        >>> class NamesFilter(object):\n        ...    def __init__(self, allowed):\n        ...        self._allowed = allowed\n        ...\n        ...    def filter(self, names):\n        ...        return [name for name in names if name in self._allowed]\n        >>> NamesFilter(set(['alice', 'bob'])).filter(['alice', 'bob', 'carol'])\n        ['alice', 'bob']\n\n    What if we want to just express \"let all the names through\"?\n\n    We could try to enumerate all of the expected names::\n\n       ``NamesFilter({'alice', 'bob', 'carol'})``\n\n    But this is very brittle -- what if at some point over this\n    object is changed to filter ``['alice', 'bob', 'carol', 'dan']``?\n\n    Even worse, what about the poor programmer who next works\n    on this piece of code?  They cannot tell whether the purpose\n    of the large allowed set was \"allow everything\", or if 'dan'\n    was excluded for some subtle reason.\n\n    A complement set lets the programmer intention be expressed\n    succinctly and directly::\n\n       NamesFilter(complement(set()))\n\n    Not only is this code short and robust, it is easy to understand\n    the intention.\n\n    \"\"\"\n    if type(wrapped) is _ComplementSet:\n        return wrapped.complemented()\n    if type(wrapped) is frozenset:\n        return _ComplementSet(excluded=wrapped)\n    return _ComplementSet(excluded=set(wrapped))",
    "docstring": "Given a :class:`set`, convert it to a **complement set**.\n\nWhereas a :class:`set` keeps track of what it contains, a\n`complement set\n<https://en.wikipedia.org/wiki/Complement_(set_theory)>`_ keeps\ntrack of what it does *not* contain. For example, look what\nhappens when we intersect a normal set with a complement set::\n\n>>> list(set(range(5)) & complement(set([2, 3])))\n[0, 1, 4]\n\nWe get the everything in the left that wasn't in the right,\nbecause intersecting with a complement is the same as subtracting\na normal set.\n\nArgs:\n    wrapped (set): A set or any other iterable which should be\n       turned into a complement set.\n\nAll set methods and operators are supported by complement sets,\nbetween other :func:`complement`-wrapped sets and/or regular\n:class:`set` objects.\n\nBecause a complement set only tracks what elements are *not* in\nthe set, functionality based on set contents is unavailable:\n:func:`len`, :func:`iter` (and for loops), and ``.pop()``. But a\ncomplement set can always be turned back into a regular set by\ncomplementing it again:\n\n>>> s = set(range(5))\n>>> complement(complement(s)) == s\nTrue\n\n.. note::\n\n   An empty complement set corresponds to the concept of a\n   `universal set <https://en.wikipedia.org/wiki/Universal_set>`_\n   from mathematics.\n\nComplement sets by example\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nMany uses of sets can be expressed more simply by using a\ncomplement. Rather than trying to work out in your head the proper\nway to invert an expression, you can just throw a complement on\nthe set. Consider this example of a name filter::\n\n    >>> class NamesFilter(object):\n    ...    def __init__(self, allowed):\n    ...        self._allowed = allowed\n    ...\n    ...    def filter(self, names):\n    ...        return [name for name in names if name in self._allowed]\n    >>> NamesFilter(set(['alice', 'bob'])).filter(['alice', 'bob', 'carol'])\n    ['alice', 'bob']\n\nWhat if we want to just express \"let all the names through\"?\n\nWe could try to enumerate all of the expected names::\n\n   ``NamesFilter({'alice', 'bob', 'carol'})``\n\nBut this is very brittle -- what if at some point over this\nobject is changed to filter ``['alice', 'bob', 'carol', 'dan']``?\n\nEven worse, what about the poor programmer who next works\non this piece of code?  They cannot tell whether the purpose\nof the large allowed set was \"allow everything\", or if 'dan'\nwas excluded for some subtle reason.\n\nA complement set lets the programmer intention be expressed\nsuccinctly and directly::\n\n   NamesFilter(complement(set()))\n\nNot only is this code short and robust, it is easy to understand\nthe intention."
  },
  {
    "function": "_norm_args_typeerror",
    "code": "def _norm_args_typeerror(other):\n    '''normalize args and raise type-error if there is a problem'''\n    if type(other) in (set, frozenset):\n        inc, exc = other, None\n    elif type(other) is _ComplementSet:\n        inc, exc = other._included, other._excluded\n    else:\n        raise TypeError('argument must be another set or complement(set)')\n    return inc, exc",
    "docstring": "normalize args and raise type-error if there is a problem"
  },
  {
    "function": "_norm_args_notimplemented",
    "code": "def _norm_args_notimplemented(other):\n    '''normalize args and return NotImplemented (for overloaded operators)'''\n    if type(other) in (set, frozenset):\n        inc, exc = other, None\n    elif type(other) is _ComplementSet:\n        inc, exc = other._included, other._excluded\n    else:\n        return NotImplemented, None\n    return inc, exc",
    "docstring": "normalize args and return NotImplemented (for overloaded operators)"
  },
  {
    "function": "describe",
    "code": "def describe(data, quantiles=None, format=None):\n    \"\"\"A convenience function to get standard summary statistics useful\n    for describing most data. See :meth:`Stats.describe` for more\n    details.\n\n    >>> print(describe(range(7), format='text'))\n    count:    7\n    mean:     3.0\n    std_dev:  2.0\n    mad:      2.0\n    min:      0\n    0.25:     1.5\n    0.5:      3\n    0.75:     4.5\n    max:      6\n\n    See :meth:`Stats.format_histogram` for another very useful\n    summarization that uses textual visualization.\n    \"\"\"\n    return Stats(data).describe(quantiles=quantiles, format=format)",
    "docstring": "A convenience function to get standard summary statistics useful\nfor describing most data. See :meth:`Stats.describe` for more\ndetails.\n\n>>> print(describe(range(7), format='text'))\ncount:    7\nmean:     3.0\nstd_dev:  2.0\nmad:      2.0\nmin:      0\n0.25:     1.5\n0.5:      3\n0.75:     4.5\nmax:      6\n\nSee :meth:`Stats.format_histogram` for another very useful\nsummarization that uses textual visualization."
  },
  {
    "function": "format_histogram_counts",
    "code": "def format_histogram_counts(bin_counts, width=None, format_bin=None):\n    \"\"\"The formatting logic behind :meth:`Stats.format_histogram`, which\n    takes the output of :meth:`Stats.get_histogram_counts`, and passes\n    them to this function.\n\n    Args:\n        bin_counts (list): A list of bin values to counts.\n        width (int): Number of character columns in the text output,\n            defaults to 80 or console width in Python 3.3+.\n        format_bin (callable): Used to convert bin values into string\n            labels.\n    \"\"\"\n    lines = []\n    if not format_bin:\n        format_bin = lambda v: v\n    if not width:\n        try:\n            import shutil  # python 3 convenience\n            width = shutil.get_terminal_size()[0]\n        except Exception:\n            width = 80\n\n    bins = [b for b, _ in bin_counts]\n    count_max = max([count for _, count in bin_counts])\n    count_cols = len(str(count_max))\n\n    labels = ['%s' % format_bin(b) for b in bins]\n    label_cols = max([len(l) for l in labels])\n    tmp_line = '{}: {} #'.format('x' * label_cols, count_max)\n\n    bar_cols = max(width - len(tmp_line), 3)\n    line_k = float(bar_cols) / count_max\n    tmpl = \"{label:>{label_cols}}: {count:>{count_cols}} {bar}\"\n    for label, (bin_val, count) in zip(labels, bin_counts):\n        bar_len = int(round(count * line_k))\n        bar = ('#' * bar_len) or '|'\n        line = tmpl.format(label=label,\n                           label_cols=label_cols,\n                           count=count,\n                           count_cols=count_cols,\n                           bar=bar)\n        lines.append(line)\n\n    return '\\n'.join(lines)",
    "docstring": "The formatting logic behind :meth:`Stats.format_histogram`, which\ntakes the output of :meth:`Stats.get_histogram_counts`, and passes\nthem to this function.\n\nArgs:\n    bin_counts (list): A list of bin values to counts.\n    width (int): Number of character columns in the text output,\n        defaults to 80 or console width in Python 3.3+.\n    format_bin (callable): Used to convert bin values into string\n        labels."
  },
  {
    "function": "camel2under",
    "code": "def camel2under(camel_string):\n    \"\"\"Converts a camelcased string to underscores. Useful for turning a\n    class name into a function name.\n\n    >>> camel2under('BasicParseTest')\n    'basic_parse_test'\n    \"\"\"\n    return _camel2under_re.sub(r'_\\1', camel_string).lower()",
    "docstring": "Converts a camelcased string to underscores. Useful for turning a\nclass name into a function name.\n\n>>> camel2under('BasicParseTest')\n'basic_parse_test'"
  },
  {
    "function": "under2camel",
    "code": "def under2camel(under_string):\n    \"\"\"Converts an underscored string to camelcased. Useful for turning a\n    function name into a class name.\n\n    >>> under2camel('complex_tokenizer')\n    'ComplexTokenizer'\n    \"\"\"\n    return ''.join(w.capitalize() or '_' for w in under_string.split('_'))",
    "docstring": "Converts an underscored string to camelcased. Useful for turning a\nfunction name into a class name.\n\n>>> under2camel('complex_tokenizer')\n'ComplexTokenizer'"
  },
  {
    "function": "slugify",
    "code": "def slugify(text, delim='_', lower=True, ascii=False):\n    \"\"\"\n    A basic function that turns text full of scary characters\n    (i.e., punctuation and whitespace), into a relatively safe\n    lowercased string separated only by the delimiter specified\n    by *delim*, which defaults to ``_``.\n\n    The *ascii* convenience flag will :func:`asciify` the slug if\n    you require ascii-only slugs.\n\n    >>> slugify('First post! Hi!!!!~1    ')\n    'first_post_hi_1'\n\n    >>> slugify(\"Kurt G\u00f6del's pretty cool.\", ascii=True) == \\\n        b'kurt_goedel_s_pretty_cool'\n    True\n\n    \"\"\"\n    ret = delim.join(split_punct_ws(text)) or delim if text else ''\n    if ascii:\n        ret = asciify(ret)\n    if lower:\n        ret = ret.lower()\n    return ret",
    "docstring": "A basic function that turns text full of scary characters\n(i.e., punctuation and whitespace), into a relatively safe\nlowercased string separated only by the delimiter specified\nby *delim*, which defaults to ``_``.\n\nThe *ascii* convenience flag will :func:`asciify` the slug if\nyou require ascii-only slugs.\n\n>>> slugify('First post! Hi!!!!~1    ')\n'first_post_hi_1'\n\n>>> slugify(\"Kurt G\u00f6del's pretty cool.\", ascii=True) ==         b'kurt_goedel_s_pretty_cool'\nTrue"
  },
  {
    "function": "split_punct_ws",
    "code": "def split_punct_ws(text):\n    \"\"\"While :meth:`str.split` will split on whitespace,\n    :func:`split_punct_ws` will split on punctuation and\n    whitespace. This used internally by :func:`slugify`, above.\n\n    >>> split_punct_ws('First post! Hi!!!!~1    ')\n    ['First', 'post', 'Hi', '1']\n    \"\"\"\n    return [w for w in _punct_re.split(text) if w]",
    "docstring": "While :meth:`str.split` will split on whitespace,\n:func:`split_punct_ws` will split on punctuation and\nwhitespace. This used internally by :func:`slugify`, above.\n\n>>> split_punct_ws('First post! Hi!!!!~1    ')\n['First', 'post', 'Hi', '1']"
  },
  {
    "function": "unit_len",
    "code": "def unit_len(sized_iterable, unit_noun='item'):  # TODO: len_units()/unitize()?\n    \"\"\"Returns a plain-English description of an iterable's\n    :func:`len()`, conditionally pluralized with :func:`cardinalize`,\n    detailed below.\n\n    >>> print(unit_len(range(10), 'number'))\n    10 numbers\n    >>> print(unit_len('aeiou', 'vowel'))\n    5 vowels\n    >>> print(unit_len([], 'worry'))\n    No worries\n    \"\"\"\n    count = len(sized_iterable)\n    units = cardinalize(unit_noun, count)\n    if count:\n        return f'{count} {units}'\n    return f'No {units}'",
    "docstring": "Returns a plain-English description of an iterable's\n:func:`len()`, conditionally pluralized with :func:`cardinalize`,\ndetailed below.\n\n>>> print(unit_len(range(10), 'number'))\n10 numbers\n>>> print(unit_len('aeiou', 'vowel'))\n5 vowels\n>>> print(unit_len([], 'worry'))\nNo worries"
  },
  {
    "function": "ordinalize",
    "code": "def ordinalize(number, ext_only=False):\n    \"\"\"Turns *number* into its cardinal form, i.e., 1st, 2nd,\n    3rd, 4th, etc. If the last character isn't a digit, it returns the\n    string value unchanged.\n\n    Args:\n        number (int or str): Number to be cardinalized.\n        ext_only (bool): Whether to return only the suffix. Default ``False``.\n\n    >>> print(ordinalize(1))\n    1st\n    >>> print(ordinalize(3694839230))\n    3694839230th\n    >>> print(ordinalize('hi'))\n    hi\n    >>> print(ordinalize(1515))\n    1515th\n    \"\"\"\n    numstr, ext = str(number), ''\n    if numstr and numstr[-1] in string.digits:\n        try:\n            # first check for teens\n            if numstr[-2] == '1':\n                ext = 'th'\n            else:\n                # all other cases\n                ext = _ORDINAL_MAP.get(numstr[-1], 'th')\n        except IndexError:\n            # single digit numbers (will reach here based on [-2] above)\n            ext = _ORDINAL_MAP.get(numstr[-1], 'th')\n    if ext_only:\n        return ext\n    else:\n        return numstr + ext",
    "docstring": "Turns *number* into its cardinal form, i.e., 1st, 2nd,\n3rd, 4th, etc. If the last character isn't a digit, it returns the\nstring value unchanged.\n\nArgs:\n    number (int or str): Number to be cardinalized.\n    ext_only (bool): Whether to return only the suffix. Default ``False``.\n\n>>> print(ordinalize(1))\n1st\n>>> print(ordinalize(3694839230))\n3694839230th\n>>> print(ordinalize('hi'))\nhi\n>>> print(ordinalize(1515))\n1515th"
  },
  {
    "function": "cardinalize",
    "code": "def cardinalize(unit_noun, count):\n    \"\"\"Conditionally pluralizes a singular word *unit_noun* if\n    *count* is not one, preserving case when possible.\n\n    >>> vowels = 'aeiou'\n    >>> print(len(vowels), cardinalize('vowel', len(vowels)))\n    5 vowels\n    >>> print(3, cardinalize('Wish', 3))\n    3 Wishes\n    \"\"\"\n    if count == 1:\n        return unit_noun\n    return pluralize(unit_noun)",
    "docstring": "Conditionally pluralizes a singular word *unit_noun* if\n*count* is not one, preserving case when possible.\n\n>>> vowels = 'aeiou'\n>>> print(len(vowels), cardinalize('vowel', len(vowels)))\n5 vowels\n>>> print(3, cardinalize('Wish', 3))\n3 Wishes"
  },
  {
    "function": "singularize",
    "code": "def singularize(word):\n    \"\"\"Semi-intelligently converts an English plural *word* to its\n    singular form, preserving case pattern.\n\n    >>> singularize('chances')\n    'chance'\n    >>> singularize('Activities')\n    'Activity'\n    >>> singularize('Glasses')\n    'Glass'\n    >>> singularize('FEET')\n    'FOOT'\n\n    \"\"\"\n    orig_word, word = word, word.strip().lower()\n    if not word or word in _IRR_S2P:\n        return orig_word\n\n    irr_singular = _IRR_P2S.get(word)\n    if irr_singular:\n        singular = irr_singular\n    elif not word.endswith('s'):\n        return orig_word\n    elif len(word) == 2:\n        singular = word[:-1]  # or just return word?\n    elif word.endswith('ies') and word[-4:-3] not in 'aeiou':\n        singular = word[:-3] + 'y'\n    elif word.endswith('es') and word[-3] == 's':\n        singular = word[:-2]\n    else:\n        singular = word[:-1]\n    return _match_case(orig_word, singular)",
    "docstring": "Semi-intelligently converts an English plural *word* to its\nsingular form, preserving case pattern.\n\n>>> singularize('chances')\n'chance'\n>>> singularize('Activities')\n'Activity'\n>>> singularize('Glasses')\n'Glass'\n>>> singularize('FEET')\n'FOOT'"
  },
  {
    "function": "pluralize",
    "code": "def pluralize(word):\n    \"\"\"Semi-intelligently converts an English *word* from singular form to\n    plural, preserving case pattern.\n\n    >>> pluralize('friend')\n    'friends'\n    >>> pluralize('enemy')\n    'enemies'\n    >>> pluralize('Sheep')\n    'Sheep'\n    \"\"\"\n    orig_word, word = word, word.strip().lower()\n    if not word or word in _IRR_P2S:\n        return orig_word\n    irr_plural = _IRR_S2P.get(word)\n    if irr_plural:\n        plural = irr_plural\n    elif word.endswith('y') and word[-2:-1] not in 'aeiou':\n        plural = word[:-1] + 'ies'\n    elif word[-1] == 's' or word.endswith('ch') or word.endswith('sh'):\n        plural = word if word.endswith('es') else word + 'es'\n    else:\n        plural = word + 's'\n    return _match_case(orig_word, plural)",
    "docstring": "Semi-intelligently converts an English *word* from singular form to\nplural, preserving case pattern.\n\n>>> pluralize('friend')\n'friends'\n>>> pluralize('enemy')\n'enemies'\n>>> pluralize('Sheep')\n'Sheep'"
  },
  {
    "function": "find_hashtags",
    "code": "def find_hashtags(string):\n    \"\"\"Finds and returns all hashtags in a string, with the hashmark\n    removed. Supports full-width hashmarks for Asian languages and\n    does not false-positive on URL anchors.\n\n    >>> find_hashtags('#atag http://asite/#ananchor')\n    ['atag']\n\n    ``find_hashtags`` also works with unicode hashtags.\n    \"\"\"\n\n    # the following works, doctest just struggles with it\n    # >>> find_hashtags(u\"can't get enough of that dignity chicken #\u80af\u5fb7\u57fa woo\")\n    # [u'\\u80af\\u5fb7\\u57fa']\n    return HASHTAG_RE.findall(string)",
    "docstring": "Finds and returns all hashtags in a string, with the hashmark\nremoved. Supports full-width hashmarks for Asian languages and\ndoes not false-positive on URL anchors.\n\n>>> find_hashtags('#atag http://asite/#ananchor')\n['atag']\n\n``find_hashtags`` also works with unicode hashtags."
  },
  {
    "function": "a10n",
    "code": "def a10n(string):\n    \"\"\"That thing where \"internationalization\" becomes \"i18n\", what's it\n    called? Abbreviation? Oh wait, no: ``a10n``. (It's actually a form\n    of `numeronym`_.)\n\n    >>> a10n('abbreviation')\n    'a10n'\n    >>> a10n('internationalization')\n    'i18n'\n    >>> a10n('')\n    ''\n\n    .. _numeronym: http://en.wikipedia.org/wiki/Numeronym\n    \"\"\"\n    if len(string) < 3:\n        return string\n    return f'{string[0]}{len(string[1:-1])}{string[-1]}'",
    "docstring": "That thing where \"internationalization\" becomes \"i18n\", what's it\ncalled? Abbreviation? Oh wait, no: ``a10n``. (It's actually a form\nof `numeronym`_.)\n\n>>> a10n('abbreviation')\n'a10n'\n>>> a10n('internationalization')\n'i18n'\n>>> a10n('')\n''\n\n.. _numeronym: http://en.wikipedia.org/wiki/Numeronym"
  },
  {
    "function": "strip_ansi",
    "code": "def strip_ansi(text):\n    \"\"\"Strips ANSI escape codes from *text*. Useful for the occasional\n    time when a log or redirected output accidentally captures console\n    color codes and the like.\n\n    >>> strip_ansi('\\x1b[0m\\x1b[1;36mart\\x1b[46;34m')\n    'art'\n\n    Supports str, bytes and bytearray content as input. Returns the\n    same type as the input.\n\n    There's a lot of ANSI art available for testing on `sixteencolors.net`_.\n    This function does not interpret or render ANSI art, but you can do so with\n    `ansi2img`_ or `escapes.js`_.\n\n    .. _sixteencolors.net: http://sixteencolors.net\n    .. _ansi2img: http://www.bedroomlan.org/projects/ansi2img\n    .. _escapes.js: https://github.com/atdt/escapes.js\n    \"\"\"\n    # TODO: move to cliutils.py\n\n    # Transform any ASCII-like content to unicode to allow regex to match, and\n    # save input type for later.\n    target_type = None\n    # Unicode type aliased to str is code-smell for Boltons in Python 3 env.\n    if isinstance(text, (bytes, bytearray)):\n        target_type = type(text)\n        text = text.decode('utf-8')\n\n    cleaned = ANSI_SEQUENCES.sub('', text)\n\n    # Transform back the result to the same bytearray type provided by the user.\n    if target_type and target_type != type(cleaned):\n        cleaned = target_type(cleaned, 'utf-8')\n\n    return cleaned",
    "docstring": "Strips ANSI escape codes from *text*. Useful for the occasional\ntime when a log or redirected output accidentally captures console\ncolor codes and the like.\n\n>>> strip_ansi('\u001b[0m\u001b[1;36mart\u001b[46;34m')\n'art'\n\nSupports str, bytes and bytearray content as input. Returns the\nsame type as the input.\n\nThere's a lot of ANSI art available for testing on `sixteencolors.net`_.\nThis function does not interpret or render ANSI art, but you can do so with\n`ansi2img`_ or `escapes.js`_.\n\n.. _sixteencolors.net: http://sixteencolors.net\n.. _ansi2img: http://www.bedroomlan.org/projects/ansi2img\n.. _escapes.js: https://github.com/atdt/escapes.js"
  },
  {
    "function": "asciify",
    "code": "def asciify(text, ignore=False):\n    \"\"\"Converts a unicode or bytestring, *text*, into a bytestring with\n    just ascii characters. Performs basic deaccenting for all you\n    Europhiles out there.\n\n    Also, a gentle reminder that this is a **utility**, primarily meant\n    for slugification. Whenever possible, make your application work\n    **with** unicode, not against it.\n\n    Args:\n        text (str): The string to be asciified.\n        ignore (bool): Configures final encoding to ignore remaining\n            unasciified string instead of replacing it.\n\n    >>> asciify('Beyonc\u00e9') == b'Beyonce'\n    True\n    \"\"\"\n    try:\n        try:\n            return text.encode('ascii')\n        except UnicodeDecodeError:\n            # this usually means you passed in a non-unicode string\n            text = text.decode('utf-8')\n            return text.encode('ascii')\n    except UnicodeEncodeError:\n        mode = 'replace'\n        if ignore:\n            mode = 'ignore'\n        transd = unicodedata.normalize('NFKD', text.translate(DEACCENT_MAP))\n        ret = transd.encode('ascii', mode)\n        return ret",
    "docstring": "Converts a unicode or bytestring, *text*, into a bytestring with\njust ascii characters. Performs basic deaccenting for all you\nEurophiles out there.\n\nAlso, a gentle reminder that this is a **utility**, primarily meant\nfor slugification. Whenever possible, make your application work\n**with** unicode, not against it.\n\nArgs:\n    text (str): The string to be asciified.\n    ignore (bool): Configures final encoding to ignore remaining\n        unasciified string instead of replacing it.\n\n>>> asciify('Beyonc\u00e9') == b'Beyonce'\nTrue"
  },
  {
    "function": "is_ascii",
    "code": "def is_ascii(text):\n    \"\"\"Check if a string or bytestring, *text*, is composed of ascii\n    characters only. Raises :exc:`ValueError` if argument is not text.\n\n    Args:\n        text (str): The string to be checked.\n\n    >>> is_ascii('Beyonc\u00e9')\n    False\n    >>> is_ascii('Beyonce')\n    True\n    \"\"\"\n    if isinstance(text, str):\n        try:\n            text.encode('ascii')\n        except UnicodeEncodeError:\n            return False\n    elif isinstance(text, bytes):\n        try:\n            text.decode('ascii')\n        except UnicodeDecodeError:\n            return False\n    else:\n        raise ValueError('expected text or bytes, not %r' % type(text))\n    return True",
    "docstring": "Check if a string or bytestring, *text*, is composed of ascii\ncharacters only. Raises :exc:`ValueError` if argument is not text.\n\nArgs:\n    text (str): The string to be checked.\n\n>>> is_ascii('Beyonc\u00e9')\nFalse\n>>> is_ascii('Beyonce')\nTrue"
  },
  {
    "function": "bytes2human",
    "code": "def bytes2human(nbytes, ndigits=0):\n    \"\"\"Turns an integer value of *nbytes* into a human readable format. Set\n    *ndigits* to control how many digits after the decimal point\n    should be shown (default ``0``).\n\n    >>> bytes2human(128991)\n    '126K'\n    >>> bytes2human(100001221)\n    '95M'\n    >>> bytes2human(0, 2)\n    '0.00B'\n    \"\"\"\n    abs_bytes = abs(nbytes)\n    for (size, symbol), (next_size, next_symbol) in _SIZE_RANGES:\n        if abs_bytes <= next_size:\n            break\n    hnbytes = float(nbytes) / size\n    return '{hnbytes:.{ndigits}f}{symbol}'.format(hnbytes=hnbytes,\n                                                  ndigits=ndigits,\n                                                  symbol=symbol)",
    "docstring": "Turns an integer value of *nbytes* into a human readable format. Set\n*ndigits* to control how many digits after the decimal point\nshould be shown (default ``0``).\n\n>>> bytes2human(128991)\n'126K'\n>>> bytes2human(100001221)\n'95M'\n>>> bytes2human(0, 2)\n'0.00B'"
  },
  {
    "function": "html2text",
    "code": "def html2text(html):\n    \"\"\"Strips tags from HTML text, returning markup-free text. Also, does\n    a best effort replacement of entities like \"&nbsp;\"\n\n    >>> r = html2text(u'<a href=\"#\">Test &amp;<em>(\\u0394&#x03b7;&#956;&#x03CE;)</em></a>')\n    >>> r == u'Test &(\\u0394\\u03b7\\u03bc\\u03ce)'\n    True\n    \"\"\"\n    # based on answers to http://stackoverflow.com/questions/753052/\n    s = HTMLTextExtractor()\n    s.feed(html)\n    return s.get_text()",
    "docstring": "Strips tags from HTML text, returning markup-free text. Also, does\na best effort replacement of entities like \"&nbsp;\"\n\n>>> r = html2text(u'<a href=\"#\">Test &amp;<em>(\u0394&#x03b7;&#956;&#x03CE;)</em></a>')\n>>> r == u'Test &(\u0394\u03b7\u03bc\u03ce)'\nTrue"
  },
  {
    "function": "gunzip_bytes",
    "code": "def gunzip_bytes(bytestring):\n    \"\"\"The :mod:`gzip` module is great if you have a file or file-like\n    object, but what if you just have bytes. StringIO is one\n    possibility, but it's often faster, easier, and simpler to just\n    use this one-liner. Use this tried-and-true utility function to\n    decompress gzip from bytes.\n\n    >>> gunzip_bytes(_EMPTY_GZIP_BYTES) == b''\n    True\n    >>> gunzip_bytes(_NON_EMPTY_GZIP_BYTES).rstrip() == b'bytesahoy!'\n    True\n    \"\"\"\n    return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)",
    "docstring": "The :mod:`gzip` module is great if you have a file or file-like\nobject, but what if you just have bytes. StringIO is one\npossibility, but it's often faster, easier, and simpler to just\nuse this one-liner. Use this tried-and-true utility function to\ndecompress gzip from bytes.\n\n>>> gunzip_bytes(_EMPTY_GZIP_BYTES) == b''\nTrue\n>>> gunzip_bytes(_NON_EMPTY_GZIP_BYTES).rstrip() == b'bytesahoy!'\nTrue"
  },
  {
    "function": "gzip_bytes",
    "code": "def gzip_bytes(bytestring, level=6):\n    \"\"\"Turn some bytes into some compressed bytes.\n\n    >>> len(gzip_bytes(b'a' * 10000))\n    46\n\n    Args:\n        bytestring (bytes): Bytes to be compressed\n        level (int): An integer, 1-9, controlling the\n          speed/compression. 1 is fastest, least compressed, 9 is\n          slowest, but most compressed.\n\n    Note that all levels of gzip are pretty fast these days, though\n    it's not really a competitor in compression, at any level.\n    \"\"\"\n    out = StringIO()\n    f = GzipFile(fileobj=out, mode='wb', compresslevel=level)\n    f.write(bytestring)\n    f.close()\n    return out.getvalue()",
    "docstring": "Turn some bytes into some compressed bytes.\n\n>>> len(gzip_bytes(b'a' * 10000))\n46\n\nArgs:\n    bytestring (bytes): Bytes to be compressed\n    level (int): An integer, 1-9, controlling the\n      speed/compression. 1 is fastest, least compressed, 9 is\n      slowest, but most compressed.\n\nNote that all levels of gzip are pretty fast these days, though\nit's not really a competitor in compression, at any level."
  },
  {
    "function": "iter_splitlines",
    "code": "def iter_splitlines(text):\n    r\"\"\"Like :meth:`str.splitlines`, but returns an iterator of lines\n    instead of a list. Also similar to :meth:`file.next`, as that also\n    lazily reads and yields lines from a file.\n\n    This function works with a variety of line endings, but as always,\n    be careful when mixing line endings within a file.\n\n    >>> list(iter_splitlines('\\nhi\\nbye\\n'))\n    ['', 'hi', 'bye', '']\n    >>> list(iter_splitlines('\\r\\nhi\\rbye\\r\\n'))\n    ['', 'hi', 'bye', '']\n    >>> list(iter_splitlines(''))\n    []\n    \"\"\"\n    prev_end, len_text = 0, len(text)\n    # print('last: %r' % last_idx)\n    # start, end = None, None\n    for match in _line_ending_re.finditer(text):\n        start, end = match.start(1), match.end(1)\n        # print(start, end)\n        if prev_end <= start:\n            yield text[prev_end:start]\n        if end == len_text:\n            yield ''\n        prev_end = end\n    tail = text[prev_end:]\n    if tail:\n        yield tail\n    return",
    "docstring": "Like :meth:`str.splitlines`, but returns an iterator of lines\ninstead of a list. Also similar to :meth:`file.next`, as that also\nlazily reads and yields lines from a file.\n\nThis function works with a variety of line endings, but as always,\nbe careful when mixing line endings within a file.\n\n>>> list(iter_splitlines('\\nhi\\nbye\\n'))\n['', 'hi', 'bye', '']\n>>> list(iter_splitlines('\\r\\nhi\\rbye\\r\\n'))\n['', 'hi', 'bye', '']\n>>> list(iter_splitlines(''))\n[]"
  },
  {
    "function": "indent",
    "code": "def indent(text, margin, newline='\\n', key=bool):\n    \"\"\"The missing counterpart to the built-in :func:`textwrap.dedent`.\n\n    Args:\n        text (str): The text to indent.\n        margin (str): The string to prepend to each line.\n        newline (str): The newline used to rejoin the lines (default: ``\\\\n``)\n        key (callable): Called on each line to determine whether to\n          indent it. Default: :class:`bool`, to ensure that empty lines do\n          not get whitespace added.\n    \"\"\"\n    indented_lines = [(margin + line if key(line) else line)\n                      for line in iter_splitlines(text)]\n    return newline.join(indented_lines)",
    "docstring": "The missing counterpart to the built-in :func:`textwrap.dedent`.\n\nArgs:\n    text (str): The text to indent.\n    margin (str): The string to prepend to each line.\n    newline (str): The newline used to rejoin the lines (default: ``\\n``)\n    key (callable): Called on each line to determine whether to\n      indent it. Default: :class:`bool`, to ensure that empty lines do\n      not get whitespace added."
  },
  {
    "function": "is_uuid",
    "code": "def is_uuid(obj, version=4):\n    \"\"\"Check the argument is either a valid UUID object or string.\n\n    Args:\n        obj (object): The test target. Strings and UUID objects supported.\n        version (int): The target UUID version, set to 0 to skip version check.\n\n    >>> is_uuid('e682ccca-5a4c-4ef2-9711-73f9ad1e15ea')\n    True\n    >>> is_uuid('0221f0d9-d4b9-11e5-a478-10ddb1c2feb9')\n    False\n    >>> is_uuid('0221f0d9-d4b9-11e5-a478-10ddb1c2feb9', version=1)\n    True\n    \"\"\"\n    if not isinstance(obj, uuid.UUID):\n        try:\n            obj = uuid.UUID(obj)\n        except (TypeError, ValueError, AttributeError):\n            return False\n    if version and obj.version != int(version):\n        return False\n    return True",
    "docstring": "Check the argument is either a valid UUID object or string.\n\nArgs:\n    obj (object): The test target. Strings and UUID objects supported.\n    version (int): The target UUID version, set to 0 to skip version check.\n\n>>> is_uuid('e682ccca-5a4c-4ef2-9711-73f9ad1e15ea')\nTrue\n>>> is_uuid('0221f0d9-d4b9-11e5-a478-10ddb1c2feb9')\nFalse\n>>> is_uuid('0221f0d9-d4b9-11e5-a478-10ddb1c2feb9', version=1)\nTrue"
  },
  {
    "function": "escape_shell_args",
    "code": "def escape_shell_args(args, sep=' ', style=None):\n    \"\"\"Returns an escaped version of each string in *args*, according to\n    *style*.\n\n    Args:\n        args (list): A list of arguments to escape and join together\n        sep (str): The separator used to join the escaped arguments.\n        style (str): The style of escaping to use. Can be one of\n          ``cmd`` or ``sh``, geared toward Windows and Linux/BSD/etc.,\n          respectively. If *style* is ``None``, then it is picked\n          according to the system platform.\n\n    See :func:`args2cmd` and :func:`args2sh` for details and example\n    output for each style.\n    \"\"\"\n    if not style:\n        style = 'cmd' if sys.platform == 'win32' else 'sh'\n\n    if style == 'sh':\n        return args2sh(args, sep=sep)\n    elif style == 'cmd':\n        return args2cmd(args, sep=sep)\n\n    raise ValueError(\"style expected one of 'cmd' or 'sh', not %r\" % style)",
    "docstring": "Returns an escaped version of each string in *args*, according to\n*style*.\n\nArgs:\n    args (list): A list of arguments to escape and join together\n    sep (str): The separator used to join the escaped arguments.\n    style (str): The style of escaping to use. Can be one of\n      ``cmd`` or ``sh``, geared toward Windows and Linux/BSD/etc.,\n      respectively. If *style* is ``None``, then it is picked\n      according to the system platform.\n\nSee :func:`args2cmd` and :func:`args2sh` for details and example\noutput for each style."
  },
  {
    "function": "args2sh",
    "code": "def args2sh(args, sep=' '):\n    \"\"\"Return a shell-escaped string version of *args*, separated by\n    *sep*, based on the rules of sh, bash, and other shells in the\n    Linux/BSD/MacOS ecosystem.\n\n    >>> print(args2sh(['aa', '[bb]', \"cc'cc\", 'dd\"dd']))\n    aa '[bb]' 'cc'\"'\"'cc' 'dd\"dd'\n\n    As you can see, arguments with no special characters are not\n    escaped, arguments with special characters are quoted with single\n    quotes, and single quotes themselves are quoted with double\n    quotes. Double quotes are handled like any other special\n    character.\n\n    Based on code from the :mod:`pipes`/:mod:`shlex` modules. Also\n    note that :mod:`shlex` and :mod:`argparse` have functions to split\n    and parse strings escaped in this manner.\n    \"\"\"\n    ret_list = []\n\n    for arg in args:\n        if not arg:\n            ret_list.append(\"''\")\n            continue\n        if _find_sh_unsafe(arg) is None:\n            ret_list.append(arg)\n            continue\n        # use single quotes, and put single quotes into double quotes\n        # the string $'b is then quoted as '$'\"'\"'b'\n        ret_list.append(\"'\" + arg.replace(\"'\", \"'\\\"'\\\"'\") + \"'\")\n\n    return ' '.join(ret_list)",
    "docstring": "Return a shell-escaped string version of *args*, separated by\n*sep*, based on the rules of sh, bash, and other shells in the\nLinux/BSD/MacOS ecosystem.\n\n>>> print(args2sh(['aa', '[bb]', \"cc'cc\", 'dd\"dd']))\naa '[bb]' 'cc'\"'\"'cc' 'dd\"dd'\n\nAs you can see, arguments with no special characters are not\nescaped, arguments with special characters are quoted with single\nquotes, and single quotes themselves are quoted with double\nquotes. Double quotes are handled like any other special\ncharacter.\n\nBased on code from the :mod:`pipes`/:mod:`shlex` modules. Also\nnote that :mod:`shlex` and :mod:`argparse` have functions to split\nand parse strings escaped in this manner."
  },
  {
    "function": "args2cmd",
    "code": "def args2cmd(args, sep=' '):\n    r\"\"\"Return a shell-escaped string version of *args*, separated by\n    *sep*, using the same rules as the Microsoft C runtime.\n\n    >>> print(args2cmd(['aa', '[bb]', \"cc'cc\", 'dd\"dd']))\n    aa [bb] cc'cc dd\\\"dd\n\n    As you can see, escaping is through backslashing and not quoting,\n    and double quotes are the only special character. See the comment\n    in the code for more details. Based on internal code from the\n    :mod:`subprocess` module.\n\n    \"\"\"\n    # technique description from subprocess below\n    \"\"\"\n    1) Arguments are delimited by white space, which is either a\n       space or a tab.\n\n    2) A string surrounded by double quotation marks is\n       interpreted as a single argument, regardless of white space\n       contained within.  A quoted string can be embedded in an\n       argument.\n\n    3) A double quotation mark preceded by a backslash is\n       interpreted as a literal double quotation mark.\n\n    4) Backslashes are interpreted literally, unless they\n       immediately precede a double quotation mark.\n\n    5) If backslashes immediately precede a double quotation mark,\n       every pair of backslashes is interpreted as a literal\n       backslash.  If the number of backslashes is odd, the last\n       backslash escapes the next double quotation mark as\n       described in rule 3.\n\n    See http://msdn.microsoft.com/en-us/library/17w5ykft.aspx\n    or search http://msdn.microsoft.com for\n    \"Parsing C++ Command-Line Arguments\"\n    \"\"\"\n    result = []\n    needquote = False\n    for arg in args:\n        bs_buf = []\n\n        # Add a space to separate this argument from the others\n        if result:\n            result.append(' ')\n\n        needquote = (\" \" in arg) or (\"\\t\" in arg) or not arg\n        if needquote:\n            result.append('\"')\n\n        for c in arg:\n            if c == '\\\\':\n                # Don't know if we need to double yet.\n                bs_buf.append(c)\n            elif c == '\"':\n                # Double backslashes.\n                result.append('\\\\' * len(bs_buf)*2)\n                bs_buf = []\n                result.append('\\\\\"')\n            else:\n                # Normal char\n                if bs_buf:\n                    result.extend(bs_buf)\n                    bs_buf = []\n                result.append(c)\n\n        # Add remaining backslashes, if any.\n        if bs_buf:\n            result.extend(bs_buf)\n\n        if needquote:\n            result.extend(bs_buf)\n            result.append('\"')\n\n    return ''.join(result)",
    "docstring": "Return a shell-escaped string version of *args*, separated by\n*sep*, using the same rules as the Microsoft C runtime.\n\n>>> print(args2cmd(['aa', '[bb]', \"cc'cc\", 'dd\"dd']))\naa [bb] cc'cc dd\\\"dd\n\nAs you can see, escaping is through backslashing and not quoting,\nand double quotes are the only special character. See the comment\nin the code for more details. Based on internal code from the\n:mod:`subprocess` module."
  },
  {
    "function": "parse_int_list",
    "code": "def parse_int_list(range_string, delim=',', range_delim='-'):\n    \"\"\"Returns a sorted list of positive integers based on\n    *range_string*. Reverse of :func:`format_int_list`.\n\n    Args:\n        range_string (str): String of comma separated positive\n            integers or ranges (e.g. '1,2,4-6,8'). Typical of a custom\n            page range string used in printer dialogs.\n        delim (char): Defaults to ','. Separates integers and\n            contiguous ranges of integers.\n        range_delim (char): Defaults to '-'. Indicates a contiguous\n            range of integers.\n\n    >>> parse_int_list('1,3,5-8,10-11,15')\n    [1, 3, 5, 6, 7, 8, 10, 11, 15]\n\n    \"\"\"\n    output = []\n\n    for x in range_string.strip().split(delim):\n\n        # Range\n        if range_delim in x:\n            range_limits = list(map(int, x.split(range_delim)))\n            output += list(range(min(range_limits), max(range_limits)+1))\n\n        # Empty String\n        elif not x:\n            continue\n\n        # Integer\n        else:\n            output.append(int(x))\n\n    return sorted(output)",
    "docstring": "Returns a sorted list of positive integers based on\n*range_string*. Reverse of :func:`format_int_list`.\n\nArgs:\n    range_string (str): String of comma separated positive\n        integers or ranges (e.g. '1,2,4-6,8'). Typical of a custom\n        page range string used in printer dialogs.\n    delim (char): Defaults to ','. Separates integers and\n        contiguous ranges of integers.\n    range_delim (char): Defaults to '-'. Indicates a contiguous\n        range of integers.\n\n>>> parse_int_list('1,3,5-8,10-11,15')\n[1, 3, 5, 6, 7, 8, 10, 11, 15]"
  },
  {
    "function": "format_int_list",
    "code": "def format_int_list(int_list, delim=',', range_delim='-', delim_space=False):\n    \"\"\"Returns a sorted range string from a list of positive integers\n    (*int_list*). Contiguous ranges of integers are collapsed to min\n    and max values. Reverse of :func:`parse_int_list`.\n\n    Args:\n        int_list (list): List of positive integers to be converted\n           into a range string (e.g. [1,2,4,5,6,8]).\n        delim (char): Defaults to ','. Separates integers and\n           contiguous ranges of integers.\n        range_delim (char): Defaults to '-'. Indicates a contiguous\n           range of integers.\n        delim_space (bool): Defaults to ``False``. If ``True``, adds a\n           space after all *delim* characters.\n\n    >>> format_int_list([1,3,5,6,7,8,10,11,15])\n    '1,3,5-8,10-11,15'\n\n    \"\"\"\n    output = []\n    contig_range = collections.deque()\n\n    for x in sorted(int_list):\n\n        # Handle current (and first) value.\n        if len(contig_range) < 1:\n            contig_range.append(x)\n\n        # Handle current value, given multiple previous values are contiguous.\n        elif len(contig_range) > 1:\n            delta = x - contig_range[-1]\n\n            # Current value is contiguous.\n            if delta == 1:\n                contig_range.append(x)\n\n            # Current value is non-contiguous.\n            elif delta > 1:\n                range_substr = '{:d}{}{:d}'.format(min(contig_range),\n                                                      range_delim,\n                                                      max(contig_range))\n                output.append(range_substr)\n                contig_range.clear()\n                contig_range.append(x)\n\n            # Current value repeated.\n            else:\n                continue\n\n        # Handle current value, given no previous contiguous integers\n        else:\n            delta = x - contig_range[0]\n\n            # Current value is contiguous.\n            if delta == 1:\n                contig_range.append(x)\n\n            # Current value is non-contiguous.\n            elif delta > 1:\n                output.append(f'{contig_range.popleft():d}')\n                contig_range.append(x)\n\n            # Current value repeated.\n            else:\n                continue\n\n    # Handle the last value.\n    else:\n\n        # Last value is non-contiguous.\n        if len(contig_range) == 1:\n            output.append(f'{contig_range.popleft():d}')\n            contig_range.clear()\n\n        # Last value is part of contiguous range.\n        elif len(contig_range) > 1:\n            range_substr = '{:d}{}{:d}'.format(min(contig_range),\n                                                  range_delim,\n                                                  max(contig_range))\n            output.append(range_substr)\n            contig_range.clear()\n\n    if delim_space:\n        output_str = (delim+' ').join(output)\n    else:\n        output_str = delim.join(output)\n\n    return output_str",
    "docstring": "Returns a sorted range string from a list of positive integers\n(*int_list*). Contiguous ranges of integers are collapsed to min\nand max values. Reverse of :func:`parse_int_list`.\n\nArgs:\n    int_list (list): List of positive integers to be converted\n       into a range string (e.g. [1,2,4,5,6,8]).\n    delim (char): Defaults to ','. Separates integers and\n       contiguous ranges of integers.\n    range_delim (char): Defaults to '-'. Indicates a contiguous\n       range of integers.\n    delim_space (bool): Defaults to ``False``. If ``True``, adds a\n       space after all *delim* characters.\n\n>>> format_int_list([1,3,5,6,7,8,10,11,15])\n'1,3,5-8,10-11,15'"
  },
  {
    "function": "complement_int_list",
    "code": "def complement_int_list(\n        range_string, range_start=0, range_end=None,\n        delim=',', range_delim='-'):\n    \"\"\" Returns range string that is the complement of the one provided as\n    *range_string* parameter.\n\n    These range strings are of the kind produce by :func:`format_int_list`, and\n    parseable by :func:`parse_int_list`.\n\n    Args:\n        range_string (str): String of comma separated positive integers or\n           ranges (e.g. '1,2,4-6,8'). Typical of a custom page range string\n           used in printer dialogs.\n        range_start (int): A positive integer from which to start the resulting\n           range. Value is inclusive. Defaults to ``0``.\n        range_end (int): A positive integer from which the produced range is\n           stopped. Value is exclusive. Defaults to the maximum value found in\n           the provided ``range_string``.\n        delim (char): Defaults to ','. Separates integers and contiguous ranges\n           of integers.\n        range_delim (char): Defaults to '-'. Indicates a contiguous range of\n           integers.\n\n    >>> complement_int_list('1,3,5-8,10-11,15')\n    '0,2,4,9,12-14'\n\n    >>> complement_int_list('1,3,5-8,10-11,15', range_start=0)\n    '0,2,4,9,12-14'\n\n    >>> complement_int_list('1,3,5-8,10-11,15', range_start=1)\n    '2,4,9,12-14'\n\n    >>> complement_int_list('1,3,5-8,10-11,15', range_start=2)\n    '2,4,9,12-14'\n\n    >>> complement_int_list('1,3,5-8,10-11,15', range_start=3)\n    '4,9,12-14'\n\n    >>> complement_int_list('1,3,5-8,10-11,15', range_end=15)\n    '0,2,4,9,12-14'\n\n    >>> complement_int_list('1,3,5-8,10-11,15', range_end=14)\n    '0,2,4,9,12-13'\n\n    >>> complement_int_list('1,3,5-8,10-11,15', range_end=13)\n    '0,2,4,9,12'\n\n    >>> complement_int_list('1,3,5-8,10-11,15', range_end=20)\n    '0,2,4,9,12-14,16-19'\n\n    >>> complement_int_list('1,3,5-8,10-11,15', range_end=0)\n    ''\n\n    >>> complement_int_list('1,3,5-8,10-11,15', range_start=-1)\n    '0,2,4,9,12-14'\n\n    >>> complement_int_list('1,3,5-8,10-11,15', range_end=-1)\n    ''\n\n    >>> complement_int_list('1,3,5-8', range_start=1, range_end=1)\n    ''\n\n    >>> complement_int_list('1,3,5-8', range_start=2, range_end=2)\n    ''\n\n    >>> complement_int_list('1,3,5-8', range_start=2, range_end=3)\n    '2'\n\n    >>> complement_int_list('1,3,5-8', range_start=-10, range_end=-5)\n    ''\n\n    >>> complement_int_list('1,3,5-8', range_start=20, range_end=10)\n    ''\n\n    >>> complement_int_list('')\n    ''\n    \"\"\"\n    int_list = set(parse_int_list(range_string, delim, range_delim))\n    if range_end is None:\n        if int_list:\n            range_end = max(int_list) + 1\n        else:\n            range_end = range_start\n    complement_values = set(\n        range(range_end)) - int_list - set(range(range_start))\n    return format_int_list(complement_values, delim, range_delim)",
    "docstring": "Returns range string that is the complement of the one provided as\n*range_string* parameter.\n\nThese range strings are of the kind produce by :func:`format_int_list`, and\nparseable by :func:`parse_int_list`.\n\nArgs:\n    range_string (str): String of comma separated positive integers or\n       ranges (e.g. '1,2,4-6,8'). Typical of a custom page range string\n       used in printer dialogs.\n    range_start (int): A positive integer from which to start the resulting\n       range. Value is inclusive. Defaults to ``0``.\n    range_end (int): A positive integer from which the produced range is\n       stopped. Value is exclusive. Defaults to the maximum value found in\n       the provided ``range_string``.\n    delim (char): Defaults to ','. Separates integers and contiguous ranges\n       of integers.\n    range_delim (char): Defaults to '-'. Indicates a contiguous range of\n       integers.\n\n>>> complement_int_list('1,3,5-8,10-11,15')\n'0,2,4,9,12-14'\n\n>>> complement_int_list('1,3,5-8,10-11,15', range_start=0)\n'0,2,4,9,12-14'\n\n>>> complement_int_list('1,3,5-8,10-11,15', range_start=1)\n'2,4,9,12-14'\n\n>>> complement_int_list('1,3,5-8,10-11,15', range_start=2)\n'2,4,9,12-14'\n\n>>> complement_int_list('1,3,5-8,10-11,15', range_start=3)\n'4,9,12-14'\n\n>>> complement_int_list('1,3,5-8,10-11,15', range_end=15)\n'0,2,4,9,12-14'\n\n>>> complement_int_list('1,3,5-8,10-11,15', range_end=14)\n'0,2,4,9,12-13'\n\n>>> complement_int_list('1,3,5-8,10-11,15', range_end=13)\n'0,2,4,9,12'\n\n>>> complement_int_list('1,3,5-8,10-11,15', range_end=20)\n'0,2,4,9,12-14,16-19'\n\n>>> complement_int_list('1,3,5-8,10-11,15', range_end=0)\n''\n\n>>> complement_int_list('1,3,5-8,10-11,15', range_start=-1)\n'0,2,4,9,12-14'\n\n>>> complement_int_list('1,3,5-8,10-11,15', range_end=-1)\n''\n\n>>> complement_int_list('1,3,5-8', range_start=1, range_end=1)\n''\n\n>>> complement_int_list('1,3,5-8', range_start=2, range_end=2)\n''\n\n>>> complement_int_list('1,3,5-8', range_start=2, range_end=3)\n'2'\n\n>>> complement_int_list('1,3,5-8', range_start=-10, range_end=-5)\n''\n\n>>> complement_int_list('1,3,5-8', range_start=20, range_end=10)\n''\n\n>>> complement_int_list('')\n''"
  },
  {
    "function": "int_ranges_from_int_list",
    "code": "def int_ranges_from_int_list(range_string, delim=',', range_delim='-'):\n    \"\"\" Transform a string of ranges (*range_string*) into a tuple of tuples.\n\n    Args:\n        range_string (str): String of comma separated positive integers or\n           ranges (e.g. '1,2,4-6,8'). Typical of a custom page range string\n           used in printer dialogs.\n        delim (char): Defaults to ','. Separates integers and contiguous ranges\n           of integers.\n        range_delim (char): Defaults to '-'. Indicates a contiguous range of\n           integers.\n\n    >>> int_ranges_from_int_list('1,3,5-8,10-11,15')\n    ((1, 1), (3, 3), (5, 8), (10, 11), (15, 15))\n\n    >>> int_ranges_from_int_list('1')\n    ((1, 1),)\n\n    >>> int_ranges_from_int_list('')\n    ()\n    \"\"\"\n    int_tuples = []\n    # Normalize the range string to our internal format for processing.\n    range_string = format_int_list(\n        parse_int_list(range_string, delim, range_delim))\n    if range_string:\n        for bounds in range_string.split(','):\n            if '-' in bounds:\n                start, end = bounds.split('-')\n            else:\n                start, end = bounds, bounds\n            int_tuples.append((int(start), int(end)))\n    return tuple(int_tuples)",
    "docstring": "Transform a string of ranges (*range_string*) into a tuple of tuples.\n\nArgs:\n    range_string (str): String of comma separated positive integers or\n       ranges (e.g. '1,2,4-6,8'). Typical of a custom page range string\n       used in printer dialogs.\n    delim (char): Defaults to ','. Separates integers and contiguous ranges\n       of integers.\n    range_delim (char): Defaults to '-'. Indicates a contiguous range of\n       integers.\n\n>>> int_ranges_from_int_list('1,3,5-8,10-11,15')\n((1, 1), (3, 3), (5, 8), (10, 11), (15, 15))\n\n>>> int_ranges_from_int_list('1')\n((1, 1),)\n\n>>> int_ranges_from_int_list('')\n()"
  },
  {
    "function": "multi_replace",
    "code": "def multi_replace(text, sub_map, **kwargs):\n    \"\"\"\n    Shortcut function to invoke MultiReplace in a single call.\n\n    Example Usage::\n\n        from boltons.strutils import multi_replace\n        new = multi_replace(\n            'The foo bar cat ate a bat',\n            {'foo': 'zoo', 'cat': 'hat', 'bat': 'kraken'}\n        )\n        new == 'The zoo bar hat ate a kraken'\n    \"\"\"\n    m = MultiReplace(sub_map, **kwargs)\n    return m.sub(text)",
    "docstring": "Shortcut function to invoke MultiReplace in a single call.\n\nExample Usage::\n\n    from boltons.strutils import multi_replace\n    new = multi_replace(\n        'The foo bar cat ate a bat',\n        {'foo': 'zoo', 'cat': 'hat', 'bat': 'kraken'}\n    )\n    new == 'The zoo bar hat ate a kraken'"
  },
  {
    "function": "unwrap_text",
    "code": "def unwrap_text(text, ending='\\n\\n'):\n    r\"\"\"\n    Unwrap text, the natural complement to :func:`textwrap.wrap`.\n\n    >>> text = \"Short \\n lines  \\nwrapped\\nsmall.\\n\\nAnother\\nparagraph.\"\n    >>> unwrap_text(text)\n    'Short lines wrapped small.\\n\\nAnother paragraph.'\n\n    Args:\n       text: A string to unwrap.\n       ending (str): The string to join all unwrapped paragraphs\n          by. Pass ``None`` to get the list. Defaults to '\\n\\n' for\n          compatibility with Markdown and RST.\n\n    \"\"\"\n    all_grafs = []\n    cur_graf = []\n    for line in text.splitlines():\n        line = line.strip()\n        if line:\n            cur_graf.append(line)\n        else:\n            all_grafs.append(' '.join(cur_graf))\n            cur_graf = []\n    if cur_graf:\n        all_grafs.append(' '.join(cur_graf))\n    if ending is None:\n        return all_grafs\n    return ending.join(all_grafs)",
    "docstring": "Unwrap text, the natural complement to :func:`textwrap.wrap`.\n\n>>> text = \"Short \\n lines  \\nwrapped\\nsmall.\\n\\nAnother\\nparagraph.\"\n>>> unwrap_text(text)\n'Short lines wrapped small.\\n\\nAnother paragraph.'\n\nArgs:\n   text: A string to unwrap.\n   ending (str): The string to join all unwrapped paragraphs\n      by. Pass ``None`` to get the list. Defaults to '\\n\\n' for\n      compatibility with Markdown and RST."
  },
  {
    "function": "removeprefix",
    "code": "def removeprefix(text: str, prefix: str) -> str:\n    r\"\"\"\n    Remove `prefix` from start of `text` if present.\n\n    Backport of `str.removeprefix` for Python versions less than 3.9.\n\n    Args:\n        text: A string to remove the prefix from.\n        prefix: The string to remove from the beginning of `text`.\n    \"\"\"\n    if text.startswith(prefix):\n        return text[len(prefix):]\n    return text",
    "docstring": "Remove `prefix` from start of `text` if present.\n\nBackport of `str.removeprefix` for Python versions less than 3.9.\n\nArgs:\n    text: A string to remove the prefix from.\n    prefix: The string to remove from the beginning of `text`."
  },
  {
    "function": "format_exception_only",
    "code": "def format_exception_only(etype, value):\n    \"\"\"Format the exception part of a traceback.\n\n    The arguments are the exception type and value such as given by\n    sys.last_type and sys.last_value. The return value is a list of\n    strings, each ending in a newline.\n\n    Normally, the list contains a single string; however, for\n    SyntaxError exceptions, it contains several lines that (when\n    printed) display detailed information about where the syntax\n    error occurred.\n\n    The message indicating which exception occurred is always the last\n    string in the list.\n\n    \"\"\"\n    # Gracefully handle (the way Python 2.4 and earlier did) the case of\n    # being called with (None, None).\n    if etype is None:\n        return [_format_final_exc_line(etype, value)]\n\n    stype = etype.__name__\n    smod = etype.__module__\n    if smod not in (\"__main__\", \"builtins\", \"exceptions\"):\n        stype = smod + '.' + stype\n\n    if not issubclass(etype, SyntaxError):\n        return [_format_final_exc_line(stype, value)]\n\n    # It was a syntax error; show exactly where the problem was found.\n    lines = []\n    filename = value.filename or \"<string>\"\n    lineno = str(value.lineno) or '?'\n    lines.append(f'  File \"{filename}\", line {lineno}\\n')\n    badline = value.text\n    offset = value.offset\n    if badline is not None:\n        lines.append('    %s\\n' % badline.strip())\n        if offset is not None:\n            caretspace = badline.rstrip('\\n')[:offset].lstrip()\n            # non-space whitespace (likes tabs) must be kept for alignment\n            caretspace = ((c.isspace() and c or ' ') for c in caretspace)\n            # only three spaces to account for offset1 == pos 0\n            lines.append('   %s^\\n' % ''.join(caretspace))\n    msg = value.msg or \"<no detail available>\"\n    lines.append(f\"{stype}: {msg}\\n\")\n    return lines",
    "docstring": "Format the exception part of a traceback.\n\nThe arguments are the exception type and value such as given by\nsys.last_type and sys.last_value. The return value is a list of\nstrings, each ending in a newline.\n\nNormally, the list contains a single string; however, for\nSyntaxError exceptions, it contains several lines that (when\nprinted) display detailed information about where the syntax\nerror occurred.\n\nThe message indicating which exception occurred is always the last\nstring in the list."
  },
  {
    "function": "print_exception",
    "code": "def print_exception(etype, value, tb, limit=None, file=None):\n    \"\"\"Print exception up to 'limit' stack trace entries from 'tb' to 'file'.\n\n    This differs from print_tb() in the following ways: (1) if\n    traceback is not None, it prints a header \"Traceback (most recent\n    call last):\"; (2) it prints the exception type and value after the\n    stack trace; (3) if type is SyntaxError and value has the\n    appropriate format, it prints the line where the syntax error\n    occurred with a caret on the next line indicating the approximate\n    position of the error.\n    \"\"\"\n\n    if file is None:\n        file = sys.stderr\n    if tb:\n        tbi = TracebackInfo.from_traceback(tb, limit)\n        print(str(tbi), end='', file=file)\n\n    for line in format_exception_only(etype, value):\n        print(line, end='', file=file)",
    "docstring": "Print exception up to 'limit' stack trace entries from 'tb' to 'file'.\n\nThis differs from print_tb() in the following ways: (1) if\ntraceback is not None, it prints a header \"Traceback (most recent\ncall last):\"; (2) it prints the exception type and value after the\nstack trace; (3) if type is SyntaxError and value has the\nappropriate format, it prints the line where the syntax error\noccurred with a caret on the next line indicating the approximate\nposition of the error."
  },
  {
    "function": "fix_print_exception",
    "code": "def fix_print_exception():\n    \"\"\"\n    Sets the default exception hook :func:`sys.excepthook` to the\n    :func:`tbutils.print_exception` that uses all the ``tbutils``\n    facilities to provide a consistent output behavior.\n    \"\"\"\n    sys.excepthook = print_exception",
    "docstring": "Sets the default exception hook :func:`sys.excepthook` to the\n:func:`tbutils.print_exception` that uses all the ``tbutils``\nfacilities to provide a consistent output behavior."
  },
  {
    "function": "dt_to_timestamp",
    "code": "def dt_to_timestamp(dt):\n    \"\"\"Converts from a :class:`~datetime.datetime` object to an integer\n    timestamp, suitable interoperation with :func:`time.time` and\n    other `Epoch-based timestamps`.\n\n    .. _Epoch-based timestamps: https://en.wikipedia.org/wiki/Unix_time\n\n    >>> timestamp = int(time.time())\n    >>> utc_dt = datetime.fromtimestamp(timestamp, timezone.utc)\n    >>> timestamp - dt_to_timestamp(utc_dt)\n    0.0\n\n    ``dt_to_timestamp`` supports both timezone-aware and na\u00efve\n    :class:`~datetime.datetime` objects. Note that it assumes na\u00efve\n    datetime objects are implied UTC, such as those generated with\n    :meth:`datetime.datetime.utcnow`. If your datetime objects are\n    local time, such as those generated with\n    :meth:`datetime.datetime.now`, first convert it using the\n    :meth:`datetime.datetime.replace` method with ``tzinfo=``\n    :class:`LocalTZ` object in this module, then pass the result of\n    that to ``dt_to_timestamp``.\n    \"\"\"\n    if dt.tzinfo:\n        td = dt - EPOCH_AWARE\n    else:\n        td = dt.replace(tzinfo=timezone.utc) - EPOCH_AWARE\n    return timedelta.total_seconds(td)",
    "docstring": "Converts from a :class:`~datetime.datetime` object to an integer\ntimestamp, suitable interoperation with :func:`time.time` and\nother `Epoch-based timestamps`.\n\n.. _Epoch-based timestamps: https://en.wikipedia.org/wiki/Unix_time\n\n>>> timestamp = int(time.time())\n>>> utc_dt = datetime.fromtimestamp(timestamp, timezone.utc)\n>>> timestamp - dt_to_timestamp(utc_dt)\n0.0\n\n``dt_to_timestamp`` supports both timezone-aware and na\u00efve\n:class:`~datetime.datetime` objects. Note that it assumes na\u00efve\ndatetime objects are implied UTC, such as those generated with\n:meth:`datetime.datetime.utcnow`. If your datetime objects are\nlocal time, such as those generated with\n:meth:`datetime.datetime.now`, first convert it using the\n:meth:`datetime.datetime.replace` method with ``tzinfo=``\n:class:`LocalTZ` object in this module, then pass the result of\nthat to ``dt_to_timestamp``."
  },
  {
    "function": "isoparse",
    "code": "def isoparse(iso_str):\n    \"\"\"Parses the limited subset of `ISO8601-formatted time`_ strings as\n    returned by :meth:`datetime.datetime.isoformat`.\n\n    >>> epoch_dt = datetime.fromtimestamp(0, timezone.utc).replace(tzinfo=None)\n    >>> iso_str = epoch_dt.isoformat()\n    >>> print(iso_str)\n    1970-01-01T00:00:00\n    >>> isoparse(iso_str)\n    datetime.datetime(1970, 1, 1, 0, 0)\n\n    >>> utcnow = datetime.now(timezone.utc).replace(tzinfo=None)\n    >>> utcnow == isoparse(utcnow.isoformat())\n    True\n\n    For further datetime parsing, see the `iso8601`_ package for strict\n    ISO parsing and `dateutil`_ package for loose parsing and more.\n\n    .. _ISO8601-formatted time: https://en.wikipedia.org/wiki/ISO_8601\n    .. _iso8601: https://pypi.python.org/pypi/iso8601\n    .. _dateutil: https://pypi.python.org/pypi/python-dateutil\n\n    \"\"\"\n    dt_args = [int(p) for p in _NONDIGIT_RE.split(iso_str)]\n    return datetime(*dt_args)",
    "docstring": "Parses the limited subset of `ISO8601-formatted time`_ strings as\nreturned by :meth:`datetime.datetime.isoformat`.\n\n>>> epoch_dt = datetime.fromtimestamp(0, timezone.utc).replace(tzinfo=None)\n>>> iso_str = epoch_dt.isoformat()\n>>> print(iso_str)\n1970-01-01T00:00:00\n>>> isoparse(iso_str)\ndatetime.datetime(1970, 1, 1, 0, 0)\n\n>>> utcnow = datetime.now(timezone.utc).replace(tzinfo=None)\n>>> utcnow == isoparse(utcnow.isoformat())\nTrue\n\nFor further datetime parsing, see the `iso8601`_ package for strict\nISO parsing and `dateutil`_ package for loose parsing and more.\n\n.. _ISO8601-formatted time: https://en.wikipedia.org/wiki/ISO_8601\n.. _iso8601: https://pypi.python.org/pypi/iso8601\n.. _dateutil: https://pypi.python.org/pypi/python-dateutil"
  },
  {
    "function": "parse_timedelta",
    "code": "def parse_timedelta(text):\n    \"\"\"Robustly parses a short text description of a time period into a\n    :class:`datetime.timedelta`. Supports weeks, days, hours, minutes,\n    and seconds, with or without decimal points:\n\n    Args:\n        text (str): Text to parse.\n    Returns:\n        datetime.timedelta\n    Raises:\n        ValueError: on parse failure.\n\n    >>> parse_td('1d 2h 3.5m 0s') == timedelta(days=1, seconds=7410)\n    True\n\n    Also supports full words and whitespace.\n\n    >>> parse_td('2 weeks 1 day') == timedelta(days=15)\n    True\n\n    Negative times are supported, too:\n\n    >>> parse_td('-1.5 weeks 3m 20s') == timedelta(days=-11, seconds=43400)\n    True\n    \"\"\"\n    td_kwargs = {}\n    for match in _PARSE_TD_RE.finditer(text):\n        value, unit = match.group('value'), match.group('unit')\n        try:\n            unit_key = _PARSE_TD_KW_MAP[unit]\n        except KeyError:\n            raise ValueError('invalid time unit %r, expected one of %r'\n                             % (unit, _PARSE_TD_KW_MAP.keys()))\n        try:\n            value = float(value)\n        except ValueError:\n            raise ValueError('invalid time value for unit %r: %r'\n                             % (unit, value))\n        td_kwargs[unit_key] = value\n    return timedelta(**td_kwargs)",
    "docstring": "Robustly parses a short text description of a time period into a\n:class:`datetime.timedelta`. Supports weeks, days, hours, minutes,\nand seconds, with or without decimal points:\n\nArgs:\n    text (str): Text to parse.\nReturns:\n    datetime.timedelta\nRaises:\n    ValueError: on parse failure.\n\n>>> parse_td('1d 2h 3.5m 0s') == timedelta(days=1, seconds=7410)\nTrue\n\nAlso supports full words and whitespace.\n\n>>> parse_td('2 weeks 1 day') == timedelta(days=15)\nTrue\n\nNegative times are supported, too:\n\n>>> parse_td('-1.5 weeks 3m 20s') == timedelta(days=-11, seconds=43400)\nTrue"
  },
  {
    "function": "decimal_relative_time",
    "code": "def decimal_relative_time(d, other=None, ndigits=0, cardinalize=True):\n    \"\"\"Get a tuple representing the relative time difference between two\n    :class:`~datetime.datetime` objects or one\n    :class:`~datetime.datetime` and now.\n\n    Args:\n        d (datetime): The first datetime object.\n        other (datetime): An optional second datetime object. If\n            unset, defaults to the current time as determined\n            :meth:`datetime.utcnow`.\n        ndigits (int): The number of decimal digits to round to,\n            defaults to ``0``.\n        cardinalize (bool): Whether to pluralize the time unit if\n            appropriate, defaults to ``True``.\n    Returns:\n        (float, str): A tuple of the :class:`float` difference and\n           respective unit of time, pluralized if appropriate and\n           *cardinalize* is set to ``True``.\n\n    Unlike :func:`relative_time`, this method's return is amenable to\n    localization into other languages and custom phrasing and\n    formatting.\n\n    >>> now = datetime.now(timezone.utc).replace(tzinfo=None)\n    >>> decimal_relative_time(now - timedelta(days=1, seconds=3600), now)\n    (1.0, 'day')\n    >>> decimal_relative_time(now - timedelta(seconds=0.002), now, ndigits=5)\n    (0.002, 'seconds')\n    >>> decimal_relative_time(now, now - timedelta(days=900), ndigits=1)\n    (-2.5, 'years')\n\n    \"\"\"\n    if other is None:\n        other = datetime.now(timezone.utc).replace(tzinfo=None)\n    diff = other - d\n    diff_seconds = timedelta.total_seconds(diff)\n    abs_diff = abs(diff)\n    b_idx = bisect.bisect(_BOUND_DELTAS, abs_diff) - 1\n    bbound, bunit, bname = _BOUNDS[b_idx]\n    f_diff = diff_seconds / timedelta.total_seconds(bunit)\n    rounded_diff = round(f_diff, ndigits)\n    if cardinalize:\n        return rounded_diff, _cardinalize_time_unit(bname, abs(rounded_diff))\n    return rounded_diff, bname",
    "docstring": "Get a tuple representing the relative time difference between two\n:class:`~datetime.datetime` objects or one\n:class:`~datetime.datetime` and now.\n\nArgs:\n    d (datetime): The first datetime object.\n    other (datetime): An optional second datetime object. If\n        unset, defaults to the current time as determined\n        :meth:`datetime.utcnow`.\n    ndigits (int): The number of decimal digits to round to,\n        defaults to ``0``.\n    cardinalize (bool): Whether to pluralize the time unit if\n        appropriate, defaults to ``True``.\nReturns:\n    (float, str): A tuple of the :class:`float` difference and\n       respective unit of time, pluralized if appropriate and\n       *cardinalize* is set to ``True``.\n\nUnlike :func:`relative_time`, this method's return is amenable to\nlocalization into other languages and custom phrasing and\nformatting.\n\n>>> now = datetime.now(timezone.utc).replace(tzinfo=None)\n>>> decimal_relative_time(now - timedelta(days=1, seconds=3600), now)\n(1.0, 'day')\n>>> decimal_relative_time(now - timedelta(seconds=0.002), now, ndigits=5)\n(0.002, 'seconds')\n>>> decimal_relative_time(now, now - timedelta(days=900), ndigits=1)\n(-2.5, 'years')"
  },
  {
    "function": "relative_time",
    "code": "def relative_time(d, other=None, ndigits=0):\n    \"\"\"Get a string representation of the difference between two\n    :class:`~datetime.datetime` objects or one\n    :class:`~datetime.datetime` and the current time. Handles past and\n    future times.\n\n    Args:\n        d (datetime): The first datetime object.\n        other (datetime): An optional second datetime object. If\n            unset, defaults to the current time as determined\n            :meth:`datetime.utcnow`.\n        ndigits (int): The number of decimal digits to round to,\n            defaults to ``0``.\n    Returns:\n        A short English-language string.\n\n    >>> now = datetime.now(timezone.utc).replace(tzinfo=None)\n    >>> relative_time(now, ndigits=1)\n    '0 seconds ago'\n    >>> relative_time(now - timedelta(days=1, seconds=36000), ndigits=1)\n    '1.4 days ago'\n    >>> relative_time(now + timedelta(days=7), now, ndigits=1)\n    '1 week from now'\n\n    \"\"\"\n    drt, unit = decimal_relative_time(d, other, ndigits, cardinalize=True)\n    phrase = 'ago'\n    if drt < 0:\n        phrase = 'from now'\n    return f'{abs(drt):g} {unit} {phrase}'",
    "docstring": "Get a string representation of the difference between two\n:class:`~datetime.datetime` objects or one\n:class:`~datetime.datetime` and the current time. Handles past and\nfuture times.\n\nArgs:\n    d (datetime): The first datetime object.\n    other (datetime): An optional second datetime object. If\n        unset, defaults to the current time as determined\n        :meth:`datetime.utcnow`.\n    ndigits (int): The number of decimal digits to round to,\n        defaults to ``0``.\nReturns:\n    A short English-language string.\n\n>>> now = datetime.now(timezone.utc).replace(tzinfo=None)\n>>> relative_time(now, ndigits=1)\n'0 seconds ago'\n>>> relative_time(now - timedelta(days=1, seconds=36000), ndigits=1)\n'1.4 days ago'\n>>> relative_time(now + timedelta(days=7), now, ndigits=1)\n'1 week from now'"
  },
  {
    "function": "strpdate",
    "code": "def strpdate(string, format):\n    \"\"\"Parse the date string according to the format in `format`.  Returns a\n    :class:`date` object.  Internally, :meth:`datetime.strptime` is used to\n    parse the string and thus conversion specifiers for time fields (e.g. `%H`)\n    may be provided;  these will be parsed but ignored.\n\n    Args:\n        string (str): The date string to be parsed.\n        format (str): The `strptime`_-style date format string.\n    Returns:\n        datetime.date\n\n    .. _`strptime`: https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior\n\n    >>> strpdate('2016-02-14', '%Y-%m-%d')\n    datetime.date(2016, 2, 14)\n    >>> strpdate('26/12 (2015)', '%d/%m (%Y)')\n    datetime.date(2015, 12, 26)\n    >>> strpdate('20151231 23:59:59', '%Y%m%d %H:%M:%S')\n    datetime.date(2015, 12, 31)\n    >>> strpdate('20160101 00:00:00.001', '%Y%m%d %H:%M:%S.%f')\n    datetime.date(2016, 1, 1)\n    \"\"\"\n    whence = datetime.strptime(string, format)\n    return whence.date()",
    "docstring": "Parse the date string according to the format in `format`.  Returns a\n:class:`date` object.  Internally, :meth:`datetime.strptime` is used to\nparse the string and thus conversion specifiers for time fields (e.g. `%H`)\nmay be provided;  these will be parsed but ignored.\n\nArgs:\n    string (str): The date string to be parsed.\n    format (str): The `strptime`_-style date format string.\nReturns:\n    datetime.date\n\n.. _`strptime`: https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior\n\n>>> strpdate('2016-02-14', '%Y-%m-%d')\ndatetime.date(2016, 2, 14)\n>>> strpdate('26/12 (2015)', '%d/%m (%Y)')\ndatetime.date(2015, 12, 26)\n>>> strpdate('20151231 23:59:59', '%Y%m%d %H:%M:%S')\ndatetime.date(2015, 12, 31)\n>>> strpdate('20160101 00:00:00.001', '%Y%m%d %H:%M:%S.%f')\ndatetime.date(2016, 1, 1)"
  },
  {
    "function": "daterange",
    "code": "def daterange(start, stop, step=1, inclusive=False):\n    \"\"\"In the spirit of :func:`range` and :func:`xrange`, the `daterange`\n    generator that yields a sequence of :class:`~datetime.date`\n    objects, starting at *start*, incrementing by *step*, until *stop*\n    is reached.\n\n    When *inclusive* is True, the final date may be *stop*, **if**\n    *step* falls evenly on it. By default, *step* is one day. See\n    details below for many more details.\n\n    Args:\n        start (datetime.date): The starting date The first value in\n            the sequence.\n        stop (datetime.date): The stopping date. By default not\n            included in return. Can be `None` to yield an infinite\n            sequence.\n        step (int): The value to increment *start* by to reach\n            *stop*. Can be an :class:`int` number of days, a\n            :class:`datetime.timedelta`, or a :class:`tuple` of integers,\n            `(year, month, day)`. Positive and negative *step* values\n            are supported.\n        inclusive (bool): Whether or not the *stop* date can be\n            returned. *stop* is only returned when a *step* falls evenly\n            on it.\n\n    >>> christmas = date(year=2015, month=12, day=25)\n    >>> boxing_day = date(year=2015, month=12, day=26)\n    >>> new_year = date(year=2016, month=1,  day=1)\n    >>> for day in daterange(christmas, new_year):\n    ...     print(repr(day))\n    datetime.date(2015, 12, 25)\n    datetime.date(2015, 12, 26)\n    datetime.date(2015, 12, 27)\n    datetime.date(2015, 12, 28)\n    datetime.date(2015, 12, 29)\n    datetime.date(2015, 12, 30)\n    datetime.date(2015, 12, 31)\n    >>> for day in daterange(christmas, boxing_day):\n    ...     print(repr(day))\n    datetime.date(2015, 12, 25)\n    >>> for day in daterange(date(2017, 5, 1), date(2017, 8, 1),\n    ...                      step=(0, 1, 0), inclusive=True):\n    ...     print(repr(day))\n    datetime.date(2017, 5, 1)\n    datetime.date(2017, 6, 1)\n    datetime.date(2017, 7, 1)\n    datetime.date(2017, 8, 1)\n\n    *Be careful when using stop=None, as this will yield an infinite\n    sequence of dates.*\n    \"\"\"\n    if not isinstance(start, date):\n        raise TypeError(\"start expected datetime.date instance\")\n    if stop and not isinstance(stop, date):\n        raise TypeError(\"stop expected datetime.date instance or None\")\n    try:\n        y_step, m_step, d_step = step\n    except TypeError:\n        y_step, m_step, d_step = 0, 0, step\n    else:\n        y_step, m_step = int(y_step), int(m_step)\n    if isinstance(d_step, int):\n        d_step = timedelta(days=int(d_step))\n    elif isinstance(d_step, timedelta):\n        pass\n    else:\n        raise ValueError('step expected int, timedelta, or tuple'\n                         ' (year, month, day), not: %r' % step)\n    \n    m_step += y_step * 12\n\n    if stop is None:\n        finished = lambda now, stop: False\n    elif start <= stop:\n        finished = operator.gt if inclusive else operator.ge\n    else:\n        finished = operator.lt if inclusive else operator.le\n    now = start\n\n    while not finished(now, stop):\n        yield now\n        if m_step:\n            m_y_step, cur_month = divmod((now.month - 1) + m_step, 12)\n            now = now.replace(year=now.year + m_y_step,\n                              month=(cur_month + 1))\n        now = now + d_step\n    return",
    "docstring": "In the spirit of :func:`range` and :func:`xrange`, the `daterange`\ngenerator that yields a sequence of :class:`~datetime.date`\nobjects, starting at *start*, incrementing by *step*, until *stop*\nis reached.\n\nWhen *inclusive* is True, the final date may be *stop*, **if**\n*step* falls evenly on it. By default, *step* is one day. See\ndetails below for many more details.\n\nArgs:\n    start (datetime.date): The starting date The first value in\n        the sequence.\n    stop (datetime.date): The stopping date. By default not\n        included in return. Can be `None` to yield an infinite\n        sequence.\n    step (int): The value to increment *start* by to reach\n        *stop*. Can be an :class:`int` number of days, a\n        :class:`datetime.timedelta`, or a :class:`tuple` of integers,\n        `(year, month, day)`. Positive and negative *step* values\n        are supported.\n    inclusive (bool): Whether or not the *stop* date can be\n        returned. *stop* is only returned when a *step* falls evenly\n        on it.\n\n>>> christmas = date(year=2015, month=12, day=25)\n>>> boxing_day = date(year=2015, month=12, day=26)\n>>> new_year = date(year=2016, month=1,  day=1)\n>>> for day in daterange(christmas, new_year):\n...     print(repr(day))\ndatetime.date(2015, 12, 25)\ndatetime.date(2015, 12, 26)\ndatetime.date(2015, 12, 27)\ndatetime.date(2015, 12, 28)\ndatetime.date(2015, 12, 29)\ndatetime.date(2015, 12, 30)\ndatetime.date(2015, 12, 31)\n>>> for day in daterange(christmas, boxing_day):\n...     print(repr(day))\ndatetime.date(2015, 12, 25)\n>>> for day in daterange(date(2017, 5, 1), date(2017, 8, 1),\n...                      step=(0, 1, 0), inclusive=True):\n...     print(repr(day))\ndatetime.date(2017, 5, 1)\ndatetime.date(2017, 6, 1)\ndatetime.date(2017, 7, 1)\ndatetime.date(2017, 8, 1)\n\n*Be careful when using stop=None, as this will yield an infinite\nsequence of dates.*"
  },
  {
    "function": "make_sentinel",
    "code": "def make_sentinel(name='_MISSING', var_name=None):\n    \"\"\"Creates and returns a new **instance** of a new class, suitable for\n    usage as a \"sentinel\", a kind of singleton often used to indicate\n    a value is missing when ``None`` is a valid input.\n\n    Args:\n        name (str): Name of the Sentinel\n        var_name (str): Set this name to the name of the variable in\n            its respective module enable pickleability. Note:\n            pickleable sentinels should be global constants at the top\n            level of their module.\n\n    >>> make_sentinel(var_name='_MISSING')\n    _MISSING\n\n    The most common use cases here in boltons are as default values\n    for optional function arguments, partly because of its\n    less-confusing appearance in automatically generated\n    documentation. Sentinels also function well as placeholders in queues\n    and linked lists.\n\n    .. note::\n\n      By design, additional calls to ``make_sentinel`` with the same\n      values will not produce equivalent objects.\n\n      >>> make_sentinel('TEST') == make_sentinel('TEST')\n      False\n      >>> type(make_sentinel('TEST')) == type(make_sentinel('TEST'))\n      False\n\n    \"\"\"\n    class Sentinel:\n        def __init__(self):\n            self.name = name\n            self.var_name = var_name\n\n        def __repr__(self):\n            if self.var_name:\n                return self.var_name\n            return f'{self.__class__.__name__}({self.name!r})'\n\n        if var_name:\n            def __reduce__(self):\n                return self.var_name\n\n        def __bool__(self):\n            return False\n\n        def __copy__(self):\n            return self\n\n        def __deepcopy__(self, _memo):\n            return self\n\n    if var_name:\n        frame = sys._getframe(1)\n        module = frame.f_globals.get('__name__')\n        if not module or module not in sys.modules:\n            raise ValueError('Pickleable sentinel objects (with var_name) can only'\n                             ' be created from top-level module scopes')\n        Sentinel.__module__ = module\n\n    return Sentinel()",
    "docstring": "Creates and returns a new **instance** of a new class, suitable for\nusage as a \"sentinel\", a kind of singleton often used to indicate\na value is missing when ``None`` is a valid input.\n\nArgs:\n    name (str): Name of the Sentinel\n    var_name (str): Set this name to the name of the variable in\n        its respective module enable pickleability. Note:\n        pickleable sentinels should be global constants at the top\n        level of their module.\n\n>>> make_sentinel(var_name='_MISSING')\n_MISSING\n\nThe most common use cases here in boltons are as default values\nfor optional function arguments, partly because of its\nless-confusing appearance in automatically generated\ndocumentation. Sentinels also function well as placeholders in queues\nand linked lists.\n\n.. note::\n\n  By design, additional calls to ``make_sentinel`` with the same\n  values will not produce equivalent objects.\n\n  >>> make_sentinel('TEST') == make_sentinel('TEST')\n  False\n  >>> type(make_sentinel('TEST')) == type(make_sentinel('TEST'))\n  False"
  },
  {
    "function": "issubclass",
    "code": "def issubclass(subclass, baseclass):\n    \"\"\"Just like the built-in :func:`issubclass`, this function checks\n    whether *subclass* is inherited from *baseclass*. Unlike the\n    built-in function, this ``issubclass`` will simply return\n    ``False`` if either argument is not suitable (e.g., if *subclass*\n    is not an instance of :class:`type`), instead of raising\n    :exc:`TypeError`.\n\n    Args:\n        subclass (type): The target class to check.\n        baseclass (type): The base class *subclass* will be checked against.\n\n    >>> class MyObject(object): pass\n    ...\n    >>> issubclass(MyObject, object)  # always a fun fact\n    True\n    >>> issubclass('hi', 'friend')\n    False\n    \"\"\"\n    try:\n        return _issubclass(subclass, baseclass)\n    except TypeError:\n        return False",
    "docstring": "Just like the built-in :func:`issubclass`, this function checks\nwhether *subclass* is inherited from *baseclass*. Unlike the\nbuilt-in function, this ``issubclass`` will simply return\n``False`` if either argument is not suitable (e.g., if *subclass*\nis not an instance of :class:`type`), instead of raising\n:exc:`TypeError`.\n\nArgs:\n    subclass (type): The target class to check.\n    baseclass (type): The base class *subclass* will be checked against.\n\n>>> class MyObject(object): pass\n...\n>>> issubclass(MyObject, object)  # always a fun fact\nTrue\n>>> issubclass('hi', 'friend')\nFalse"
  },
  {
    "function": "get_all_subclasses",
    "code": "def get_all_subclasses(cls):\n    \"\"\"Recursively finds and returns a :class:`list` of all types\n    inherited from *cls*.\n\n    >>> class A(object):\n    ...     pass\n    ...\n    >>> class B(A):\n    ...     pass\n    ...\n    >>> class C(B):\n    ...     pass\n    ...\n    >>> class D(A):\n    ...     pass\n    ...\n    >>> [t.__name__ for t in get_all_subclasses(A)]\n    ['B', 'D', 'C']\n    >>> [t.__name__ for t in get_all_subclasses(B)]\n    ['C']\n\n    \"\"\"\n    try:\n        to_check = deque(cls.__subclasses__())\n    except (AttributeError, TypeError):\n        raise TypeError('expected type object, not %r' % cls)\n    seen, ret = set(), []\n    while to_check:\n        cur = to_check.popleft()\n        if cur in seen:\n            continue\n        ret.append(cur)\n        seen.add(cur)\n        to_check.extend(cur.__subclasses__())\n    return ret",
    "docstring": "Recursively finds and returns a :class:`list` of all types\ninherited from *cls*.\n\n>>> class A(object):\n...     pass\n...\n>>> class B(A):\n...     pass\n...\n>>> class C(B):\n...     pass\n...\n>>> class D(A):\n...     pass\n...\n>>> [t.__name__ for t in get_all_subclasses(A)]\n['B', 'D', 'C']\n>>> [t.__name__ for t in get_all_subclasses(B)]\n['C']"
  },
  {
    "function": "find_all_links",
    "code": "def find_all_links(text, with_text=False, default_scheme='https', schemes=()):\n    \"\"\"This function uses heuristics to searches plain text for strings\n    that look like URLs, returning a :class:`list` of :class:`URL`\n    objects. It supports limiting the accepted schemes, and returning\n    interleaved text as well.\n\n    >>> find_all_links('Visit https://boltons.rtfd.org!')\n    [URL(u'https://boltons.rtfd.org')]\n    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)\n    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']\n\n    Args:\n       text (str): The text to search.\n\n       with_text (bool): Whether or not to interleave plaintext blocks\n          with the returned URL objects. Having all tokens can be\n          useful for transforming the text, e.g., replacing links with\n          HTML equivalents. Defaults to ``False``.\n\n       default_scheme (str): Many URLs are written without the scheme\n          component. This function can match a reasonable subset of\n          those, provided *default_scheme* is set to a string. Set to\n          ``False`` to disable matching scheme-less URLs. Defaults to\n          ``'https'``.\n\n       schemes (list): A list of strings that a URL's scheme must\n          match in order to be included in the results. Defaults to\n          empty, which matches all schemes.\n\n    .. note:: Currently this function does not support finding IPv6\n      addresses or URLs with netloc-less schemes, like mailto.\n\n    \"\"\"\n    text = to_unicode(text)\n    prev_end, start, end = 0, None, None\n    ret = []\n    _add = ret.append\n\n    def _add_text(t):\n        if ret and isinstance(ret[-1], str):\n            ret[-1] += t\n        else:\n            _add(t)\n\n    for match in _FIND_ALL_URL_RE.finditer(text):\n        start, end = match.start(1), match.end(1)\n        if prev_end < start and with_text:\n            _add(text[prev_end:start])\n        prev_end = end\n        try:\n            cur_url_text = match.group(0)\n            cur_url = URL(cur_url_text)\n            if not cur_url.scheme:\n                if default_scheme:\n                    cur_url = URL(default_scheme + '://' + cur_url_text)\n                else:\n                    _add_text(text[start:end])\n                    continue\n            if schemes and cur_url.scheme not in schemes:\n                _add_text(text[start:end])\n            else:\n                _add(cur_url)\n        except URLParseError:\n            # currently this should only be hit with broken port\n            # strings. the regex above doesn't support ipv6 addresses\n            if with_text:\n                _add_text(text[start:end])\n\n    if with_text:\n        tail = text[prev_end:]\n        if tail:\n            _add_text(tail)\n\n    return ret",
    "docstring": "This function uses heuristics to searches plain text for strings\nthat look like URLs, returning a :class:`list` of :class:`URL`\nobjects. It supports limiting the accepted schemes, and returning\ninterleaved text as well.\n\n>>> find_all_links('Visit https://boltons.rtfd.org!')\n[URL(u'https://boltons.rtfd.org')]\n>>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)\n[u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']\n\nArgs:\n   text (str): The text to search.\n\n   with_text (bool): Whether or not to interleave plaintext blocks\n      with the returned URL objects. Having all tokens can be\n      useful for transforming the text, e.g., replacing links with\n      HTML equivalents. Defaults to ``False``.\n\n   default_scheme (str): Many URLs are written without the scheme\n      component. This function can match a reasonable subset of\n      those, provided *default_scheme* is set to a string. Set to\n      ``False`` to disable matching scheme-less URLs. Defaults to\n      ``'https'``.\n\n   schemes (list): A list of strings that a URL's scheme must\n      match in order to be included in the results. Defaults to\n      empty, which matches all schemes.\n\n.. note:: Currently this function does not support finding IPv6\n  addresses or URLs with netloc-less schemes, like mailto."
  },
  {
    "function": "quote_path_part",
    "code": "def quote_path_part(text, full_quote=True):\n    \"\"\"\n    Percent-encode a single segment of a URL path.\n    \"\"\"\n    if full_quote:\n        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')\n        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])\n    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t\n                     for t in text])",
    "docstring": "Percent-encode a single segment of a URL path."
  },
  {
    "function": "quote_query_part",
    "code": "def quote_query_part(text, full_quote=True):\n    \"\"\"\n    Percent-encode a single query string key or value.\n    \"\"\"\n    if full_quote:\n        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')\n        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])\n    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t\n                     for t in text])",
    "docstring": "Percent-encode a single query string key or value."
  },
  {
    "function": "quote_fragment_part",
    "code": "def quote_fragment_part(text, full_quote=True):\n    \"\"\"Quote the fragment part of the URL. Fragments don't have\n    subdelimiters, so the whole URL fragment can be passed.\n    \"\"\"\n    if full_quote:\n        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')\n        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])\n    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t\n                     for t in text])",
    "docstring": "Quote the fragment part of the URL. Fragments don't have\nsubdelimiters, so the whole URL fragment can be passed."
  },
  {
    "function": "quote_userinfo_part",
    "code": "def quote_userinfo_part(text, full_quote=True):\n    \"\"\"Quote special characters in either the username or password\n    section of the URL. Note that userinfo in URLs is considered\n    deprecated in many circles (especially browsers), and support for\n    percent-encoded userinfo can be spotty.\n    \"\"\"\n    if full_quote:\n        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')\n        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])\n    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS\n                     else t for t in text])",
    "docstring": "Quote special characters in either the username or password\nsection of the URL. Note that userinfo in URLs is considered\ndeprecated in many circles (especially browsers), and support for\npercent-encoded userinfo can be spotty."
  },
  {
    "function": "unquote",
    "code": "def unquote(string, encoding='utf-8', errors='replace'):\n    \"\"\"Percent-decode a string, by replacing %xx escapes with their\n    single-character equivalent. The optional *encoding* and *errors*\n    parameters specify how to decode percent-encoded sequences into\n    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By\n    default, percent-encoded sequences are decoded with UTF-8, and\n    invalid sequences are replaced by a placeholder character.\n\n    >>> unquote(u'abc%20def')\n    u'abc def'\n    \"\"\"\n    if '%' not in string:\n        string.split\n        return string\n    if encoding is None:\n        encoding = 'utf-8'\n    if errors is None:\n        errors = 'replace'\n    bits = _ASCII_RE.split(string)\n    res = [bits[0]]\n    append = res.append\n    for i in range(1, len(bits), 2):\n        append(unquote_to_bytes(bits[i]).decode(encoding, errors))\n        append(bits[i + 1])\n    return ''.join(res)",
    "docstring": "Percent-decode a string, by replacing %xx escapes with their\nsingle-character equivalent. The optional *encoding* and *errors*\nparameters specify how to decode percent-encoded sequences into\nUnicode characters, as accepted by the :meth:`bytes.decode()` method.  By\ndefault, percent-encoded sequences are decoded with UTF-8, and\ninvalid sequences are replaced by a placeholder character.\n\n>>> unquote(u'abc%20def')\nu'abc def'"
  },
  {
    "function": "unquote_to_bytes",
    "code": "def unquote_to_bytes(string):\n    \"\"\"unquote_to_bytes('abc%20def') -> b'abc def'.\"\"\"\n    # Note: strings are encoded as UTF-8. This is only an issue if it contains\n    # unescaped non-ASCII characters, which URIs should not.\n    if not string:\n        # Is it a string-like object?\n        string.split\n        return b''\n    if isinstance(string, str):\n        string = string.encode('utf-8')\n    bits = string.split(b'%')\n    if len(bits) == 1:\n        return string\n    # import pdb;pdb.set_trace()\n    res = [bits[0]]\n    append = res.append\n\n    for item in bits[1:]:\n        try:\n            append(_HEX_CHAR_MAP[item[:2]])\n            append(item[2:])\n        except KeyError:\n            append(b'%')\n            append(item)\n    return b''.join(res)",
    "docstring": "unquote_to_bytes('abc%20def') -> b'abc def'."
  },
  {
    "function": "register_scheme",
    "code": "def register_scheme(text, uses_netloc=None, default_port=None):\n    \"\"\"Registers new scheme information, resulting in correct port and\n    slash behavior from the URL object. There are dozens of standard\n    schemes preregistered, so this function is mostly meant for\n    proprietary internal customizations or stopgaps on missing\n    standards information. If a scheme seems to be missing, please\n    `file an issue`_!\n\n    Args:\n        text (str): Text representing the scheme.\n           (the 'http' in 'http://hatnote.com')\n        uses_netloc (bool): Does the scheme support specifying a\n           network host? For instance, \"http\" does, \"mailto\" does not.\n        default_port (int): The default port, if any, for netloc-using\n           schemes.\n\n    .. _file an issue: https://github.com/mahmoud/boltons/issues\n    \"\"\"\n    text = text.lower()\n    if default_port is not None:\n        try:\n            default_port = int(default_port)\n        except ValueError:\n            raise ValueError('default_port expected integer or None, not %r'\n                             % (default_port,))\n\n    if uses_netloc is True:\n        SCHEME_PORT_MAP[text] = default_port\n    elif uses_netloc is False:\n        if default_port is not None:\n            raise ValueError('unexpected default port while specifying'\n                             ' non-netloc scheme: %r' % default_port)\n        NO_NETLOC_SCHEMES.add(text)\n    elif uses_netloc is not None:\n        raise ValueError('uses_netloc expected True, False, or None')\n\n    return",
    "docstring": "Registers new scheme information, resulting in correct port and\nslash behavior from the URL object. There are dozens of standard\nschemes preregistered, so this function is mostly meant for\nproprietary internal customizations or stopgaps on missing\nstandards information. If a scheme seems to be missing, please\n`file an issue`_!\n\nArgs:\n    text (str): Text representing the scheme.\n       (the 'http' in 'http://hatnote.com')\n    uses_netloc (bool): Does the scheme support specifying a\n       network host? For instance, \"http\" does, \"mailto\" does not.\n    default_port (int): The default port, if any, for netloc-using\n       schemes.\n\n.. _file an issue: https://github.com/mahmoud/boltons/issues"
  },
  {
    "function": "resolve_path_parts",
    "code": "def resolve_path_parts(path_parts):\n    \"\"\"Normalize the URL path by resolving segments of '.' and '..',\n    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove\n    Dot Segments.\n    \"\"\"\n    # TODO: what to do with multiple slashes\n    ret = []\n\n    for part in path_parts:\n        if part == '.':\n            pass\n        elif part == '..':\n            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting\n                ret.pop()\n        else:\n            ret.append(part)\n\n    if list(path_parts[-1:]) in (['.'], ['..']):\n        ret.append('')\n\n    return ret",
    "docstring": "Normalize the URL path by resolving segments of '.' and '..',\nresulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove\nDot Segments."
  },
  {
    "function": "parse_host",
    "code": "def parse_host(host):\n    \"\"\"\\\n    Low-level function used to parse the host portion of a URL.\n\n    Returns a tuple of (family, host) where *family* is a\n    :mod:`socket` module constant or ``None``, and host is a string.\n\n    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')\n    True\n    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')\n    True\n    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')\n    True\n\n    Odd doctest formatting above due to py3's switch from int to enums\n    for :mod:`socket` constants.\n\n    \"\"\"\n    if not host:\n        return None, ''\n    if ':' in host and '[' == host[0] and ']' == host[-1]:\n        host = host[1:-1]\n        try:\n            inet_pton(socket.AF_INET6, host)\n        except OSError as se:\n            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')\n        except UnicodeEncodeError:\n            pass  # TODO: this can't be a real host right?\n        else:\n            family = socket.AF_INET6\n            return family, host\n    try:\n        inet_pton(socket.AF_INET, host)\n    except (OSError, UnicodeEncodeError):\n        family = None  # not an IP\n    else:\n        family = socket.AF_INET\n    return family, host",
    "docstring": "Low-level function used to parse the host portion of a URL.\n\nReturns a tuple of (family, host) where *family* is a\n:mod:`socket` module constant or ``None``, and host is a string.\n\n>>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')\nTrue\n>>> parse_host('[::1]') == (socket.AF_INET6, '::1')\nTrue\n>>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')\nTrue\n\nOdd doctest formatting above due to py3's switch from int to enums\nfor :mod:`socket` constants."
  },
  {
    "function": "parse_url",
    "code": "def parse_url(url_text):\n    \"\"\"\\\n    Used to parse the text for a single URL into a dictionary, used\n    internally by the :class:`URL` type.\n\n    Note that \"URL\" has a very narrow, standards-based\n    definition. While :func:`parse_url` may raise\n    :class:`URLParseError` under a very limited number of conditions,\n    such as non-integer port, a surprising number of strings are\n    technically valid URLs. For instance, the text ``\"url\"`` is a\n    valid URL, because it is a relative path.\n\n    In short, do not expect this function to validate form inputs or\n    other more colloquial usages of URLs.\n\n    >>> res = parse_url('http://127.0.0.1:3000/?a=1')\n    >>> sorted(res.keys())  # res is a basic dictionary\n    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']\n    \"\"\"\n    url_text = str(url_text)\n    # raise TypeError('parse_url expected text, not %r' % url_str)\n    um = _URL_RE.match(url_text)\n    try:\n        gs = um.groupdict()\n    except AttributeError:\n        raise URLParseError('could not parse url: %r' % url_text)\n\n    au_text = gs['authority']\n    user, pw, hostinfo = None, None, au_text\n\n    if au_text:\n        userinfo, sep, hostinfo = au_text.rpartition('@')\n        if sep:\n            # TODO: empty userinfo error?\n            user, _, pw = userinfo.partition(':')\n\n    host, port = None, None\n    if hostinfo:\n        host, sep, port_str = hostinfo.partition(':')\n        if sep:\n            if host and host[0] == '[' and ']' in port_str:\n                host_right, _, port_str = port_str.partition(']')\n                host = host + ':' + host_right + ']'\n                if port_str and port_str[0] == ':':\n                    port_str = port_str[1:]\n\n            try:\n                port = int(port_str)\n            except ValueError:\n                if port_str:  # empty ports ok according to RFC 3986 6.2.3\n                    raise URLParseError('expected integer for port, not %r'\n                                        % port_str)\n                port = None\n\n    family, host = parse_host(host)\n\n    gs['username'] = user\n    gs['password'] = pw\n    gs['family'] = family\n    gs['host'] = host\n    gs['port'] = port\n    return gs",
    "docstring": "Used to parse the text for a single URL into a dictionary, used\ninternally by the :class:`URL` type.\n\nNote that \"URL\" has a very narrow, standards-based\ndefinition. While :func:`parse_url` may raise\n:class:`URLParseError` under a very limited number of conditions,\nsuch as non-integer port, a surprising number of strings are\ntechnically valid URLs. For instance, the text ``\"url\"`` is a\nvalid URL, because it is a relative path.\n\nIn short, do not expect this function to validate form inputs or\nother more colloquial usages of URLs.\n\n>>> res = parse_url('http://127.0.0.1:3000/?a=1')\n>>> sorted(res.keys())  # res is a basic dictionary\n['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']"
  },
  {
    "function": "parse_qsl",
    "code": "def parse_qsl(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):\n    \"\"\"\n    Converts a query string into a list of (key, value) pairs.\n    \"\"\"\n    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]\n    ret = []\n    for pair in pairs:\n        if not pair:\n            continue\n        key, _, value = pair.partition('=')\n        if not value:\n            if keep_blank_values:\n                value = None\n            else:\n                continue\n        key = unquote(key.replace('+', ' '))\n        if value:\n            value = unquote(value.replace('+', ' '))\n        ret.append((key, value))\n    return ret",
    "docstring": "Converts a query string into a list of (key, value) pairs."
  },
  {
    "function": "pytest_ignore_collect",
    "code": "def pytest_ignore_collect(path, config):\n    \"\"\"\n    Ignore tests that end with _pyX, where X does not equal this\n    interpreter's major version.\n    \"\"\"\n    filename = path.basename\n    modulename = filename.split('.', 1)[0]\n    match = _VERSION_MARKER.search(modulename)\n    if not match:\n        return False\n    major_version = match.group('major_version')\n    minor_version = match.group('minor_version')\n\n    if minor_version:\n        version_match = (int(major_version), int(minor_version)) == sys.version_info[:2]\n    else:\n        version_match = int(major_version) == sys.version_info[0]\n\n    return not version_match  # because this is an _ignore_ (not an include)",
    "docstring": "Ignore tests that end with _pyX, where X does not equal this\ninterpreter's major version."
  },
  {
    "function": "test_lri_cache_eviction",
    "code": "def test_lri_cache_eviction():\n    \"\"\"\n    Regression test\n    Original LRI implementation had a bug where the specified cache\n    size only supported `max_size` number of inserts to the cache,\n    rather than support `max_size` number of keys in the cache. This\n    would result in some unintuitive behavior, where a key is evicted\n    recently inserted value would be evicted from the cache if the key\n    inserted was inserted `max_size` keys earlier.\n    \"\"\"\n    test_cache = LRI(2)\n    # dequeue: (key1); dict keys: (key1)\n    test_cache[\"key1\"] = \"value1\"\n    # dequeue: (key1, key1); dict keys: (key1)\n    test_cache[\"key1\"] = \"value1\"\n    # dequeue: (key1, key1, key2); dict keys: (key1, key2)\n    test_cache[\"key2\"] = \"value2\"\n    # dequeue: (key1, key2, key3); dict keys: (key2, key3)\n    test_cache[\"key3\"] = \"value3\"\n    # will error here since we evict key1 from the cache and it doesn't\n    # exist in the dict anymore\n    test_cache[\"key3\"] = \"value3\"",
    "docstring": "Regression test\nOriginal LRI implementation had a bug where the specified cache\nsize only supported `max_size` number of inserts to the cache,\nrather than support `max_size` number of keys in the cache. This\nwould result in some unintuitive behavior, where a key is evicted\nrecently inserted value would be evicted from the cache if the key\ninserted was inserted `max_size` keys earlier."
  },
  {
    "function": "test_cache_sizes_on_repeat_insertions",
    "code": "def test_cache_sizes_on_repeat_insertions():\n    \"\"\"\n    Regression test\n    Original LRI implementation had an unbounded size of memory\n    regardless of the value for its `max_size` parameter due to a naive\n    insertion algorithm onto an underlying deque data structure. To\n    prevent memory leaks, this test will assert that a cache does not\n    grow past its max size given values of a uniform memory footprint\n    \"\"\"\n    caches_to_test = (LRU, LRI)\n    for cache_type in caches_to_test:\n        test_cache = cache_type(2)\n        # note strings are used to force allocation of memory\n        test_cache[\"key1\"] = \"1\"\n        test_cache[\"key2\"] = \"1\"\n        initial_list_size = len(test_cache._get_flattened_ll())\n        for k in test_cache:\n            for __ in range(100):\n                test_cache[k] = \"1\"\n        list_size_after_inserts = len(test_cache._get_flattened_ll())\n        assert initial_list_size == list_size_after_inserts",
    "docstring": "Regression test\nOriginal LRI implementation had an unbounded size of memory\nregardless of the value for its `max_size` parameter due to a naive\ninsertion algorithm onto an underlying deque data structure. To\nprevent memory leaks, this test will assert that a cache does not\ngrow past its max size given values of a uniform memory footprint"
  },
  {
    "function": "test_lru_with_dupes_2",
    "code": "def test_lru_with_dupes_2():\n    \"From Issue #55, h/t github.com/mt\"\n    SIZE = 3\n    lru = LRU(max_size=SIZE)\n    keys = ['A', 'A', 'B', 'A', 'C', 'B', 'D', 'E']\n    for i, k in enumerate(keys):\n        lru[k] = 'HIT'\n        assert _test_linkage(lru._anchor, SIZE + 1), 'linked list invalid'\n\n    return",
    "docstring": "From Issue #55, h/t github.com/mt"
  },
  {
    "function": "_test_linkage",
    "code": "def _test_linkage(dll, max_count=10000, prev_idx=0, next_idx=1):\n    \"\"\"A function to test basic invariants of doubly-linked lists (with\n    links made of Python lists).\n\n    1. Test that the list is not longer than a certain length\n    2. That the forward links (indicated by `next_idx`) correspond to\n    the backward links (indicated by `prev_idx`).\n\n    The `dll` parameter is the root/anchor link of the list.\n    \"\"\"\n    start = cur = dll\n    i = 0\n    prev = None\n    while 1:\n        if i > max_count:\n            raise Exception(\"did not return to anchor link after %r rounds\"\n                            % max_count)\n        if prev is not None and cur is start:\n            break\n        prev = cur\n        cur = cur[next_idx]\n        if cur[prev_idx] is not prev:\n            raise Exception('prev_idx does not point to prev at i = %r' % i)\n        i += 1\n\n    return True",
    "docstring": "A function to test basic invariants of doubly-linked lists (with\nlinks made of Python lists).\n\n1. Test that the list is not longer than a certain length\n2. That the forward links (indicated by `next_idx`) correspond to\nthe backward links (indicated by `prev_idx`).\n\nThe `dll` parameter is the root/anchor link of the list."
  },
  {
    "function": "test_FunctionBuilder_KWONLY_MARKER",
    "code": "def test_FunctionBuilder_KWONLY_MARKER(signature, should_match):\n    \"\"\"\n    _KWONLY_MARKER matches the keyword-only argument separator,\n    regardless of whitespace.\n\n    Note: it assumes the signature is valid Python.\n    \"\"\"\n    matched = bool(FunctionBuilder._KWONLY_MARKER.search(signature))\n    message = \"{!r}: should_match was {}, but result was {}\".format(\n        signature, should_match, matched)\n    assert bool(matched) == should_match, message",
    "docstring": "_KWONLY_MARKER matches the keyword-only argument separator,\nregardless of whitespace.\n\nNote: it assumes the signature is valid Python."
  },
  {
    "function": "test_wraps_inner_kwarg_only",
    "code": "def test_wraps_inner_kwarg_only():\n    \"\"\"from https://github.com/mahmoud/boltons/issues/261\n\n    mh responds to the issue:\n\n    You'll notice that when kw-only args are involved the first time\n    (wraps(f)(g)) it works fine. The other way around, however,\n    wraps(g)(f) fails, because by the very nature of funcutils.wraps,\n    you're trying to give f the same signature as g. And f's signature\n    is not like g's. g supports positional b and f() does not.\n\n    If you want to make a wrapper which converts a keyword-only\n    argument to one that can be positional or keyword only, that'll\n    require a different approach for now.\n\n    A potential fix would be to pass all function arguments as\n    keywords. But doubt that's the right direction, because, while I\n    have yet to add positional argument only support, that'll\n    definitely throw a wrench into things.\n    \"\"\"\n    from boltons.funcutils import wraps\n\n    def g(a: float, b=10):\n        return a * b\n\n    def f(a: int,  *, b=1):\n        return a * b\n\n    # all is well here...\n    assert f(3) == 3\n    assert g(3) == 30\n    assert wraps(f)(g)(3) == 3  # yay, g got the f default (not so with functools.wraps!)\n\n    # but this doesn't work\n    with pytest.raises(TypeError):\n        wraps(g)(f)(3)\n\n    return",
    "docstring": "from https://github.com/mahmoud/boltons/issues/261\n\nmh responds to the issue:\n\nYou'll notice that when kw-only args are involved the first time\n(wraps(f)(g)) it works fine. The other way around, however,\nwraps(g)(f) fails, because by the very nature of funcutils.wraps,\nyou're trying to give f the same signature as g. And f's signature\nis not like g's. g supports positional b and f() does not.\n\nIf you want to make a wrapper which converts a keyword-only\nargument to one that can be positional or keyword only, that'll\nrequire a different approach for now.\n\nA potential fix would be to pass all function arguments as\nkeywords. But doubt that's the right direction, because, while I\nhave yet to add positional argument only support, that'll\ndefinitely throw a wrench into things."
  },
  {
    "function": "test_clamp_examples",
    "code": "def test_clamp_examples():\n    \"\"\"some examples for clamp()\"\"\"\n    assert 0 == clamp(0, 0, 1) == clamp(-1, 0, 1)\n    assert 0 == clamp(-1, lower=0)\n    assert 1 == clamp(1, 0, 1) == clamp(5, 0, 1)\n    assert 1 == clamp(5, upper=1)\n    assert 0.5 == clamp(7, upper=0.5)\n    assert 1 == clamp(7.7, upper=1)",
    "docstring": "some examples for clamp()"
  },
  {
    "function": "test_clamp_transparent",
    "code": "def test_clamp_transparent():\n    \"\"\"clamp(x) should equal x because both limits are omitted\"\"\"\n    assert clamp(0) == 0\n    assert clamp(1) == 1\n    assert clamp(10**100) == 10**100\n    assert clamp(INF) == INF\n    assert clamp(-INF) == -INF\n    assert math.isnan(clamp(NAN))",
    "docstring": "clamp(x) should equal x because both limits are omitted"
  },
  {
    "function": "test_complement_set",
    "code": "def test_complement_set():\n    '''exercises a bunch of code-paths but doesn't really confirm math identities'''\n    assert complement(complement(set())) == set()\n    sab = set('ab')\n    sbc = set('bc')\n    cab = complement('ab')\n    cbc = complement('bc')\n    cc = complement('c')\n    sc = set('c')\n    u = complement(set())\n    assert repr(sab) in repr(cab)\n    # non-mutating tests\n    assert cab != cbc\n    assert complement(cab) == sab\n    assert complement(cbc) == sbc\n    assert 'a' not in cab\n    assert 'c' in cab\n    assert (sab & cbc) == (sab - sbc)  # set theory invariant\n    assert not (cab < sab)  # complement never subset of set\n    assert not (sab < cab)\n    assert not (cbc < sab)\n    assert not (cbc < cab)  # not subsets of each other\n    assert sab < cc\n    assert cab < (cab | cbc)\n    assert (cab | cbc) > cab\n    assert cc > sab\n    assert not (cab > sab)\n    assert not cab.isdisjoint(cc)  # complements never disjoint\n    assert cab.isdisjoint(sab)\n    assert not cab.isdisjoint(sc)\n    assert (cab | sab) == u\n    assert (cab | cc) == u\n    assert (cab | cbc) == complement('b')\n    assert (sab | cab) == (cbc | sbc)\n    assert (sab & cab) == (cbc & sbc)\n    assert (sab ^ cab) == (cbc ^ sbc)\n    assert cab - cc == sc\n    assert cab - sab == cab\n    assert sab - cab == sab\n    assert (cab ^ cbc | set('b')) == (sab | sbc)\n    everything = complement(frozenset())\n    assert everything in everything  # https://en.wikipedia.org/wiki/Russell%27s_paradox\n    assert bool(cab)\n    assert not complement(u)\n    # destructive testing\n    cab ^= sab\n    cab ^= sab\n    cab &= sab\n    cab &= cbc\n    cab |= sab\n    cab |= cbc\n    cab -= sab\n    cab.add(5)\n    cab.remove(5)\n    cab.update(sab)\n    cab.discard(sab)\n    cab.update(cbc)\n    cab.add(complement(frozenset()))  # frozen complement can be a member of complement set\n    assert len({complement(frozenset()): 1, complement(frozenset()): 2}) == 1  # hash works\n    with raises(NotImplementedError): cab.pop()\n    with raises(NotImplementedError): len(cab)\n    with raises(NotImplementedError): iter(cab)\n    ~cab\n    cab.complement()\n    cab.complemented()\n    class OpOverloader:\n        # tests that operators properly return NotImplemented so they will defer to\n        # another class implementation if available\n        def __and__(self, other): return self\n        __rand__ = __iand__ = __or__ = __ror__ = __ior__ = __xor__ = __rxor__ = __sub__ = __isub__ = __and__\n        def __le__(self, other): return True\n        __lt__ = __ge__ = __gt__ = __le__\n\n    ops = OpOverloader()\n    def opsmash(a, b):\n        a &= b; a |= b; a -= b; a ^= b\n        a > b; a >= b; a < b; a <= b\n        return (((a & b) | b) - b) ^ b\n\n    with raises(TypeError): opsmash(cab, object())\n    assert opsmash(ops, cab) == ops\n    assert opsmash(cab, ops) == ops",
    "docstring": "exercises a bunch of code-paths but doesn't really confirm math identities"
  },
  {
    "function": "test_multibyte_delim",
    "code": "def test_multibyte_delim():\n    \"\"\"Primarily tests recv_until with various maxsizes and True/False\n    for with_delimiter.\n    \"\"\"\n\n    delim = b'\\r\\n'\n    for with_delim in (True, False):\n        if with_delim:\n            cond_delim = b'\\r\\n'\n        else:\n            cond_delim = b''\n\n        empty = b''\n        small_one = b'1'\n        big_two = b'2' * 2048\n        for ms in (3, 5, 1024, None):\n            x, y = socket.socketpair()\n            bs = BufferedSocket(x)\n\n            y.sendall(empty + delim)\n            y.sendall(small_one + delim)\n            y.sendall(big_two + delim)\n\n            kwargs = {'maxsize': ms, 'with_delimiter': with_delim}\n            assert bs.recv_until(delim, **kwargs) == empty + cond_delim\n            assert bs.recv_until(delim, **kwargs) == small_one + cond_delim\n            try:\n                assert bs.recv_until(delim, **kwargs) == big_two + cond_delim\n            except MessageTooLong:\n                if ms is None:\n                    assert False, 'unexpected MessageTooLong'\n            else:\n                if ms is not None:\n                    assert False, 'expected MessageTooLong'\n\n    return",
    "docstring": "Primarily tests recv_until with various maxsizes and True/False\nfor with_delimiter."
  },
  {
    "function": "netstring_server",
    "code": "def netstring_server(server_socket):\n    \"A basic netstring server loop, supporting a few operations\"\n    try:\n        while True:\n            clientsock, addr = server_socket.accept()\n            client = NetstringSocket(clientsock)\n            while 1:\n                request = client.read_ns()\n                if request == b'close':\n                    clientsock.close()\n                    break\n                elif request == b'shutdown':\n                    return\n                elif request == b'reply4k':\n                    client.write_ns(b'a' * 4096)\n                elif request == b'ping':\n                    client.write_ns(b'pong')\n                elif request == b'reply128k':\n                    client.setmaxsize(128 * 1024)\n                    client.write_ns(b'huge' * 32 * 1024)  # 128kb\n                    client.setmaxsize(32768)  # back to default\n    except Exception as e:\n        print('netstring_server exiting with error: %r' % e)\n        raise",
    "docstring": "A basic netstring server loop, supporting a few operations"
  },
  {
    "function": "test_socketutils_netstring",
    "code": "def test_socketutils_netstring():\n    \"\"\"A holistic feature test of BufferedSocket via the NetstringSocket\n    wrapper. Runs\n    \"\"\"\n    print(\"running self tests\")\n\n    # Set up server\n    server_socket = socket.socket()\n    server_socket.bind(('127.0.0.1', 0))  # localhost with ephemeral port\n    server_socket.listen(100)\n    ip, port = server_socket.getsockname()\n    start_server = lambda: netstring_server(server_socket)\n    threading.Thread(target=start_server).start()\n\n    # set up client\n    def client_connect():\n        clientsock = socket.create_connection((ip, port))\n        client = NetstringSocket(clientsock)\n        return client\n\n    # connect, ping-pong\n    client = client_connect()\n    client.write_ns(b'ping')\n    assert client.read_ns() == b'pong'\n    s = time.time()\n    for i in range(1000):\n        client.write_ns(b'ping')\n        assert client.read_ns() == b'pong'\n    dur = time.time() - s\n    print(\"netstring ping-pong latency\", dur, \"ms\")\n\n    s = time.time()\n    for i in range(1000):\n        client.write_ns(b'ping')\n    resps = []\n    for i in range(1000):\n        resps.append(client.read_ns())\n    e = time.time()\n    assert all([r == b'pong' for r in resps])\n    assert client.bsock.getrecvbuffer() == b''\n    dur = e - s\n    print(\"netstring pipelined ping-pong latency\", dur, \"ms\")\n\n    # tell the server to close the socket and then try a failure case\n    client.write_ns(b'close')\n    try:\n        client.read_ns()\n        raise Exception('read from closed socket')\n    except ConnectionClosed:\n        print(\"raised ConnectionClosed correctly\")\n\n    # test big messages\n    client = client_connect()\n    client.setmaxsize(128 * 1024)\n    client.write_ns(b'reply128k')\n    res = client.read_ns()\n    assert len(res) == (128 * 1024)\n    client.write_ns(b'close')\n\n    # test that read timeouts work\n    client = client_connect()\n    client.settimeout(0.1)\n    try:\n        client.read_ns()\n        raise Exception('did not timeout')\n    except Timeout:\n        print(\"read_ns raised timeout correctly\")\n    client.write_ns(b'close')\n\n    # test that netstring max sizes work\n    client = client_connect()\n    client.setmaxsize(2048)\n    client.write_ns(b'reply4k')\n    try:\n        client.read_ns()\n        raise Exception('read more than maxsize')\n    except NetstringMessageTooLong:\n        print(\"raised MessageTooLong correctly\")\n    try:\n        client.bsock.recv_until(b'b', maxsize=4096)\n        raise Exception('recv_until did not raise MessageTooLong')\n    except MessageTooLong:\n        print(\"raised MessageTooLong correctly\")\n    assert client.bsock.recv_size(4097) == b'a' * 4096 + b','\n    print('correctly maintained buffer after exception raised')\n\n    # test BufferedSocket read timeouts with recv_until and recv_size\n    client.bsock.settimeout(0.01)\n    try:\n        client.bsock.recv_until(b'a')\n        raise Exception('recv_until did not raise Timeout')\n    except Timeout:\n        print('recv_until correctly raised Timeout')\n    try:\n        client.bsock.recv_size(1)\n        raise Exception('recv_size did not raise Timeout')\n    except Timeout:\n        print('recv_size correctly raised Timeout')\n\n    client.write_ns(b'shutdown')\n    print(\"all passed\")",
    "docstring": "A holistic feature test of BufferedSocket via the NetstringSocket\nwrapper. Runs"
  },
  {
    "function": "netstring_server_timeout_override",
    "code": "def netstring_server_timeout_override(server_socket):\n    \"\"\"Netstring socket has an unreasonably low timeout,\n    however it should be overridden by the `read_ns` argument.\"\"\"\n\n    try:\n        while True:\n            clientsock, addr = server_socket.accept()\n            client = NetstringSocket(clientsock, timeout=0.01)\n            while 1:\n                request = client.read_ns(1)\n                if request == b'close':\n                    clientsock.close()\n                    break\n                elif request == b'shutdown':\n                    return\n                elif request == b'ping':\n                    client.write_ns(b'pong')\n    except Exception as e:\n        print('netstring_server exiting with error: %r' % e)\n        raise",
    "docstring": "Netstring socket has an unreasonably low timeout,\nhowever it should be overridden by the `read_ns` argument."
  },
  {
    "function": "test_socketutils_netstring_timeout",
    "code": "def test_socketutils_netstring_timeout():\n    \"\"\"Tests that server socket timeout is overridden by the argument to read call.\n\n    Server has timeout of 10 ms, and we will sleep for 20 ms. If timeout is not overridden correctly,\n    a timeout exception will be raised.\"\"\"\n\n    print(\"running timeout test\")\n\n    # Set up server\n    server_socket = socket.socket()\n    server_socket.bind(('127.0.0.1', 0))  # localhost with ephemeral port\n    server_socket.listen(100)\n    ip, port = server_socket.getsockname()\n    start_server = lambda: netstring_server_timeout_override(server_socket)\n    threading.Thread(target=start_server).start()\n\n    # set up client\n    def client_connect():\n        clientsock = socket.create_connection((ip, port))\n        client = NetstringSocket(clientsock)\n        return client\n\n    # connect, ping-pong\n    client = client_connect()\n    time.sleep(0.02)\n    client.write_ns(b'ping')\n    assert client.read_ns() == b'pong'\n\n    client.write_ns(b'shutdown')\n    print(\"no timeout occurred - all good.\")",
    "docstring": "Tests that server socket timeout is overridden by the argument to read call.\n\nServer has timeout of 10 ms, and we will sleep for 20 ms. If timeout is not overridden correctly,\na timeout exception will be raised."
  },
  {
    "function": "test_parsed_exc_nosrcline",
    "code": "def test_parsed_exc_nosrcline():\n    \"\"\"just making sure that everything can be parsed even if there is\n    a line without source and also if the exception has no message\"\"\"\n\n    _tb_str = \"\"\"\\\nTraceback (most recent call last):\n  File \"/home/mahmoud/virtualenvs/chert/bin/chert\", line 9, in <module>\n    load_entry_point('chert==0.2.1.dev0', 'console_scripts', 'chert')()\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 1281, in main\n    ch.process()\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 741, in process\n    self.load()\n  File \"<boltons.FunctionBuilder-0>\", line 2, in load\n  File \"/home/mahmoud/projects/lithoxyl/lithoxyl/logger.py\", line 291, in logged_func\n    return func_to_log(*a, **kw)\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 775, in load\n    raise RuntimeError\nRuntimeError\"\"\"\n\n    parsed_tb = ParsedException.from_string(_tb_str)\n\n    assert parsed_tb.exc_type == 'RuntimeError'\n    assert parsed_tb.exc_msg == ''\n\n    assert len(parsed_tb.frames) == 6\n    assert parsed_tb.frames[3] == {'source_line': '',\n                                   'filepath': '<boltons.FunctionBuilder-0>',\n                                   'lineno': '2',\n                                   'funcname': 'load'}\n    assert parsed_tb.to_string() == _tb_str",
    "docstring": "just making sure that everything can be parsed even if there is\na line without source and also if the exception has no message"
  },
  {
    "function": "test_parsed_exc_with_anchor",
    "code": "def test_parsed_exc_with_anchor():\n    \"\"\"parse a traceback with anchor lines beneath source lines\"\"\"\n    _tb_str = \"\"\"\\\nTraceback (most recent call last):\n  File \"main.py\", line 3, in <module>\n    print(add(1, \"two\"))\n          ^^^^^^^^^^^^^\n  File \"add.py\", line 2, in add\n    return a + b\n           ~~^~~\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\"\"\"\n\n    parsed_tb = ParsedException.from_string(_tb_str)\n\n    assert parsed_tb.exc_type == 'TypeError'\n    assert parsed_tb.exc_msg == \"unsupported operand type(s) for +: 'int' and 'str'\"\n    assert parsed_tb.frames == [{'source_line': 'print(add(1, \"two\"))',\n                                  'filepath': 'main.py',\n                                  'lineno': '3',\n                                  'funcname': '<module>'},\n                                  {'source_line': 'return a + b',\n                                  'filepath': 'add.py',\n                                  'lineno': '2',\n                                  'funcname': 'add'}]\n    \n    # Note: not checking the anchor lines (indices 3, 6) because column details not currently stored in ParsedException\n    _tb_str_lines = _tb_str.splitlines()\n    _tb_str_without_anchor = \"\\n\".join(_tb_str_lines[:3] + _tb_str_lines[4:6] + _tb_str_lines[7:])\n    assert parsed_tb.to_string() == _tb_str_without_anchor",
    "docstring": "parse a traceback with anchor lines beneath source lines"
  },
  {
    "function": "test_chained_navigate",
    "code": "def test_chained_navigate(expected, base, paths):\n    \"\"\"Chained :meth:`navigate` calls produces correct results.\"\"\"\n    url = URL(base)\n\n    for path in paths:\n        url = url.navigate(path)\n\n    assert expected == url.to_text()",
    "docstring": "Chained :meth:`navigate` calls produces correct results."
  },
  {
    "function": "naturalsize",
    "code": "def naturalsize(value, binary=False, gnu=False, format=\"%.1f\"):\n    \"\"\"Format a number of bytes like a human readable filesize (e.g. 10 kB).\n\n    By default, decimal suffixes (kB, MB) are used.\n\n    Non-GNU modes are compatible with jinja2's `filesizeformat` filter.\n\n    Examples:\n        ```pycon\n        >>> naturalsize(3000000)\n        '3.0 MB'\n        >>> naturalsize(300, False, True)\n        '300B'\n        >>> naturalsize(3000, False, True)\n        '2.9K'\n        >>> naturalsize(3000, False, True, \"%.3f\")\n        '2.930K'\n        >>> naturalsize(3000, True)\n        '2.9 KiB'\n\n        ```\n    Args:\n        value (int, float, str): Integer to convert.\n        binary (bool): If `True`, uses binary suffixes (KiB, MiB) with base\n            2<sup>10</sup> instead of 10<sup>3</sup>.\n        gnu (bool): If `True`, the binary argument is ignored and GNU-style\n            (`ls -sh` style) prefixes are used (K, M) with the 2**10 definition.\n        format (str): Custom formatter.\n\n    Returns:\n        str: Human readable representation of a filesize.\n    \"\"\"\n    if gnu:\n        suffix = suffixes[\"gnu\"]\n    elif binary:\n        suffix = suffixes[\"binary\"]\n    else:\n        suffix = suffixes[\"decimal\"]\n\n    base = 1024 if (gnu or binary) else 1000\n    bytes = float(value)\n    abs_bytes = abs(bytes)\n\n    if abs_bytes == 1 and not gnu:\n        return \"%d Byte\" % bytes\n    elif abs_bytes < base and not gnu:\n        return \"%d Bytes\" % bytes\n    elif abs_bytes < base and gnu:\n        return \"%dB\" % bytes\n\n    for i, s in enumerate(suffix):\n        unit = base ** (i + 2)\n        if abs_bytes < unit and not gnu:\n            return (format + \" %s\") % ((base * bytes / unit), s)\n        elif abs_bytes < unit and gnu:\n            return (format + \"%s\") % ((base * bytes / unit), s)\n    if gnu:\n        return (format + \"%s\") % ((base * bytes / unit), s)\n    return (format + \" %s\") % ((base * bytes / unit), s)",
    "docstring": "Format a number of bytes like a human readable filesize (e.g. 10 kB).\n\nBy default, decimal suffixes (kB, MB) are used.\n\nNon-GNU modes are compatible with jinja2's `filesizeformat` filter.\n\nExamples:\n    ```pycon\n    >>> naturalsize(3000000)\n    '3.0 MB'\n    >>> naturalsize(300, False, True)\n    '300B'\n    >>> naturalsize(3000, False, True)\n    '2.9K'\n    >>> naturalsize(3000, False, True, \"%.3f\")\n    '2.930K'\n    >>> naturalsize(3000, True)\n    '2.9 KiB'\n\n    ```\nArgs:\n    value (int, float, str): Integer to convert.\n    binary (bool): If `True`, uses binary suffixes (KiB, MiB) with base\n        2<sup>10</sup> instead of 10<sup>3</sup>.\n    gnu (bool): If `True`, the binary argument is ignored and GNU-style\n        (`ls -sh` style) prefixes are used (K, M) with the 2**10 definition.\n    format (str): Custom formatter.\n\nReturns:\n    str: Human readable representation of a filesize."
  },
  {
    "function": "activate",
    "code": "def activate(locale, path=None):\n    \"\"\"Activate internationalisation.\n\n    Set `locale` as current locale. Search for locale in directory `path`.\n\n    Args:\n        locale (str): Language name, e.g. `en_GB`.\n        path (str): Path to search for locales.\n\n    Returns:\n        dict: Translations.\n\n    Raises:\n        Exception: If humanize cannot find the locale folder.\n    \"\"\"\n    if path is None:\n        path = _get_default_locale_path()\n\n    if path is None:\n        raise Exception(\n            \"Humanize cannot determinate the default location of the 'locale' folder. \"\n            \"You need to pass the path explicitly.\"\n        )\n    if locale not in _TRANSLATIONS:\n        translation = gettext_module.translation(\"humanize\", path, [locale])\n        _TRANSLATIONS[locale] = translation\n    _CURRENT.locale = locale\n    return _TRANSLATIONS[locale]",
    "docstring": "Activate internationalisation.\n\nSet `locale` as current locale. Search for locale in directory `path`.\n\nArgs:\n    locale (str): Language name, e.g. `en_GB`.\n    path (str): Path to search for locales.\n\nReturns:\n    dict: Translations.\n\nRaises:\n    Exception: If humanize cannot find the locale folder."
  },
  {
    "function": "_gettext",
    "code": "def _gettext(message):\n    \"\"\"Get translation.\n\n    Args:\n        message (str): Text to translate.\n\n    Returns:\n        str: Translated text.\n    \"\"\"\n    return get_translation().gettext(message)",
    "docstring": "Get translation.\n\nArgs:\n    message (str): Text to translate.\n\nReturns:\n    str: Translated text."
  },
  {
    "function": "_pgettext",
    "code": "def _pgettext(msgctxt, message):\n    \"\"\"Fetches a particular translation.\n\n    It works with `msgctxt` .po modifiers and allows duplicate keys with different\n    translations.\n\n    Args:\n        msgctxt (str): Context of the translation.\n        message (str): Text to translate.\n\n    Returns:\n        str: Translated text.\n    \"\"\"\n    # This GNU gettext function was added in Python 3.8, so for older versions we\n    # reimplement it. It works by joining `msgctx` and `message` by '4' byte.\n    try:\n        # Python 3.8+\n        return get_translation().pgettext(msgctxt, message)\n    except AttributeError:\n        # Python 3.7 and older\n        key = msgctxt + \"\\x04\" + message\n        translation = get_translation().gettext(key)\n        return message if translation == key else translation",
    "docstring": "Fetches a particular translation.\n\nIt works with `msgctxt` .po modifiers and allows duplicate keys with different\ntranslations.\n\nArgs:\n    msgctxt (str): Context of the translation.\n    message (str): Text to translate.\n\nReturns:\n    str: Translated text."
  },
  {
    "function": "_ngettext",
    "code": "def _ngettext(message, plural, num):\n    \"\"\"Plural version of _gettext.\n\n    Args:\n        message (str): Singular text to translate.\n        plural (str): Plural text to translate.\n        num (str): The number (e.g. item count) to determine translation for the\n            respective grammatical number.\n\n    Returns:\n        str: Translated text.\n    \"\"\"\n    return get_translation().ngettext(message, plural, num)",
    "docstring": "Plural version of _gettext.\n\nArgs:\n    message (str): Singular text to translate.\n    plural (str): Plural text to translate.\n    num (str): The number (e.g. item count) to determine translation for the\n        respective grammatical number.\n\nReturns:\n    str: Translated text."
  },
  {
    "function": "_gettext_noop",
    "code": "def _gettext_noop(message):\n    \"\"\"Mark a string as a translation string without translating it.\n\n    Example usage:\n    ```python\n    CONSTANTS = [_gettext_noop('first'), _gettext_noop('second')]\n    def num_name(n):\n        return _gettext(CONSTANTS[n])\n    ```\n\n    Args:\n        message (str): Text to translate in the future.\n\n    Returns:\n        str: Original text, unchanged.\n    \"\"\"\n    return message",
    "docstring": "Mark a string as a translation string without translating it.\n\nExample usage:\n```python\nCONSTANTS = [_gettext_noop('first'), _gettext_noop('second')]\ndef num_name(n):\n    return _gettext(CONSTANTS[n])\n```\n\nArgs:\n    message (str): Text to translate in the future.\n\nReturns:\n    str: Original text, unchanged."
  },
  {
    "function": "_ngettext_noop",
    "code": "def _ngettext_noop(singular, plural):\n    \"\"\"Mark two strings as pluralized translations without translating them.\n\n    Example usage:\n    ```python\n    CONSTANTS = [ngettext_noop('first', 'firsts'), ngettext_noop('second', 'seconds')]\n    def num_name(n):\n        return _ngettext(*CONSTANTS[n])\n    ```\n\n    Args:\n        singular (str): Singular text to translate in the future.\n        plural (str): Plural text to translate in the future.\n\n    Returns:\n        tuple: Original text, unchanged.\n    \"\"\"\n    return (singular, plural)",
    "docstring": "Mark two strings as pluralized translations without translating them.\n\nExample usage:\n```python\nCONSTANTS = [ngettext_noop('first', 'firsts'), ngettext_noop('second', 'seconds')]\ndef num_name(n):\n    return _ngettext(*CONSTANTS[n])\n```\n\nArgs:\n    singular (str): Singular text to translate in the future.\n    plural (str): Plural text to translate in the future.\n\nReturns:\n    tuple: Original text, unchanged."
  },
  {
    "function": "thousands_separator",
    "code": "def thousands_separator() -> str:\n    \"\"\"Return the thousands separator for a locale, default to comma.\n\n    Returns:\n         str: Thousands separator.\n    \"\"\"\n    try:\n        sep = _THOUSANDS_SEPARATOR[_CURRENT.locale]\n    except (AttributeError, KeyError):\n        sep = \",\"\n    return sep",
    "docstring": "Return the thousands separator for a locale, default to comma.\n\nReturns:\n     str: Thousands separator."
  },
  {
    "function": "ordinal",
    "code": "def ordinal(value, gender=\"male\"):\n    \"\"\"Converts an integer to its ordinal as a string.\n\n    For example, 1 is \"1st\", 2 is \"2nd\", 3 is \"3rd\", etc. Works for any integer or\n    anything `int()` will turn into an integer. Anything other value will have nothing\n    done to it.\n\n    Examples:\n        ```pycon\n        >>> ordinal(1)\n        '1st'\n        >>> ordinal(1002)\n        '1002nd'\n        >>> ordinal(103)\n        '103rd'\n        >>> ordinal(4)\n        '4th'\n        >>> ordinal(12)\n        '12th'\n        >>> ordinal(101)\n        '101st'\n        >>> ordinal(111)\n        '111th'\n        >>> ordinal(\"something else\")\n        'something else'\n        >>> ordinal(None) is None\n        True\n\n        ```\n    Args:\n        value (int, str, float): Integer to convert.\n        gender (str): Gender for translations. Accepts either \"male\" or \"female\".\n\n    Returns:\n        str: Ordinal string.\n    \"\"\"\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n    if gender == \"male\":\n        t = (\n            P_(\"0 (male)\", \"th\"),\n            P_(\"1 (male)\", \"st\"),\n            P_(\"2 (male)\", \"nd\"),\n            P_(\"3 (male)\", \"rd\"),\n            P_(\"4 (male)\", \"th\"),\n            P_(\"5 (male)\", \"th\"),\n            P_(\"6 (male)\", \"th\"),\n            P_(\"7 (male)\", \"th\"),\n            P_(\"8 (male)\", \"th\"),\n            P_(\"9 (male)\", \"th\"),\n        )\n    else:\n        t = (\n            P_(\"0 (female)\", \"th\"),\n            P_(\"1 (female)\", \"st\"),\n            P_(\"2 (female)\", \"nd\"),\n            P_(\"3 (female)\", \"rd\"),\n            P_(\"4 (female)\", \"th\"),\n            P_(\"5 (female)\", \"th\"),\n            P_(\"6 (female)\", \"th\"),\n            P_(\"7 (female)\", \"th\"),\n            P_(\"8 (female)\", \"th\"),\n            P_(\"9 (female)\", \"th\"),\n        )\n    if value % 100 in (11, 12, 13):  # special case\n        return f\"{value}{t[0]}\"\n    return f\"{value}{t[value % 10]}\"",
    "docstring": "Converts an integer to its ordinal as a string.\n\nFor example, 1 is \"1st\", 2 is \"2nd\", 3 is \"3rd\", etc. Works for any integer or\nanything `int()` will turn into an integer. Anything other value will have nothing\ndone to it.\n\nExamples:\n    ```pycon\n    >>> ordinal(1)\n    '1st'\n    >>> ordinal(1002)\n    '1002nd'\n    >>> ordinal(103)\n    '103rd'\n    >>> ordinal(4)\n    '4th'\n    >>> ordinal(12)\n    '12th'\n    >>> ordinal(101)\n    '101st'\n    >>> ordinal(111)\n    '111th'\n    >>> ordinal(\"something else\")\n    'something else'\n    >>> ordinal(None) is None\n    True\n\n    ```\nArgs:\n    value (int, str, float): Integer to convert.\n    gender (str): Gender for translations. Accepts either \"male\" or \"female\".\n\nReturns:\n    str: Ordinal string."
  },
  {
    "function": "intcomma",
    "code": "def intcomma(value, ndigits=None):\n    \"\"\"Converts an integer to a string containing commas every three digits.\n\n    For example, 3000 becomes \"3,000\" and 45000 becomes \"45,000\". To maintain some\n    compatibility with Django's `intcomma`, this function also accepts floats.\n\n    Examples:\n        ```pycon\n        >>> intcomma(100)\n        '100'\n        >>> intcomma(\"1000\")\n        '1,000'\n        >>> intcomma(1_000_000)\n        '1,000,000'\n        >>> intcomma(1_234_567.25)\n        '1,234,567.25'\n        >>> intcomma(1234.5454545, 2)\n        '1,234.55'\n        >>> intcomma(14308.40, 1)\n        '14,308.4'\n        >>> intcomma(None) is None\n        True\n\n        ```\n    Args:\n        value (int, float, str): Integer or float to convert.\n        ndigits (int, None): Digits of precision for rounding after the decimal point.\n\n    Returns:\n        str: string containing commas every three digits.\n    \"\"\"\n    sep = thousands_separator()\n    try:\n        if isinstance(value, str):\n            float(value.replace(sep, \"\"))\n        else:\n            float(value)\n    except (TypeError, ValueError):\n        return value\n\n    if ndigits:\n        orig = \"{0:.{1}f}\".format(value, ndigits)\n    else:\n        orig = str(value)\n\n    new = re.sub(r\"^(-?\\d+)(\\d{3})\", rf\"\\g<1>{sep}\\g<2>\", orig)\n    if orig == new:\n        return new\n    else:\n        return intcomma(new)",
    "docstring": "Converts an integer to a string containing commas every three digits.\n\nFor example, 3000 becomes \"3,000\" and 45000 becomes \"45,000\". To maintain some\ncompatibility with Django's `intcomma`, this function also accepts floats.\n\nExamples:\n    ```pycon\n    >>> intcomma(100)\n    '100'\n    >>> intcomma(\"1000\")\n    '1,000'\n    >>> intcomma(1_000_000)\n    '1,000,000'\n    >>> intcomma(1_234_567.25)\n    '1,234,567.25'\n    >>> intcomma(1234.5454545, 2)\n    '1,234.55'\n    >>> intcomma(14308.40, 1)\n    '14,308.4'\n    >>> intcomma(None) is None\n    True\n\n    ```\nArgs:\n    value (int, float, str): Integer or float to convert.\n    ndigits (int, None): Digits of precision for rounding after the decimal point.\n\nReturns:\n    str: string containing commas every three digits."
  },
  {
    "function": "intword",
    "code": "def intword(value, format=\"%.1f\"):\n    \"\"\"Converts a large integer to a friendly text representation.\n\n    Works best for numbers over 1 million. For example, 1_000_000 becomes \"1.0 million\",\n    1200000 becomes \"1.2 million\" and \"1_200_000_000\" becomes \"1.2 billion\". Supports up\n    to decillion (33 digits) and googol (100 digits).\n\n    Examples:\n        ```pycon\n        >>> intword(\"100\")\n        '100'\n        >>> intword(\"12400\")\n        '12.4 thousand'\n        >>> intword(\"1000000\")\n        '1.0 million'\n        >>> intword(1_200_000_000)\n        '1.2 billion'\n        >>> intword(8100000000000000000000000000000000)\n        '8.1 decillion'\n        >>> intword(None) is None\n        True\n        >>> intword(\"1234000\", \"%0.3f\")\n        '1.234 million'\n\n        ```\n    Args:\n        value (int, float, str): Integer to convert.\n        format (str): To change the number of decimal or general format of the number\n            portion.\n\n    Returns:\n        str: Friendly text representation as a string, unless the value passed could not\n        be coaxed into an `int`.\n    \"\"\"\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n\n    if value < powers[0]:\n        return str(value)\n    for ordinal, power in enumerate(powers[1:], 1):\n        if value < power:\n            chopped = value / float(powers[ordinal - 1])\n            if float(format % chopped) == float(10**3):\n                chopped = value / float(powers[ordinal])\n                singular, plural = human_powers[ordinal]\n                return (\n                    \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])\n                ) % chopped\n            else:\n                singular, plural = human_powers[ordinal - 1]\n                return (\n                    \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])\n                ) % chopped\n    return str(value)",
    "docstring": "Converts a large integer to a friendly text representation.\n\nWorks best for numbers over 1 million. For example, 1_000_000 becomes \"1.0 million\",\n1200000 becomes \"1.2 million\" and \"1_200_000_000\" becomes \"1.2 billion\". Supports up\nto decillion (33 digits) and googol (100 digits).\n\nExamples:\n    ```pycon\n    >>> intword(\"100\")\n    '100'\n    >>> intword(\"12400\")\n    '12.4 thousand'\n    >>> intword(\"1000000\")\n    '1.0 million'\n    >>> intword(1_200_000_000)\n    '1.2 billion'\n    >>> intword(8100000000000000000000000000000000)\n    '8.1 decillion'\n    >>> intword(None) is None\n    True\n    >>> intword(\"1234000\", \"%0.3f\")\n    '1.234 million'\n\n    ```\nArgs:\n    value (int, float, str): Integer to convert.\n    format (str): To change the number of decimal or general format of the number\n        portion.\n\nReturns:\n    str: Friendly text representation as a string, unless the value passed could not\n    be coaxed into an `int`."
  },
  {
    "function": "apnumber",
    "code": "def apnumber(value):\n    \"\"\"Converts an integer to Associated Press style.\n\n    Examples:\n      ```pycon\n      >>> apnumber(0)\n      'zero'\n      >>> apnumber(5)\n      'five'\n      >>> apnumber(10)\n      '10'\n      >>> apnumber(\"7\")\n      'seven'\n      >>> apnumber(\"foo\")\n      'foo'\n      >>> apnumber(None) is None\n      True\n\n      ```\n    Args:\n        value (int, float, str): Integer to convert.\n\n    Returns:\n        str: For numbers 0-9, the number spelled out. Otherwise, the number. This always\n        returns a string unless the value was not `int`-able, unlike the Django filter.\n    \"\"\"\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n    if not 0 <= value < 10:\n        return str(value)\n    return (\n        _(\"zero\"),\n        _(\"one\"),\n        _(\"two\"),\n        _(\"three\"),\n        _(\"four\"),\n        _(\"five\"),\n        _(\"six\"),\n        _(\"seven\"),\n        _(\"eight\"),\n        _(\"nine\"),\n    )[value]",
    "docstring": "Converts an integer to Associated Press style.\n\nExamples:\n  ```pycon\n  >>> apnumber(0)\n  'zero'\n  >>> apnumber(5)\n  'five'\n  >>> apnumber(10)\n  '10'\n  >>> apnumber(\"7\")\n  'seven'\n  >>> apnumber(\"foo\")\n  'foo'\n  >>> apnumber(None) is None\n  True\n\n  ```\nArgs:\n    value (int, float, str): Integer to convert.\n\nReturns:\n    str: For numbers 0-9, the number spelled out. Otherwise, the number. This always\n    returns a string unless the value was not `int`-able, unlike the Django filter."
  },
  {
    "function": "fractional",
    "code": "def fractional(value):\n    \"\"\"Convert to fractional number.\n\n    There will be some cases where one might not want to show ugly decimal places for\n    floats and decimals.\n\n    This function returns a human-readable fractional number in form of fractions and\n    mixed fractions.\n\n    Pass in a string, or a number or a float, and this function returns:\n\n    * a string representation of a fraction\n    * or a whole number\n    * or a mixed fraction\n\n    Examples:\n        ```pycon\n        >>> fractional(0.3)\n        '3/10'\n        >>> fractional(1.3)\n        '1 3/10'\n        >>> fractional(float(1/3))\n        '1/3'\n        >>> fractional(1)\n        '1'\n        >>> fractional(\"ten\")\n        'ten'\n        >>> fractional(None) is None\n        True\n\n        ```\n    Args:\n        value (int, float, str): Integer to convert.\n\n    Returns:\n        str: Fractional number as a string.\n    \"\"\"\n    try:\n        number = float(value)\n    except (TypeError, ValueError):\n        return value\n    whole_number = int(number)\n    frac = Fraction(number - whole_number).limit_denominator(1000)\n    numerator = frac._numerator\n    denominator = frac._denominator\n    if whole_number and not numerator and denominator == 1:\n        # this means that an integer was passed in\n        # (or variants of that integer like 1.0000)\n        return f\"{whole_number:.0f}\"\n    elif not whole_number:\n        return f\"{numerator:.0f}/{denominator:.0f}\"\n    else:\n        return f\"{whole_number:.0f} {numerator:.0f}/{denominator:.0f}\"",
    "docstring": "Convert to fractional number.\n\nThere will be some cases where one might not want to show ugly decimal places for\nfloats and decimals.\n\nThis function returns a human-readable fractional number in form of fractions and\nmixed fractions.\n\nPass in a string, or a number or a float, and this function returns:\n\n* a string representation of a fraction\n* or a whole number\n* or a mixed fraction\n\nExamples:\n    ```pycon\n    >>> fractional(0.3)\n    '3/10'\n    >>> fractional(1.3)\n    '1 3/10'\n    >>> fractional(float(1/3))\n    '1/3'\n    >>> fractional(1)\n    '1'\n    >>> fractional(\"ten\")\n    'ten'\n    >>> fractional(None) is None\n    True\n\n    ```\nArgs:\n    value (int, float, str): Integer to convert.\n\nReturns:\n    str: Fractional number as a string."
  },
  {
    "function": "scientific",
    "code": "def scientific(value, precision=2):\n    \"\"\"Return number in string scientific notation z.wq x 10\u207f.\n\n    Examples:\n        ```pycon\n        >>> scientific(float(0.3))\n        '3.00 x 10\u207b\u00b9'\n        >>> scientific(int(500))\n        '5.00 x 10\u00b2'\n        >>> scientific(-1000)\n        '1.00 x 10\u207b\u00b3'\n        >>> scientific(1000, 1)\n        '1.0 x 10\u00b3'\n        >>> scientific(1000, 3)\n        '1.000 x 10\u00b3'\n        >>> scientific(\"99\")\n        '9.90 x 10\u00b9'\n        >>> scientific(\"foo\")\n        'foo'\n        >>> scientific(None) is None\n        True\n\n        ```\n\n    Args:\n        value (int, float, str): Input number.\n        precision (int): Number of decimal for first part of the number.\n\n    Returns:\n        str: Number in scientific notation z.wq x 10\u207f.\n    \"\"\"\n    exponents = {\n        \"0\": \"\u2070\",\n        \"1\": \"\u00b9\",\n        \"2\": \"\u00b2\",\n        \"3\": \"\u00b3\",\n        \"4\": \"\u2074\",\n        \"5\": \"\u2075\",\n        \"6\": \"\u2076\",\n        \"7\": \"\u2077\",\n        \"8\": \"\u2078\",\n        \"9\": \"\u2079\",\n        \"+\": \"\u207a\",\n        \"-\": \"\u207b\",\n    }\n    negative = False\n    try:\n        if \"-\" in str(value):\n            value = str(value).replace(\"-\", \"\")\n            negative = True\n\n        if isinstance(value, str):\n            value = float(value)\n\n        fmt = \"{:.%se}\" % str(int(precision))\n        n = fmt.format(value)\n\n    except (ValueError, TypeError):\n        return value\n\n    part1, part2 = n.split(\"e\")\n    if \"-0\" in part2:\n        part2 = part2.replace(\"-0\", \"-\")\n\n    if \"+0\" in part2:\n        part2 = part2.replace(\"+0\", \"\")\n\n    new_part2 = []\n    if negative:\n        new_part2.append(exponents[\"-\"])\n\n    for char in part2:\n        new_part2.append(exponents[char])\n\n    final_str = part1 + \" x 10\" + \"\".join(new_part2)\n\n    return final_str",
    "docstring": "Return number in string scientific notation z.wq x 10\u207f.\n\nExamples:\n    ```pycon\n    >>> scientific(float(0.3))\n    '3.00 x 10\u207b\u00b9'\n    >>> scientific(int(500))\n    '5.00 x 10\u00b2'\n    >>> scientific(-1000)\n    '1.00 x 10\u207b\u00b3'\n    >>> scientific(1000, 1)\n    '1.0 x 10\u00b3'\n    >>> scientific(1000, 3)\n    '1.000 x 10\u00b3'\n    >>> scientific(\"99\")\n    '9.90 x 10\u00b9'\n    >>> scientific(\"foo\")\n    'foo'\n    >>> scientific(None) is None\n    True\n\n    ```\n\nArgs:\n    value (int, float, str): Input number.\n    precision (int): Number of decimal for first part of the number.\n\nReturns:\n    str: Number in scientific notation z.wq x 10\u207f."
  },
  {
    "function": "clamp",
    "code": "def clamp(value, format=\"{:}\", floor=None, ceil=None, floor_token=\"<\", ceil_token=\">\"):\n    \"\"\"Returns number with the specified format, clamped between floor and ceil.\n\n    If the number is larger than ceil or smaller than floor, then the respective limit\n    will be returned, formatted and prepended with a token specifying as such.\n\n    Examples:\n        ```pycon\n        >>> clamp(123.456)\n        '123.456'\n        >>> clamp(0.0001, floor=0.01)\n        '<0.01'\n        >>> clamp(0.99, format=\"{:.0%}\", ceil=0.99)\n        '99%'\n        >>> clamp(0.999, format=\"{:.0%}\", ceil=0.99)\n        '>99%'\n        >>> clamp(1, format=intword, floor=1e6, floor_token=\"under \")\n        'under 1.0 million'\n        >>> clamp(None) is None\n        True\n\n        ```\n\n    Args:\n        value (int, float): Input number.\n        format (str OR callable): Can either be a formatting string, or a callable\n            function that receives value and returns a string.\n        floor (int, float): Smallest value before clamping.\n        ceil (int, float): Largest value before clamping.\n        floor_token (str): If value is smaller than floor, token will be prepended\n            to output.\n        ceil_token (str): If value is larger than ceil, token will be prepended\n            to output.\n\n    Returns:\n        str: Formatted number. The output is clamped between the indicated floor and\n        ceil. If the number if larger than ceil or smaller than floor, the output will\n        be prepended with a token indicating as such.\n\n    \"\"\"\n    if value is None:\n        return None\n\n    if floor is not None and value < floor:\n        value = floor\n        token = floor_token\n    elif ceil is not None and value > ceil:\n        value = ceil\n        token = ceil_token\n    else:\n        token = \"\"\n\n    if isinstance(format, str):\n        return token + format.format(value)\n    elif callable(format):\n        return token + format(value)\n    else:\n        raise ValueError(\n            \"Invalid format. Must be either a valid formatting string, or a function \"\n            \"that accepts value and returns a string.\"\n        )",
    "docstring": "Returns number with the specified format, clamped between floor and ceil.\n\nIf the number is larger than ceil or smaller than floor, then the respective limit\nwill be returned, formatted and prepended with a token specifying as such.\n\nExamples:\n    ```pycon\n    >>> clamp(123.456)\n    '123.456'\n    >>> clamp(0.0001, floor=0.01)\n    '<0.01'\n    >>> clamp(0.99, format=\"{:.0%}\", ceil=0.99)\n    '99%'\n    >>> clamp(0.999, format=\"{:.0%}\", ceil=0.99)\n    '>99%'\n    >>> clamp(1, format=intword, floor=1e6, floor_token=\"under \")\n    'under 1.0 million'\n    >>> clamp(None) is None\n    True\n\n    ```\n\nArgs:\n    value (int, float): Input number.\n    format (str OR callable): Can either be a formatting string, or a callable\n        function that receives value and returns a string.\n    floor (int, float): Smallest value before clamping.\n    ceil (int, float): Largest value before clamping.\n    floor_token (str): If value is smaller than floor, token will be prepended\n        to output.\n    ceil_token (str): If value is larger than ceil, token will be prepended\n        to output.\n\nReturns:\n    str: Formatted number. The output is clamped between the indicated floor and\n    ceil. If the number if larger than ceil or smaller than floor, the output will\n    be prepended with a token indicating as such."
  },
  {
    "function": "_abs_timedelta",
    "code": "def _abs_timedelta(delta):\n    \"\"\"Return an \"absolute\" value for a timedelta, always representing a time distance.\n\n    Args:\n        delta (datetime.timedelta): Input timedelta.\n\n    Returns:\n        datetime.timedelta: Absolute timedelta.\n    \"\"\"\n    if delta.days < 0:\n        now = _now()\n        return now - (now + delta)\n    return delta",
    "docstring": "Return an \"absolute\" value for a timedelta, always representing a time distance.\n\nArgs:\n    delta (datetime.timedelta): Input timedelta.\n\nReturns:\n    datetime.timedelta: Absolute timedelta."
  },
  {
    "function": "_date_and_delta",
    "code": "def _date_and_delta(value, *, now=None):\n    \"\"\"Turn a value into a date and a timedelta which represents how long ago it was.\n\n    If that's not possible, return `(None, value)`.\n    \"\"\"\n    if not now:\n        now = _now()\n    if isinstance(value, dt.datetime):\n        date = value\n        delta = now - value\n    elif isinstance(value, dt.timedelta):\n        date = now - value\n        delta = value\n    else:\n        try:\n            value = int(value)\n            delta = dt.timedelta(seconds=value)\n            date = now - delta\n        except (ValueError, TypeError):\n            return None, value\n    return date, _abs_timedelta(delta)",
    "docstring": "Turn a value into a date and a timedelta which represents how long ago it was.\n\nIf that's not possible, return `(None, value)`."
  },
  {
    "function": "naturaldelta",
    "code": "def naturaldelta(\n    value,\n    months=True,\n    minimum_unit=\"seconds\",\n) -> str:\n    \"\"\"Return a natural representation of a timedelta or number of seconds.\n\n    This is similar to `naturaltime`, but does not add tense to the result.\n\n    Args:\n        value (datetime.timedelta or int): A timedelta or a number of seconds.\n        months (bool): If `True`, then a number of months (based on 30.5 days) will be\n            used for fuzziness between years.\n        minimum_unit (str): The lowest unit that can be used.\n        when (datetime.datetime): Removed in version 4.0; If you need to\n            construct a timedelta, do it inline as the first argument.\n\n    Returns:\n        str (str or `value`): A natural representation of the amount of time\n            elapsed unless `value` is not datetime.timedelta or cannot be\n            converted to int. In that case, a `value` is returned unchanged.\n\n    Raises:\n        OverflowError: If `value` is too large to convert to datetime.timedelta.\n\n    Examples\n        Compare two timestamps in a custom local timezone::\n\n        import datetime as dt\n        from dateutil.tz import gettz\n\n        berlin = gettz(\"Europe/Berlin\")\n        now = dt.datetime.now(tz=berlin)\n        later = now + dt.timedelta(minutes=30)\n\n        assert naturaldelta(later - now) == \"30 minutes\"\n    \"\"\"\n    tmp = Unit[minimum_unit.upper()]\n    if tmp not in (Unit.SECONDS, Unit.MILLISECONDS, Unit.MICROSECONDS):\n        raise ValueError(f\"Minimum unit '{minimum_unit}' not supported\")\n    minimum_unit = tmp\n\n    if isinstance(value, dt.timedelta):\n        delta = value\n    else:\n        try:\n            value = int(value)\n            delta = dt.timedelta(seconds=value)\n        except (ValueError, TypeError):\n            return value\n\n    use_months = months\n\n    seconds = abs(delta.seconds)\n    days = abs(delta.days)\n    years = days // 365\n    days = days % 365\n    months = int(days // 30.5)\n\n    if not years and days < 1:\n        if seconds == 0:\n            if minimum_unit == Unit.MICROSECONDS and delta.microseconds < 1000:\n                return (\n                    _ngettext(\"%d microsecond\", \"%d microseconds\", delta.microseconds)\n                    % delta.microseconds\n                )\n            elif minimum_unit == Unit.MILLISECONDS or (\n                minimum_unit == Unit.MICROSECONDS\n                and 1000 <= delta.microseconds < 1_000_000\n            ):\n                milliseconds = delta.microseconds / 1000\n                return (\n                    _ngettext(\"%d millisecond\", \"%d milliseconds\", milliseconds)\n                    % milliseconds\n                )\n            return _(\"a moment\")\n        elif seconds == 1:\n            return _(\"a second\")\n        elif seconds < 60:\n            return _ngettext(\"%d second\", \"%d seconds\", seconds) % seconds\n        elif 60 <= seconds < 120:\n            return _(\"a minute\")\n        elif 120 <= seconds < 3600:\n            minutes = seconds // 60\n            return _ngettext(\"%d minute\", \"%d minutes\", minutes) % minutes\n        elif 3600 <= seconds < 3600 * 2:\n            return _(\"an hour\")\n        elif 3600 < seconds:\n            hours = seconds // 3600\n            return _ngettext(\"%d hour\", \"%d hours\", hours) % hours\n    elif years == 0:\n        if days == 1:\n            return _(\"a day\")\n        if not use_months:\n            return _ngettext(\"%d day\", \"%d days\", days) % days\n        else:\n            if not months:\n                return _ngettext(\"%d day\", \"%d days\", days) % days\n            elif months == 1:\n                return _(\"a month\")\n            else:\n                return _ngettext(\"%d month\", \"%d months\", months) % months\n    elif years == 1:\n        if not months and not days:\n            return _(\"a year\")\n        elif not months:\n            return _ngettext(\"1 year, %d day\", \"1 year, %d days\", days) % days\n        elif use_months:\n            if months == 1:\n                return _(\"1 year, 1 month\")\n            else:\n                return (\n                    _ngettext(\"1 year, %d month\", \"1 year, %d months\", months) % months\n                )\n        else:\n            return _ngettext(\"1 year, %d day\", \"1 year, %d days\", days) % days\n    else:\n        return _ngettext(\"%s year\", \"%s years\", years) % intcomma(years)",
    "docstring": "Return a natural representation of a timedelta or number of seconds.\n\nThis is similar to `naturaltime`, but does not add tense to the result.\n\nArgs:\n    value (datetime.timedelta or int): A timedelta or a number of seconds.\n    months (bool): If `True`, then a number of months (based on 30.5 days) will be\n        used for fuzziness between years.\n    minimum_unit (str): The lowest unit that can be used.\n    when (datetime.datetime): Removed in version 4.0; If you need to\n        construct a timedelta, do it inline as the first argument.\n\nReturns:\n    str (str or `value`): A natural representation of the amount of time\n        elapsed unless `value` is not datetime.timedelta or cannot be\n        converted to int. In that case, a `value` is returned unchanged.\n\nRaises:\n    OverflowError: If `value` is too large to convert to datetime.timedelta.\n\nExamples\n    Compare two timestamps in a custom local timezone::\n\n    import datetime as dt\n    from dateutil.tz import gettz\n\n    berlin = gettz(\"Europe/Berlin\")\n    now = dt.datetime.now(tz=berlin)\n    later = now + dt.timedelta(minutes=30)\n\n    assert naturaldelta(later - now) == \"30 minutes\""
  },
  {
    "function": "naturaltime",
    "code": "def naturaltime(\n    value,\n    future=False,\n    months=True,\n    minimum_unit=\"seconds\",\n    when=None,\n) -> str:\n    \"\"\"Return a natural representation of a time in a resolution that makes sense.\n\n    This is more or less compatible with Django's `naturaltime` filter.\n\n    Args:\n        value (datetime.datetime, int): A `datetime` or a number of seconds.\n        future (bool): Ignored for `datetime`s, where the tense is always figured out\n            based on the current time. For integers, the return value will be past tense\n            by default, unless future is `True`.\n        months (bool): If `True`, then a number of months (based on 30.5 days) will be\n            used for fuzziness between years.\n        minimum_unit (str): The lowest unit that can be used.\n        when (datetime.datetime): Point in time relative to which _value_ is\n            interpreted.  Defaults to the current time in the local timezone.\n\n    Returns:\n        str: A natural representation of the input in a resolution that makes sense.\n    \"\"\"\n    now = when or _now()\n    date, delta = _date_and_delta(value, now=now)\n    if date is None:\n        return value\n    # determine tense by value only if datetime/timedelta were passed\n    if isinstance(value, (dt.datetime, dt.timedelta)):\n        future = date > now\n\n    ago = _(\"%s from now\") if future else _(\"%s ago\")\n    delta = naturaldelta(delta, months, minimum_unit)\n\n    if delta == _(\"a moment\"):\n        return _(\"now\")\n\n    return ago % delta",
    "docstring": "Return a natural representation of a time in a resolution that makes sense.\n\nThis is more or less compatible with Django's `naturaltime` filter.\n\nArgs:\n    value (datetime.datetime, int): A `datetime` or a number of seconds.\n    future (bool): Ignored for `datetime`s, where the tense is always figured out\n        based on the current time. For integers, the return value will be past tense\n        by default, unless future is `True`.\n    months (bool): If `True`, then a number of months (based on 30.5 days) will be\n        used for fuzziness between years.\n    minimum_unit (str): The lowest unit that can be used.\n    when (datetime.datetime): Point in time relative to which _value_ is\n        interpreted.  Defaults to the current time in the local timezone.\n\nReturns:\n    str: A natural representation of the input in a resolution that makes sense."
  },
  {
    "function": "naturalday",
    "code": "def naturalday(value, format=\"%b %d\") -> str:\n    \"\"\"Return a natural day.\n\n    For date values that are tomorrow, today or yesterday compared to\n    present day return representing string. Otherwise, return a string\n    formatted according to `format`.\n\n    \"\"\"\n    try:\n        value = dt.date(value.year, value.month, value.day)\n    except AttributeError:\n        # Passed value wasn't date-ish\n        return value\n    except (OverflowError, ValueError):\n        # Date arguments out of range\n        return value\n    delta = value - dt.date.today()\n    if delta.days == 0:\n        return _(\"today\")\n    elif delta.days == 1:\n        return _(\"tomorrow\")\n    elif delta.days == -1:\n        return _(\"yesterday\")\n    return value.strftime(format)",
    "docstring": "Return a natural day.\n\nFor date values that are tomorrow, today or yesterday compared to\npresent day return representing string. Otherwise, return a string\nformatted according to `format`."
  },
  {
    "function": "naturaldate",
    "code": "def naturaldate(value) -> str:\n    \"\"\"Like `naturalday`, but append a year for dates more than ~five months away.\"\"\"\n    try:\n        value = dt.date(value.year, value.month, value.day)\n    except AttributeError:\n        # Passed value wasn't date-ish\n        return value\n    except (OverflowError, ValueError):\n        # Date arguments out of range\n        return value\n    delta = _abs_timedelta(value - dt.date.today())\n    if delta.days >= 5 * 365 / 12:\n        return naturalday(value, \"%b %d %Y\")\n    return naturalday(value)",
    "docstring": "Like `naturalday`, but append a year for dates more than ~five months away."
  },
  {
    "function": "_quotient_and_remainder",
    "code": "def _quotient_and_remainder(value, divisor, unit, minimum_unit, suppress):\n    \"\"\"Divide `value` by `divisor` returning the quotient and remainder.\n\n    If `unit` is `minimum_unit`, makes the quotient a float number and the remainder\n    will be zero. The rational is that if `unit` is the unit of the quotient, we cannot\n    represent the remainder because it would require a unit smaller than the\n    `minimum_unit`.\n\n    >>> from humanize.time import _quotient_and_remainder, Unit\n    >>> _quotient_and_remainder(36, 24, Unit.DAYS, Unit.DAYS, [])\n    (1.5, 0)\n\n    If unit is in `suppress`, the quotient will be zero and the remainder will be the\n    initial value. The idea is that if we cannot use `unit`, we are forced to use a\n    lower unit so we cannot do the division.\n\n    >>> _quotient_and_remainder(36, 24, Unit.DAYS, Unit.HOURS, [Unit.DAYS])\n    (0, 36)\n\n    In other case return quotient and remainder as `divmod` would do it.\n\n    >>> _quotient_and_remainder(36, 24, Unit.DAYS, Unit.HOURS, [])\n    (1, 12)\n\n    \"\"\"\n    if unit == minimum_unit:\n        return (value / divisor, 0)\n    elif unit in suppress:\n        return (0, value)\n    else:\n        return divmod(value, divisor)",
    "docstring": "Divide `value` by `divisor` returning the quotient and remainder.\n\nIf `unit` is `minimum_unit`, makes the quotient a float number and the remainder\nwill be zero. The rational is that if `unit` is the unit of the quotient, we cannot\nrepresent the remainder because it would require a unit smaller than the\n`minimum_unit`.\n\n>>> from humanize.time import _quotient_and_remainder, Unit\n>>> _quotient_and_remainder(36, 24, Unit.DAYS, Unit.DAYS, [])\n(1.5, 0)\n\nIf unit is in `suppress`, the quotient will be zero and the remainder will be the\ninitial value. The idea is that if we cannot use `unit`, we are forced to use a\nlower unit so we cannot do the division.\n\n>>> _quotient_and_remainder(36, 24, Unit.DAYS, Unit.HOURS, [Unit.DAYS])\n(0, 36)\n\nIn other case return quotient and remainder as `divmod` would do it.\n\n>>> _quotient_and_remainder(36, 24, Unit.DAYS, Unit.HOURS, [])\n(1, 12)"
  },
  {
    "function": "_carry",
    "code": "def _carry(value1, value2, ratio, unit, min_unit, suppress):\n    \"\"\"Return a tuple with two values.\n\n    If the unit is in `suppress`, multiply `value1` by `ratio` and add it to `value2`\n    (carry to right). The idea is that if we cannot represent `value1` we need to\n    represent it in a lower unit.\n\n    >>> from humanize.time import _carry, Unit\n    >>> _carry(2, 6, 24, Unit.DAYS, Unit.SECONDS, [Unit.DAYS])\n    (0, 54)\n\n    If the unit is the minimum unit, `value2` is divided by `ratio` and added to\n    `value1` (carry to left). We assume that `value2` has a lower unit so we need to\n    carry it to `value1`.\n\n    >>> _carry(2, 6, 24, Unit.DAYS, Unit.DAYS, [])\n    (2.25, 0)\n\n    Otherwise, just return the same input:\n\n    >>> _carry(2, 6, 24, Unit.DAYS, Unit.SECONDS, [])\n    (2, 6)\n    \"\"\"\n    if unit == min_unit:\n        return (value1 + value2 / ratio, 0)\n    elif unit in suppress:\n        return (0, value2 + value1 * ratio)\n    else:\n        return (value1, value2)",
    "docstring": "Return a tuple with two values.\n\nIf the unit is in `suppress`, multiply `value1` by `ratio` and add it to `value2`\n(carry to right). The idea is that if we cannot represent `value1` we need to\nrepresent it in a lower unit.\n\n>>> from humanize.time import _carry, Unit\n>>> _carry(2, 6, 24, Unit.DAYS, Unit.SECONDS, [Unit.DAYS])\n(0, 54)\n\nIf the unit is the minimum unit, `value2` is divided by `ratio` and added to\n`value1` (carry to left). We assume that `value2` has a lower unit so we need to\ncarry it to `value1`.\n\n>>> _carry(2, 6, 24, Unit.DAYS, Unit.DAYS, [])\n(2.25, 0)\n\nOtherwise, just return the same input:\n\n>>> _carry(2, 6, 24, Unit.DAYS, Unit.SECONDS, [])\n(2, 6)"
  },
  {
    "function": "_suitable_minimum_unit",
    "code": "def _suitable_minimum_unit(min_unit, suppress):\n    \"\"\"Return a minimum unit suitable that is not suppressed.\n\n    If not suppressed, return the same unit:\n\n    >>> from humanize.time import _suitable_minimum_unit, Unit\n    >>> _suitable_minimum_unit(Unit.HOURS, []).name\n    'HOURS'\n\n    But if suppressed, find a unit greather than the original one that is not\n    suppressed:\n\n    >>> _suitable_minimum_unit(Unit.HOURS, [Unit.HOURS]).name\n    'DAYS'\n\n    >>> _suitable_minimum_unit(Unit.HOURS, [Unit.HOURS, Unit.DAYS]).name\n    'MONTHS'\n    \"\"\"\n    if min_unit in suppress:\n        for unit in Unit:\n            if unit > min_unit and unit not in suppress:\n                return unit\n\n        raise ValueError(\n            \"Minimum unit is suppressed and no suitable replacement was found\"\n        )\n\n    return min_unit",
    "docstring": "Return a minimum unit suitable that is not suppressed.\n\nIf not suppressed, return the same unit:\n\n>>> from humanize.time import _suitable_minimum_unit, Unit\n>>> _suitable_minimum_unit(Unit.HOURS, []).name\n'HOURS'\n\nBut if suppressed, find a unit greather than the original one that is not\nsuppressed:\n\n>>> _suitable_minimum_unit(Unit.HOURS, [Unit.HOURS]).name\n'DAYS'\n\n>>> _suitable_minimum_unit(Unit.HOURS, [Unit.HOURS, Unit.DAYS]).name\n'MONTHS'"
  },
  {
    "function": "_suppress_lower_units",
    "code": "def _suppress_lower_units(min_unit, suppress):\n    \"\"\"Extend suppressed units (if any) with all units lower than the minimum unit.\n\n    >>> from humanize.time import _suppress_lower_units, Unit\n    >>> [x.name for x in sorted(_suppress_lower_units(Unit.SECONDS, [Unit.DAYS]))]\n    ['MICROSECONDS', 'MILLISECONDS', 'DAYS']\n    \"\"\"\n    suppress = set(suppress)\n    for u in Unit:\n        if u == min_unit:\n            break\n        suppress.add(u)\n\n    return suppress",
    "docstring": "Extend suppressed units (if any) with all units lower than the minimum unit.\n\n>>> from humanize.time import _suppress_lower_units, Unit\n>>> [x.name for x in sorted(_suppress_lower_units(Unit.SECONDS, [Unit.DAYS]))]\n['MICROSECONDS', 'MILLISECONDS', 'DAYS']"
  },
  {
    "function": "precisedelta",
    "code": "def precisedelta(value, minimum_unit=\"seconds\", suppress=(), format=\"%0.2f\") -> str:\n    \"\"\"Return a precise representation of a timedelta.\n\n    ```pycon\n    >>> import datetime as dt\n    >>> from humanize.time import precisedelta\n\n    >>> delta = dt.timedelta(seconds=3633, days=2, microseconds=123000)\n    >>> precisedelta(delta)\n    '2 days, 1 hour and 33.12 seconds'\n\n    ```\n\n    A custom `format` can be specified to control how the fractional part\n    is represented:\n\n    ```pycon\n    >>> precisedelta(delta, format=\"%0.4f\")\n    '2 days, 1 hour and 33.1230 seconds'\n\n    ```\n\n    Instead, the `minimum_unit` can be changed to have a better resolution;\n    the function will still readjust the unit to use the greatest of the\n    units that does not lose precision.\n\n    For example setting microseconds but still representing the date with milliseconds:\n\n    ```pycon\n    >>> precisedelta(delta, minimum_unit=\"microseconds\")\n    '2 days, 1 hour, 33 seconds and 123 milliseconds'\n\n    ```\n\n    If desired, some units can be suppressed: you will not see them represented and the\n    time of the other units will be adjusted to keep representing the same timedelta:\n\n    ```pycon\n    >>> precisedelta(delta, suppress=['days'])\n    '49 hours and 33.12 seconds'\n\n    ```\n\n    Note that microseconds precision is lost if the seconds and all\n    the units below are suppressed:\n\n    ```pycon\n    >>> delta = dt.timedelta(seconds=90, microseconds=100)\n    >>> precisedelta(delta, suppress=['seconds', 'milliseconds', 'microseconds'])\n    '1.50 minutes'\n\n    ```\n\n    If the delta is too small to be represented with the minimum unit,\n    a value of zero will be returned:\n\n    ```pycon\n    >>> delta = dt.timedelta(seconds=1)\n    >>> precisedelta(delta, minimum_unit=\"minutes\")\n    '0.02 minutes'\n\n    >>> delta = dt.timedelta(seconds=0.1)\n    >>> precisedelta(delta, minimum_unit=\"minutes\")\n    '0 minutes'\n\n    ```\n    \"\"\"\n    date, delta = _date_and_delta(value)\n    if date is None:\n        return value\n\n    suppress = [Unit[s.upper()] for s in suppress]\n\n    # Find a suitable minimum unit (it can be greater the one that the\n    # user gave us if it is suppressed).\n    min_unit = Unit[minimum_unit.upper()]\n    min_unit = _suitable_minimum_unit(min_unit, suppress)\n    del minimum_unit\n\n    # Expand the suppressed units list/set to include all the units\n    # that are below the minimum unit\n    suppress = _suppress_lower_units(min_unit, suppress)\n\n    # handy aliases\n    days = delta.days\n    secs = delta.seconds\n    usecs = delta.microseconds\n\n    MICROSECONDS, MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, MONTHS, YEARS = list(\n        Unit\n    )\n\n    # Given DAYS compute YEARS and the remainder of DAYS as follows:\n    #   if YEARS is the minimum unit, we cannot use DAYS so\n    #   we will use a float for YEARS and 0 for DAYS:\n    #       years, days = years/days, 0\n    #\n    #   if YEARS is suppressed, use DAYS:\n    #       years, days = 0, days\n    #\n    #   otherwise:\n    #       years, days = divmod(years, days)\n    #\n    # The same applies for months, hours, minutes and milliseconds below\n    years, days = _quotient_and_remainder(days, 365, YEARS, min_unit, suppress)\n    months, days = _quotient_and_remainder(days, 30.5, MONTHS, min_unit, suppress)\n\n    # If DAYS is not in suppress, we can represent the days but\n    # if it is a suppressed unit, we need to carry it to a lower unit,\n    # seconds in this case.\n    #\n    # The same applies for secs and usecs below\n    days, secs = _carry(days, secs, 24 * 3600, DAYS, min_unit, suppress)\n\n    hours, secs = _quotient_and_remainder(secs, 3600, HOURS, min_unit, suppress)\n    minutes, secs = _quotient_and_remainder(secs, 60, MINUTES, min_unit, suppress)\n\n    secs, usecs = _carry(secs, usecs, 1e6, SECONDS, min_unit, suppress)\n\n    msecs, usecs = _quotient_and_remainder(\n        usecs, 1000, MILLISECONDS, min_unit, suppress\n    )\n\n    # if _unused != 0 we had lost some precision\n    usecs, _unused = _carry(usecs, 0, 1, MICROSECONDS, min_unit, suppress)\n\n    fmts = [\n        (\"%d year\", \"%d years\", years),\n        (\"%d month\", \"%d months\", months),\n        (\"%d day\", \"%d days\", days),\n        (\"%d hour\", \"%d hours\", hours),\n        (\"%d minute\", \"%d minutes\", minutes),\n        (\"%d second\", \"%d seconds\", secs),\n        (\"%d millisecond\", \"%d milliseconds\", msecs),\n        (\"%d microsecond\", \"%d microseconds\", usecs),\n    ]\n\n    texts = []\n    for unit, fmt in zip(reversed(Unit), fmts):\n        singular_txt, plural_txt, value = fmt\n        if value > 0 or (not texts and unit == min_unit):\n            fmt_txt = _ngettext(singular_txt, plural_txt, value)\n            if unit == min_unit and math.modf(value)[0] > 0:\n                fmt_txt = fmt_txt.replace(\"%d\", format)\n            elif unit == YEARS:\n                fmt_txt = fmt_txt.replace(\"%d\", \"%s\")\n                texts.append(fmt_txt % intcomma(value))\n                continue\n\n            texts.append(fmt_txt % value)\n\n        if unit == min_unit:\n            break\n\n    if len(texts) == 1:\n        return texts[0]\n\n    head = \", \".join(texts[:-1])\n    tail = texts[-1]\n\n    return _(\"%s and %s\") % (head, tail)",
    "docstring": "Return a precise representation of a timedelta.\n\n```pycon\n>>> import datetime as dt\n>>> from humanize.time import precisedelta\n\n>>> delta = dt.timedelta(seconds=3633, days=2, microseconds=123000)\n>>> precisedelta(delta)\n'2 days, 1 hour and 33.12 seconds'\n\n```\n\nA custom `format` can be specified to control how the fractional part\nis represented:\n\n```pycon\n>>> precisedelta(delta, format=\"%0.4f\")\n'2 days, 1 hour and 33.1230 seconds'\n\n```\n\nInstead, the `minimum_unit` can be changed to have a better resolution;\nthe function will still readjust the unit to use the greatest of the\nunits that does not lose precision.\n\nFor example setting microseconds but still representing the date with milliseconds:\n\n```pycon\n>>> precisedelta(delta, minimum_unit=\"microseconds\")\n'2 days, 1 hour, 33 seconds and 123 milliseconds'\n\n```\n\nIf desired, some units can be suppressed: you will not see them represented and the\ntime of the other units will be adjusted to keep representing the same timedelta:\n\n```pycon\n>>> precisedelta(delta, suppress=['days'])\n'49 hours and 33.12 seconds'\n\n```\n\nNote that microseconds precision is lost if the seconds and all\nthe units below are suppressed:\n\n```pycon\n>>> delta = dt.timedelta(seconds=90, microseconds=100)\n>>> precisedelta(delta, suppress=['seconds', 'milliseconds', 'microseconds'])\n'1.50 minutes'\n\n```\n\nIf the delta is too small to be represented with the minimum unit,\na value of zero will be returned:\n\n```pycon\n>>> delta = dt.timedelta(seconds=1)\n>>> precisedelta(delta, minimum_unit=\"minutes\")\n'0.02 minutes'\n\n>>> delta = dt.timedelta(seconds=0.1)\n>>> precisedelta(delta, minimum_unit=\"minutes\")\n'0 minutes'\n\n```"
  },
  {
    "function": "chunked",
    "code": "def chunked(iterable, n, strict=False):\n    \"\"\"Break *iterable* into lists of length *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6], 3))\n        [[1, 2, 3], [4, 5, 6]]\n\n    By the default, the last yielded list will have fewer than *n* elements\n    if the length of *iterable* is not divisible by *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))\n        [[1, 2, 3], [4, 5, 6], [7, 8]]\n\n    To use a fill-in value instead, see the :func:`grouper` recipe.\n\n    If the length of *iterable* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    list is yielded.\n\n    \"\"\"\n    iterator = iter(partial(take, n, iter(iterable)), [])\n    if strict:\n        if n is None:\n            raise ValueError('n must not be None when using strict mode.')\n\n        def ret():\n            for chunk in iterator:\n                if len(chunk) != n:\n                    raise ValueError('iterable is not divisible by n.')\n                yield chunk\n\n        return ret()\n    else:\n        return iterator",
    "docstring": "Break *iterable* into lists of length *n*:\n\n    >>> list(chunked([1, 2, 3, 4, 5, 6], 3))\n    [[1, 2, 3], [4, 5, 6]]\n\nBy the default, the last yielded list will have fewer than *n* elements\nif the length of *iterable* is not divisible by *n*:\n\n    >>> list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))\n    [[1, 2, 3], [4, 5, 6], [7, 8]]\n\nTo use a fill-in value instead, see the :func:`grouper` recipe.\n\nIf the length of *iterable* is not divisible by *n* and *strict* is\n``True``, then ``ValueError`` will be raised before the last\nlist is yielded."
  },
  {
    "function": "first",
    "code": "def first(iterable, default=_marker):\n    \"\"\"Return the first item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> first([0, 1, 2, 3])\n        0\n        >>> first([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n\n    :func:`first` is useful when you have a generator of expensive-to-retrieve\n    values and want any arbitrary one. It is marginally shorter than\n    ``next(iter(iterable), default)``.\n\n    \"\"\"\n    for item in iterable:\n        return item\n    if default is _marker:\n        raise ValueError(\n            'first() was called on an empty iterable, '\n            'and no default value was provided.'\n        )\n    return default",
    "docstring": "Return the first item of *iterable*, or *default* if *iterable* is\nempty.\n\n    >>> first([0, 1, 2, 3])\n    0\n    >>> first([], 'some default')\n    'some default'\n\nIf *default* is not provided and there are no items in the iterable,\nraise ``ValueError``.\n\n:func:`first` is useful when you have a generator of expensive-to-retrieve\nvalues and want any arbitrary one. It is marginally shorter than\n``next(iter(iterable), default)``."
  },
  {
    "function": "last",
    "code": "def last(iterable, default=_marker):\n    \"\"\"Return the last item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> last([0, 1, 2, 3])\n        3\n        >>> last([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    \"\"\"\n    try:\n        if isinstance(iterable, Sequence):\n            return iterable[-1]\n        # Work around https://bugs.python.org/issue38525\n        if getattr(iterable, '__reversed__', None):\n            return next(reversed(iterable))\n        return deque(iterable, maxlen=1)[-1]\n    except (IndexError, TypeError, StopIteration):\n        if default is _marker:\n            raise ValueError(\n                'last() was called on an empty iterable, '\n                'and no default value was provided.'\n            )\n        return default",
    "docstring": "Return the last item of *iterable*, or *default* if *iterable* is\nempty.\n\n    >>> last([0, 1, 2, 3])\n    3\n    >>> last([], 'some default')\n    'some default'\n\nIf *default* is not provided and there are no items in the iterable,\nraise ``ValueError``."
  },
  {
    "function": "nth_or_last",
    "code": "def nth_or_last(iterable, n, default=_marker):\n    \"\"\"Return the nth or the last item of *iterable*,\n    or *default* if *iterable* is empty.\n\n        >>> nth_or_last([0, 1, 2, 3], 2)\n        2\n        >>> nth_or_last([0, 1], 2)\n        1\n        >>> nth_or_last([], 0, 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    \"\"\"\n    return last(islice(iterable, n + 1), default=default)",
    "docstring": "Return the nth or the last item of *iterable*,\nor *default* if *iterable* is empty.\n\n    >>> nth_or_last([0, 1, 2, 3], 2)\n    2\n    >>> nth_or_last([0, 1], 2)\n    1\n    >>> nth_or_last([], 0, 'some default')\n    'some default'\n\nIf *default* is not provided and there are no items in the iterable,\nraise ``ValueError``."
  },
  {
    "function": "consumer",
    "code": "def consumer(func):\n    \"\"\"Decorator that automatically advances a PEP-342-style \"reverse iterator\"\n    to its first yield point so you don't have to call ``next()`` on it\n    manually.\n\n        >>> @consumer\n        ... def tally():\n        ...     i = 0\n        ...     while True:\n        ...         print('Thing number %s is %s.' % (i, (yield)))\n        ...         i += 1\n        ...\n        >>> t = tally()\n        >>> t.send('red')\n        Thing number 0 is red.\n        >>> t.send('fish')\n        Thing number 1 is fish.\n\n    Without the decorator, you would have to call ``next(t)`` before\n    ``t.send()`` could be used.\n\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        gen = func(*args, **kwargs)\n        next(gen)\n        return gen\n\n    return wrapper",
    "docstring": "Decorator that automatically advances a PEP-342-style \"reverse iterator\"\nto its first yield point so you don't have to call ``next()`` on it\nmanually.\n\n    >>> @consumer\n    ... def tally():\n    ...     i = 0\n    ...     while True:\n    ...         print('Thing number %s is %s.' % (i, (yield)))\n    ...         i += 1\n    ...\n    >>> t = tally()\n    >>> t.send('red')\n    Thing number 0 is red.\n    >>> t.send('fish')\n    Thing number 1 is fish.\n\nWithout the decorator, you would have to call ``next(t)`` before\n``t.send()`` could be used."
  },
  {
    "function": "ilen",
    "code": "def ilen(iterable):\n    \"\"\"Return the number of items in *iterable*.\n\n    For example, there are 168 prime numbers below 1,000:\n\n        >>> ilen(sieve(1000))\n        168\n\n    Equivalent to, but faster than::\n\n        def ilen(iterable):\n            count = 0\n            for _ in iterable:\n                count += 1\n            return count\n\n    This fully consumes the iterable, so handle with care.\n\n    \"\"\"\n    # This is the \"most beautiful of the fast variants\" of this function.\n    # If you think you can improve on it, please ensure that your version\n    # is both 10x faster and 10x more beautiful.\n    return sum(compress(repeat(1), zip(iterable)))",
    "docstring": "Return the number of items in *iterable*.\n\nFor example, there are 168 prime numbers below 1,000:\n\n    >>> ilen(sieve(1000))\n    168\n\nEquivalent to, but faster than::\n\n    def ilen(iterable):\n        count = 0\n        for _ in iterable:\n            count += 1\n        return count\n\nThis fully consumes the iterable, so handle with care."
  },
  {
    "function": "iterate",
    "code": "def iterate(func, start):\n    \"\"\"Return ``start``, ``func(start)``, ``func(func(start))``, ...\n\n    Produces an infinite iterator. To add a stopping condition,\n    use :func:`take`, ``takewhile``, or :func:`takewhile_inclusive`:.\n\n    >>> take(10, iterate(lambda x: 2*x, 1))\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n\n    >>> collatz = lambda x: 3*x + 1 if x%2==1 else x // 2\n    >>> list(takewhile_inclusive(lambda x: x!=1, iterate(collatz, 10)))\n    [10, 5, 16, 8, 4, 2, 1]\n\n    \"\"\"\n    with suppress(StopIteration):\n        while True:\n            yield start\n            start = func(start)",
    "docstring": "Return ``start``, ``func(start)``, ``func(func(start))``, ...\n\nProduces an infinite iterator. To add a stopping condition,\nuse :func:`take`, ``takewhile``, or :func:`takewhile_inclusive`:.\n\n>>> take(10, iterate(lambda x: 2*x, 1))\n[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n\n>>> collatz = lambda x: 3*x + 1 if x%2==1 else x // 2\n>>> list(takewhile_inclusive(lambda x: x!=1, iterate(collatz, 10)))\n[10, 5, 16, 8, 4, 2, 1]"
  },
  {
    "function": "with_iter",
    "code": "def with_iter(context_manager):\n    \"\"\"Wrap an iterable in a ``with`` statement, so it closes once exhausted.\n\n    For example, this will close the file when the iterator is exhausted::\n\n        upper_lines = (line.upper() for line in with_iter(open('foo')))\n\n    Any context manager which returns an iterable is a candidate for\n    ``with_iter``.\n\n    \"\"\"\n    with context_manager as iterable:\n        yield from iterable",
    "docstring": "Wrap an iterable in a ``with`` statement, so it closes once exhausted.\n\nFor example, this will close the file when the iterator is exhausted::\n\n    upper_lines = (line.upper() for line in with_iter(open('foo')))\n\nAny context manager which returns an iterable is a candidate for\n``with_iter``."
  },
  {
    "function": "one",
    "code": "def one(iterable, too_short=None, too_long=None):\n    \"\"\"Return the first item from *iterable*, which is expected to contain only\n    that item. Raise an exception if *iterable* is empty or has more than one\n    item.\n\n    :func:`one` is useful for ensuring that an iterable contains only one item.\n    For example, it can be used to retrieve the result of a database query\n    that is expected to return a single row.\n\n    If *iterable* is empty, ``ValueError`` will be raised. You may specify a\n    different exception with the *too_short* keyword:\n\n        >>> it = []\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too few items in iterable (expected 1)'\n        >>> too_short = IndexError('too few items')\n        >>> one(it, too_short=too_short)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        IndexError: too few items\n\n    Similarly, if *iterable* contains more than one item, ``ValueError`` will\n    be raised. You may specify a different exception with the *too_long*\n    keyword:\n\n        >>> it = ['too', 'many']\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: Expected exactly one item in iterable, but got 'too',\n        'many', and perhaps more.\n        >>> too_long = RuntimeError\n        >>> one(it, too_long=too_long)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        RuntimeError\n\n    Note that :func:`one` attempts to advance *iterable* twice to ensure there\n    is only one item. See :func:`spy` or :func:`peekable` to check iterable\n    contents less destructively.\n\n    \"\"\"\n    iterator = iter(iterable)\n    for first in iterator:\n        for second in iterator:\n            msg = (\n                f'Expected exactly one item in iterable, but got {first!r}, '\n                f'{second!r}, and perhaps more.'\n            )\n            raise too_long or ValueError(msg)\n        return first\n    raise too_short or ValueError('too few items in iterable (expected 1)')",
    "docstring": "Return the first item from *iterable*, which is expected to contain only\nthat item. Raise an exception if *iterable* is empty or has more than one\nitem.\n\n:func:`one` is useful for ensuring that an iterable contains only one item.\nFor example, it can be used to retrieve the result of a database query\nthat is expected to return a single row.\n\nIf *iterable* is empty, ``ValueError`` will be raised. You may specify a\ndifferent exception with the *too_short* keyword:\n\n    >>> it = []\n    >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: too few items in iterable (expected 1)'\n    >>> too_short = IndexError('too few items')\n    >>> one(it, too_short=too_short)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    IndexError: too few items\n\nSimilarly, if *iterable* contains more than one item, ``ValueError`` will\nbe raised. You may specify a different exception with the *too_long*\nkeyword:\n\n    >>> it = ['too', 'many']\n    >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: Expected exactly one item in iterable, but got 'too',\n    'many', and perhaps more.\n    >>> too_long = RuntimeError\n    >>> one(it, too_long=too_long)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    RuntimeError\n\nNote that :func:`one` attempts to advance *iterable* twice to ensure there\nis only one item. See :func:`spy` or :func:`peekable` to check iterable\ncontents less destructively."
  },
  {
    "function": "strictly_n",
    "code": "def strictly_n(iterable, n, too_short=None, too_long=None):\n    \"\"\"Validate that *iterable* has exactly *n* items and return them if\n    it does. If it has fewer than *n* items, call function *too_short*\n    with the actual number of items. If it has more than *n* items, call function\n    *too_long* with the number ``n + 1``.\n\n        >>> iterable = ['a', 'b', 'c', 'd']\n        >>> n = 4\n        >>> list(strictly_n(iterable, n))\n        ['a', 'b', 'c', 'd']\n\n    Note that the returned iterable must be consumed in order for the check to\n    be made.\n\n    By default, *too_short* and *too_long* are functions that raise\n    ``ValueError``.\n\n        >>> list(strictly_n('ab', 3))  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too few items in iterable (got 2)\n\n        >>> list(strictly_n('abc', 2))  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too many items in iterable (got at least 3)\n\n    You can instead supply functions that do something else.\n    *too_short* will be called with the number of items in *iterable*.\n    *too_long* will be called with `n + 1`.\n\n        >>> def too_short(item_count):\n        ...     raise RuntimeError\n        >>> it = strictly_n('abcd', 6, too_short=too_short)\n        >>> list(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        RuntimeError\n\n        >>> def too_long(item_count):\n        ...     print('The boss is going to hear about this')\n        >>> it = strictly_n('abcdef', 4, too_long=too_long)\n        >>> list(it)\n        The boss is going to hear about this\n        ['a', 'b', 'c', 'd']\n\n    \"\"\"\n    if too_short is None:\n        too_short = lambda item_count: raise_(\n            ValueError,\n            f'Too few items in iterable (got {item_count})',\n        )\n\n    if too_long is None:\n        too_long = lambda item_count: raise_(\n            ValueError,\n            f'Too many items in iterable (got at least {item_count})',\n        )\n\n    it = iter(iterable)\n\n    sent = 0\n    for item in islice(it, n):\n        yield item\n        sent += 1\n\n    if sent < n:\n        too_short(sent)\n        return\n\n    for item in it:\n        too_long(n + 1)\n        return",
    "docstring": "Validate that *iterable* has exactly *n* items and return them if\nit does. If it has fewer than *n* items, call function *too_short*\nwith the actual number of items. If it has more than *n* items, call function\n*too_long* with the number ``n + 1``.\n\n    >>> iterable = ['a', 'b', 'c', 'd']\n    >>> n = 4\n    >>> list(strictly_n(iterable, n))\n    ['a', 'b', 'c', 'd']\n\nNote that the returned iterable must be consumed in order for the check to\nbe made.\n\nBy default, *too_short* and *too_long* are functions that raise\n``ValueError``.\n\n    >>> list(strictly_n('ab', 3))  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: too few items in iterable (got 2)\n\n    >>> list(strictly_n('abc', 2))  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: too many items in iterable (got at least 3)\n\nYou can instead supply functions that do something else.\n*too_short* will be called with the number of items in *iterable*.\n*too_long* will be called with `n + 1`.\n\n    >>> def too_short(item_count):\n    ...     raise RuntimeError\n    >>> it = strictly_n('abcd', 6, too_short=too_short)\n    >>> list(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    RuntimeError\n\n    >>> def too_long(item_count):\n    ...     print('The boss is going to hear about this')\n    >>> it = strictly_n('abcdef', 4, too_long=too_long)\n    >>> list(it)\n    The boss is going to hear about this\n    ['a', 'b', 'c', 'd']"
  },
  {
    "function": "distinct_permutations",
    "code": "def distinct_permutations(iterable, r=None):\n    \"\"\"Yield successive distinct permutations of the elements in *iterable*.\n\n        >>> sorted(distinct_permutations([1, 0, 1]))\n        [(0, 1, 1), (1, 0, 1), (1, 1, 0)]\n\n    Equivalent to yielding from ``set(permutations(iterable))``, except\n    duplicates are not generated and thrown away. For larger input sequences\n    this is much more efficient.\n\n    Duplicate permutations arise when there are duplicated elements in the\n    input iterable. The number of items returned is\n    `n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of\n    items input, and each `x_i` is the count of a distinct item in the input\n    sequence. The function :func:`multinomial` computes this directly.\n\n    If *r* is given, only the *r*-length permutations are yielded.\n\n        >>> sorted(distinct_permutations([1, 0, 1], r=2))\n        [(0, 1), (1, 0), (1, 1)]\n        >>> sorted(distinct_permutations(range(3), r=2))\n        [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]\n\n    *iterable* need not be sortable, but note that using equal (``x == y``)\n    but non-identical (``id(x) != id(y)``) elements may produce surprising\n    behavior. For example, ``1`` and ``True`` are equal but non-identical:\n\n        >>> list(distinct_permutations([1, True, '3']))  # doctest: +SKIP\n        [\n            (1, True, '3'),\n            (1, '3', True),\n            ('3', 1, True)\n        ]\n        >>> list(distinct_permutations([1, 2, '3']))  # doctest: +SKIP\n        [\n            (1, 2, '3'),\n            (1, '3', 2),\n            (2, 1, '3'),\n            (2, '3', 1),\n            ('3', 1, 2),\n            ('3', 2, 1)\n        ]\n    \"\"\"\n\n    # Algorithm: https://w.wiki/Qai\n    def _full(A):\n        while True:\n            # Yield the permutation we have\n            yield tuple(A)\n\n            # Find the largest index i such that A[i] < A[i + 1]\n            for i in range(size - 2, -1, -1):\n                if A[i] < A[i + 1]:\n                    break\n            #  If no such index exists, this permutation is the last one\n            else:\n                return\n\n            # Find the largest index j greater than j such that A[i] < A[j]\n            for j in range(size - 1, i, -1):\n                if A[i] < A[j]:\n                    break\n\n            # Swap the value of A[i] with that of A[j], then reverse the\n            # sequence from A[i + 1] to form the new permutation\n            A[i], A[j] = A[j], A[i]\n            A[i + 1 :] = A[: i - size : -1]  # A[i + 1:][::-1]\n\n    # Algorithm: modified from the above\n    def _partial(A, r):\n        # Split A into the first r items and the last r items\n        head, tail = A[:r], A[r:]\n        right_head_indexes = range(r - 1, -1, -1)\n        left_tail_indexes = range(len(tail))\n\n        while True:\n            # Yield the permutation we have\n            yield tuple(head)\n\n            # Starting from the right, find the first index of the head with\n            # value smaller than the maximum value of the tail - call it i.\n            pivot = tail[-1]\n            for i in right_head_indexes:\n                if head[i] < pivot:\n                    break\n                pivot = head[i]\n            else:\n                return\n\n            # Starting from the left, find the first value of the tail\n            # with a value greater than head[i] and swap.\n            for j in left_tail_indexes:\n                if tail[j] > head[i]:\n                    head[i], tail[j] = tail[j], head[i]\n                    break\n            # If we didn't find one, start from the right and find the first\n            # index of the head with a value greater than head[i] and swap.\n            else:\n                for j in right_head_indexes:\n                    if head[j] > head[i]:\n                        head[i], head[j] = head[j], head[i]\n                        break\n\n            # Reverse head[i + 1:] and swap it with tail[:r - (i + 1)]\n            tail += head[: i - r : -1]  # head[i + 1:][::-1]\n            i += 1\n            head[i:], tail[:] = tail[: r - i], tail[r - i :]\n\n    items = list(iterable)\n\n    try:\n        items.sort()\n        sortable = True\n    except TypeError:\n        sortable = False\n\n        indices_dict = defaultdict(list)\n\n        for item in items:\n            indices_dict[items.index(item)].append(item)\n\n        indices = [items.index(item) for item in items]\n        indices.sort()\n\n        equivalent_items = {k: cycle(v) for k, v in indices_dict.items()}\n\n        def permuted_items(permuted_indices):\n            return tuple(\n                next(equivalent_items[index]) for index in permuted_indices\n            )\n\n    size = len(items)\n    if r is None:\n        r = size\n\n    # functools.partial(_partial, ... )\n    algorithm = _full if (r == size) else partial(_partial, r=r)\n\n    if 0 < r <= size:\n        if sortable:\n            return algorithm(items)\n        else:\n            return (\n                permuted_items(permuted_indices)\n                for permuted_indices in algorithm(indices)\n            )\n\n    return iter(() if r else ((),))",
    "docstring": "Yield successive distinct permutations of the elements in *iterable*.\n\n    >>> sorted(distinct_permutations([1, 0, 1]))\n    [(0, 1, 1), (1, 0, 1), (1, 1, 0)]\n\nEquivalent to yielding from ``set(permutations(iterable))``, except\nduplicates are not generated and thrown away. For larger input sequences\nthis is much more efficient.\n\nDuplicate permutations arise when there are duplicated elements in the\ninput iterable. The number of items returned is\n`n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of\nitems input, and each `x_i` is the count of a distinct item in the input\nsequence. The function :func:`multinomial` computes this directly.\n\nIf *r* is given, only the *r*-length permutations are yielded.\n\n    >>> sorted(distinct_permutations([1, 0, 1], r=2))\n    [(0, 1), (1, 0), (1, 1)]\n    >>> sorted(distinct_permutations(range(3), r=2))\n    [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]\n\n*iterable* need not be sortable, but note that using equal (``x == y``)\nbut non-identical (``id(x) != id(y)``) elements may produce surprising\nbehavior. For example, ``1`` and ``True`` are equal but non-identical:\n\n    >>> list(distinct_permutations([1, True, '3']))  # doctest: +SKIP\n    [\n        (1, True, '3'),\n        (1, '3', True),\n        ('3', 1, True)\n    ]\n    >>> list(distinct_permutations([1, 2, '3']))  # doctest: +SKIP\n    [\n        (1, 2, '3'),\n        (1, '3', 2),\n        (2, 1, '3'),\n        (2, '3', 1),\n        ('3', 1, 2),\n        ('3', 2, 1)\n    ]"
  },
  {
    "function": "derangements",
    "code": "def derangements(iterable, r=None):\n    \"\"\"Yield successive derangements of the elements in *iterable*.\n\n    A derangement is a permutation in which no element appears at its original\n    index. In other words, a derangement is a permutation that has no fixed points.\n\n    Suppose Alice, Bob, Carol, and Dave are playing Secret Santa.\n    The code below outputs all of the different ways to assign gift recipients\n    such that nobody is assigned to himself or herself:\n\n        >>> for d in derangements(['Alice', 'Bob', 'Carol', 'Dave']):\n        ...    print(', '.join(d))\n        Bob, Alice, Dave, Carol\n        Bob, Carol, Dave, Alice\n        Bob, Dave, Alice, Carol\n        Carol, Alice, Dave, Bob\n        Carol, Dave, Alice, Bob\n        Carol, Dave, Bob, Alice\n        Dave, Alice, Bob, Carol\n        Dave, Carol, Alice, Bob\n        Dave, Carol, Bob, Alice\n\n    If *r* is given, only the *r*-length derangements are yielded.\n\n        >>> sorted(derangements(range(3), 2))\n        [(1, 0), (1, 2), (2, 0)]\n        >>> sorted(derangements([0, 2, 3], 2))\n        [(2, 0), (2, 3), (3, 0)]\n\n    Elements are treated as unique based on their position, not on their value.\n\n    Consider the Secret Santa example with two *different* people who have\n    the *same* name. Then there are two valid gift assignments even though\n    it might appear that a person is assigned to themselves:\n\n        >>> names = ['Alice', 'Bob', 'Bob']\n        >>> list(derangements(names))\n        [('Bob', 'Bob', 'Alice'), ('Bob', 'Alice', 'Bob')]\n\n    To avoid confusion, make the inputs distinct:\n\n        >>> deduped = [f'{name}{index}' for index, name in enumerate(names)]\n        >>> list(derangements(deduped))\n        [('Bob1', 'Bob2', 'Alice0'), ('Bob2', 'Alice0', 'Bob1')]\n\n    The number of derangements of a set of size *n* is known as the\n    \"subfactorial of n\".  For n > 0, the subfactorial is:\n    ``round(math.factorial(n) / math.e)``.\n\n    References:\n\n    * Article:  https://www.numberanalytics.com/blog/ultimate-guide-to-derangements-in-combinatorics\n    * Sizes:    https://oeis.org/A000166\n    \"\"\"\n    xs = tuple(iterable)\n    ys = tuple(range(len(xs)))\n    return compress(\n        permutations(xs, r=r),\n        map(all, map(map, repeat(is_not), repeat(ys), permutations(ys, r=r))),\n    )",
    "docstring": "Yield successive derangements of the elements in *iterable*.\n\nA derangement is a permutation in which no element appears at its original\nindex. In other words, a derangement is a permutation that has no fixed points.\n\nSuppose Alice, Bob, Carol, and Dave are playing Secret Santa.\nThe code below outputs all of the different ways to assign gift recipients\nsuch that nobody is assigned to himself or herself:\n\n    >>> for d in derangements(['Alice', 'Bob', 'Carol', 'Dave']):\n    ...    print(', '.join(d))\n    Bob, Alice, Dave, Carol\n    Bob, Carol, Dave, Alice\n    Bob, Dave, Alice, Carol\n    Carol, Alice, Dave, Bob\n    Carol, Dave, Alice, Bob\n    Carol, Dave, Bob, Alice\n    Dave, Alice, Bob, Carol\n    Dave, Carol, Alice, Bob\n    Dave, Carol, Bob, Alice\n\nIf *r* is given, only the *r*-length derangements are yielded.\n\n    >>> sorted(derangements(range(3), 2))\n    [(1, 0), (1, 2), (2, 0)]\n    >>> sorted(derangements([0, 2, 3], 2))\n    [(2, 0), (2, 3), (3, 0)]\n\nElements are treated as unique based on their position, not on their value.\n\nConsider the Secret Santa example with two *different* people who have\nthe *same* name. Then there are two valid gift assignments even though\nit might appear that a person is assigned to themselves:\n\n    >>> names = ['Alice', 'Bob', 'Bob']\n    >>> list(derangements(names))\n    [('Bob', 'Bob', 'Alice'), ('Bob', 'Alice', 'Bob')]\n\nTo avoid confusion, make the inputs distinct:\n\n    >>> deduped = [f'{name}{index}' for index, name in enumerate(names)]\n    >>> list(derangements(deduped))\n    [('Bob1', 'Bob2', 'Alice0'), ('Bob2', 'Alice0', 'Bob1')]\n\nThe number of derangements of a set of size *n* is known as the\n\"subfactorial of n\".  For n > 0, the subfactorial is:\n``round(math.factorial(n) / math.e)``.\n\nReferences:\n\n* Article:  https://www.numberanalytics.com/blog/ultimate-guide-to-derangements-in-combinatorics\n* Sizes:    https://oeis.org/A000166"
  },
  {
    "function": "intersperse",
    "code": "def intersperse(e, iterable, n=1):\n    \"\"\"Intersperse filler element *e* among the items in *iterable*, leaving\n    *n* items between each filler element.\n\n        >>> list(intersperse('!', [1, 2, 3, 4, 5]))\n        [1, '!', 2, '!', 3, '!', 4, '!', 5]\n\n        >>> list(intersperse(None, [1, 2, 3, 4, 5], n=2))\n        [1, 2, None, 3, 4, None, 5]\n\n    \"\"\"\n    if n == 0:\n        raise ValueError('n must be > 0')\n    elif n == 1:\n        # interleave(repeat(e), iterable) -> e, x_0, e, x_1, e, x_2...\n        # islice(..., 1, None) -> x_0, e, x_1, e, x_2...\n        return islice(interleave(repeat(e), iterable), 1, None)\n    else:\n        # interleave(filler, chunks) -> [e], [x_0, x_1], [e], [x_2, x_3]...\n        # islice(..., 1, None) -> [x_0, x_1], [e], [x_2, x_3]...\n        # flatten(...) -> x_0, x_1, e, x_2, x_3...\n        filler = repeat([e])\n        chunks = chunked(iterable, n)\n        return flatten(islice(interleave(filler, chunks), 1, None))",
    "docstring": "Intersperse filler element *e* among the items in *iterable*, leaving\n*n* items between each filler element.\n\n    >>> list(intersperse('!', [1, 2, 3, 4, 5]))\n    [1, '!', 2, '!', 3, '!', 4, '!', 5]\n\n    >>> list(intersperse(None, [1, 2, 3, 4, 5], n=2))\n    [1, 2, None, 3, 4, None, 5]"
  },
  {
    "function": "unique_to_each",
    "code": "def unique_to_each(*iterables):\n    \"\"\"Return the elements from each of the input iterables that aren't in the\n    other input iterables.\n\n    For example, suppose you have a set of packages, each with a set of\n    dependencies::\n\n        {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}\n\n    If you remove one package, which dependencies can also be removed?\n\n    If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not\n    associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for\n    ``pkg_2``, and ``D`` is only needed for ``pkg_3``::\n\n        >>> unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})\n        [['A'], ['C'], ['D']]\n\n    If there are duplicates in one input iterable that aren't in the others\n    they will be duplicated in the output. Input order is preserved::\n\n        >>> unique_to_each(\"mississippi\", \"missouri\")\n        [['p', 'p'], ['o', 'u', 'r']]\n\n    It is assumed that the elements of each iterable are hashable.\n\n    \"\"\"\n    pool = [list(it) for it in iterables]\n    counts = Counter(chain.from_iterable(map(set, pool)))\n    uniques = {element for element in counts if counts[element] == 1}\n    return [list(filter(uniques.__contains__, it)) for it in pool]",
    "docstring": "Return the elements from each of the input iterables that aren't in the\nother input iterables.\n\nFor example, suppose you have a set of packages, each with a set of\ndependencies::\n\n    {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}\n\nIf you remove one package, which dependencies can also be removed?\n\nIf ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not\nassociated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for\n``pkg_2``, and ``D`` is only needed for ``pkg_3``::\n\n    >>> unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})\n    [['A'], ['C'], ['D']]\n\nIf there are duplicates in one input iterable that aren't in the others\nthey will be duplicated in the output. Input order is preserved::\n\n    >>> unique_to_each(\"mississippi\", \"missouri\")\n    [['p', 'p'], ['o', 'u', 'r']]\n\nIt is assumed that the elements of each iterable are hashable."
  },
  {
    "function": "windowed",
    "code": "def windowed(seq, n, fillvalue=None, step=1):\n    \"\"\"Return a sliding window of width *n* over the given iterable.\n\n        >>> all_windows = windowed([1, 2, 3, 4, 5], 3)\n        >>> list(all_windows)\n        [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n\n    When the window is larger than the iterable, *fillvalue* is used in place\n    of missing values:\n\n        >>> list(windowed([1, 2, 3], 4))\n        [(1, 2, 3, None)]\n\n    Each window will advance in increments of *step*:\n\n        >>> list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue='!', step=2))\n        [(1, 2, 3), (3, 4, 5), (5, 6, '!')]\n\n    To slide into the iterable's items, use :func:`chain` to add filler items\n    to the left:\n\n        >>> iterable = [1, 2, 3, 4]\n        >>> n = 3\n        >>> padding = [None] * (n - 1)\n        >>> list(windowed(chain(padding, iterable), 3))\n        [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        yield ()\n        return\n    if step < 1:\n        raise ValueError('step must be >= 1')\n\n    iterator = iter(seq)\n\n    # Generate first window\n    window = deque(islice(iterator, n), maxlen=n)\n\n    # Deal with the first window not being full\n    if not window:\n        return\n    if len(window) < n:\n        yield tuple(window) + ((fillvalue,) * (n - len(window)))\n        return\n    yield tuple(window)\n\n    # Create the filler for the next windows. The padding ensures\n    # we have just enough elements to fill the last window.\n    padding = (fillvalue,) * (n - 1 if step >= n else step - 1)\n    filler = map(window.append, chain(iterator, padding))\n\n    # Generate the rest of the windows\n    for _ in islice(filler, step - 1, None, step):\n        yield tuple(window)",
    "docstring": "Return a sliding window of width *n* over the given iterable.\n\n    >>> all_windows = windowed([1, 2, 3, 4, 5], 3)\n    >>> list(all_windows)\n    [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n\nWhen the window is larger than the iterable, *fillvalue* is used in place\nof missing values:\n\n    >>> list(windowed([1, 2, 3], 4))\n    [(1, 2, 3, None)]\n\nEach window will advance in increments of *step*:\n\n    >>> list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue='!', step=2))\n    [(1, 2, 3), (3, 4, 5), (5, 6, '!')]\n\nTo slide into the iterable's items, use :func:`chain` to add filler items\nto the left:\n\n    >>> iterable = [1, 2, 3, 4]\n    >>> n = 3\n    >>> padding = [None] * (n - 1)\n    >>> list(windowed(chain(padding, iterable), 3))\n    [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]"
  },
  {
    "function": "substrings",
    "code": "def substrings(iterable):\n    \"\"\"Yield all of the substrings of *iterable*.\n\n        >>> [''.join(s) for s in substrings('more')]\n        ['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more']\n\n    Note that non-string iterables can also be subdivided.\n\n        >>> list(substrings([0, 1, 2]))\n        [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]\n\n    Like subslices() but returns tuples instead of lists\n    and returns the shortest substrings first.\n\n    \"\"\"\n    seq = tuple(iterable)\n    item_count = len(seq)\n    for n in range(1, item_count + 1):\n        slices = map(slice, range(item_count), range(n, item_count + 1))\n        yield from map(getitem, repeat(seq), slices)",
    "docstring": "Yield all of the substrings of *iterable*.\n\n    >>> [''.join(s) for s in substrings('more')]\n    ['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more']\n\nNote that non-string iterables can also be subdivided.\n\n    >>> list(substrings([0, 1, 2]))\n    [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]\n\nLike subslices() but returns tuples instead of lists\nand returns the shortest substrings first."
  },
  {
    "function": "substrings_indexes",
    "code": "def substrings_indexes(seq, reverse=False):\n    \"\"\"Yield all substrings and their positions in *seq*\n\n    The items yielded will be a tuple of the form ``(substr, i, j)``, where\n    ``substr == seq[i:j]``.\n\n    This function only works for iterables that support slicing, such as\n    ``str`` objects.\n\n    >>> for item in substrings_indexes('more'):\n    ...    print(item)\n    ('m', 0, 1)\n    ('o', 1, 2)\n    ('r', 2, 3)\n    ('e', 3, 4)\n    ('mo', 0, 2)\n    ('or', 1, 3)\n    ('re', 2, 4)\n    ('mor', 0, 3)\n    ('ore', 1, 4)\n    ('more', 0, 4)\n\n    Set *reverse* to ``True`` to yield the same items in the opposite order.\n\n\n    \"\"\"\n    r = range(1, len(seq) + 1)\n    if reverse:\n        r = reversed(r)\n    return (\n        (seq[i : i + L], i, i + L) for L in r for i in range(len(seq) - L + 1)\n    )",
    "docstring": "Yield all substrings and their positions in *seq*\n\nThe items yielded will be a tuple of the form ``(substr, i, j)``, where\n``substr == seq[i:j]``.\n\nThis function only works for iterables that support slicing, such as\n``str`` objects.\n\n>>> for item in substrings_indexes('more'):\n...    print(item)\n('m', 0, 1)\n('o', 1, 2)\n('r', 2, 3)\n('e', 3, 4)\n('mo', 0, 2)\n('or', 1, 3)\n('re', 2, 4)\n('mor', 0, 3)\n('ore', 1, 4)\n('more', 0, 4)\n\nSet *reverse* to ``True`` to yield the same items in the opposite order."
  },
  {
    "function": "spy",
    "code": "def spy(iterable, n=1):\n    \"\"\"Return a 2-tuple with a list containing the first *n* elements of\n    *iterable*, and an iterator with the same items as *iterable*.\n    This allows you to \"look ahead\" at the items in the iterable without\n    advancing it.\n\n    There is one item in the list by default:\n\n        >>> iterable = 'abcdefg'\n        >>> head, iterable = spy(iterable)\n        >>> head\n        ['a']\n        >>> list(iterable)\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\n    You may use unpacking to retrieve items instead of lists:\n\n        >>> (head,), iterable = spy('abcdefg')\n        >>> head\n        'a'\n        >>> (first, second), iterable = spy('abcdefg', 2)\n        >>> first\n        'a'\n        >>> second\n        'b'\n\n    The number of items requested can be larger than the number of items in\n    the iterable:\n\n        >>> iterable = [1, 2, 3, 4, 5]\n        >>> head, iterable = spy(iterable, 10)\n        >>> head\n        [1, 2, 3, 4, 5]\n        >>> list(iterable)\n        [1, 2, 3, 4, 5]\n\n    \"\"\"\n    p, q = tee(iterable)\n    return take(n, q), p",
    "docstring": "Return a 2-tuple with a list containing the first *n* elements of\n*iterable*, and an iterator with the same items as *iterable*.\nThis allows you to \"look ahead\" at the items in the iterable without\nadvancing it.\n\nThere is one item in the list by default:\n\n    >>> iterable = 'abcdefg'\n    >>> head, iterable = spy(iterable)\n    >>> head\n    ['a']\n    >>> list(iterable)\n    ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\nYou may use unpacking to retrieve items instead of lists:\n\n    >>> (head,), iterable = spy('abcdefg')\n    >>> head\n    'a'\n    >>> (first, second), iterable = spy('abcdefg', 2)\n    >>> first\n    'a'\n    >>> second\n    'b'\n\nThe number of items requested can be larger than the number of items in\nthe iterable:\n\n    >>> iterable = [1, 2, 3, 4, 5]\n    >>> head, iterable = spy(iterable, 10)\n    >>> head\n    [1, 2, 3, 4, 5]\n    >>> list(iterable)\n    [1, 2, 3, 4, 5]"
  },
  {
    "function": "interleave",
    "code": "def interleave(*iterables):\n    \"\"\"Return a new iterable yielding from each iterable in turn,\n    until the shortest is exhausted.\n\n        >>> list(interleave([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7]\n\n    For a version that doesn't terminate after the shortest iterable is\n    exhausted, see :func:`interleave_longest`.\n\n    \"\"\"\n    return chain.from_iterable(zip(*iterables))",
    "docstring": "Return a new iterable yielding from each iterable in turn,\nuntil the shortest is exhausted.\n\n    >>> list(interleave([1, 2, 3], [4, 5], [6, 7, 8]))\n    [1, 4, 6, 2, 5, 7]\n\nFor a version that doesn't terminate after the shortest iterable is\nexhausted, see :func:`interleave_longest`."
  },
  {
    "function": "interleave_longest",
    "code": "def interleave_longest(*iterables):\n    \"\"\"Return a new iterable yielding from each iterable in turn,\n    skipping any that are exhausted.\n\n        >>> list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7, 3, 8]\n\n    This function produces the same output as :func:`roundrobin`, but may\n    perform better for some inputs (in particular when the number of iterables\n    is large).\n\n    \"\"\"\n    for xs in zip_longest(*iterables, fillvalue=_marker):\n        for x in xs:\n            if x is not _marker:\n                yield x",
    "docstring": "Return a new iterable yielding from each iterable in turn,\nskipping any that are exhausted.\n\n    >>> list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))\n    [1, 4, 6, 2, 5, 7, 3, 8]\n\nThis function produces the same output as :func:`roundrobin`, but may\nperform better for some inputs (in particular when the number of iterables\nis large)."
  },
  {
    "function": "interleave_evenly",
    "code": "def interleave_evenly(iterables, lengths=None):\n    \"\"\"\n    Interleave multiple iterables so that their elements are evenly distributed\n    throughout the output sequence.\n\n    >>> iterables = [1, 2, 3, 4, 5], ['a', 'b']\n    >>> list(interleave_evenly(iterables))\n    [1, 2, 'a', 3, 4, 'b', 5]\n\n    >>> iterables = [[1, 2, 3], [4, 5], [6, 7, 8]]\n    >>> list(interleave_evenly(iterables))\n    [1, 6, 4, 2, 7, 3, 8, 5]\n\n    This function requires iterables of known length. Iterables without\n    ``__len__()`` can be used by manually specifying lengths with *lengths*:\n\n    >>> from itertools import combinations, repeat\n    >>> iterables = [combinations(range(4), 2), ['a', 'b', 'c']]\n    >>> lengths = [4 * (4 - 1) // 2, 3]\n    >>> list(interleave_evenly(iterables, lengths=lengths))\n    [(0, 1), (0, 2), 'a', (0, 3), (1, 2), 'b', (1, 3), (2, 3), 'c']\n\n    Based on Bresenham's algorithm.\n    \"\"\"\n    if lengths is None:\n        try:\n            lengths = [len(it) for it in iterables]\n        except TypeError:\n            raise ValueError(\n                'Iterable lengths could not be determined automatically. '\n                'Specify them with the lengths keyword.'\n            )\n    elif len(iterables) != len(lengths):\n        raise ValueError('Mismatching number of iterables and lengths.')\n\n    dims = len(lengths)\n\n    # sort iterables by length, descending\n    lengths_permute = sorted(\n        range(dims), key=lambda i: lengths[i], reverse=True\n    )\n    lengths_desc = [lengths[i] for i in lengths_permute]\n    iters_desc = [iter(iterables[i]) for i in lengths_permute]\n\n    # the longest iterable is the primary one (Bresenham: the longest\n    # distance along an axis)\n    delta_primary, deltas_secondary = lengths_desc[0], lengths_desc[1:]\n    iter_primary, iters_secondary = iters_desc[0], iters_desc[1:]\n    errors = [delta_primary // dims] * len(deltas_secondary)\n\n    to_yield = sum(lengths)\n    while to_yield:\n        yield next(iter_primary)\n        to_yield -= 1\n        # update errors for each secondary iterable\n        errors = [e - delta for e, delta in zip(errors, deltas_secondary)]\n\n        # those iterables for which the error is negative are yielded\n        # (\"diagonal step\" in Bresenham)\n        for i, e_ in enumerate(errors):\n            if e_ < 0:\n                yield next(iters_secondary[i])\n                to_yield -= 1\n                errors[i] += delta_primary",
    "docstring": "Interleave multiple iterables so that their elements are evenly distributed\nthroughout the output sequence.\n\n>>> iterables = [1, 2, 3, 4, 5], ['a', 'b']\n>>> list(interleave_evenly(iterables))\n[1, 2, 'a', 3, 4, 'b', 5]\n\n>>> iterables = [[1, 2, 3], [4, 5], [6, 7, 8]]\n>>> list(interleave_evenly(iterables))\n[1, 6, 4, 2, 7, 3, 8, 5]\n\nThis function requires iterables of known length. Iterables without\n``__len__()`` can be used by manually specifying lengths with *lengths*:\n\n>>> from itertools import combinations, repeat\n>>> iterables = [combinations(range(4), 2), ['a', 'b', 'c']]\n>>> lengths = [4 * (4 - 1) // 2, 3]\n>>> list(interleave_evenly(iterables, lengths=lengths))\n[(0, 1), (0, 2), 'a', (0, 3), (1, 2), 'b', (1, 3), (2, 3), 'c']\n\nBased on Bresenham's algorithm."
  },
  {
    "function": "interleave_randomly",
    "code": "def interleave_randomly(*iterables):\n    \"\"\"Repeatedly select one of the input *iterables* at random and yield the next\n    item from it.\n\n        >>> iterables = [1, 2, 3], 'abc', (True, False, None)\n        >>> list(interleave_randomly(*iterables))  # doctest: +SKIP\n        ['a', 'b', 1, 'c', True, False, None, 2, 3]\n\n    The relative order of the items in each input iterable will preserved. Note the\n    sequences of items with this property are not equally likely to be generated.\n\n    \"\"\"\n    iterators = [iter(e) for e in iterables]\n    while iterators:\n        idx = randrange(len(iterators))\n        try:\n            yield next(iterators[idx])\n        except StopIteration:\n            # equivalent to `list.pop` but slightly faster\n            iterators[idx] = iterators[-1]\n            del iterators[-1]",
    "docstring": "Repeatedly select one of the input *iterables* at random and yield the next\nitem from it.\n\n    >>> iterables = [1, 2, 3], 'abc', (True, False, None)\n    >>> list(interleave_randomly(*iterables))  # doctest: +SKIP\n    ['a', 'b', 1, 'c', True, False, None, 2, 3]\n\nThe relative order of the items in each input iterable will preserved. Note the\nsequences of items with this property are not equally likely to be generated."
  },
  {
    "function": "collapse",
    "code": "def collapse(iterable, base_type=None, levels=None):\n    \"\"\"Flatten an iterable with multiple levels of nesting (e.g., a list of\n    lists of tuples) into non-iterable types.\n\n        >>> iterable = [(1, 2), ([3, 4], [[5], [6]])]\n        >>> list(collapse(iterable))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and\n    will not be collapsed.\n\n    To avoid collapsing other types, specify *base_type*:\n\n        >>> iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]\n        >>> list(collapse(iterable, base_type=tuple))\n        ['ab', ('cd', 'ef'), 'gh', 'ij']\n\n    Specify *levels* to stop flattening after a certain level:\n\n    >>> iterable = [('a', ['b']), ('c', ['d'])]\n    >>> list(collapse(iterable))  # Fully flattened\n    ['a', 'b', 'c', 'd']\n    >>> list(collapse(iterable, levels=1))  # Only one level flattened\n    ['a', ['b'], 'c', ['d']]\n\n    \"\"\"\n    stack = deque()\n    # Add our first node group, treat the iterable as a single node\n    stack.appendleft((0, repeat(iterable, 1)))\n\n    while stack:\n        node_group = stack.popleft()\n        level, nodes = node_group\n\n        # Check if beyond max level\n        if levels is not None and level > levels:\n            yield from nodes\n            continue\n\n        for node in nodes:\n            # Check if done iterating\n            if isinstance(node, (str, bytes)) or (\n                (base_type is not None) and isinstance(node, base_type)\n            ):\n                yield node\n            # Otherwise try to create child nodes\n            else:\n                try:\n                    tree = iter(node)\n                except TypeError:\n                    yield node\n                else:\n                    # Save our current location\n                    stack.appendleft(node_group)\n                    # Append the new child node\n                    stack.appendleft((level + 1, tree))\n                    # Break to process child node\n                    break",
    "docstring": "Flatten an iterable with multiple levels of nesting (e.g., a list of\nlists of tuples) into non-iterable types.\n\n    >>> iterable = [(1, 2), ([3, 4], [[5], [6]])]\n    >>> list(collapse(iterable))\n    [1, 2, 3, 4, 5, 6]\n\nBinary and text strings are not considered iterable and\nwill not be collapsed.\n\nTo avoid collapsing other types, specify *base_type*:\n\n    >>> iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]\n    >>> list(collapse(iterable, base_type=tuple))\n    ['ab', ('cd', 'ef'), 'gh', 'ij']\n\nSpecify *levels* to stop flattening after a certain level:\n\n>>> iterable = [('a', ['b']), ('c', ['d'])]\n>>> list(collapse(iterable))  # Fully flattened\n['a', 'b', 'c', 'd']\n>>> list(collapse(iterable, levels=1))  # Only one level flattened\n['a', ['b'], 'c', ['d']]"
  },
  {
    "function": "side_effect",
    "code": "def side_effect(func, iterable, chunk_size=None, before=None, after=None):\n    \"\"\"Invoke *func* on each item in *iterable* (or on each *chunk_size* group\n    of items) before yielding the item.\n\n    `func` must be a function that takes a single argument. Its return value\n    will be discarded.\n\n    *before* and *after* are optional functions that take no arguments. They\n    will be executed before iteration starts and after it ends, respectively.\n\n    `side_effect` can be used for logging, updating progress bars, or anything\n    that is not functionally \"pure.\"\n\n    Emitting a status message:\n\n        >>> from more_itertools import consume\n        >>> func = lambda item: print('Received {}'.format(item))\n        >>> consume(side_effect(func, range(2)))\n        Received 0\n        Received 1\n\n    Operating on chunks of items:\n\n        >>> pair_sums = []\n        >>> func = lambda chunk: pair_sums.append(sum(chunk))\n        >>> list(side_effect(func, [0, 1, 2, 3, 4, 5], 2))\n        [0, 1, 2, 3, 4, 5]\n        >>> list(pair_sums)\n        [1, 5, 9]\n\n    Writing to a file-like object:\n\n        >>> from io import StringIO\n        >>> from more_itertools import consume\n        >>> f = StringIO()\n        >>> func = lambda x: print(x, file=f)\n        >>> before = lambda: print(u'HEADER', file=f)\n        >>> after = f.close\n        >>> it = [u'a', u'b', u'c']\n        >>> consume(side_effect(func, it, before=before, after=after))\n        >>> f.closed\n        True\n\n    \"\"\"\n    try:\n        if before is not None:\n            before()\n\n        if chunk_size is None:\n            for item in iterable:\n                func(item)\n                yield item\n        else:\n            for chunk in chunked(iterable, chunk_size):\n                func(chunk)\n                yield from chunk\n    finally:\n        if after is not None:\n            after()",
    "docstring": "Invoke *func* on each item in *iterable* (or on each *chunk_size* group\nof items) before yielding the item.\n\n`func` must be a function that takes a single argument. Its return value\nwill be discarded.\n\n*before* and *after* are optional functions that take no arguments. They\nwill be executed before iteration starts and after it ends, respectively.\n\n`side_effect` can be used for logging, updating progress bars, or anything\nthat is not functionally \"pure.\"\n\nEmitting a status message:\n\n    >>> from more_itertools import consume\n    >>> func = lambda item: print('Received {}'.format(item))\n    >>> consume(side_effect(func, range(2)))\n    Received 0\n    Received 1\n\nOperating on chunks of items:\n\n    >>> pair_sums = []\n    >>> func = lambda chunk: pair_sums.append(sum(chunk))\n    >>> list(side_effect(func, [0, 1, 2, 3, 4, 5], 2))\n    [0, 1, 2, 3, 4, 5]\n    >>> list(pair_sums)\n    [1, 5, 9]\n\nWriting to a file-like object:\n\n    >>> from io import StringIO\n    >>> from more_itertools import consume\n    >>> f = StringIO()\n    >>> func = lambda x: print(x, file=f)\n    >>> before = lambda: print(u'HEADER', file=f)\n    >>> after = f.close\n    >>> it = [u'a', u'b', u'c']\n    >>> consume(side_effect(func, it, before=before, after=after))\n    >>> f.closed\n    True"
  },
  {
    "function": "sliced",
    "code": "def sliced(seq, n, strict=False):\n    \"\"\"Yield slices of length *n* from the sequence *seq*.\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6), 3))\n    [(1, 2, 3), (4, 5, 6)]\n\n    By the default, the last yielded slice will have fewer than *n* elements\n    if the length of *seq* is not divisible by *n*:\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))\n    [(1, 2, 3), (4, 5, 6), (7, 8)]\n\n    If the length of *seq* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    slice is yielded.\n\n    This function will only work for iterables that support slicing.\n    For non-sliceable iterables, see :func:`chunked`.\n\n    \"\"\"\n    iterator = takewhile(len, (seq[i : i + n] for i in count(0, n)))\n    if strict:\n\n        def ret():\n            for _slice in iterator:\n                if len(_slice) != n:\n                    raise ValueError(\"seq is not divisible by n.\")\n                yield _slice\n\n        return ret()\n    else:\n        return iterator",
    "docstring": "Yield slices of length *n* from the sequence *seq*.\n\n>>> list(sliced((1, 2, 3, 4, 5, 6), 3))\n[(1, 2, 3), (4, 5, 6)]\n\nBy the default, the last yielded slice will have fewer than *n* elements\nif the length of *seq* is not divisible by *n*:\n\n>>> list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))\n[(1, 2, 3), (4, 5, 6), (7, 8)]\n\nIf the length of *seq* is not divisible by *n* and *strict* is\n``True``, then ``ValueError`` will be raised before the last\nslice is yielded.\n\nThis function will only work for iterables that support slicing.\nFor non-sliceable iterables, see :func:`chunked`."
  },
  {
    "function": "split_at",
    "code": "def split_at(iterable, pred, maxsplit=-1, keep_separator=False):\n    \"\"\"Yield lists of items from *iterable*, where each list is delimited by\n    an item where callable *pred* returns ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b'))\n        [['a'], ['c', 'd', 'c'], ['a']]\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1))\n        [[0], [2], [4], [6], [8], []]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1, maxsplit=2))\n        [[0], [2], [4, 5, 6, 7, 8, 9]]\n\n    By default, the delimiting items are not included in the output.\n    To include them, set *keep_separator* to ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b', keep_separator=True))\n        [['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item):\n            yield buf\n            if keep_separator:\n                yield [item]\n            if maxsplit == 1:\n                yield list(it)\n                return\n            buf = []\n            maxsplit -= 1\n        else:\n            buf.append(item)\n    yield buf",
    "docstring": "Yield lists of items from *iterable*, where each list is delimited by\nan item where callable *pred* returns ``True``.\n\n    >>> list(split_at('abcdcba', lambda x: x == 'b'))\n    [['a'], ['c', 'd', 'c'], ['a']]\n\n    >>> list(split_at(range(10), lambda n: n % 2 == 1))\n    [[0], [2], [4], [6], [8], []]\n\nAt most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\nthen there is no limit on the number of splits:\n\n    >>> list(split_at(range(10), lambda n: n % 2 == 1, maxsplit=2))\n    [[0], [2], [4, 5, 6, 7, 8, 9]]\n\nBy default, the delimiting items are not included in the output.\nTo include them, set *keep_separator* to ``True``.\n\n    >>> list(split_at('abcdcba', lambda x: x == 'b', keep_separator=True))\n    [['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']]"
  },
  {
    "function": "split_before",
    "code": "def split_before(iterable, pred, maxsplit=-1):\n    \"\"\"Yield lists of items from *iterable*, where each list ends just before\n    an item for which callable *pred* returns ``True``:\n\n        >>> list(split_before('OneTwo', lambda s: s.isupper()))\n        [['O', 'n', 'e'], ['T', 'w', 'o']]\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                yield [item, *it]\n                return\n            buf = []\n            maxsplit -= 1\n        buf.append(item)\n    if buf:\n        yield buf",
    "docstring": "Yield lists of items from *iterable*, where each list ends just before\nan item for which callable *pred* returns ``True``:\n\n    >>> list(split_before('OneTwo', lambda s: s.isupper()))\n    [['O', 'n', 'e'], ['T', 'w', 'o']]\n\n    >>> list(split_before(range(10), lambda n: n % 3 == 0))\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n\nAt most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\nthen there is no limit on the number of splits:\n\n    >>> list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2))\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]"
  },
  {
    "function": "split_after",
    "code": "def split_after(iterable, pred, maxsplit=-1):\n    \"\"\"Yield lists of items from *iterable*, where each list ends with an\n    item where callable *pred* returns ``True``:\n\n        >>> list(split_after('one1two2', lambda s: s.isdigit()))\n        [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0))\n        [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        buf.append(item)\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                buf = list(it)\n                if buf:\n                    yield buf\n                return\n            buf = []\n            maxsplit -= 1\n    if buf:\n        yield buf",
    "docstring": "Yield lists of items from *iterable*, where each list ends with an\nitem where callable *pred* returns ``True``:\n\n    >>> list(split_after('one1two2', lambda s: s.isdigit()))\n    [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]\n\n    >>> list(split_after(range(10), lambda n: n % 3 == 0))\n    [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nAt most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\nthen there is no limit on the number of splits:\n\n    >>> list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2))\n    [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]"
  },
  {
    "function": "split_when",
    "code": "def split_when(iterable, pred, maxsplit=-1):\n    \"\"\"Split *iterable* into pieces based on the output of *pred*.\n    *pred* should be a function that takes successive pairs of items and\n    returns ``True`` if the iterable should be split in between them.\n\n    For example, to find runs of increasing numbers, split the iterable when\n    element ``i`` is larger than element ``i + 1``:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x > y))\n        [[1, 2, 3, 3], [2, 5], [2, 4], [2]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],\n        ...                 lambda x, y: x > y, maxsplit=2))\n        [[1, 2, 3, 3], [2, 5], [2, 4, 2]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    it = iter(iterable)\n    try:\n        cur_item = next(it)\n    except StopIteration:\n        return\n\n    buf = [cur_item]\n    for next_item in it:\n        if pred(cur_item, next_item):\n            yield buf\n            if maxsplit == 1:\n                yield [next_item, *it]\n                return\n            buf = []\n            maxsplit -= 1\n\n        buf.append(next_item)\n        cur_item = next_item\n\n    yield buf",
    "docstring": "Split *iterable* into pieces based on the output of *pred*.\n*pred* should be a function that takes successive pairs of items and\nreturns ``True`` if the iterable should be split in between them.\n\nFor example, to find runs of increasing numbers, split the iterable when\nelement ``i`` is larger than element ``i + 1``:\n\n    >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x > y))\n    [[1, 2, 3, 3], [2, 5], [2, 4], [2]]\n\nAt most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\nthen there is no limit on the number of splits:\n\n    >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],\n    ...                 lambda x, y: x > y, maxsplit=2))\n    [[1, 2, 3, 3], [2, 5], [2, 4, 2]]"
  },
  {
    "function": "split_into",
    "code": "def split_into(iterable, sizes):\n    \"\"\"Yield a list of sequential items from *iterable* of length 'n' for each\n    integer 'n' in *sizes*.\n\n        >>> list(split_into([1,2,3,4,5,6], [1,2,3]))\n        [[1], [2, 3], [4, 5, 6]]\n\n    If the sum of *sizes* is smaller than the length of *iterable*, then the\n    remaining items of *iterable* will not be returned.\n\n        >>> list(split_into([1,2,3,4,5,6], [2,3]))\n        [[1, 2], [3, 4, 5]]\n\n    If the sum of *sizes* is larger than the length of *iterable*, fewer items\n    will be returned in the iteration that overruns the *iterable* and further\n    lists will be empty:\n\n        >>> list(split_into([1,2,3,4], [1,2,3,4]))\n        [[1], [2, 3], [4], []]\n\n    When a ``None`` object is encountered in *sizes*, the returned list will\n    contain items up to the end of *iterable* the same way that\n    :func:`itertools.slice` does:\n\n        >>> list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))\n        [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]\n\n    :func:`split_into` can be useful for grouping a series of items where the\n    sizes of the groups are not uniform. An example would be where in a row\n    from a table, multiple columns represent elements of the same feature\n    (e.g. a point represented by x,y,z) but, the format is not the same for\n    all columns.\n    \"\"\"\n    # convert the iterable argument into an iterator so its contents can\n    # be consumed by islice in case it is a generator\n    it = iter(iterable)\n\n    for size in sizes:\n        if size is None:\n            yield list(it)\n            return\n        else:\n            yield list(islice(it, size))",
    "docstring": "Yield a list of sequential items from *iterable* of length 'n' for each\ninteger 'n' in *sizes*.\n\n    >>> list(split_into([1,2,3,4,5,6], [1,2,3]))\n    [[1], [2, 3], [4, 5, 6]]\n\nIf the sum of *sizes* is smaller than the length of *iterable*, then the\nremaining items of *iterable* will not be returned.\n\n    >>> list(split_into([1,2,3,4,5,6], [2,3]))\n    [[1, 2], [3, 4, 5]]\n\nIf the sum of *sizes* is larger than the length of *iterable*, fewer items\nwill be returned in the iteration that overruns the *iterable* and further\nlists will be empty:\n\n    >>> list(split_into([1,2,3,4], [1,2,3,4]))\n    [[1], [2, 3], [4], []]\n\nWhen a ``None`` object is encountered in *sizes*, the returned list will\ncontain items up to the end of *iterable* the same way that\n:func:`itertools.slice` does:\n\n    >>> list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))\n    [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]\n\n:func:`split_into` can be useful for grouping a series of items where the\nsizes of the groups are not uniform. An example would be where in a row\nfrom a table, multiple columns represent elements of the same feature\n(e.g. a point represented by x,y,z) but, the format is not the same for\nall columns."
  },
  {
    "function": "padded",
    "code": "def padded(iterable, fillvalue=None, n=None, next_multiple=False):\n    \"\"\"Yield the elements from *iterable*, followed by *fillvalue*, such that\n    at least *n* items are emitted.\n\n        >>> list(padded([1, 2, 3], '?', 5))\n        [1, 2, 3, '?', '?']\n\n    If *next_multiple* is ``True``, *fillvalue* will be emitted until the\n    number of items emitted is a multiple of *n*:\n\n        >>> list(padded([1, 2, 3, 4], n=3, next_multiple=True))\n        [1, 2, 3, 4, None, None]\n\n    If *n* is ``None``, *fillvalue* will be emitted indefinitely.\n\n    To create an *iterable* of exactly size *n*, you can truncate with\n    :func:`islice`.\n\n        >>> list(islice(padded([1, 2, 3], '?'), 5))\n        [1, 2, 3, '?', '?']\n        >>> list(islice(padded([1, 2, 3, 4, 5, 6, 7, 8], '?'), 5))\n        [1, 2, 3, 4, 5]\n\n    \"\"\"\n    iterator = iter(iterable)\n    iterator_with_repeat = chain(iterator, repeat(fillvalue))\n\n    if n is None:\n        return iterator_with_repeat\n    elif n < 1:\n        raise ValueError('n must be at least 1')\n    elif next_multiple:\n\n        def slice_generator():\n            for first in iterator:\n                yield (first,)\n                yield islice(iterator_with_repeat, n - 1)\n\n        # While elements exist produce slices of size n\n        return chain.from_iterable(slice_generator())\n    else:\n        # Ensure the first batch is at least size n then iterate\n        return chain(islice(iterator_with_repeat, n), iterator)",
    "docstring": "Yield the elements from *iterable*, followed by *fillvalue*, such that\nat least *n* items are emitted.\n\n    >>> list(padded([1, 2, 3], '?', 5))\n    [1, 2, 3, '?', '?']\n\nIf *next_multiple* is ``True``, *fillvalue* will be emitted until the\nnumber of items emitted is a multiple of *n*:\n\n    >>> list(padded([1, 2, 3, 4], n=3, next_multiple=True))\n    [1, 2, 3, 4, None, None]\n\nIf *n* is ``None``, *fillvalue* will be emitted indefinitely.\n\nTo create an *iterable* of exactly size *n*, you can truncate with\n:func:`islice`.\n\n    >>> list(islice(padded([1, 2, 3], '?'), 5))\n    [1, 2, 3, '?', '?']\n    >>> list(islice(padded([1, 2, 3, 4, 5, 6, 7, 8], '?'), 5))\n    [1, 2, 3, 4, 5]"
  },
  {
    "function": "repeat_each",
    "code": "def repeat_each(iterable, n=2):\n    \"\"\"Repeat each element in *iterable* *n* times.\n\n    >>> list(repeat_each('ABC', 3))\n    ['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C']\n    \"\"\"\n    return chain.from_iterable(map(repeat, iterable, repeat(n)))",
    "docstring": "Repeat each element in *iterable* *n* times.\n\n>>> list(repeat_each('ABC', 3))\n['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C']"
  },
  {
    "function": "repeat_last",
    "code": "def repeat_last(iterable, default=None):\n    \"\"\"After the *iterable* is exhausted, keep yielding its last element.\n\n        >>> list(islice(repeat_last(range(3)), 5))\n        [0, 1, 2, 2, 2]\n\n    If the iterable is empty, yield *default* forever::\n\n        >>> list(islice(repeat_last(range(0), 42), 5))\n        [42, 42, 42, 42, 42]\n\n    \"\"\"\n    item = _marker\n    for item in iterable:\n        yield item\n    final = default if item is _marker else item\n    yield from repeat(final)",
    "docstring": "After the *iterable* is exhausted, keep yielding its last element.\n\n    >>> list(islice(repeat_last(range(3)), 5))\n    [0, 1, 2, 2, 2]\n\nIf the iterable is empty, yield *default* forever::\n\n    >>> list(islice(repeat_last(range(0), 42), 5))\n    [42, 42, 42, 42, 42]"
  },
  {
    "function": "distribute",
    "code": "def distribute(n, iterable):\n    \"\"\"Distribute the items from *iterable* among *n* smaller iterables.\n\n        >>> group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 3, 5]\n        >>> list(group_2)\n        [2, 4, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = distribute(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 4, 7], [2, 5], [3, 6]]\n\n    If the length of *iterable* is smaller than *n*, then the last returned\n    iterables will be empty:\n\n        >>> children = distribute(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function uses :func:`itertools.tee` and may require significant\n    storage.\n\n    If you need the order items in the smaller iterables to match the\n    original iterable, see :func:`divide`.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    children = tee(iterable, n)\n    return [islice(it, index, None, n) for index, it in enumerate(children)]",
    "docstring": "Distribute the items from *iterable* among *n* smaller iterables.\n\n    >>> group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])\n    >>> list(group_1)\n    [1, 3, 5]\n    >>> list(group_2)\n    [2, 4, 6]\n\nIf the length of *iterable* is not evenly divisible by *n*, then the\nlength of the returned iterables will not be identical:\n\n    >>> children = distribute(3, [1, 2, 3, 4, 5, 6, 7])\n    >>> [list(c) for c in children]\n    [[1, 4, 7], [2, 5], [3, 6]]\n\nIf the length of *iterable* is smaller than *n*, then the last returned\niterables will be empty:\n\n    >>> children = distribute(5, [1, 2, 3])\n    >>> [list(c) for c in children]\n    [[1], [2], [3], [], []]\n\nThis function uses :func:`itertools.tee` and may require significant\nstorage.\n\nIf you need the order items in the smaller iterables to match the\noriginal iterable, see :func:`divide`."
  },
  {
    "function": "stagger",
    "code": "def stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):\n    \"\"\"Yield tuples whose elements are offset from *iterable*.\n    The amount by which the `i`-th item in each tuple is offset is given by\n    the `i`-th item in *offsets*.\n\n        >>> list(stagger([0, 1, 2, 3]))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3)]\n        >>> list(stagger(range(8), offsets=(0, 2, 4)))\n        [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]\n\n    By default, the sequence will end when the final element of a tuple is the\n    last item in the iterable. To continue until the first element of a tuple\n    is the last item in the iterable, set *longest* to ``True``::\n\n        >>> list(stagger([0, 1, 2, 3], longest=True))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    \"\"\"\n    children = tee(iterable, len(offsets))\n\n    return zip_offset(\n        *children, offsets=offsets, longest=longest, fillvalue=fillvalue\n    )",
    "docstring": "Yield tuples whose elements are offset from *iterable*.\nThe amount by which the `i`-th item in each tuple is offset is given by\nthe `i`-th item in *offsets*.\n\n    >>> list(stagger([0, 1, 2, 3]))\n    [(None, 0, 1), (0, 1, 2), (1, 2, 3)]\n    >>> list(stagger(range(8), offsets=(0, 2, 4)))\n    [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]\n\nBy default, the sequence will end when the final element of a tuple is the\nlast item in the iterable. To continue until the first element of a tuple\nis the last item in the iterable, set *longest* to ``True``::\n\n    >>> list(stagger([0, 1, 2, 3], longest=True))\n    [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]\n\nBy default, ``None`` will be used to replace offsets beyond the end of the\nsequence. Specify *fillvalue* to use some other value."
  },
  {
    "function": "zip_offset",
    "code": "def zip_offset(*iterables, offsets, longest=False, fillvalue=None):\n    \"\"\"``zip`` the input *iterables* together, but offset the `i`-th iterable\n    by the `i`-th item in *offsets*.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1)))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]\n\n    This can be used as a lightweight alternative to SciPy or pandas to analyze\n    data sets in which some series have a lead or lag relationship.\n\n    By default, the sequence will end when the shortest iterable is exhausted.\n    To continue until the longest iterable is exhausted, set *longest* to\n    ``True``.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    \"\"\"\n    if len(iterables) != len(offsets):\n        raise ValueError(\"Number of iterables and offsets didn't match\")\n\n    staggered = []\n    for it, n in zip(iterables, offsets):\n        if n < 0:\n            staggered.append(chain(repeat(fillvalue, -n), it))\n        elif n > 0:\n            staggered.append(islice(it, n, None))\n        else:\n            staggered.append(it)\n\n    if longest:\n        return zip_longest(*staggered, fillvalue=fillvalue)\n\n    return zip(*staggered)",
    "docstring": "``zip`` the input *iterables* together, but offset the `i`-th iterable\nby the `i`-th item in *offsets*.\n\n    >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1)))\n    [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]\n\nThis can be used as a lightweight alternative to SciPy or pandas to analyze\ndata sets in which some series have a lead or lag relationship.\n\nBy default, the sequence will end when the shortest iterable is exhausted.\nTo continue until the longest iterable is exhausted, set *longest* to\n``True``.\n\n    >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True))\n    [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]\n\nBy default, ``None`` will be used to replace offsets beyond the end of the\nsequence. Specify *fillvalue* to use some other value."
  },
  {
    "function": "sort_together",
    "code": "def sort_together(\n    iterables, key_list=(0,), key=None, reverse=False, strict=False\n):\n    \"\"\"Return the input iterables sorted together, with *key_list* as the\n    priority for sorting. All iterables are trimmed to the length of the\n    shortest one.\n\n    This can be used like the sorting function in a spreadsheet. If each\n    iterable represents a column of data, the key list determines which\n    columns are used for sorting.\n\n    By default, all iterables are sorted using the ``0``-th iterable::\n\n        >>> iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]\n        >>> sort_together(iterables)\n        [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]\n\n    Set a different key list to sort according to another iterable.\n    Specifying multiple keys dictates how ties are broken::\n\n        >>> iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]\n        >>> sort_together(iterables, key_list=(1, 2))\n        [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]\n\n    To sort by a function of the elements of the iterable, pass a *key*\n    function. Its arguments are the elements of the iterables corresponding to\n    the key list::\n\n        >>> names = ('a', 'b', 'c')\n        >>> lengths = (1, 2, 3)\n        >>> widths = (5, 2, 1)\n        >>> def area(length, width):\n        ...     return length * width\n        >>> sort_together([names, lengths, widths], key_list=(1, 2), key=area)\n        [('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)]\n\n    Set *reverse* to ``True`` to sort in descending order.\n\n        >>> sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True)\n        [(3, 2, 1), ('a', 'b', 'c')]\n\n    If the *strict* keyword argument is ``True``, then\n    ``ValueError`` will be raised if any of the iterables have\n    different lengths.\n\n    \"\"\"\n    if key is None:\n        # if there is no key function, the key argument to sorted is an\n        # itemgetter\n        key_argument = itemgetter(*key_list)\n    else:\n        # if there is a key function, call it with the items at the offsets\n        # specified by the key function as arguments\n        key_list = list(key_list)\n        if len(key_list) == 1:\n            # if key_list contains a single item, pass the item at that offset\n            # as the only argument to the key function\n            key_offset = key_list[0]\n            key_argument = lambda zipped_items: key(zipped_items[key_offset])\n        else:\n            # if key_list contains multiple items, use itemgetter to return a\n            # tuple of items, which we pass as *args to the key function\n            get_key_items = itemgetter(*key_list)\n            key_argument = lambda zipped_items: key(\n                *get_key_items(zipped_items)\n            )\n\n    transposed = zip(*iterables, strict=strict)\n    reordered = sorted(transposed, key=key_argument, reverse=reverse)\n    untransposed = zip(*reordered, strict=strict)\n    return list(untransposed)",
    "docstring": "Return the input iterables sorted together, with *key_list* as the\npriority for sorting. All iterables are trimmed to the length of the\nshortest one.\n\nThis can be used like the sorting function in a spreadsheet. If each\niterable represents a column of data, the key list determines which\ncolumns are used for sorting.\n\nBy default, all iterables are sorted using the ``0``-th iterable::\n\n    >>> iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]\n    >>> sort_together(iterables)\n    [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]\n\nSet a different key list to sort according to another iterable.\nSpecifying multiple keys dictates how ties are broken::\n\n    >>> iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]\n    >>> sort_together(iterables, key_list=(1, 2))\n    [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]\n\nTo sort by a function of the elements of the iterable, pass a *key*\nfunction. Its arguments are the elements of the iterables corresponding to\nthe key list::\n\n    >>> names = ('a', 'b', 'c')\n    >>> lengths = (1, 2, 3)\n    >>> widths = (5, 2, 1)\n    >>> def area(length, width):\n    ...     return length * width\n    >>> sort_together([names, lengths, widths], key_list=(1, 2), key=area)\n    [('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)]\n\nSet *reverse* to ``True`` to sort in descending order.\n\n    >>> sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True)\n    [(3, 2, 1), ('a', 'b', 'c')]\n\nIf the *strict* keyword argument is ``True``, then\n``ValueError`` will be raised if any of the iterables have\ndifferent lengths."
  },
  {
    "function": "unzip",
    "code": "def unzip(iterable):\n    \"\"\"The inverse of :func:`zip`, this function disaggregates the elements\n    of the zipped *iterable*.\n\n    The ``i``-th iterable contains the ``i``-th element from each element\n    of the zipped iterable. The first element is used to determine the\n    length of the remaining elements.\n\n        >>> iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> letters, numbers = unzip(iterable)\n        >>> list(letters)\n        ['a', 'b', 'c', 'd']\n        >>> list(numbers)\n        [1, 2, 3, 4]\n\n    This is similar to using ``zip(*iterable)``, but it avoids reading\n    *iterable* into memory. Note, however, that this function uses\n    :func:`itertools.tee` and thus may require significant storage.\n\n    \"\"\"\n    head, iterable = spy(iterable)\n    if not head:\n        # empty iterable, e.g. zip([], [], [])\n        return ()\n    # spy returns a one-length iterable as head\n    head = head[0]\n    iterables = tee(iterable, len(head))\n\n    # If we have an iterable like iter([(1, 2, 3), (4, 5), (6,)]),\n    # the second unzipped iterable fails at the third tuple since\n    # it tries to access (6,)[1].\n    # Same with the third unzipped iterable and the second tuple.\n    # To support these \"improperly zipped\" iterables, we suppress\n    # the IndexError, which just stops the unzipped iterables at\n    # first length mismatch.\n    return tuple(\n        iter_suppress(map(itemgetter(i), it), IndexError)\n        for i, it in enumerate(iterables)\n    )",
    "docstring": "The inverse of :func:`zip`, this function disaggregates the elements\nof the zipped *iterable*.\n\nThe ``i``-th iterable contains the ``i``-th element from each element\nof the zipped iterable. The first element is used to determine the\nlength of the remaining elements.\n\n    >>> iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n    >>> letters, numbers = unzip(iterable)\n    >>> list(letters)\n    ['a', 'b', 'c', 'd']\n    >>> list(numbers)\n    [1, 2, 3, 4]\n\nThis is similar to using ``zip(*iterable)``, but it avoids reading\n*iterable* into memory. Note, however, that this function uses\n:func:`itertools.tee` and thus may require significant storage."
  },
  {
    "function": "divide",
    "code": "def divide(n, iterable):\n    \"\"\"Divide the elements from *iterable* into *n* parts, maintaining\n    order.\n\n        >>> group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 2, 3]\n        >>> list(group_2)\n        [4, 5, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = divide(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 2, 3], [4, 5], [6, 7]]\n\n    If the length of the iterable is smaller than n, then the last returned\n    iterables will be empty:\n\n        >>> children = divide(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function will exhaust the iterable before returning.\n    If order is not important, see :func:`distribute`, which does not first\n    pull the iterable into memory.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    try:\n        iterable[:0]\n    except TypeError:\n        seq = tuple(iterable)\n    else:\n        seq = iterable\n\n    q, r = divmod(len(seq), n)\n\n    ret = []\n    stop = 0\n    for i in range(1, n + 1):\n        start = stop\n        stop += q + 1 if i <= r else q\n        ret.append(iter(seq[start:stop]))\n\n    return ret",
    "docstring": "Divide the elements from *iterable* into *n* parts, maintaining\norder.\n\n    >>> group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])\n    >>> list(group_1)\n    [1, 2, 3]\n    >>> list(group_2)\n    [4, 5, 6]\n\nIf the length of *iterable* is not evenly divisible by *n*, then the\nlength of the returned iterables will not be identical:\n\n    >>> children = divide(3, [1, 2, 3, 4, 5, 6, 7])\n    >>> [list(c) for c in children]\n    [[1, 2, 3], [4, 5], [6, 7]]\n\nIf the length of the iterable is smaller than n, then the last returned\niterables will be empty:\n\n    >>> children = divide(5, [1, 2, 3])\n    >>> [list(c) for c in children]\n    [[1], [2], [3], [], []]\n\nThis function will exhaust the iterable before returning.\nIf order is not important, see :func:`distribute`, which does not first\npull the iterable into memory."
  },
  {
    "function": "always_iterable",
    "code": "def always_iterable(obj, base_type=(str, bytes)):\n    \"\"\"If *obj* is iterable, return an iterator over its items::\n\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n\n    If *obj* is ``None``, return an empty iterable:\n\n        >>> obj = None\n        >>> list(always_iterable(None))\n        []\n\n    By default, binary and text strings are not considered iterable::\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj))\n        ['foo']\n\n    If *base_type* is set, objects for which ``isinstance(obj, base_type)``\n    returns ``True`` won't be considered iterable.\n\n        >>> obj = {'a': 1}\n        >>> list(always_iterable(obj))  # Iterate over the dict's keys\n        ['a']\n        >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n        [{'a': 1}]\n\n    Set *base_type* to ``None`` to avoid any special handling and treat objects\n    Python considers iterable as iterable:\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj, base_type=None))\n        ['f', 'o', 'o']\n    \"\"\"\n    if obj is None:\n        return iter(())\n\n    if (base_type is not None) and isinstance(obj, base_type):\n        return iter((obj,))\n\n    try:\n        return iter(obj)\n    except TypeError:\n        return iter((obj,))",
    "docstring": "If *obj* is iterable, return an iterator over its items::\n\n    >>> obj = (1, 2, 3)\n    >>> list(always_iterable(obj))\n    [1, 2, 3]\n\nIf *obj* is not iterable, return a one-item iterable containing *obj*::\n\n    >>> obj = 1\n    >>> list(always_iterable(obj))\n    [1]\n\nIf *obj* is ``None``, return an empty iterable:\n\n    >>> obj = None\n    >>> list(always_iterable(None))\n    []\n\nBy default, binary and text strings are not considered iterable::\n\n    >>> obj = 'foo'\n    >>> list(always_iterable(obj))\n    ['foo']\n\nIf *base_type* is set, objects for which ``isinstance(obj, base_type)``\nreturns ``True`` won't be considered iterable.\n\n    >>> obj = {'a': 1}\n    >>> list(always_iterable(obj))  # Iterate over the dict's keys\n    ['a']\n    >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n    [{'a': 1}]\n\nSet *base_type* to ``None`` to avoid any special handling and treat objects\nPython considers iterable as iterable:\n\n    >>> obj = 'foo'\n    >>> list(always_iterable(obj, base_type=None))\n    ['f', 'o', 'o']"
  },
  {
    "function": "adjacent",
    "code": "def adjacent(predicate, iterable, distance=1):\n    \"\"\"Return an iterable over `(bool, item)` tuples where the `item` is\n    drawn from *iterable* and the `bool` indicates whether\n    that item satisfies the *predicate* or is adjacent to an item that does.\n\n    For example, to find whether items are adjacent to a ``3``::\n\n        >>> list(adjacent(lambda x: x == 3, range(6)))\n        [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]\n\n    Set *distance* to change what counts as adjacent. For example, to find\n    whether items are two places away from a ``3``:\n\n        >>> list(adjacent(lambda x: x == 3, range(6), distance=2))\n        [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]\n\n    This is useful for contextualizing the results of a search function.\n    For example, a code comparison tool might want to identify lines that\n    have changed, but also surrounding lines to give the viewer of the diff\n    context.\n\n    The predicate function will only be called once for each item in the\n    iterable.\n\n    See also :func:`groupby_transform`, which can be used with this function\n    to group ranges of items with the same `bool` value.\n\n    \"\"\"\n    # Allow distance=0 mainly for testing that it reproduces results with map()\n    if distance < 0:\n        raise ValueError('distance must be at least 0')\n\n    i1, i2 = tee(iterable)\n    padding = [False] * distance\n    selected = chain(padding, map(predicate, i1), padding)\n    adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))\n    return zip(adjacent_to_selected, i2)",
    "docstring": "Return an iterable over `(bool, item)` tuples where the `item` is\ndrawn from *iterable* and the `bool` indicates whether\nthat item satisfies the *predicate* or is adjacent to an item that does.\n\nFor example, to find whether items are adjacent to a ``3``::\n\n    >>> list(adjacent(lambda x: x == 3, range(6)))\n    [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]\n\nSet *distance* to change what counts as adjacent. For example, to find\nwhether items are two places away from a ``3``:\n\n    >>> list(adjacent(lambda x: x == 3, range(6), distance=2))\n    [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]\n\nThis is useful for contextualizing the results of a search function.\nFor example, a code comparison tool might want to identify lines that\nhave changed, but also surrounding lines to give the viewer of the diff\ncontext.\n\nThe predicate function will only be called once for each item in the\niterable.\n\nSee also :func:`groupby_transform`, which can be used with this function\nto group ranges of items with the same `bool` value."
  },
  {
    "function": "groupby_transform",
    "code": "def groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):\n    \"\"\"An extension of :func:`itertools.groupby` that can apply transformations\n    to the grouped data.\n\n    * *keyfunc* is a function computing a key value for each item in *iterable*\n    * *valuefunc* is a function that transforms the individual items from\n      *iterable* after grouping\n    * *reducefunc* is a function that transforms each group of items\n\n    >>> iterable = 'aAAbBBcCC'\n    >>> keyfunc = lambda k: k.upper()\n    >>> valuefunc = lambda v: v.lower()\n    >>> reducefunc = lambda g: ''.join(g)\n    >>> list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))\n    [('A', 'aaa'), ('B', 'bbb'), ('C', 'ccc')]\n\n    Each optional argument defaults to an identity function if not specified.\n\n    :func:`groupby_transform` is useful when grouping elements of an iterable\n    using a separate iterable as the key. To do this, :func:`zip` the iterables\n    and pass a *keyfunc* that extracts the first element and a *valuefunc*\n    that extracts the second element::\n\n        >>> from operator import itemgetter\n        >>> keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]\n        >>> values = 'abcdefghi'\n        >>> iterable = zip(keys, values)\n        >>> grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))\n        >>> [(k, ''.join(g)) for k, g in grouper]\n        [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')]\n\n    Note that the order of items in the iterable is significant.\n    Only adjacent items are grouped together, so if you don't want any\n    duplicate groups, you should sort the iterable by the key function.\n\n    \"\"\"\n    ret = groupby(iterable, keyfunc)\n    if valuefunc:\n        ret = ((k, map(valuefunc, g)) for k, g in ret)\n    if reducefunc:\n        ret = ((k, reducefunc(g)) for k, g in ret)\n\n    return ret",
    "docstring": "An extension of :func:`itertools.groupby` that can apply transformations\nto the grouped data.\n\n* *keyfunc* is a function computing a key value for each item in *iterable*\n* *valuefunc* is a function that transforms the individual items from\n  *iterable* after grouping\n* *reducefunc* is a function that transforms each group of items\n\n>>> iterable = 'aAAbBBcCC'\n>>> keyfunc = lambda k: k.upper()\n>>> valuefunc = lambda v: v.lower()\n>>> reducefunc = lambda g: ''.join(g)\n>>> list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))\n[('A', 'aaa'), ('B', 'bbb'), ('C', 'ccc')]\n\nEach optional argument defaults to an identity function if not specified.\n\n:func:`groupby_transform` is useful when grouping elements of an iterable\nusing a separate iterable as the key. To do this, :func:`zip` the iterables\nand pass a *keyfunc* that extracts the first element and a *valuefunc*\nthat extracts the second element::\n\n    >>> from operator import itemgetter\n    >>> keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]\n    >>> values = 'abcdefghi'\n    >>> iterable = zip(keys, values)\n    >>> grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))\n    >>> [(k, ''.join(g)) for k, g in grouper]\n    [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')]\n\nNote that the order of items in the iterable is significant.\nOnly adjacent items are grouped together, so if you don't want any\nduplicate groups, you should sort the iterable by the key function."
  },
  {
    "function": "count_cycle",
    "code": "def count_cycle(iterable, n=None):\n    \"\"\"Cycle through the items from *iterable* up to *n* times, yielding\n    the number of completed cycles along with each item. If *n* is omitted the\n    process repeats indefinitely.\n\n    >>> list(count_cycle('AB', 3))\n    [(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]\n\n    \"\"\"\n    if n is not None:\n        return product(range(n), iterable)\n    seq = tuple(iterable)\n    if not seq:\n        return iter(())\n    counter = count() if n is None else range(n)\n    return zip(repeat_each(counter, len(seq)), cycle(seq))",
    "docstring": "Cycle through the items from *iterable* up to *n* times, yielding\nthe number of completed cycles along with each item. If *n* is omitted the\nprocess repeats indefinitely.\n\n>>> list(count_cycle('AB', 3))\n[(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]"
  },
  {
    "function": "mark_ends",
    "code": "def mark_ends(iterable):\n    \"\"\"Yield 3-tuples of the form ``(is_first, is_last, item)``.\n\n    >>> list(mark_ends('ABC'))\n    [(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]\n\n    Use this when looping over an iterable to take special action on its first\n    and/or last items:\n\n    >>> iterable = ['Header', 100, 200, 'Footer']\n    >>> total = 0\n    >>> for is_first, is_last, item in mark_ends(iterable):\n    ...     if is_first:\n    ...         continue  # Skip the header\n    ...     if is_last:\n    ...         continue  # Skip the footer\n    ...     total += item\n    >>> print(total)\n    300\n    \"\"\"\n    it = iter(iterable)\n    for a in it:\n        first = True\n        for b in it:\n            yield first, False, a\n            a = b\n            first = False\n        yield first, True, a",
    "docstring": "Yield 3-tuples of the form ``(is_first, is_last, item)``.\n\n>>> list(mark_ends('ABC'))\n[(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]\n\nUse this when looping over an iterable to take special action on its first\nand/or last items:\n\n>>> iterable = ['Header', 100, 200, 'Footer']\n>>> total = 0\n>>> for is_first, is_last, item in mark_ends(iterable):\n...     if is_first:\n...         continue  # Skip the header\n...     if is_last:\n...         continue  # Skip the footer\n...     total += item\n>>> print(total)\n300"
  },
  {
    "function": "locate",
    "code": "def locate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(locate([0, 1, 1, 0, 1, 0, 0]))\n        [1, 2, 4]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item.\n\n        >>> list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b'))\n        [1, 3]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(locate(iterable, pred=pred, window_size=3))\n        [1, 5, 9]\n\n    Use with :func:`seekable` to find indexes and then retrieve the associated\n    items:\n\n        >>> from itertools import count\n        >>> from more_itertools import seekable\n        >>> source = (3 * n + 1 if (n % 2) else n // 2 for n in count())\n        >>> it = seekable(source)\n        >>> pred = lambda x: x > 100\n        >>> indexes = locate(it, pred=pred)\n        >>> i = next(indexes)\n        >>> it.seek(i)\n        >>> next(it)\n        106\n\n    \"\"\"\n    if window_size is None:\n        return compress(count(), map(pred, iterable))\n\n    if window_size < 1:\n        raise ValueError('window size must be at least 1')\n\n    it = windowed(iterable, window_size, fillvalue=_marker)\n    return compress(count(), starmap(pred, it))",
    "docstring": "Yield the index of each item in *iterable* for which *pred* returns\n``True``.\n\n*pred* defaults to :func:`bool`, which will select truthy items:\n\n    >>> list(locate([0, 1, 1, 0, 1, 0, 0]))\n    [1, 2, 4]\n\nSet *pred* to a custom function to, e.g., find the indexes for a particular\nitem.\n\n    >>> list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b'))\n    [1, 3]\n\nIf *window_size* is given, then the *pred* function will be called with\nthat many items. This enables searching for sub-sequences:\n\n    >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n    >>> pred = lambda *args: args == (1, 2, 3)\n    >>> list(locate(iterable, pred=pred, window_size=3))\n    [1, 5, 9]\n\nUse with :func:`seekable` to find indexes and then retrieve the associated\nitems:\n\n    >>> from itertools import count\n    >>> from more_itertools import seekable\n    >>> source = (3 * n + 1 if (n % 2) else n // 2 for n in count())\n    >>> it = seekable(source)\n    >>> pred = lambda x: x > 100\n    >>> indexes = locate(it, pred=pred)\n    >>> i = next(indexes)\n    >>> it.seek(i)\n    >>> next(it)\n    106"
  },
  {
    "function": "longest_common_prefix",
    "code": "def longest_common_prefix(iterables):\n    \"\"\"Yield elements of the longest common prefix among given *iterables*.\n\n    >>> ''.join(longest_common_prefix(['abcd', 'abc', 'abf']))\n    'ab'\n\n    \"\"\"\n    return (c[0] for c in takewhile(all_equal, zip(*iterables)))",
    "docstring": "Yield elements of the longest common prefix among given *iterables*.\n\n>>> ''.join(longest_common_prefix(['abcd', 'abc', 'abf']))\n'ab'"
  },
  {
    "function": "lstrip",
    "code": "def lstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the beginning\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the start of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(lstrip(iterable, pred))\n        [1, 2, None, 3, False, None]\n\n    This function is analogous to to :func:`str.lstrip`, and is essentially\n    an wrapper for :func:`itertools.dropwhile`.\n\n    \"\"\"\n    return dropwhile(pred, iterable)",
    "docstring": "Yield the items from *iterable*, but strip any from the beginning\nfor which *pred* returns ``True``.\n\nFor example, to remove a set of items from the start of an iterable:\n\n    >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n    >>> pred = lambda x: x in {None, False, ''}\n    >>> list(lstrip(iterable, pred))\n    [1, 2, None, 3, False, None]\n\nThis function is analogous to to :func:`str.lstrip`, and is essentially\nan wrapper for :func:`itertools.dropwhile`."
  },
  {
    "function": "rstrip",
    "code": "def rstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the end\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the end of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(rstrip(iterable, pred))\n        [None, False, None, 1, 2, None, 3]\n\n    This function is analogous to :func:`str.rstrip`.\n\n    \"\"\"\n    cache = []\n    cache_append = cache.append\n    cache_clear = cache.clear\n    for x in iterable:\n        if pred(x):\n            cache_append(x)\n        else:\n            yield from cache\n            cache_clear()\n            yield x",
    "docstring": "Yield the items from *iterable*, but strip any from the end\nfor which *pred* returns ``True``.\n\nFor example, to remove a set of items from the end of an iterable:\n\n    >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n    >>> pred = lambda x: x in {None, False, ''}\n    >>> list(rstrip(iterable, pred))\n    [None, False, None, 1, 2, None, 3]\n\nThis function is analogous to :func:`str.rstrip`."
  },
  {
    "function": "strip",
    "code": "def strip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the\n    beginning and end for which *pred* returns ``True``.\n\n    For example, to remove a set of items from both ends of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(strip(iterable, pred))\n        [1, 2, None, 3]\n\n    This function is analogous to :func:`str.strip`.\n\n    \"\"\"\n    return rstrip(lstrip(iterable, pred), pred)",
    "docstring": "Yield the items from *iterable*, but strip any from the\nbeginning and end for which *pred* returns ``True``.\n\nFor example, to remove a set of items from both ends of an iterable:\n\n    >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n    >>> pred = lambda x: x in {None, False, ''}\n    >>> list(strip(iterable, pred))\n    [1, 2, None, 3]\n\nThis function is analogous to :func:`str.strip`."
  },
  {
    "function": "always_reversible",
    "code": "def always_reversible(iterable):\n    \"\"\"An extension of :func:`reversed` that supports all iterables, not\n    just those which implement the ``Reversible`` or ``Sequence`` protocols.\n\n        >>> print(*always_reversible(x for x in range(3)))\n        2 1 0\n\n    If the iterable is already reversible, this function returns the\n    result of :func:`reversed()`. If the iterable is not reversible,\n    this function will cache the remaining items in the iterable and\n    yield them in reverse order, which may require significant storage.\n    \"\"\"\n    try:\n        return reversed(iterable)\n    except TypeError:\n        return reversed(list(iterable))",
    "docstring": "An extension of :func:`reversed` that supports all iterables, not\njust those which implement the ``Reversible`` or ``Sequence`` protocols.\n\n    >>> print(*always_reversible(x for x in range(3)))\n    2 1 0\n\nIf the iterable is already reversible, this function returns the\nresult of :func:`reversed()`. If the iterable is not reversible,\nthis function will cache the remaining items in the iterable and\nyield them in reverse order, which may require significant storage."
  },
  {
    "function": "consecutive_groups",
    "code": "def consecutive_groups(iterable, ordering=None):\n    \"\"\"Yield groups of consecutive items using :func:`itertools.groupby`.\n    The *ordering* function determines whether two items are adjacent by\n    returning their position.\n\n    By default, the ordering function is the identity function. This is\n    suitable for finding runs of numbers:\n\n        >>> iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]\n        >>> for group in consecutive_groups(iterable):\n        ...     print(list(group))\n        [1]\n        [10, 11, 12]\n        [20]\n        [30, 31, 32, 33]\n        [40]\n\n    To find runs of adjacent letters, apply :func:`ord` function\n    to convert letters to ordinals.\n\n        >>> iterable = 'abcdfgilmnop'\n        >>> ordering = ord\n        >>> for group in consecutive_groups(iterable, ordering):\n        ...     print(list(group))\n        ['a', 'b', 'c', 'd']\n        ['f', 'g']\n        ['i']\n        ['l', 'm', 'n', 'o', 'p']\n\n    Each group of consecutive items is an iterator that shares it source with\n    *iterable*. When an an output group is advanced, the previous group is\n    no longer available unless its elements are copied (e.g., into a ``list``).\n\n        >>> iterable = [1, 2, 11, 12, 21, 22]\n        >>> saved_groups = []\n        >>> for group in consecutive_groups(iterable):\n        ...     saved_groups.append(list(group))  # Copy group elements\n        >>> saved_groups\n        [[1, 2], [11, 12], [21, 22]]\n\n    \"\"\"\n    if ordering is None:\n        key = lambda x: x[0] - x[1]\n    else:\n        key = lambda x: x[0] - ordering(x[1])\n\n    for k, g in groupby(enumerate(iterable), key=key):\n        yield map(itemgetter(1), g)",
    "docstring": "Yield groups of consecutive items using :func:`itertools.groupby`.\nThe *ordering* function determines whether two items are adjacent by\nreturning their position.\n\nBy default, the ordering function is the identity function. This is\nsuitable for finding runs of numbers:\n\n    >>> iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]\n    >>> for group in consecutive_groups(iterable):\n    ...     print(list(group))\n    [1]\n    [10, 11, 12]\n    [20]\n    [30, 31, 32, 33]\n    [40]\n\nTo find runs of adjacent letters, apply :func:`ord` function\nto convert letters to ordinals.\n\n    >>> iterable = 'abcdfgilmnop'\n    >>> ordering = ord\n    >>> for group in consecutive_groups(iterable, ordering):\n    ...     print(list(group))\n    ['a', 'b', 'c', 'd']\n    ['f', 'g']\n    ['i']\n    ['l', 'm', 'n', 'o', 'p']\n\nEach group of consecutive items is an iterator that shares it source with\n*iterable*. When an an output group is advanced, the previous group is\nno longer available unless its elements are copied (e.g., into a ``list``).\n\n    >>> iterable = [1, 2, 11, 12, 21, 22]\n    >>> saved_groups = []\n    >>> for group in consecutive_groups(iterable):\n    ...     saved_groups.append(list(group))  # Copy group elements\n    >>> saved_groups\n    [[1, 2], [11, 12], [21, 22]]"
  },
  {
    "function": "difference",
    "code": "def difference(iterable, func=sub, *, initial=None):\n    \"\"\"This function is the inverse of :func:`itertools.accumulate`. By default\n    it will compute the first difference of *iterable* using\n    :func:`operator.sub`:\n\n        >>> from itertools import accumulate\n        >>> iterable = accumulate([0, 1, 2, 3, 4])  # produces 0, 1, 3, 6, 10\n        >>> list(difference(iterable))\n        [0, 1, 2, 3, 4]\n\n    *func* defaults to :func:`operator.sub`, but other functions can be\n    specified. They will be applied as follows::\n\n        A, B, C, D, ... --> A, func(B, A), func(C, B), func(D, C), ...\n\n    For example, to do progressive division:\n\n        >>> iterable = [1, 2, 6, 24, 120]\n        >>> func = lambda x, y: x // y\n        >>> list(difference(iterable, func))\n        [1, 2, 3, 4, 5]\n\n    If the *initial* keyword is set, the first element will be skipped when\n    computing successive differences.\n\n        >>> it = [10, 11, 13, 16]  # from accumulate([1, 2, 3], initial=10)\n        >>> list(difference(it, initial=10))\n        [1, 2, 3]\n\n    \"\"\"\n    a, b = tee(iterable)\n    try:\n        first = [next(b)]\n    except StopIteration:\n        return iter([])\n\n    if initial is not None:\n        first = []\n\n    return chain(first, map(func, b, a))",
    "docstring": "This function is the inverse of :func:`itertools.accumulate`. By default\nit will compute the first difference of *iterable* using\n:func:`operator.sub`:\n\n    >>> from itertools import accumulate\n    >>> iterable = accumulate([0, 1, 2, 3, 4])  # produces 0, 1, 3, 6, 10\n    >>> list(difference(iterable))\n    [0, 1, 2, 3, 4]\n\n*func* defaults to :func:`operator.sub`, but other functions can be\nspecified. They will be applied as follows::\n\n    A, B, C, D, ... --> A, func(B, A), func(C, B), func(D, C), ...\n\nFor example, to do progressive division:\n\n    >>> iterable = [1, 2, 6, 24, 120]\n    >>> func = lambda x, y: x // y\n    >>> list(difference(iterable, func))\n    [1, 2, 3, 4, 5]\n\nIf the *initial* keyword is set, the first element will be skipped when\ncomputing successive differences.\n\n    >>> it = [10, 11, 13, 16]  # from accumulate([1, 2, 3], initial=10)\n    >>> list(difference(it, initial=10))\n    [1, 2, 3]"
  },
  {
    "function": "exactly_n",
    "code": "def exactly_n(iterable, n, predicate=bool):\n    \"\"\"Return ``True`` if exactly ``n`` items in the iterable are ``True``\n    according to the *predicate* function.\n\n        >>> exactly_n([True, True, False], 2)\n        True\n        >>> exactly_n([True, True, False], 1)\n        False\n        >>> exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x < 3)\n        True\n\n    The iterable will be advanced until ``n + 1`` truthy items are encountered,\n    so avoid calling it on infinite iterables.\n\n    \"\"\"\n    iterator = filter(predicate, iterable)\n    if n <= 0:\n        if n < 0:\n            return False\n        for _ in iterator:\n            return False\n        return True\n\n    iterator = islice(iterator, n - 1, None)\n    for _ in iterator:\n        for _ in iterator:\n            return False\n        return True\n    return False",
    "docstring": "Return ``True`` if exactly ``n`` items in the iterable are ``True``\naccording to the *predicate* function.\n\n    >>> exactly_n([True, True, False], 2)\n    True\n    >>> exactly_n([True, True, False], 1)\n    False\n    >>> exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x < 3)\n    True\n\nThe iterable will be advanced until ``n + 1`` truthy items are encountered,\nso avoid calling it on infinite iterables."
  },
  {
    "function": "circular_shifts",
    "code": "def circular_shifts(iterable, steps=1):\n    \"\"\"Yield the circular shifts of *iterable*.\n\n    >>> list(circular_shifts(range(4)))\n    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n\n    Set *steps* to the number of places to rotate to the left\n    (or to the right if negative).  Defaults to 1.\n\n    >>> list(circular_shifts(range(4), 2))\n    [(0, 1, 2, 3), (2, 3, 0, 1)]\n\n    >>> list(circular_shifts(range(4), -1))\n    [(0, 1, 2, 3), (3, 0, 1, 2), (2, 3, 0, 1), (1, 2, 3, 0)]\n\n    \"\"\"\n    buffer = deque(iterable)\n    if steps == 0:\n        raise ValueError('Steps should be a non-zero integer')\n\n    buffer.rotate(steps)\n    steps = -steps\n    n = len(buffer)\n    n //= math.gcd(n, steps)\n\n    for _ in repeat(None, n):\n        buffer.rotate(steps)\n        yield tuple(buffer)",
    "docstring": "Yield the circular shifts of *iterable*.\n\n>>> list(circular_shifts(range(4)))\n[(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n\nSet *steps* to the number of places to rotate to the left\n(or to the right if negative).  Defaults to 1.\n\n>>> list(circular_shifts(range(4), 2))\n[(0, 1, 2, 3), (2, 3, 0, 1)]\n\n>>> list(circular_shifts(range(4), -1))\n[(0, 1, 2, 3), (3, 0, 1, 2), (2, 3, 0, 1), (1, 2, 3, 0)]"
  },
  {
    "function": "make_decorator",
    "code": "def make_decorator(wrapping_func, result_index=0):\n    \"\"\"Return a decorator version of *wrapping_func*, which is a function that\n    modifies an iterable. *result_index* is the position in that function's\n    signature where the iterable goes.\n\n    This lets you use itertools on the \"production end,\" i.e. at function\n    definition. This can augment what the function returns without changing the\n    function's code.\n\n    For example, to produce a decorator version of :func:`chunked`:\n\n        >>> from more_itertools import chunked\n        >>> chunker = make_decorator(chunked, result_index=0)\n        >>> @chunker(3)\n        ... def iter_range(n):\n        ...     return iter(range(n))\n        ...\n        >>> list(iter_range(9))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n    To only allow truthy items to be returned:\n\n        >>> truth_serum = make_decorator(filter, result_index=1)\n        >>> @truth_serum(bool)\n        ... def boolean_test():\n        ...     return [0, 1, '', ' ', False, True]\n        ...\n        >>> list(boolean_test())\n        [1, ' ', True]\n\n    The :func:`peekable` and :func:`seekable` wrappers make for practical\n    decorators:\n\n        >>> from more_itertools import peekable\n        >>> peekable_function = make_decorator(peekable)\n        >>> @peekable_function()\n        ... def str_range(*args):\n        ...     return (str(x) for x in range(*args))\n        ...\n        >>> it = str_range(1, 20, 2)\n        >>> next(it), next(it), next(it)\n        ('1', '3', '5')\n        >>> it.peek()\n        '7'\n        >>> next(it)\n        '7'\n\n    \"\"\"\n\n    # See https://sites.google.com/site/bbayles/index/decorator_factory for\n    # notes on how this works.\n    def decorator(*wrapping_args, **wrapping_kwargs):\n        def outer_wrapper(f):\n            def inner_wrapper(*args, **kwargs):\n                result = f(*args, **kwargs)\n                wrapping_args_ = list(wrapping_args)\n                wrapping_args_.insert(result_index, result)\n                return wrapping_func(*wrapping_args_, **wrapping_kwargs)\n\n            return inner_wrapper\n\n        return outer_wrapper\n\n    return decorator",
    "docstring": "Return a decorator version of *wrapping_func*, which is a function that\nmodifies an iterable. *result_index* is the position in that function's\nsignature where the iterable goes.\n\nThis lets you use itertools on the \"production end,\" i.e. at function\ndefinition. This can augment what the function returns without changing the\nfunction's code.\n\nFor example, to produce a decorator version of :func:`chunked`:\n\n    >>> from more_itertools import chunked\n    >>> chunker = make_decorator(chunked, result_index=0)\n    >>> @chunker(3)\n    ... def iter_range(n):\n    ...     return iter(range(n))\n    ...\n    >>> list(iter_range(9))\n    [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\nTo only allow truthy items to be returned:\n\n    >>> truth_serum = make_decorator(filter, result_index=1)\n    >>> @truth_serum(bool)\n    ... def boolean_test():\n    ...     return [0, 1, '', ' ', False, True]\n    ...\n    >>> list(boolean_test())\n    [1, ' ', True]\n\nThe :func:`peekable` and :func:`seekable` wrappers make for practical\ndecorators:\n\n    >>> from more_itertools import peekable\n    >>> peekable_function = make_decorator(peekable)\n    >>> @peekable_function()\n    ... def str_range(*args):\n    ...     return (str(x) for x in range(*args))\n    ...\n    >>> it = str_range(1, 20, 2)\n    >>> next(it), next(it), next(it)\n    ('1', '3', '5')\n    >>> it.peek()\n    '7'\n    >>> next(it)\n    '7'"
  },
  {
    "function": "map_reduce",
    "code": "def map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):\n    \"\"\"Return a dictionary that maps the items in *iterable* to categories\n    defined by *keyfunc*, transforms them with *valuefunc*, and\n    then summarizes them by category with *reducefunc*.\n\n    *valuefunc* defaults to the identity function if it is unspecified.\n    If *reducefunc* is unspecified, no summarization takes place:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> result = map_reduce('abbccc', keyfunc)\n        >>> sorted(result.items())\n        [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    Specifying *valuefunc* transforms the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc)\n        >>> sorted(result.items())\n        [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    Specifying *reducefunc* summarizes the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> reducefunc = sum\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)\n        >>> sorted(result.items())\n        [('A', 1), ('B', 2), ('C', 3)]\n\n    You may want to filter the input iterable before applying the map/reduce\n    procedure:\n\n        >>> all_items = range(30)\n        >>> items = [x for x in all_items if 10 <= x <= 20]  # Filter\n        >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n        >>> categories = map_reduce(items, keyfunc=keyfunc)\n        >>> sorted(categories.items())\n        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n        >>> summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)\n        >>> sorted(summaries.items())\n        [(0, 90), (1, 75)]\n\n    Note that all items in the iterable are gathered into a list before the\n    summarization step, which may require significant storage.\n\n    The returned object is a :obj:`collections.defaultdict` with the\n    ``default_factory`` set to ``None``, such that it behaves like a normal\n    dictionary.\n\n    \"\"\"\n\n    ret = defaultdict(list)\n\n    if valuefunc is None:\n        for item in iterable:\n            key = keyfunc(item)\n            ret[key].append(item)\n\n    else:\n        for item in iterable:\n            key = keyfunc(item)\n            value = valuefunc(item)\n            ret[key].append(value)\n\n    if reducefunc is not None:\n        for key, value_list in ret.items():\n            ret[key] = reducefunc(value_list)\n\n    ret.default_factory = None\n    return ret",
    "docstring": "Return a dictionary that maps the items in *iterable* to categories\ndefined by *keyfunc*, transforms them with *valuefunc*, and\nthen summarizes them by category with *reducefunc*.\n\n*valuefunc* defaults to the identity function if it is unspecified.\nIf *reducefunc* is unspecified, no summarization takes place:\n\n    >>> keyfunc = lambda x: x.upper()\n    >>> result = map_reduce('abbccc', keyfunc)\n    >>> sorted(result.items())\n    [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\nSpecifying *valuefunc* transforms the categorized items:\n\n    >>> keyfunc = lambda x: x.upper()\n    >>> valuefunc = lambda x: 1\n    >>> result = map_reduce('abbccc', keyfunc, valuefunc)\n    >>> sorted(result.items())\n    [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\nSpecifying *reducefunc* summarizes the categorized items:\n\n    >>> keyfunc = lambda x: x.upper()\n    >>> valuefunc = lambda x: 1\n    >>> reducefunc = sum\n    >>> result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)\n    >>> sorted(result.items())\n    [('A', 1), ('B', 2), ('C', 3)]\n\nYou may want to filter the input iterable before applying the map/reduce\nprocedure:\n\n    >>> all_items = range(30)\n    >>> items = [x for x in all_items if 10 <= x <= 20]  # Filter\n    >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n    >>> categories = map_reduce(items, keyfunc=keyfunc)\n    >>> sorted(categories.items())\n    [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n    >>> summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)\n    >>> sorted(summaries.items())\n    [(0, 90), (1, 75)]\n\nNote that all items in the iterable are gathered into a list before the\nsummarization step, which may require significant storage.\n\nThe returned object is a :obj:`collections.defaultdict` with the\n``default_factory`` set to ``None``, such that it behaves like a normal\ndictionary."
  },
  {
    "function": "rlocate",
    "code": "def rlocate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``, starting from the right and moving left.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(rlocate([0, 1, 1, 0, 1, 0, 0]))  # Truthy at 1, 2, and 4\n        [4, 2, 1]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item:\n\n        >>> iterator = iter('abcb')\n        >>> pred = lambda x: x == 'b'\n        >>> list(rlocate(iterator, pred))\n        [3, 1]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(rlocate(iterable, pred=pred, window_size=3))\n        [9, 5, 1]\n\n    Beware, this function won't return anything for infinite iterables.\n    If *iterable* is reversible, ``rlocate`` will reverse it and search from\n    the right. Otherwise, it will search from the left and return the results\n    in reverse order.\n\n    See :func:`locate` to for other example applications.\n\n    \"\"\"\n    if window_size is None:\n        try:\n            len_iter = len(iterable)\n            return (len_iter - i - 1 for i in locate(reversed(iterable), pred))\n        except TypeError:\n            pass\n\n    return reversed(list(locate(iterable, pred, window_size)))",
    "docstring": "Yield the index of each item in *iterable* for which *pred* returns\n``True``, starting from the right and moving left.\n\n*pred* defaults to :func:`bool`, which will select truthy items:\n\n    >>> list(rlocate([0, 1, 1, 0, 1, 0, 0]))  # Truthy at 1, 2, and 4\n    [4, 2, 1]\n\nSet *pred* to a custom function to, e.g., find the indexes for a particular\nitem:\n\n    >>> iterator = iter('abcb')\n    >>> pred = lambda x: x == 'b'\n    >>> list(rlocate(iterator, pred))\n    [3, 1]\n\nIf *window_size* is given, then the *pred* function will be called with\nthat many items. This enables searching for sub-sequences:\n\n    >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n    >>> pred = lambda *args: args == (1, 2, 3)\n    >>> list(rlocate(iterable, pred=pred, window_size=3))\n    [9, 5, 1]\n\nBeware, this function won't return anything for infinite iterables.\nIf *iterable* is reversible, ``rlocate`` will reverse it and search from\nthe right. Otherwise, it will search from the left and return the results\nin reverse order.\n\nSee :func:`locate` to for other example applications."
  },
  {
    "function": "replace",
    "code": "def replace(iterable, pred, substitutes, count=None, window_size=1):\n    \"\"\"Yield the items from *iterable*, replacing the items for which *pred*\n    returns ``True`` with the items from the iterable *substitutes*.\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = (2, 3)\n        >>> list(replace(iterable, pred, substitutes))\n        [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]\n\n    If *count* is given, the number of replacements will be limited:\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = [None]\n        >>> list(replace(iterable, pred, substitutes, count=2))\n        [1, 1, None, 1, 1, None, 1, 1, 0]\n\n    Use *window_size* to control the number of items passed as arguments to\n    *pred*. This allows for locating and replacing subsequences.\n\n        >>> iterable = [0, 1, 2, 5, 0, 1, 2, 5]\n        >>> window_size = 3\n        >>> pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred\n        >>> substitutes = [3, 4] # Splice in these items\n        >>> list(replace(iterable, pred, substitutes, window_size=window_size))\n        [3, 4, 5, 3, 4, 5]\n\n    \"\"\"\n    if window_size < 1:\n        raise ValueError('window_size must be at least 1')\n\n    # Save the substitutes iterable, since it's used more than once\n    substitutes = tuple(substitutes)\n\n    # Add padding such that the number of windows matches the length of the\n    # iterable\n    it = chain(iterable, repeat(_marker, window_size - 1))\n    windows = windowed(it, window_size)\n\n    n = 0\n    for w in windows:\n        # If the current window matches our predicate (and we haven't hit\n        # our maximum number of replacements), splice in the substitutes\n        # and then consume the following windows that overlap with this one.\n        # For example, if the iterable is (0, 1, 2, 3, 4...)\n        # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...\n        # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)\n        if pred(*w):\n            if (count is None) or (n < count):\n                n += 1\n                yield from substitutes\n                consume(windows, window_size - 1)\n                continue\n\n        # If there was no match (or we've reached the replacement limit),\n        # yield the first item from the window.\n        if w and (w[0] is not _marker):\n            yield w[0]",
    "docstring": "Yield the items from *iterable*, replacing the items for which *pred*\nreturns ``True`` with the items from the iterable *substitutes*.\n\n    >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1]\n    >>> pred = lambda x: x == 0\n    >>> substitutes = (2, 3)\n    >>> list(replace(iterable, pred, substitutes))\n    [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]\n\nIf *count* is given, the number of replacements will be limited:\n\n    >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]\n    >>> pred = lambda x: x == 0\n    >>> substitutes = [None]\n    >>> list(replace(iterable, pred, substitutes, count=2))\n    [1, 1, None, 1, 1, None, 1, 1, 0]\n\nUse *window_size* to control the number of items passed as arguments to\n*pred*. This allows for locating and replacing subsequences.\n\n    >>> iterable = [0, 1, 2, 5, 0, 1, 2, 5]\n    >>> window_size = 3\n    >>> pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred\n    >>> substitutes = [3, 4] # Splice in these items\n    >>> list(replace(iterable, pred, substitutes, window_size=window_size))\n    [3, 4, 5, 3, 4, 5]"
  },
  {
    "function": "partitions",
    "code": "def partitions(iterable):\n    \"\"\"Yield all possible order-preserving partitions of *iterable*.\n\n    >>> iterable = 'abc'\n    >>> for part in partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['a', 'b', 'c']\n\n    This is unrelated to :func:`partition`.\n\n    \"\"\"\n    sequence = list(iterable)\n    n = len(sequence)\n    for i in powerset(range(1, n)):\n        yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]",
    "docstring": "Yield all possible order-preserving partitions of *iterable*.\n\n>>> iterable = 'abc'\n>>> for part in partitions(iterable):\n...     print([''.join(p) for p in part])\n['abc']\n['a', 'bc']\n['ab', 'c']\n['a', 'b', 'c']\n\nThis is unrelated to :func:`partition`."
  },
  {
    "function": "set_partitions",
    "code": "def set_partitions(iterable, k=None, min_size=None, max_size=None):\n    \"\"\"\n    Yield the set partitions of *iterable* into *k* parts. Set partitions are\n    not order-preserving.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable, 2):\n    ...     print([''.join(p) for p in part])\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n\n\n    If *k* is not given, every set partition is generated.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n    ['a', 'b', 'c']\n\n    if *min_size* and/or *max_size* are given, the minimum and/or maximum size\n    per block in partition is set.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable, min_size=2):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    >>> for part in set_partitions(iterable, max_size=2):\n    ...     print([''.join(p) for p in part])\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n    ['a', 'b', 'c']\n\n    \"\"\"\n    L = list(iterable)\n    n = len(L)\n    if k is not None:\n        if k < 1:\n            raise ValueError(\n                \"Can't partition in a negative or zero number of groups\"\n            )\n        elif k > n:\n            return\n\n    min_size = min_size if min_size is not None else 0\n    max_size = max_size if max_size is not None else n\n    if min_size > max_size:\n        return\n\n    def set_partitions_helper(L, k):\n        n = len(L)\n        if k == 1:\n            yield [L]\n        elif n == k:\n            yield [[s] for s in L]\n        else:\n            e, *M = L\n            for p in set_partitions_helper(M, k - 1):\n                yield [[e], *p]\n            for p in set_partitions_helper(M, k):\n                for i in range(len(p)):\n                    yield p[:i] + [[e] + p[i]] + p[i + 1 :]\n\n    if k is None:\n        for k in range(1, n + 1):\n            yield from filter(\n                lambda z: all(min_size <= len(bk) <= max_size for bk in z),\n                set_partitions_helper(L, k),\n            )\n    else:\n        yield from filter(\n            lambda z: all(min_size <= len(bk) <= max_size for bk in z),\n            set_partitions_helper(L, k),\n        )",
    "docstring": "Yield the set partitions of *iterable* into *k* parts. Set partitions are\nnot order-preserving.\n\n>>> iterable = 'abc'\n>>> for part in set_partitions(iterable, 2):\n...     print([''.join(p) for p in part])\n['a', 'bc']\n['ab', 'c']\n['b', 'ac']\n\n\nIf *k* is not given, every set partition is generated.\n\n>>> iterable = 'abc'\n>>> for part in set_partitions(iterable):\n...     print([''.join(p) for p in part])\n['abc']\n['a', 'bc']\n['ab', 'c']\n['b', 'ac']\n['a', 'b', 'c']\n\nif *min_size* and/or *max_size* are given, the minimum and/or maximum size\nper block in partition is set.\n\n>>> iterable = 'abc'\n>>> for part in set_partitions(iterable, min_size=2):\n...     print([''.join(p) for p in part])\n['abc']\n>>> for part in set_partitions(iterable, max_size=2):\n...     print([''.join(p) for p in part])\n['a', 'bc']\n['ab', 'c']\n['b', 'ac']\n['a', 'b', 'c']"
  },
  {
    "function": "only",
    "code": "def only(iterable, default=None, too_long=None):\n    \"\"\"If *iterable* has only one item, return it.\n    If it has zero items, return *default*.\n    If it has more than one item, raise the exception given by *too_long*,\n    which is ``ValueError`` by default.\n\n    >>> only([], default='missing')\n    'missing'\n    >>> only([1])\n    1\n    >>> only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: Expected exactly one item in iterable, but got 1, 2,\n     and perhaps more.'\n    >>> only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    TypeError\n\n    Note that :func:`only` attempts to advance *iterable* twice to ensure there\n    is only one item.  See :func:`spy` or :func:`peekable` to check\n    iterable contents less destructively.\n\n    \"\"\"\n    iterator = iter(iterable)\n    for first in iterator:\n        for second in iterator:\n            msg = (\n                f'Expected exactly one item in iterable, but got {first!r}, '\n                f'{second!r}, and perhaps more.'\n            )\n            raise too_long or ValueError(msg)\n        return first\n    return default",
    "docstring": "If *iterable* has only one item, return it.\nIf it has zero items, return *default*.\nIf it has more than one item, raise the exception given by *too_long*,\nwhich is ``ValueError`` by default.\n\n>>> only([], default='missing')\n'missing'\n>>> only([1])\n1\n>>> only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nValueError: Expected exactly one item in iterable, but got 1, 2,\n and perhaps more.'\n>>> only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nTypeError\n\nNote that :func:`only` attempts to advance *iterable* twice to ensure there\nis only one item.  See :func:`spy` or :func:`peekable` to check\niterable contents less destructively."
  },
  {
    "function": "ichunked",
    "code": "def ichunked(iterable, n):\n    \"\"\"Break *iterable* into sub-iterables with *n* elements each.\n    :func:`ichunked` is like :func:`chunked`, but it yields iterables\n    instead of lists.\n\n    If the sub-iterables are read in order, the elements of *iterable*\n    won't be stored in memory.\n    If they are read out of order, :func:`itertools.tee` is used to cache\n    elements as necessary.\n\n    >>> from itertools import count\n    >>> all_chunks = ichunked(count(), 4)\n    >>> c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)\n    >>> list(c_2)  # c_1's elements have been cached; c_3's haven't been\n    [4, 5, 6, 7]\n    >>> list(c_1)\n    [0, 1, 2, 3]\n    >>> list(c_3)\n    [8, 9, 10, 11]\n\n    \"\"\"\n    iterator = iter(iterable)\n    while True:\n        # Create new chunk\n        chunk, materialize_next = _ichunk(iterator, n)\n\n        # Check to see whether we're at the end of the source iterable\n        if not materialize_next():\n            return\n\n        yield chunk\n\n        # Fill previous chunk's cache\n        materialize_next(None)",
    "docstring": "Break *iterable* into sub-iterables with *n* elements each.\n:func:`ichunked` is like :func:`chunked`, but it yields iterables\ninstead of lists.\n\nIf the sub-iterables are read in order, the elements of *iterable*\nwon't be stored in memory.\nIf they are read out of order, :func:`itertools.tee` is used to cache\nelements as necessary.\n\n>>> from itertools import count\n>>> all_chunks = ichunked(count(), 4)\n>>> c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)\n>>> list(c_2)  # c_1's elements have been cached; c_3's haven't been\n[4, 5, 6, 7]\n>>> list(c_1)\n[0, 1, 2, 3]\n>>> list(c_3)\n[8, 9, 10, 11]"
  },
  {
    "function": "iequals",
    "code": "def iequals(*iterables):\n    \"\"\"Return ``True`` if all given *iterables* are equal to each other,\n    which means that they contain the same elements in the same order.\n\n    The function is useful for comparing iterables of different data types\n    or iterables that do not support equality checks.\n\n    >>> iequals(\"abc\", ['a', 'b', 'c'], ('a', 'b', 'c'), iter(\"abc\"))\n    True\n\n    >>> iequals(\"abc\", \"acb\")\n    False\n\n    Not to be confused with :func:`all_equal`, which checks whether all\n    elements of iterable are equal to each other.\n\n    \"\"\"\n    try:\n        return all(map(all_equal, zip(*iterables, strict=True)))\n    except ValueError:\n        return False",
    "docstring": "Return ``True`` if all given *iterables* are equal to each other,\nwhich means that they contain the same elements in the same order.\n\nThe function is useful for comparing iterables of different data types\nor iterables that do not support equality checks.\n\n>>> iequals(\"abc\", ['a', 'b', 'c'], ('a', 'b', 'c'), iter(\"abc\"))\nTrue\n\n>>> iequals(\"abc\", \"acb\")\nFalse\n\nNot to be confused with :func:`all_equal`, which checks whether all\nelements of iterable are equal to each other."
  },
  {
    "function": "distinct_combinations",
    "code": "def distinct_combinations(iterable, r):\n    \"\"\"Yield the distinct combinations of *r* items taken from *iterable*.\n\n        >>> list(distinct_combinations([0, 0, 1], 2))\n        [(0, 0), (0, 1)]\n\n    Equivalent to ``set(combinations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    \"\"\"\n    if r < 0:\n        raise ValueError('r must be non-negative')\n    elif r == 0:\n        yield ()\n        return\n    pool = tuple(iterable)\n    generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]\n    current_combo = [None] * r\n    level = 0\n    while generators:\n        try:\n            cur_idx, p = next(generators[-1])\n        except StopIteration:\n            generators.pop()\n            level -= 1\n            continue\n        current_combo[level] = p\n        if level + 1 == r:\n            yield tuple(current_combo)\n        else:\n            generators.append(\n                unique_everseen(\n                    enumerate(pool[cur_idx + 1 :], cur_idx + 1),\n                    key=itemgetter(1),\n                )\n            )\n            level += 1",
    "docstring": "Yield the distinct combinations of *r* items taken from *iterable*.\n\n    >>> list(distinct_combinations([0, 0, 1], 2))\n    [(0, 0), (0, 1)]\n\nEquivalent to ``set(combinations(iterable))``, except duplicates are not\ngenerated and thrown away. For larger input sequences this is much more\nefficient."
  },
  {
    "function": "filter_except",
    "code": "def filter_except(validator, iterable, *exceptions):\n    \"\"\"Yield the items from *iterable* for which the *validator* function does\n    not raise one of the specified *exceptions*.\n\n    *validator* is called for each item in *iterable*.\n    It should be a function that accepts one argument and raises an exception\n    if that item is not valid.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(filter_except(int, iterable, ValueError, TypeError))\n    ['1', '2', '4']\n\n    If an exception other than one given by *exceptions* is raised by\n    *validator*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            validator(item)\n        except exceptions:\n            pass\n        else:\n            yield item",
    "docstring": "Yield the items from *iterable* for which the *validator* function does\nnot raise one of the specified *exceptions*.\n\n*validator* is called for each item in *iterable*.\nIt should be a function that accepts one argument and raises an exception\nif that item is not valid.\n\n>>> iterable = ['1', '2', 'three', '4', None]\n>>> list(filter_except(int, iterable, ValueError, TypeError))\n['1', '2', '4']\n\nIf an exception other than one given by *exceptions* is raised by\n*validator*, it is raised like normal."
  },
  {
    "function": "map_except",
    "code": "def map_except(function, iterable, *exceptions):\n    \"\"\"Transform each item from *iterable* with *function* and yield the\n    result, unless *function* raises one of the specified *exceptions*.\n\n    *function* is called to transform each item in *iterable*.\n    It should accept one argument.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(map_except(int, iterable, ValueError, TypeError))\n    [1, 2, 4]\n\n    If an exception other than one given by *exceptions* is raised by\n    *function*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            yield function(item)\n        except exceptions:\n            pass",
    "docstring": "Transform each item from *iterable* with *function* and yield the\nresult, unless *function* raises one of the specified *exceptions*.\n\n*function* is called to transform each item in *iterable*.\nIt should accept one argument.\n\n>>> iterable = ['1', '2', 'three', '4', None]\n>>> list(map_except(int, iterable, ValueError, TypeError))\n[1, 2, 4]\n\nIf an exception other than one given by *exceptions* is raised by\n*function*, it is raised like normal."
  },
  {
    "function": "map_if",
    "code": "def map_if(iterable, pred, func, func_else=None):\n    \"\"\"Evaluate each item from *iterable* using *pred*. If the result is\n    equivalent to ``True``, transform the item with *func* and yield it.\n    Otherwise, transform the item with *func_else* and yield it.\n\n    *pred*, *func*, and *func_else* should each be functions that accept\n    one argument. By default, *func_else* is the identity function.\n\n    >>> from math import sqrt\n    >>> iterable = list(range(-5, 5))\n    >>> iterable\n    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n    >>> list(map_if(iterable, lambda x: x > 3, lambda x: 'toobig'))\n    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']\n    >>> list(map_if(iterable, lambda x: x >= 0,\n    ... lambda x: f'{sqrt(x):.2f}', lambda x: None))\n    [None, None, None, None, None, '0.00', '1.00', '1.41', '1.73', '2.00']\n    \"\"\"\n\n    if func_else is None:\n        for item in iterable:\n            yield func(item) if pred(item) else item\n\n    else:\n        for item in iterable:\n            yield func(item) if pred(item) else func_else(item)",
    "docstring": "Evaluate each item from *iterable* using *pred*. If the result is\nequivalent to ``True``, transform the item with *func* and yield it.\nOtherwise, transform the item with *func_else* and yield it.\n\n*pred*, *func*, and *func_else* should each be functions that accept\none argument. By default, *func_else* is the identity function.\n\n>>> from math import sqrt\n>>> iterable = list(range(-5, 5))\n>>> iterable\n[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n>>> list(map_if(iterable, lambda x: x > 3, lambda x: 'toobig'))\n[-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']\n>>> list(map_if(iterable, lambda x: x >= 0,\n... lambda x: f'{sqrt(x):.2f}', lambda x: None))\n[None, None, None, None, None, '0.00', '1.00', '1.41', '1.73', '2.00']"
  },
  {
    "function": "sample",
    "code": "def sample(iterable, k, weights=None, *, counts=None, strict=False):\n    \"\"\"Return a *k*-length list of elements chosen (without replacement)\n    from the *iterable*.\n\n    Similar to :func:`random.sample`, but works on inputs that aren't\n    indexable (such as sets and dictionaries) and on inputs where the\n    size isn't known in advance (such as generators).\n\n    >>> iterable = range(100)\n    >>> sample(iterable, 5)  # doctest: +SKIP\n    [81, 60, 96, 16, 4]\n\n    For iterables with repeated elements, you may supply *counts* to\n    indicate the repeats.\n\n    >>> iterable = ['a', 'b']\n    >>> counts = [3, 4]  # Equivalent to 'a', 'a', 'a', 'b', 'b', 'b', 'b'\n    >>> sample(iterable, k=3, counts=counts)  # doctest: +SKIP\n    ['a', 'a', 'b']\n\n    An iterable with *weights* may be given:\n\n    >>> iterable = range(100)\n    >>> weights = (i * i + 1 for i in range(100))\n    >>> sampled = sample(iterable, 5, weights=weights)  # doctest: +SKIP\n    [79, 67, 74, 66, 78]\n\n    Weighted selections are made without replacement.\n    After an element is selected, it is removed from the pool and the\n    relative weights of the other elements increase (this\n    does not match the behavior of :func:`random.sample`'s *counts*\n    parameter). Note that *weights* may not be used with *counts*.\n\n    If the length of *iterable* is less than *k*,\n    ``ValueError`` is raised if *strict* is ``True`` and\n    all elements are returned (in shuffled order) if *strict* is ``False``.\n\n    By default, the `Algorithm L <https://w.wiki/ANrM>`__ reservoir sampling\n    technique is used. When *weights* are provided,\n    `Algorithm A-ExpJ <https://w.wiki/ANrS>`__ is used instead.\n\n    Notes on reproducibility:\n\n    * The algorithms rely on inexact floating-point functions provided\n      by the underlying math library (e.g. ``log``, ``log1p``, and ``pow``).\n      Those functions can `produce slightly different results\n      <https://members.loria.fr/PZimmermann/papers/accuracy.pdf>`_ on\n      different builds.  Accordingly, selections can vary across builds\n      even for the same seed.\n\n    * The algorithms loop over the input and make selections based on\n      ordinal position, so selections from unordered collections (such as\n      sets) won't reproduce across sessions on the same platform using the\n      same seed.  For example, this won't reproduce::\n\n          >> seed(8675309)\n          >> sample(set('abcdefghijklmnopqrstuvwxyz'), 10)\n          ['c', 'p', 'e', 'w', 's', 'a', 'j', 'd', 'n', 't']\n\n    \"\"\"\n    iterator = iter(iterable)\n\n    if k < 0:\n        raise ValueError('k must be non-negative')\n\n    if k == 0:\n        return []\n\n    if weights is not None and counts is not None:\n        raise TypeError('weights and counts are mutually exclusive')\n\n    elif weights is not None:\n        weights = iter(weights)\n        return _sample_weighted(iterator, k, weights, strict)\n\n    elif counts is not None:\n        counts = iter(counts)\n        return _sample_counted(iterator, k, counts, strict)\n\n    else:\n        return _sample_unweighted(iterator, k, strict)",
    "docstring": "Return a *k*-length list of elements chosen (without replacement)\nfrom the *iterable*.\n\nSimilar to :func:`random.sample`, but works on inputs that aren't\nindexable (such as sets and dictionaries) and on inputs where the\nsize isn't known in advance (such as generators).\n\n>>> iterable = range(100)\n>>> sample(iterable, 5)  # doctest: +SKIP\n[81, 60, 96, 16, 4]\n\nFor iterables with repeated elements, you may supply *counts* to\nindicate the repeats.\n\n>>> iterable = ['a', 'b']\n>>> counts = [3, 4]  # Equivalent to 'a', 'a', 'a', 'b', 'b', 'b', 'b'\n>>> sample(iterable, k=3, counts=counts)  # doctest: +SKIP\n['a', 'a', 'b']\n\nAn iterable with *weights* may be given:\n\n>>> iterable = range(100)\n>>> weights = (i * i + 1 for i in range(100))\n>>> sampled = sample(iterable, 5, weights=weights)  # doctest: +SKIP\n[79, 67, 74, 66, 78]\n\nWeighted selections are made without replacement.\nAfter an element is selected, it is removed from the pool and the\nrelative weights of the other elements increase (this\ndoes not match the behavior of :func:`random.sample`'s *counts*\nparameter). Note that *weights* may not be used with *counts*.\n\nIf the length of *iterable* is less than *k*,\n``ValueError`` is raised if *strict* is ``True`` and\nall elements are returned (in shuffled order) if *strict* is ``False``.\n\nBy default, the `Algorithm L <https://w.wiki/ANrM>`__ reservoir sampling\ntechnique is used. When *weights* are provided,\n`Algorithm A-ExpJ <https://w.wiki/ANrS>`__ is used instead.\n\nNotes on reproducibility:\n\n* The algorithms rely on inexact floating-point functions provided\n  by the underlying math library (e.g. ``log``, ``log1p``, and ``pow``).\n  Those functions can `produce slightly different results\n  <https://members.loria.fr/PZimmermann/papers/accuracy.pdf>`_ on\n  different builds.  Accordingly, selections can vary across builds\n  even for the same seed.\n\n* The algorithms loop over the input and make selections based on\n  ordinal position, so selections from unordered collections (such as\n  sets) won't reproduce across sessions on the same platform using the\n  same seed.  For example, this won't reproduce::\n\n      >> seed(8675309)\n      >> sample(set('abcdefghijklmnopqrstuvwxyz'), 10)\n      ['c', 'p', 'e', 'w', 's', 'a', 'j', 'd', 'n', 't']"
  },
  {
    "function": "is_sorted",
    "code": "def is_sorted(iterable, key=None, reverse=False, strict=False):\n    \"\"\"Returns ``True`` if the items of iterable are in sorted order, and\n    ``False`` otherwise. *key* and *reverse* have the same meaning that they do\n    in the built-in :func:`sorted` function.\n\n    >>> is_sorted(['1', '2', '3', '4', '5'], key=int)\n    True\n    >>> is_sorted([5, 4, 3, 1, 2], reverse=True)\n    False\n\n    If *strict*, tests for strict sorting, that is, returns ``False`` if equal\n    elements are found:\n\n    >>> is_sorted([1, 2, 2])\n    True\n    >>> is_sorted([1, 2, 2], strict=True)\n    False\n\n    The function returns ``False`` after encountering the first out-of-order\n    item, which means it may produce results that differ from the built-in\n    :func:`sorted` function for objects with unusual comparison dynamics\n    (like ``math.nan``). If there are no out-of-order items, the iterable is\n    exhausted.\n    \"\"\"\n    it = iterable if (key is None) else map(key, iterable)\n    a, b = tee(it)\n    next(b, None)\n    if reverse:\n        b, a = a, b\n    return all(map(lt, a, b)) if strict else not any(map(lt, b, a))",
    "docstring": "Returns ``True`` if the items of iterable are in sorted order, and\n``False`` otherwise. *key* and *reverse* have the same meaning that they do\nin the built-in :func:`sorted` function.\n\n>>> is_sorted(['1', '2', '3', '4', '5'], key=int)\nTrue\n>>> is_sorted([5, 4, 3, 1, 2], reverse=True)\nFalse\n\nIf *strict*, tests for strict sorting, that is, returns ``False`` if equal\nelements are found:\n\n>>> is_sorted([1, 2, 2])\nTrue\n>>> is_sorted([1, 2, 2], strict=True)\nFalse\n\nThe function returns ``False`` after encountering the first out-of-order\nitem, which means it may produce results that differ from the built-in\n:func:`sorted` function for objects with unusual comparison dynamics\n(like ``math.nan``). If there are no out-of-order items, the iterable is\nexhausted."
  },
  {
    "function": "windowed_complete",
    "code": "def windowed_complete(iterable, n):\n    \"\"\"\n    Yield ``(beginning, middle, end)`` tuples, where:\n\n    * Each ``middle`` has *n* items from *iterable*\n    * Each ``beginning`` has the items before the ones in ``middle``\n    * Each ``end`` has the items after the ones in ``middle``\n\n    >>> iterable = range(7)\n    >>> n = 3\n    >>> for beginning, middle, end in windowed_complete(iterable, n):\n    ...     print(beginning, middle, end)\n    () (0, 1, 2) (3, 4, 5, 6)\n    (0,) (1, 2, 3) (4, 5, 6)\n    (0, 1) (2, 3, 4) (5, 6)\n    (0, 1, 2) (3, 4, 5) (6,)\n    (0, 1, 2, 3) (4, 5, 6) ()\n\n    Note that *n* must be at least 0 and most equal to the length of\n    *iterable*.\n\n    This function will exhaust the iterable and may require significant\n    storage.\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be >= 0')\n\n    seq = tuple(iterable)\n    size = len(seq)\n\n    if n > size:\n        raise ValueError('n must be <= len(seq)')\n\n    for i in range(size - n + 1):\n        beginning = seq[:i]\n        middle = seq[i : i + n]\n        end = seq[i + n :]\n        yield beginning, middle, end",
    "docstring": "Yield ``(beginning, middle, end)`` tuples, where:\n\n* Each ``middle`` has *n* items from *iterable*\n* Each ``beginning`` has the items before the ones in ``middle``\n* Each ``end`` has the items after the ones in ``middle``\n\n>>> iterable = range(7)\n>>> n = 3\n>>> for beginning, middle, end in windowed_complete(iterable, n):\n...     print(beginning, middle, end)\n() (0, 1, 2) (3, 4, 5, 6)\n(0,) (1, 2, 3) (4, 5, 6)\n(0, 1) (2, 3, 4) (5, 6)\n(0, 1, 2) (3, 4, 5) (6,)\n(0, 1, 2, 3) (4, 5, 6) ()\n\nNote that *n* must be at least 0 and most equal to the length of\n*iterable*.\n\nThis function will exhaust the iterable and may require significant\nstorage."
  },
  {
    "function": "all_unique",
    "code": "def all_unique(iterable, key=None):\n    \"\"\"\n    Returns ``True`` if all the elements of *iterable* are unique (no two\n    elements are equal).\n\n        >>> all_unique('ABCB')\n        False\n\n    If a *key* function is specified, it will be used to make comparisons.\n\n        >>> all_unique('ABCb')\n        True\n        >>> all_unique('ABCb', str.lower)\n        False\n\n    The function returns as soon as the first non-unique element is\n    encountered. Iterables with a mix of hashable and unhashable items can\n    be used, but the function will be slower for unhashable items.\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    for element in map(key, iterable) if key else iterable:\n        try:\n            if element in seenset:\n                return False\n            seenset_add(element)\n        except TypeError:\n            if element in seenlist:\n                return False\n            seenlist_add(element)\n    return True",
    "docstring": "Returns ``True`` if all the elements of *iterable* are unique (no two\nelements are equal).\n\n    >>> all_unique('ABCB')\n    False\n\nIf a *key* function is specified, it will be used to make comparisons.\n\n    >>> all_unique('ABCb')\n    True\n    >>> all_unique('ABCb', str.lower)\n    False\n\nThe function returns as soon as the first non-unique element is\nencountered. Iterables with a mix of hashable and unhashable items can\nbe used, but the function will be slower for unhashable items."
  },
  {
    "function": "nth_product",
    "code": "def nth_product(index, *args):\n    \"\"\"Equivalent to ``list(product(*args))[index]``.\n\n    The products of *args* can be ordered lexicographically.\n    :func:`nth_product` computes the product at sort position *index* without\n    computing the previous products.\n\n        >>> nth_product(8, range(2), range(2), range(2), range(2))\n        (1, 0, 0, 0)\n\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pools = list(map(tuple, reversed(args)))\n    ns = list(map(len, pools))\n\n    c = reduce(mul, ns)\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = []\n    for pool, n in zip(pools, ns):\n        result.append(pool[index % n])\n        index //= n\n\n    return tuple(reversed(result))",
    "docstring": "Equivalent to ``list(product(*args))[index]``.\n\nThe products of *args* can be ordered lexicographically.\n:func:`nth_product` computes the product at sort position *index* without\ncomputing the previous products.\n\n    >>> nth_product(8, range(2), range(2), range(2), range(2))\n    (1, 0, 0, 0)\n\n``IndexError`` will be raised if the given *index* is invalid."
  },
  {
    "function": "nth_permutation",
    "code": "def nth_permutation(iterable, r, index):\n    \"\"\"Equivalent to ``list(permutations(iterable, r))[index]```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`nth_permutation`\n    computes the subsequence at sort position *index* directly, without\n    computing the previous subsequences.\n\n        >>> nth_permutation('ghijk', 2, 5)\n        ('h', 'i')\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = list(iterable)\n    n = len(pool)\n\n    if r is None or r == n:\n        r, c = n, factorial(n)\n    elif not 0 <= r < n:\n        raise ValueError\n    else:\n        c = perm(n, r)\n    assert c > 0  # factorial(n)>0, and r<n so perm(n,r) is never zero\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = [0] * r\n    q = index * factorial(n) // c if r < n else index\n    for d in range(1, n + 1):\n        q, i = divmod(q, d)\n        if 0 <= n - d < r:\n            result[n - d] = i\n        if q == 0:\n            break\n\n    return tuple(map(pool.pop, result))",
    "docstring": "Equivalent to ``list(permutations(iterable, r))[index]```\n\nThe subsequences of *iterable* that are of length *r* where order is\nimportant can be ordered lexicographically. :func:`nth_permutation`\ncomputes the subsequence at sort position *index* directly, without\ncomputing the previous subsequences.\n\n    >>> nth_permutation('ghijk', 2, 5)\n    ('h', 'i')\n\n``ValueError`` will be raised If *r* is negative or greater than the length\nof *iterable*.\n``IndexError`` will be raised if the given *index* is invalid."
  },
  {
    "function": "nth_combination_with_replacement",
    "code": "def nth_combination_with_replacement(iterable, r, index):\n    \"\"\"Equivalent to\n    ``list(combinations_with_replacement(iterable, r))[index]``.\n\n\n    The subsequences with repetition of *iterable* that are of length *r* can\n    be ordered lexicographically. :func:`nth_combination_with_replacement`\n    computes the subsequence at sort position *index* directly, without\n    computing the previous subsequences with replacement.\n\n        >>> nth_combination_with_replacement(range(5), 3, 5)\n        (0, 1, 1)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = comb(n + r - 1, r)\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    i = 0\n    while r:\n        r -= 1\n        while n >= 0:\n            num_combs = comb(n + r - 1, r)\n            if index < num_combs:\n                break\n            n -= 1\n            i += 1\n            index -= num_combs\n        result.append(pool[i])\n\n    return tuple(result)",
    "docstring": "Equivalent to\n``list(combinations_with_replacement(iterable, r))[index]``.\n\n\nThe subsequences with repetition of *iterable* that are of length *r* can\nbe ordered lexicographically. :func:`nth_combination_with_replacement`\ncomputes the subsequence at sort position *index* directly, without\ncomputing the previous subsequences with replacement.\n\n    >>> nth_combination_with_replacement(range(5), 3, 5)\n    (0, 1, 1)\n\n``ValueError`` will be raised If *r* is negative or greater than the length\nof *iterable*.\n``IndexError`` will be raised if the given *index* is invalid."
  },
  {
    "function": "value_chain",
    "code": "def value_chain(*args):\n    \"\"\"Yield all arguments passed to the function in the same order in which\n    they were passed. If an argument itself is iterable then iterate over its\n    values.\n\n        >>> list(value_chain(1, 2, 3, [4, 5, 6]))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and are emitted\n    as-is:\n\n        >>> list(value_chain('12', '34', ['56', '78']))\n        ['12', '34', '56', '78']\n\n    Pre- or postpend a single element to an iterable:\n\n        >>> list(value_chain(1, [2, 3, 4, 5, 6]))\n        [1, 2, 3, 4, 5, 6]\n        >>> list(value_chain([1, 2, 3, 4, 5], 6))\n        [1, 2, 3, 4, 5, 6]\n\n    Multiple levels of nesting are not flattened.\n\n    \"\"\"\n    scalar_types = (str, bytes)\n    for value in args:\n        if isinstance(value, scalar_types):\n            yield value\n            continue\n        try:\n            yield from value\n        except TypeError:\n            yield value",
    "docstring": "Yield all arguments passed to the function in the same order in which\nthey were passed. If an argument itself is iterable then iterate over its\nvalues.\n\n    >>> list(value_chain(1, 2, 3, [4, 5, 6]))\n    [1, 2, 3, 4, 5, 6]\n\nBinary and text strings are not considered iterable and are emitted\nas-is:\n\n    >>> list(value_chain('12', '34', ['56', '78']))\n    ['12', '34', '56', '78']\n\nPre- or postpend a single element to an iterable:\n\n    >>> list(value_chain(1, [2, 3, 4, 5, 6]))\n    [1, 2, 3, 4, 5, 6]\n    >>> list(value_chain([1, 2, 3, 4, 5], 6))\n    [1, 2, 3, 4, 5, 6]\n\nMultiple levels of nesting are not flattened."
  },
  {
    "function": "product_index",
    "code": "def product_index(element, *args):\n    \"\"\"Equivalent to ``list(product(*args)).index(element)``\n\n    The products of *args* can be ordered lexicographically.\n    :func:`product_index` computes the first index of *element* without\n    computing the previous products.\n\n        >>> product_index([8, 2], range(10), range(5))\n        42\n\n    ``ValueError`` will be raised if the given *element* isn't in the product\n    of *args*.\n    \"\"\"\n    elements = tuple(element)\n    pools = tuple(map(tuple, args))\n    if len(elements) != len(pools):\n        raise ValueError('element is not a product of args')\n\n    index = 0\n    for elem, pool in zip(elements, pools):\n        index = index * len(pool) + pool.index(elem)\n    return index",
    "docstring": "Equivalent to ``list(product(*args)).index(element)``\n\nThe products of *args* can be ordered lexicographically.\n:func:`product_index` computes the first index of *element* without\ncomputing the previous products.\n\n    >>> product_index([8, 2], range(10), range(5))\n    42\n\n``ValueError`` will be raised if the given *element* isn't in the product\nof *args*."
  },
  {
    "function": "combination_index",
    "code": "def combination_index(element, iterable):\n    \"\"\"Equivalent to ``list(combinations(iterable, r)).index(element)``\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`combination_index` computes the index of the\n    first *element*, without computing the previous combinations.\n\n        >>> combination_index('adf', 'abcdefg')\n        10\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations of *iterable*.\n    \"\"\"\n    element = enumerate(element)\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = enumerate(iterable)\n    for n, x in pool:\n        if x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n    else:\n        raise ValueError('element is not a combination of iterable')\n\n    n, _ = last(pool, default=(n, None))\n\n    index = 1\n    for i, j in enumerate(reversed(indexes), start=1):\n        j = n - j\n        if i <= j:\n            index += comb(j, i)\n\n    return comb(n + 1, k + 1) - index",
    "docstring": "Equivalent to ``list(combinations(iterable, r)).index(element)``\n\nThe subsequences of *iterable* that are of length *r* can be ordered\nlexicographically. :func:`combination_index` computes the index of the\nfirst *element*, without computing the previous combinations.\n\n    >>> combination_index('adf', 'abcdefg')\n    10\n\n``ValueError`` will be raised if the given *element* isn't one of the\ncombinations of *iterable*."
  },
  {
    "function": "combination_with_replacement_index",
    "code": "def combination_with_replacement_index(element, iterable):\n    \"\"\"Equivalent to\n    ``list(combinations_with_replacement(iterable, r)).index(element)``\n\n    The subsequences with repetition of *iterable* that are of length *r* can\n    be ordered lexicographically. :func:`combination_with_replacement_index`\n    computes the index of the first *element*, without computing the previous\n    combinations with replacement.\n\n        >>> combination_with_replacement_index('adf', 'abcdefg')\n        20\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations with replacement of *iterable*.\n    \"\"\"\n    element = tuple(element)\n    l = len(element)\n    element = enumerate(element)\n\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = tuple(iterable)\n    for n, x in enumerate(pool):\n        while x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n        if y is None:\n            break\n    else:\n        raise ValueError(\n            'element is not a combination with replacement of iterable'\n        )\n\n    n = len(pool)\n    occupations = [0] * n\n    for p in indexes:\n        occupations[p] += 1\n\n    index = 0\n    cumulative_sum = 0\n    for k in range(1, n):\n        cumulative_sum += occupations[k - 1]\n        j = l + n - 1 - k - cumulative_sum\n        i = n - k\n        if i <= j:\n            index += comb(j, i)\n\n    return index",
    "docstring": "Equivalent to\n``list(combinations_with_replacement(iterable, r)).index(element)``\n\nThe subsequences with repetition of *iterable* that are of length *r* can\nbe ordered lexicographically. :func:`combination_with_replacement_index`\ncomputes the index of the first *element*, without computing the previous\ncombinations with replacement.\n\n    >>> combination_with_replacement_index('adf', 'abcdefg')\n    20\n\n``ValueError`` will be raised if the given *element* isn't one of the\ncombinations with replacement of *iterable*."
  },
  {
    "function": "permutation_index",
    "code": "def permutation_index(element, iterable):\n    \"\"\"Equivalent to ``list(permutations(iterable, r)).index(element)```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`permutation_index`\n    computes the index of the first *element* directly, without computing\n    the previous permutations.\n\n        >>> permutation_index([1, 3, 2], range(5))\n        19\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    permutations of *iterable*.\n    \"\"\"\n    index = 0\n    pool = list(iterable)\n    for i, x in zip(range(len(pool), -1, -1), element):\n        r = pool.index(x)\n        index = index * i + r\n        del pool[r]\n\n    return index",
    "docstring": "Equivalent to ``list(permutations(iterable, r)).index(element)```\n\nThe subsequences of *iterable* that are of length *r* where order is\nimportant can be ordered lexicographically. :func:`permutation_index`\ncomputes the index of the first *element* directly, without computing\nthe previous permutations.\n\n    >>> permutation_index([1, 3, 2], range(5))\n    19\n\n``ValueError`` will be raised if the given *element* isn't one of the\npermutations of *iterable*."
  },
  {
    "function": "chunked_even",
    "code": "def chunked_even(iterable, n):\n    \"\"\"Break *iterable* into lists of approximately length *n*.\n    Items are distributed such the lengths of the lists differ by at most\n    1 item.\n\n    >>> iterable = [1, 2, 3, 4, 5, 6, 7]\n    >>> n = 3\n    >>> list(chunked_even(iterable, n))  # List lengths: 3, 2, 2\n    [[1, 2, 3], [4, 5], [6, 7]]\n    >>> list(chunked(iterable, n))  # List lengths: 3, 3, 1\n    [[1, 2, 3], [4, 5, 6], [7]]\n\n    \"\"\"\n    iterator = iter(iterable)\n\n    # Initialize a buffer to process the chunks while keeping\n    # some back to fill any underfilled chunks\n    min_buffer = (n - 1) * (n - 2)\n    buffer = list(islice(iterator, min_buffer))\n\n    # Append items until we have a completed chunk\n    for _ in islice(map(buffer.append, iterator), n, None, n):\n        yield buffer[:n]\n        del buffer[:n]\n\n    # Check if any chunks need addition processing\n    if not buffer:\n        return\n    length = len(buffer)\n\n    # Chunks are either size `full_size <= n` or `partial_size = full_size - 1`\n    q, r = divmod(length, n)\n    num_lists = q + (1 if r > 0 else 0)\n    q, r = divmod(length, num_lists)\n    full_size = q + (1 if r > 0 else 0)\n    partial_size = full_size - 1\n    num_full = length - partial_size * num_lists\n\n    # Yield chunks of full size\n    partial_start_idx = num_full * full_size\n    if full_size > 0:\n        for i in range(0, partial_start_idx, full_size):\n            yield buffer[i : i + full_size]\n\n    # Yield chunks of partial size\n    if partial_size > 0:\n        for i in range(partial_start_idx, length, partial_size):\n            yield buffer[i : i + partial_size]",
    "docstring": "Break *iterable* into lists of approximately length *n*.\nItems are distributed such the lengths of the lists differ by at most\n1 item.\n\n>>> iterable = [1, 2, 3, 4, 5, 6, 7]\n>>> n = 3\n>>> list(chunked_even(iterable, n))  # List lengths: 3, 2, 2\n[[1, 2, 3], [4, 5], [6, 7]]\n>>> list(chunked(iterable, n))  # List lengths: 3, 3, 1\n[[1, 2, 3], [4, 5, 6], [7]]"
  },
  {
    "function": "zip_broadcast",
    "code": "def zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):\n    \"\"\"A version of :func:`zip` that \"broadcasts\" any scalar\n    (i.e., non-iterable) items into output tuples.\n\n    >>> iterable_1 = [1, 2, 3]\n    >>> iterable_2 = ['a', 'b', 'c']\n    >>> scalar = '_'\n    >>> list(zip_broadcast(iterable_1, iterable_2, scalar))\n    [(1, 'a', '_'), (2, 'b', '_'), (3, 'c', '_')]\n\n    The *scalar_types* keyword argument determines what types are considered\n    scalar. It is set to ``(str, bytes)`` by default. Set it to ``None`` to\n    treat strings and byte strings as iterable:\n\n    >>> list(zip_broadcast('abc', 0, 'xyz', scalar_types=None))\n    [('a', 0, 'x'), ('b', 0, 'y'), ('c', 0, 'z')]\n\n    If the *strict* keyword argument is ``True``, then\n    ``ValueError`` will be raised if any of the iterables have\n    different lengths.\n    \"\"\"\n\n    def is_scalar(obj):\n        if scalar_types and isinstance(obj, scalar_types):\n            return True\n        try:\n            iter(obj)\n        except TypeError:\n            return True\n        else:\n            return False\n\n    size = len(objects)\n    if not size:\n        return\n\n    new_item = [None] * size\n    iterables, iterable_positions = [], []\n    for i, obj in enumerate(objects):\n        if is_scalar(obj):\n            new_item[i] = obj\n        else:\n            iterables.append(iter(obj))\n            iterable_positions.append(i)\n\n    if not iterables:\n        yield tuple(objects)\n        return\n\n    for item in zip(*iterables, strict=strict):\n        for i, new_item[i] in zip(iterable_positions, item):\n            pass\n        yield tuple(new_item)",
    "docstring": "A version of :func:`zip` that \"broadcasts\" any scalar\n(i.e., non-iterable) items into output tuples.\n\n>>> iterable_1 = [1, 2, 3]\n>>> iterable_2 = ['a', 'b', 'c']\n>>> scalar = '_'\n>>> list(zip_broadcast(iterable_1, iterable_2, scalar))\n[(1, 'a', '_'), (2, 'b', '_'), (3, 'c', '_')]\n\nThe *scalar_types* keyword argument determines what types are considered\nscalar. It is set to ``(str, bytes)`` by default. Set it to ``None`` to\ntreat strings and byte strings as iterable:\n\n>>> list(zip_broadcast('abc', 0, 'xyz', scalar_types=None))\n[('a', 0, 'x'), ('b', 0, 'y'), ('c', 0, 'z')]\n\nIf the *strict* keyword argument is ``True``, then\n``ValueError`` will be raised if any of the iterables have\ndifferent lengths."
  },
  {
    "function": "unique_in_window",
    "code": "def unique_in_window(iterable, n, key=None):\n    \"\"\"Yield the items from *iterable* that haven't been seen recently.\n    *n* is the size of the sliding window.\n\n        >>> iterable = [0, 1, 0, 2, 3, 0]\n        >>> n = 3\n        >>> list(unique_in_window(iterable, n))\n        [0, 1, 2, 3, 0]\n\n    The *key* function, if provided, will be used to determine uniqueness:\n\n        >>> list(unique_in_window('abAcda', 3, key=lambda x: x.lower()))\n        ['a', 'b', 'c', 'd', 'a']\n\n    Updates a sliding window no larger than n and yields a value\n    if the item only occurs once in the updated window.\n\n    When `n == 1`, *unique_in_window* is memoryless:\n\n        >>> list(unique_in_window('aab', n=1))\n        ['a', 'a', 'b']\n\n    The items in *iterable* must be hashable.\n\n    \"\"\"\n    if n <= 0:\n        raise ValueError('n must be greater than 0')\n\n    window = deque(maxlen=n)\n    counts = Counter()\n    use_key = key is not None\n\n    for item in iterable:\n        if len(window) == n:\n            to_discard = window[0]\n            if counts[to_discard] == 1:\n                del counts[to_discard]\n            else:\n                counts[to_discard] -= 1\n\n        k = key(item) if use_key else item\n        if k not in counts:\n            yield item\n        counts[k] += 1\n        window.append(k)",
    "docstring": "Yield the items from *iterable* that haven't been seen recently.\n*n* is the size of the sliding window.\n\n    >>> iterable = [0, 1, 0, 2, 3, 0]\n    >>> n = 3\n    >>> list(unique_in_window(iterable, n))\n    [0, 1, 2, 3, 0]\n\nThe *key* function, if provided, will be used to determine uniqueness:\n\n    >>> list(unique_in_window('abAcda', 3, key=lambda x: x.lower()))\n    ['a', 'b', 'c', 'd', 'a']\n\nUpdates a sliding window no larger than n and yields a value\nif the item only occurs once in the updated window.\n\nWhen `n == 1`, *unique_in_window* is memoryless:\n\n    >>> list(unique_in_window('aab', n=1))\n    ['a', 'a', 'b']\n\nThe items in *iterable* must be hashable."
  },
  {
    "function": "duplicates_everseen",
    "code": "def duplicates_everseen(iterable, key=None):\n    \"\"\"Yield duplicate elements after their first appearance.\n\n    >>> list(duplicates_everseen('mississippi'))\n    ['s', 'i', 's', 's', 'i', 'p', 'i']\n    >>> list(duplicates_everseen('AaaBbbCccAaa', str.lower))\n    ['a', 'a', 'b', 'b', 'c', 'c', 'A', 'a', 'a']\n\n    This function is analogous to :func:`unique_everseen` and is subject to\n    the same performance considerations.\n\n    \"\"\"\n    seen_set = set()\n    seen_list = []\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seen_set:\n                seen_set.add(k)\n            else:\n                yield element\n        except TypeError:\n            if k not in seen_list:\n                seen_list.append(k)\n            else:\n                yield element",
    "docstring": "Yield duplicate elements after their first appearance.\n\n>>> list(duplicates_everseen('mississippi'))\n['s', 'i', 's', 's', 'i', 'p', 'i']\n>>> list(duplicates_everseen('AaaBbbCccAaa', str.lower))\n['a', 'a', 'b', 'b', 'c', 'c', 'A', 'a', 'a']\n\nThis function is analogous to :func:`unique_everseen` and is subject to\nthe same performance considerations."
  },
  {
    "function": "duplicates_justseen",
    "code": "def duplicates_justseen(iterable, key=None):\n    \"\"\"Yields serially-duplicate elements after their first appearance.\n\n    >>> list(duplicates_justseen('mississippi'))\n    ['s', 's', 'p']\n    >>> list(duplicates_justseen('AaaBbbCccAaa', str.lower))\n    ['a', 'a', 'b', 'b', 'c', 'c', 'a', 'a']\n\n    This function is analogous to :func:`unique_justseen`.\n\n    \"\"\"\n    return flatten(g for _, g in groupby(iterable, key) for _ in g)",
    "docstring": "Yields serially-duplicate elements after their first appearance.\n\n>>> list(duplicates_justseen('mississippi'))\n['s', 's', 'p']\n>>> list(duplicates_justseen('AaaBbbCccAaa', str.lower))\n['a', 'a', 'b', 'b', 'c', 'c', 'a', 'a']\n\nThis function is analogous to :func:`unique_justseen`."
  },
  {
    "function": "classify_unique",
    "code": "def classify_unique(iterable, key=None):\n    \"\"\"Classify each element in terms of its uniqueness.\n\n    For each element in the input iterable, return a 3-tuple consisting of:\n\n    1. The element itself\n    2. ``False`` if the element is equal to the one preceding it in the input,\n       ``True`` otherwise (i.e. the equivalent of :func:`unique_justseen`)\n    3. ``False`` if this element has been seen anywhere in the input before,\n       ``True`` otherwise (i.e. the equivalent of :func:`unique_everseen`)\n\n    >>> list(classify_unique('otto'))    # doctest: +NORMALIZE_WHITESPACE\n    [('o', True,  True),\n     ('t', True,  True),\n     ('t', False, False),\n     ('o', True,  False)]\n\n    This function is analogous to :func:`unique_everseen` and is subject to\n    the same performance considerations.\n\n    \"\"\"\n    seen_set = set()\n    seen_list = []\n    use_key = key is not None\n    previous = None\n\n    for i, element in enumerate(iterable):\n        k = key(element) if use_key else element\n        is_unique_justseen = not i or previous != k\n        previous = k\n        is_unique_everseen = False\n        try:\n            if k not in seen_set:\n                seen_set.add(k)\n                is_unique_everseen = True\n        except TypeError:\n            if k not in seen_list:\n                seen_list.append(k)\n                is_unique_everseen = True\n        yield element, is_unique_justseen, is_unique_everseen",
    "docstring": "Classify each element in terms of its uniqueness.\n\nFor each element in the input iterable, return a 3-tuple consisting of:\n\n1. The element itself\n2. ``False`` if the element is equal to the one preceding it in the input,\n   ``True`` otherwise (i.e. the equivalent of :func:`unique_justseen`)\n3. ``False`` if this element has been seen anywhere in the input before,\n   ``True`` otherwise (i.e. the equivalent of :func:`unique_everseen`)\n\n>>> list(classify_unique('otto'))    # doctest: +NORMALIZE_WHITESPACE\n[('o', True,  True),\n ('t', True,  True),\n ('t', False, False),\n ('o', True,  False)]\n\nThis function is analogous to :func:`unique_everseen` and is subject to\nthe same performance considerations."
  },
  {
    "function": "minmax",
    "code": "def minmax(iterable_or_value, *others, key=None, default=_marker):\n    \"\"\"Returns both the smallest and largest items from an iterable\n    or from two or more arguments.\n\n        >>> minmax([3, 1, 5])\n        (1, 5)\n\n        >>> minmax(4, 2, 6)\n        (2, 6)\n\n    If a *key* function is provided, it will be used to transform the input\n    items for comparison.\n\n        >>> minmax([5, 30], key=str)  # '30' sorts before '5'\n        (30, 5)\n\n    If a *default* value is provided, it will be returned if there are no\n    input items.\n\n        >>> minmax([], default=(0, 0))\n        (0, 0)\n\n    Otherwise ``ValueError`` is raised.\n\n    This function makes a single pass over the input elements and takes care to\n    minimize the number of comparisons made during processing.\n\n    Note that unlike the builtin ``max`` function, which always returns the first\n    item with the maximum value, this function may return another item when there are\n    ties.\n\n    This function is based on the\n    `recipe <https://code.activestate.com/recipes/577916-fast-minmax-function>`__ by\n    Raymond Hettinger.\n    \"\"\"\n    iterable = (iterable_or_value, *others) if others else iterable_or_value\n\n    it = iter(iterable)\n\n    try:\n        lo = hi = next(it)\n    except StopIteration as exc:\n        if default is _marker:\n            raise ValueError(\n                '`minmax()` argument is an empty iterable. '\n                'Provide a `default` value to suppress this error.'\n            ) from exc\n        return default\n\n    # Different branches depending on the presence of key. This saves a lot\n    # of unimportant copies which would slow the \"key=None\" branch\n    # significantly down.\n    if key is None:\n        for x, y in zip_longest(it, it, fillvalue=lo):\n            if y < x:\n                x, y = y, x\n            if x < lo:\n                lo = x\n            if hi < y:\n                hi = y\n\n    else:\n        lo_key = hi_key = key(lo)\n\n        for x, y in zip_longest(it, it, fillvalue=lo):\n            x_key, y_key = key(x), key(y)\n\n            if y_key < x_key:\n                x, y, x_key, y_key = y, x, y_key, x_key\n            if x_key < lo_key:\n                lo, lo_key = x, x_key\n            if hi_key < y_key:\n                hi, hi_key = y, y_key\n\n    return lo, hi",
    "docstring": "Returns both the smallest and largest items from an iterable\nor from two or more arguments.\n\n    >>> minmax([3, 1, 5])\n    (1, 5)\n\n    >>> minmax(4, 2, 6)\n    (2, 6)\n\nIf a *key* function is provided, it will be used to transform the input\nitems for comparison.\n\n    >>> minmax([5, 30], key=str)  # '30' sorts before '5'\n    (30, 5)\n\nIf a *default* value is provided, it will be returned if there are no\ninput items.\n\n    >>> minmax([], default=(0, 0))\n    (0, 0)\n\nOtherwise ``ValueError`` is raised.\n\nThis function makes a single pass over the input elements and takes care to\nminimize the number of comparisons made during processing.\n\nNote that unlike the builtin ``max`` function, which always returns the first\nitem with the maximum value, this function may return another item when there are\nties.\n\nThis function is based on the\n`recipe <https://code.activestate.com/recipes/577916-fast-minmax-function>`__ by\nRaymond Hettinger."
  },
  {
    "function": "constrained_batches",
    "code": "def constrained_batches(\n    iterable, max_size, max_count=None, get_len=len, strict=True\n):\n    \"\"\"Yield batches of items from *iterable* with a combined size limited by\n    *max_size*.\n\n    >>> iterable = [b'12345', b'123', b'12345678', b'1', b'1', b'12', b'1']\n    >>> list(constrained_batches(iterable, 10))\n    [(b'12345', b'123'), (b'12345678', b'1', b'1'), (b'12', b'1')]\n\n    If a *max_count* is supplied, the number of items per batch is also\n    limited:\n\n    >>> iterable = [b'12345', b'123', b'12345678', b'1', b'1', b'12', b'1']\n    >>> list(constrained_batches(iterable, 10, max_count = 2))\n    [(b'12345', b'123'), (b'12345678', b'1'), (b'1', b'12'), (b'1',)]\n\n    If a *get_len* function is supplied, use that instead of :func:`len` to\n    determine item size.\n\n    If *strict* is ``True``, raise ``ValueError`` if any single item is bigger\n    than *max_size*. Otherwise, allow single items to exceed *max_size*.\n    \"\"\"\n    if max_size <= 0:\n        raise ValueError('maximum size must be greater than zero')\n\n    batch = []\n    batch_size = 0\n    batch_count = 0\n    for item in iterable:\n        item_len = get_len(item)\n        if strict and item_len > max_size:\n            raise ValueError('item size exceeds maximum size')\n\n        reached_count = batch_count == max_count\n        reached_size = item_len + batch_size > max_size\n        if batch_count and (reached_size or reached_count):\n            yield tuple(batch)\n            batch.clear()\n            batch_size = 0\n            batch_count = 0\n\n        batch.append(item)\n        batch_size += item_len\n        batch_count += 1\n\n    if batch:\n        yield tuple(batch)",
    "docstring": "Yield batches of items from *iterable* with a combined size limited by\n*max_size*.\n\n>>> iterable = [b'12345', b'123', b'12345678', b'1', b'1', b'12', b'1']\n>>> list(constrained_batches(iterable, 10))\n[(b'12345', b'123'), (b'12345678', b'1', b'1'), (b'12', b'1')]\n\nIf a *max_count* is supplied, the number of items per batch is also\nlimited:\n\n>>> iterable = [b'12345', b'123', b'12345678', b'1', b'1', b'12', b'1']\n>>> list(constrained_batches(iterable, 10, max_count = 2))\n[(b'12345', b'123'), (b'12345678', b'1'), (b'1', b'12'), (b'1',)]\n\nIf a *get_len* function is supplied, use that instead of :func:`len` to\ndetermine item size.\n\nIf *strict* is ``True``, raise ``ValueError`` if any single item is bigger\nthan *max_size*. Otherwise, allow single items to exceed *max_size*."
  },
  {
    "function": "gray_product",
    "code": "def gray_product(*iterables):\n    \"\"\"Like :func:`itertools.product`, but return tuples in an order such\n    that only one element in the generated tuple changes from one iteration\n    to the next.\n\n        >>> list(gray_product('AB','CD'))\n        [('A', 'C'), ('B', 'C'), ('B', 'D'), ('A', 'D')]\n\n    This function consumes all of the input iterables before producing output.\n    If any of the input iterables have fewer than two items, ``ValueError``\n    is raised.\n\n    For information on the algorithm, see\n    `this section <https://www-cs-faculty.stanford.edu/~knuth/fasc2a.ps.gz>`__\n    of Donald Knuth's *The Art of Computer Programming*.\n    \"\"\"\n    all_iterables = tuple(tuple(x) for x in iterables)\n    iterable_count = len(all_iterables)\n    for iterable in all_iterables:\n        if len(iterable) < 2:\n            raise ValueError(\"each iterable must have two or more items\")\n\n    # This is based on \"Algorithm H\" from section 7.2.1.1, page 20.\n    # a holds the indexes of the source iterables for the n-tuple to be yielded\n    # f is the array of \"focus pointers\"\n    # o is the array of \"directions\"\n    a = [0] * iterable_count\n    f = list(range(iterable_count + 1))\n    o = [1] * iterable_count\n    while True:\n        yield tuple(all_iterables[i][a[i]] for i in range(iterable_count))\n        j = f[0]\n        f[0] = 0\n        if j == iterable_count:\n            break\n        a[j] = a[j] + o[j]\n        if a[j] == 0 or a[j] == len(all_iterables[j]) - 1:\n            o[j] = -o[j]\n            f[j] = f[j + 1]\n            f[j + 1] = j + 1",
    "docstring": "Like :func:`itertools.product`, but return tuples in an order such\nthat only one element in the generated tuple changes from one iteration\nto the next.\n\n    >>> list(gray_product('AB','CD'))\n    [('A', 'C'), ('B', 'C'), ('B', 'D'), ('A', 'D')]\n\nThis function consumes all of the input iterables before producing output.\nIf any of the input iterables have fewer than two items, ``ValueError``\nis raised.\n\nFor information on the algorithm, see\n`this section <https://www-cs-faculty.stanford.edu/~knuth/fasc2a.ps.gz>`__\nof Donald Knuth's *The Art of Computer Programming*."
  },
  {
    "function": "partial_product",
    "code": "def partial_product(*iterables):\n    \"\"\"Yields tuples containing one item from each iterator, with subsequent\n    tuples changing a single item at a time by advancing each iterator until it\n    is exhausted. This sequence guarantees every value in each iterable is\n    output at least once without generating all possible combinations.\n\n    This may be useful, for example, when testing an expensive function.\n\n        >>> list(partial_product('AB', 'C', 'DEF'))\n        [('A', 'C', 'D'), ('B', 'C', 'D'), ('B', 'C', 'E'), ('B', 'C', 'F')]\n    \"\"\"\n\n    iterators = list(map(iter, iterables))\n\n    try:\n        prod = [next(it) for it in iterators]\n    except StopIteration:\n        return\n    yield tuple(prod)\n\n    for i, it in enumerate(iterators):\n        for prod[i] in it:\n            yield tuple(prod)",
    "docstring": "Yields tuples containing one item from each iterator, with subsequent\ntuples changing a single item at a time by advancing each iterator until it\nis exhausted. This sequence guarantees every value in each iterable is\noutput at least once without generating all possible combinations.\n\nThis may be useful, for example, when testing an expensive function.\n\n    >>> list(partial_product('AB', 'C', 'DEF'))\n    [('A', 'C', 'D'), ('B', 'C', 'D'), ('B', 'C', 'E'), ('B', 'C', 'F')]"
  },
  {
    "function": "takewhile_inclusive",
    "code": "def takewhile_inclusive(predicate, iterable):\n    \"\"\"A variant of :func:`takewhile` that yields one additional element.\n\n        >>> list(takewhile_inclusive(lambda x: x < 5, [1, 4, 6, 4, 1]))\n        [1, 4, 6]\n\n    :func:`takewhile` would return ``[1, 4]``.\n    \"\"\"\n    for x in iterable:\n        yield x\n        if not predicate(x):\n            break",
    "docstring": "A variant of :func:`takewhile` that yields one additional element.\n\n    >>> list(takewhile_inclusive(lambda x: x < 5, [1, 4, 6, 4, 1]))\n    [1, 4, 6]\n\n:func:`takewhile` would return ``[1, 4]``."
  },
  {
    "function": "outer_product",
    "code": "def outer_product(func, xs, ys, *args, **kwargs):\n    \"\"\"A generalized outer product that applies a binary function to all\n    pairs of items. Returns a 2D matrix with ``len(xs)`` rows and ``len(ys)``\n    columns.\n    Also accepts ``*args`` and ``**kwargs`` that are passed to ``func``.\n\n    Multiplication table:\n\n    >>> list(outer_product(mul, range(1, 4), range(1, 6)))\n    [(1, 2, 3, 4, 5), (2, 4, 6, 8, 10), (3, 6, 9, 12, 15)]\n\n    Cross tabulation:\n\n    >>> xs = ['A', 'B', 'A', 'A', 'B', 'B', 'A', 'A', 'B', 'B']\n    >>> ys = ['X', 'X', 'X', 'Y', 'Z', 'Z', 'Y', 'Y', 'Z', 'Z']\n    >>> pair_counts = Counter(zip(xs, ys))\n    >>> count_rows = lambda x, y: pair_counts[x, y]\n    >>> list(outer_product(count_rows, sorted(set(xs)), sorted(set(ys))))\n    [(2, 3, 0), (1, 0, 4)]\n\n    Usage with ``*args`` and ``**kwargs``:\n\n    >>> animals = ['cat', 'wolf', 'mouse']\n    >>> list(outer_product(min, animals, animals, key=len))\n    [('cat', 'cat', 'cat'), ('cat', 'wolf', 'wolf'), ('cat', 'wolf', 'mouse')]\n    \"\"\"\n    ys = tuple(ys)\n    return batched(\n        starmap(lambda x, y: func(x, y, *args, **kwargs), product(xs, ys)),\n        n=len(ys),\n    )",
    "docstring": "A generalized outer product that applies a binary function to all\npairs of items. Returns a 2D matrix with ``len(xs)`` rows and ``len(ys)``\ncolumns.\nAlso accepts ``*args`` and ``**kwargs`` that are passed to ``func``.\n\nMultiplication table:\n\n>>> list(outer_product(mul, range(1, 4), range(1, 6)))\n[(1, 2, 3, 4, 5), (2, 4, 6, 8, 10), (3, 6, 9, 12, 15)]\n\nCross tabulation:\n\n>>> xs = ['A', 'B', 'A', 'A', 'B', 'B', 'A', 'A', 'B', 'B']\n>>> ys = ['X', 'X', 'X', 'Y', 'Z', 'Z', 'Y', 'Y', 'Z', 'Z']\n>>> pair_counts = Counter(zip(xs, ys))\n>>> count_rows = lambda x, y: pair_counts[x, y]\n>>> list(outer_product(count_rows, sorted(set(xs)), sorted(set(ys))))\n[(2, 3, 0), (1, 0, 4)]\n\nUsage with ``*args`` and ``**kwargs``:\n\n>>> animals = ['cat', 'wolf', 'mouse']\n>>> list(outer_product(min, animals, animals, key=len))\n[('cat', 'cat', 'cat'), ('cat', 'wolf', 'wolf'), ('cat', 'wolf', 'mouse')]"
  },
  {
    "function": "iter_suppress",
    "code": "def iter_suppress(iterable, *exceptions):\n    \"\"\"Yield each of the items from *iterable*. If the iteration raises one of\n    the specified *exceptions*, that exception will be suppressed and iteration\n    will stop.\n\n    >>> from itertools import chain\n    >>> def breaks_at_five(x):\n    ...     while True:\n    ...         if x >= 5:\n    ...             raise RuntimeError\n    ...         yield x\n    ...         x += 1\n    >>> it_1 = iter_suppress(breaks_at_five(1), RuntimeError)\n    >>> it_2 = iter_suppress(breaks_at_five(2), RuntimeError)\n    >>> list(chain(it_1, it_2))\n    [1, 2, 3, 4, 2, 3, 4]\n    \"\"\"\n    try:\n        yield from iterable\n    except exceptions:\n        return",
    "docstring": "Yield each of the items from *iterable*. If the iteration raises one of\nthe specified *exceptions*, that exception will be suppressed and iteration\nwill stop.\n\n>>> from itertools import chain\n>>> def breaks_at_five(x):\n...     while True:\n...         if x >= 5:\n...             raise RuntimeError\n...         yield x\n...         x += 1\n>>> it_1 = iter_suppress(breaks_at_five(1), RuntimeError)\n>>> it_2 = iter_suppress(breaks_at_five(2), RuntimeError)\n>>> list(chain(it_1, it_2))\n[1, 2, 3, 4, 2, 3, 4]"
  },
  {
    "function": "filter_map",
    "code": "def filter_map(func, iterable):\n    \"\"\"Apply *func* to every element of *iterable*, yielding only those which\n    are not ``None``.\n\n    >>> elems = ['1', 'a', '2', 'b', '3']\n    >>> list(filter_map(lambda s: int(s) if s.isnumeric() else None, elems))\n    [1, 2, 3]\n    \"\"\"\n    for x in iterable:\n        y = func(x)\n        if y is not None:\n            yield y",
    "docstring": "Apply *func* to every element of *iterable*, yielding only those which\nare not ``None``.\n\n>>> elems = ['1', 'a', '2', 'b', '3']\n>>> list(filter_map(lambda s: int(s) if s.isnumeric() else None, elems))\n[1, 2, 3]"
  },
  {
    "function": "powerset_of_sets",
    "code": "def powerset_of_sets(iterable, *, baseset=set):\n    \"\"\"Yields all possible subsets of the iterable.\n\n        >>> list(powerset_of_sets([1, 2, 3]))  # doctest: +SKIP\n        [set(), {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}]\n        >>> list(powerset_of_sets([1, 1, 0]))  # doctest: +SKIP\n        [set(), {1}, {0}, {0, 1}]\n\n    :func:`powerset_of_sets` takes care to minimize the number\n    of hash operations performed.\n\n    The *baseset* parameter determines what kind of sets are\n    constructed, either *set* or *frozenset*.\n    \"\"\"\n    sets = tuple(dict.fromkeys(map(frozenset, zip(iterable))))\n    union = baseset().union\n    return chain.from_iterable(\n        starmap(union, combinations(sets, r)) for r in range(len(sets) + 1)\n    )",
    "docstring": "Yields all possible subsets of the iterable.\n\n    >>> list(powerset_of_sets([1, 2, 3]))  # doctest: +SKIP\n    [set(), {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}]\n    >>> list(powerset_of_sets([1, 1, 0]))  # doctest: +SKIP\n    [set(), {1}, {0}, {0, 1}]\n\n:func:`powerset_of_sets` takes care to minimize the number\nof hash operations performed.\n\nThe *baseset* parameter determines what kind of sets are\nconstructed, either *set* or *frozenset*."
  },
  {
    "function": "join_mappings",
    "code": "def join_mappings(**field_to_map):\n    \"\"\"\n    Joins multiple mappings together using their common keys.\n\n    >>> user_scores = {'elliot': 50, 'claris': 60}\n    >>> user_times = {'elliot': 30, 'claris': 40}\n    >>> join_mappings(score=user_scores, time=user_times)\n    {'elliot': {'score': 50, 'time': 30}, 'claris': {'score': 60, 'time': 40}}\n    \"\"\"\n    ret = defaultdict(dict)\n\n    for field_name, mapping in field_to_map.items():\n        for key, value in mapping.items():\n            ret[key][field_name] = value\n\n    return dict(ret)",
    "docstring": "Joins multiple mappings together using their common keys.\n\n>>> user_scores = {'elliot': 50, 'claris': 60}\n>>> user_times = {'elliot': 30, 'claris': 40}\n>>> join_mappings(score=user_scores, time=user_times)\n{'elliot': {'score': 50, 'time': 30}, 'claris': {'score': 60, 'time': 40}}"
  },
  {
    "function": "_complex_sumprod",
    "code": "def _complex_sumprod(v1, v2):\n    \"\"\"High precision sumprod() for complex numbers.\n    Used by :func:`dft` and :func:`idft`.\n    \"\"\"\n\n    real = attrgetter('real')\n    imag = attrgetter('imag')\n    r1 = chain(map(real, v1), map(neg, map(imag, v1)))\n    r2 = chain(map(real, v2), map(imag, v2))\n    i1 = chain(map(real, v1), map(imag, v1))\n    i2 = chain(map(imag, v2), map(real, v2))\n    return complex(_fsumprod(r1, r2), _fsumprod(i1, i2))",
    "docstring": "High precision sumprod() for complex numbers.\nUsed by :func:`dft` and :func:`idft`."
  },
  {
    "function": "dft",
    "code": "def dft(xarr):\n    \"\"\"Discrete Fourier Transform. *xarr* is a sequence of complex numbers.\n    Yields the components of the corresponding transformed output vector.\n\n    >>> import cmath\n    >>> xarr = [1, 2-1j, -1j, -1+2j]  # time domain\n    >>> Xarr = [2, -2-2j, -2j, 4+4j]  # frequency domain\n    >>> magnitudes, phases = zip(*map(cmath.polar, Xarr))\n    >>> all(map(cmath.isclose, dft(xarr), Xarr))\n    True\n\n    Inputs are restricted to numeric types that can add and multiply\n    with a complex number.  This includes int, float, complex, and\n    Fraction, but excludes Decimal.\n\n    See :func:`idft` for the inverse Discrete Fourier Transform.\n    \"\"\"\n    N = len(xarr)\n    roots_of_unity = [e ** (n / N * tau * -1j) for n in range(N)]\n    for k in range(N):\n        coeffs = [roots_of_unity[k * n % N] for n in range(N)]\n        yield _complex_sumprod(xarr, coeffs)",
    "docstring": "Discrete Fourier Transform. *xarr* is a sequence of complex numbers.\nYields the components of the corresponding transformed output vector.\n\n>>> import cmath\n>>> xarr = [1, 2-1j, -1j, -1+2j]  # time domain\n>>> Xarr = [2, -2-2j, -2j, 4+4j]  # frequency domain\n>>> magnitudes, phases = zip(*map(cmath.polar, Xarr))\n>>> all(map(cmath.isclose, dft(xarr), Xarr))\nTrue\n\nInputs are restricted to numeric types that can add and multiply\nwith a complex number.  This includes int, float, complex, and\nFraction, but excludes Decimal.\n\nSee :func:`idft` for the inverse Discrete Fourier Transform."
  },
  {
    "function": "idft",
    "code": "def idft(Xarr):\n    \"\"\"Inverse Discrete Fourier Transform. *Xarr* is a sequence of\n    complex numbers. Yields the components of the corresponding\n    inverse-transformed output vector.\n\n    >>> import cmath\n    >>> xarr = [1, 2-1j, -1j, -1+2j]  # time domain\n    >>> Xarr = [2, -2-2j, -2j, 4+4j]  # frequency domain\n    >>> all(map(cmath.isclose, idft(Xarr), xarr))\n    True\n\n    Inputs are restricted to numeric types that can add and multiply\n    with a complex number.  This includes int, float, complex, and\n    Fraction, but excludes Decimal.\n\n    See :func:`dft` for the Discrete Fourier Transform.\n    \"\"\"\n    N = len(Xarr)\n    roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]\n    for k in range(N):\n        coeffs = [roots_of_unity[k * n % N] for n in range(N)]\n        yield _complex_sumprod(Xarr, coeffs) / N",
    "docstring": "Inverse Discrete Fourier Transform. *Xarr* is a sequence of\ncomplex numbers. Yields the components of the corresponding\ninverse-transformed output vector.\n\n>>> import cmath\n>>> xarr = [1, 2-1j, -1j, -1+2j]  # time domain\n>>> Xarr = [2, -2-2j, -2j, 4+4j]  # frequency domain\n>>> all(map(cmath.isclose, idft(Xarr), xarr))\nTrue\n\nInputs are restricted to numeric types that can add and multiply\nwith a complex number.  This includes int, float, complex, and\nFraction, but excludes Decimal.\n\nSee :func:`dft` for the Discrete Fourier Transform."
  },
  {
    "function": "doublestarmap",
    "code": "def doublestarmap(func, iterable):\n    \"\"\"Apply *func* to every item of *iterable* by dictionary unpacking\n    the item into *func*.\n\n    The difference between :func:`itertools.starmap` and :func:`doublestarmap`\n    parallels the distinction between ``func(*a)`` and ``func(**a)``.\n\n    >>> iterable = [{'a': 1, 'b': 2}, {'a': 40, 'b': 60}]\n    >>> list(doublestarmap(lambda a, b: a + b, iterable))\n    [3, 100]\n\n    ``TypeError`` will be raised if *func*'s signature doesn't match the\n    mapping contained in *iterable* or if *iterable* does not contain mappings.\n    \"\"\"\n    for item in iterable:\n        yield func(**item)",
    "docstring": "Apply *func* to every item of *iterable* by dictionary unpacking\nthe item into *func*.\n\nThe difference between :func:`itertools.starmap` and :func:`doublestarmap`\nparallels the distinction between ``func(*a)`` and ``func(**a)``.\n\n>>> iterable = [{'a': 1, 'b': 2}, {'a': 40, 'b': 60}]\n>>> list(doublestarmap(lambda a, b: a + b, iterable))\n[3, 100]\n\n``TypeError`` will be raised if *func*'s signature doesn't match the\nmapping contained in *iterable* or if *iterable* does not contain mappings."
  },
  {
    "function": "_nth_prime_bounds",
    "code": "def _nth_prime_bounds(n):\n    \"\"\"Bounds for the nth prime (counting from 1): lb < p_n < ub.\"\"\"\n    # At and above 688,383, the lb/ub spread is under 0.003 * p_n.\n\n    if n < 1:\n        raise ValueError\n\n    if n < 6:\n        return (n, 2.25 * n)\n\n    # https://en.wikipedia.org/wiki/Prime-counting_function#Inequalities\n    upper_bound = n * log(n * log(n))\n    lower_bound = upper_bound - n\n    if n >= 688_383:\n        upper_bound -= n * (1.0 - (log(log(n)) - 2.0) / log(n))\n\n    return lower_bound, upper_bound",
    "docstring": "Bounds for the nth prime (counting from 1): lb < p_n < ub."
  },
  {
    "function": "nth_prime",
    "code": "def nth_prime(n, *, approximate=False):\n    \"\"\"Return the nth prime (counting from 0).\n\n    >>> nth_prime(0)\n    2\n    >>> nth_prime(100)\n    547\n\n    If *approximate* is set to True, will return a prime close\n    to the nth prime.  The estimation is much faster than computing\n    an exact result.\n\n    >>> nth_prime(200_000_000, approximate=True)  # Exact result is 4222234763\n    4217820427\n\n    \"\"\"\n    lb, ub = _nth_prime_bounds(n + 1)\n\n    if not approximate or n <= 1_000_000:\n        return nth(sieve(ceil(ub)), n)\n\n    # Search from the midpoint and return the first odd prime\n    odd = floor((lb + ub) / 2) | 1\n    return first_true(count(odd, step=2), pred=is_prime)",
    "docstring": "Return the nth prime (counting from 0).\n\n>>> nth_prime(0)\n2\n>>> nth_prime(100)\n547\n\nIf *approximate* is set to True, will return a prime close\nto the nth prime.  The estimation is much faster than computing\nan exact result.\n\n>>> nth_prime(200_000_000, approximate=True)  # Exact result is 4222234763\n4217820427"
  },
  {
    "function": "argmin",
    "code": "def argmin(iterable, *, key=None):\n    \"\"\"\n    Index of the first occurrence of a minimum value in an iterable.\n\n        >>> argmin('efghabcdijkl')\n        4\n        >>> argmin([3, 2, 1, 0, 4, 2, 1, 0])\n        3\n\n    For example, look up a label corresponding to the position\n    of a value that minimizes a cost function::\n\n        >>> def cost(x):\n        ...     \"Days for a wound to heal given a subject's age.\"\n        ...     return x**2 - 20*x + 150\n        ...\n        >>> labels =  ['homer', 'marge', 'bart', 'lisa', 'maggie']\n        >>> ages =    [  35,      30,      10,      9,      1    ]\n\n        # Fastest healing family member\n        >>> labels[argmin(ages, key=cost)]\n        'bart'\n\n        # Age with fastest healing\n        >>> min(ages, key=cost)\n        10\n\n    \"\"\"\n    if key is not None:\n        iterable = map(key, iterable)\n    return min(enumerate(iterable), key=itemgetter(1))[0]",
    "docstring": "Index of the first occurrence of a minimum value in an iterable.\n\n    >>> argmin('efghabcdijkl')\n    4\n    >>> argmin([3, 2, 1, 0, 4, 2, 1, 0])\n    3\n\nFor example, look up a label corresponding to the position\nof a value that minimizes a cost function::\n\n    >>> def cost(x):\n    ...     \"Days for a wound to heal given a subject's age.\"\n    ...     return x**2 - 20*x + 150\n    ...\n    >>> labels =  ['homer', 'marge', 'bart', 'lisa', 'maggie']\n    >>> ages =    [  35,      30,      10,      9,      1    ]\n\n    # Fastest healing family member\n    >>> labels[argmin(ages, key=cost)]\n    'bart'\n\n    # Age with fastest healing\n    >>> min(ages, key=cost)\n    10"
  },
  {
    "function": "argmax",
    "code": "def argmax(iterable, *, key=None):\n    \"\"\"\n    Index of the first occurrence of a maximum value in an iterable.\n\n        >>> argmax('abcdefghabcd')\n        7\n        >>> argmax([0, 1, 2, 3, 3, 2, 1, 0])\n        3\n\n    For example, identify the best machine learning model::\n\n        >>> models =   ['svm', 'random forest', 'knn', 'na\u00efve bayes']\n        >>> accuracy = [  68,        61,          84,       72      ]\n\n        # Most accurate model\n        >>> models[argmax(accuracy)]\n        'knn'\n\n        # Best accuracy\n        >>> max(accuracy)\n        84\n\n    \"\"\"\n    if key is not None:\n        iterable = map(key, iterable)\n    return max(enumerate(iterable), key=itemgetter(1))[0]",
    "docstring": "Index of the first occurrence of a maximum value in an iterable.\n\n    >>> argmax('abcdefghabcd')\n    7\n    >>> argmax([0, 1, 2, 3, 3, 2, 1, 0])\n    3\n\nFor example, identify the best machine learning model::\n\n    >>> models =   ['svm', 'random forest', 'knn', 'na\u00efve bayes']\n    >>> accuracy = [  68,        61,          84,       72      ]\n\n    # Most accurate model\n    >>> models[argmax(accuracy)]\n    'knn'\n\n    # Best accuracy\n    >>> max(accuracy)\n    84"
  },
  {
    "function": "_extract_monotonic",
    "code": "def _extract_monotonic(iterator, indices):\n    'Non-decreasing indices, lazily consumed'\n    num_read = 0\n    for index in indices:\n        advance = index - num_read\n        try:\n            value = next(islice(iterator, advance, None))\n        except ValueError:\n            if advance != -1 or index < 0:\n                raise ValueError(f'Invalid index: {index}') from None\n        except StopIteration:\n            raise IndexError(index) from None\n        else:\n            num_read += advance + 1\n        yield value",
    "docstring": "Non-decreasing indices, lazily consumed"
  },
  {
    "function": "_extract_buffered",
    "code": "def _extract_buffered(iterator, index_and_position):\n    'Arbitrary index order, greedily consumed'\n    buffer = {}\n    iterator_position = -1\n    next_to_emit = 0\n\n    for index, order in index_and_position:\n        advance = index - iterator_position\n        if advance:\n            try:\n                value = next(islice(iterator, advance - 1, None))\n            except StopIteration:\n                raise IndexError(index) from None\n            iterator_position = index\n\n        buffer[order] = value\n\n        while next_to_emit in buffer:\n            yield buffer.pop(next_to_emit)\n            next_to_emit += 1",
    "docstring": "Arbitrary index order, greedily consumed"
  },
  {
    "function": "extract",
    "code": "def extract(iterable, indices, *, monotonic=False):\n    \"\"\"Yield values at the specified indices.\n\n    Example:\n\n        >>> data = 'abcdefghijklmnopqrstuvwxyz'\n        >>> list(extract(data, [7, 4, 11, 11, 14]))\n        ['h', 'e', 'l', 'l', 'o']\n\n    The *iterable* is consumed lazily and can be infinite.\n\n    When *monotonic* is false, the *indices* are consumed immediately\n    and must be finite. When *monotonic* is true, *indices* are consumed\n    lazily and can be infinite but must be non-decreasing.\n\n    Raises ``IndexError`` if an index lies beyond the iterable.\n    Raises ``ValueError`` for a negative index or for a decreasing\n    index when *monotonic* is true.\n    \"\"\"\n\n    iterator = iter(iterable)\n    indices = iter(indices)\n\n    if monotonic:\n        return _extract_monotonic(iterator, indices)\n\n    index_and_position = sorted(zip(indices, count()))\n    if index_and_position and index_and_position[0][0] < 0:\n        raise ValueError('Indices must be non-negative')\n    return _extract_buffered(iterator, index_and_position)",
    "docstring": "Yield values at the specified indices.\n\nExample:\n\n    >>> data = 'abcdefghijklmnopqrstuvwxyz'\n    >>> list(extract(data, [7, 4, 11, 11, 14]))\n    ['h', 'e', 'l', 'l', 'o']\n\nThe *iterable* is consumed lazily and can be infinite.\n\nWhen *monotonic* is false, the *indices* are consumed immediately\nand must be finite. When *monotonic* is true, *indices* are consumed\nlazily and can be infinite but must be non-decreasing.\n\nRaises ``IndexError`` if an index lies beyond the iterable.\nRaises ``ValueError`` for a negative index or for a decreasing\nindex when *monotonic* is true."
  },
  {
    "function": "synchronized",
    "code": "def synchronized(func):\n    \"\"\"Wrap an iterator-returning callable to make its iterators thread-safe.\n\n    Existing itertools and more-itertools can be wrapped so that their\n    iterator instances are serialized.\n\n    For example, ``itertools.count`` does not make thread-safe instances,\n    but that is easily fixed with::\n\n        atomic_counter = synchronized(itertools.count)\n\n    Can also be used as a decorator for generator functions definitions\n    so that the generator instances are serialized::\n\n        @synchronized\n        def enumerate_and_timestamp(iterable):\n            for count, value in enumerate(iterable):\n                yield count, time_ns(), value\n\n    \"\"\"\n\n    @wraps(func)\n    def inner(*args, **kwargs):\n        iterator = func(*args, **kwargs)\n        return serialize(iterator)\n\n    return inner",
    "docstring": "Wrap an iterator-returning callable to make its iterators thread-safe.\n\nExisting itertools and more-itertools can be wrapped so that their\niterator instances are serialized.\n\nFor example, ``itertools.count`` does not make thread-safe instances,\nbut that is easily fixed with::\n\n    atomic_counter = synchronized(itertools.count)\n\nCan also be used as a decorator for generator functions definitions\nso that the generator instances are serialized::\n\n    @synchronized\n    def enumerate_and_timestamp(iterable):\n        for count, value in enumerate(iterable):\n            yield count, time_ns(), value"
  },
  {
    "function": "concurrent_tee",
    "code": "def concurrent_tee(iterable, n=2):\n    \"\"\"Variant of itertools.tee() but with guaranteed threading semantics.\n\n    Takes a non-threadsafe iterator as an input and creates concurrent\n    tee objects for other threads to have reliable independent copies of\n    the data stream.\n\n    The new iterators are only thread-safe if consumed within a single thread.\n    To share just one of the new iterators across multiple threads, wrap it\n    with :func:`serialize`.\n    \"\"\"\n\n    if n < 0:\n        raise ValueError\n    if n == 0:\n        return ()\n    iterator = _concurrent_tee(iterable)\n    result = [iterator]\n    for _ in range(n - 1):\n        result.append(_concurrent_tee(iterator))\n    return tuple(result)",
    "docstring": "Variant of itertools.tee() but with guaranteed threading semantics.\n\nTakes a non-threadsafe iterator as an input and creates concurrent\ntee objects for other threads to have reliable independent copies of\nthe data stream.\n\nThe new iterators are only thread-safe if consumed within a single thread.\nTo share just one of the new iterators across multiple threads, wrap it\nwith :func:`serialize`."
  },
  {
    "function": "take",
    "code": "def take(n, iterable):\n    \"\"\"Return first *n* items of the *iterable* as a list.\n\n        >>> take(3, range(10))\n        [0, 1, 2]\n\n    If there are fewer than *n* items in the iterable, all of them are\n    returned.\n\n        >>> take(10, range(3))\n        [0, 1, 2]\n\n    \"\"\"\n    return list(islice(iterable, n))",
    "docstring": "Return first *n* items of the *iterable* as a list.\n\n    >>> take(3, range(10))\n    [0, 1, 2]\n\nIf there are fewer than *n* items in the iterable, all of them are\nreturned.\n\n    >>> take(10, range(3))\n    [0, 1, 2]"
  },
  {
    "function": "tabulate",
    "code": "def tabulate(function, start=0):\n    \"\"\"Return an iterator over the results of ``func(start)``,\n    ``func(start + 1)``, ``func(start + 2)``...\n\n    *func* should be a function that accepts one integer argument.\n\n    If *start* is not specified it defaults to 0. It will be incremented each\n    time the iterator is advanced.\n\n        >>> square = lambda x: x ** 2\n        >>> iterator = tabulate(square, -3)\n        >>> take(4, iterator)\n        [9, 4, 1, 0]\n\n    \"\"\"\n    return map(function, count(start))",
    "docstring": "Return an iterator over the results of ``func(start)``,\n``func(start + 1)``, ``func(start + 2)``...\n\n*func* should be a function that accepts one integer argument.\n\nIf *start* is not specified it defaults to 0. It will be incremented each\ntime the iterator is advanced.\n\n    >>> square = lambda x: x ** 2\n    >>> iterator = tabulate(square, -3)\n    >>> take(4, iterator)\n    [9, 4, 1, 0]"
  },
  {
    "function": "tail",
    "code": "def tail(n, iterable):\n    \"\"\"Return an iterator over the last *n* items of *iterable*.\n\n    >>> t = tail(3, 'ABCDEFG')\n    >>> list(t)\n    ['E', 'F', 'G']\n\n    \"\"\"\n    try:\n        size = len(iterable)\n    except TypeError:\n        return iter(deque(iterable, maxlen=n))\n    else:\n        return islice(iterable, max(0, size - n), None)",
    "docstring": "Return an iterator over the last *n* items of *iterable*.\n\n>>> t = tail(3, 'ABCDEFG')\n>>> list(t)\n['E', 'F', 'G']"
  },
  {
    "function": "consume",
    "code": "def consume(iterator, n=None):\n    \"\"\"Advance *iterable* by *n* steps. If *n* is ``None``, consume it\n    entirely.\n\n    Efficiently exhausts an iterator without returning values. Defaults to\n    consuming the whole iterator, but an optional second argument may be\n    provided to limit consumption.\n\n        >>> i = (x for x in range(10))\n        >>> next(i)\n        0\n        >>> consume(i, 3)\n        >>> next(i)\n        4\n        >>> consume(i)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    If the iterator has fewer items remaining than the provided limit, the\n    whole iterator will be consumed.\n\n        >>> i = (x for x in range(3))\n        >>> consume(i, 5)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    \"\"\"\n    # Use functions that consume iterators at C speed.\n    if n is None:\n        # feed the entire iterator into a zero-length deque\n        deque(iterator, maxlen=0)\n    else:\n        # advance to the empty slice starting at position n\n        next(islice(iterator, n, n), None)",
    "docstring": "Advance *iterable* by *n* steps. If *n* is ``None``, consume it\nentirely.\n\nEfficiently exhausts an iterator without returning values. Defaults to\nconsuming the whole iterator, but an optional second argument may be\nprovided to limit consumption.\n\n    >>> i = (x for x in range(10))\n    >>> next(i)\n    0\n    >>> consume(i, 3)\n    >>> next(i)\n    4\n    >>> consume(i)\n    >>> next(i)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    StopIteration\n\nIf the iterator has fewer items remaining than the provided limit, the\nwhole iterator will be consumed.\n\n    >>> i = (x for x in range(3))\n    >>> consume(i, 5)\n    >>> next(i)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    StopIteration"
  },
  {
    "function": "nth",
    "code": "def nth(iterable, n, default=None):\n    \"\"\"Returns the nth item or a default value.\n\n    >>> l = range(10)\n    >>> nth(l, 3)\n    3\n    >>> nth(l, 20, \"zebra\")\n    'zebra'\n\n    \"\"\"\n    return next(islice(iterable, n, None), default)",
    "docstring": "Returns the nth item or a default value.\n\n>>> l = range(10)\n>>> nth(l, 3)\n3\n>>> nth(l, 20, \"zebra\")\n'zebra'"
  },
  {
    "function": "all_equal",
    "code": "def all_equal(iterable, key=None):\n    \"\"\"\n    Returns ``True`` if all the elements are equal to each other.\n\n        >>> all_equal('aaaa')\n        True\n        >>> all_equal('aaab')\n        False\n\n    A function that accepts a single argument and returns a transformed version\n    of each input item can be specified with *key*:\n\n        >>> all_equal('AaaA', key=str.casefold)\n        True\n        >>> all_equal([1, 2, 3], key=lambda x: x < 10)\n        True\n\n    \"\"\"\n    iterator = groupby(iterable, key)\n    for first in iterator:\n        for second in iterator:\n            return False\n        return True\n    return True",
    "docstring": "Returns ``True`` if all the elements are equal to each other.\n\n    >>> all_equal('aaaa')\n    True\n    >>> all_equal('aaab')\n    False\n\nA function that accepts a single argument and returns a transformed version\nof each input item can be specified with *key*:\n\n    >>> all_equal('AaaA', key=str.casefold)\n    True\n    >>> all_equal([1, 2, 3], key=lambda x: x < 10)\n    True"
  },
  {
    "function": "quantify",
    "code": "def quantify(iterable, pred=bool):\n    \"\"\"Return the how many times the predicate is true.\n\n    >>> quantify([True, False, True])\n    2\n\n    \"\"\"\n    return sum(map(pred, iterable))",
    "docstring": "Return the how many times the predicate is true.\n\n>>> quantify([True, False, True])\n2"
  },
  {
    "function": "pad_none",
    "code": "def pad_none(iterable):\n    \"\"\"Returns the sequence of elements and then returns ``None`` indefinitely.\n\n        >>> take(5, pad_none(range(3)))\n        [0, 1, 2, None, None]\n\n    Useful for emulating the behavior of the built-in :func:`map` function.\n\n    See also :func:`padded`.\n\n    \"\"\"\n    return chain(iterable, repeat(None))",
    "docstring": "Returns the sequence of elements and then returns ``None`` indefinitely.\n\n    >>> take(5, pad_none(range(3)))\n    [0, 1, 2, None, None]\n\nUseful for emulating the behavior of the built-in :func:`map` function.\n\nSee also :func:`padded`."
  },
  {
    "function": "ncycles",
    "code": "def ncycles(iterable, n):\n    \"\"\"Returns the sequence elements *n* times\n\n    >>> list(ncycles([\"a\", \"b\"], 3))\n    ['a', 'b', 'a', 'b', 'a', 'b']\n\n    \"\"\"\n    return chain.from_iterable(repeat(tuple(iterable), n))",
    "docstring": "Returns the sequence elements *n* times\n\n>>> list(ncycles([\"a\", \"b\"], 3))\n['a', 'b', 'a', 'b', 'a', 'b']"
  },
  {
    "function": "dotproduct",
    "code": "def dotproduct(vec1, vec2):\n    \"\"\"Returns the dot product of the two iterables.\n\n    >>> dotproduct([10, 15, 12], [0.65, 0.80, 1.25])\n    33.5\n    >>> 10 * 0.65 + 15 * 0.80 + 12 * 1.25\n    33.5\n\n    In Python 3.12 and later, use ``math.sumprod()`` instead.\n    \"\"\"\n    return sum(map(mul, vec1, vec2))",
    "docstring": "Returns the dot product of the two iterables.\n\n>>> dotproduct([10, 15, 12], [0.65, 0.80, 1.25])\n33.5\n>>> 10 * 0.65 + 15 * 0.80 + 12 * 1.25\n33.5\n\nIn Python 3.12 and later, use ``math.sumprod()`` instead."
  },
  {
    "function": "flatten",
    "code": "def flatten(listOfLists):\n    \"\"\"Return an iterator flattening one level of nesting in a list of lists.\n\n        >>> list(flatten([[0, 1], [2, 3]]))\n        [0, 1, 2, 3]\n\n    See also :func:`collapse`, which can flatten multiple levels of nesting.\n\n    \"\"\"\n    return chain.from_iterable(listOfLists)",
    "docstring": "Return an iterator flattening one level of nesting in a list of lists.\n\n    >>> list(flatten([[0, 1], [2, 3]]))\n    [0, 1, 2, 3]\n\nSee also :func:`collapse`, which can flatten multiple levels of nesting."
  },
  {
    "function": "repeatfunc",
    "code": "def repeatfunc(func, times=None, *args):\n    \"\"\"Call *func* with *args* repeatedly, returning an iterable over the\n    results.\n\n    If *times* is specified, the iterable will terminate after that many\n    repetitions:\n\n        >>> from operator import add\n        >>> times = 4\n        >>> args = 3, 5\n        >>> list(repeatfunc(add, times, *args))\n        [8, 8, 8, 8]\n\n    If *times* is ``None`` the iterable will not terminate:\n\n        >>> from random import randrange\n        >>> times = None\n        >>> args = 1, 11\n        >>> take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP\n        [2, 4, 8, 1, 8, 4]\n\n    \"\"\"\n    if times is None:\n        return starmap(func, repeat(args))\n    return starmap(func, repeat(args, times))",
    "docstring": "Call *func* with *args* repeatedly, returning an iterable over the\nresults.\n\nIf *times* is specified, the iterable will terminate after that many\nrepetitions:\n\n    >>> from operator import add\n    >>> times = 4\n    >>> args = 3, 5\n    >>> list(repeatfunc(add, times, *args))\n    [8, 8, 8, 8]\n\nIf *times* is ``None`` the iterable will not terminate:\n\n    >>> from random import randrange\n    >>> times = None\n    >>> args = 1, 11\n    >>> take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP\n    [2, 4, 8, 1, 8, 4]"
  },
  {
    "function": "grouper",
    "code": "def grouper(iterable, n, incomplete='fill', fillvalue=None):\n    \"\"\"Group elements from *iterable* into fixed-length groups of length *n*.\n\n    >>> list(grouper('ABCDEF', 3))\n    [('A', 'B', 'C'), ('D', 'E', 'F')]\n\n    The keyword arguments *incomplete* and *fillvalue* control what happens for\n    iterables whose length is not a multiple of *n*.\n\n    When *incomplete* is `'fill'`, the last group will contain instances of\n    *fillvalue*.\n\n    >>> list(grouper('ABCDEFG', 3, incomplete='fill', fillvalue='x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')]\n\n    When *incomplete* is `'ignore'`, the last group will not be emitted.\n\n    >>> list(grouper('ABCDEFG', 3, incomplete='ignore', fillvalue='x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F')]\n\n    When *incomplete* is `'strict'`, a `ValueError` will be raised.\n\n    >>> iterator = grouper('ABCDEFG', 3, incomplete='strict')\n    >>> list(iterator)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError\n\n    \"\"\"\n    iterators = [iter(iterable)] * n\n    match incomplete:\n        case 'fill':\n            return zip_longest(*iterators, fillvalue=fillvalue)\n        case 'strict':\n            return zip(*iterators, strict=True)\n        case 'ignore':\n            return zip(*iterators)\n        case _:\n            raise ValueError('Expected fill, strict, or ignore')",
    "docstring": "Group elements from *iterable* into fixed-length groups of length *n*.\n\n>>> list(grouper('ABCDEF', 3))\n[('A', 'B', 'C'), ('D', 'E', 'F')]\n\nThe keyword arguments *incomplete* and *fillvalue* control what happens for\niterables whose length is not a multiple of *n*.\n\nWhen *incomplete* is `'fill'`, the last group will contain instances of\n*fillvalue*.\n\n>>> list(grouper('ABCDEFG', 3, incomplete='fill', fillvalue='x'))\n[('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')]\n\nWhen *incomplete* is `'ignore'`, the last group will not be emitted.\n\n>>> list(grouper('ABCDEFG', 3, incomplete='ignore', fillvalue='x'))\n[('A', 'B', 'C'), ('D', 'E', 'F')]\n\nWhen *incomplete* is `'strict'`, a `ValueError` will be raised.\n\n>>> iterator = grouper('ABCDEFG', 3, incomplete='strict')\n>>> list(iterator)  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nValueError"
  },
  {
    "function": "roundrobin",
    "code": "def roundrobin(*iterables):\n    \"\"\"Visit input iterables in a cycle until each is exhausted.\n\n        >>> list(roundrobin('ABC', 'D', 'EF'))\n        ['A', 'D', 'E', 'B', 'F', 'C']\n\n    This function produces the same output as :func:`interleave_longest`, but\n    may perform better for some inputs (in particular when the number of\n    iterables is small).\n\n    \"\"\"\n    # Algorithm credited to George Sakkis\n    iterators = map(iter, iterables)\n    for num_active in range(len(iterables), 0, -1):\n        iterators = cycle(islice(iterators, num_active))\n        yield from map(next, iterators)",
    "docstring": "Visit input iterables in a cycle until each is exhausted.\n\n    >>> list(roundrobin('ABC', 'D', 'EF'))\n    ['A', 'D', 'E', 'B', 'F', 'C']\n\nThis function produces the same output as :func:`interleave_longest`, but\nmay perform better for some inputs (in particular when the number of\niterables is small)."
  },
  {
    "function": "partition",
    "code": "def partition(pred, iterable):\n    \"\"\"\n    Returns a 2-tuple of iterables derived from the input iterable.\n    The first yields the items that have ``pred(item) == False``.\n    The second yields the items that have ``pred(item) == True``.\n\n        >>> is_odd = lambda x: x % 2 != 0\n        >>> iterable = range(10)\n        >>> even_items, odd_items = partition(is_odd, iterable)\n        >>> list(even_items), list(odd_items)\n        ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9])\n\n    If *pred* is None, :func:`bool` is used.\n\n        >>> iterable = [0, 1, False, True, '', ' ']\n        >>> false_items, true_items = partition(None, iterable)\n        >>> list(false_items), list(true_items)\n        ([0, False, ''], [1, True, ' '])\n\n    \"\"\"\n    if pred is None:\n        pred = bool\n\n    t1, t2, p = tee(iterable, 3)\n    p1, p2 = tee(map(pred, p))\n    return (compress(t1, map(not_, p1)), compress(t2, p2))",
    "docstring": "Returns a 2-tuple of iterables derived from the input iterable.\nThe first yields the items that have ``pred(item) == False``.\nThe second yields the items that have ``pred(item) == True``.\n\n    >>> is_odd = lambda x: x % 2 != 0\n    >>> iterable = range(10)\n    >>> even_items, odd_items = partition(is_odd, iterable)\n    >>> list(even_items), list(odd_items)\n    ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9])\n\nIf *pred* is None, :func:`bool` is used.\n\n    >>> iterable = [0, 1, False, True, '', ' ']\n    >>> false_items, true_items = partition(None, iterable)\n    >>> list(false_items), list(true_items)\n    ([0, False, ''], [1, True, ' '])"
  },
  {
    "function": "powerset",
    "code": "def powerset(iterable):\n    \"\"\"Yields all possible subsets of the iterable.\n\n        >>> list(powerset([1, 2, 3]))\n        [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]\n\n    :func:`powerset` will operate on iterables that aren't :class:`set`\n    instances, so repeated elements in the input will produce repeated elements\n    in the output.\n\n        >>> seq = [1, 1, 0]\n        >>> list(powerset(seq))\n        [(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)]\n\n    For a variant that efficiently yields actual :class:`set` instances, see\n    :func:`powerset_of_sets`.\n    \"\"\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))",
    "docstring": "Yields all possible subsets of the iterable.\n\n    >>> list(powerset([1, 2, 3]))\n    [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]\n\n:func:`powerset` will operate on iterables that aren't :class:`set`\ninstances, so repeated elements in the input will produce repeated elements\nin the output.\n\n    >>> seq = [1, 1, 0]\n    >>> list(powerset(seq))\n    [(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)]\n\nFor a variant that efficiently yields actual :class:`set` instances, see\n:func:`powerset_of_sets`."
  },
  {
    "function": "unique_everseen",
    "code": "def unique_everseen(iterable, key=None):\n    \"\"\"\n    Yield unique elements, preserving order.\n\n        >>> list(unique_everseen('AAAABBBCCDAABBB'))\n        ['A', 'B', 'C', 'D']\n        >>> list(unique_everseen('ABBCcAD', str.lower))\n        ['A', 'B', 'C', 'D']\n\n    Sequences with a mix of hashable and unhashable items can be used.\n    The function will be slower (i.e., `O(n^2)`) for unhashable items.\n\n    Remember that ``list`` objects are unhashable - you can use the *key*\n    parameter to transform the list to a tuple (which is hashable) to\n    avoid a slowdown.\n\n        >>> iterable = ([1, 2], [2, 3], [1, 2])\n        >>> list(unique_everseen(iterable))  # Slow\n        [[1, 2], [2, 3]]\n        >>> list(unique_everseen(iterable, key=tuple))  # Faster\n        [[1, 2], [2, 3]]\n\n    Similarly, you may want to convert unhashable ``set`` objects with\n    ``key=frozenset``. For ``dict`` objects,\n    ``key=lambda x: frozenset(x.items())`` can be used.\n\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seenset:\n                seenset_add(k)\n                yield element\n        except TypeError:\n            if k not in seenlist:\n                seenlist_add(k)\n                yield element",
    "docstring": "Yield unique elements, preserving order.\n\n    >>> list(unique_everseen('AAAABBBCCDAABBB'))\n    ['A', 'B', 'C', 'D']\n    >>> list(unique_everseen('ABBCcAD', str.lower))\n    ['A', 'B', 'C', 'D']\n\nSequences with a mix of hashable and unhashable items can be used.\nThe function will be slower (i.e., `O(n^2)`) for unhashable items.\n\nRemember that ``list`` objects are unhashable - you can use the *key*\nparameter to transform the list to a tuple (which is hashable) to\navoid a slowdown.\n\n    >>> iterable = ([1, 2], [2, 3], [1, 2])\n    >>> list(unique_everseen(iterable))  # Slow\n    [[1, 2], [2, 3]]\n    >>> list(unique_everseen(iterable, key=tuple))  # Faster\n    [[1, 2], [2, 3]]\n\nSimilarly, you may want to convert unhashable ``set`` objects with\n``key=frozenset``. For ``dict`` objects,\n``key=lambda x: frozenset(x.items())`` can be used."
  },
  {
    "function": "unique_justseen",
    "code": "def unique_justseen(iterable, key=None):\n    \"\"\"Yields elements in order, ignoring serial duplicates\n\n    >>> list(unique_justseen('AAAABBBCCDAABBB'))\n    ['A', 'B', 'C', 'D', 'A', 'B']\n    >>> list(unique_justseen('ABBCcAD', str.lower))\n    ['A', 'B', 'C', 'A', 'D']\n\n    \"\"\"\n    if key is None:\n        return map(itemgetter(0), groupby(iterable))\n\n    return map(next, map(itemgetter(1), groupby(iterable, key)))",
    "docstring": "Yields elements in order, ignoring serial duplicates\n\n>>> list(unique_justseen('AAAABBBCCDAABBB'))\n['A', 'B', 'C', 'D', 'A', 'B']\n>>> list(unique_justseen('ABBCcAD', str.lower))\n['A', 'B', 'C', 'A', 'D']"
  },
  {
    "function": "unique",
    "code": "def unique(iterable, key=None, reverse=False):\n    \"\"\"Yields unique elements in sorted order.\n\n    >>> list(unique([[1, 2], [3, 4], [1, 2]]))\n    [[1, 2], [3, 4]]\n\n    *key* and *reverse* are passed to :func:`sorted`.\n\n    >>> list(unique('ABBcCAD', str.casefold))\n    ['A', 'B', 'c', 'D']\n    >>> list(unique('ABBcCAD', str.casefold, reverse=True))\n    ['D', 'c', 'B', 'A']\n\n    The elements in *iterable* need not be hashable, but they must be\n    comparable for sorting to work.\n    \"\"\"\n    sequenced = sorted(iterable, key=key, reverse=reverse)\n    return unique_justseen(sequenced, key=key)",
    "docstring": "Yields unique elements in sorted order.\n\n>>> list(unique([[1, 2], [3, 4], [1, 2]]))\n[[1, 2], [3, 4]]\n\n*key* and *reverse* are passed to :func:`sorted`.\n\n>>> list(unique('ABBcCAD', str.casefold))\n['A', 'B', 'c', 'D']\n>>> list(unique('ABBcCAD', str.casefold, reverse=True))\n['D', 'c', 'B', 'A']\n\nThe elements in *iterable* need not be hashable, but they must be\ncomparable for sorting to work."
  },
  {
    "function": "iter_except",
    "code": "def iter_except(func, exception, first=None):\n    \"\"\"Yields results from a function repeatedly until an exception is raised.\n\n    Converts a call-until-exception interface to an iterator interface.\n    Like ``iter(func, sentinel)``, but uses an exception instead of a sentinel\n    to end the loop.\n\n        >>> l = [0, 1, 2]\n        >>> list(iter_except(l.pop, IndexError))\n        [2, 1, 0]\n\n    Multiple exceptions can be specified as a stopping condition:\n\n        >>> l = [1, 2, 3, '...', 4, 5, 6]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        [7, 6, 5]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        [4, 3, 2]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        []\n\n    \"\"\"\n    with suppress(exception):\n        if first is not None:\n            yield first()\n        while True:\n            yield func()",
    "docstring": "Yields results from a function repeatedly until an exception is raised.\n\nConverts a call-until-exception interface to an iterator interface.\nLike ``iter(func, sentinel)``, but uses an exception instead of a sentinel\nto end the loop.\n\n    >>> l = [0, 1, 2]\n    >>> list(iter_except(l.pop, IndexError))\n    [2, 1, 0]\n\nMultiple exceptions can be specified as a stopping condition:\n\n    >>> l = [1, 2, 3, '...', 4, 5, 6]\n    >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n    [7, 6, 5]\n    >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n    [4, 3, 2]\n    >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n    []"
  },
  {
    "function": "first_true",
    "code": "def first_true(iterable, default=None, pred=None):\n    \"\"\"\n    Returns the first true value in the iterable.\n\n    If no true value is found, returns *default*\n\n    If *pred* is not None, returns the first item for which\n    ``pred(item) == True`` .\n\n        >>> first_true(range(10))\n        1\n        >>> first_true(range(10), pred=lambda x: x > 5)\n        6\n        >>> first_true(range(10), default='missing', pred=lambda x: x > 9)\n        'missing'\n\n    \"\"\"\n    return next(filter(pred, iterable), default)",
    "docstring": "Returns the first true value in the iterable.\n\nIf no true value is found, returns *default*\n\nIf *pred* is not None, returns the first item for which\n``pred(item) == True`` .\n\n    >>> first_true(range(10))\n    1\n    >>> first_true(range(10), pred=lambda x: x > 5)\n    6\n    >>> first_true(range(10), default='missing', pred=lambda x: x > 9)\n    'missing'"
  },
  {
    "function": "random_product",
    "code": "def random_product(*args, repeat=1):\n    \"\"\"Draw an item at random from each of the input iterables.\n\n        >>> random_product('abc', range(4), 'XYZ')  # doctest:+SKIP\n        ('c', 3, 'Z')\n\n    If *repeat* is provided as a keyword argument, that many items will be\n    drawn from each iterable.\n\n        >>> random_product('abcd', range(4), repeat=2)  # doctest:+SKIP\n        ('a', 2, 'd', 3)\n\n    This equivalent to taking a random selection from\n    ``itertools.product(*args, repeat=repeat)``.\n\n    \"\"\"\n    pools = list(map(tuple, args)) * repeat\n    return tuple(map(choice, pools))",
    "docstring": "Draw an item at random from each of the input iterables.\n\n    >>> random_product('abc', range(4), 'XYZ')  # doctest:+SKIP\n    ('c', 3, 'Z')\n\nIf *repeat* is provided as a keyword argument, that many items will be\ndrawn from each iterable.\n\n    >>> random_product('abcd', range(4), repeat=2)  # doctest:+SKIP\n    ('a', 2, 'd', 3)\n\nThis equivalent to taking a random selection from\n``itertools.product(*args, repeat=repeat)``."
  },
  {
    "function": "random_permutation",
    "code": "def random_permutation(iterable, r=None):\n    \"\"\"Return a random *r* length permutation of the elements in *iterable*.\n\n    If *r* is not specified or is ``None``, then *r* defaults to the length of\n    *iterable*.\n\n        >>> random_permutation(range(5))  # doctest:+SKIP\n        (3, 4, 0, 1, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.permutations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    r = len(pool) if r is None else r\n    return tuple(sample(pool, r))",
    "docstring": "Return a random *r* length permutation of the elements in *iterable*.\n\nIf *r* is not specified or is ``None``, then *r* defaults to the length of\n*iterable*.\n\n    >>> random_permutation(range(5))  # doctest:+SKIP\n    (3, 4, 0, 1, 2)\n\nThis equivalent to taking a random selection from\n``itertools.permutations(iterable, r)``."
  },
  {
    "function": "random_combination",
    "code": "def random_combination(iterable, r):\n    \"\"\"Return a random *r* length subsequence of the elements in *iterable*.\n\n        >>> random_combination(range(5), 3)  # doctest:+SKIP\n        (2, 3, 4)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(sample(range(n), r))\n    return tuple([pool[i] for i in indices])",
    "docstring": "Return a random *r* length subsequence of the elements in *iterable*.\n\n    >>> random_combination(range(5), 3)  # doctest:+SKIP\n    (2, 3, 4)\n\nThis equivalent to taking a random selection from\n``itertools.combinations(iterable, r)``."
  },
  {
    "function": "random_combination_with_replacement",
    "code": "def random_combination_with_replacement(iterable, r):\n    \"\"\"Return a random *r* length subsequence of elements in *iterable*,\n    allowing individual elements to be repeated.\n\n        >>> random_combination_with_replacement(range(3), 5) # doctest:+SKIP\n        (0, 0, 1, 2, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations_with_replacement(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(randrange(n) for i in range(r))\n    return tuple([pool[i] for i in indices])",
    "docstring": "Return a random *r* length subsequence of elements in *iterable*,\nallowing individual elements to be repeated.\n\n    >>> random_combination_with_replacement(range(3), 5) # doctest:+SKIP\n    (0, 0, 1, 2, 2)\n\nThis equivalent to taking a random selection from\n``itertools.combinations_with_replacement(iterable, r)``."
  },
  {
    "function": "nth_combination",
    "code": "def nth_combination(iterable, r, index):\n    \"\"\"Equivalent to ``list(combinations(iterable, r))[index]``.\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`nth_combination` computes the subsequence at\n    sort position *index* directly, without computing the previous\n    subsequences.\n\n        >>> nth_combination(range(5), 3, 5)\n        (0, 3, 4)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = 1\n    k = min(r, n - r)\n    for i in range(1, k + 1):\n        c = c * (n - k + i) // i\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    while r:\n        c, n, r = c * r // n, n - 1, r - 1\n        while index >= c:\n            index -= c\n            c, n = c * (n - r) // n, n - 1\n        result.append(pool[-1 - n])\n\n    return tuple(result)",
    "docstring": "Equivalent to ``list(combinations(iterable, r))[index]``.\n\nThe subsequences of *iterable* that are of length *r* can be ordered\nlexicographically. :func:`nth_combination` computes the subsequence at\nsort position *index* directly, without computing the previous\nsubsequences.\n\n    >>> nth_combination(range(5), 3, 5)\n    (0, 3, 4)\n\n``ValueError`` will be raised If *r* is negative or greater than the length\nof *iterable*.\n``IndexError`` will be raised if the given *index* is invalid."
  },
  {
    "function": "prepend",
    "code": "def prepend(value, iterator):\n    \"\"\"Yield *value*, followed by the elements in *iterator*.\n\n        >>> value = '0'\n        >>> iterator = ['1', '2', '3']\n        >>> list(prepend(value, iterator))\n        ['0', '1', '2', '3']\n\n    To prepend multiple values, see :func:`itertools.chain`\n    or :func:`value_chain`.\n\n    \"\"\"\n    return chain([value], iterator)",
    "docstring": "Yield *value*, followed by the elements in *iterator*.\n\n    >>> value = '0'\n    >>> iterator = ['1', '2', '3']\n    >>> list(prepend(value, iterator))\n    ['0', '1', '2', '3']\n\nTo prepend multiple values, see :func:`itertools.chain`\nor :func:`value_chain`."
  },
  {
    "function": "convolve",
    "code": "def convolve(signal, kernel):\n    \"\"\"Discrete linear convolution of two iterables.\n    Equivalent to polynomial multiplication.\n\n    For example, multiplying ``(x\u00b2 -x - 20)`` by ``(x - 3)``\n    gives ``(x\u00b3 -4x\u00b2 -17x + 60)``.\n\n        >>> list(convolve([1, -1, -20], [1, -3]))\n        [1, -4, -17, 60]\n\n    Examples of popular kinds of kernels:\n\n    * The kernel ``[0.25, 0.25, 0.25, 0.25]`` computes a moving average.\n      For image data, this blurs the image and reduces noise.\n    * The kernel ``[1/2, 0, -1/2]`` estimates the first derivative of\n      a function evaluated at evenly spaced inputs.\n    * The kernel ``[1, -2, 1]`` estimates the second derivative of a\n      function evaluated at evenly spaced inputs.\n\n    Convolutions are mathematically commutative; however, the inputs are\n    evaluated differently.  The signal is consumed lazily and can be\n    infinite. The kernel is fully consumed before the calculations begin.\n\n    Supports all numeric types: int, float, complex, Decimal, Fraction.\n\n    References:\n\n    * Article:  https://betterexplained.com/articles/intuitive-convolution/\n    * Video by 3Blue1Brown:  https://www.youtube.com/watch?v=KuXjwB4LzSA\n\n    \"\"\"\n    # This implementation comes from an older version of the itertools\n    # documentation.  While the newer implementation is a bit clearer,\n    # this one was kept because the inlined window logic is faster\n    # and it avoids an unnecessary deque-to-tuple conversion.\n    kernel = tuple(kernel)[::-1]\n    n = len(kernel)\n    window = deque([0], maxlen=n) * n\n    for x in chain(signal, repeat(0, n - 1)):\n        window.append(x)\n        yield _sumprod(kernel, window)",
    "docstring": "Discrete linear convolution of two iterables.\nEquivalent to polynomial multiplication.\n\nFor example, multiplying ``(x\u00b2 -x - 20)`` by ``(x - 3)``\ngives ``(x\u00b3 -4x\u00b2 -17x + 60)``.\n\n    >>> list(convolve([1, -1, -20], [1, -3]))\n    [1, -4, -17, 60]\n\nExamples of popular kinds of kernels:\n\n* The kernel ``[0.25, 0.25, 0.25, 0.25]`` computes a moving average.\n  For image data, this blurs the image and reduces noise.\n* The kernel ``[1/2, 0, -1/2]`` estimates the first derivative of\n  a function evaluated at evenly spaced inputs.\n* The kernel ``[1, -2, 1]`` estimates the second derivative of a\n  function evaluated at evenly spaced inputs.\n\nConvolutions are mathematically commutative; however, the inputs are\nevaluated differently.  The signal is consumed lazily and can be\ninfinite. The kernel is fully consumed before the calculations begin.\n\nSupports all numeric types: int, float, complex, Decimal, Fraction.\n\nReferences:\n\n* Article:  https://betterexplained.com/articles/intuitive-convolution/\n* Video by 3Blue1Brown:  https://www.youtube.com/watch?v=KuXjwB4LzSA"
  },
  {
    "function": "before_and_after",
    "code": "def before_and_after(predicate, it):\n    \"\"\"A variant of :func:`takewhile` that allows complete access to the\n    remainder of the iterator.\n\n         >>> it = iter('ABCdEfGhI')\n         >>> all_upper, remainder = before_and_after(str.isupper, it)\n         >>> ''.join(all_upper)\n         'ABC'\n         >>> ''.join(remainder) # takewhile() would lose the 'd'\n         'dEfGhI'\n\n    Note that the first iterator must be fully consumed before the second\n    iterator can generate valid results.\n    \"\"\"\n    trues, after = tee(it)\n    trues = compress(takewhile(predicate, trues), zip(after))\n    return trues, after",
    "docstring": "A variant of :func:`takewhile` that allows complete access to the\nremainder of the iterator.\n\n     >>> it = iter('ABCdEfGhI')\n     >>> all_upper, remainder = before_and_after(str.isupper, it)\n     >>> ''.join(all_upper)\n     'ABC'\n     >>> ''.join(remainder) # takewhile() would lose the 'd'\n     'dEfGhI'\n\nNote that the first iterator must be fully consumed before the second\niterator can generate valid results."
  },
  {
    "function": "triplewise",
    "code": "def triplewise(iterable):\n    \"\"\"Return overlapping triplets from *iterable*.\n\n    >>> list(triplewise('ABCDE'))\n    [('A', 'B', 'C'), ('B', 'C', 'D'), ('C', 'D', 'E')]\n\n    \"\"\"\n    # This deviates from the itertools documentation recipe - see\n    # https://github.com/more-itertools/more-itertools/issues/889\n    t1, t2, t3 = tee(iterable, 3)\n    next(t3, None)\n    next(t3, None)\n    next(t2, None)\n    return zip(t1, t2, t3)",
    "docstring": "Return overlapping triplets from *iterable*.\n\n>>> list(triplewise('ABCDE'))\n[('A', 'B', 'C'), ('B', 'C', 'D'), ('C', 'D', 'E')]"
  },
  {
    "function": "sliding_window",
    "code": "def sliding_window(iterable, n):\n    \"\"\"Return a sliding window of width *n* over *iterable*.\n\n        >>> list(sliding_window(range(6), 4))\n        [(0, 1, 2, 3), (1, 2, 3, 4), (2, 3, 4, 5)]\n\n    If *iterable* has fewer than *n* items, then nothing is yielded:\n\n        >>> list(sliding_window(range(3), 4))\n        []\n\n    For a variant with more features, see :func:`windowed`.\n    \"\"\"\n    if n > 20:\n        return _sliding_window_deque(iterable, n)\n    elif n > 2:\n        return _sliding_window_islice(iterable, n)\n    elif n == 2:\n        return pairwise(iterable)\n    elif n == 1:\n        return zip(iterable)\n    else:\n        raise ValueError(f'n should be at least one, not {n}')",
    "docstring": "Return a sliding window of width *n* over *iterable*.\n\n    >>> list(sliding_window(range(6), 4))\n    [(0, 1, 2, 3), (1, 2, 3, 4), (2, 3, 4, 5)]\n\nIf *iterable* has fewer than *n* items, then nothing is yielded:\n\n    >>> list(sliding_window(range(3), 4))\n    []\n\nFor a variant with more features, see :func:`windowed`."
  },
  {
    "function": "subslices",
    "code": "def subslices(iterable):\n    \"\"\"Return all contiguous non-empty subslices of *iterable*.\n\n        >>> list(subslices('ABC'))\n        [['A'], ['A', 'B'], ['A', 'B', 'C'], ['B'], ['B', 'C'], ['C']]\n\n    This is similar to :func:`substrings`, but emits items in a different\n    order.\n    \"\"\"\n    seq = list(iterable)\n    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n    return map(getitem, repeat(seq), slices)",
    "docstring": "Return all contiguous non-empty subslices of *iterable*.\n\n    >>> list(subslices('ABC'))\n    [['A'], ['A', 'B'], ['A', 'B', 'C'], ['B'], ['B', 'C'], ['C']]\n\nThis is similar to :func:`substrings`, but emits items in a different\norder."
  },
  {
    "function": "polynomial_from_roots",
    "code": "def polynomial_from_roots(roots):\n    \"\"\"Compute a polynomial's coefficients from its roots.\n\n    >>> roots = [5, -4, 3]            # (x - 5) * (x + 4) * (x - 3)\n    >>> polynomial_from_roots(roots)  # x\u00b3 - 4 x\u00b2 - 17 x + 60\n    [1, -4, -17, 60]\n\n    Note that polynomial coefficients are specified in descending power order.\n\n    Supports all numeric types: int, float, complex, Decimal, Fraction.\n    \"\"\"\n\n    # This recipe differs from the one in itertools docs in that it\n    # applies list() after each call to convolve().  This avoids\n    # hitting stack limits with nested generators.\n\n    poly = [1]\n    for root in roots:\n        poly = list(convolve(poly, (1, -root)))\n    return poly",
    "docstring": "Compute a polynomial's coefficients from its roots.\n\n>>> roots = [5, -4, 3]            # (x - 5) * (x + 4) * (x - 3)\n>>> polynomial_from_roots(roots)  # x\u00b3 - 4 x\u00b2 - 17 x + 60\n[1, -4, -17, 60]\n\nNote that polynomial coefficients are specified in descending power order.\n\nSupports all numeric types: int, float, complex, Decimal, Fraction."
  },
  {
    "function": "iter_index",
    "code": "def iter_index(iterable, value, start=0, stop=None):\n    \"\"\"Yield the index of each place in *iterable* that *value* occurs,\n    beginning with index *start* and ending before index *stop*.\n\n\n    >>> list(iter_index('AABCADEAF', 'A'))\n    [0, 1, 4, 7]\n    >>> list(iter_index('AABCADEAF', 'A', 1))  # start index is inclusive\n    [1, 4, 7]\n    >>> list(iter_index('AABCADEAF', 'A', 1, 7))  # stop index is not inclusive\n    [1, 4]\n\n    The behavior for non-scalar *values* matches the built-in Python types.\n\n    >>> list(iter_index('ABCDABCD', 'AB'))\n    [0, 4]\n    >>> list(iter_index([0, 1, 2, 3, 0, 1, 2, 3], [0, 1]))\n    []\n    >>> list(iter_index([[0, 1], [2, 3], [0, 1], [2, 3]], [0, 1]))\n    [0, 2]\n\n    See :func:`locate` for a more general means of finding the indexes\n    associated with particular values.\n\n    \"\"\"\n    seq_index = getattr(iterable, 'index', None)\n    if seq_index is None:\n        # Slow path for general iterables\n        iterator = islice(iterable, start, stop)\n        for i, element in enumerate(iterator, start):\n            if element is value or element == value:\n                yield i\n    else:\n        # Fast path for sequences\n        stop = len(iterable) if stop is None else stop\n        i = start - 1\n        with suppress(ValueError):\n            while True:\n                yield (i := seq_index(value, i + 1, stop))",
    "docstring": "Yield the index of each place in *iterable* that *value* occurs,\nbeginning with index *start* and ending before index *stop*.\n\n\n>>> list(iter_index('AABCADEAF', 'A'))\n[0, 1, 4, 7]\n>>> list(iter_index('AABCADEAF', 'A', 1))  # start index is inclusive\n[1, 4, 7]\n>>> list(iter_index('AABCADEAF', 'A', 1, 7))  # stop index is not inclusive\n[1, 4]\n\nThe behavior for non-scalar *values* matches the built-in Python types.\n\n>>> list(iter_index('ABCDABCD', 'AB'))\n[0, 4]\n>>> list(iter_index([0, 1, 2, 3, 0, 1, 2, 3], [0, 1]))\n[]\n>>> list(iter_index([[0, 1], [2, 3], [0, 1], [2, 3]], [0, 1]))\n[0, 2]\n\nSee :func:`locate` for a more general means of finding the indexes\nassociated with particular values."
  },
  {
    "function": "sieve",
    "code": "def sieve(n):\n    \"\"\"Yield the primes less than n.\n\n    >>> list(sieve(30))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n    \"\"\"\n    # This implementation comes from an older version of the itertools\n    # documentation.  The newer implementation is easier to read but is\n    # less lazy.\n    if n > 2:\n        yield 2\n    start = 3\n    data = bytearray((0, 1)) * (n // 2)\n    for p in iter_index(data, 1, start, stop=isqrt(n) + 1):\n        yield from iter_index(data, 1, start, p * p)\n        data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))\n        start = p * p\n    yield from iter_index(data, 1, start)",
    "docstring": "Yield the primes less than n.\n\n>>> list(sieve(30))\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]"
  },
  {
    "function": "_batched",
    "code": "def _batched(iterable, n, *, strict=False):  # pragma: no cover\n    \"\"\"Batch data into tuples of length *n*. If the number of items in\n    *iterable* is not divisible by *n*:\n    * The last batch will be shorter if *strict* is ``False``.\n    * :exc:`ValueError` will be raised if *strict* is ``True``.\n\n    >>> list(batched('ABCDEFG', 3))\n    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G',)]\n\n    On Python 3.13 and above, this is an alias for :func:`itertools.batched`.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least one')\n    iterator = iter(iterable)\n    while batch := tuple(islice(iterator, n)):\n        if strict and len(batch) != n:\n            raise ValueError('batched(): incomplete batch')\n        yield batch",
    "docstring": "Batch data into tuples of length *n*. If the number of items in\n*iterable* is not divisible by *n*:\n* The last batch will be shorter if *strict* is ``False``.\n* :exc:`ValueError` will be raised if *strict* is ``True``.\n\n>>> list(batched('ABCDEFG', 3))\n[('A', 'B', 'C'), ('D', 'E', 'F'), ('G',)]\n\nOn Python 3.13 and above, this is an alias for :func:`itertools.batched`."
  },
  {
    "function": "transpose",
    "code": "def transpose(it):\n    \"\"\"Swap the rows and columns of the input matrix.\n\n    >>> list(transpose([(1, 2, 3), (11, 22, 33)]))\n    [(1, 11), (2, 22), (3, 33)]\n\n    The caller should ensure that the dimensions of the input are compatible.\n    If the input is empty, no output will be produced.\n    \"\"\"\n    return zip(*it, strict=True)",
    "docstring": "Swap the rows and columns of the input matrix.\n\n>>> list(transpose([(1, 2, 3), (11, 22, 33)]))\n[(1, 11), (2, 22), (3, 33)]\n\nThe caller should ensure that the dimensions of the input are compatible.\nIf the input is empty, no output will be produced."
  },
  {
    "function": "_is_scalar",
    "code": "def _is_scalar(value, stringlike=(str, bytes)):\n    \"Scalars are bytes, strings, and non-iterables.\"\n    try:\n        iter(value)\n    except TypeError:\n        return True\n    return isinstance(value, stringlike)",
    "docstring": "Scalars are bytes, strings, and non-iterables."
  },
  {
    "function": "_flatten_tensor",
    "code": "def _flatten_tensor(tensor):\n    \"Depth-first iterator over scalars in a tensor.\"\n    iterator = iter(tensor)\n    while True:\n        try:\n            value = next(iterator)\n        except StopIteration:\n            return iterator\n        iterator = chain((value,), iterator)\n        if _is_scalar(value):\n            return iterator\n        iterator = chain.from_iterable(iterator)",
    "docstring": "Depth-first iterator over scalars in a tensor."
  },
  {
    "function": "reshape",
    "code": "def reshape(matrix, shape):\n    \"\"\"Change the shape of a *matrix*.\n\n    If *shape* is an integer, the matrix must be two dimensional\n    and the shape is interpreted as the desired number of columns:\n\n        >>> matrix = [(0, 1), (2, 3), (4, 5)]\n        >>> cols = 3\n        >>> list(reshape(matrix, cols))\n        [(0, 1, 2), (3, 4, 5)]\n\n    If *shape* is a tuple (or other iterable), the input matrix can have\n    any number of dimensions. It will first be flattened and then rebuilt\n    to the desired shape which can also be multidimensional:\n\n        >>> matrix = [(0, 1), (2, 3), (4, 5)]    # Start with a 3 x 2 matrix\n\n        >>> list(reshape(matrix, (2, 3)))        # Make a 2 x 3 matrix\n        [(0, 1, 2), (3, 4, 5)]\n\n        >>> list(reshape(matrix, (6,)))          # Make a vector of length six\n        [0, 1, 2, 3, 4, 5]\n\n        >>> list(reshape(matrix, (2, 1, 3, 1)))  # Make 2 x 1 x 3 x 1 tensor\n        [(((0,), (1,), (2,)),), (((3,), (4,), (5,)),)]\n\n    Each dimension is assumed to be uniform, either all arrays or all scalars.\n    Flattening stops when the first value in a dimension is a scalar.\n    Scalars are bytes, strings, and non-iterables.\n    The reshape iterator stops when the requested shape is complete\n    or when the input is exhausted, whichever comes first.\n\n    \"\"\"\n    if isinstance(shape, int):\n        return batched(chain.from_iterable(matrix), shape)\n    first_dim, *dims = shape\n    scalar_stream = _flatten_tensor(matrix)\n    reshaped = reduce(batched, reversed(dims), scalar_stream)\n    return islice(reshaped, first_dim)",
    "docstring": "Change the shape of a *matrix*.\n\nIf *shape* is an integer, the matrix must be two dimensional\nand the shape is interpreted as the desired number of columns:\n\n    >>> matrix = [(0, 1), (2, 3), (4, 5)]\n    >>> cols = 3\n    >>> list(reshape(matrix, cols))\n    [(0, 1, 2), (3, 4, 5)]\n\nIf *shape* is a tuple (or other iterable), the input matrix can have\nany number of dimensions. It will first be flattened and then rebuilt\nto the desired shape which can also be multidimensional:\n\n    >>> matrix = [(0, 1), (2, 3), (4, 5)]    # Start with a 3 x 2 matrix\n\n    >>> list(reshape(matrix, (2, 3)))        # Make a 2 x 3 matrix\n    [(0, 1, 2), (3, 4, 5)]\n\n    >>> list(reshape(matrix, (6,)))          # Make a vector of length six\n    [0, 1, 2, 3, 4, 5]\n\n    >>> list(reshape(matrix, (2, 1, 3, 1)))  # Make 2 x 1 x 3 x 1 tensor\n    [(((0,), (1,), (2,)),), (((3,), (4,), (5,)),)]\n\nEach dimension is assumed to be uniform, either all arrays or all scalars.\nFlattening stops when the first value in a dimension is a scalar.\nScalars are bytes, strings, and non-iterables.\nThe reshape iterator stops when the requested shape is complete\nor when the input is exhausted, whichever comes first."
  },
  {
    "function": "matmul",
    "code": "def matmul(m1, m2):\n    \"\"\"Multiply two matrices.\n\n    >>> list(matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]))\n    [(49, 80), (41, 60)]\n\n    The caller should ensure that the dimensions of the input matrices are\n    compatible with each other.\n\n    Supports all numeric types: int, float, complex, Decimal, Fraction.\n    \"\"\"\n    n = len(m2[0])\n    return batched(starmap(_sumprod, product(m1, transpose(m2))), n)",
    "docstring": "Multiply two matrices.\n\n>>> list(matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]))\n[(49, 80), (41, 60)]\n\nThe caller should ensure that the dimensions of the input matrices are\ncompatible with each other.\n\nSupports all numeric types: int, float, complex, Decimal, Fraction."
  },
  {
    "function": "factor",
    "code": "def factor(n):\n    \"\"\"Yield the prime factors of n.\n\n    >>> list(factor(360))\n    [2, 2, 2, 3, 3, 5]\n\n    Finds small factors with trial division.  Larger factors are\n    either verified as prime with ``is_prime`` or split into\n    smaller factors with Pollard's rho algorithm.\n    \"\"\"\n\n    # Corner case reduction\n    if n < 2:\n        return\n\n    # Trial division reduction\n    for prime in _primes_below_211:\n        while not n % prime:\n            yield prime\n            n //= prime\n\n    # Pollard's rho reduction\n    primes = []\n    todo = [n] if n > 1 else []\n    for n in todo:\n        if n < 211**2 or is_prime(n):\n            primes.append(n)\n        else:\n            fact = _factor_pollard(n)\n            todo += (fact, n // fact)\n    yield from sorted(primes)",
    "docstring": "Yield the prime factors of n.\n\n>>> list(factor(360))\n[2, 2, 2, 3, 3, 5]\n\nFinds small factors with trial division.  Larger factors are\neither verified as prime with ``is_prime`` or split into\nsmaller factors with Pollard's rho algorithm."
  },
  {
    "function": "polynomial_eval",
    "code": "def polynomial_eval(coefficients, x):\n    \"\"\"Evaluate a polynomial at a specific value.\n\n    Computes with better numeric stability than Horner's method.\n\n    Evaluate ``x^3 - 4 * x^2 - 17 * x + 60`` at ``x = 2.5``:\n\n    >>> coefficients = [1, -4, -17, 60]\n    >>> x = 2.5\n    >>> polynomial_eval(coefficients, x)\n    8.125\n\n    Note that polynomial coefficients are specified in descending power order.\n\n    Supports all numeric types: int, float, complex, Decimal, Fraction.\n    \"\"\"\n    n = len(coefficients)\n    if n == 0:\n        return type(x)(0)\n    powers = map(pow, repeat(x), reversed(range(n)))\n    return _sumprod(coefficients, powers)",
    "docstring": "Evaluate a polynomial at a specific value.\n\nComputes with better numeric stability than Horner's method.\n\nEvaluate ``x^3 - 4 * x^2 - 17 * x + 60`` at ``x = 2.5``:\n\n>>> coefficients = [1, -4, -17, 60]\n>>> x = 2.5\n>>> polynomial_eval(coefficients, x)\n8.125\n\nNote that polynomial coefficients are specified in descending power order.\n\nSupports all numeric types: int, float, complex, Decimal, Fraction."
  },
  {
    "function": "sum_of_squares",
    "code": "def sum_of_squares(it):\n    \"\"\"Return the sum of the squares of the input values.\n\n    >>> sum_of_squares([10, 20, 30])\n    1400\n\n    Supports all numeric types: int, float, complex, Decimal, Fraction.\n    \"\"\"\n    return _sumprod(*tee(it))",
    "docstring": "Return the sum of the squares of the input values.\n\n>>> sum_of_squares([10, 20, 30])\n1400\n\nSupports all numeric types: int, float, complex, Decimal, Fraction."
  },
  {
    "function": "polynomial_derivative",
    "code": "def polynomial_derivative(coefficients):\n    \"\"\"Compute the first derivative of a polynomial.\n\n    Evaluate the derivative of ``x\u00b3 - 4 x\u00b2 - 17 x + 60``:\n\n    >>> coefficients = [1, -4, -17, 60]\n    >>> derivative_coefficients = polynomial_derivative(coefficients)\n    >>> derivative_coefficients\n    [3, -8, -17]\n\n    Note that polynomial coefficients are specified in descending power order.\n\n    Supports all numeric types: int, float, complex, Decimal, Fraction.\n    \"\"\"\n    n = len(coefficients)\n    powers = reversed(range(1, n))\n    return list(map(mul, coefficients, powers))",
    "docstring": "Compute the first derivative of a polynomial.\n\nEvaluate the derivative of ``x\u00b3 - 4 x\u00b2 - 17 x + 60``:\n\n>>> coefficients = [1, -4, -17, 60]\n>>> derivative_coefficients = polynomial_derivative(coefficients)\n>>> derivative_coefficients\n[3, -8, -17]\n\nNote that polynomial coefficients are specified in descending power order.\n\nSupports all numeric types: int, float, complex, Decimal, Fraction."
  },
  {
    "function": "totient",
    "code": "def totient(n):\n    \"\"\"Return the count of natural numbers up to *n* that are coprime with *n*.\n\n    Euler's totient function \u03c6(n) gives the number of totatives.\n    Totative are integers k in the range 1 \u2264 k \u2264 n such that gcd(n, k) = 1.\n\n    >>> n = 9\n    >>> totient(n)\n    6\n\n    >>> totatives = [x for x in range(1, n) if gcd(n, x) == 1]\n    >>> totatives\n    [1, 2, 4, 5, 7, 8]\n    >>> len(totatives)\n    6\n\n    Reference:  https://en.wikipedia.org/wiki/Euler%27s_totient_function\n\n    \"\"\"\n    for prime in set(factor(n)):\n        n -= n // prime\n    return n",
    "docstring": "Return the count of natural numbers up to *n* that are coprime with *n*.\n\nEuler's totient function \u03c6(n) gives the number of totatives.\nTotative are integers k in the range 1 \u2264 k \u2264 n such that gcd(n, k) = 1.\n\n>>> n = 9\n>>> totient(n)\n6\n\n>>> totatives = [x for x in range(1, n) if gcd(n, x) == 1]\n>>> totatives\n[1, 2, 4, 5, 7, 8]\n>>> len(totatives)\n6\n\nReference:  https://en.wikipedia.org/wiki/Euler%27s_totient_function"
  },
  {
    "function": "_shift_to_odd",
    "code": "def _shift_to_odd(n):\n    'Return s, d such that 2**s * d == n'\n    s = ((n - 1) ^ n).bit_length() - 1\n    d = n >> s\n    assert (1 << s) * d == n and d & 1 and s >= 0\n    return s, d",
    "docstring": "Return s, d such that 2**s * d == n"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(n):\n    \"\"\"Return ``True`` if *n* is prime and ``False`` otherwise.\n\n    Basic examples:\n\n        >>> is_prime(37)\n        True\n        >>> is_prime(3 * 13)\n        False\n        >>> is_prime(18_446_744_073_709_551_557)\n        True\n\n    Find the next prime over one billion:\n\n        >>> next(filter(is_prime, count(10**9)))\n        1000000007\n\n    Generate random primes up to 200 bits and up to 60 decimal digits:\n\n        >>> from random import seed, randrange, getrandbits\n        >>> seed(18675309)\n\n        >>> next(filter(is_prime, map(getrandbits, repeat(200))))\n        893303929355758292373272075469392561129886005037663238028407\n\n        >>> next(filter(is_prime, map(randrange, repeat(10**60))))\n        269638077304026462407872868003560484232362454342414618963649\n\n    This function is exact for values of *n* below 10**24.  For larger inputs,\n    the probabilistic Miller-Rabin primality test has a less than 1 in 2**128\n    chance of a false positive.\n    \"\"\"\n\n    if n < 17:\n        return n in {2, 3, 5, 7, 11, 13}\n\n    if not (n & 1 and n % 3 and n % 5 and n % 7 and n % 11 and n % 13):\n        return False\n\n    for limit, bases in _perfect_tests:\n        if n < limit:\n            break\n    else:\n        bases = (_private_randrange(2, n - 1) for i in range(64))\n\n    return all(_strong_probable_prime(n, base) for base in bases)",
    "docstring": "Return ``True`` if *n* is prime and ``False`` otherwise.\n\nBasic examples:\n\n    >>> is_prime(37)\n    True\n    >>> is_prime(3 * 13)\n    False\n    >>> is_prime(18_446_744_073_709_551_557)\n    True\n\nFind the next prime over one billion:\n\n    >>> next(filter(is_prime, count(10**9)))\n    1000000007\n\nGenerate random primes up to 200 bits and up to 60 decimal digits:\n\n    >>> from random import seed, randrange, getrandbits\n    >>> seed(18675309)\n\n    >>> next(filter(is_prime, map(getrandbits, repeat(200))))\n    893303929355758292373272075469392561129886005037663238028407\n\n    >>> next(filter(is_prime, map(randrange, repeat(10**60))))\n    269638077304026462407872868003560484232362454342414618963649\n\nThis function is exact for values of *n* below 10**24.  For larger inputs,\nthe probabilistic Miller-Rabin primality test has a less than 1 in 2**128\nchance of a false positive."
  },
  {
    "function": "loops",
    "code": "def loops(n):\n    \"\"\"Returns an iterable with *n* elements for efficient looping.\n    Like ``range(n)`` but doesn't create integers.\n\n    >>> i = 0\n    >>> for _ in loops(5):\n    ...     i += 1\n    >>> i\n    5\n\n    \"\"\"\n    return repeat(None, n)",
    "docstring": "Returns an iterable with *n* elements for efficient looping.\nLike ``range(n)`` but doesn't create integers.\n\n>>> i = 0\n>>> for _ in loops(5):\n...     i += 1\n>>> i\n5"
  },
  {
    "function": "multinomial",
    "code": "def multinomial(*counts):\n    \"\"\"Number of distinct arrangements of a multiset.\n\n    The expression ``multinomial(3, 4, 2)`` has several equivalent\n    interpretations:\n\n    * In the expansion of ``(a + b + c)\u2079``, the coefficient of the\n      ``a\u00b3b\u2074c\u00b2`` term is 1260.\n\n    * There are 1260 distinct ways to arrange 9 balls consisting of 3 reds, 4\n      greens, and 2 blues.\n\n    * There are 1260 unique ways to place 9 distinct objects into three bins\n      with sizes 3, 4, and 2.\n\n    The :func:`multinomial` function computes the length of\n    :func:`distinct_permutations`.  For example, there are 83,160 distinct\n    anagrams of the word \"abracadabra\":\n\n        >>> from more_itertools import distinct_permutations, ilen\n        >>> ilen(distinct_permutations('abracadabra'))\n        83160\n\n    This can be computed directly from the letter counts, 5a 2b 2r 1c 1d:\n\n        >>> from collections import Counter\n        >>> list(Counter('abracadabra').values())\n        [5, 2, 2, 1, 1]\n        >>> multinomial(5, 2, 2, 1, 1)\n        83160\n\n    A binomial coefficient is a special case of multinomial where there are\n    only two categories.  For example, the number of ways to arrange 12 balls\n    with 5 reds and 7 blues is ``multinomial(5, 7)`` or ``math.comb(12, 5)``.\n\n    Likewise, factorial is a special case of multinomial where\n    the multiplicities are all just 1 so that\n    ``multinomial(1, 1, 1, 1, 1, 1, 1) == math.factorial(7)``.\n\n    Reference:  https://en.wikipedia.org/wiki/Multinomial_theorem\n\n    \"\"\"\n    return prod(map(comb, accumulate(counts), counts))",
    "docstring": "Number of distinct arrangements of a multiset.\n\nThe expression ``multinomial(3, 4, 2)`` has several equivalent\ninterpretations:\n\n* In the expansion of ``(a + b + c)\u2079``, the coefficient of the\n  ``a\u00b3b\u2074c\u00b2`` term is 1260.\n\n* There are 1260 distinct ways to arrange 9 balls consisting of 3 reds, 4\n  greens, and 2 blues.\n\n* There are 1260 unique ways to place 9 distinct objects into three bins\n  with sizes 3, 4, and 2.\n\nThe :func:`multinomial` function computes the length of\n:func:`distinct_permutations`.  For example, there are 83,160 distinct\nanagrams of the word \"abracadabra\":\n\n    >>> from more_itertools import distinct_permutations, ilen\n    >>> ilen(distinct_permutations('abracadabra'))\n    83160\n\nThis can be computed directly from the letter counts, 5a 2b 2r 1c 1d:\n\n    >>> from collections import Counter\n    >>> list(Counter('abracadabra').values())\n    [5, 2, 2, 1, 1]\n    >>> multinomial(5, 2, 2, 1, 1)\n    83160\n\nA binomial coefficient is a special case of multinomial where there are\nonly two categories.  For example, the number of ways to arrange 12 balls\nwith 5 reds and 7 blues is ``multinomial(5, 7)`` or ``math.comb(12, 5)``.\n\nLikewise, factorial is a special case of multinomial where\nthe multiplicities are all just 1 so that\n``multinomial(1, 1, 1, 1, 1, 1, 1) == math.factorial(7)``.\n\nReference:  https://en.wikipedia.org/wiki/Multinomial_theorem"
  },
  {
    "function": "_running_median_minheap_and_maxheap",
    "code": "def _running_median_minheap_and_maxheap(iterator):  # pragma: no cover\n    \"Non-windowed running_median() for Python 3.14+\"\n\n    read = iterator.__next__\n    lo = []  # max-heap\n    hi = []  # min-heap (same size as or one smaller than lo)\n\n    with suppress(StopIteration):\n        while True:\n            heappush_max(lo, heappushpop(hi, read()))\n            yield lo[0]\n\n            heappush(hi, heappushpop_max(lo, read()))\n            yield (lo[0] + hi[0]) / 2",
    "docstring": "Non-windowed running_median() for Python 3.14+"
  },
  {
    "function": "_running_median_minheap_only",
    "code": "def _running_median_minheap_only(iterator):  # pragma: no cover\n    \"Backport of non-windowed running_median() for Python 3.13 and prior.\"\n\n    read = iterator.__next__\n    lo = []  # max-heap (actually a minheap with negated values)\n    hi = []  # min-heap (same size as or one smaller than lo)\n\n    with suppress(StopIteration):\n        while True:\n            heappush(lo, -heappushpop(hi, read()))\n            yield -lo[0]\n\n            heappush(hi, -heappushpop(lo, -read()))\n            yield (hi[0] - lo[0]) / 2",
    "docstring": "Backport of non-windowed running_median() for Python 3.13 and prior."
  },
  {
    "function": "_running_median_windowed",
    "code": "def _running_median_windowed(iterator, maxlen):\n    \"Yield median of values in a sliding window.\"\n\n    window = deque()\n    ordered = []\n\n    for x in iterator:\n        window.append(x)\n        insort(ordered, x)\n\n        if len(ordered) > maxlen:\n            i = bisect_left(ordered, window.popleft())\n            del ordered[i]\n\n        n = len(ordered)\n        m = n // 2\n        yield ordered[m] if n & 1 else (ordered[m - 1] + ordered[m]) / 2",
    "docstring": "Yield median of values in a sliding window."
  },
  {
    "function": "running_median",
    "code": "def running_median(iterable, *, maxlen=None):\n    \"\"\"Cumulative median of values seen so far or values in a sliding window.\n\n    Set *maxlen* to a positive integer to specify the maximum size\n    of the sliding window.  The default of *None* is equivalent to\n    an unbounded window.\n\n    For example:\n\n        >>> list(running_median([5.0, 9.0, 4.0, 12.0, 8.0, 9.0]))\n        [5.0, 7.0, 5.0, 7.0, 8.0, 8.5]\n        >>> list(running_median([5.0, 9.0, 4.0, 12.0, 8.0, 9.0], maxlen=3))\n        [5.0, 7.0, 5.0, 9.0, 8.0, 9.0]\n\n    Supports numeric types such as int, float, Decimal, and Fraction,\n    but not complex numbers which are unorderable.\n\n    On version Python 3.13 and prior, max-heaps are simulated with\n    negative values. The negation causes Decimal inputs to apply context\n    rounding, making the results slightly different than that obtained\n    by statistics.median().\n    \"\"\"\n\n    iterator = iter(iterable)\n\n    if maxlen is not None:\n        maxlen = index(maxlen)\n        if maxlen <= 0:\n            raise ValueError('Window size should be positive')\n        return _running_median_windowed(iterator, maxlen)\n\n    if not _max_heap_available:\n        return _running_median_minheap_only(iterator)  # pragma: no cover\n\n    return _running_median_minheap_and_maxheap(iterator)  # pragma: no cover",
    "docstring": "Cumulative median of values seen so far or values in a sliding window.\n\nSet *maxlen* to a positive integer to specify the maximum size\nof the sliding window.  The default of *None* is equivalent to\nan unbounded window.\n\nFor example:\n\n    >>> list(running_median([5.0, 9.0, 4.0, 12.0, 8.0, 9.0]))\n    [5.0, 7.0, 5.0, 7.0, 8.0, 8.5]\n    >>> list(running_median([5.0, 9.0, 4.0, 12.0, 8.0, 9.0], maxlen=3))\n    [5.0, 7.0, 5.0, 9.0, 8.0, 9.0]\n\nSupports numeric types such as int, float, Decimal, and Fraction,\nbut not complex numbers which are unorderable.\n\nOn version Python 3.13 and prior, max-heaps are simulated with\nnegative values. The negation causes Decimal inputs to apply context\nrounding, making the results slightly different than that obtained\nby statistics.median()."
  },
  {
    "function": "random_derangement",
    "code": "def random_derangement(iterable):\n    \"\"\"Return a random derangement of elements in the iterable.\n\n    Equivalent to but much faster than ``choice(list(derangements(iterable)))``.\n\n    \"\"\"\n    seq = tuple(iterable)\n    if len(seq) < 2:\n        if len(seq) == 0:\n            return ()\n        raise IndexError('No derangments to choose from')\n    perm = list(range(len(seq)))\n    start = tuple(perm)\n    while True:\n        shuffle(perm)\n        if not any(map(is_, start, perm)):\n            return itemgetter(*perm)(seq)",
    "docstring": "Return a random derangement of elements in the iterable.\n\nEquivalent to but much faster than ``choice(list(derangements(iterable)))``."
  },
  {
    "function": "make_lowpass",
    "code": "def make_lowpass(\n    frequency: int,\n    samplerate: int,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a low-pass filter\n\n    >>> filter = make_lowpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.004277569313094809,\n     0.008555138626189618, 0.004277569313094809]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n\n    b0 = (1 - _cos) / 2\n    b1 = 1 - _cos\n\n    a0 = 1 + alpha\n    a1 = -2 * _cos\n    a2 = 1 - alpha\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b0])\n    return filt",
    "docstring": "Creates a low-pass filter\n\n>>> filter = make_lowpass(1000, 48000)\n>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n[1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.004277569313094809,\n 0.008555138626189618, 0.004277569313094809]"
  },
  {
    "function": "make_highpass",
    "code": "def make_highpass(\n    frequency: int,\n    samplerate: int,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a high-pass filter\n\n    >>> filter = make_highpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9957224306869052,\n     -1.9914448613738105, 0.9957224306869052]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n\n    b0 = (1 + _cos) / 2\n    b1 = -1 - _cos\n\n    a0 = 1 + alpha\n    a1 = -2 * _cos\n    a2 = 1 - alpha\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b0])\n    return filt",
    "docstring": "Creates a high-pass filter\n\n>>> filter = make_highpass(1000, 48000)\n>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n[1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9957224306869052,\n -1.9914448613738105, 0.9957224306869052]"
  },
  {
    "function": "make_bandpass",
    "code": "def make_bandpass(\n    frequency: int,\n    samplerate: int,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a band-pass filter\n\n    >>> filter = make_bandpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.06526309611002579,\n     0, -0.06526309611002579]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n\n    b0 = _sin / 2\n    b1 = 0\n    b2 = -b0\n\n    a0 = 1 + alpha\n    a1 = -2 * _cos\n    a2 = 1 - alpha\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\n    return filt",
    "docstring": "Creates a band-pass filter\n\n>>> filter = make_bandpass(1000, 48000)\n>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n[1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.06526309611002579,\n 0, -0.06526309611002579]"
  },
  {
    "function": "make_allpass",
    "code": "def make_allpass(\n    frequency: int,\n    samplerate: int,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates an all-pass filter\n\n    >>> filter = make_allpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9077040443587427,\n     -1.9828897227476208, 1.0922959556412573]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n\n    b0 = 1 - alpha\n    b1 = -2 * _cos\n    b2 = 1 + alpha\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([b2, b1, b0], [b0, b1, b2])\n    return filt",
    "docstring": "Creates an all-pass filter\n\n>>> filter = make_allpass(1000, 48000)\n>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n[1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9077040443587427,\n -1.9828897227476208, 1.0922959556412573]"
  },
  {
    "function": "make_peak",
    "code": "def make_peak(\n    frequency: int,\n    samplerate: int,\n    gain_db: float,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a peak filter\n\n    >>> filter = make_peak(1000, 48000, 6)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0653405327119334, -1.9828897227476208, 0.9346594672880666, 1.1303715025601122,\n     -1.9828897227476208, 0.8696284974398878]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n    big_a = 10 ** (gain_db / 40)\n\n    b0 = 1 + alpha * big_a\n    b1 = -2 * _cos\n    b2 = 1 - alpha * big_a\n    a0 = 1 + alpha / big_a\n    a1 = -2 * _cos\n    a2 = 1 - alpha / big_a\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\n    return filt",
    "docstring": "Creates a peak filter\n\n>>> filter = make_peak(1000, 48000, 6)\n>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n[1.0653405327119334, -1.9828897227476208, 0.9346594672880666, 1.1303715025601122,\n -1.9828897227476208, 0.8696284974398878]"
  },
  {
    "function": "make_lowshelf",
    "code": "def make_lowshelf(\n    frequency: int,\n    samplerate: int,\n    gain_db: float,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a low-shelf filter\n\n    >>> filter = make_lowshelf(1000, 48000, 6)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [3.0409336710888786, -5.608870992220748, 2.602157875636628, 3.139954022810743,\n     -5.591841778072785, 2.5201667380627257]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n    big_a = 10 ** (gain_db / 40)\n    pmc = (big_a + 1) - (big_a - 1) * _cos\n    ppmc = (big_a + 1) + (big_a - 1) * _cos\n    mpc = (big_a - 1) - (big_a + 1) * _cos\n    pmpc = (big_a - 1) + (big_a + 1) * _cos\n    aa2 = 2 * sqrt(big_a) * alpha\n\n    b0 = big_a * (pmc + aa2)\n    b1 = 2 * big_a * mpc\n    b2 = big_a * (pmc - aa2)\n    a0 = ppmc + aa2\n    a1 = -2 * pmpc\n    a2 = ppmc - aa2\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\n    return filt",
    "docstring": "Creates a low-shelf filter\n\n>>> filter = make_lowshelf(1000, 48000, 6)\n>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n[3.0409336710888786, -5.608870992220748, 2.602157875636628, 3.139954022810743,\n -5.591841778072785, 2.5201667380627257]"
  },
  {
    "function": "make_highshelf",
    "code": "def make_highshelf(\n    frequency: int,\n    samplerate: int,\n    gain_db: float,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a high-shelf filter\n\n    >>> filter = make_highshelf(1000, 48000, 6)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [2.2229172136088806, -3.9587208137297303, 1.7841414181566304, 4.295432981120543,\n     -7.922740859457287, 3.6756456963725253]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n    big_a = 10 ** (gain_db / 40)\n    pmc = (big_a + 1) - (big_a - 1) * _cos\n    ppmc = (big_a + 1) + (big_a - 1) * _cos\n    mpc = (big_a - 1) - (big_a + 1) * _cos\n    pmpc = (big_a - 1) + (big_a + 1) * _cos\n    aa2 = 2 * sqrt(big_a) * alpha\n\n    b0 = big_a * (ppmc + aa2)\n    b1 = -2 * big_a * pmpc\n    b2 = big_a * (ppmc - aa2)\n    a0 = pmc + aa2\n    a1 = 2 * mpc\n    a2 = pmc - aa2\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\n    return filt",
    "docstring": "Creates a high-shelf filter\n\n>>> filter = make_highshelf(1000, 48000, 6)\n>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n[2.2229172136088806, -3.9587208137297303, 1.7841414181566304, 4.295432981120543,\n -7.922740859457287, 3.6756456963725253]"
  },
  {
    "function": "get_bounds",
    "code": "def get_bounds(\n    fft_results: np.ndarray, samplerate: int\n) -> tuple[int | float, int | float]:\n    \"\"\"\n    Get bounds for printing fft results\n\n    >>> import numpy\n    >>> array = numpy.linspace(-20.0, 20.0, 1000)\n    >>> get_bounds(array, 1000)\n    (-20, 20)\n    \"\"\"\n    lowest = min([-20, np.min(fft_results[1 : samplerate // 2 - 1])])\n    highest = max([20, np.max(fft_results[1 : samplerate // 2 - 1])])\n    return lowest, highest",
    "docstring": "Get bounds for printing fft results\n\n>>> import numpy\n>>> array = numpy.linspace(-20.0, 20.0, 1000)\n>>> get_bounds(array, 1000)\n(-20, 20)"
  },
  {
    "function": "show_frequency_response",
    "code": "def show_frequency_response(filter_type: FilterType, samplerate: int) -> None:\n    \"\"\"\n    Show frequency response of a filter\n\n    >>> from audio_filters.iir_filter import IIRFilter\n    >>> filt = IIRFilter(4)\n    >>> show_frequency_response(filt, 48000)\n    \"\"\"\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\n\n    filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.abs(np.fft.fft(outputs))\n    fft_db = 20 * np.log10(fft_out)\n\n    # Frequencies on log scale from 24 to nyquist frequency\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\n\n    # Display within reasonable bounds\n    bounds = get_bounds(fft_db, samplerate)\n    plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))\n    plt.ylabel(\"Gain (dB)\")\n\n    plt.plot(fft_db)\n    plt.show()",
    "docstring": "Show frequency response of a filter\n\n>>> from audio_filters.iir_filter import IIRFilter\n>>> filt = IIRFilter(4)\n>>> show_frequency_response(filt, 48000)"
  },
  {
    "function": "show_phase_response",
    "code": "def show_phase_response(filter_type: FilterType, samplerate: int) -> None:\n    \"\"\"\n    Show phase response of a filter\n\n    >>> from audio_filters.iir_filter import IIRFilter\n    >>> filt = IIRFilter(4)\n    >>> show_phase_response(filt, 48000)\n    \"\"\"\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\n\n    filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.angle(np.fft.fft(outputs))\n\n    # Frequencies on log scale from 24 to nyquist frequency\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\n\n    plt.ylim(-2 * pi, 2 * pi)\n    plt.ylabel(\"Phase shift (Radians)\")\n    plt.plot(np.unwrap(fft_out, -2 * pi))\n    plt.show()",
    "docstring": "Show phase response of a filter\n\n>>> from audio_filters.iir_filter import IIRFilter\n>>> filt = IIRFilter(4)\n>>> show_phase_response(filt, 48000)"
  },
  {
    "function": "combination_lists",
    "code": "def combination_lists(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    Generates all possible combinations of k numbers out of 1 ... n using itertools.\n\n    >>> combination_lists(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    return [list(x) for x in combinations(range(1, n + 1), k)]",
    "docstring": "Generates all possible combinations of k numbers out of 1 ... n using itertools.\n\n>>> combination_lists(n=4, k=2)\n[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]"
  },
  {
    "function": "generate_all_combinations",
    "code": "def generate_all_combinations(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    Generates all possible combinations of k numbers out of 1 ... n using backtracking.\n\n    >>> generate_all_combinations(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    >>> generate_all_combinations(n=0, k=0)\n    [[]]\n    >>> generate_all_combinations(n=10, k=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: k must not be negative\n    >>> generate_all_combinations(n=-1, k=10)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must not be negative\n    >>> generate_all_combinations(n=5, k=4)\n    [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]\n    >>> generate_all_combinations(n=3, k=3)\n    [[1, 2, 3]]\n    >>> generate_all_combinations(n=3, k=1)\n    [[1], [2], [3]]\n    >>> generate_all_combinations(n=1, k=0)\n    [[]]\n    >>> generate_all_combinations(n=1, k=1)\n    [[1]]\n    >>> from itertools import combinations\n    >>> all(generate_all_combinations(n, k) == combination_lists(n, k)\n    ...     for n in range(1, 6) for k in range(1, 6))\n    True\n    \"\"\"\n    if k < 0:\n        raise ValueError(\"k must not be negative\")\n    if n < 0:\n        raise ValueError(\"n must not be negative\")\n\n    result: list[list[int]] = []\n    create_all_state(1, n, k, [], result)\n    return result",
    "docstring": "Generates all possible combinations of k numbers out of 1 ... n using backtracking.\n\n>>> generate_all_combinations(n=4, k=2)\n[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n>>> generate_all_combinations(n=0, k=0)\n[[]]\n>>> generate_all_combinations(n=10, k=-1)\nTraceback (most recent call last):\n    ...\nValueError: k must not be negative\n>>> generate_all_combinations(n=-1, k=10)\nTraceback (most recent call last):\n    ...\nValueError: n must not be negative\n>>> generate_all_combinations(n=5, k=4)\n[[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]\n>>> generate_all_combinations(n=3, k=3)\n[[1, 2, 3]]\n>>> generate_all_combinations(n=3, k=1)\n[[1], [2], [3]]\n>>> generate_all_combinations(n=1, k=0)\n[[]]\n>>> generate_all_combinations(n=1, k=1)\n[[1]]\n>>> from itertools import combinations\n>>> all(generate_all_combinations(n, k) == combination_lists(n, k)\n...     for n in range(1, 6) for k in range(1, 6))\nTrue"
  },
  {
    "function": "create_all_state",
    "code": "def create_all_state(\n    increment: int,\n    total_number: int,\n    level: int,\n    current_list: list[int],\n    total_list: list[list[int]],\n) -> None:\n    \"\"\"\n    Helper function to recursively build all combinations.\n\n    >>> create_all_state(1, 4, 2, [], result := [])\n    >>> result\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    >>> create_all_state(1, 3, 3, [], result := [])\n    >>> result\n    [[1, 2, 3]]\n    >>> create_all_state(2, 2, 1, [1], result := [])\n    >>> result\n    [[1, 2]]\n    >>> create_all_state(1, 0, 0, [], result := [])\n    >>> result\n    [[]]\n    >>> create_all_state(1, 4, 0, [1, 2], result := [])\n    >>> result\n    [[1, 2]]\n    >>> create_all_state(5, 4, 2, [1, 2], result := [])\n    >>> result\n    []\n    \"\"\"\n    if level == 0:\n        total_list.append(current_list[:])\n        return\n\n    for i in range(increment, total_number - level + 2):\n        current_list.append(i)\n        create_all_state(i + 1, total_number, level - 1, current_list, total_list)\n        current_list.pop()",
    "docstring": "Helper function to recursively build all combinations.\n\n>>> create_all_state(1, 4, 2, [], result := [])\n>>> result\n[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n>>> create_all_state(1, 3, 3, [], result := [])\n>>> result\n[[1, 2, 3]]\n>>> create_all_state(2, 2, 1, [1], result := [])\n>>> result\n[[1, 2]]\n>>> create_all_state(1, 0, 0, [], result := [])\n>>> result\n[[]]\n>>> create_all_state(1, 4, 0, [1, 2], result := [])\n>>> result\n[[1, 2]]\n>>> create_all_state(5, 4, 2, [1, 2], result := [])\n>>> result\n[]"
  },
  {
    "function": "create_state_space_tree",
    "code": "def create_state_space_tree(\n    sequence: list[int | str],\n    current_sequence: list[int | str],\n    index: int,\n    index_used: list[int],\n) -> None:\n    \"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    We know that each state has exactly len(sequence) - index children.\n    It terminates when it reaches the end of the given sequence.\n\n    :param sequence: The input sequence for which permutations are generated.\n    :param current_sequence: The current permutation being built.\n    :param index: The current index in the sequence.\n    :param index_used: list to track which elements are used in permutation.\n\n    Example 1:\n    >>> sequence = [1, 2, 3]\n    >>> current_sequence = []\n    >>> index_used = [False, False, False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    [1, 2, 3]\n    [1, 3, 2]\n    [2, 1, 3]\n    [2, 3, 1]\n    [3, 1, 2]\n    [3, 2, 1]\n\n    Example 2:\n    >>> sequence = [\"A\", \"B\", \"C\"]\n    >>> current_sequence = []\n    >>> index_used = [False, False, False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    ['A', 'B', 'C']\n    ['A', 'C', 'B']\n    ['B', 'A', 'C']\n    ['B', 'C', 'A']\n    ['C', 'A', 'B']\n    ['C', 'B', 'A']\n\n    Example 3:\n    >>> sequence = [1]\n    >>> current_sequence = []\n    >>> index_used = [False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    [1]\n    \"\"\"\n\n    if index == len(sequence):\n        print(current_sequence)\n        return\n\n    for i in range(len(sequence)):\n        if not index_used[i]:\n            current_sequence.append(sequence[i])\n            index_used[i] = True\n            create_state_space_tree(sequence, current_sequence, index + 1, index_used)\n            current_sequence.pop()\n            index_used[i] = False",
    "docstring": "Creates a state space tree to iterate through each branch using DFS.\nWe know that each state has exactly len(sequence) - index children.\nIt terminates when it reaches the end of the given sequence.\n\n:param sequence: The input sequence for which permutations are generated.\n:param current_sequence: The current permutation being built.\n:param index: The current index in the sequence.\n:param index_used: list to track which elements are used in permutation.\n\nExample 1:\n>>> sequence = [1, 2, 3]\n>>> current_sequence = []\n>>> index_used = [False, False, False]\n>>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n[1, 2, 3]\n[1, 3, 2]\n[2, 1, 3]\n[2, 3, 1]\n[3, 1, 2]\n[3, 2, 1]\n\nExample 2:\n>>> sequence = [\"A\", \"B\", \"C\"]\n>>> current_sequence = []\n>>> index_used = [False, False, False]\n>>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n['A', 'B', 'C']\n['A', 'C', 'B']\n['B', 'A', 'C']\n['B', 'C', 'A']\n['C', 'A', 'B']\n['C', 'B', 'A']\n\nExample 3:\n>>> sequence = [1]\n>>> current_sequence = []\n>>> index_used = [False]\n>>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n[1]"
  },
  {
    "function": "create_state_space_tree",
    "code": "def create_state_space_tree(\n    sequence: list[Any], current_subsequence: list[Any], index: int\n) -> None:\n    \"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    We know that each state has exactly two children.\n    It terminates when it reaches the end of the given sequence.\n\n    :param sequence: The input sequence for which subsequences are generated.\n    :param current_subsequence: The current subsequence being built.\n    :param index: The current index in the sequence.\n\n    Example:\n    >>> sequence = [3, 2, 1]\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n    [1]\n    [2]\n    [2, 1]\n    [3]\n    [3, 1]\n    [3, 2]\n    [3, 2, 1]\n\n    >>> sequence = [\"A\", \"B\"]\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n    ['B']\n    ['A']\n    ['A', 'B']\n\n    >>> sequence = []\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n\n    >>> sequence = [1, 2, 3, 4]\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n    [4]\n    [3]\n    [3, 4]\n    [2]\n    [2, 4]\n    [2, 3]\n    [2, 3, 4]\n    [1]\n    [1, 4]\n    [1, 3]\n    [1, 3, 4]\n    [1, 2]\n    [1, 2, 4]\n    [1, 2, 3]\n    [1, 2, 3, 4]\n    \"\"\"\n\n    if index == len(sequence):\n        print(current_subsequence)\n        return\n\n    create_state_space_tree(sequence, current_subsequence, index + 1)\n    current_subsequence.append(sequence[index])\n    create_state_space_tree(sequence, current_subsequence, index + 1)\n    current_subsequence.pop()",
    "docstring": "Creates a state space tree to iterate through each branch using DFS.\nWe know that each state has exactly two children.\nIt terminates when it reaches the end of the given sequence.\n\n:param sequence: The input sequence for which subsequences are generated.\n:param current_subsequence: The current subsequence being built.\n:param index: The current index in the sequence.\n\nExample:\n>>> sequence = [3, 2, 1]\n>>> current_subsequence = []\n>>> create_state_space_tree(sequence, current_subsequence, 0)\n[]\n[1]\n[2]\n[2, 1]\n[3]\n[3, 1]\n[3, 2]\n[3, 2, 1]\n\n>>> sequence = [\"A\", \"B\"]\n>>> current_subsequence = []\n>>> create_state_space_tree(sequence, current_subsequence, 0)\n[]\n['B']\n['A']\n['A', 'B']\n\n>>> sequence = []\n>>> current_subsequence = []\n>>> create_state_space_tree(sequence, current_subsequence, 0)\n[]\n\n>>> sequence = [1, 2, 3, 4]\n>>> current_subsequence = []\n>>> create_state_space_tree(sequence, current_subsequence, 0)\n[]\n[4]\n[3]\n[3, 4]\n[2]\n[2, 4]\n[2, 3]\n[2, 3, 4]\n[1]\n[1, 4]\n[1, 3]\n[1, 3, 4]\n[1, 2]\n[1, 2, 4]\n[1, 2, 3]\n[1, 2, 3, 4]"
  },
  {
    "function": "valid_coloring",
    "code": "def valid_coloring(\n    neighbours: list[int], colored_vertices: list[int], color: int\n) -> bool:\n    \"\"\"\n    For each neighbour check if the coloring constraint is satisfied\n    If any of the neighbours fail the constraint return False\n    If all neighbours validate the constraint return True\n\n    >>> neighbours = [0,1,0,1,0]\n    >>> colored_vertices = [0, 2, 1, 2, 0]\n\n    >>> color = 1\n    >>> valid_coloring(neighbours, colored_vertices, color)\n    True\n\n    >>> color = 2\n    >>> valid_coloring(neighbours, colored_vertices, color)\n    False\n    \"\"\"\n    # Does any neighbour not satisfy the constraints\n    return not any(\n        neighbour == 1 and colored_vertices[i] == color\n        for i, neighbour in enumerate(neighbours)\n    )",
    "docstring": "For each neighbour check if the coloring constraint is satisfied\nIf any of the neighbours fail the constraint return False\nIf all neighbours validate the constraint return True\n\n>>> neighbours = [0,1,0,1,0]\n>>> colored_vertices = [0, 2, 1, 2, 0]\n\n>>> color = 1\n>>> valid_coloring(neighbours, colored_vertices, color)\nTrue\n\n>>> color = 2\n>>> valid_coloring(neighbours, colored_vertices, color)\nFalse"
  },
  {
    "function": "util_color",
    "code": "def util_color(\n    graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int\n) -> bool:\n    \"\"\"\n    Pseudo-Code\n\n    Base Case:\n    1. Check if coloring is complete\n        1.1 If complete return True (meaning that we successfully colored the graph)\n\n    Recursive Step:\n    2. Iterates over each color:\n        Check if the current coloring is valid:\n            2.1. Color given vertex\n            2.2. Do recursive call, check if this coloring leads to a solution\n            2.4. if current coloring leads to a solution return\n            2.5. Uncolor given vertex\n\n    >>> graph = [[0, 1, 0, 0, 0],\n    ...          [1, 0, 1, 0, 1],\n    ...          [0, 1, 0, 1, 0],\n    ...          [0, 1, 1, 0, 0],\n    ...          [0, 1, 0, 0, 0]]\n    >>> max_colors = 3\n    >>> colored_vertices = [0, 1, 0, 0, 0]\n    >>> index = 3\n\n    >>> util_color(graph, max_colors, colored_vertices, index)\n    True\n\n    >>> max_colors = 2\n    >>> util_color(graph, max_colors, colored_vertices, index)\n    False\n    \"\"\"\n\n    # Base Case\n    if index == len(graph):\n        return True\n\n    # Recursive Step\n    for i in range(max_colors):\n        if valid_coloring(graph[index], colored_vertices, i):\n            # Color current vertex\n            colored_vertices[index] = i\n            # Validate coloring\n            if util_color(graph, max_colors, colored_vertices, index + 1):\n                return True\n            # Backtrack\n            colored_vertices[index] = -1\n    return False",
    "docstring": "Pseudo-Code\n\nBase Case:\n1. Check if coloring is complete\n    1.1 If complete return True (meaning that we successfully colored the graph)\n\nRecursive Step:\n2. Iterates over each color:\n    Check if the current coloring is valid:\n        2.1. Color given vertex\n        2.2. Do recursive call, check if this coloring leads to a solution\n        2.4. if current coloring leads to a solution return\n        2.5. Uncolor given vertex\n\n>>> graph = [[0, 1, 0, 0, 0],\n...          [1, 0, 1, 0, 1],\n...          [0, 1, 0, 1, 0],\n...          [0, 1, 1, 0, 0],\n...          [0, 1, 0, 0, 0]]\n>>> max_colors = 3\n>>> colored_vertices = [0, 1, 0, 0, 0]\n>>> index = 3\n\n>>> util_color(graph, max_colors, colored_vertices, index)\nTrue\n\n>>> max_colors = 2\n>>> util_color(graph, max_colors, colored_vertices, index)\nFalse"
  },
  {
    "function": "color",
    "code": "def color(graph: list[list[int]], max_colors: int) -> list[int]:\n    \"\"\"\n    Wrapper function to call subroutine called util_color\n    which will either return True or False.\n    If True is returned colored_vertices list is filled with correct colorings\n\n    >>> graph = [[0, 1, 0, 0, 0],\n    ...          [1, 0, 1, 0, 1],\n    ...          [0, 1, 0, 1, 0],\n    ...          [0, 1, 1, 0, 0],\n    ...          [0, 1, 0, 0, 0]]\n\n    >>> max_colors = 3\n    >>> color(graph, max_colors)\n    [0, 1, 0, 2, 0]\n\n    >>> max_colors = 2\n    >>> color(graph, max_colors)\n    []\n    \"\"\"\n    colored_vertices = [-1] * len(graph)\n\n    if util_color(graph, max_colors, colored_vertices, 0):\n        return colored_vertices\n\n    return []",
    "docstring": "Wrapper function to call subroutine called util_color\nwhich will either return True or False.\nIf True is returned colored_vertices list is filled with correct colorings\n\n>>> graph = [[0, 1, 0, 0, 0],\n...          [1, 0, 1, 0, 1],\n...          [0, 1, 0, 1, 0],\n...          [0, 1, 1, 0, 0],\n...          [0, 1, 0, 0, 0]]\n\n>>> max_colors = 3\n>>> color(graph, max_colors)\n[0, 1, 0, 2, 0]\n\n>>> max_colors = 2\n>>> color(graph, max_colors)\n[]"
  },
  {
    "function": "backtrack",
    "code": "def backtrack(\n    candidates: list, path: list, answer: list, target: int, previous_index: int\n) -> None:\n    \"\"\"\n    A recursive function that searches for possible combinations. Backtracks in case\n    of a bigger current combination value than the target value.\n\n    Parameters\n    ----------\n    previous_index: Last index from the previous search\n    target: The value we need to obtain by summing our integers in the path list.\n    answer: A list of possible combinations\n    path: Current combination\n    candidates: A list of integers we can use.\n    \"\"\"\n    if target == 0:\n        answer.append(path.copy())\n    else:\n        for index in range(previous_index, len(candidates)):\n            if target >= candidates[index]:\n                path.append(candidates[index])\n                backtrack(candidates, path, answer, target - candidates[index], index)\n                path.pop(len(path) - 1)",
    "docstring": "A recursive function that searches for possible combinations. Backtracks in case\nof a bigger current combination value than the target value.\n\nParameters\n----------\nprevious_index: Last index from the previous search\ntarget: The value we need to obtain by summing our integers in the path list.\nanswer: A list of possible combinations\npath: Current combination\ncandidates: A list of integers we can use."
  },
  {
    "function": "combination_sum",
    "code": "def combination_sum(candidates: list, target: int) -> list:\n    \"\"\"\n    >>> combination_sum([2, 3, 5], 8)\n    [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    >>> combination_sum([2, 3, 6, 7], 7)\n    [[2, 2, 3], [7]]\n    >>> combination_sum([-8, 2.3, 0], 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: All elements in candidates must be non-negative\n    >>> combination_sum([], 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Candidates list should not be empty\n    \"\"\"\n    if not candidates:\n        raise ValueError(\"Candidates list should not be empty\")\n\n    if any(x < 0 for x in candidates):\n        raise ValueError(\"All elements in candidates must be non-negative\")\n\n    path = []  # type: list[int]\n    answer = []  # type: list[int]\n    backtrack(candidates, path, answer, target, 0)\n    return answer",
    "docstring": ">>> combination_sum([2, 3, 5], 8)\n[[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n>>> combination_sum([2, 3, 6, 7], 7)\n[[2, 2, 3], [7]]\n>>> combination_sum([-8, 2.3, 0], 1)\nTraceback (most recent call last):\n    ...\nValueError: All elements in candidates must be non-negative\n>>> combination_sum([], 1)\nTraceback (most recent call last):\n    ...\nValueError: Candidates list should not be empty"
  },
  {
    "function": "is_valid",
    "code": "def is_valid(\n    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool\n) -> bool:\n    \"\"\"\n    Check if a word can be placed at the given position.\n\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n    >>> is_valid(puzzle, 'word', 0, 0, True)\n    True\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n    >>> is_valid(puzzle, 'word', 0, 0, False)\n    True\n    \"\"\"\n    for i in range(len(word)):\n        if vertical:\n            if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":\n                return False\n        elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":\n            return False\n    return True",
    "docstring": "Check if a word can be placed at the given position.\n\n>>> puzzle = [\n...     ['', '', '', ''],\n...     ['', '', '', ''],\n...     ['', '', '', ''],\n...     ['', '', '', '']\n... ]\n>>> is_valid(puzzle, 'word', 0, 0, True)\nTrue\n>>> puzzle = [\n...     ['', '', '', ''],\n...     ['', '', '', ''],\n...     ['', '', '', ''],\n...     ['', '', '', '']\n... ]\n>>> is_valid(puzzle, 'word', 0, 0, False)\nTrue"
  },
  {
    "function": "place_word",
    "code": "def place_word(\n    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool\n) -> None:\n    \"\"\"\n    Place a word at the given position.\n\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n    >>> place_word(puzzle, 'word', 0, 0, True)\n    >>> puzzle\n    [['w', '', '', ''], ['o', '', '', ''], ['r', '', '', ''], ['d', '', '', '']]\n    \"\"\"\n    for i, char in enumerate(word):\n        if vertical:\n            puzzle[row + i][col] = char\n        else:\n            puzzle[row][col + i] = char",
    "docstring": "Place a word at the given position.\n\n>>> puzzle = [\n...     ['', '', '', ''],\n...     ['', '', '', ''],\n...     ['', '', '', ''],\n...     ['', '', '', '']\n... ]\n>>> place_word(puzzle, 'word', 0, 0, True)\n>>> puzzle\n[['w', '', '', ''], ['o', '', '', ''], ['r', '', '', ''], ['d', '', '', '']]"
  },
  {
    "function": "remove_word",
    "code": "def remove_word(\n    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool\n) -> None:\n    \"\"\"\n    Remove a word from the given position.\n\n    >>> puzzle = [\n    ...     ['w', '', '', ''],\n    ...     ['o', '', '', ''],\n    ...     ['r', '', '', ''],\n    ...     ['d', '', '', '']\n    ... ]\n    >>> remove_word(puzzle, 'word', 0, 0, True)\n    >>> puzzle\n    [['', '', '', ''], ['', '', '', ''], ['', '', '', ''], ['', '', '', '']]\n    \"\"\"\n    for i in range(len(word)):\n        if vertical:\n            puzzle[row + i][col] = \"\"\n        else:\n            puzzle[row][col + i] = \"\"",
    "docstring": "Remove a word from the given position.\n\n>>> puzzle = [\n...     ['w', '', '', ''],\n...     ['o', '', '', ''],\n...     ['r', '', '', ''],\n...     ['d', '', '', '']\n... ]\n>>> remove_word(puzzle, 'word', 0, 0, True)\n>>> puzzle\n[['', '', '', ''], ['', '', '', ''], ['', '', '', ''], ['', '', '', '']]"
  },
  {
    "function": "solve_crossword",
    "code": "def solve_crossword(puzzle: list[list[str]], words: list[str]) -> bool:\n    \"\"\"\n    Solve the crossword puzzle using backtracking.\n\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n\n    >>> words = ['word', 'four', 'more', 'last']\n    >>> solve_crossword(puzzle, words)\n    True\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n    >>> words = ['word', 'four', 'more', 'paragraphs']\n    >>> solve_crossword(puzzle, words)\n    False\n    \"\"\"\n    for row in range(len(puzzle)):\n        for col in range(len(puzzle[0])):\n            if puzzle[row][col] == \"\":\n                for word in words:\n                    for vertical in [True, False]:\n                        if is_valid(puzzle, word, row, col, vertical):\n                            place_word(puzzle, word, row, col, vertical)\n                            words.remove(word)\n                            if solve_crossword(puzzle, words):\n                                return True\n                            words.append(word)\n                            remove_word(puzzle, word, row, col, vertical)\n                return False\n    return True",
    "docstring": "Solve the crossword puzzle using backtracking.\n\n>>> puzzle = [\n...     ['', '', '', ''],\n...     ['', '', '', ''],\n...     ['', '', '', ''],\n...     ['', '', '', '']\n... ]\n\n>>> words = ['word', 'four', 'more', 'last']\n>>> solve_crossword(puzzle, words)\nTrue\n>>> puzzle = [\n...     ['', '', '', ''],\n...     ['', '', '', ''],\n...     ['', '', '', ''],\n...     ['', '', '', '']\n... ]\n>>> words = ['word', 'four', 'more', 'paragraphs']\n>>> solve_crossword(puzzle, words)\nFalse"
  },
  {
    "function": "backtrack",
    "code": "def backtrack(\n    partial: str, open_count: int, close_count: int, n: int, result: list[str]\n) -> None:\n    \"\"\"\n    Generate valid combinations of balanced parentheses using recursion.\n\n    :param partial: A string representing the current combination.\n    :param open_count: An integer representing the count of open parentheses.\n    :param close_count: An integer representing the count of close parentheses.\n    :param n: An integer representing the total number of pairs.\n    :param result: A list to store valid combinations.\n    :return: None\n\n    This function uses recursion to explore all possible combinations,\n    ensuring that at each step, the parentheses remain balanced.\n\n    Example:\n    >>> result = []\n    >>> backtrack(\"\", 0, 0, 2, result)\n    >>> result\n    ['(())', '()()']\n    \"\"\"\n    if len(partial) == 2 * n:\n        # When the combination is complete, add it to the result.\n        result.append(partial)\n        return\n\n    if open_count < n:\n        # If we can add an open parenthesis, do so, and recurse.\n        backtrack(partial + \"(\", open_count + 1, close_count, n, result)\n\n    if close_count < open_count:\n        # If we can add a close parenthesis (it won't make the combination invalid),\n        # do so, and recurse.\n        backtrack(partial + \")\", open_count, close_count + 1, n, result)",
    "docstring": "Generate valid combinations of balanced parentheses using recursion.\n\n:param partial: A string representing the current combination.\n:param open_count: An integer representing the count of open parentheses.\n:param close_count: An integer representing the count of close parentheses.\n:param n: An integer representing the total number of pairs.\n:param result: A list to store valid combinations.\n:return: None\n\nThis function uses recursion to explore all possible combinations,\nensuring that at each step, the parentheses remain balanced.\n\nExample:\n>>> result = []\n>>> backtrack(\"\", 0, 0, 2, result)\n>>> result\n['(())', '()()']"
  },
  {
    "function": "generate_parenthesis",
    "code": "def generate_parenthesis(n: int) -> list[str]:\n    \"\"\"\n    Generate valid combinations of balanced parentheses for a given n.\n\n    :param n: An integer representing the number of pairs of parentheses.\n    :return: A list of strings with valid combinations.\n\n    This function uses a recursive approach to generate the combinations.\n\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\n    Space Complexity: O(n) - where 'n' is the number of pairs.\n\n    Example 1:\n    >>> generate_parenthesis(3)\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Example 2:\n    >>> generate_parenthesis(1)\n    ['()']\n    \"\"\"\n\n    result: list[str] = []\n    backtrack(\"\", 0, 0, n, result)\n    return result",
    "docstring": "Generate valid combinations of balanced parentheses for a given n.\n\n:param n: An integer representing the number of pairs of parentheses.\n:return: A list of strings with valid combinations.\n\nThis function uses a recursive approach to generate the combinations.\n\nTime Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\nSpace Complexity: O(n) - where 'n' is the number of pairs.\n\nExample 1:\n>>> generate_parenthesis(3)\n['((()))', '(()())', '(())()', '()(())', '()()()']\n\nExample 2:\n>>> generate_parenthesis(1)\n['()']"
  },
  {
    "function": "generate_parentheses_iterative",
    "code": "def generate_parentheses_iterative(length: int) -> list:\n    \"\"\"\n    Generate all valid combinations of parentheses (Iterative Approach).\n\n    The algorithm works as follows:\n    1. Initialize an empty list to store the combinations.\n    2. Initialize a stack to keep track of partial combinations.\n    3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n    4. While the stack is not empty:\n        a. Pop a partial combination and its open and close counts from the stack.\n        b. If the combination length is equal to 2*length, add it to the result.\n        c. If open count < length, push new combination with added '(' on stack.\n        d. If close count < open count, push new combination with added ')' on stack.\n    5. Return the result containing all valid combinations.\n\n    Args:\n        length: The desired length of the parentheses combinations\n\n    Returns:\n        A list of strings representing valid combinations of parentheses\n\n    Time Complexity:\n        O(2^(2*length))\n\n    Space Complexity:\n        O(2^(2*length))\n\n    >>> generate_parentheses_iterative(3)\n    ['()()()', '()(())', '(())()', '(()())', '((()))']\n    >>> generate_parentheses_iterative(2)\n    ['()()', '(())']\n    >>> generate_parentheses_iterative(1)\n    ['()']\n    >>> generate_parentheses_iterative(0)\n    ['']\n    \"\"\"\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result",
    "docstring": "Generate all valid combinations of parentheses (Iterative Approach).\n\nThe algorithm works as follows:\n1. Initialize an empty list to store the combinations.\n2. Initialize a stack to keep track of partial combinations.\n3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n4. While the stack is not empty:\n    a. Pop a partial combination and its open and close counts from the stack.\n    b. If the combination length is equal to 2*length, add it to the result.\n    c. If open count < length, push new combination with added '(' on stack.\n    d. If close count < open count, push new combination with added ')' on stack.\n5. Return the result containing all valid combinations.\n\nArgs:\n    length: The desired length of the parentheses combinations\n\nReturns:\n    A list of strings representing valid combinations of parentheses\n\nTime Complexity:\n    O(2^(2*length))\n\nSpace Complexity:\n    O(2^(2*length))\n\n>>> generate_parentheses_iterative(3)\n['()()()', '()(())', '(())()', '(()())', '((()))']\n>>> generate_parentheses_iterative(2)\n['()()', '(())']\n>>> generate_parentheses_iterative(1)\n['()']\n>>> generate_parentheses_iterative(0)\n['']"
  },
  {
    "function": "valid_connection",
    "code": "def valid_connection(\n    graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int]\n) -> bool:\n    \"\"\"\n    Checks whether it is possible to add next into path by validating 2 statements\n    1. There should be path between current and next vertex\n    2. Next vertex should not be in path\n    If both validations succeed we return True, saying that it is possible to connect\n    this vertices, otherwise we return False\n\n    Case 1:Use exact graph as in main function, with initialized values\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 1],\n    ...          [0, 1, 1, 1, 0]]\n    >>> path = [0, -1, -1, -1, -1, 0]\n    >>> curr_ind = 1\n    >>> next_ver = 1\n    >>> valid_connection(graph, next_ver, curr_ind, path)\n    True\n\n    Case 2: Same graph, but trying to connect to node that is already in path\n    >>> path = [0, 1, 2, 4, -1, 0]\n    >>> curr_ind = 4\n    >>> next_ver = 1\n    >>> valid_connection(graph, next_ver, curr_ind, path)\n    False\n    \"\"\"\n\n    # 1. Validate that path exists between current and next vertices\n    if graph[path[curr_ind - 1]][next_ver] == 0:\n        return False\n\n    # 2. Validate that next vertex is not already in path\n    return not any(vertex == next_ver for vertex in path)",
    "docstring": "Checks whether it is possible to add next into path by validating 2 statements\n1. There should be path between current and next vertex\n2. Next vertex should not be in path\nIf both validations succeed we return True, saying that it is possible to connect\nthis vertices, otherwise we return False\n\nCase 1:Use exact graph as in main function, with initialized values\n>>> graph = [[0, 1, 0, 1, 0],\n...          [1, 0, 1, 1, 1],\n...          [0, 1, 0, 0, 1],\n...          [1, 1, 0, 0, 1],\n...          [0, 1, 1, 1, 0]]\n>>> path = [0, -1, -1, -1, -1, 0]\n>>> curr_ind = 1\n>>> next_ver = 1\n>>> valid_connection(graph, next_ver, curr_ind, path)\nTrue\n\nCase 2: Same graph, but trying to connect to node that is already in path\n>>> path = [0, 1, 2, 4, -1, 0]\n>>> curr_ind = 4\n>>> next_ver = 1\n>>> valid_connection(graph, next_ver, curr_ind, path)\nFalse"
  },
  {
    "function": "util_hamilton_cycle",
    "code": "def util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:\n    \"\"\"\n    Pseudo-Code\n    Base Case:\n    1. Check if we visited all of vertices\n        1.1 If last visited vertex has path to starting vertex return True either\n            return False\n    Recursive Step:\n    2. Iterate over each vertex\n        Check if next vertex is valid for transiting from current vertex\n            2.1 Remember next vertex as next transition\n            2.2 Do recursive call and check if going to this vertex solves problem\n            2.3 If next vertex leads to solution return True\n            2.4 Else backtrack, delete remembered vertex\n\n    Case 1: Use exact graph as in main function, with initialized values\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 1],\n    ...          [0, 1, 1, 1, 0]]\n    >>> path = [0, -1, -1, -1, -1, 0]\n    >>> curr_ind = 1\n    >>> util_hamilton_cycle(graph, path, curr_ind)\n    True\n    >>> path\n    [0, 1, 2, 4, 3, 0]\n\n    Case 2: Use exact graph as in previous case, but in the properties taken from\n        middle of calculation\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 1],\n    ...          [0, 1, 1, 1, 0]]\n    >>> path = [0, 1, 2, -1, -1, 0]\n    >>> curr_ind = 3\n    >>> util_hamilton_cycle(graph, path, curr_ind)\n    True\n    >>> path\n    [0, 1, 2, 4, 3, 0]\n    \"\"\"\n\n    # Base Case\n    if curr_ind == len(graph):\n        # return whether path exists between current and starting vertices\n        return graph[path[curr_ind - 1]][path[0]] == 1\n\n    # Recursive Step\n    for next_ver in range(len(graph)):\n        if valid_connection(graph, next_ver, curr_ind, path):\n            # Insert current vertex  into path as next transition\n            path[curr_ind] = next_ver\n            # Validate created path\n            if util_hamilton_cycle(graph, path, curr_ind + 1):\n                return True\n            # Backtrack\n            path[curr_ind] = -1\n    return False",
    "docstring": "Pseudo-Code\nBase Case:\n1. Check if we visited all of vertices\n    1.1 If last visited vertex has path to starting vertex return True either\n        return False\nRecursive Step:\n2. Iterate over each vertex\n    Check if next vertex is valid for transiting from current vertex\n        2.1 Remember next vertex as next transition\n        2.2 Do recursive call and check if going to this vertex solves problem\n        2.3 If next vertex leads to solution return True\n        2.4 Else backtrack, delete remembered vertex\n\nCase 1: Use exact graph as in main function, with initialized values\n>>> graph = [[0, 1, 0, 1, 0],\n...          [1, 0, 1, 1, 1],\n...          [0, 1, 0, 0, 1],\n...          [1, 1, 0, 0, 1],\n...          [0, 1, 1, 1, 0]]\n>>> path = [0, -1, -1, -1, -1, 0]\n>>> curr_ind = 1\n>>> util_hamilton_cycle(graph, path, curr_ind)\nTrue\n>>> path\n[0, 1, 2, 4, 3, 0]\n\nCase 2: Use exact graph as in previous case, but in the properties taken from\n    middle of calculation\n>>> graph = [[0, 1, 0, 1, 0],\n...          [1, 0, 1, 1, 1],\n...          [0, 1, 0, 0, 1],\n...          [1, 1, 0, 0, 1],\n...          [0, 1, 1, 1, 0]]\n>>> path = [0, 1, 2, -1, -1, 0]\n>>> curr_ind = 3\n>>> util_hamilton_cycle(graph, path, curr_ind)\nTrue\n>>> path\n[0, 1, 2, 4, 3, 0]"
  },
  {
    "function": "hamilton_cycle",
    "code": "def hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:\n    r\"\"\"\n    Wrapper function to call subroutine called util_hamilton_cycle,\n    which will either return array of vertices indicating hamiltonian cycle\n    or an empty list indicating that hamiltonian cycle was not found.\n    Case 1:\n    Following graph consists of 5 edges.\n    If we look closely, we can see that there are multiple Hamiltonian cycles.\n    For example one result is when we iterate like:\n    (0)->(1)->(2)->(4)->(3)->(0)\n\n    (0)---(1)---(2)\n     |   /   \\   |\n     |  /     \\  |\n     | /       \\ |\n     |/         \\|\n    (3)---------(4)\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 1],\n    ...          [0, 1, 1, 1, 0]]\n    >>> hamilton_cycle(graph)\n    [0, 1, 2, 4, 3, 0]\n\n    Case 2:\n    Same Graph as it was in Case 1, changed starting index from default to 3\n\n    (0)---(1)---(2)\n     |   /   \\   |\n     |  /     \\  |\n     | /       \\ |\n     |/         \\|\n    (3)---------(4)\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 1],\n    ...          [0, 1, 1, 1, 0]]\n    >>> hamilton_cycle(graph, 3)\n    [3, 0, 1, 2, 4, 3]\n\n    Case 3:\n    Following Graph is exactly what it was before, but edge 3-4 is removed.\n    Result is that there is no Hamiltonian Cycle anymore.\n\n    (0)---(1)---(2)\n     |   /   \\   |\n     |  /     \\  |\n     | /       \\ |\n     |/         \\|\n    (3)         (4)\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 0],\n    ...          [0, 1, 1, 0, 0]]\n    >>> hamilton_cycle(graph,4)\n    []\n    \"\"\"\n\n    # Initialize path with -1, indicating that we have not visited them yet\n    path = [-1] * (len(graph) + 1)\n    # initialize start and end of path with starting index\n    path[0] = path[-1] = start_index\n    # evaluate and if we find answer return path either return empty array\n    return path if util_hamilton_cycle(graph, path, 1) else []",
    "docstring": "Wrapper function to call subroutine called util_hamilton_cycle,\nwhich will either return array of vertices indicating hamiltonian cycle\nor an empty list indicating that hamiltonian cycle was not found.\nCase 1:\nFollowing graph consists of 5 edges.\nIf we look closely, we can see that there are multiple Hamiltonian cycles.\nFor example one result is when we iterate like:\n(0)->(1)->(2)->(4)->(3)->(0)\n\n(0)---(1)---(2)\n |   /   \\   |\n |  /     \\  |\n | /       \\ |\n |/         \\|\n(3)---------(4)\n>>> graph = [[0, 1, 0, 1, 0],\n...          [1, 0, 1, 1, 1],\n...          [0, 1, 0, 0, 1],\n...          [1, 1, 0, 0, 1],\n...          [0, 1, 1, 1, 0]]\n>>> hamilton_cycle(graph)\n[0, 1, 2, 4, 3, 0]\n\nCase 2:\nSame Graph as it was in Case 1, changed starting index from default to 3\n\n(0)---(1)---(2)\n |   /   \\   |\n |  /     \\  |\n | /       \\ |\n |/         \\|\n(3)---------(4)\n>>> graph = [[0, 1, 0, 1, 0],\n...          [1, 0, 1, 1, 1],\n...          [0, 1, 0, 0, 1],\n...          [1, 1, 0, 0, 1],\n...          [0, 1, 1, 1, 0]]\n>>> hamilton_cycle(graph, 3)\n[3, 0, 1, 2, 4, 3]\n\nCase 3:\nFollowing Graph is exactly what it was before, but edge 3-4 is removed.\nResult is that there is no Hamiltonian Cycle anymore.\n\n(0)---(1)---(2)\n |   /   \\   |\n |  /     \\  |\n | /       \\ |\n |/         \\|\n(3)         (4)\n>>> graph = [[0, 1, 0, 1, 0],\n...          [1, 0, 1, 1, 1],\n...          [0, 1, 0, 0, 1],\n...          [1, 1, 0, 0, 0],\n...          [0, 1, 1, 0, 0]]\n>>> hamilton_cycle(graph,4)\n[]"
  },
  {
    "function": "get_valid_pos",
    "code": "def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for inner_position in positions:\n        y_test, x_test = inner_position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(inner_position)\n\n    return permissible_positions",
    "docstring": "Find all the valid positions a knight can move to from the current position.\n\n>>> get_valid_pos((1, 3), 4)\n[(2, 1), (0, 1), (3, 2)]"
  },
  {
    "function": "is_complete",
    "code": "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)",
    "docstring": "Check if the board (matrix) has been completely filled with non-zero values.\n\n>>> is_complete([[1]])\nTrue\n\n>>> is_complete([[1, 2], [3, 0]])\nFalse"
  },
  {
    "function": "open_knight_tour_helper",
    "code": "def open_knight_tour_helper(\n    board: list[list[int]], pos: tuple[int, int], curr: int\n) -> bool:\n    \"\"\"\n    Helper function to solve knight tour problem.\n    \"\"\"\n\n    if is_complete(board):\n        return True\n\n    for position in get_valid_pos(pos, len(board)):\n        y, x = position\n\n        if board[y][x] == 0:\n            board[y][x] = curr + 1\n            if open_knight_tour_helper(board, position, curr + 1):\n                return True\n            board[y][x] = 0\n\n    return False",
    "docstring": "Helper function to solve knight tour problem."
  },
  {
    "function": "open_knight_tour",
    "code": "def open_knight_tour(n: int) -> list[list[int]]:\n    \"\"\"\n    Find the solution for the knight tour problem for a board of size n. Raises\n    ValueError if the tour cannot be performed for the given size.\n\n    >>> open_knight_tour(1)\n    [[1]]\n\n    >>> open_knight_tour(2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Open Knight Tour cannot be performed on a board of size 2\n    \"\"\"\n\n    board = [[0 for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 1\n            if open_knight_tour_helper(board, (i, j), 1):\n                return board\n            board[i][j] = 0\n\n    msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"\n    raise ValueError(msg)",
    "docstring": "Find the solution for the knight tour problem for a board of size n. Raises\nValueError if the tour cannot be performed for the given size.\n\n>>> open_knight_tour(1)\n[[1]]\n\n>>> open_knight_tour(2)\nTraceback (most recent call last):\n    ...\nValueError: Open Knight Tour cannot be performed on a board of size 2"
  },
  {
    "function": "match_word_pattern",
    "code": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)",
    "docstring": "Determine if a given pattern matches a string using backtracking.\n\npattern: The pattern to match.\ninput_string: The string to match against the pattern.\nreturn: True if the pattern matches the string, False otherwise.\n\n>>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\nTrue\n\n>>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\nTrue\n\n>>> match_word_pattern(\"GG\", \"PythonJavaPython\")\nFalse"
  },
  {
    "function": "minimax",
    "code": "def minimax(\n    depth: int, node_index: int, is_max: bool, scores: list[int], height: float\n) -> int:\n    \"\"\"\n    This function implements the minimax algorithm, which helps achieve the optimal\n    score for a player in a two-player game by checking all possible moves.\n    If the player is the maximizer, then the score is maximized.\n    If the player is the minimizer, then the score is minimized.\n\n    Parameters:\n    - depth: Current depth in the game tree.\n    - node_index: Index of the current node in the scores list.\n    - is_max: A boolean indicating whether the current move\n              is for the maximizer (True) or minimizer (False).\n    - scores: A list containing the scores of the leaves of the game tree.\n    - height: The maximum height of the game tree.\n\n    Returns:\n    - An integer representing the optimal score for the current player.\n\n    >>> import math\n    >>> scores = [90, 23, 6, 33, 21, 65, 123, 34423]\n    >>> height = math.log(len(scores), 2)\n    >>> minimax(0, 0, True, scores, height)\n    65\n    >>> minimax(-1, 0, True, scores, height)\n    Traceback (most recent call last):\n        ...\n    ValueError: Depth cannot be less than 0\n    >>> minimax(0, 0, True, [], 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Scores cannot be empty\n    >>> scores = [3, 5, 2, 9, 12, 5, 23, 23]\n    >>> height = math.log(len(scores), 2)\n    >>> minimax(0, 0, True, scores, height)\n    12\n    \"\"\"\n\n    if depth < 0:\n        raise ValueError(\"Depth cannot be less than 0\")\n    if len(scores) == 0:\n        raise ValueError(\"Scores cannot be empty\")\n\n    # Base case: If the current depth equals the height of the tree,\n    # return the score of the current node.\n    if depth == height:\n        return scores[node_index]\n\n    # If it's the maximizer's turn, choose the maximum score\n    # between the two possible moves.\n    if is_max:\n        return max(\n            minimax(depth + 1, node_index * 2, False, scores, height),\n            minimax(depth + 1, node_index * 2 + 1, False, scores, height),\n        )\n\n    # If it's the minimizer's turn, choose the minimum score\n    # between the two possible moves.\n    return min(\n        minimax(depth + 1, node_index * 2, True, scores, height),\n        minimax(depth + 1, node_index * 2 + 1, True, scores, height),\n    )",
    "docstring": "This function implements the minimax algorithm, which helps achieve the optimal\nscore for a player in a two-player game by checking all possible moves.\nIf the player is the maximizer, then the score is maximized.\nIf the player is the minimizer, then the score is minimized.\n\nParameters:\n- depth: Current depth in the game tree.\n- node_index: Index of the current node in the scores list.\n- is_max: A boolean indicating whether the current move\n          is for the maximizer (True) or minimizer (False).\n- scores: A list containing the scores of the leaves of the game tree.\n- height: The maximum height of the game tree.\n\nReturns:\n- An integer representing the optimal score for the current player.\n\n>>> import math\n>>> scores = [90, 23, 6, 33, 21, 65, 123, 34423]\n>>> height = math.log(len(scores), 2)\n>>> minimax(0, 0, True, scores, height)\n65\n>>> minimax(-1, 0, True, scores, height)\nTraceback (most recent call last):\n    ...\nValueError: Depth cannot be less than 0\n>>> minimax(0, 0, True, [], 2)\nTraceback (most recent call last):\n    ...\nValueError: Scores cannot be empty\n>>> scores = [3, 5, 2, 9, 12, 5, 23, 23]\n>>> height = math.log(len(scores), 2)\n>>> minimax(0, 0, True, scores, height)\n12"
  },
  {
    "function": "is_safe",
    "code": "def is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same upper column,\n    # left upper diagonal and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))\n        )\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))\n        )\n    )",
    "docstring": "This function returns a boolean value True if it is safe to place a queen there\nconsidering the current state of the board.\n\nParameters:\nboard (2D matrix): The chessboard\nrow, column: Coordinates of the cell on the board\n\nReturns:\nBoolean Value\n\n>>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\nTrue\n>>> is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\nFalse\n>>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\nFalse\n>>> is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1)\nFalse"
  },
  {
    "function": "solve",
    "code": "def solve(board: list[list[int]], row: int) -> bool:\n    \"\"\"\n    This function creates a state space tree and calls the safe function until it\n    receives a False Boolean and terminates that branch and backtracks to the next\n    possible solution branch.\n    \"\"\"\n    if row >= len(board):\n        \"\"\"\n        If the row number exceeds N, we have a board with a successful combination\n        and that combination is appended to the solution list and the board is printed.\n        \"\"\"\n        solution.append(board)\n        printboard(board)\n        print()\n        return True\n    for i in range(len(board)):\n        \"\"\"\n        For every row, it iterates through each column to check if it is feasible to\n        place a queen there.\n        If all the combinations for that particular branch are successful, the board is\n        reinitialized for the next possible combination.\n        \"\"\"\n        if is_safe(board, row, i):\n            board[row][i] = 1\n            solve(board, row + 1)\n            board[row][i] = 0\n    return False",
    "docstring": "This function creates a state space tree and calls the safe function until it\nreceives a False Boolean and terminates that branch and backtracks to the next\npossible solution branch."
  },
  {
    "function": "printboard",
    "code": "def printboard(board: list[list[int]]) -> None:\n    \"\"\"\n    Prints the boards that have a successful combination.\n    \"\"\"\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 1:\n                print(\"Q\", end=\" \")  # Queen is present\n            else:\n                print(\".\", end=\" \")  # Empty cell\n        print()",
    "docstring": "Prints the boards that have a successful combination."
  },
  {
    "function": "depth_first_search",
    "code": "def depth_first_search(\n    possible_board: list[int],\n    diagonal_right_collisions: list[int],\n    diagonal_left_collisions: list[int],\n    boards: list[list[str]],\n    n: int,\n) -> None:\n    \"\"\"\n    >>> boards = []\n    >>> depth_first_search([], [], [], boards, 4)\n    >>> for board in boards:\n    ...     print(board)\n    ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n    ['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']\n    \"\"\"\n\n    # Get next row in the current board (possible_board) to fill it with a queen\n    row = len(possible_board)\n\n    # If row is equal to the size of the board it means there are a queen in each row in\n    # the current board (possible_board)\n    if row == n:\n        # We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n        # this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n        boards.append([\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board])\n        return\n\n    # We iterate each column in the row to find all possible results in each row\n    for col in range(n):\n        # We apply that we learned previously. First we check that in the current board\n        # (possible_board) there are not other same value because if there is it means\n        # that there are a collision in vertical. Then we apply the two formulas we\n        # learned before:\n        #\n        # 45\u00ba: y - x = b or 45: row - col = b\n        # 135\u00ba: y + x = b or row + col = b.\n        #\n        # And we verify if the results of this two formulas not exist in their variables\n        # respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n        #\n        # If any or these are True it means there is a collision so we continue to the\n        # next value in the for loop.\n        if (\n            col in possible_board\n            or row - col in diagonal_right_collisions\n            or row + col in diagonal_left_collisions\n        ):\n            continue\n\n        # If it is False we call dfs function again and we update the inputs\n        depth_first_search(\n            [*possible_board, col],\n            [*diagonal_right_collisions, row - col],\n            [*diagonal_left_collisions, row + col],\n            boards,\n            n,\n        )",
    "docstring": ">>> boards = []\n>>> depth_first_search([], [], [], boards, 4)\n>>> for board in boards:\n...     print(board)\n['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']"
  },
  {
    "function": "backtrack",
    "code": "def backtrack(\n    needed_sum: int,\n    power: int,\n    current_number: int,\n    current_sum: int,\n    solutions_count: int,\n) -> tuple[int, int]:\n    \"\"\"\n    >>> backtrack(13, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(10, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(10, 3, 1, 0, 0)\n    (0, 0)\n    >>> backtrack(20, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(15, 10, 1, 0, 0)\n    (0, 0)\n    >>> backtrack(16, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(20, 1, 1, 0, 0)\n    (0, 64)\n    \"\"\"\n    if current_sum == needed_sum:\n        # If the sum of the powers is equal to needed_sum, then we have a solution.\n        solutions_count += 1\n        return current_sum, solutions_count\n\n    i_to_n = current_number**power\n    if current_sum + i_to_n <= needed_sum:\n        # If the sum of the powers is less than needed_sum, then continue adding powers.\n        current_sum += i_to_n\n        current_sum, solutions_count = backtrack(\n            needed_sum, power, current_number + 1, current_sum, solutions_count\n        )\n        current_sum -= i_to_n\n    if i_to_n < needed_sum:\n        # If the power of i is less than needed_sum, then try with the next power.\n        current_sum, solutions_count = backtrack(\n            needed_sum, power, current_number + 1, current_sum, solutions_count\n        )\n    return current_sum, solutions_count",
    "docstring": ">>> backtrack(13, 2, 1, 0, 0)\n(0, 1)\n>>> backtrack(10, 2, 1, 0, 0)\n(0, 1)\n>>> backtrack(10, 3, 1, 0, 0)\n(0, 0)\n>>> backtrack(20, 2, 1, 0, 0)\n(0, 1)\n>>> backtrack(15, 10, 1, 0, 0)\n(0, 0)\n>>> backtrack(16, 2, 1, 0, 0)\n(0, 1)\n>>> backtrack(20, 1, 1, 0, 0)\n(0, 64)"
  },
  {
    "function": "solve",
    "code": "def solve(needed_sum: int, power: int) -> int:\n    \"\"\"\n    >>> solve(13, 2)\n    1\n    >>> solve(10, 2)\n    1\n    >>> solve(10, 3)\n    0\n    >>> solve(20, 2)\n    1\n    >>> solve(15, 10)\n    0\n    >>> solve(16, 2)\n    1\n    >>> solve(20, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    >>> solve(-10, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    \"\"\"\n    if not (1 <= needed_sum <= 1000 and 2 <= power <= 10):\n        raise ValueError(\n            \"Invalid input\\n\"\n            \"needed_sum must be between 1 and 1000, power between 2 and 10.\"\n        )\n\n    return backtrack(needed_sum, power, 1, 0, 0)[1]  # Return the solutions_count",
    "docstring": ">>> solve(13, 2)\n1\n>>> solve(10, 2)\n1\n>>> solve(10, 3)\n0\n>>> solve(20, 2)\n1\n>>> solve(15, 10)\n0\n>>> solve(16, 2)\n1\n>>> solve(20, 1)\nTraceback (most recent call last):\n    ...\nValueError: Invalid input\nneeded_sum must be between 1 and 1000, power between 2 and 10.\n>>> solve(-10, 5)\nTraceback (most recent call last):\n    ...\nValueError: Invalid input\nneeded_sum must be between 1 and 1000, power between 2 and 10."
  },
  {
    "function": "solve_maze",
    "code": "def solve_maze(\n    maze: list[list[int]],\n    source_row: int,\n    source_column: int,\n    destination_row: int,\n    destination_column: int,\n) -> list[list[int]]:\n    \"\"\"\n    This method solves the \"rat in maze\" problem.\n    Parameters :\n        - maze: A two dimensional matrix of zeros and ones.\n        - source_row: The row index of the starting point.\n        - source_column: The column index of the starting point.\n        - destination_row: The row index of the destination point.\n        - destination_column: The column index of the destination point.\n    Returns:\n        - solution: A 2D matrix representing the solution path if it exists.\n    Raises:\n        - ValueError: If no solution exists or if the source or\n            destination coordinates are invalid.\n    Description:\n        This method navigates through a maze represented as an n by n matrix,\n        starting from a specified source cell and\n        aiming to reach a destination cell.\n        The maze consists of walls (1s) and open paths (0s).\n        By providing custom row and column values, the source and destination\n        cells can be adjusted.\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [1, 0, 1, 0, 1],\n    ...         [0, 0, 1, 0, 0],\n    ...         [1, 0, 0, 1, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 1],\n    [1, 1, 1, 0, 1],\n    [1, 1, 1, 0, 0],\n    [1, 1, 1, 1, 0]]\n\n    Note:\n        In the output maze, the zeros (0s) represent one of the possible\n        paths from the source to the destination.\n\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 0]]\n\n    >>> maze = [[0, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[1, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\n    ...         [1, 0, 1, 0, 0, 1, 1, 1],\n    ...         [0, 1, 0, 1, 0, 0, 1, 0],\n    ...         [1, 1, 1, 0, 0, 1, 0, 1],\n    ...         [0, 1, 0, 0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 1, 1, 1, 0, 1],\n    ...         [0, 1, 0, 1, 0, 1, 1, 1],\n    ...         [1, 1, 0, 0, 0, 0, 0, 1]]\n    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\n    [[1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1]]\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 1],\n    ...         [1, 0, 1]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 0],\n    ...         [1, 1]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 1],\n    ...         [1, 0]]\n    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n    \"\"\"\n    size = len(maze)\n    # Check if source and destination coordinates are Invalid.\n    if not (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1) or (\n        not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1)\n    ):\n        raise ValueError(\"Invalid source or destination coordinates\")\n    # We need to create solution object to save path.\n    solutions = [[1 for _ in range(size)] for _ in range(size)]\n    solved = run_maze(\n        maze, source_row, source_column, destination_row, destination_column, solutions\n    )\n    if solved:\n        return solutions\n    else:\n        raise ValueError(\"No solution exists!\")",
    "docstring": "This method solves the \"rat in maze\" problem.\nParameters :\n    - maze: A two dimensional matrix of zeros and ones.\n    - source_row: The row index of the starting point.\n    - source_column: The column index of the starting point.\n    - destination_row: The row index of the destination point.\n    - destination_column: The column index of the destination point.\nReturns:\n    - solution: A 2D matrix representing the solution path if it exists.\nRaises:\n    - ValueError: If no solution exists or if the source or\n        destination coordinates are invalid.\nDescription:\n    This method navigates through a maze represented as an n by n matrix,\n    starting from a specified source cell and\n    aiming to reach a destination cell.\n    The maze consists of walls (1s) and open paths (0s).\n    By providing custom row and column values, the source and destination\n    cells can be adjusted.\n>>> maze = [[0, 1, 0, 1, 1],\n...         [0, 0, 0, 0, 0],\n...         [1, 0, 1, 0, 1],\n...         [0, 0, 1, 0, 0],\n...         [1, 0, 0, 1, 0]]\n>>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n[[0, 1, 1, 1, 1],\n[0, 0, 0, 0, 1],\n[1, 1, 1, 0, 1],\n[1, 1, 1, 0, 0],\n[1, 1, 1, 1, 0]]\n\nNote:\n    In the output maze, the zeros (0s) represent one of the possible\n    paths from the source to the destination.\n\n>>> maze = [[0, 1, 0, 1, 1],\n...         [0, 0, 0, 0, 0],\n...         [0, 0, 0, 0, 1],\n...         [0, 0, 0, 0, 0],\n...         [0, 0, 0, 0, 0]]\n>>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n[[0, 1, 1, 1, 1],\n[0, 1, 1, 1, 1],\n[0, 1, 1, 1, 1],\n[0, 1, 1, 1, 1],\n[0, 0, 0, 0, 0]]\n\n>>> maze = [[0, 0, 0],\n...         [0, 1, 0],\n...         [1, 0, 0]]\n>>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n[[0, 0, 0],\n[1, 1, 0],\n[1, 1, 0]]\n\n>>> maze = [[1, 0, 0],\n...         [0, 1, 0],\n...         [1, 0, 0]]\n>>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n[[1, 0, 0],\n[1, 1, 0],\n[1, 1, 0]]\n\n>>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\n...         [1, 0, 1, 0, 0, 1, 1, 1],\n...         [0, 1, 0, 1, 0, 0, 1, 0],\n...         [1, 1, 1, 0, 0, 1, 0, 1],\n...         [0, 1, 0, 0, 1, 0, 1, 1],\n...         [0, 0, 0, 1, 1, 1, 0, 1],\n...         [0, 1, 0, 1, 0, 1, 1, 1],\n...         [1, 1, 0, 0, 0, 0, 0, 1]]\n>>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\n[[1, 1, 0, 0, 1, 1, 1, 1],\n[1, 1, 1, 0, 0, 1, 1, 1],\n[1, 1, 1, 1, 0, 1, 1, 1],\n[1, 1, 1, 0, 0, 1, 1, 1],\n[1, 1, 0, 0, 1, 1, 1, 1],\n[1, 1, 0, 1, 1, 1, 1, 1],\n[1, 1, 0, 1, 1, 1, 1, 1],\n[1, 1, 0, 1, 1, 1, 1, 1]]\n>>> maze = [[1, 0, 0],\n...         [0, 1, 1],\n...         [1, 0, 1]]\n>>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\nTraceback (most recent call last):\n    ...\nValueError: No solution exists!\n\n>>> maze = [[0, 0],\n...         [1, 1]]\n>>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\nTraceback (most recent call last):\n    ...\nValueError: No solution exists!\n\n>>> maze = [[0, 1],\n...         [1, 0]]\n>>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\nTraceback (most recent call last):\n    ...\nValueError: Invalid source or destination coordinates\n\n>>> maze = [[1, 0, 0],\n...         [0, 1, 0],\n...         [1, 0, 0]]\n>>> solve_maze(maze,0,1,len(maze),len(maze)-1)\nTraceback (most recent call last):\n    ...\nValueError: Invalid source or destination coordinates"
  },
  {
    "function": "run_maze",
    "code": "def run_maze(\n    maze: list[list[int]],\n    i: int,\n    j: int,\n    destination_row: int,\n    destination_column: int,\n    solutions: list[list[int]],\n) -> bool:\n    \"\"\"\n    This method is recursive starting from (i, j) and going in one of four directions:\n    up, down, left, right.\n    If a path is found to destination it returns True otherwise it returns False.\n    Parameters\n        maze: A two dimensional matrix of zeros and ones.\n        i, j : coordinates of matrix\n        solutions: A two dimensional matrix of solutions.\n    Returns:\n        Boolean if path is found True, Otherwise False.\n    \"\"\"\n    size = len(maze)\n    # Final check point.\n    if i == destination_row and j == destination_column and maze[i][j] == 0:\n        solutions[i][j] = 0\n        return True\n\n    lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds\n    upper_flag = (i < size) and (j < size)  # Check upper bounds\n\n    if lower_flag and upper_flag:\n        # check for already visited and block points.\n        block_flag = (solutions[i][j]) and (not maze[i][j])\n        if block_flag:\n            # check visited\n            solutions[i][j] = 0\n\n            # check for directions\n            if (\n                run_maze(maze, i + 1, j, destination_row, destination_column, solutions)\n                or run_maze(\n                    maze, i, j + 1, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i - 1, j, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i, j - 1, destination_row, destination_column, solutions\n                )\n            ):\n                return True\n\n            solutions[i][j] = 1\n            return False\n    return False",
    "docstring": "This method is recursive starting from (i, j) and going in one of four directions:\nup, down, left, right.\nIf a path is found to destination it returns True otherwise it returns False.\nParameters\n    maze: A two dimensional matrix of zeros and ones.\n    i, j : coordinates of matrix\n    solutions: A two dimensional matrix of solutions.\nReturns:\n    Boolean if path is found True, Otherwise False."
  },
  {
    "function": "is_safe",
    "code": "def is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:\n    \"\"\"\n    This function checks the grid to see if each row,\n    column, and the 3x3 subgrids contain the digit 'n'.\n    It returns False if it is not 'safe' (a duplicate digit\n    is found) else returns True if it is 'safe'\n    \"\"\"\n    for i in range(9):\n        if n in {grid[row][i], grid[i][column]}:\n            return False\n\n    for i in range(3):\n        for j in range(3):\n            if grid[(row - row % 3) + i][(column - column % 3) + j] == n:\n                return False\n\n    return True",
    "docstring": "This function checks the grid to see if each row,\ncolumn, and the 3x3 subgrids contain the digit 'n'.\nIt returns False if it is not 'safe' (a duplicate digit\nis found) else returns True if it is 'safe'"
  },
  {
    "function": "find_empty_location",
    "code": "def find_empty_location(grid: Matrix) -> tuple[int, int] | None:\n    \"\"\"\n    This function finds an empty location so that we can assign a number\n    for that particular row and column.\n    \"\"\"\n    for i in range(9):\n        for j in range(9):\n            if grid[i][j] == 0:\n                return i, j\n    return None",
    "docstring": "This function finds an empty location so that we can assign a number\nfor that particular row and column."
  },
  {
    "function": "sudoku",
    "code": "def sudoku(grid: Matrix) -> Matrix | None:\n    \"\"\"\n    Takes a partially filled-in grid and attempts to assign values to\n    all unassigned locations in such a way to meet the requirements\n    for Sudoku solution (non-duplication across rows, columns, and boxes)\n\n    >>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE\n    [[3, 1, 6, 5, 7, 8, 4, 9, 2],\n     [5, 2, 9, 1, 3, 4, 7, 6, 8],\n     [4, 8, 7, 6, 2, 9, 5, 3, 1],\n     [2, 6, 3, 4, 1, 5, 9, 8, 7],\n     [9, 7, 4, 8, 6, 3, 1, 2, 5],\n     [8, 5, 1, 7, 9, 2, 6, 4, 3],\n     [1, 3, 8, 9, 4, 7, 2, 5, 6],\n     [6, 9, 2, 3, 5, 1, 8, 7, 4],\n     [7, 4, 5, 2, 8, 6, 3, 1, 9]]\n     >>> sudoku(no_solution) is None\n     True\n    \"\"\"\n    if location := find_empty_location(grid):\n        row, column = location\n    else:\n        # If the location is ``None``, then the grid is solved.\n        return grid\n\n    for digit in range(1, 10):\n        if is_safe(grid, row, column, digit):\n            grid[row][column] = digit\n\n            if sudoku(grid) is not None:\n                return grid\n\n            grid[row][column] = 0\n\n    return None",
    "docstring": "Takes a partially filled-in grid and attempts to assign values to\nall unassigned locations in such a way to meet the requirements\nfor Sudoku solution (non-duplication across rows, columns, and boxes)\n\n>>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE\n[[3, 1, 6, 5, 7, 8, 4, 9, 2],\n [5, 2, 9, 1, 3, 4, 7, 6, 8],\n [4, 8, 7, 6, 2, 9, 5, 3, 1],\n [2, 6, 3, 4, 1, 5, 9, 8, 7],\n [9, 7, 4, 8, 6, 3, 1, 2, 5],\n [8, 5, 1, 7, 9, 2, 6, 4, 3],\n [1, 3, 8, 9, 4, 7, 2, 5, 6],\n [6, 9, 2, 3, 5, 1, 8, 7, 4],\n [7, 4, 5, 2, 8, 6, 3, 1, 9]]\n >>> sudoku(no_solution) is None\n True"
  },
  {
    "function": "print_solution",
    "code": "def print_solution(grid: Matrix) -> None:\n    \"\"\"\n    A function to print the solution in the form\n    of a 9x9 grid\n    \"\"\"\n    for row in grid:\n        for cell in row:\n            print(cell, end=\" \")\n        print()",
    "docstring": "A function to print the solution in the form\nof a 9x9 grid"
  },
  {
    "function": "generate_sum_of_subsets_solutions",
    "code": "def generate_sum_of_subsets_solutions(nums: list[int], max_sum: int) -> list[list[int]]:\n    \"\"\"\n    The main function. For list of numbers 'nums' find the subsets with sum\n    equal to 'max_sum'\n\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=9)\n    [[3, 4, 2], [4, 5]]\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=3)\n    [[3]]\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=1)\n    []\n    \"\"\"\n\n    result: list[list[int]] = []\n    path: list[int] = []\n    num_index = 0\n    remaining_nums_sum = sum(nums)\n    create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)\n    return result",
    "docstring": "The main function. For list of numbers 'nums' find the subsets with sum\nequal to 'max_sum'\n\n>>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=9)\n[[3, 4, 2], [4, 5]]\n>>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=3)\n[[3]]\n>>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=1)\n[]"
  },
  {
    "function": "create_state_space_tree",
    "code": "def create_state_space_tree(\n    nums: list[int],\n    max_sum: int,\n    num_index: int,\n    path: list[int],\n    result: list[list[int]],\n    remaining_nums_sum: int,\n) -> None:\n    \"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    It terminates the branching of a node when any of the two conditions\n    given below satisfy.\n    This algorithm follows depth-fist-search and backtracks when the node is not\n    branchable.\n\n    >>> path = []\n    >>> result = []\n    >>> create_state_space_tree(\n    ...     nums=[1],\n    ...     max_sum=1,\n    ...     num_index=0,\n    ...     path=path,\n    ...     result=result,\n    ...     remaining_nums_sum=1)\n    >>> path\n    []\n    >>> result\n    [[1]]\n    \"\"\"\n\n    if sum(path) > max_sum or (remaining_nums_sum + sum(path)) < max_sum:\n        return\n    if sum(path) == max_sum:\n        result.append(path)\n        return\n    for index in range(num_index, len(nums)):\n        create_state_space_tree(\n            nums,\n            max_sum,\n            index + 1,\n            [*path, nums[index]],\n            result,\n            remaining_nums_sum - nums[index],\n        )",
    "docstring": "Creates a state space tree to iterate through each branch using DFS.\nIt terminates the branching of a node when any of the two conditions\ngiven below satisfy.\nThis algorithm follows depth-fist-search and backtracks when the node is not\nbranchable.\n\n>>> path = []\n>>> result = []\n>>> create_state_space_tree(\n...     nums=[1],\n...     max_sum=1,\n...     num_index=0,\n...     path=path,\n...     result=result,\n...     remaining_nums_sum=1)\n>>> path\n[]\n>>> result\n[[1]]"
  },
  {
    "function": "backtrack",
    "code": "def backtrack(input_string: str, word_dict: set[str], start: int) -> bool:\n    \"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\n\n    # Base case: if the starting index has reached the end of the string\n    if start == len(input_string):\n        return True\n\n    # Try every possible substring from 'start' to 'end'\n    for end in range(start + 1, len(input_string) + 1):\n        if input_string[start:end] in word_dict and backtrack(\n            input_string, word_dict, end\n        ):\n            return True\n\n    return False",
    "docstring": "Helper function that uses backtracking to determine if a valid\nword segmentation is possible starting from index 'start'.\n\nParameters:\ninput_string (str): The input string to be segmented.\nword_dict (set[str]): A set of valid dictionary words.\nstart (int): The starting index of the substring to be checked.\n\nReturns:\nbool: True if a valid segmentation is possible, otherwise False.\n\nExample:\n>>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\nTrue\n\n>>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\nTrue\n\n>>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\nFalse"
  },
  {
    "function": "word_break",
    "code": "def word_break(input_string: str, word_dict: set[str]) -> bool:\n    \"\"\"\n    Determines if the input string can be segmented into a sequence of\n    valid dictionary words using backtracking.\n\n    Parameters:\n    input_string (str): The input string to segment.\n    word_dict (set[str]): The set of valid words.\n\n    Returns:\n    bool: True if the string can be segmented into valid words, otherwise False.\n\n    Example:\n    >>> word_break(\"leetcode\", {\"leet\", \"code\"})\n    True\n\n    >>> word_break(\"applepenapple\", {\"apple\", \"pen\"})\n    True\n\n    >>> word_break(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"})\n    False\n    \"\"\"\n\n    return backtrack(input_string, word_dict, 0)",
    "docstring": "Determines if the input string can be segmented into a sequence of\nvalid dictionary words using backtracking.\n\nParameters:\ninput_string (str): The input string to segment.\nword_dict (set[str]): The set of valid words.\n\nReturns:\nbool: True if the string can be segmented into valid words, otherwise False.\n\nExample:\n>>> word_break(\"leetcode\", {\"leet\", \"code\"})\nTrue\n\n>>> word_break(\"applepenapple\", {\"apple\", \"pen\"})\nTrue\n\n>>> word_break(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"})\nFalse"
  },
  {
    "function": "backtrack",
    "code": "def backtrack(\n    current_word: str, path: list[str], end_word: str, word_set: set[str]\n) -> list[str]:\n    \"\"\"\n    Helper function to perform backtracking to find the transformation\n    from the current_word to the end_word.\n\n    Parameters:\n    current_word (str): The current word in the transformation sequence.\n    path (list[str]): The list of transformations from begin_word to current_word.\n    end_word (str): The target word for transformation.\n    word_set (set[str]): The set of valid words for transformation.\n\n    Returns:\n    list[str]: The list of transformations from begin_word to end_word.\n               Returns an empty list if there is no valid\n                transformation from current_word to end_word.\n\n    Example:\n    >>> backtrack(\"hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"})\n    ['hit', 'hot', 'dot', 'lot', 'log', 'cog']\n\n    >>> backtrack(\"hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\"})\n    []\n\n    >>> backtrack(\"lead\", [\"lead\"], \"gold\", {\"load\", \"goad\", \"gold\", \"lead\", \"lord\"})\n    ['lead', 'lead', 'load', 'goad', 'gold']\n\n    >>> backtrack(\"game\", [\"game\"], \"code\", {\"came\", \"cage\", \"code\", \"cade\", \"gave\"})\n    ['game', 'came', 'cade', 'code']\n    \"\"\"\n\n    # Base case: If the current word is the end word, return the path\n    if current_word == end_word:\n        return path\n\n    # Try all possible single-letter transformations\n    for i in range(len(current_word)):\n        for c in string.ascii_lowercase:  # Try changing each letter\n            transformed_word = current_word[:i] + c + current_word[i + 1 :]\n            if transformed_word in word_set:\n                word_set.remove(transformed_word)\n                # Recur with the new word added to the path\n                result = backtrack(\n                    transformed_word, [*path, transformed_word], end_word, word_set\n                )\n                if result:  # valid transformation found\n                    return result\n                word_set.add(transformed_word)  # backtrack\n\n    return []  # No valid transformation found",
    "docstring": "Helper function to perform backtracking to find the transformation\nfrom the current_word to the end_word.\n\nParameters:\ncurrent_word (str): The current word in the transformation sequence.\npath (list[str]): The list of transformations from begin_word to current_word.\nend_word (str): The target word for transformation.\nword_set (set[str]): The set of valid words for transformation.\n\nReturns:\nlist[str]: The list of transformations from begin_word to end_word.\n           Returns an empty list if there is no valid\n            transformation from current_word to end_word.\n\nExample:\n>>> backtrack(\"hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"})\n['hit', 'hot', 'dot', 'lot', 'log', 'cog']\n\n>>> backtrack(\"hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\"})\n[]\n\n>>> backtrack(\"lead\", [\"lead\"], \"gold\", {\"load\", \"goad\", \"gold\", \"lead\", \"lord\"})\n['lead', 'lead', 'load', 'goad', 'gold']\n\n>>> backtrack(\"game\", [\"game\"], \"code\", {\"came\", \"cage\", \"code\", \"cade\", \"gave\"})\n['game', 'came', 'cade', 'code']"
  },
  {
    "function": "word_ladder",
    "code": "def word_ladder(begin_word: str, end_word: str, word_set: set[str]) -> list[str]:\n    \"\"\"\n    Solve the Word Ladder problem using Backtracking and return\n    the list of transformations from begin_word to end_word.\n\n    Parameters:\n    begin_word (str): The word from which the transformation starts.\n    end_word (str): The target word for transformation.\n    word_list (list[str]): The list of valid words for transformation.\n\n    Returns:\n    list[str]: The list of transformations from begin_word to end_word.\n               Returns an empty list if there is no valid transformation.\n\n    Example:\n    >>> word_ladder(\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"])\n    ['hit', 'hot', 'dot', 'lot', 'log', 'cog']\n\n    >>> word_ladder(\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"])\n    []\n\n    >>> word_ladder(\"lead\", \"gold\", [\"load\", \"goad\", \"gold\", \"lead\", \"lord\"])\n    ['lead', 'lead', 'load', 'goad', 'gold']\n\n    >>> word_ladder(\"game\", \"code\", [\"came\", \"cage\", \"code\", \"cade\", \"gave\"])\n    ['game', 'came', 'cade', 'code']\n    \"\"\"\n\n    if end_word not in word_set:  # no valid transformation possible\n        return []\n\n    # Perform backtracking starting from the begin_word\n    return backtrack(begin_word, [begin_word], end_word, word_set)",
    "docstring": "Solve the Word Ladder problem using Backtracking and return\nthe list of transformations from begin_word to end_word.\n\nParameters:\nbegin_word (str): The word from which the transformation starts.\nend_word (str): The target word for transformation.\nword_list (list[str]): The list of valid words for transformation.\n\nReturns:\nlist[str]: The list of transformations from begin_word to end_word.\n           Returns an empty list if there is no valid transformation.\n\nExample:\n>>> word_ladder(\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"])\n['hit', 'hot', 'dot', 'lot', 'log', 'cog']\n\n>>> word_ladder(\"hit\", \"cog\", [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"])\n[]\n\n>>> word_ladder(\"lead\", \"gold\", [\"load\", \"goad\", \"gold\", \"lead\", \"lord\"])\n['lead', 'lead', 'load', 'goad', 'gold']\n\n>>> word_ladder(\"game\", \"code\", [\"came\", \"cage\", \"code\", \"cade\", \"gave\"])\n['game', 'came', 'cade', 'code']"
  },
  {
    "function": "get_point_key",
    "code": "def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column",
    "docstring": "Returns the hash key of matrix indexes.\n\n>>> get_point_key(10, 20, 1, 0)\n200"
  },
  {
    "function": "exits_word",
    "code": "def exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False",
    "docstring": "Return True if it's possible to search the word suffix\nstarting from the word_index.\n\n>>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\nFalse"
  },
  {
    "function": "word_exists",
    "code": "def word_exists(board: list[list[str]], word: str) -> bool:\n    \"\"\"\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCCED\")\n    True\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"SEE\")\n    True\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCB\")\n    False\n    >>> word_exists([[\"A\"]], \"A\")\n    True\n    >>> word_exists([[\"B\", \"A\", \"A\"], [\"A\", \"A\", \"A\"], [\"A\", \"B\", \"A\"]], \"ABB\")\n    False\n    >>> word_exists([[\"A\"]], 123)\n    Traceback (most recent call last):\n        ...\n    ValueError: The word parameter should be a string of length greater than 0.\n    >>> word_exists([[\"A\"]], \"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The word parameter should be a string of length greater than 0.\n    >>> word_exists([[]], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    >>> word_exists([], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    >>> word_exists([[\"A\"], [21]], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    \"\"\"\n\n    # Validate board\n    board_error_message = (\n        \"The board should be a non empty matrix of single chars strings.\"\n    )\n\n    len_board = len(board)\n    if not isinstance(board, list) or len(board) == 0:\n        raise ValueError(board_error_message)\n\n    for row in board:\n        if not isinstance(row, list) or len(row) == 0:\n            raise ValueError(board_error_message)\n\n        for item in row:\n            if not isinstance(item, str) or len(item) != 1:\n                raise ValueError(board_error_message)\n\n    # Validate word\n    if not isinstance(word, str) or len(word) == 0:\n        raise ValueError(\n            \"The word parameter should be a string of length greater than 0.\"\n        )\n\n    len_board_column = len(board[0])\n    for i in range(len_board):\n        for j in range(len_board_column):\n            if exits_word(\n                board, word, i, j, 0, {get_point_key(len_board, len_board_column, i, j)}\n            ):\n                return True\n\n    return False",
    "docstring": ">>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCCED\")\nTrue\n>>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"SEE\")\nTrue\n>>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCB\")\nFalse\n>>> word_exists([[\"A\"]], \"A\")\nTrue\n>>> word_exists([[\"B\", \"A\", \"A\"], [\"A\", \"A\", \"A\"], [\"A\", \"B\", \"A\"]], \"ABB\")\nFalse\n>>> word_exists([[\"A\"]], 123)\nTraceback (most recent call last):\n    ...\nValueError: The word parameter should be a string of length greater than 0.\n>>> word_exists([[\"A\"]], \"\")\nTraceback (most recent call last):\n    ...\nValueError: The word parameter should be a string of length greater than 0.\n>>> word_exists([[]], \"AB\")\nTraceback (most recent call last):\n    ...\nValueError: The board should be a non empty matrix of single chars strings.\n>>> word_exists([], \"AB\")\nTraceback (most recent call last):\n    ...\nValueError: The board should be a non empty matrix of single chars strings.\n>>> word_exists([[\"A\"], [21]], \"AB\")\nTraceback (most recent call last):\n    ...\nValueError: The board should be a non empty matrix of single chars strings."
  },
  {
    "function": "binary_and",
    "code": "def binary_and(a: int, b: int) -> str:\n    \"\"\"\n    Take in 2 integers, convert them to binary,\n    return a binary number that is the\n    result of a binary and operation on the integers provided.\n\n    >>> binary_and(25, 32)\n    '0b000000'\n    >>> binary_and(37, 50)\n    '0b100000'\n    >>> binary_and(21, 30)\n    '0b10100'\n    >>> binary_and(58, 73)\n    '0b0001000'\n    >>> binary_and(0, 255)\n    '0b00000000'\n    >>> binary_and(256, 256)\n    '0b100000000'\n    >>> binary_and(0, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of both inputs must be positive\n    >>> binary_and(0, 1.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Unknown format code 'b' for object of type 'float'\n    >>> binary_and(\"0\", \"1\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"the value of both inputs must be positive\")\n\n    a_binary = format(a, \"b\")\n    b_binary = format(b, \"b\")\n\n    max_len = max(len(a_binary), len(b_binary))\n\n    return \"0b\" + \"\".join(\n        str(int(char_a == \"1\" and char_b == \"1\"))\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\n    )",
    "docstring": "Take in 2 integers, convert them to binary,\nreturn a binary number that is the\nresult of a binary and operation on the integers provided.\n\n>>> binary_and(25, 32)\n'0b000000'\n>>> binary_and(37, 50)\n'0b100000'\n>>> binary_and(21, 30)\n'0b10100'\n>>> binary_and(58, 73)\n'0b0001000'\n>>> binary_and(0, 255)\n'0b00000000'\n>>> binary_and(256, 256)\n'0b100000000'\n>>> binary_and(0, -1)\nTraceback (most recent call last):\n    ...\nValueError: the value of both inputs must be positive\n>>> binary_and(0, 1.1)\nTraceback (most recent call last):\n    ...\nValueError: Unknown format code 'b' for object of type 'float'\n>>> binary_and(\"0\", \"1\")\nTraceback (most recent call last):\n    ...\nTypeError: '<' not supported between instances of 'str' and 'int'"
  },
  {
    "function": "binary_coded_decimal",
    "code": "def binary_coded_decimal(number: int) -> str:\n    \"\"\"\n    Find binary coded decimal (bcd) of integer base 10.\n    Each digit of the number is represented by a 4-bit binary.\n    Example:\n    >>> binary_coded_decimal(-2)\n    '0b0000'\n    >>> binary_coded_decimal(-1)\n    '0b0000'\n    >>> binary_coded_decimal(0)\n    '0b0000'\n    >>> binary_coded_decimal(3)\n    '0b0011'\n    >>> binary_coded_decimal(2)\n    '0b0010'\n    >>> binary_coded_decimal(12)\n    '0b00010010'\n    >>> binary_coded_decimal(987)\n    '0b100110000111'\n    \"\"\"\n    return \"0b\" + \"\".join(\n        str(bin(int(digit)))[2:].zfill(4) for digit in str(max(0, number))\n    )",
    "docstring": "Find binary coded decimal (bcd) of integer base 10.\nEach digit of the number is represented by a 4-bit binary.\nExample:\n>>> binary_coded_decimal(-2)\n'0b0000'\n>>> binary_coded_decimal(-1)\n'0b0000'\n>>> binary_coded_decimal(0)\n'0b0000'\n>>> binary_coded_decimal(3)\n'0b0011'\n>>> binary_coded_decimal(2)\n'0b0010'\n>>> binary_coded_decimal(12)\n'0b00010010'\n>>> binary_coded_decimal(987)\n'0b100110000111'"
  },
  {
    "function": "binary_count_setbits",
    "code": "def binary_count_setbits(a: int) -> int:\n    \"\"\"\n    Take in 1 integer, return a number that is\n    the number of 1's in binary representation of that number.\n\n    >>> binary_count_setbits(25)\n    3\n    >>> binary_count_setbits(36)\n    2\n    >>> binary_count_setbits(16)\n    1\n    >>> binary_count_setbits(58)\n    4\n    >>> binary_count_setbits(4294967295)\n    32\n    >>> binary_count_setbits(0)\n    0\n    >>> binary_count_setbits(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value must be a positive integer\n    >>> binary_count_setbits(0.8)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n    >>> binary_count_setbits(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if a < 0:\n        raise ValueError(\"Input value must be a positive integer\")\n    elif isinstance(a, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    return bin(a).count(\"1\")",
    "docstring": "Take in 1 integer, return a number that is\nthe number of 1's in binary representation of that number.\n\n>>> binary_count_setbits(25)\n3\n>>> binary_count_setbits(36)\n2\n>>> binary_count_setbits(16)\n1\n>>> binary_count_setbits(58)\n4\n>>> binary_count_setbits(4294967295)\n32\n>>> binary_count_setbits(0)\n0\n>>> binary_count_setbits(-10)\nTraceback (most recent call last):\n    ...\nValueError: Input value must be a positive integer\n>>> binary_count_setbits(0.8)\nTraceback (most recent call last):\n    ...\nTypeError: Input value must be a 'int' type\n>>> binary_count_setbits(\"0\")\nTraceback (most recent call last):\n    ...\nTypeError: '<' not supported between instances of 'str' and 'int'"
  },
  {
    "function": "binary_count_trailing_zeros",
    "code": "def binary_count_trailing_zeros(a: int) -> int:\n    \"\"\"\n    Take in 1 integer, return a number that is\n    the number of trailing zeros in binary representation of that number.\n\n    >>> binary_count_trailing_zeros(25)\n    0\n    >>> binary_count_trailing_zeros(36)\n    2\n    >>> binary_count_trailing_zeros(16)\n    4\n    >>> binary_count_trailing_zeros(58)\n    1\n    >>> binary_count_trailing_zeros(4294967296)\n    32\n    >>> binary_count_trailing_zeros(0)\n    0\n    >>> binary_count_trailing_zeros(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value must be a positive integer\n    >>> binary_count_trailing_zeros(0.8)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n    >>> binary_count_trailing_zeros(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if a < 0:\n        raise ValueError(\"Input value must be a positive integer\")\n    elif isinstance(a, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    return 0 if (a == 0) else int(log2(a & -a))",
    "docstring": "Take in 1 integer, return a number that is\nthe number of trailing zeros in binary representation of that number.\n\n>>> binary_count_trailing_zeros(25)\n0\n>>> binary_count_trailing_zeros(36)\n2\n>>> binary_count_trailing_zeros(16)\n4\n>>> binary_count_trailing_zeros(58)\n1\n>>> binary_count_trailing_zeros(4294967296)\n32\n>>> binary_count_trailing_zeros(0)\n0\n>>> binary_count_trailing_zeros(-10)\nTraceback (most recent call last):\n    ...\nValueError: Input value must be a positive integer\n>>> binary_count_trailing_zeros(0.8)\nTraceback (most recent call last):\n    ...\nTypeError: Input value must be a 'int' type\n>>> binary_count_trailing_zeros(\"0\")\nTraceback (most recent call last):\n    ...\nTypeError: '<' not supported between instances of 'str' and 'int'"
  },
  {
    "function": "binary_or",
    "code": "def binary_or(a: int, b: int) -> str:\n    \"\"\"\n    Take in 2 integers, convert them to binary, and return a binary number that is the\n    result of a binary or operation on the integers provided.\n\n    >>> binary_or(25, 32)\n    '0b111001'\n    >>> binary_or(37, 50)\n    '0b110111'\n    >>> binary_or(21, 30)\n    '0b11111'\n    >>> binary_or(58, 73)\n    '0b1111011'\n    >>> binary_or(0, 255)\n    '0b11111111'\n    >>> binary_or(0, 256)\n    '0b100000000'\n    >>> binary_or(0, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of both inputs must be positive\n    >>> binary_or(0, 1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> binary_or(\"0\", \"1\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"the value of both inputs must be positive\")\n    a_binary = str(bin(a))[2:]  # remove the leading \"0b\"\n    b_binary = str(bin(b))[2:]\n    max_len = max(len(a_binary), len(b_binary))\n    return \"0b\" + \"\".join(\n        str(int(\"1\" in (char_a, char_b)))\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\n    )",
    "docstring": "Take in 2 integers, convert them to binary, and return a binary number that is the\nresult of a binary or operation on the integers provided.\n\n>>> binary_or(25, 32)\n'0b111001'\n>>> binary_or(37, 50)\n'0b110111'\n>>> binary_or(21, 30)\n'0b11111'\n>>> binary_or(58, 73)\n'0b1111011'\n>>> binary_or(0, 255)\n'0b11111111'\n>>> binary_or(0, 256)\n'0b100000000'\n>>> binary_or(0, -1)\nTraceback (most recent call last):\n    ...\nValueError: the value of both inputs must be positive\n>>> binary_or(0, 1.1)\nTraceback (most recent call last):\n    ...\nTypeError: 'float' object cannot be interpreted as an integer\n>>> binary_or(\"0\", \"1\")\nTraceback (most recent call last):\n    ...\nTypeError: '<' not supported between instances of 'str' and 'int'"
  },
  {
    "function": "logical_left_shift",
    "code": "def logical_left_shift(number: int, shift_amount: int) -> str:\n    \"\"\"\n    Take in 2 positive integers.\n    'number' is the integer to be logically left shifted 'shift_amount' times.\n    i.e. (number << shift_amount)\n    Return the shifted binary representation.\n\n    >>> logical_left_shift(0, 1)\n    '0b00'\n    >>> logical_left_shift(1, 1)\n    '0b10'\n    >>> logical_left_shift(1, 5)\n    '0b100000'\n    >>> logical_left_shift(17, 2)\n    '0b1000100'\n    >>> logical_left_shift(1983, 4)\n    '0b111101111110000'\n    >>> logical_left_shift(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: both inputs must be positive integers\n    \"\"\"\n    if number < 0 or shift_amount < 0:\n        raise ValueError(\"both inputs must be positive integers\")\n\n    binary_number = str(bin(number))\n    binary_number += \"0\" * shift_amount\n    return binary_number",
    "docstring": "Take in 2 positive integers.\n'number' is the integer to be logically left shifted 'shift_amount' times.\ni.e. (number << shift_amount)\nReturn the shifted binary representation.\n\n>>> logical_left_shift(0, 1)\n'0b00'\n>>> logical_left_shift(1, 1)\n'0b10'\n>>> logical_left_shift(1, 5)\n'0b100000'\n>>> logical_left_shift(17, 2)\n'0b1000100'\n>>> logical_left_shift(1983, 4)\n'0b111101111110000'\n>>> logical_left_shift(1, -1)\nTraceback (most recent call last):\n    ...\nValueError: both inputs must be positive integers"
  },
  {
    "function": "logical_right_shift",
    "code": "def logical_right_shift(number: int, shift_amount: int) -> str:\n    \"\"\"\n    Take in positive 2 integers.\n    'number' is the integer to be logically right shifted 'shift_amount' times.\n    i.e. (number >>> shift_amount)\n    Return the shifted binary representation.\n\n    >>> logical_right_shift(0, 1)\n    '0b0'\n    >>> logical_right_shift(1, 1)\n    '0b0'\n    >>> logical_right_shift(1, 5)\n    '0b0'\n    >>> logical_right_shift(17, 2)\n    '0b100'\n    >>> logical_right_shift(1983, 4)\n    '0b1111011'\n    >>> logical_right_shift(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: both inputs must be positive integers\n    \"\"\"\n    if number < 0 or shift_amount < 0:\n        raise ValueError(\"both inputs must be positive integers\")\n\n    binary_number = str(bin(number))[2:]\n    if shift_amount >= len(binary_number):\n        return \"0b0\"\n    shifted_binary_number = binary_number[: len(binary_number) - shift_amount]\n    return \"0b\" + shifted_binary_number",
    "docstring": "Take in positive 2 integers.\n'number' is the integer to be logically right shifted 'shift_amount' times.\ni.e. (number >>> shift_amount)\nReturn the shifted binary representation.\n\n>>> logical_right_shift(0, 1)\n'0b0'\n>>> logical_right_shift(1, 1)\n'0b0'\n>>> logical_right_shift(1, 5)\n'0b0'\n>>> logical_right_shift(17, 2)\n'0b100'\n>>> logical_right_shift(1983, 4)\n'0b1111011'\n>>> logical_right_shift(1, -1)\nTraceback (most recent call last):\n    ...\nValueError: both inputs must be positive integers"
  },
  {
    "function": "arithmetic_right_shift",
    "code": "def arithmetic_right_shift(number: int, shift_amount: int) -> str:\n    \"\"\"\n    Take in 2 integers.\n    'number' is the integer to be arithmetically right shifted 'shift_amount' times.\n    i.e. (number >> shift_amount)\n    Return the shifted binary representation.\n\n    >>> arithmetic_right_shift(0, 1)\n    '0b00'\n    >>> arithmetic_right_shift(1, 1)\n    '0b00'\n    >>> arithmetic_right_shift(-1, 1)\n    '0b11'\n    >>> arithmetic_right_shift(17, 2)\n    '0b000100'\n    >>> arithmetic_right_shift(-17, 2)\n    '0b111011'\n    >>> arithmetic_right_shift(-1983, 4)\n    '0b111110000100'\n    \"\"\"\n    if number >= 0:  # Get binary representation of positive number\n        binary_number = \"0\" + str(bin(number)).strip(\"-\")[2:]\n    else:  # Get binary (2's complement) representation of negative number\n        binary_number_length = len(bin(number)[3:])  # Find 2's complement of number\n        binary_number = bin(abs(number) - (1 << binary_number_length))[3:]\n        binary_number = (\n            \"1\" + \"0\" * (binary_number_length - len(binary_number)) + binary_number\n        )\n\n    if shift_amount >= len(binary_number):\n        return \"0b\" + binary_number[0] * len(binary_number)\n    return (\n        \"0b\"\n        + binary_number[0] * shift_amount\n        + binary_number[: len(binary_number) - shift_amount]\n    )",
    "docstring": "Take in 2 integers.\n'number' is the integer to be arithmetically right shifted 'shift_amount' times.\ni.e. (number >> shift_amount)\nReturn the shifted binary representation.\n\n>>> arithmetic_right_shift(0, 1)\n'0b00'\n>>> arithmetic_right_shift(1, 1)\n'0b00'\n>>> arithmetic_right_shift(-1, 1)\n'0b11'\n>>> arithmetic_right_shift(17, 2)\n'0b000100'\n>>> arithmetic_right_shift(-17, 2)\n'0b111011'\n>>> arithmetic_right_shift(-1983, 4)\n'0b111110000100'"
  },
  {
    "function": "twos_complement",
    "code": "def twos_complement(number: int) -> str:\n    \"\"\"\n    Take in a negative integer 'number'.\n    Return the two's complement representation of 'number'.\n\n    >>> twos_complement(0)\n    '0b0'\n    >>> twos_complement(-1)\n    '0b11'\n    >>> twos_complement(-5)\n    '0b1011'\n    >>> twos_complement(-17)\n    '0b101111'\n    >>> twos_complement(-207)\n    '0b100110001'\n    >>> twos_complement(1)\n    Traceback (most recent call last):\n        ...\n    ValueError: input must be a negative integer\n    \"\"\"\n    if number > 0:\n        raise ValueError(\"input must be a negative integer\")\n    binary_number_length = len(bin(number)[3:])\n    twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]\n    twos_complement_number = (\n        (\n            \"1\"\n            + \"0\" * (binary_number_length - len(twos_complement_number))\n            + twos_complement_number\n        )\n        if number < 0\n        else \"0\"\n    )\n    return \"0b\" + twos_complement_number",
    "docstring": "Take in a negative integer 'number'.\nReturn the two's complement representation of 'number'.\n\n>>> twos_complement(0)\n'0b0'\n>>> twos_complement(-1)\n'0b11'\n>>> twos_complement(-5)\n'0b1011'\n>>> twos_complement(-17)\n'0b101111'\n>>> twos_complement(-207)\n'0b100110001'\n>>> twos_complement(1)\nTraceback (most recent call last):\n    ...\nValueError: input must be a negative integer"
  },
  {
    "function": "binary_xor",
    "code": "def binary_xor(a: int, b: int) -> str:\n    \"\"\"\n    Take in 2 integers, convert them to binary,\n    return a binary number that is the\n    result of a binary xor operation on the integers provided.\n\n    >>> binary_xor(25, 32)\n    '0b111001'\n    >>> binary_xor(37, 50)\n    '0b010111'\n    >>> binary_xor(21, 30)\n    '0b01011'\n    >>> binary_xor(58, 73)\n    '0b1110011'\n    >>> binary_xor(0, 255)\n    '0b11111111'\n    >>> binary_xor(256, 256)\n    '0b000000000'\n    >>> binary_xor(0, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of both inputs must be positive\n    >>> binary_xor(0, 1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> binary_xor(\"0\", \"1\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"the value of both inputs must be positive\")\n\n    a_binary = str(bin(a))[2:]  # remove the leading \"0b\"\n    b_binary = str(bin(b))[2:]  # remove the leading \"0b\"\n\n    max_len = max(len(a_binary), len(b_binary))\n\n    return \"0b\" + \"\".join(\n        str(int(char_a != char_b))\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\n    )",
    "docstring": "Take in 2 integers, convert them to binary,\nreturn a binary number that is the\nresult of a binary xor operation on the integers provided.\n\n>>> binary_xor(25, 32)\n'0b111001'\n>>> binary_xor(37, 50)\n'0b010111'\n>>> binary_xor(21, 30)\n'0b01011'\n>>> binary_xor(58, 73)\n'0b1110011'\n>>> binary_xor(0, 255)\n'0b11111111'\n>>> binary_xor(256, 256)\n'0b000000000'\n>>> binary_xor(0, -1)\nTraceback (most recent call last):\n    ...\nValueError: the value of both inputs must be positive\n>>> binary_xor(0, 1.1)\nTraceback (most recent call last):\n    ...\nTypeError: 'float' object cannot be interpreted as an integer\n>>> binary_xor(\"0\", \"1\")\nTraceback (most recent call last):\n    ...\nTypeError: '<' not supported between instances of 'str' and 'int'"
  },
  {
    "function": "bitwise_addition_recursive",
    "code": "def bitwise_addition_recursive(number: int, other_number: int) -> int:\n    \"\"\"\n    >>> bitwise_addition_recursive(4, 5)\n    9\n    >>> bitwise_addition_recursive(8, 9)\n    17\n    >>> bitwise_addition_recursive(0, 4)\n    4\n    >>> bitwise_addition_recursive(4.5, 9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments MUST be integers!\n    >>> bitwise_addition_recursive('4', 9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments MUST be integers!\n    >>> bitwise_addition_recursive('4.5', 9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments MUST be integers!\n    >>> bitwise_addition_recursive(-1, 9)\n    Traceback (most recent call last):\n        ...\n    ValueError: Both arguments MUST be non-negative!\n    >>> bitwise_addition_recursive(1, -9)\n    Traceback (most recent call last):\n        ...\n    ValueError: Both arguments MUST be non-negative!\n    \"\"\"\n\n    if not isinstance(number, int) or not isinstance(other_number, int):\n        raise TypeError(\"Both arguments MUST be integers!\")\n\n    if number < 0 or other_number < 0:\n        raise ValueError(\"Both arguments MUST be non-negative!\")\n\n    bitwise_sum = number ^ other_number\n    carry = number & other_number\n\n    if carry == 0:\n        return bitwise_sum\n\n    return bitwise_addition_recursive(bitwise_sum, carry << 1)",
    "docstring": ">>> bitwise_addition_recursive(4, 5)\n9\n>>> bitwise_addition_recursive(8, 9)\n17\n>>> bitwise_addition_recursive(0, 4)\n4\n>>> bitwise_addition_recursive(4.5, 9)\nTraceback (most recent call last):\n    ...\nTypeError: Both arguments MUST be integers!\n>>> bitwise_addition_recursive('4', 9)\nTraceback (most recent call last):\n    ...\nTypeError: Both arguments MUST be integers!\n>>> bitwise_addition_recursive('4.5', 9)\nTraceback (most recent call last):\n    ...\nTypeError: Both arguments MUST be integers!\n>>> bitwise_addition_recursive(-1, 9)\nTraceback (most recent call last):\n    ...\nValueError: Both arguments MUST be non-negative!\n>>> bitwise_addition_recursive(1, -9)\nTraceback (most recent call last):\n    ...\nValueError: Both arguments MUST be non-negative!"
  },
  {
    "function": "get_1s_count",
    "code": "def get_1s_count(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer using Brian Kernighan's way.\n    Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\n    >>> get_1s_count(25)\n    3\n    >>> get_1s_count(37)\n    3\n    >>> get_1s_count(21)\n    3\n    >>> get_1s_count(58)\n    4\n    >>> get_1s_count(0)\n    0\n    >>> get_1s_count(256)\n    1\n    >>> get_1s_count(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(0.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(\"25\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    count = 0\n    while number:\n        # This way we arrive at next set bit (next 1) instead of looping\n        # through each bit and checking for 1s hence the\n        # loop won't run 32 times it will only run the number of `1` times\n        number &= number - 1\n        count += 1\n    return count",
    "docstring": "Count the number of set bits in a 32 bit integer using Brian Kernighan's way.\nRef - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\n>>> get_1s_count(25)\n3\n>>> get_1s_count(37)\n3\n>>> get_1s_count(21)\n3\n>>> get_1s_count(58)\n4\n>>> get_1s_count(0)\n0\n>>> get_1s_count(256)\n1\n>>> get_1s_count(-1)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a non-negative integer\n>>> get_1s_count(0.8)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a non-negative integer\n>>> get_1s_count(\"25\")\nTraceback (most recent call last):\n    ...\nValueError: Input must be a non-negative integer"
  },
  {
    "function": "get_set_bits_count_using_brian_kernighans_algorithm",
    "code": "def get_set_bits_count_using_brian_kernighans_algorithm(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(25)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(37)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(21)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(58)\n    4\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(0)\n    0\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(256)\n    1\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must not be negative\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"the value of input must not be negative\")\n    result = 0\n    while number:\n        number &= number - 1\n        result += 1\n    return result",
    "docstring": "Count the number of set bits in a 32 bit integer\n>>> get_set_bits_count_using_brian_kernighans_algorithm(25)\n3\n>>> get_set_bits_count_using_brian_kernighans_algorithm(37)\n3\n>>> get_set_bits_count_using_brian_kernighans_algorithm(21)\n3\n>>> get_set_bits_count_using_brian_kernighans_algorithm(58)\n4\n>>> get_set_bits_count_using_brian_kernighans_algorithm(0)\n0\n>>> get_set_bits_count_using_brian_kernighans_algorithm(256)\n1\n>>> get_set_bits_count_using_brian_kernighans_algorithm(-1)\nTraceback (most recent call last):\n    ...\nValueError: the value of input must not be negative"
  },
  {
    "function": "get_set_bits_count_using_modulo_operator",
    "code": "def get_set_bits_count_using_modulo_operator(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer\n    >>> get_set_bits_count_using_modulo_operator(25)\n    3\n    >>> get_set_bits_count_using_modulo_operator(37)\n    3\n    >>> get_set_bits_count_using_modulo_operator(21)\n    3\n    >>> get_set_bits_count_using_modulo_operator(58)\n    4\n    >>> get_set_bits_count_using_modulo_operator(0)\n    0\n    >>> get_set_bits_count_using_modulo_operator(256)\n    1\n    >>> get_set_bits_count_using_modulo_operator(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must not be negative\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"the value of input must not be negative\")\n    result = 0\n    while number:\n        if number % 2 == 1:\n            result += 1\n        number >>= 1\n    return result",
    "docstring": "Count the number of set bits in a 32 bit integer\n>>> get_set_bits_count_using_modulo_operator(25)\n3\n>>> get_set_bits_count_using_modulo_operator(37)\n3\n>>> get_set_bits_count_using_modulo_operator(21)\n3\n>>> get_set_bits_count_using_modulo_operator(58)\n4\n>>> get_set_bits_count_using_modulo_operator(0)\n0\n>>> get_set_bits_count_using_modulo_operator(256)\n1\n>>> get_set_bits_count_using_modulo_operator(-1)\nTraceback (most recent call last):\n    ...\nValueError: the value of input must not be negative"
  },
  {
    "function": "benchmark",
    "code": "def benchmark() -> None:\n    \"\"\"\n    Benchmark code for comparing 2 functions, with different length int values.\n    Brian Kernighan's algorithm is consistently faster than using modulo_operator.\n    \"\"\"\n\n    def do_benchmark(number: int) -> None:\n        setup = \"import __main__ as z\"\n        print(f\"Benchmark when {number = }:\")\n        print(f\"{get_set_bits_count_using_modulo_operator(number) = }\")\n        timing = timeit(\n            f\"z.get_set_bits_count_using_modulo_operator({number})\", setup=setup\n        )\n        print(f\"timeit() runs in {timing} seconds\")\n        print(f\"{get_set_bits_count_using_brian_kernighans_algorithm(number) = }\")\n        timing = timeit(\n            f\"z.get_set_bits_count_using_brian_kernighans_algorithm({number})\",\n            setup=setup,\n        )\n        print(f\"timeit() runs in {timing} seconds\")\n\n    for number in (25, 37, 58, 0):\n        do_benchmark(number)\n        print()",
    "docstring": "Benchmark code for comparing 2 functions, with different length int values.\nBrian Kernighan's algorithm is consistently faster than using modulo_operator."
  },
  {
    "function": "excess_3_code",
    "code": "def excess_3_code(number: int) -> str:\n    \"\"\"\n    Find excess-3 code of integer base 10.\n    Add 3 to all digits in a decimal number then convert to a binary-coded decimal.\n    https://en.wikipedia.org/wiki/Excess-3\n\n    >>> excess_3_code(0)\n    '0b0011'\n    >>> excess_3_code(3)\n    '0b0110'\n    >>> excess_3_code(2)\n    '0b0101'\n    >>> excess_3_code(20)\n    '0b01010011'\n    >>> excess_3_code(120)\n    '0b010001010011'\n    \"\"\"\n    num = \"\"\n    for digit in str(max(0, number)):\n        num += str(bin(int(digit) + 3))[2:].zfill(4)\n    return \"0b\" + num",
    "docstring": "Find excess-3 code of integer base 10.\nAdd 3 to all digits in a decimal number then convert to a binary-coded decimal.\nhttps://en.wikipedia.org/wiki/Excess-3\n\n>>> excess_3_code(0)\n'0b0011'\n>>> excess_3_code(3)\n'0b0110'\n>>> excess_3_code(2)\n'0b0101'\n>>> excess_3_code(20)\n'0b01010011'\n>>> excess_3_code(120)\n'0b010001010011'"
  },
  {
    "function": "find_previous_power_of_two",
    "code": "def find_previous_power_of_two(number: int) -> int:\n    \"\"\"\n    Find the largest power of two that is less than or equal to a given integer.\n    https://stackoverflow.com/questions/1322510\n\n    >>> [find_previous_power_of_two(i) for i in range(18)]\n    [0, 1, 2, 2, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16]\n    >>> find_previous_power_of_two(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> find_previous_power_of_two(10.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    if number == 0:\n        return 0\n    power = 1\n    while power <= number:\n        power <<= 1  # Equivalent to multiplying by 2\n    return power >> 1 if number > 1 else 1",
    "docstring": "Find the largest power of two that is less than or equal to a given integer.\nhttps://stackoverflow.com/questions/1322510\n\n>>> [find_previous_power_of_two(i) for i in range(18)]\n[0, 1, 2, 2, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16]\n>>> find_previous_power_of_two(-5)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a non-negative integer\n>>> find_previous_power_of_two(10.5)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a non-negative integer"
  },
  {
    "function": "find_unique_number",
    "code": "def find_unique_number(arr: list[int]) -> int:\n    \"\"\"\n    Given a list of integers where every element appears twice except for one,\n    this function returns the element that appears only once using bitwise XOR.\n\n    >>> find_unique_number([1, 1, 2, 2, 3])\n    3\n    >>> find_unique_number([4, 5, 4, 6, 6])\n    5\n    >>> find_unique_number([7])\n    7\n    >>> find_unique_number([10, 20, 10])\n    20\n    >>> find_unique_number([])\n    Traceback (most recent call last):\n        ...\n    ValueError: input list must not be empty\n    >>> find_unique_number([1, 'a', 1])\n    Traceback (most recent call last):\n        ...\n    TypeError: all elements must be integers\n    \"\"\"\n    if not arr:\n        raise ValueError(\"input list must not be empty\")\n    if not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"all elements must be integers\")\n\n    result = 0\n    for num in arr:\n        result ^= num\n    return result",
    "docstring": "Given a list of integers where every element appears twice except for one,\nthis function returns the element that appears only once using bitwise XOR.\n\n>>> find_unique_number([1, 1, 2, 2, 3])\n3\n>>> find_unique_number([4, 5, 4, 6, 6])\n5\n>>> find_unique_number([7])\n7\n>>> find_unique_number([10, 20, 10])\n20\n>>> find_unique_number([])\nTraceback (most recent call last):\n    ...\nValueError: input list must not be empty\n>>> find_unique_number([1, 'a', 1])\nTraceback (most recent call last):\n    ...\nTypeError: all elements must be integers"
  },
  {
    "function": "gray_code",
    "code": "def gray_code(bit_count: int) -> list:\n    \"\"\"\n    Takes in an integer n and returns a n-bit\n    gray code sequence\n    An n-bit gray code sequence is a sequence of 2^n\n    integers where:\n\n    a) Every integer is between [0,2^n -1] inclusive\n    b) The sequence begins with 0\n    c) An integer appears at most one times in the sequence\n    d)The binary representation of every pair of integers differ\n       by exactly one bit\n    e) The binary representation of first and last bit also\n       differ by exactly one bit\n\n    >>> gray_code(2)\n    [0, 1, 3, 2]\n\n    >>> gray_code(1)\n    [0, 1]\n\n    >>> gray_code(3)\n    [0, 1, 3, 2, 6, 7, 5, 4]\n\n    >>> gray_code(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The given input must be positive\n\n    >>> gray_code(10.6)\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for <<: 'int' and 'float'\n    \"\"\"\n\n    # bit count represents no. of bits in the gray code\n    if bit_count < 0:\n        raise ValueError(\"The given input must be positive\")\n\n    # get the generated string sequence\n    sequence = gray_code_sequence_string(bit_count)\n    #\n    # convert them to integers\n    for i in range(len(sequence)):\n        sequence[i] = int(sequence[i], 2)\n\n    return sequence",
    "docstring": "Takes in an integer n and returns a n-bit\ngray code sequence\nAn n-bit gray code sequence is a sequence of 2^n\nintegers where:\n\na) Every integer is between [0,2^n -1] inclusive\nb) The sequence begins with 0\nc) An integer appears at most one times in the sequence\nd)The binary representation of every pair of integers differ\n   by exactly one bit\ne) The binary representation of first and last bit also\n   differ by exactly one bit\n\n>>> gray_code(2)\n[0, 1, 3, 2]\n\n>>> gray_code(1)\n[0, 1]\n\n>>> gray_code(3)\n[0, 1, 3, 2, 6, 7, 5, 4]\n\n>>> gray_code(-1)\nTraceback (most recent call last):\n    ...\nValueError: The given input must be positive\n\n>>> gray_code(10.6)\nTraceback (most recent call last):\n    ...\nTypeError: unsupported operand type(s) for <<: 'int' and 'float'"
  },
  {
    "function": "gray_code_sequence_string",
    "code": "def gray_code_sequence_string(bit_count: int) -> list:\n    \"\"\"\n    Will output the n-bit grey sequence as a\n    string of bits\n\n    >>> gray_code_sequence_string(2)\n    ['00', '01', '11', '10']\n\n    >>> gray_code_sequence_string(1)\n    ['0', '1']\n    \"\"\"\n\n    # The approach is a recursive one\n    # Base case achieved when either n = 0 or n=1\n    if bit_count == 0:\n        return [\"0\"]\n\n    if bit_count == 1:\n        return [\"0\", \"1\"]\n\n    seq_len = 1 << bit_count  # defines the length of the sequence\n    # 1<< n is equivalent to 2^n\n\n    # recursive answer will generate answer for n-1 bits\n    smaller_sequence = gray_code_sequence_string(bit_count - 1)\n\n    sequence = []\n\n    # append 0 to first half of the smaller sequence generated\n    for i in range(seq_len // 2):\n        generated_no = \"0\" + smaller_sequence[i]\n        sequence.append(generated_no)\n\n    # append 1 to second half ... start from the end of the list\n    for i in reversed(range(seq_len // 2)):\n        generated_no = \"1\" + smaller_sequence[i]\n        sequence.append(generated_no)\n\n    return sequence",
    "docstring": "Will output the n-bit grey sequence as a\nstring of bits\n\n>>> gray_code_sequence_string(2)\n['00', '01', '11', '10']\n\n>>> gray_code_sequence_string(1)\n['0', '1']"
  },
  {
    "function": "get_highest_set_bit_position",
    "code": "def get_highest_set_bit_position(number: int) -> int:\n    \"\"\"\n    Returns position of the highest set bit of a number.\n    Ref - https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious\n    >>> get_highest_set_bit_position(25)\n    5\n    >>> get_highest_set_bit_position(37)\n    6\n    >>> get_highest_set_bit_position(1)\n    1\n    >>> get_highest_set_bit_position(4)\n    3\n    >>> get_highest_set_bit_position(0)\n    0\n    >>> get_highest_set_bit_position(0.8)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be an 'int' type\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Input value must be an 'int' type\")\n\n    position = 0\n    while number:\n        position += 1\n        number >>= 1\n\n    return position",
    "docstring": "Returns position of the highest set bit of a number.\nRef - https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious\n>>> get_highest_set_bit_position(25)\n5\n>>> get_highest_set_bit_position(37)\n6\n>>> get_highest_set_bit_position(1)\n1\n>>> get_highest_set_bit_position(4)\n3\n>>> get_highest_set_bit_position(0)\n0\n>>> get_highest_set_bit_position(0.8)\nTraceback (most recent call last):\n    ...\nTypeError: Input value must be an 'int' type"
  },
  {
    "function": "get_index_of_rightmost_set_bit",
    "code": "def get_index_of_rightmost_set_bit(number: int) -> int:\n    \"\"\"\n    Take in a positive integer 'number'.\n    Returns the zero-based index of first set bit in that 'number' from right.\n    Returns -1, If no set bit found.\n\n    >>> get_index_of_rightmost_set_bit(0)\n    -1\n    >>> get_index_of_rightmost_set_bit(5)\n    0\n    >>> get_index_of_rightmost_set_bit(36)\n    2\n    >>> get_index_of_rightmost_set_bit(8)\n    3\n    >>> get_index_of_rightmost_set_bit(-18)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit('test')\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit(1.25)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    intermediate = number & ~(number - 1)\n    index = 0\n    while intermediate:\n        intermediate >>= 1\n        index += 1\n    return index - 1",
    "docstring": "Take in a positive integer 'number'.\nReturns the zero-based index of first set bit in that 'number' from right.\nReturns -1, If no set bit found.\n\n>>> get_index_of_rightmost_set_bit(0)\n-1\n>>> get_index_of_rightmost_set_bit(5)\n0\n>>> get_index_of_rightmost_set_bit(36)\n2\n>>> get_index_of_rightmost_set_bit(8)\n3\n>>> get_index_of_rightmost_set_bit(-18)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a non-negative integer\n>>> get_index_of_rightmost_set_bit('test')\nTraceback (most recent call last):\n    ...\nValueError: Input must be a non-negative integer\n>>> get_index_of_rightmost_set_bit(1.25)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a non-negative integer"
  },
  {
    "function": "is_even",
    "code": "def is_even(number: int) -> bool:\n    \"\"\"\n    return true if the input integer is even\n    Explanation: Lets take a look at the following decimal to binary conversions\n    2 => 10\n    14 => 1110\n    100 => 1100100\n    3 => 11\n    13 => 1101\n    101 => 1100101\n    from the above examples we can observe that\n    for all the odd integers there is always 1 set bit at the end\n    also, 1 in binary can be represented as 001, 00001, or 0000001\n    so for any odd integer n => n&1 is always equals 1 else the integer is even\n\n    >>> is_even(1)\n    False\n    >>> is_even(4)\n    True\n    >>> is_even(9)\n    False\n    >>> is_even(15)\n    False\n    >>> is_even(40)\n    True\n    >>> is_even(100)\n    True\n    >>> is_even(101)\n    False\n    \"\"\"\n    return number & 1 == 0",
    "docstring": "return true if the input integer is even\nExplanation: Lets take a look at the following decimal to binary conversions\n2 => 10\n14 => 1110\n100 => 1100100\n3 => 11\n13 => 1101\n101 => 1100101\nfrom the above examples we can observe that\nfor all the odd integers there is always 1 set bit at the end\nalso, 1 in binary can be represented as 001, 00001, or 0000001\nso for any odd integer n => n&1 is always equals 1 else the integer is even\n\n>>> is_even(1)\nFalse\n>>> is_even(4)\nTrue\n>>> is_even(9)\nFalse\n>>> is_even(15)\nFalse\n>>> is_even(40)\nTrue\n>>> is_even(100)\nTrue\n>>> is_even(101)\nFalse"
  },
  {
    "function": "is_power_of_two",
    "code": "def is_power_of_two(number: int) -> bool:\n    \"\"\"\n    Return True if this number is power of 2 or False otherwise.\n\n    >>> is_power_of_two(0)\n    True\n    >>> is_power_of_two(1)\n    True\n    >>> is_power_of_two(2)\n    True\n    >>> is_power_of_two(4)\n    True\n    >>> is_power_of_two(6)\n    False\n    >>> is_power_of_two(8)\n    True\n    >>> is_power_of_two(17)\n    False\n    >>> is_power_of_two(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number must not be negative\n    >>> is_power_of_two(1.2)\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for &: 'float' and 'float'\n\n    # Test all powers of 2 from 0 to 10,000\n    >>> all(is_power_of_two(int(2 ** i)) for i in range(10000))\n    True\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"number must not be negative\")\n    return number & (number - 1) == 0",
    "docstring": "Return True if this number is power of 2 or False otherwise.\n\n>>> is_power_of_two(0)\nTrue\n>>> is_power_of_two(1)\nTrue\n>>> is_power_of_two(2)\nTrue\n>>> is_power_of_two(4)\nTrue\n>>> is_power_of_two(6)\nFalse\n>>> is_power_of_two(8)\nTrue\n>>> is_power_of_two(17)\nFalse\n>>> is_power_of_two(-1)\nTraceback (most recent call last):\n    ...\nValueError: number must not be negative\n>>> is_power_of_two(1.2)\nTraceback (most recent call last):\n    ...\nTypeError: unsupported operand type(s) for &: 'float' and 'float'\n\n# Test all powers of 2 from 0 to 10,000\n>>> all(is_power_of_two(int(2 ** i)) for i in range(10000))\nTrue"
  },
  {
    "function": "largest_pow_of_two_le_num",
    "code": "def largest_pow_of_two_le_num(number: int) -> int:\n    \"\"\"\n    Return the largest power of two less than or equal to a number.\n\n    >>> largest_pow_of_two_le_num(0)\n    0\n    >>> largest_pow_of_two_le_num(1)\n    1\n    >>> largest_pow_of_two_le_num(-1)\n    0\n    >>> largest_pow_of_two_le_num(3)\n    2\n    >>> largest_pow_of_two_le_num(15)\n    8\n    >>> largest_pow_of_two_le_num(99)\n    64\n    >>> largest_pow_of_two_le_num(178)\n    128\n    >>> largest_pow_of_two_le_num(999999)\n    524288\n    >>> largest_pow_of_two_le_num(99.9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n    \"\"\"\n    if isinstance(number, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    if number <= 0:\n        return 0\n    res = 1\n    while (res << 1) <= number:\n        res <<= 1\n    return res",
    "docstring": "Return the largest power of two less than or equal to a number.\n\n>>> largest_pow_of_two_le_num(0)\n0\n>>> largest_pow_of_two_le_num(1)\n1\n>>> largest_pow_of_two_le_num(-1)\n0\n>>> largest_pow_of_two_le_num(3)\n2\n>>> largest_pow_of_two_le_num(15)\n8\n>>> largest_pow_of_two_le_num(99)\n64\n>>> largest_pow_of_two_le_num(178)\n128\n>>> largest_pow_of_two_le_num(999999)\n524288\n>>> largest_pow_of_two_le_num(99.9)\nTraceback (most recent call last):\n    ...\nTypeError: Input value must be a 'int' type"
  },
  {
    "function": "find_missing_number",
    "code": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([4, 3, 1, 0])\n        2\n        >>> find_missing_number([-4, -3, -1, 0])\n        -2\n        >>> find_missing_number([-2, 2, 1, 3, 0])\n        -1\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n\n    for i in range(low, high):\n        missing_number ^= i ^ nums[i - low]\n\n    return missing_number",
    "docstring": "Finds the missing number in a list of consecutive integers.\n\nArgs:\n    nums: A list of integers.\n\nReturns:\n    The missing number.\n\nExample:\n    >>> find_missing_number([0, 1, 3, 4])\n    2\n    >>> find_missing_number([4, 3, 1, 0])\n    2\n    >>> find_missing_number([-4, -3, -1, 0])\n    -2\n    >>> find_missing_number([-2, 2, 1, 3, 0])\n    -1\n    >>> find_missing_number([1, 3, 4, 5, 6])\n    2\n    >>> find_missing_number([6, 5, 4, 2, 1])\n    3\n    >>> find_missing_number([6, 1, 5, 3, 4])\n    2"
  },
  {
    "function": "different_signs",
    "code": "def different_signs(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if numbers have opposite signs False otherwise.\n\n    >>> different_signs(1, -1)\n    True\n    >>> different_signs(1, 1)\n    False\n    >>> different_signs(1000000000000000000000000000, -1000000000000000000000000000)\n    True\n    >>> different_signs(-1000000000000000000000000000, 1000000000000000000000000000)\n    True\n    >>> different_signs(50, 278)\n    False\n    >>> different_signs(0, 2)\n    False\n    >>> different_signs(2, 0)\n    False\n    \"\"\"\n    return num1 ^ num2 < 0",
    "docstring": "Return True if numbers have opposite signs False otherwise.\n\n>>> different_signs(1, -1)\nTrue\n>>> different_signs(1, 1)\nFalse\n>>> different_signs(1000000000000000000000000000, -1000000000000000000000000000)\nTrue\n>>> different_signs(-1000000000000000000000000000, 1000000000000000000000000000)\nTrue\n>>> different_signs(50, 278)\nFalse\n>>> different_signs(0, 2)\nFalse\n>>> different_signs(2, 0)\nFalse"
  },
  {
    "function": "power_of_4",
    "code": "def power_of_4(number: int) -> bool:\n    \"\"\"\n    Return True if this number is power of 4 or False otherwise.\n\n    >>> power_of_4(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: number must be positive\n    >>> power_of_4(1)\n    True\n    >>> power_of_4(2)\n    False\n    >>> power_of_4(4)\n    True\n    >>> power_of_4(6)\n    False\n    >>> power_of_4(8)\n    False\n    >>> power_of_4(17)\n    False\n    >>> power_of_4(64)\n    True\n    >>> power_of_4(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number must be positive\n    >>> power_of_4(1.2)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be an integer\n\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"number must be an integer\")\n    if number <= 0:\n        raise ValueError(\"number must be positive\")\n    if number & (number - 1) == 0:\n        c = 0\n        while number:\n            c += 1\n            number >>= 1\n        return c % 2 == 1\n    else:\n        return False",
    "docstring": "Return True if this number is power of 4 or False otherwise.\n\n>>> power_of_4(0)\nTraceback (most recent call last):\n    ...\nValueError: number must be positive\n>>> power_of_4(1)\nTrue\n>>> power_of_4(2)\nFalse\n>>> power_of_4(4)\nTrue\n>>> power_of_4(6)\nFalse\n>>> power_of_4(8)\nFalse\n>>> power_of_4(17)\nFalse\n>>> power_of_4(64)\nTrue\n>>> power_of_4(-1)\nTraceback (most recent call last):\n    ...\nValueError: number must be positive\n>>> power_of_4(1.2)\nTraceback (most recent call last):\n    ...\nTypeError: number must be an integer"
  },
  {
    "function": "get_reverse_bit_string",
    "code": "def get_reverse_bit_string(number: int) -> str:\n    \"\"\"\n    Return the reverse bit string of a 32 bit integer\n\n    >>> get_reverse_bit_string(9)\n    '10010000000000000000000000000000'\n    >>> get_reverse_bit_string(43)\n    '11010100000000000000000000000000'\n    >>> get_reverse_bit_string(2873)\n    '10011100110100000000000000000000'\n    >>> get_reverse_bit_string(2550136832)\n    '00000000000000000000000000011001'\n    >>> get_reverse_bit_string(\"this is not a number\")\n    Traceback (most recent call last):\n        ...\n    TypeError: operation can not be conducted on an object of type str\n    \"\"\"\n    if not isinstance(number, int):\n        msg = (\n            \"operation can not be conducted on an object of type \"\n            f\"{type(number).__name__}\"\n        )\n        raise TypeError(msg)\n    bit_string = \"\"\n    for _ in range(32):\n        bit_string += str(number % 2)\n        number >>= 1\n    return bit_string",
    "docstring": "Return the reverse bit string of a 32 bit integer\n\n>>> get_reverse_bit_string(9)\n'10010000000000000000000000000000'\n>>> get_reverse_bit_string(43)\n'11010100000000000000000000000000'\n>>> get_reverse_bit_string(2873)\n'10011100110100000000000000000000'\n>>> get_reverse_bit_string(2550136832)\n'00000000000000000000000000011001'\n>>> get_reverse_bit_string(\"this is not a number\")\nTraceback (most recent call last):\n    ...\nTypeError: operation can not be conducted on an object of type str"
  },
  {
    "function": "reverse_bit",
    "code": "def reverse_bit(number: int) -> int:\n    \"\"\"\n    Take in a 32 bit integer, reverse its bits, return a 32 bit integer result\n\n    >>> reverse_bit(25)\n    2550136832\n    >>> reverse_bit(37)\n    2751463424\n    >>> reverse_bit(21)\n    2818572288\n    >>> reverse_bit(58)\n    1543503872\n    >>> reverse_bit(0)\n    0\n    >>> reverse_bit(256)\n    8388608\n    >>> reverse_bit(2550136832)\n    25\n    >>> reverse_bit(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The value of input must be non-negative\n\n    >>> reverse_bit(1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be an 'int' type\n\n    >>> reverse_bit(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be an 'int' type\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Input value must be an 'int' type\")\n    if number < 0:\n        raise ValueError(\"The value of input must be non-negative\")\n\n    result = 0\n    # iterator over [0 to 31], since we are dealing with a 32 bit integer\n    for _ in range(32):\n        # left shift the bits by unity\n        result <<= 1\n        # get the end bit\n        end_bit = number & 1\n        # right shift the bits by unity\n        number >>= 1\n        # add that bit to our answer\n        result |= end_bit\n    return result",
    "docstring": "Take in a 32 bit integer, reverse its bits, return a 32 bit integer result\n\n>>> reverse_bit(25)\n2550136832\n>>> reverse_bit(37)\n2751463424\n>>> reverse_bit(21)\n2818572288\n>>> reverse_bit(58)\n1543503872\n>>> reverse_bit(0)\n0\n>>> reverse_bit(256)\n8388608\n>>> reverse_bit(2550136832)\n25\n>>> reverse_bit(-1)\nTraceback (most recent call last):\n    ...\nValueError: The value of input must be non-negative\n\n>>> reverse_bit(1.1)\nTraceback (most recent call last):\n    ...\nTypeError: Input value must be an 'int' type\n\n>>> reverse_bit(\"0\")\nTraceback (most recent call last):\n    ...\nTypeError: Input value must be an 'int' type"
  },
  {
    "function": "set_bit",
    "code": "def set_bit(number: int, position: int) -> int:\n    \"\"\"\n    Set the bit at position to 1.\n\n    Details: perform bitwise or for given number and X.\n    Where X is a number with all the bits - zeroes and bit on given\n    position - one.\n\n    >>> set_bit(0b1101, 1) # 0b1111\n    15\n    >>> set_bit(0b0, 5) # 0b100000\n    32\n    >>> set_bit(0b1111, 1) # 0b1111\n    15\n    \"\"\"\n    return number | (1 << position)",
    "docstring": "Set the bit at position to 1.\n\nDetails: perform bitwise or for given number and X.\nWhere X is a number with all the bits - zeroes and bit on given\nposition - one.\n\n>>> set_bit(0b1101, 1) # 0b1111\n15\n>>> set_bit(0b0, 5) # 0b100000\n32\n>>> set_bit(0b1111, 1) # 0b1111\n15"
  },
  {
    "function": "clear_bit",
    "code": "def clear_bit(number: int, position: int) -> int:\n    \"\"\"\n    Set the bit at position to 0.\n\n    Details: perform bitwise and for given number and X.\n    Where X is a number with all the bits - ones and bit on given\n    position - zero.\n\n    >>> clear_bit(0b10010, 1) # 0b10000\n    16\n    >>> clear_bit(0b0, 5) # 0b0\n    0\n    \"\"\"\n    return number & ~(1 << position)",
    "docstring": "Set the bit at position to 0.\n\nDetails: perform bitwise and for given number and X.\nWhere X is a number with all the bits - ones and bit on given\nposition - zero.\n\n>>> clear_bit(0b10010, 1) # 0b10000\n16\n>>> clear_bit(0b0, 5) # 0b0\n0"
  },
  {
    "function": "flip_bit",
    "code": "def flip_bit(number: int, position: int) -> int:\n    \"\"\"\n    Flip the bit at position.\n\n    Details: perform bitwise xor for given number and X.\n    Where X is a number with all the bits - zeroes and bit on given\n    position - one.\n\n    >>> flip_bit(0b101, 1) # 0b111\n    7\n    >>> flip_bit(0b101, 0) # 0b100\n    4\n    \"\"\"\n    return number ^ (1 << position)",
    "docstring": "Flip the bit at position.\n\nDetails: perform bitwise xor for given number and X.\nWhere X is a number with all the bits - zeroes and bit on given\nposition - one.\n\n>>> flip_bit(0b101, 1) # 0b111\n7\n>>> flip_bit(0b101, 0) # 0b100\n4"
  },
  {
    "function": "is_bit_set",
    "code": "def is_bit_set(number: int, position: int) -> bool:\n    \"\"\"\n    Is the bit at position set?\n\n    Details: Shift the bit at position to be the first (smallest) bit.\n    Then check if the first bit is set by anding the shifted number with 1.\n\n    >>> is_bit_set(0b1010, 0)\n    False\n    >>> is_bit_set(0b1010, 1)\n    True\n    >>> is_bit_set(0b1010, 2)\n    False\n    >>> is_bit_set(0b1010, 3)\n    True\n    >>> is_bit_set(0b0, 17)\n    False\n    \"\"\"\n    return ((number >> position) & 1) == 1",
    "docstring": "Is the bit at position set?\n\nDetails: Shift the bit at position to be the first (smallest) bit.\nThen check if the first bit is set by anding the shifted number with 1.\n\n>>> is_bit_set(0b1010, 0)\nFalse\n>>> is_bit_set(0b1010, 1)\nTrue\n>>> is_bit_set(0b1010, 2)\nFalse\n>>> is_bit_set(0b1010, 3)\nTrue\n>>> is_bit_set(0b0, 17)\nFalse"
  },
  {
    "function": "get_bit",
    "code": "def get_bit(number: int, position: int) -> int:\n    \"\"\"\n    Get the bit at the given position\n\n    Details: perform bitwise and for the given number and X,\n    Where X is a number with all the bits - zeroes and bit on given position - one.\n    If the result is not equal to 0, then the bit on the given position is 1, else 0.\n\n    >>> get_bit(0b1010, 0)\n    0\n    >>> get_bit(0b1010, 1)\n    1\n    >>> get_bit(0b1010, 2)\n    0\n    >>> get_bit(0b1010, 3)\n    1\n    \"\"\"\n    return int((number & (1 << position)) != 0)",
    "docstring": "Get the bit at the given position\n\nDetails: perform bitwise and for the given number and X,\nWhere X is a number with all the bits - zeroes and bit on given position - one.\nIf the result is not equal to 0, then the bit on the given position is 1, else 0.\n\n>>> get_bit(0b1010, 0)\n0\n>>> get_bit(0b1010, 1)\n1\n>>> get_bit(0b1010, 2)\n0\n>>> get_bit(0b1010, 3)\n1"
  },
  {
    "function": "show_bits",
    "code": "def show_bits(before: int, after: int) -> str:\n    \"\"\"\n    >>> print(show_bits(0, 0xFFFF))\n        0: 00000000\n    65535: 1111111111111111\n    \"\"\"\n    return f\"{before:>5}: {before:08b}\\n{after:>5}: {after:08b}\"",
    "docstring": ">>> print(show_bits(0, 0xFFFF))\n    0: 00000000\n65535: 1111111111111111"
  },
  {
    "function": "swap_odd_even_bits",
    "code": "def swap_odd_even_bits(num: int) -> int:\n    \"\"\"\n    1. We use bitwise AND operations to separate the even bits (0, 2, 4, 6, etc.) and\n       odd bits (1, 3, 5, 7, etc.) in the input number.\n    2. We then right-shift the even bits by 1 position and left-shift the odd bits by\n       1 position to swap them.\n    3. Finally, we combine the swapped even and odd bits using a bitwise OR operation\n       to obtain the final result.\n    >>> print(show_bits(0, swap_odd_even_bits(0)))\n        0: 00000000\n        0: 00000000\n    >>> print(show_bits(1, swap_odd_even_bits(1)))\n        1: 00000001\n        2: 00000010\n    >>> print(show_bits(2, swap_odd_even_bits(2)))\n        2: 00000010\n        1: 00000001\n    >>> print(show_bits(3, swap_odd_even_bits(3)))\n        3: 00000011\n        3: 00000011\n    >>> print(show_bits(4, swap_odd_even_bits(4)))\n        4: 00000100\n        8: 00001000\n    >>> print(show_bits(5, swap_odd_even_bits(5)))\n        5: 00000101\n       10: 00001010\n    >>> print(show_bits(6, swap_odd_even_bits(6)))\n        6: 00000110\n        9: 00001001\n    >>> print(show_bits(23, swap_odd_even_bits(23)))\n       23: 00010111\n       43: 00101011\n    \"\"\"\n    # Get all even bits - 0xAAAAAAAA is a 32-bit number with all even bits set to 1\n    even_bits = num & 0xAAAAAAAA\n\n    # Get all odd bits - 0x55555555 is a 32-bit number with all odd bits set to 1\n    odd_bits = num & 0x55555555\n\n    # Right shift even bits and left shift odd bits and swap them\n    return even_bits >> 1 | odd_bits << 1",
    "docstring": "1. We use bitwise AND operations to separate the even bits (0, 2, 4, 6, etc.) and\n   odd bits (1, 3, 5, 7, etc.) in the input number.\n2. We then right-shift the even bits by 1 position and left-shift the odd bits by\n   1 position to swap them.\n3. Finally, we combine the swapped even and odd bits using a bitwise OR operation\n   to obtain the final result.\n>>> print(show_bits(0, swap_odd_even_bits(0)))\n    0: 00000000\n    0: 00000000\n>>> print(show_bits(1, swap_odd_even_bits(1)))\n    1: 00000001\n    2: 00000010\n>>> print(show_bits(2, swap_odd_even_bits(2)))\n    2: 00000010\n    1: 00000001\n>>> print(show_bits(3, swap_odd_even_bits(3)))\n    3: 00000011\n    3: 00000011\n>>> print(show_bits(4, swap_odd_even_bits(4)))\n    4: 00000100\n    8: 00001000\n>>> print(show_bits(5, swap_odd_even_bits(5)))\n    5: 00000101\n   10: 00001010\n>>> print(show_bits(6, swap_odd_even_bits(6)))\n    6: 00000110\n    9: 00001001\n>>> print(show_bits(23, swap_odd_even_bits(23)))\n   23: 00010111\n   43: 00101011"
  },
  {
    "function": "diophantine",
    "code": "def diophantine(a: int, b: int, c: int) -> tuple[float, float]:\n    \"\"\"\n    Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n    diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n    iff greatest_common_divisor(a,b) divides c.\n\n    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n    >>> diophantine(10,6,14)\n    (-7.0, 14.0)\n\n    >>> diophantine(391,299,-69)\n    (9.0, -12.0)\n\n    But above equation has one more solution i.e., x = -4, y = 5.\n    That's why we need diophantine all solution function.\n\n    \"\"\"\n\n    assert (\n        c % greatest_common_divisor(a, b) == 0\n    )  # greatest_common_divisor(a,b) is in maths directory\n    (d, x, y) = extended_gcd(a, b)  # extended_gcd(a,b) function implemented below\n    r = c / d\n    return (r * x, r * y)",
    "docstring": "Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\ndiophantine equation a*x + b*y = c has a solution (where x and y are integers)\niff greatest_common_divisor(a,b) divides c.\n\nGCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n>>> diophantine(10,6,14)\n(-7.0, 14.0)\n\n>>> diophantine(391,299,-69)\n(9.0, -12.0)\n\nBut above equation has one more solution i.e., x = -4, y = 5.\nThat's why we need diophantine all solution function."
  },
  {
    "function": "diophantine_all_soln",
    "code": "def diophantine_all_soln(a: int, b: int, c: int, n: int = 2) -> None:\n    \"\"\"\n    Lemma : if n|ab and gcd(a,n) = 1, then n|b.\n\n    Finding All solutions of Diophantine Equations:\n\n    Theorem : Let gcd(a,b) = d, a = d*p, b = d*q. If (x0,y0) is a solution of\n    Diophantine Equation a*x + b*y = c.  a*x0 + b*y0 = c, then all the\n    solutions have the form a(x0 + t*q) + b(y0 - t*p) = c,\n    where t is an arbitrary integer.\n\n    n is the number of solution you want, n = 2 by default\n\n    >>> diophantine_all_soln(10, 6, 14)\n    -7.0 14.0\n    -4.0 9.0\n\n    >>> diophantine_all_soln(10, 6, 14, 4)\n    -7.0 14.0\n    -4.0 9.0\n    -1.0 4.0\n    2.0 -1.0\n\n    >>> diophantine_all_soln(391, 299, -69, n = 4)\n    9.0 -12.0\n    22.0 -29.0\n    35.0 -46.0\n    48.0 -63.0\n\n    \"\"\"\n    (x0, y0) = diophantine(a, b, c)  # Initial value\n    d = greatest_common_divisor(a, b)\n    p = a // d\n    q = b // d\n\n    for i in range(n):\n        x = x0 + i * q\n        y = y0 - i * p\n        print(x, y)",
    "docstring": "Lemma : if n|ab and gcd(a,n) = 1, then n|b.\n\nFinding All solutions of Diophantine Equations:\n\nTheorem : Let gcd(a,b) = d, a = d*p, b = d*q. If (x0,y0) is a solution of\nDiophantine Equation a*x + b*y = c.  a*x0 + b*y0 = c, then all the\nsolutions have the form a(x0 + t*q) + b(y0 - t*p) = c,\nwhere t is an arbitrary integer.\n\nn is the number of solution you want, n = 2 by default\n\n>>> diophantine_all_soln(10, 6, 14)\n-7.0 14.0\n-4.0 9.0\n\n>>> diophantine_all_soln(10, 6, 14, 4)\n-7.0 14.0\n-4.0 9.0\n-1.0 4.0\n2.0 -1.0\n\n>>> diophantine_all_soln(391, 299, -69, n = 4)\n9.0 -12.0\n22.0 -29.0\n35.0 -46.0\n48.0 -63.0"
  },
  {
    "function": "extended_gcd",
    "code": "def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0\n    assert b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0\n    assert b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)",
    "docstring": "Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\nx and y, then d = gcd(a,b)\n\n>>> extended_gcd(10, 6)\n(2, -1, 2)\n\n>>> extended_gcd(7, 5)\n(1, -2, 3)"
  },
  {
    "function": "and_gate",
    "code": "def and_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate AND of the input values\n\n    >>> and_gate(0, 0)\n    0\n    >>> and_gate(0, 1)\n    0\n    >>> and_gate(1, 0)\n    0\n    >>> and_gate(1, 1)\n    1\n    \"\"\"\n    return int(input_1 and input_2)",
    "docstring": "Calculate AND of the input values\n\n>>> and_gate(0, 0)\n0\n>>> and_gate(0, 1)\n0\n>>> and_gate(1, 0)\n0\n>>> and_gate(1, 1)\n1"
  },
  {
    "function": "n_input_and_gate",
    "code": "def n_input_and_gate(inputs: list[int]) -> int:\n    \"\"\"\n    Calculate AND of a list of input values\n\n    >>> n_input_and_gate([1, 0, 1, 1, 0])\n    0\n    >>> n_input_and_gate([1, 1, 1, 1, 1])\n    1\n    \"\"\"\n    return int(all(inputs))",
    "docstring": "Calculate AND of a list of input values\n\n>>> n_input_and_gate([1, 0, 1, 1, 0])\n0\n>>> n_input_and_gate([1, 1, 1, 1, 1])\n1"
  },
  {
    "function": "imply_gate",
    "code": "def imply_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate IMPLY of the input values\n\n    >>> imply_gate(0, 0)\n    1\n    >>> imply_gate(0, 1)\n    1\n    >>> imply_gate(1, 0)\n    0\n    >>> imply_gate(1, 1)\n    1\n    \"\"\"\n    return int(input_1 == 0 or input_2 == 1)",
    "docstring": "Calculate IMPLY of the input values\n\n>>> imply_gate(0, 0)\n1\n>>> imply_gate(0, 1)\n1\n>>> imply_gate(1, 0)\n0\n>>> imply_gate(1, 1)\n1"
  },
  {
    "function": "recursive_imply_list",
    "code": "def recursive_imply_list(input_list: list[int]) -> int:\n    \"\"\"\n    Recursively calculates the implication of a list.\n    Strictly the implication is applied consecutively left to right:\n    ( (a -> b) -> c ) -> d ...\n\n    >>> recursive_imply_list([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must contain at least two elements\n    >>> recursive_imply_list([0])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must contain at least two elements\n    >>> recursive_imply_list([1])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must contain at least two elements\n    >>> recursive_imply_list([0, 0])\n    1\n    >>> recursive_imply_list([0, 1])\n    1\n    >>> recursive_imply_list([1, 0])\n    0\n    >>> recursive_imply_list([1, 1])\n    1\n    >>> recursive_imply_list([0, 0, 0])\n    0\n    >>> recursive_imply_list([0, 0, 1])\n    1\n    >>> recursive_imply_list([0, 1, 0])\n    0\n    >>> recursive_imply_list([0, 1, 1])\n    1\n    >>> recursive_imply_list([1, 0, 0])\n    1\n    >>> recursive_imply_list([1, 0, 1])\n    1\n    >>> recursive_imply_list([1, 1, 0])\n    0\n    >>> recursive_imply_list([1, 1, 1])\n    1\n    \"\"\"\n    if len(input_list) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n    first_implication = imply_gate(input_list[0], input_list[1])\n    if len(input_list) == 2:\n        return first_implication\n    new_list = [first_implication, *input_list[2:]]\n    return recursive_imply_list(new_list)",
    "docstring": "Recursively calculates the implication of a list.\nStrictly the implication is applied consecutively left to right:\n( (a -> b) -> c ) -> d ...\n\n>>> recursive_imply_list([])\nTraceback (most recent call last):\n    ...\nValueError: Input list must contain at least two elements\n>>> recursive_imply_list([0])\nTraceback (most recent call last):\n    ...\nValueError: Input list must contain at least two elements\n>>> recursive_imply_list([1])\nTraceback (most recent call last):\n    ...\nValueError: Input list must contain at least two elements\n>>> recursive_imply_list([0, 0])\n1\n>>> recursive_imply_list([0, 1])\n1\n>>> recursive_imply_list([1, 0])\n0\n>>> recursive_imply_list([1, 1])\n1\n>>> recursive_imply_list([0, 0, 0])\n0\n>>> recursive_imply_list([0, 0, 1])\n1\n>>> recursive_imply_list([0, 1, 0])\n0\n>>> recursive_imply_list([0, 1, 1])\n1\n>>> recursive_imply_list([1, 0, 0])\n1\n>>> recursive_imply_list([1, 0, 1])\n1\n>>> recursive_imply_list([1, 1, 0])\n0\n>>> recursive_imply_list([1, 1, 1])\n1"
  },
  {
    "function": "simplify_kmap",
    "code": "def simplify_kmap(kmap: list[list[int]]) -> str:\n    \"\"\"\n    Simplify the Karnaugh map.\n    >>> simplify_kmap(kmap=[[0, 1], [1, 1]])\n    \"A'B + AB' + AB\"\n    >>> simplify_kmap(kmap=[[0, 0], [0, 0]])\n    ''\n    >>> simplify_kmap(kmap=[[0, 1], [1, -1]])\n    \"A'B + AB' + AB\"\n    >>> simplify_kmap(kmap=[[0, 1], [1, 2]])\n    \"A'B + AB' + AB\"\n    >>> simplify_kmap(kmap=[[0, 1], [1, 1.1]])\n    \"A'B + AB' + AB\"\n    >>> simplify_kmap(kmap=[[0, 1], [1, 'a']])\n    \"A'B + AB' + AB\"\n    \"\"\"\n    simplified_f = []\n    for a, row in enumerate(kmap):\n        for b, item in enumerate(row):\n            if item:\n                term = (\"A\" if a else \"A'\") + (\"B\" if b else \"B'\")\n                simplified_f.append(term)\n    return \" + \".join(simplified_f)",
    "docstring": "Simplify the Karnaugh map.\n>>> simplify_kmap(kmap=[[0, 1], [1, 1]])\n\"A'B + AB' + AB\"\n>>> simplify_kmap(kmap=[[0, 0], [0, 0]])\n''\n>>> simplify_kmap(kmap=[[0, 1], [1, -1]])\n\"A'B + AB' + AB\"\n>>> simplify_kmap(kmap=[[0, 1], [1, 2]])\n\"A'B + AB' + AB\"\n>>> simplify_kmap(kmap=[[0, 1], [1, 1.1]])\n\"A'B + AB' + AB\"\n>>> simplify_kmap(kmap=[[0, 1], [1, 'a']])\n\"A'B + AB' + AB\""
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Main function to create and simplify a K-Map.\n\n    >>> main()\n    [0, 1]\n    [1, 1]\n    Simplified Expression:\n    A'B + AB' + AB\n    \"\"\"\n    kmap = [[0, 1], [1, 1]]\n\n    # Manually generate the product of [0, 1] and [0, 1]\n\n    for row in kmap:\n        print(row)\n\n    print(\"Simplified Expression:\")\n    print(simplify_kmap(kmap))",
    "docstring": "Main function to create and simplify a K-Map.\n\n>>> main()\n[0, 1]\n[1, 1]\nSimplified Expression:\nA'B + AB' + AB"
  },
  {
    "function": "mux",
    "code": "def mux(input0: int, input1: int, select: int) -> int:\n    \"\"\"\n    Implement a 2-to-1 Multiplexer.\n\n    :param input0: The first input value (0 or 1).\n    :param input1: The second input value (0 or 1).\n    :param select: The select signal (0 or 1) to choose between input0 and input1.\n    :return: The output based on the select signal.  input1 if select else input0.\n\n    https://www.electrically4u.com/solved-problems-on-multiplexer\n    https://en.wikipedia.org/wiki/Multiplexer\n\n    >>> mux(0, 1, 0)\n    0\n    >>> mux(0, 1, 1)\n    1\n    >>> mux(1, 0, 0)\n    1\n    >>> mux(1, 0, 1)\n    0\n    >>> mux(2, 1, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inputs and select signal must be 0 or 1\n    >>> mux(0, -1, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inputs and select signal must be 0 or 1\n    >>> mux(0, 1, 1.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inputs and select signal must be 0 or 1\n    \"\"\"\n    if all(i in (0, 1) for i in (input0, input1, select)):\n        return input1 if select else input0\n    raise ValueError(\"Inputs and select signal must be 0 or 1\")",
    "docstring": "Implement a 2-to-1 Multiplexer.\n\n:param input0: The first input value (0 or 1).\n:param input1: The second input value (0 or 1).\n:param select: The select signal (0 or 1) to choose between input0 and input1.\n:return: The output based on the select signal.  input1 if select else input0.\n\nhttps://www.electrically4u.com/solved-problems-on-multiplexer\nhttps://en.wikipedia.org/wiki/Multiplexer\n\n>>> mux(0, 1, 0)\n0\n>>> mux(0, 1, 1)\n1\n>>> mux(1, 0, 0)\n1\n>>> mux(1, 0, 1)\n0\n>>> mux(2, 1, 0)\nTraceback (most recent call last):\n    ...\nValueError: Inputs and select signal must be 0 or 1\n>>> mux(0, -1, 0)\nTraceback (most recent call last):\n    ...\nValueError: Inputs and select signal must be 0 or 1\n>>> mux(0, 1, 1.1)\nTraceback (most recent call last):\n    ...\nValueError: Inputs and select signal must be 0 or 1"
  },
  {
    "function": "nand_gate",
    "code": "def nand_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate NAND of the input values\n    >>> nand_gate(0, 0)\n    1\n    >>> nand_gate(0, 1)\n    1\n    >>> nand_gate(1, 0)\n    1\n    >>> nand_gate(1, 1)\n    0\n    \"\"\"\n    return int(not (input_1 and input_2))",
    "docstring": "Calculate NAND of the input values\n>>> nand_gate(0, 0)\n1\n>>> nand_gate(0, 1)\n1\n>>> nand_gate(1, 0)\n1\n>>> nand_gate(1, 1)\n0"
  },
  {
    "function": "nimply_gate",
    "code": "def nimply_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate NIMPLY of the input values\n\n    >>> nimply_gate(0, 0)\n    0\n    >>> nimply_gate(0, 1)\n    0\n    >>> nimply_gate(1, 0)\n    1\n    >>> nimply_gate(1, 1)\n    0\n    \"\"\"\n    return int(input_1 == 1 and input_2 == 0)",
    "docstring": "Calculate NIMPLY of the input values\n\n>>> nimply_gate(0, 0)\n0\n>>> nimply_gate(0, 1)\n0\n>>> nimply_gate(1, 0)\n1\n>>> nimply_gate(1, 1)\n0"
  },
  {
    "function": "nor_gate",
    "code": "def nor_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    >>> nor_gate(0, 0)\n    1\n    >>> nor_gate(0, 1)\n    0\n    >>> nor_gate(1, 0)\n    0\n    >>> nor_gate(1, 1)\n    0\n    >>> nor_gate(0.0, 0.0)\n    1\n    >>> nor_gate(0, -7)\n    0\n    \"\"\"\n    return int(input_1 == input_2 == 0)",
    "docstring": ">>> nor_gate(0, 0)\n1\n>>> nor_gate(0, 1)\n0\n>>> nor_gate(1, 0)\n0\n>>> nor_gate(1, 1)\n0\n>>> nor_gate(0.0, 0.0)\n1\n>>> nor_gate(0, -7)\n0"
  },
  {
    "function": "truth_table",
    "code": "def truth_table(func: Callable) -> str:\n    \"\"\"\n    >>> print(truth_table(nor_gate))\n    Truth Table of NOR Gate:\n    | Input 1  | Input 2  |  Output  |\n    |    0     |    0     |    1     |\n    |    0     |    1     |    0     |\n    |    1     |    0     |    0     |\n    |    1     |    1     |    0     |\n    \"\"\"\n\n    def make_table_row(items: list | tuple) -> str:\n        \"\"\"\n        >>> make_table_row((\"One\", \"Two\", \"Three\"))\n        '|   One    |   Two    |  Three   |'\n        \"\"\"\n        return f\"| {' | '.join(f'{item:^8}' for item in items)} |\"\n\n    return \"\\n\".join(\n        (\n            \"Truth Table of NOR Gate:\",\n            make_table_row((\"Input 1\", \"Input 2\", \"Output\")),\n            *[make_table_row((i, j, func(i, j))) for i in (0, 1) for j in (0, 1)],\n        )\n    )",
    "docstring": ">>> print(truth_table(nor_gate))\nTruth Table of NOR Gate:\n| Input 1  | Input 2  |  Output  |\n|    0     |    0     |    1     |\n|    0     |    1     |    0     |\n|    1     |    0     |    0     |\n|    1     |    1     |    0     |"
  },
  {
    "function": "not_gate",
    "code": "def not_gate(input_1: int) -> int:\n    \"\"\"\n    Calculate NOT of the input values\n    >>> not_gate(0)\n    1\n    >>> not_gate(1)\n    0\n    \"\"\"\n\n    return 1 if input_1 == 0 else 0",
    "docstring": "Calculate NOT of the input values\n>>> not_gate(0)\n1\n>>> not_gate(1)\n0"
  },
  {
    "function": "or_gate",
    "code": "def or_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate OR of the input values\n    >>> or_gate(0, 0)\n    0\n    >>> or_gate(0, 1)\n    1\n    >>> or_gate(1, 0)\n    1\n    >>> or_gate(1, 1)\n    1\n    \"\"\"\n    return int((input_1, input_2).count(1) != 0)",
    "docstring": "Calculate OR of the input values\n>>> or_gate(0, 0)\n0\n>>> or_gate(0, 1)\n1\n>>> or_gate(1, 0)\n1\n>>> or_gate(1, 1)\n1"
  },
  {
    "function": "compare_string",
    "code": "def compare_string(string1: str, string2: str) -> str | Literal[False]:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    False\n    \"\"\"\n    list1 = list(string1)\n    list2 = list(string2)\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] != list2[i]:\n            count += 1\n            list1[i] = \"_\"\n    if count > 1:\n        return False\n    else:\n        return \"\".join(list1)",
    "docstring": ">>> compare_string('0010','0110')\n'0_10'\n\n>>> compare_string('0110','1101')\nFalse"
  },
  {
    "function": "check",
    "code": "def check(binary: list[str]) -> list[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while True:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k is False:\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(\"X\")\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))",
    "docstring": ">>> check(['0.00.01.5'])\n['0.00.01.5']"
  },
  {
    "function": "decimal_to_binary",
    "code": "def decimal_to_binary(no_of_variable: int, minterms: Sequence[float]) -> list[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    for minterm in minterms:\n        string = \"\"\n        for _ in range(no_of_variable):\n            string = str(minterm % 2) + string\n            minterm //= 2\n        temp.append(string)\n    return temp",
    "docstring": ">>> decimal_to_binary(3,[1.5])\n['0.00.01.5']"
  },
  {
    "function": "is_for_table",
    "code": "def is_for_table(string1: str, string2: str, count: int) -> bool:\n    \"\"\"\n    >>> is_for_table('__1','011',2)\n    True\n\n    >>> is_for_table('01_','001',1)\n    False\n    \"\"\"\n    list1 = list(string1)\n    list2 = list(string2)\n    count_n = sum(item1 != item2 for item1, item2 in zip(list1, list2))\n    return count_n == count",
    "docstring": ">>> is_for_table('__1','011',2)\nTrue\n\n>>> is_for_table('01_','001',1)\nFalse"
  },
  {
    "function": "selection",
    "code": "def selection(chart: list[list[int]], prime_implicants: list[str]) -> list[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = sum(row[i] == 1 for row in chart)\n        if count == 1:\n            rem = max(j for j, row in enumerate(chart) if row[i] == 1)\n            select[rem] = 1\n    for i, item in enumerate(select):\n        if item != 1:\n            continue\n        for j in range(len(chart[0])):\n            if chart[i][j] != 1:\n                continue\n            for row in chart:\n                row[j] = 0\n        temp.append(prime_implicants[i])\n    while True:\n        counts = [chart[i].count(1) for i in range(len(chart))]\n        max_n = max(counts)\n        rem = counts.index(max_n)\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for j in range(len(chart[0])):\n            if chart[rem][j] != 1:\n                continue\n            for i in range(len(chart)):\n                chart[i][j] = 0",
    "docstring": ">>> selection([[1]],['0.00.01.5'])\n['0.00.01.5']\n\n>>> selection([[1]],['0.00.01.5'])\n['0.00.01.5']"
  },
  {
    "function": "prime_implicant_chart",
    "code": "def prime_implicant_chart(\n    prime_implicants: list[str], binary: list[str]\n) -> list[list[int]]:\n    \"\"\"\n    >>> prime_implicant_chart(['0.00.01.5'],['0.00.01.5'])\n    [[1]]\n    \"\"\"\n    chart = [[0 for x in range(len(binary))] for x in range(len(prime_implicants))]\n    for i in range(len(prime_implicants)):\n        count = prime_implicants[i].count(\"_\")\n        for j in range(len(binary)):\n            if is_for_table(prime_implicants[i], binary[j], count):\n                chart[i][j] = 1\n\n    return chart",
    "docstring": ">>> prime_implicant_chart(['0.00.01.5'],['0.00.01.5'])\n[[1]]"
  },
  {
    "function": "xnor_gate",
    "code": "def xnor_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate XOR of the input values\n    >>> xnor_gate(0, 0)\n    1\n    >>> xnor_gate(0, 1)\n    0\n    >>> xnor_gate(1, 0)\n    0\n    >>> xnor_gate(1, 1)\n    1\n    \"\"\"\n    return 1 if input_1 == input_2 else 0",
    "docstring": "Calculate XOR of the input values\n>>> xnor_gate(0, 0)\n1\n>>> xnor_gate(0, 1)\n0\n>>> xnor_gate(1, 0)\n0\n>>> xnor_gate(1, 1)\n1"
  },
  {
    "function": "xor_gate",
    "code": "def xor_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    calculate xor of the input values\n\n    >>> xor_gate(0, 0)\n    0\n    >>> xor_gate(0, 1)\n    1\n    >>> xor_gate(1, 0)\n    1\n    >>> xor_gate(1, 1)\n    0\n    \"\"\"\n    return (input_1, input_2).count(0) % 2",
    "docstring": "calculate xor of the input values\n\n>>> xor_gate(0, 0)\n0\n>>> xor_gate(0, 1)\n1\n>>> xor_gate(1, 0)\n1\n>>> xor_gate(1, 1)\n0"
  },
  {
    "function": "new_generation",
    "code": "def new_generation(cells: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Generates the next generation for a given state of Conway's Game of Life.\n    >>> new_generation(BLINKER)\n    [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    \"\"\"\n    next_generation = []\n    for i in range(len(cells)):\n        next_generation_row = []\n        for j in range(len(cells[i])):\n            # Get the number of live neighbours\n            neighbour_count = 0\n            if i > 0 and j > 0:\n                neighbour_count += cells[i - 1][j - 1]\n            if i > 0:\n                neighbour_count += cells[i - 1][j]\n            if i > 0 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i - 1][j + 1]\n            if j > 0:\n                neighbour_count += cells[i][j - 1]\n            if j < len(cells[i]) - 1:\n                neighbour_count += cells[i][j + 1]\n            if i < len(cells) - 1 and j > 0:\n                neighbour_count += cells[i + 1][j - 1]\n            if i < len(cells) - 1:\n                neighbour_count += cells[i + 1][j]\n            if i < len(cells) - 1 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i + 1][j + 1]\n\n            # Rules of the game of life (excerpt from Wikipedia):\n            # 1. Any live cell with two or three live neighbours survives.\n            # 2. Any dead cell with three live neighbours becomes a live cell.\n            # 3. All other live cells die in the next generation.\n            #    Similarly, all other dead cells stay dead.\n            alive = cells[i][j] == 1\n            if (alive and 2 <= neighbour_count <= 3) or (\n                not alive and neighbour_count == 3\n            ):\n                next_generation_row.append(1)\n            else:\n                next_generation_row.append(0)\n\n        next_generation.append(next_generation_row)\n    return next_generation",
    "docstring": "Generates the next generation for a given state of Conway's Game of Life.\n>>> new_generation(BLINKER)\n[[0, 0, 0], [1, 1, 1], [0, 0, 0]]"
  },
  {
    "function": "generate_images",
    "code": "def generate_images(cells: list[list[int]], frames: int) -> list[Image.Image]:\n    \"\"\"\n    Generates a list of images of subsequent Game of Life states.\n    \"\"\"\n    images = []\n    for _ in range(frames):\n        # Create output image\n        img = Image.new(\"RGB\", (len(cells[0]), len(cells)))\n        pixels = img.load()\n\n        # Save cells to image\n        for x in range(len(cells)):\n            for y in range(len(cells[0])):\n                colour = 255 - cells[y][x] * 255\n                pixels[x, y] = (colour, colour, colour)\n\n        # Save image\n        images.append(img)\n        cells = new_generation(cells)\n    return images",
    "docstring": "Generates a list of images of subsequent Game of Life states."
  },
  {
    "function": "run",
    "code": "def run(canvas: list[list[bool]]) -> list[list[bool]]:\n    \"\"\"\n    This function runs the rules of game through all points, and changes their\n    status accordingly.(in the same canvas)\n    @Args:\n    --\n    canvas : canvas of population to run the rules on.\n\n    @returns:\n    --\n    canvas of population after one step\n    \"\"\"\n    current_canvas = np.array(canvas)\n    next_gen_canvas = np.array(create_canvas(current_canvas.shape[0]))\n    for r, row in enumerate(current_canvas):\n        for c, pt in enumerate(row):\n            next_gen_canvas[r][c] = __judge_point(\n                pt, current_canvas[r - 1 : r + 2, c - 1 : c + 2]\n            )\n\n    return next_gen_canvas.tolist()",
    "docstring": "This function runs the rules of game through all points, and changes their\nstatus accordingly.(in the same canvas)\n@Args:\n--\ncanvas : canvas of population to run the rules on.\n\n@returns:\n--\ncanvas of population after one step"
  },
  {
    "function": "construct_highway",
    "code": "def construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway",
    "docstring": "Build the highway following the parameters given\n>>> construct_highway(10, 2, 6)\n[[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n>>> construct_highway(10, 10, 2)\n[[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]"
  },
  {
    "function": "get_distance",
    "code": "def get_distance(highway_now: list, car_index: int) -> int:\n    \"\"\"\n    Get the distance between a car (at index car_index) and the next car\n    >>> get_distance([6, -1, 6, -1, 6], 2)\n    1\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n    3\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n    4\n    \"\"\"\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)",
    "docstring": "Get the distance between a car (at index car_index) and the next car\n>>> get_distance([6, -1, 6, -1, 6], 2)\n1\n>>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n3\n>>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n4"
  },
  {
    "function": "update",
    "code": "def update(highway_now: list, probability: float, max_speed: int) -> list:\n    \"\"\"\n    Update the speed of the cars\n    >>> update([-1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)\n    [-1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 4]\n    >>> update([-1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)\n    [-1, -1, 3, -1, -1, -1, -1, 1]\n    \"\"\"\n\n    number_of_cells = len(highway_now)\n    # Beforce calculations, the highway is empty\n    next_highway = [-1] * number_of_cells\n\n    for car_index in range(number_of_cells):\n        if highway_now[car_index] != -1:\n            # Add 1 to the current speed of the car and cap the speed\n            next_highway[car_index] = min(highway_now[car_index] + 1, max_speed)\n            # Number of empty cell before the next car\n            dn = get_distance(highway_now, car_index) - 1\n            # We can't have the car causing an accident\n            next_highway[car_index] = min(next_highway[car_index], dn)\n            if random() < probability:\n                # Randomly, a driver will slow down\n                next_highway[car_index] = max(next_highway[car_index] - 1, 0)\n    return next_highway",
    "docstring": "Update the speed of the cars\n>>> update([-1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)\n[-1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 4]\n>>> update([-1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)\n[-1, -1, 3, -1, -1, -1, -1, 1]"
  },
  {
    "function": "simulate",
    "code": "def simulate(\n    highway: list, number_of_update: int, probability: float, max_speed: int\n) -> list:\n    \"\"\"\n    The main function, it will simulate the evolution of the highway\n    >>> simulate([[-1, 2, -1, -1, -1, 3]], 2, 0.0, 3)\n    [[-1, 2, -1, -1, -1, 3], [-1, -1, -1, 2, -1, 0], [1, -1, -1, 0, -1, -1]]\n    >>> simulate([[-1, 2, -1, 3]], 4, 0.0, 3)\n    [[-1, 2, -1, 3], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0]]\n    \"\"\"\n\n    number_of_cells = len(highway[0])\n\n    for i in range(number_of_update):\n        next_speeds_calculated = update(highway[i], probability, max_speed)\n        real_next_speeds = [-1] * number_of_cells\n\n        for car_index in range(number_of_cells):\n            speed = next_speeds_calculated[car_index]\n            if speed != -1:\n                # Change the position based on the speed (with % to create the loop)\n                index = (car_index + speed) % number_of_cells\n                # Commit the change of position\n                real_next_speeds[index] = speed\n        highway.append(real_next_speeds)\n\n    return highway",
    "docstring": "The main function, it will simulate the evolution of the highway\n>>> simulate([[-1, 2, -1, -1, -1, 3]], 2, 0.0, 3)\n[[-1, 2, -1, -1, -1, 3], [-1, -1, -1, 2, -1, 0], [1, -1, -1, 0, -1, -1]]\n>>> simulate([[-1, 2, -1, 3]], 4, 0.0, 3)\n[[-1, 2, -1, 3], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0]]"
  },
  {
    "function": "format_ruleset",
    "code": "def format_ruleset(ruleset: int) -> list[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]",
    "docstring": ">>> format_ruleset(11100)\n[0, 0, 0, 1, 1, 1, 0, 0]\n>>> format_ruleset(0)\n[0, 0, 0, 0, 0, 0, 0, 0]\n>>> format_ruleset(11111111)\n[1, 1, 1, 1, 1, 1, 1, 1]"
  },
  {
    "function": "generate_image",
    "code": "def generate_image(cells: list[list[int]]) -> Image.Image:\n    \"\"\"\n    Convert the cells into a greyscale PIL.Image.Image and return it to the caller.\n    >>> from random import random\n    >>> cells = [[random() for w in range(31)] for h in range(16)]\n    >>> img = generate_image(cells)\n    >>> isinstance(img, Image.Image)\n    True\n    >>> img.width, img.height\n    (31, 16)\n    \"\"\"\n    # Create the output image\n    img = Image.new(\"RGB\", (len(cells[0]), len(cells)))\n    pixels = img.load()\n    # Generates image\n    for w in range(img.width):\n        for h in range(img.height):\n            color = 255 - int(255 * cells[h][w])\n            pixels[w, h] = (color, color, color)\n    return img",
    "docstring": "Convert the cells into a greyscale PIL.Image.Image and return it to the caller.\n>>> from random import random\n>>> cells = [[random() for w in range(31)] for h in range(16)]\n>>> img = generate_image(cells)\n>>> isinstance(img, Image.Image)\nTrue\n>>> img.width, img.height\n(31, 16)"
  },
  {
    "function": "visualise",
    "code": "def visualise(wt: WaTor, iter_number: int, *, colour: bool = True) -> None:\n    \"\"\"\n    Visually displays the Wa-Tor planet using\n    an ascii code in terminal to clear and re-print\n    the Wa-Tor planet at intervals.\n\n    Uses ascii colour codes to colourfully display the predators and prey:\n        * (0x60f197) Prey = ``#``\n        * (0xfffff) Predator = ``x``\n\n    >>> wt = WaTor(30, 30)\n    >>> wt.set_planet([\n    ... [Entity(True, coords=(0, 0)), Entity(False, coords=(0, 1)), None],\n    ... [Entity(False, coords=(1, 0)), None, Entity(False, coords=(1, 2))],\n    ... [None, Entity(True, coords=(2, 1)), None]\n    ... ])\n    >>> visualise(wt, 0, colour=False)  # doctest: +NORMALIZE_WHITESPACE\n    #  x  .\n    x  .  x\n    .  #  .\n    <BLANKLINE>\n    Iteration: 0 | Prey count: 2 | Predator count: 3 |\n    \"\"\"\n    if colour:\n        __import__(\"os\").system(\"\")\n        print(\"\\x1b[0;0H\\x1b[2J\\x1b[?25l\")\n\n    reprint = \"\\x1b[0;0H\" if colour else \"\"\n    ansi_colour_end = \"\\x1b[0m \" if colour else \" \"\n\n    planet = wt.planet\n    output = \"\"\n\n    # Iterate over every entity in the planet\n    for row in planet:\n        for entity in row:\n            if entity is None:\n                output += \" . \"\n            else:\n                if colour is True:\n                    output += (\n                        \"\\x1b[38;2;96;241;151m\"\n                        if entity.prey\n                        else \"\\x1b[38;2;255;255;15m\"\n                    )\n                output += f\" {'#' if entity.prey else 'x'}{ansi_colour_end}\"\n\n        output += \"\\n\"\n\n    entities = wt.get_entities()\n    prey_count = sum(entity.prey for entity in entities)\n\n    print(\n        f\"{output}\\n Iteration: {iter_number} | Prey count: {prey_count} | \"\n        f\"Predator count: {len(entities) - prey_count} | {reprint}\"\n    )\n    # Block the thread to be able to visualise seeing the algorithm\n    sleep(0.05)",
    "docstring": "Visually displays the Wa-Tor planet using\nan ascii code in terminal to clear and re-print\nthe Wa-Tor planet at intervals.\n\nUses ascii colour codes to colourfully display the predators and prey:\n    * (0x60f197) Prey = ``#``\n    * (0xfffff) Predator = ``x``\n\n>>> wt = WaTor(30, 30)\n>>> wt.set_planet([\n... [Entity(True, coords=(0, 0)), Entity(False, coords=(0, 1)), None],\n... [Entity(False, coords=(1, 0)), None, Entity(False, coords=(1, 2))],\n... [None, Entity(True, coords=(2, 1)), None]\n... ])\n>>> visualise(wt, 0, colour=False)  # doctest: +NORMALIZE_WHITESPACE\n#  x  .\nx  .  x\n.  #  .\n<BLANKLINE>\nIteration: 0 | Prey count: 2 | Predator count: 3 |"
  },
  {
    "function": "encode",
    "code": "def encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]",
    "docstring": ">>> encode(\"myname\")\n[13, 25, 14, 1, 13, 5]"
  },
  {
    "function": "decode",
    "code": "def decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)",
    "docstring": ">>> decode([13, 25, 14, 1, 13, 5])\n'myname'"
  },
  {
    "function": "encrypt_message",
    "code": "def encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(4545, 'The affine cipher is a type of monoalphabetic '\n    ...                       'substitution cipher.')\n    'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF{xIp~{HL}Gi'\n    \"\"\"\n    key_a, key_b = divmod(key, len(SYMBOLS))\n    check_keys(key_a, key_b, \"encrypt\")\n    cipher_text = \"\"\n    for symbol in message:\n        if symbol in SYMBOLS:\n            sym_index = SYMBOLS.find(symbol)\n            cipher_text += SYMBOLS[(sym_index * key_a + key_b) % len(SYMBOLS)]\n        else:\n            cipher_text += symbol\n    return cipher_text",
    "docstring": ">>> encrypt_message(4545, 'The affine cipher is a type of monoalphabetic '\n...                       'substitution cipher.')\n'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF{xIp~{HL}Gi'"
  },
  {
    "function": "decrypt_message",
    "code": "def decrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> decrypt_message(4545, 'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF'\n    ...                       '{xIp~{HL}Gi')\n    'The affine cipher is a type of monoalphabetic substitution cipher.'\n    \"\"\"\n    key_a, key_b = divmod(key, len(SYMBOLS))\n    check_keys(key_a, key_b, \"decrypt\")\n    plain_text = \"\"\n    mod_inverse_of_key_a = cryptomath.find_mod_inverse(key_a, len(SYMBOLS))\n    for symbol in message:\n        if symbol in SYMBOLS:\n            sym_index = SYMBOLS.find(symbol)\n            plain_text += SYMBOLS[\n                (sym_index - key_b) * mod_inverse_of_key_a % len(SYMBOLS)\n            ]\n        else:\n            plain_text += symbol\n    return plain_text",
    "docstring": ">>> decrypt_message(4545, 'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF'\n...                       '{xIp~{HL}Gi')\n'The affine cipher is a type of monoalphabetic substitution cipher.'"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    >>> key = get_random_key()\n    >>> msg = \"This is a test!\"\n    >>> decrypt_message(key, encrypt_message(key, msg)) == msg\n    True\n    \"\"\"\n    message = input(\"Enter message: \").strip()\n    key = int(input(\"Enter key [2000 - 9000]: \").strip())\n    mode = input(\"Encrypt/Decrypt [E/D]: \").strip().lower()\n\n    if mode.startswith(\"e\"):\n        mode = \"encrypt\"\n        translated = encrypt_message(key, message)\n    elif mode.startswith(\"d\"):\n        mode = \"decrypt\"\n        translated = decrypt_message(key, message)\n    print(f\"\\n{mode.title()}ed text: \\n{translated}\")",
    "docstring": ">>> key = get_random_key()\n>>> msg = \"This is a test!\"\n>>> decrypt_message(key, encrypt_message(key, msg)) == msg\nTrue"
  },
  {
    "function": "atbash_slow",
    "code": "def atbash_slow(sequence: str) -> str:\n    \"\"\"\n    >>> atbash_slow(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash_slow(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    output = \"\"\n    for i in sequence:\n        extract = ord(i)\n        if 65 <= extract <= 90:\n            output += chr(155 - extract)\n        elif 97 <= extract <= 122:\n            output += chr(219 - extract)\n        else:\n            output += i\n    return output",
    "docstring": ">>> atbash_slow(\"ABCDEFG\")\n'ZYXWVUT'\n\n>>> atbash_slow(\"aW;;123BX\")\n'zD;;123YC'"
  },
  {
    "function": "atbash",
    "code": "def atbash(sequence: str) -> str:\n    \"\"\"\n    >>> atbash(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    letters = string.ascii_letters\n    letters_reversed = string.ascii_lowercase[::-1] + string.ascii_uppercase[::-1]\n    return \"\".join(\n        letters_reversed[letters.index(c)] if c in letters else c for c in sequence\n    )",
    "docstring": ">>> atbash(\"ABCDEFG\")\n'ZYXWVUT'\n\n>>> atbash(\"aW;;123BX\")\n'zD;;123YC'"
  },
  {
    "function": "benchmark",
    "code": "def benchmark() -> None:\n    \"\"\"Let's benchmark our functions side-by-side...\"\"\"\n    from timeit import timeit\n\n    print(\"Running performance benchmarks...\")\n    setup = \"from string import printable ; from __main__ import atbash, atbash_slow\"\n    print(f\"> atbash_slow(): {timeit('atbash_slow(printable)', setup=setup)} seconds\")\n    print(f\">      atbash(): {timeit('atbash(printable)', setup=setup)} seconds\")",
    "docstring": "Let's benchmark our functions side-by-side..."
  },
  {
    "function": "encrypt",
    "code": "def encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    Encrypt a given `plaintext` (string) and `key` (string), returning the\n    encrypted ciphertext.\n\n    >>> encrypt(\"hello world\", \"coffee\")\n    'jsqqs avvwo'\n    >>> encrypt(\"coffee is good as python\", \"TheAlgorithms\")\n    'vvjfpk wj ohvp su ddylsv'\n    >>> encrypt(\"coffee is good as python\", 2)\n    Traceback (most recent call last):\n        ...\n    TypeError: key must be a string\n    >>> encrypt(\"\", \"TheAlgorithms\")\n    Traceback (most recent call last):\n        ...\n    ValueError: plaintext is empty\n    >>> encrypt(\"coffee is good as python\", \"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: key is empty\n    >>> encrypt(527.26, \"TheAlgorithms\")\n    Traceback (most recent call last):\n        ...\n    TypeError: plaintext must be a string\n    \"\"\"\n    if not isinstance(plaintext, str):\n        raise TypeError(\"plaintext must be a string\")\n    if not isinstance(key, str):\n        raise TypeError(\"key must be a string\")\n\n    if not plaintext:\n        raise ValueError(\"plaintext is empty\")\n    if not key:\n        raise ValueError(\"key is empty\")\n\n    key += plaintext\n    plaintext = plaintext.lower()\n    key = key.lower()\n    plaintext_iterator = 0\n    key_iterator = 0\n    ciphertext = \"\"\n    while plaintext_iterator < len(plaintext):\n        if (\n            ord(plaintext[plaintext_iterator]) < 97\n            or ord(plaintext[plaintext_iterator]) > 122\n        ):\n            ciphertext += plaintext[plaintext_iterator]\n            plaintext_iterator += 1\n        elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:\n            key_iterator += 1\n        else:\n            ciphertext += chr(\n                (\n                    (ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))\n                    - 97\n                )\n                % 26\n                + 97\n            )\n            key_iterator += 1\n            plaintext_iterator += 1\n    return ciphertext",
    "docstring": "Encrypt a given `plaintext` (string) and `key` (string), returning the\nencrypted ciphertext.\n\n>>> encrypt(\"hello world\", \"coffee\")\n'jsqqs avvwo'\n>>> encrypt(\"coffee is good as python\", \"TheAlgorithms\")\n'vvjfpk wj ohvp su ddylsv'\n>>> encrypt(\"coffee is good as python\", 2)\nTraceback (most recent call last):\n    ...\nTypeError: key must be a string\n>>> encrypt(\"\", \"TheAlgorithms\")\nTraceback (most recent call last):\n    ...\nValueError: plaintext is empty\n>>> encrypt(\"coffee is good as python\", \"\")\nTraceback (most recent call last):\n    ...\nValueError: key is empty\n>>> encrypt(527.26, \"TheAlgorithms\")\nTraceback (most recent call last):\n    ...\nTypeError: plaintext must be a string"
  },
  {
    "function": "decrypt",
    "code": "def decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    Decrypt a given `ciphertext` (string) and `key` (string), returning the decrypted\n    ciphertext.\n\n    >>> decrypt(\"jsqqs avvwo\", \"coffee\")\n    'hello world'\n    >>> decrypt(\"vvjfpk wj ohvp su ddylsv\", \"TheAlgorithms\")\n    'coffee is good as python'\n    >>> decrypt(\"vvjfpk wj ohvp su ddylsv\", \"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: key is empty\n    >>> decrypt(527.26, \"TheAlgorithms\")\n    Traceback (most recent call last):\n        ...\n    TypeError: ciphertext must be a string\n    >>> decrypt(\"\", \"TheAlgorithms\")\n    Traceback (most recent call last):\n        ...\n    ValueError: ciphertext is empty\n    >>> decrypt(\"vvjfpk wj ohvp su ddylsv\", 2)\n    Traceback (most recent call last):\n        ...\n    TypeError: key must be a string\n    \"\"\"\n    if not isinstance(ciphertext, str):\n        raise TypeError(\"ciphertext must be a string\")\n    if not isinstance(key, str):\n        raise TypeError(\"key must be a string\")\n\n    if not ciphertext:\n        raise ValueError(\"ciphertext is empty\")\n    if not key:\n        raise ValueError(\"key is empty\")\n\n    key = key.lower()\n    ciphertext_iterator = 0\n    key_iterator = 0\n    plaintext = \"\"\n    while ciphertext_iterator < len(ciphertext):\n        if (\n            ord(ciphertext[ciphertext_iterator]) < 97\n            or ord(ciphertext[ciphertext_iterator]) > 122\n        ):\n            plaintext += ciphertext[ciphertext_iterator]\n        else:\n            plaintext += chr(\n                (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26\n                + 97\n            )\n            key += chr(\n                (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26\n                + 97\n            )\n            key_iterator += 1\n        ciphertext_iterator += 1\n    return plaintext",
    "docstring": "Decrypt a given `ciphertext` (string) and `key` (string), returning the decrypted\nciphertext.\n\n>>> decrypt(\"jsqqs avvwo\", \"coffee\")\n'hello world'\n>>> decrypt(\"vvjfpk wj ohvp su ddylsv\", \"TheAlgorithms\")\n'coffee is good as python'\n>>> decrypt(\"vvjfpk wj ohvp su ddylsv\", \"\")\nTraceback (most recent call last):\n    ...\nValueError: key is empty\n>>> decrypt(527.26, \"TheAlgorithms\")\nTraceback (most recent call last):\n    ...\nTypeError: ciphertext must be a string\n>>> decrypt(\"\", \"TheAlgorithms\")\nTraceback (most recent call last):\n    ...\nValueError: ciphertext is empty\n>>> decrypt(\"vvjfpk wj ohvp su ddylsv\", 2)\nTraceback (most recent call last):\n    ...\nTypeError: key must be a string"
  },
  {
    "function": "encode",
    "code": "def encode(word: str) -> str:\n    \"\"\"\n    Encodes to Baconian cipher\n\n    >>> encode(\"hello\")\n    'AABBBAABAAABABAABABAABBAB'\n    >>> encode(\"hello world\")\n    'AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB'\n    >>> encode(\"hello world!\")\n    Traceback (most recent call last):\n        ...\n    Exception: encode() accepts only letters of the alphabet and spaces\n    \"\"\"\n    encoded = \"\"\n    for letter in word.lower():\n        if letter.isalpha() or letter == \" \":\n            encoded += encode_dict[letter]\n        else:\n            raise Exception(\"encode() accepts only letters of the alphabet and spaces\")\n    return encoded",
    "docstring": "Encodes to Baconian cipher\n\n>>> encode(\"hello\")\n'AABBBAABAAABABAABABAABBAB'\n>>> encode(\"hello world\")\n'AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB'\n>>> encode(\"hello world!\")\nTraceback (most recent call last):\n    ...\nException: encode() accepts only letters of the alphabet and spaces"
  },
  {
    "function": "decode",
    "code": "def decode(coded: str) -> str:\n    \"\"\"\n    Decodes from Baconian cipher\n\n    >>> decode(\"AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB\")\n    'hello world'\n    >>> decode(\"AABBBAABAAABABAABABAABBAB\")\n    'hello'\n    >>> decode(\"AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB!\")\n    Traceback (most recent call last):\n        ...\n    Exception: decode() accepts only 'A', 'B' and spaces\n    \"\"\"\n    if set(coded) - {\"A\", \"B\", \" \"} != set():\n        raise Exception(\"decode() accepts only 'A', 'B' and spaces\")\n    decoded = \"\"\n    for word in coded.split():\n        while len(word) != 0:\n            decoded += decode_dict[word[:5]]\n            word = word[5:]\n        decoded += \" \"\n    return decoded.strip()",
    "docstring": "Decodes from Baconian cipher\n\n>>> decode(\"AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB\")\n'hello world'\n>>> decode(\"AABBBAABAAABABAABABAABBAB\")\n'hello'\n>>> decode(\"AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB!\")\nTraceback (most recent call last):\n    ...\nException: decode() accepts only 'A', 'B' and spaces"
  },
  {
    "function": "base16_encode",
    "code": "def base16_encode(data: bytes) -> str:\n    \"\"\"\n    Encodes the given bytes into base16.\n\n    >>> base16_encode(b'Hello World!')\n    '48656C6C6F20576F726C6421'\n    >>> base16_encode(b'HELLO WORLD!')\n    '48454C4C4F20574F524C4421'\n    >>> base16_encode(b'')\n    ''\n    \"\"\"\n    # Turn the data into a list of integers (where each integer is a byte),\n    # Then turn each byte into its hexadecimal representation, make sure\n    # it is uppercase, and then join everything together and return it.\n    return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])",
    "docstring": "Encodes the given bytes into base16.\n\n>>> base16_encode(b'Hello World!')\n'48656C6C6F20576F726C6421'\n>>> base16_encode(b'HELLO WORLD!')\n'48454C4C4F20574F524C4421'\n>>> base16_encode(b'')\n''"
  },
  {
    "function": "base16_decode",
    "code": "def base16_decode(data: str) -> bytes:\n    \"\"\"\n    Decodes the given base16 encoded data into bytes.\n\n    >>> base16_decode('48656C6C6F20576F726C6421')\n    b'Hello World!'\n    >>> base16_decode('48454C4C4F20574F524C4421')\n    b'HELLO WORLD!'\n    >>> base16_decode('')\n    b''\n    >>> base16_decode('486')\n    Traceback (most recent call last):\n      ...\n    ValueError: Base16 encoded data is invalid:\n    Data does not have an even number of hex digits.\n    >>> base16_decode('48656c6c6f20576f726c6421')\n    Traceback (most recent call last):\n      ...\n    ValueError: Base16 encoded data is invalid:\n    Data is not uppercase hex or it contains invalid characters.\n    >>> base16_decode('This is not base64 encoded data.')\n    Traceback (most recent call last):\n      ...\n    ValueError: Base16 encoded data is invalid:\n    Data is not uppercase hex or it contains invalid characters.\n    \"\"\"\n    # Check data validity, following RFC3548\n    # https://www.ietf.org/rfc/rfc3548.txt\n    if (len(data) % 2) != 0:\n        raise ValueError(\n            \"\"\"Base16 encoded data is invalid:\nData does not have an even number of hex digits.\"\"\"\n        )\n    # Check the character set - the standard base16 alphabet\n    # is uppercase according to RFC3548 section 6\n    if not set(data) <= set(\"0123456789ABCDEF\"):\n        raise ValueError(\n            \"\"\"Base16 encoded data is invalid:\nData is not uppercase hex or it contains invalid characters.\"\"\"\n        )\n    # For every two hexadecimal digits (= a byte), turn it into an integer.\n    # Then, string the result together into bytes, and return it.\n    return bytes(int(data[i] + data[i + 1], 16) for i in range(0, len(data), 2))",
    "docstring": "Decodes the given base16 encoded data into bytes.\n\n>>> base16_decode('48656C6C6F20576F726C6421')\nb'Hello World!'\n>>> base16_decode('48454C4C4F20574F524C4421')\nb'HELLO WORLD!'\n>>> base16_decode('')\nb''\n>>> base16_decode('486')\nTraceback (most recent call last):\n  ...\nValueError: Base16 encoded data is invalid:\nData does not have an even number of hex digits.\n>>> base16_decode('48656c6c6f20576f726c6421')\nTraceback (most recent call last):\n  ...\nValueError: Base16 encoded data is invalid:\nData is not uppercase hex or it contains invalid characters.\n>>> base16_decode('This is not base64 encoded data.')\nTraceback (most recent call last):\n  ...\nValueError: Base16 encoded data is invalid:\nData is not uppercase hex or it contains invalid characters."
  },
  {
    "function": "base32_encode",
    "code": "def base32_encode(data: bytes) -> bytes:\n    \"\"\"\n    >>> base32_encode(b\"Hello World!\")\n    b'JBSWY3DPEBLW64TMMQQQ===='\n    >>> base32_encode(b\"123456\")\n    b'GEZDGNBVGY======'\n    >>> base32_encode(b\"some long complex string\")\n    b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY='\n    \"\"\"\n    binary_data = \"\".join(bin(ord(d))[2:].zfill(8) for d in data.decode(\"utf-8\"))\n    binary_data = binary_data.ljust(5 * ((len(binary_data) // 5) + 1), \"0\")\n    b32_chunks = map(\"\".join, zip(*[iter(binary_data)] * 5))\n    b32_result = \"\".join(B32_CHARSET[int(chunk, 2)] for chunk in b32_chunks)\n    return bytes(b32_result.ljust(8 * ((len(b32_result) // 8) + 1), \"=\"), \"utf-8\")",
    "docstring": ">>> base32_encode(b\"Hello World!\")\nb'JBSWY3DPEBLW64TMMQQQ===='\n>>> base32_encode(b\"123456\")\nb'GEZDGNBVGY======'\n>>> base32_encode(b\"some long complex string\")\nb'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY='"
  },
  {
    "function": "base32_decode",
    "code": "def base32_decode(data: bytes) -> bytes:\n    \"\"\"\n    >>> base32_decode(b'JBSWY3DPEBLW64TMMQQQ====')\n    b'Hello World!'\n    >>> base32_decode(b'GEZDGNBVGY======')\n    b'123456'\n    >>> base32_decode(b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY=')\n    b'some long complex string'\n    \"\"\"\n    binary_chunks = \"\".join(\n        bin(B32_CHARSET.index(_d))[2:].zfill(5)\n        for _d in data.decode(\"utf-8\").strip(\"=\")\n    )\n    binary_data = list(map(\"\".join, zip(*[iter(binary_chunks)] * 8)))\n    return bytes(\"\".join([chr(int(_d, 2)) for _d in binary_data]), \"utf-8\")",
    "docstring": ">>> base32_decode(b'JBSWY3DPEBLW64TMMQQQ====')\nb'Hello World!'\n>>> base32_decode(b'GEZDGNBVGY======')\nb'123456'\n>>> base32_decode(b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY=')\nb'some long complex string'"
  },
  {
    "function": "base64_encode",
    "code": "def base64_encode(data: bytes) -> bytes:\n    \"\"\"Encodes data according to RFC4648.\n\n    The data is first transformed to binary and appended with binary digits so that its\n    length becomes a multiple of 6, then each 6 binary digits will match a character in\n    the B64_CHARSET string. The number of appended binary digits would later determine\n    how many \"=\" signs should be added, the padding.\n    For every 2 binary digits added, a \"=\" sign is added in the output.\n    We can add any binary digits to make it a multiple of 6, for instance, consider the\n    following example:\n    \"AA\" -> 0010100100101001 -> 001010 010010 1001\n    As can be seen above, 2 more binary digits should be added, so there's 4\n    possibilities here: 00, 01, 10 or 11.\n    That being said, Base64 encoding can be used in Steganography to hide data in these\n    appended digits.\n\n    >>> from base64 import b64encode\n    >>> a = b\"This pull request is part of Hacktoberfest20!\"\n    >>> b = b\"https://tools.ietf.org/html/rfc4648\"\n    >>> c = b\"A\"\n    >>> base64_encode(a) == b64encode(a)\n    True\n    >>> base64_encode(b) == b64encode(b)\n    True\n    >>> base64_encode(c) == b64encode(c)\n    True\n    >>> base64_encode(\"abc\")\n    Traceback (most recent call last):\n      ...\n    TypeError: a bytes-like object is required, not 'str'\n    \"\"\"\n    # Make sure the supplied data is a bytes-like object\n    if not isinstance(data, bytes):\n        msg = f\"a bytes-like object is required, not '{data.__class__.__name__}'\"\n        raise TypeError(msg)\n\n    binary_stream = \"\".join(bin(byte)[2:].zfill(8) for byte in data)\n\n    padding_needed = len(binary_stream) % 6 != 0\n\n    if padding_needed:\n        # The padding that will be added later\n        padding = b\"=\" * ((6 - len(binary_stream) % 6) // 2)\n\n        # Append binary_stream with arbitrary binary digits (0's by default) to make its\n        # length a multiple of 6.\n        binary_stream += \"0\" * (6 - len(binary_stream) % 6)\n    else:\n        padding = b\"\"\n\n    # Encode every 6 binary digits to their corresponding Base64 character\n    return (\n        \"\".join(\n            B64_CHARSET[int(binary_stream[index : index + 6], 2)]\n            for index in range(0, len(binary_stream), 6)\n        ).encode()\n        + padding\n    )",
    "docstring": "Encodes data according to RFC4648.\n\nThe data is first transformed to binary and appended with binary digits so that its\nlength becomes a multiple of 6, then each 6 binary digits will match a character in\nthe B64_CHARSET string. The number of appended binary digits would later determine\nhow many \"=\" signs should be added, the padding.\nFor every 2 binary digits added, a \"=\" sign is added in the output.\nWe can add any binary digits to make it a multiple of 6, for instance, consider the\nfollowing example:\n\"AA\" -> 0010100100101001 -> 001010 010010 1001\nAs can be seen above, 2 more binary digits should be added, so there's 4\npossibilities here: 00, 01, 10 or 11.\nThat being said, Base64 encoding can be used in Steganography to hide data in these\nappended digits.\n\n>>> from base64 import b64encode\n>>> a = b\"This pull request is part of Hacktoberfest20!\"\n>>> b = b\"https://tools.ietf.org/html/rfc4648\"\n>>> c = b\"A\"\n>>> base64_encode(a) == b64encode(a)\nTrue\n>>> base64_encode(b) == b64encode(b)\nTrue\n>>> base64_encode(c) == b64encode(c)\nTrue\n>>> base64_encode(\"abc\")\nTraceback (most recent call last):\n  ...\nTypeError: a bytes-like object is required, not 'str'"
  },
  {
    "function": "base64_decode",
    "code": "def base64_decode(encoded_data: str) -> bytes:\n    \"\"\"Decodes data according to RFC4648.\n\n    This does the reverse operation of base64_encode.\n    We first transform the encoded data back to a binary stream, take off the\n    previously appended binary digits according to the padding, at this point we\n    would have a binary stream whose length is multiple of 8, the last step is\n    to convert every 8 bits to a byte.\n\n    >>> from base64 import b64decode\n    >>> a = \"VGhpcyBwdWxsIHJlcXVlc3QgaXMgcGFydCBvZiBIYWNrdG9iZXJmZXN0MjAh\"\n    >>> b = \"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2NDg=\"\n    >>> c = \"QQ==\"\n    >>> base64_decode(a) == b64decode(a)\n    True\n    >>> base64_decode(b) == b64decode(b)\n    True\n    >>> base64_decode(c) == b64decode(c)\n    True\n    >>> base64_decode(\"abc\")\n    Traceback (most recent call last):\n      ...\n    AssertionError: Incorrect padding\n    \"\"\"\n    # Make sure encoded_data is either a string or a bytes-like object\n    if not isinstance(encoded_data, bytes) and not isinstance(encoded_data, str):\n        msg = (\n            \"argument should be a bytes-like object or ASCII string, \"\n            f\"not '{encoded_data.__class__.__name__}'\"\n        )\n        raise TypeError(msg)\n\n    # In case encoded_data is a bytes-like object, make sure it contains only\n    # ASCII characters so we convert it to a string object\n    if isinstance(encoded_data, bytes):\n        try:\n            encoded_data = encoded_data.decode(\"utf-8\")\n        except UnicodeDecodeError:\n            raise ValueError(\"base64 encoded data should only contain ASCII characters\")\n\n    padding = encoded_data.count(\"=\")\n\n    # Check if the encoded string contains non base64 characters\n    if padding:\n        assert all(char in B64_CHARSET for char in encoded_data[:-padding]), (\n            \"Invalid base64 character(s) found.\"\n        )\n    else:\n        assert all(char in B64_CHARSET for char in encoded_data), (\n            \"Invalid base64 character(s) found.\"\n        )\n\n    # Check the padding\n    assert len(encoded_data) % 4 == 0 and padding < 3, \"Incorrect padding\"\n\n    if padding:\n        # Remove padding if there is one\n        encoded_data = encoded_data[:-padding]\n\n        binary_stream = \"\".join(\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\n        )[: -padding * 2]\n    else:\n        binary_stream = \"\".join(\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\n        )\n\n    data = [\n        int(binary_stream[index : index + 8], 2)\n        for index in range(0, len(binary_stream), 8)\n    ]\n\n    return bytes(data)",
    "docstring": "Decodes data according to RFC4648.\n\nThis does the reverse operation of base64_encode.\nWe first transform the encoded data back to a binary stream, take off the\npreviously appended binary digits according to the padding, at this point we\nwould have a binary stream whose length is multiple of 8, the last step is\nto convert every 8 bits to a byte.\n\n>>> from base64 import b64decode\n>>> a = \"VGhpcyBwdWxsIHJlcXVlc3QgaXMgcGFydCBvZiBIYWNrdG9iZXJmZXN0MjAh\"\n>>> b = \"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2NDg=\"\n>>> c = \"QQ==\"\n>>> base64_decode(a) == b64decode(a)\nTrue\n>>> base64_decode(b) == b64decode(b)\nTrue\n>>> base64_decode(c) == b64decode(c)\nTrue\n>>> base64_decode(\"abc\")\nTraceback (most recent call last):\n  ...\nAssertionError: Incorrect padding"
  },
  {
    "function": "ascii85_encode",
    "code": "def ascii85_encode(data: bytes) -> bytes:\n    \"\"\"\n    >>> ascii85_encode(b\"\")\n    b''\n    >>> ascii85_encode(b\"12345\")\n    b'0etOA2#'\n    >>> ascii85_encode(b\"base 85\")\n    b'@UX=h+?24'\n    \"\"\"\n    binary_data = \"\".join(bin(ord(d))[2:].zfill(8) for d in data.decode(\"utf-8\"))\n    null_values = (32 * ((len(binary_data) // 32) + 1) - len(binary_data)) // 8\n    binary_data = binary_data.ljust(32 * ((len(binary_data) // 32) + 1), \"0\")\n    b85_chunks = [int(_s, 2) for _s in map(\"\".join, zip(*[iter(binary_data)] * 32))]\n    result = \"\".join(_base10_to_85(chunk)[::-1] for chunk in b85_chunks)\n    return bytes(result[:-null_values] if null_values % 4 != 0 else result, \"utf-8\")",
    "docstring": ">>> ascii85_encode(b\"\")\nb''\n>>> ascii85_encode(b\"12345\")\nb'0etOA2#'\n>>> ascii85_encode(b\"base 85\")\nb'@UX=h+?24'"
  },
  {
    "function": "ascii85_decode",
    "code": "def ascii85_decode(data: bytes) -> bytes:\n    \"\"\"\n    >>> ascii85_decode(b\"\")\n    b''\n    >>> ascii85_decode(b\"0etOA2#\")\n    b'12345'\n    >>> ascii85_decode(b\"@UX=h+?24\")\n    b'base 85'\n    \"\"\"\n    null_values = 5 * ((len(data) // 5) + 1) - len(data)\n    binary_data = data.decode(\"utf-8\") + \"u\" * null_values\n    b85_chunks = map(\"\".join, zip(*[iter(binary_data)] * 5))\n    b85_segments = [[ord(_s) - 33 for _s in chunk] for chunk in b85_chunks]\n    results = [bin(_base85_to_10(chunk))[2::].zfill(32) for chunk in b85_segments]\n    char_chunks = [\n        [chr(int(_s, 2)) for _s in map(\"\".join, zip(*[iter(r)] * 8))] for r in results\n    ]\n    result = \"\".join(\"\".join(char) for char in char_chunks)\n    offset = int(null_values % 5 == 0)\n    return bytes(result[: offset - null_values], \"utf-8\")",
    "docstring": ">>> ascii85_decode(b\"\")\nb''\n>>> ascii85_decode(b\"0etOA2#\")\nb'12345'\n>>> ascii85_decode(b\"@UX=h+?24\")\nb'base 85'"
  },
  {
    "function": "generate_key",
    "code": "def generate_key(message: str, key: str) -> str:\n    \"\"\"\n    >>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n    'SECRETSECRETSECRE'\n    \"\"\"\n    x = len(message)\n    i = 0\n    while True:\n        if x == i:\n            i = 0\n        if len(key) == len(message):\n            break\n        key += key[i]\n        i += 1\n    return key",
    "docstring": ">>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n'SECRETSECRETSECRE'"
  },
  {
    "function": "cipher_text",
    "code": "def cipher_text(message: str, key_new: str) -> str:\n    \"\"\"\n    >>> cipher_text(\"THE GERMAN ATTACK\",\"SECRETSECRETSECRE\")\n    'BDC PAYUWL JPAIYI'\n    \"\"\"\n    cipher_text = \"\"\n    i = 0\n    for letter in message:\n        if letter == \" \":\n            cipher_text += \" \"\n        else:\n            x = (dict1[letter] - dict1[key_new[i]]) % 26\n            i += 1\n            cipher_text += dict2[x]\n    return cipher_text",
    "docstring": ">>> cipher_text(\"THE GERMAN ATTACK\",\"SECRETSECRETSECRE\")\n'BDC PAYUWL JPAIYI'"
  },
  {
    "function": "original_text",
    "code": "def original_text(cipher_text: str, key_new: str) -> str:\n    \"\"\"\n    >>> original_text(\"BDC PAYUWL JPAIYI\",\"SECRETSECRETSECRE\")\n    'THE GERMAN ATTACK'\n    \"\"\"\n    or_txt = \"\"\n    i = 0\n    for letter in cipher_text:\n        if letter == \" \":\n            or_txt += \" \"\n        else:\n            x = (dict1[letter] + dict1[key_new[i]] + 26) % 26\n            i += 1\n            or_txt += dict2[x]\n    return or_txt",
    "docstring": ">>> original_text(\"BDC PAYUWL JPAIYI\",\"SECRETSECRETSECRE\")\n'THE GERMAN ATTACK'"
  },
  {
    "function": "decrypt",
    "code": "def decrypt(message: str) -> None:\n    \"\"\"\n    >>> decrypt('TMDETUX PMDVU')\n    Decryption using Key #0: TMDETUX PMDVU\n    Decryption using Key #1: SLCDSTW OLCUT\n    Decryption using Key #2: RKBCRSV NKBTS\n    Decryption using Key #3: QJABQRU MJASR\n    Decryption using Key #4: PIZAPQT LIZRQ\n    Decryption using Key #5: OHYZOPS KHYQP\n    Decryption using Key #6: NGXYNOR JGXPO\n    Decryption using Key #7: MFWXMNQ IFWON\n    Decryption using Key #8: LEVWLMP HEVNM\n    Decryption using Key #9: KDUVKLO GDUML\n    Decryption using Key #10: JCTUJKN FCTLK\n    Decryption using Key #11: IBSTIJM EBSKJ\n    Decryption using Key #12: HARSHIL DARJI\n    Decryption using Key #13: GZQRGHK CZQIH\n    Decryption using Key #14: FYPQFGJ BYPHG\n    Decryption using Key #15: EXOPEFI AXOGF\n    Decryption using Key #16: DWNODEH ZWNFE\n    Decryption using Key #17: CVMNCDG YVMED\n    Decryption using Key #18: BULMBCF XULDC\n    Decryption using Key #19: ATKLABE WTKCB\n    Decryption using Key #20: ZSJKZAD VSJBA\n    Decryption using Key #21: YRIJYZC URIAZ\n    Decryption using Key #22: XQHIXYB TQHZY\n    Decryption using Key #23: WPGHWXA SPGYX\n    Decryption using Key #24: VOFGVWZ ROFXW\n    Decryption using Key #25: UNEFUVY QNEWV\n    \"\"\"\n    for key in range(len(string.ascii_uppercase)):\n        translated = \"\"\n        for symbol in message:\n            if symbol in string.ascii_uppercase:\n                num = string.ascii_uppercase.find(symbol)\n                num = num - key\n                if num < 0:\n                    num = num + len(string.ascii_uppercase)\n                translated = translated + string.ascii_uppercase[num]\n            else:\n                translated = translated + symbol\n        print(f\"Decryption using Key #{key}: {translated}\")",
    "docstring": ">>> decrypt('TMDETUX PMDVU')\nDecryption using Key #0: TMDETUX PMDVU\nDecryption using Key #1: SLCDSTW OLCUT\nDecryption using Key #2: RKBCRSV NKBTS\nDecryption using Key #3: QJABQRU MJASR\nDecryption using Key #4: PIZAPQT LIZRQ\nDecryption using Key #5: OHYZOPS KHYQP\nDecryption using Key #6: NGXYNOR JGXPO\nDecryption using Key #7: MFWXMNQ IFWON\nDecryption using Key #8: LEVWLMP HEVNM\nDecryption using Key #9: KDUVKLO GDUML\nDecryption using Key #10: JCTUJKN FCTLK\nDecryption using Key #11: IBSTIJM EBSKJ\nDecryption using Key #12: HARSHIL DARJI\nDecryption using Key #13: GZQRGHK CZQIH\nDecryption using Key #14: FYPQFGJ BYPHG\nDecryption using Key #15: EXOPEFI AXOGF\nDecryption using Key #16: DWNODEH ZWNFE\nDecryption using Key #17: CVMNCDG YVMED\nDecryption using Key #18: BULMBCF XULDC\nDecryption using Key #19: ATKLABE WTKCB\nDecryption using Key #20: ZSJKZAD VSJBA\nDecryption using Key #21: YRIJYZC URIAZ\nDecryption using Key #22: XQHIXYB TQHZY\nDecryption using Key #23: WPGHWXA SPGYX\nDecryption using Key #24: VOFGVWZ ROFXW\nDecryption using Key #25: UNEFUVY QNEWV"
  },
  {
    "function": "encrypt",
    "code": "def encrypt(input_string: str, key: int, alphabet: str | None = None) -> str:\n    \"\"\"\n    encrypt\n    =======\n\n    Encodes a given string with the caesar cipher and returns the encoded\n    message\n\n    Parameters:\n    -----------\n\n    *   `input_string`: the plain-text that needs to be encoded\n    *   `key`: the number of letters to shift the message by\n\n    Optional:\n\n    *   `alphabet` (``None``): the alphabet used to encode the cipher, if not\n        specified, the standard english alphabet with upper and lowercase\n        letters is used\n\n    Returns:\n\n    *   A string containing the encoded cipher-text\n\n    More on the caesar cipher\n    =========================\n\n    The caesar cipher is named after Julius Caesar who used it when sending\n    secret military messages to his troops. This is a simple substitution cipher\n    where every character in the plain-text is shifted by a certain number known\n    as the \"key\" or \"shift\".\n\n    Example:\n    Say we have the following message:\n    ``Hello, captain``\n\n    And our alphabet is made up of lower and uppercase letters:\n    ``abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``\n\n    And our shift is ``2``\n\n    We can then encode the message, one letter at a time. ``H`` would become ``J``,\n    since ``J`` is two letters away, and so on. If the shift is ever two large, or\n    our letter is at the end of the alphabet, we just start at the beginning\n    (``Z`` would shift to ``a`` then ``b`` and so on).\n\n    Our final message would be ``Jgnnq, ecrvckp``\n\n    Further reading\n    ===============\n\n    *   https://en.m.wikipedia.org/wiki/Caesar_cipher\n\n    Doctests\n    ========\n\n    >>> encrypt('The quick brown fox jumps over the lazy dog', 8)\n    'bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo'\n\n    >>> encrypt('A very large key', 8000)\n    's nWjq dSjYW cWq'\n\n    >>> encrypt('a lowercase alphabet', 5, 'abcdefghijklmnopqrstuvwxyz')\n    'f qtbjwhfxj fqumfgjy'\n    \"\"\"\n    # Set default alphabet to lower and upper case english chars\n    alpha = alphabet or ascii_letters\n\n    # The final result string\n    result = \"\"\n\n    for character in input_string:\n        if character not in alpha:\n            # Append without encryption if character is not in the alphabet\n            result += character\n        else:\n            # Get the index of the new key and make sure it isn't too large\n            new_key = (alpha.index(character) + key) % len(alpha)\n\n            # Append the encoded character to the alphabet\n            result += alpha[new_key]\n\n    return result",
    "docstring": "encrypt\n=======\n\nEncodes a given string with the caesar cipher and returns the encoded\nmessage\n\nParameters:\n-----------\n\n*   `input_string`: the plain-text that needs to be encoded\n*   `key`: the number of letters to shift the message by\n\nOptional:\n\n*   `alphabet` (``None``): the alphabet used to encode the cipher, if not\n    specified, the standard english alphabet with upper and lowercase\n    letters is used\n\nReturns:\n\n*   A string containing the encoded cipher-text\n\nMore on the caesar cipher\n=========================\n\nThe caesar cipher is named after Julius Caesar who used it when sending\nsecret military messages to his troops. This is a simple substitution cipher\nwhere every character in the plain-text is shifted by a certain number known\nas the \"key\" or \"shift\".\n\nExample:\nSay we have the following message:\n``Hello, captain``\n\nAnd our alphabet is made up of lower and uppercase letters:\n``abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``\n\nAnd our shift is ``2``\n\nWe can then encode the message, one letter at a time. ``H`` would become ``J``,\nsince ``J`` is two letters away, and so on. If the shift is ever two large, or\nour letter is at the end of the alphabet, we just start at the beginning\n(``Z`` would shift to ``a`` then ``b`` and so on).\n\nOur final message would be ``Jgnnq, ecrvckp``\n\nFurther reading\n===============\n\n*   https://en.m.wikipedia.org/wiki/Caesar_cipher\n\nDoctests\n========\n\n>>> encrypt('The quick brown fox jumps over the lazy dog', 8)\n'bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo'\n\n>>> encrypt('A very large key', 8000)\n's nWjq dSjYW cWq'\n\n>>> encrypt('a lowercase alphabet', 5, 'abcdefghijklmnopqrstuvwxyz')\n'f qtbjwhfxj fqumfgjy'"
  },
  {
    "function": "decrypt",
    "code": "def decrypt(input_string: str, key: int, alphabet: str | None = None) -> str:\n    \"\"\"\n    decrypt\n    =======\n\n    Decodes a given string of cipher-text and returns the decoded plain-text\n\n    Parameters:\n    -----------\n\n    *   `input_string`: the cipher-text that needs to be decoded\n    *   `key`: the number of letters to shift the message backwards by to decode\n\n    Optional:\n\n    *   `alphabet` (``None``): the alphabet used to decode the cipher, if not\n        specified, the standard english alphabet with upper and lowercase\n        letters is used\n\n    Returns:\n\n    *   A string containing the decoded plain-text\n\n    More on the caesar cipher\n    =========================\n\n    The caesar cipher is named after Julius Caesar who used it when sending\n    secret military messages to his troops. This is a simple substitution cipher\n    where very character in the plain-text is shifted by a certain number known\n    as the \"key\" or \"shift\". Please keep in mind, here we will be focused on\n    decryption.\n\n    Example:\n    Say we have the following cipher-text:\n    ``Jgnnq, ecrvckp``\n\n    And our alphabet is made up of lower and uppercase letters:\n    ``abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``\n\n    And our shift is ``2``\n\n    To decode the message, we would do the same thing as encoding, but in\n    reverse. The first letter, ``J`` would become ``H`` (remember: we are decoding)\n    because ``H`` is two letters in reverse (to the left) of ``J``. We would\n    continue doing this. A letter like ``a`` would shift back to the end of\n    the alphabet, and would become ``Z`` or ``Y`` and so on.\n\n    Our final message would be ``Hello, captain``\n\n    Further reading\n    ===============\n\n    *   https://en.m.wikipedia.org/wiki/Caesar_cipher\n\n    Doctests\n    ========\n\n    >>> decrypt('bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo', 8)\n    'The quick brown fox jumps over the lazy dog'\n\n    >>> decrypt('s nWjq dSjYW cWq', 8000)\n    'A very large key'\n\n    >>> decrypt('f qtbjwhfxj fqumfgjy', 5, 'abcdefghijklmnopqrstuvwxyz')\n    'a lowercase alphabet'\n    \"\"\"\n    # Turn on decode mode by making the key negative\n    key *= -1\n\n    return encrypt(input_string, key, alphabet)",
    "docstring": "decrypt\n=======\n\nDecodes a given string of cipher-text and returns the decoded plain-text\n\nParameters:\n-----------\n\n*   `input_string`: the cipher-text that needs to be decoded\n*   `key`: the number of letters to shift the message backwards by to decode\n\nOptional:\n\n*   `alphabet` (``None``): the alphabet used to decode the cipher, if not\n    specified, the standard english alphabet with upper and lowercase\n    letters is used\n\nReturns:\n\n*   A string containing the decoded plain-text\n\nMore on the caesar cipher\n=========================\n\nThe caesar cipher is named after Julius Caesar who used it when sending\nsecret military messages to his troops. This is a simple substitution cipher\nwhere very character in the plain-text is shifted by a certain number known\nas the \"key\" or \"shift\". Please keep in mind, here we will be focused on\ndecryption.\n\nExample:\nSay we have the following cipher-text:\n``Jgnnq, ecrvckp``\n\nAnd our alphabet is made up of lower and uppercase letters:\n``abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``\n\nAnd our shift is ``2``\n\nTo decode the message, we would do the same thing as encoding, but in\nreverse. The first letter, ``J`` would become ``H`` (remember: we are decoding)\nbecause ``H`` is two letters in reverse (to the left) of ``J``. We would\ncontinue doing this. A letter like ``a`` would shift back to the end of\nthe alphabet, and would become ``Z`` or ``Y`` and so on.\n\nOur final message would be ``Hello, captain``\n\nFurther reading\n===============\n\n*   https://en.m.wikipedia.org/wiki/Caesar_cipher\n\nDoctests\n========\n\n>>> decrypt('bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo', 8)\n'The quick brown fox jumps over the lazy dog'\n\n>>> decrypt('s nWjq dSjYW cWq', 8000)\n'A very large key'\n\n>>> decrypt('f qtbjwhfxj fqumfgjy', 5, 'abcdefghijklmnopqrstuvwxyz')\n'a lowercase alphabet'"
  },
  {
    "function": "brute_force",
    "code": "def brute_force(input_string: str, alphabet: str | None = None) -> dict[int, str]:\n    \"\"\"\n    brute_force\n    ===========\n\n    Returns all the possible combinations of keys and the decoded strings in the\n    form of a dictionary\n\n    Parameters:\n    -----------\n\n    *   `input_string`: the cipher-text that needs to be used during brute-force\n\n    Optional:\n\n    *   `alphabet` (``None``): the alphabet used to decode the cipher, if not\n        specified, the standard english alphabet with upper and lowercase\n        letters is used\n\n    More about brute force\n    ======================\n\n    Brute force is when a person intercepts a message or password, not knowing\n    the key and tries every single combination. This is easy with the caesar\n    cipher since there are only all the letters in the alphabet. The more\n    complex the cipher, the larger amount of time it will take to do brute force\n\n    Ex:\n    Say we have a ``5`` letter alphabet (``abcde``), for simplicity and we intercepted\n    the following message: ``dbc``,\n    we could then just write out every combination:\n    ``ecd``... and so on, until we reach a combination that makes sense:\n    ``cab``\n\n    Further reading\n    ===============\n\n    *   https://en.wikipedia.org/wiki/Brute_force\n\n    Doctests\n    ========\n\n    >>> brute_force(\"jFyuMy xIH'N vLONy zILwy Gy!\")[20]\n    \"Please don't brute force me!\"\n\n    >>> brute_force(1)\n    Traceback (most recent call last):\n    TypeError: 'int' object is not iterable\n    \"\"\"\n    # Set default alphabet to lower and upper case english chars\n    alpha = alphabet or ascii_letters\n\n    # To store data on all the combinations\n    brute_force_data = {}\n\n    # Cycle through each combination\n    for key in range(1, len(alpha) + 1):\n        # Decrypt the message and store the result in the data\n        brute_force_data[key] = decrypt(input_string, key, alpha)\n\n    return brute_force_data",
    "docstring": "brute_force\n===========\n\nReturns all the possible combinations of keys and the decoded strings in the\nform of a dictionary\n\nParameters:\n-----------\n\n*   `input_string`: the cipher-text that needs to be used during brute-force\n\nOptional:\n\n*   `alphabet` (``None``): the alphabet used to decode the cipher, if not\n    specified, the standard english alphabet with upper and lowercase\n    letters is used\n\nMore about brute force\n======================\n\nBrute force is when a person intercepts a message or password, not knowing\nthe key and tries every single combination. This is easy with the caesar\ncipher since there are only all the letters in the alphabet. The more\ncomplex the cipher, the larger amount of time it will take to do brute force\n\nEx:\nSay we have a ``5`` letter alphabet (``abcde``), for simplicity and we intercepted\nthe following message: ``dbc``,\nwe could then just write out every combination:\n``ecd``... and so on, until we reach a combination that makes sense:\n``cab``\n\nFurther reading\n===============\n\n*   https://en.wikipedia.org/wiki/Brute_force\n\nDoctests\n========\n\n>>> brute_force(\"jFyuMy xIH'N vLONy zILwy Gy!\")[20]\n\"Please don't brute force me!\"\n\n>>> brute_force(1)\nTraceback (most recent call last):\nTypeError: 'int' object is not iterable"
  },
  {
    "function": "decrypt_caesar_with_chi_squared",
    "code": "def decrypt_caesar_with_chi_squared(\n    ciphertext: str,\n    cipher_alphabet: list[str] | None = None,\n    frequencies_dict: dict[str, float] | None = None,\n    case_sensitive: bool = False,\n) -> tuple[int, float, str]:\n    \"\"\"\n    Basic Usage\n    ===========\n\n    Arguments:\n      * `ciphertext` (str): the text to decode (encoded with the caesar cipher)\n\n    Optional Arguments:\n      * `cipher_alphabet` (list): the alphabet used for the cipher (each letter is\n        a string separated by commas)\n      * `frequencies_dict` (dict): a dictionary of word frequencies where keys are\n        the letters and values are a percentage representation of the frequency as\n        a decimal/float\n      * `case_sensitive` (bool): a boolean value: ``True`` if the case matters during\n        decryption, ``False`` if it doesn't\n\n    Returns:\n      * A tuple in the form of:\n        (`most_likely_cipher`, `most_likely_cipher_chi_squared_value`,\n        `decoded_most_likely_cipher`)\n\n        where...\n          - `most_likely_cipher` is an integer representing the shift of the smallest\n            chi-squared statistic (most likely key)\n          - `most_likely_cipher_chi_squared_value` is a float representing the\n            chi-squared statistic of the most likely shift\n          - `decoded_most_likely_cipher` is a string with the decoded cipher\n            (decoded by the most_likely_cipher key)\n\n\n    The Chi-squared test\n    ====================\n\n    The caesar cipher\n    -----------------\n\n    The caesar cipher is a very insecure encryption algorithm, however it has\n    been used since Julius Caesar. The cipher is a simple substitution cipher\n    where each character in the plain text is replaced by a character in the\n    alphabet a certain number of characters after the original character. The\n    number of characters away is called the shift or key. For example:\n\n    | Plain text: ``hello``\n    | Key: ``1``\n    | Cipher text: ``ifmmp``\n    | (each letter in ``hello`` has been shifted one to the right in the eng. alphabet)\n\n    As you can imagine, this doesn't provide lots of security. In fact\n    decrypting ciphertext by brute-force is extremely easy even by hand. However\n    one way to do that is the chi-squared test.\n\n    The chi-squared test\n    --------------------\n\n    Each letter in the english alphabet has a frequency, or the amount of times\n    it shows up compared to other letters (usually expressed as a decimal\n    representing the percentage likelihood). The most common letter in the\n    english language is ``e`` with a frequency of ``0.11162`` or ``11.162%``.\n    The test is completed in the following fashion.\n\n    1. The ciphertext is decoded in a brute force way (every combination of the\n       ``26`` possible combinations)\n    2. For every combination, for each letter in the combination, the average\n       amount of times the letter should appear the message is calculated by\n       multiplying the total number of characters by the frequency of the letter.\n\n       | For example:\n       | In a message of ``100`` characters, ``e`` should appear around ``11.162``\n         times.\n\n    3. Then, to calculate the margin of error (the amount of times the letter\n       SHOULD appear with the amount of times the letter DOES appear), we use\n       the chi-squared test. The following formula is used:\n\n       Let:\n         - n be the number of times the letter actually appears\n         - p be the predicted value of the number of times the letter should\n           appear (see item ``2``)\n         - let v be the chi-squared test result (referred to here as chi-squared\n           value/statistic)\n\n         ::\n\n           (n - p)^2\n           --------- = v\n              p\n\n    4. Each chi squared value for each letter is then added up to the total.\n       The total is the chi-squared statistic for that encryption key.\n    5. The encryption key with the lowest chi-squared value is the most likely\n       to be the decoded answer.\n\n    Further Reading\n    ===============\n\n    * http://practicalcryptography.com/cryptanalysis/text-characterisation/chi-squared-statistic/\n    * https://en.wikipedia.org/wiki/Letter_frequency\n    * https://en.wikipedia.org/wiki/Chi-squared_test\n    * https://en.m.wikipedia.org/wiki/Caesar_cipher\n\n    Doctests\n    ========\n\n    >>> decrypt_caesar_with_chi_squared(\n    ...    'dof pz aol jhlzhy jpwoly zv wvwbshy? pa pz avv lhzf av jyhjr!'\n    ... )  # doctest: +NORMALIZE_WHITESPACE\n    (7, 3129.228005747531,\n     'why is the caesar cipher so popular? it is too easy to crack!')\n\n    >>> decrypt_caesar_with_chi_squared('crybd cdbsxq')\n    (10, 233.35343938980898, 'short string')\n\n    >>> decrypt_caesar_with_chi_squared('Crybd Cdbsxq', case_sensitive=True)\n    (10, 233.35343938980898, 'Short String')\n\n    >>> decrypt_caesar_with_chi_squared(12)\n    Traceback (most recent call last):\n    AttributeError: 'int' object has no attribute 'lower'\n    \"\"\"\n    alphabet_letters = cipher_alphabet or [chr(i) for i in range(97, 123)]\n\n    # If the argument is None or the user provided an empty dictionary\n    if not frequencies_dict:\n        # Frequencies of letters in the english language (how much they show up)\n        frequencies = {\n            \"a\": 0.08497,\n            \"b\": 0.01492,\n            \"c\": 0.02202,\n            \"d\": 0.04253,\n            \"e\": 0.11162,\n            \"f\": 0.02228,\n            \"g\": 0.02015,\n            \"h\": 0.06094,\n            \"i\": 0.07546,\n            \"j\": 0.00153,\n            \"k\": 0.01292,\n            \"l\": 0.04025,\n            \"m\": 0.02406,\n            \"n\": 0.06749,\n            \"o\": 0.07507,\n            \"p\": 0.01929,\n            \"q\": 0.00095,\n            \"r\": 0.07587,\n            \"s\": 0.06327,\n            \"t\": 0.09356,\n            \"u\": 0.02758,\n            \"v\": 0.00978,\n            \"w\": 0.02560,\n            \"x\": 0.00150,\n            \"y\": 0.01994,\n            \"z\": 0.00077,\n        }\n    else:\n        # Custom frequencies dictionary\n        frequencies = frequencies_dict\n\n    if not case_sensitive:\n        ciphertext = ciphertext.lower()\n\n    # Chi squared statistic values\n    chi_squared_statistic_values: dict[int, tuple[float, str]] = {}\n\n    # cycle through all of the shifts\n    for shift in range(len(alphabet_letters)):\n        decrypted_with_shift = \"\"\n\n        # decrypt the message with the shift\n        for letter in ciphertext:\n            try:\n                # Try to index the letter in the alphabet\n                new_key = (alphabet_letters.index(letter.lower()) - shift) % len(\n                    alphabet_letters\n                )\n                decrypted_with_shift += (\n                    alphabet_letters[new_key].upper()\n                    if case_sensitive and letter.isupper()\n                    else alphabet_letters[new_key]\n                )\n            except ValueError:\n                # Append the character if it isn't in the alphabet\n                decrypted_with_shift += letter\n\n        chi_squared_statistic = 0.0\n\n        # Loop through each letter in the decoded message with the shift\n        for letter in decrypted_with_shift:\n            if case_sensitive:\n                letter = letter.lower()\n                if letter in frequencies:\n                    # Get the amount of times the letter occurs in the message\n                    occurrences = decrypted_with_shift.lower().count(letter)\n\n                    # Get the excepcted amount of times the letter should appear based\n                    # on letter frequencies\n                    expected = frequencies[letter] * occurrences\n\n                    # Complete the chi squared statistic formula\n                    chi_letter_value = ((occurrences - expected) ** 2) / expected\n\n                    # Add the margin of error to the total chi squared statistic\n                    chi_squared_statistic += chi_letter_value\n            elif letter.lower() in frequencies:\n                # Get the amount of times the letter occurs in the message\n                occurrences = decrypted_with_shift.count(letter)\n\n                # Get the excepcted amount of times the letter should appear based\n                # on letter frequencies\n                expected = frequencies[letter] * occurrences\n\n                # Complete the chi squared statistic formula\n                chi_letter_value = ((occurrences - expected) ** 2) / expected\n\n                # Add the margin of error to the total chi squared statistic\n                chi_squared_statistic += chi_letter_value\n\n        # Add the data to the chi_squared_statistic_values dictionary\n        chi_squared_statistic_values[shift] = (\n            chi_squared_statistic,\n            decrypted_with_shift,\n        )\n\n    # Get the most likely cipher by finding the cipher with the smallest chi squared\n    # statistic\n    def chi_squared_statistic_values_sorting_key(key: int) -> tuple[float, str]:\n        return chi_squared_statistic_values[key]\n\n    most_likely_cipher: int = min(\n        chi_squared_statistic_values,\n        key=chi_squared_statistic_values_sorting_key,\n    )\n\n    # Get all the data from the most likely cipher (key, decoded message)\n    (\n        most_likely_cipher_chi_squared_value,\n        decoded_most_likely_cipher,\n    ) = chi_squared_statistic_values[most_likely_cipher]\n\n    # Return the data on the most likely shift\n    return (\n        most_likely_cipher,\n        most_likely_cipher_chi_squared_value,\n        decoded_most_likely_cipher,\n    )",
    "docstring": "Basic Usage\n===========\n\nArguments:\n  * `ciphertext` (str): the text to decode (encoded with the caesar cipher)\n\nOptional Arguments:\n  * `cipher_alphabet` (list): the alphabet used for the cipher (each letter is\n    a string separated by commas)\n  * `frequencies_dict` (dict): a dictionary of word frequencies where keys are\n    the letters and values are a percentage representation of the frequency as\n    a decimal/float\n  * `case_sensitive` (bool): a boolean value: ``True`` if the case matters during\n    decryption, ``False`` if it doesn't\n\nReturns:\n  * A tuple in the form of:\n    (`most_likely_cipher`, `most_likely_cipher_chi_squared_value`,\n    `decoded_most_likely_cipher`)\n\n    where...\n      - `most_likely_cipher` is an integer representing the shift of the smallest\n        chi-squared statistic (most likely key)\n      - `most_likely_cipher_chi_squared_value` is a float representing the\n        chi-squared statistic of the most likely shift\n      - `decoded_most_likely_cipher` is a string with the decoded cipher\n        (decoded by the most_likely_cipher key)\n\n\nThe Chi-squared test\n====================\n\nThe caesar cipher\n-----------------\n\nThe caesar cipher is a very insecure encryption algorithm, however it has\nbeen used since Julius Caesar. The cipher is a simple substitution cipher\nwhere each character in the plain text is replaced by a character in the\nalphabet a certain number of characters after the original character. The\nnumber of characters away is called the shift or key. For example:\n\n| Plain text: ``hello``\n| Key: ``1``\n| Cipher text: ``ifmmp``\n| (each letter in ``hello`` has been shifted one to the right in the eng. alphabet)\n\nAs you can imagine, this doesn't provide lots of security. In fact\ndecrypting ciphertext by brute-force is extremely easy even by hand. However\none way to do that is the chi-squared test.\n\nThe chi-squared test\n--------------------\n\nEach letter in the english alphabet has a frequency, or the amount of times\nit shows up compared to other letters (usually expressed as a decimal\nrepresenting the percentage likelihood). The most common letter in the\nenglish language is ``e`` with a frequency of ``0.11162`` or ``11.162%``.\nThe test is completed in the following fashion.\n\n1. The ciphertext is decoded in a brute force way (every combination of the\n   ``26`` possible combinations)\n2. For every combination, for each letter in the combination, the average\n   amount of times the letter should appear the message is calculated by\n   multiplying the total number of characters by the frequency of the letter.\n\n   | For example:\n   | In a message of ``100`` characters, ``e`` should appear around ``11.162``\n     times.\n\n3. Then, to calculate the margin of error (the amount of times the letter\n   SHOULD appear with the amount of times the letter DOES appear), we use\n   the chi-squared test. The following formula is used:\n\n   Let:\n     - n be the number of times the letter actually appears\n     - p be the predicted value of the number of times the letter should\n       appear (see item ``2``)\n     - let v be the chi-squared test result (referred to here as chi-squared\n       value/statistic)\n\n     ::\n\n       (n - p)^2\n       --------- = v\n          p\n\n4. Each chi squared value for each letter is then added up to the total.\n   The total is the chi-squared statistic for that encryption key.\n5. The encryption key with the lowest chi-squared value is the most likely\n   to be the decoded answer.\n\nFurther Reading\n===============\n\n* http://practicalcryptography.com/cryptanalysis/text-characterisation/chi-squared-statistic/\n* https://en.wikipedia.org/wiki/Letter_frequency\n* https://en.wikipedia.org/wiki/Chi-squared_test\n* https://en.m.wikipedia.org/wiki/Caesar_cipher\n\nDoctests\n========\n\n>>> decrypt_caesar_with_chi_squared(\n...    'dof pz aol jhlzhy jpwoly zv wvwbshy? pa pz avv lhzf av jyhjr!'\n... )  # doctest: +NORMALIZE_WHITESPACE\n(7, 3129.228005747531,\n 'why is the caesar cipher so popular? it is too easy to crack!')\n\n>>> decrypt_caesar_with_chi_squared('crybd cdbsxq')\n(10, 233.35343938980898, 'short string')\n\n>>> decrypt_caesar_with_chi_squared('Crybd Cdbsxq', case_sensitive=True)\n(10, 233.35343938980898, 'Short String')\n\n>>> decrypt_caesar_with_chi_squared(12)\nTraceback (most recent call last):\nAttributeError: 'int' object has no attribute 'lower'"
  },
  {
    "function": "miller_rabin",
    "code": "def miller_rabin(n: int, allow_probable: bool = False) -> bool:\n    \"\"\"Deterministic Miller-Rabin algorithm for primes ~< 3.32e24.\n\n    Uses numerical analysis results to return whether or not the passed number\n    is prime. If the passed number is above the upper limit, and\n    allow_probable is True, then a return value of True indicates that n is\n    probably prime. This test does not allow False negatives- a return value\n    of False is ALWAYS composite.\n\n    Parameters\n    ----------\n    n : int\n        The integer to be tested. Since we usually care if a number is prime,\n        n < 2 returns False instead of raising a ValueError.\n    allow_probable: bool, default False\n        Whether or not to test n above the upper bound of the deterministic test.\n\n    Raises\n    ------\n    ValueError\n\n    Reference\n    ---------\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\n    \"\"\"\n    if n == 2:\n        return True\n    if not n % 2 or n < 2:\n        return False\n    if n > 5 and n % 10 not in (1, 3, 7, 9):  # can quickly check last digit\n        return False\n    if n > 3_317_044_064_679_887_385_961_981 and not allow_probable:\n        raise ValueError(\n            \"Warning: upper bound of deterministic test is exceeded. \"\n            \"Pass allow_probable=True to allow probabilistic test. \"\n            \"A return value of True indicates a probable prime.\"\n        )\n    # array bounds provided by analysis\n    bounds = [\n        2_047,\n        1_373_653,\n        25_326_001,\n        3_215_031_751,\n        2_152_302_898_747,\n        3_474_749_660_383,\n        341_550_071_728_321,\n        1,\n        3_825_123_056_546_413_051,\n        1,\n        1,\n        318_665_857_834_031_151_167_461,\n        3_317_044_064_679_887_385_961_981,\n    ]\n\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n    for idx, _p in enumerate(bounds, 1):\n        if n < _p:\n            # then we have our last prime to check\n            plist = primes[:idx]\n            break\n    d, s = n - 1, 0\n    # break up n -1 into a power of 2 (s) and\n    # remaining odd component\n    # essentially, solve for d * 2 ** s == n - 1\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n    for prime in plist:\n        pr = False\n        for r in range(s):\n            m = pow(prime, d * 2**r, n)\n            # see article for analysis explanation for m\n            if (r == 0 and m == 1) or ((m + 1) % n == 0):\n                pr = True\n                # this loop will not determine compositeness\n                break\n        if pr:\n            continue\n        # if pr is False, then the above loop never evaluated to true,\n        # and the n MUST be composite\n        return False\n    return True",
    "docstring": "Deterministic Miller-Rabin algorithm for primes ~< 3.32e24.\n\nUses numerical analysis results to return whether or not the passed number\nis prime. If the passed number is above the upper limit, and\nallow_probable is True, then a return value of True indicates that n is\nprobably prime. This test does not allow False negatives- a return value\nof False is ALWAYS composite.\n\nParameters\n----------\nn : int\n    The integer to be tested. Since we usually care if a number is prime,\n    n < 2 returns False instead of raising a ValueError.\nallow_probable: bool, default False\n    Whether or not to test n above the upper bound of the deterministic test.\n\nRaises\n------\nValueError\n\nReference\n---------\nhttps://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test"
  },
  {
    "function": "test_miller_rabin",
    "code": "def test_miller_rabin() -> None:\n    \"\"\"Testing a nontrivial (ends in 1, 3, 7, 9) composite\n    and a prime in each range.\n    \"\"\"\n    assert not miller_rabin(561)\n    assert miller_rabin(563)\n    # 2047\n\n    assert not miller_rabin(838_201)\n    assert miller_rabin(838_207)\n    # 1_373_653\n\n    assert not miller_rabin(17_316_001)\n    assert miller_rabin(17_316_017)\n    # 25_326_001\n\n    assert not miller_rabin(3_078_386_641)\n    assert miller_rabin(3_078_386_653)\n    # 3_215_031_751\n\n    assert not miller_rabin(1_713_045_574_801)\n    assert miller_rabin(1_713_045_574_819)\n    # 2_152_302_898_747\n\n    assert not miller_rabin(2_779_799_728_307)\n    assert miller_rabin(2_779_799_728_327)\n    # 3_474_749_660_383\n\n    assert not miller_rabin(113_850_023_909_441)\n    assert miller_rabin(113_850_023_909_527)\n    # 341_550_071_728_321\n\n    assert not miller_rabin(1_275_041_018_848_804_351)\n    assert miller_rabin(1_275_041_018_848_804_391)\n    # 3_825_123_056_546_413_051\n\n    assert not miller_rabin(79_666_464_458_507_787_791_867)\n    assert miller_rabin(79_666_464_458_507_787_791_951)\n    # 318_665_857_834_031_151_167_461\n\n    assert not miller_rabin(552_840_677_446_647_897_660_333)\n    assert miller_rabin(552_840_677_446_647_897_660_359)",
    "docstring": "Testing a nontrivial (ends in 1, 3, 7, 9) composite\nand a prime in each range."
  },
  {
    "function": "find_primitive",
    "code": "def find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None",
    "docstring": "Find a primitive root modulo modulus, if one exists.\n\nArgs:\n    modulus : The modulus for which to find a primitive root.\n\nReturns:\n    The primitive root if one exists, or None if there is none.\n\nExamples:\n>>> find_primitive(7)  # Modulo 7 has primitive root 3\n3\n>>> find_primitive(11)  # Modulo 11 has primitive root 2\n2\n>>> find_primitive(8) == None # Modulo 8 has no primitive root\nTrue"
  },
  {
    "function": "_validator",
    "code": "def _validator(\n    rotpos: RotorPositionT, rotsel: RotorSelectionT, pb: str\n) -> tuple[RotorPositionT, RotorSelectionT, dict[str, str]]:\n    \"\"\"\n    Checks if the values can be used for the ``enigma`` function\n\n    >>> _validator((1,1,1), (rotor1, rotor2, rotor3), 'POLAND')\n    ((1, 1, 1), ('EGZWVONAHDCLFQMSIPJBYUKXTR', 'FOBHMDKEXQNRAULPGSJVTYICZW', \\\n'ZJXESIUQLHAVRMDOYGTNFWPBKC'), \\\n{'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'})\n\n    :param rotpos: rotor_positon\n    :param rotsel: rotor_selection\n    :param pb: plugb -> validated and transformed\n    :return: (`rotpos`, `rotsel`, `pb`)\n    \"\"\"\n    # Checks if there are 3 unique rotors\n\n    if (unique_rotsel := len(set(rotsel))) < 3:\n        msg = f\"Please use 3 unique rotors (not {unique_rotsel})\"\n        raise Exception(msg)\n\n    # Checks if rotor positions are valid\n    rotorpos1, rotorpos2, rotorpos3 = rotpos\n    if not 0 < rotorpos1 <= len(abc):\n        msg = f\"First rotor position is not within range of 1..26 ({rotorpos1}\"\n        raise ValueError(msg)\n    if not 0 < rotorpos2 <= len(abc):\n        msg = f\"Second rotor position is not within range of 1..26 ({rotorpos2})\"\n        raise ValueError(msg)\n    if not 0 < rotorpos3 <= len(abc):\n        msg = f\"Third rotor position is not within range of 1..26 ({rotorpos3})\"\n        raise ValueError(msg)\n\n    # Validates string and returns dict\n    pbdict = _plugboard(pb)\n\n    return rotpos, rotsel, pbdict",
    "docstring": "Checks if the values can be used for the ``enigma`` function\n\n>>> _validator((1,1,1), (rotor1, rotor2, rotor3), 'POLAND')\n((1, 1, 1), ('EGZWVONAHDCLFQMSIPJBYUKXTR', 'FOBHMDKEXQNRAULPGSJVTYICZW', 'ZJXESIUQLHAVRMDOYGTNFWPBKC'), {'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'})\n\n:param rotpos: rotor_positon\n:param rotsel: rotor_selection\n:param pb: plugb -> validated and transformed\n:return: (`rotpos`, `rotsel`, `pb`)"
  },
  {
    "function": "_plugboard",
    "code": "def _plugboard(pbstring: str) -> dict[str, str]:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Enigma_machine#Plugboard\n\n    >>> _plugboard('PICTURES')\n    {'P': 'I', 'I': 'P', 'C': 'T', 'T': 'C', 'U': 'R', 'R': 'U', 'E': 'S', 'S': 'E'}\n    >>> _plugboard('POLAND')\n    {'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'}\n\n    In the code, ``pb`` stands for ``plugboard``\n\n    Pairs can be separated by spaces\n\n    :param pbstring: string containing plugboard setting for the Enigma machine\n    :return: dictionary containing converted pairs\n    \"\"\"\n\n    # tests the input string if it\n    # a) is type string\n    # b) has even length (so pairs can be made)\n    if not isinstance(pbstring, str):\n        msg = f\"Plugboard setting isn't type string ({type(pbstring)})\"\n        raise TypeError(msg)\n    elif len(pbstring) % 2 != 0:\n        msg = f\"Odd number of symbols ({len(pbstring)})\"\n        raise Exception(msg)\n    elif pbstring == \"\":\n        return {}\n\n    pbstring.replace(\" \", \"\")\n\n    # Checks if all characters are unique\n    tmppbl = set()\n    for i in pbstring:\n        if i not in abc:\n            msg = f\"'{i}' not in list of symbols\"\n            raise Exception(msg)\n        elif i in tmppbl:\n            msg = f\"Duplicate symbol ({i})\"\n            raise Exception(msg)\n        else:\n            tmppbl.add(i)\n    del tmppbl\n\n    # Created the dictionary\n    pb = {}\n    for j in range(0, len(pbstring) - 1, 2):\n        pb[pbstring[j]] = pbstring[j + 1]\n        pb[pbstring[j + 1]] = pbstring[j]\n\n    return pb",
    "docstring": "https://en.wikipedia.org/wiki/Enigma_machine#Plugboard\n\n>>> _plugboard('PICTURES')\n{'P': 'I', 'I': 'P', 'C': 'T', 'T': 'C', 'U': 'R', 'R': 'U', 'E': 'S', 'S': 'E'}\n>>> _plugboard('POLAND')\n{'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'}\n\nIn the code, ``pb`` stands for ``plugboard``\n\nPairs can be separated by spaces\n\n:param pbstring: string containing plugboard setting for the Enigma machine\n:return: dictionary containing converted pairs"
  },
  {
    "function": "enigma",
    "code": "def enigma(\n    text: str,\n    rotor_position: RotorPositionT,\n    rotor_selection: RotorSelectionT = (rotor1, rotor2, rotor3),\n    plugb: str = \"\",\n) -> str:\n    \"\"\"\n    The only difference with real-world enigma is that ``I`` allowed string input.\n    All characters are converted to uppercase. (non-letter symbol are ignored)\n\n    | How it works:\n    | (for every letter in the message)\n\n    - Input letter goes into the plugboard.\n      If it is connected to another one, switch it.\n\n    - Letter goes through ``3`` rotors.\n      Each rotor can be represented as ``2`` sets of symbol, where one is shuffled.\n      Each symbol from the first set has corresponding symbol in\n      the second set and vice versa.\n\n      example::\n\n      | ABCDEFGHIJKLMNOPQRSTUVWXYZ | e.g. F=D and D=F\n      | VKLEPDBGRNWTFCJOHQAMUZYIXS |\n\n    - Symbol then goes through reflector (static rotor).\n      There it is switched with paired symbol.\n      The reflector can be represented as ``2`` sets, each with half of the alphanet.\n      There are usually ``10`` pairs of letters.\n\n      Example::\n\n      | ABCDEFGHIJKLM | e.g. E is paired to X\n      | ZYXWVUTSRQPON | so when E goes in X goes out and vice versa\n\n    - Letter then goes through the rotors again\n\n    - If the letter is connected to plugboard, it is switched.\n\n    - Return the letter\n\n    >>> enigma('Hello World!', (1, 2, 1), plugb='pictures')\n    'KORYH JUHHI!'\n    >>> enigma('KORYH, juhhi!', (1, 2, 1), plugb='pictures')\n    'HELLO, WORLD!'\n    >>> enigma('hello world!', (1, 1, 1), plugb='pictures')\n    'FPNCZ QWOBU!'\n    >>> enigma('FPNCZ QWOBU', (1, 1, 1), plugb='pictures')\n    'HELLO WORLD'\n\n\n    :param text: input message\n    :param rotor_position: tuple with ``3`` values in range ``1``.. ``26``\n    :param rotor_selection: tuple with ``3`` rotors\n    :param plugb: string containing plugboard configuration (default ``''``)\n    :return: en/decrypted string\n    \"\"\"\n\n    text = text.upper()\n    rotor_position, rotor_selection, plugboard = _validator(\n        rotor_position, rotor_selection, plugb.upper()\n    )\n\n    rotorpos1, rotorpos2, rotorpos3 = rotor_position\n    rotor1, rotor2, rotor3 = rotor_selection\n    rotorpos1 -= 1\n    rotorpos2 -= 1\n    rotorpos3 -= 1\n\n    result = []\n\n    # encryption/decryption process --------------------------\n    for symbol in text:\n        if symbol in abc:\n            # 1st plugboard --------------------------\n            if symbol in plugboard:\n                symbol = plugboard[symbol]\n\n            # rotor ra --------------------------\n            index = abc.index(symbol) + rotorpos1\n            symbol = rotor1[index % len(abc)]\n\n            # rotor rb --------------------------\n            index = abc.index(symbol) + rotorpos2\n            symbol = rotor2[index % len(abc)]\n\n            # rotor rc --------------------------\n            index = abc.index(symbol) + rotorpos3\n            symbol = rotor3[index % len(abc)]\n\n            # reflector --------------------------\n            # this is the reason you don't need another machine to decipher\n\n            symbol = reflector[symbol]\n\n            # 2nd rotors\n            symbol = abc[rotor3.index(symbol) - rotorpos3]\n            symbol = abc[rotor2.index(symbol) - rotorpos2]\n            symbol = abc[rotor1.index(symbol) - rotorpos1]\n\n            # 2nd plugboard\n            if symbol in plugboard:\n                symbol = plugboard[symbol]\n\n            # moves/resets rotor positions\n            rotorpos1 += 1\n            if rotorpos1 >= len(abc):\n                rotorpos1 = 0\n                rotorpos2 += 1\n            if rotorpos2 >= len(abc):\n                rotorpos2 = 0\n                rotorpos3 += 1\n            if rotorpos3 >= len(abc):\n                rotorpos3 = 0\n\n        # else:\n        #    pass\n        #    Error could be also raised\n        #    raise ValueError(\n        #       'Invalid symbol('+repr(symbol)+')')\n        result.append(symbol)\n\n    return \"\".join(result)",
    "docstring": "The only difference with real-world enigma is that ``I`` allowed string input.\nAll characters are converted to uppercase. (non-letter symbol are ignored)\n\n| How it works:\n| (for every letter in the message)\n\n- Input letter goes into the plugboard.\n  If it is connected to another one, switch it.\n\n- Letter goes through ``3`` rotors.\n  Each rotor can be represented as ``2`` sets of symbol, where one is shuffled.\n  Each symbol from the first set has corresponding symbol in\n  the second set and vice versa.\n\n  example::\n\n  | ABCDEFGHIJKLMNOPQRSTUVWXYZ | e.g. F=D and D=F\n  | VKLEPDBGRNWTFCJOHQAMUZYIXS |\n\n- Symbol then goes through reflector (static rotor).\n  There it is switched with paired symbol.\n  The reflector can be represented as ``2`` sets, each with half of the alphanet.\n  There are usually ``10`` pairs of letters.\n\n  Example::\n\n  | ABCDEFGHIJKLM | e.g. E is paired to X\n  | ZYXWVUTSRQPON | so when E goes in X goes out and vice versa\n\n- Letter then goes through the rotors again\n\n- If the letter is connected to plugboard, it is switched.\n\n- Return the letter\n\n>>> enigma('Hello World!', (1, 2, 1), plugb='pictures')\n'KORYH JUHHI!'\n>>> enigma('KORYH, juhhi!', (1, 2, 1), plugb='pictures')\n'HELLO, WORLD!'\n>>> enigma('hello world!', (1, 1, 1), plugb='pictures')\n'FPNCZ QWOBU!'\n>>> enigma('FPNCZ QWOBU', (1, 1, 1), plugb='pictures')\n'HELLO WORLD'\n\n\n:param text: input message\n:param rotor_position: tuple with ``3`` values in range ``1``.. ``26``\n:param rotor_selection: tuple with ``3`` rotors\n:param plugb: string containing plugboard configuration (default ``''``)\n:return: en/decrypted string"
  },
  {
    "function": "encode_to_morse",
    "code": "def encode_to_morse(plaintext: str) -> str:\n    \"\"\"Encode a plaintext message into Morse code.\n\n    Args:\n        plaintext: The plaintext message to encode.\n\n    Returns:\n        The Morse code representation of the plaintext message.\n\n    Example:\n        >>> encode_to_morse(\"defend the east\")\n        '-..x.x..-.x.x-.x-..xx-x....x.xx.x.-x...x-'\n    \"\"\"\n    return \"x\".join([MORSE_CODE_DICT.get(letter.upper(), \"\") for letter in plaintext])",
    "docstring": "Encode a plaintext message into Morse code.\n\nArgs:\n    plaintext: The plaintext message to encode.\n\nReturns:\n    The Morse code representation of the plaintext message.\n\nExample:\n    >>> encode_to_morse(\"defend the east\")\n    '-..x.x..-.x.x-.x-..xx-x....x.xx.x.-x...x-'"
  },
  {
    "function": "encrypt_fractionated_morse",
    "code": "def encrypt_fractionated_morse(plaintext: str, key: str) -> str:\n    \"\"\"Encrypt a plaintext message using Fractionated Morse Cipher.\n\n    Args:\n        plaintext: The plaintext message to encrypt.\n        key: The encryption key.\n\n    Returns:\n        The encrypted ciphertext.\n\n    Example:\n        >>> encrypt_fractionated_morse(\"defend the east\",\"Roundtable\")\n        'ESOAVVLJRSSTRX'\n\n    \"\"\"\n    morse_code = encode_to_morse(plaintext)\n    key = key.upper() + string.ascii_uppercase\n    key = \"\".join(sorted(set(key), key=key.find))\n\n    # Ensure morse_code length is a multiple of 3\n    padding_length = 3 - (len(morse_code) % 3)\n    morse_code += \"x\" * padding_length\n\n    fractionated_morse_dict = {v: k for k, v in zip(key, MORSE_COMBINATIONS)}\n    fractionated_morse_dict[\"xxx\"] = \"\"\n    encrypted_text = \"\".join(\n        [\n            fractionated_morse_dict[morse_code[i : i + 3]]\n            for i in range(0, len(morse_code), 3)\n        ]\n    )\n    return encrypted_text",
    "docstring": "Encrypt a plaintext message using Fractionated Morse Cipher.\n\nArgs:\n    plaintext: The plaintext message to encrypt.\n    key: The encryption key.\n\nReturns:\n    The encrypted ciphertext.\n\nExample:\n    >>> encrypt_fractionated_morse(\"defend the east\",\"Roundtable\")\n    'ESOAVVLJRSSTRX'"
  },
  {
    "function": "decrypt_fractionated_morse",
    "code": "def decrypt_fractionated_morse(ciphertext: str, key: str) -> str:\n    \"\"\"Decrypt a ciphertext message encrypted with Fractionated Morse Cipher.\n\n    Args:\n        ciphertext: The ciphertext message to decrypt.\n        key: The decryption key.\n\n    Returns:\n        The decrypted plaintext message.\n\n    Example:\n        >>> decrypt_fractionated_morse(\"ESOAVVLJRSSTRX\",\"Roundtable\")\n        'DEFEND THE EAST'\n    \"\"\"\n    key = key.upper() + string.ascii_uppercase\n    key = \"\".join(sorted(set(key), key=key.find))\n\n    inverse_fractionated_morse_dict = dict(zip(key, MORSE_COMBINATIONS))\n    morse_code = \"\".join(\n        [inverse_fractionated_morse_dict.get(letter, \"\") for letter in ciphertext]\n    )\n    decrypted_text = \"\".join(\n        [REVERSE_DICT[code] for code in morse_code.split(\"x\")]\n    ).strip()\n    return decrypted_text",
    "docstring": "Decrypt a ciphertext message encrypted with Fractionated Morse Cipher.\n\nArgs:\n    ciphertext: The ciphertext message to decrypt.\n    key: The decryption key.\n\nReturns:\n    The decrypted plaintext message.\n\nExample:\n    >>> decrypt_fractionated_morse(\"ESOAVVLJRSSTRX\",\"Roundtable\")\n    'DEFEND THE EAST'"
  },
  {
    "function": "gronsfeld",
    "code": "def gronsfeld(text: str, key: str) -> str:\n    \"\"\"\n    Encrypt plaintext with the Gronsfeld cipher\n\n    >>> gronsfeld('hello', '412')\n    'LFNPP'\n    >>> gronsfeld('hello', '123')\n    'IGOMQ'\n    >>> gronsfeld('', '123')\n    ''\n    >>> gronsfeld('yes, \u00a5\u20ac$ - _!@#%?', '0')\n    'YES, \u00a5\u20ac$ - _!@#%?'\n    >>> gronsfeld('yes, \u00a5\u20ac$ - _!@#%?', '01')\n    'YFS, \u00a5\u20ac$ - _!@#%?'\n    >>> gronsfeld('yes, \u00a5\u20ac$ - _!@#%?', '012')\n    'YFU, \u00a5\u20ac$ - _!@#%?'\n    >>> gronsfeld('yes, \u00a5\u20ac$ - _!@#%?', '')\n    Traceback (most recent call last):\n      ...\n    ZeroDivisionError: division by zero\n    \"\"\"\n    ascii_len = len(ascii_uppercase)\n    key_len = len(key)\n    encrypted_text = \"\"\n    keys = [int(char) for char in key]\n    upper_case_text = text.upper()\n\n    for i, char in enumerate(upper_case_text):\n        if char in ascii_uppercase:\n            new_position = (ascii_uppercase.index(char) + keys[i % key_len]) % ascii_len\n            shifted_letter = ascii_uppercase[new_position]\n            encrypted_text += shifted_letter\n        else:\n            encrypted_text += char\n\n    return encrypted_text",
    "docstring": "Encrypt plaintext with the Gronsfeld cipher\n\n>>> gronsfeld('hello', '412')\n'LFNPP'\n>>> gronsfeld('hello', '123')\n'IGOMQ'\n>>> gronsfeld('', '123')\n''\n>>> gronsfeld('yes, \u00a5\u20ac$ - _!@#%?', '0')\n'YES, \u00a5\u20ac$ - _!@#%?'\n>>> gronsfeld('yes, \u00a5\u20ac$ - _!@#%?', '01')\n'YFS, \u00a5\u20ac$ - _!@#%?'\n>>> gronsfeld('yes, \u00a5\u20ac$ - _!@#%?', '012')\n'YFU, \u00a5\u20ac$ - _!@#%?'\n>>> gronsfeld('yes, \u00a5\u20ac$ - _!@#%?', '')\nTraceback (most recent call last):\n  ...\nZeroDivisionError: division by zero"
  },
  {
    "function": "mixed_keyword",
    "code": "def mixed_keyword(\n    keyword: str, plaintext: str, verbose: bool = False, alphabet: str = ascii_uppercase\n) -> str:\n    \"\"\"\n    For keyword: hello\n\n    H E L O\n    A B C D\n    F G I J\n    K M N P\n    Q R S T\n    U V W X\n    Y Z\n    and map vertically\n\n    >>> mixed_keyword(\"college\", \"UNIVERSITY\", True)  # doctest: +NORMALIZE_WHITESPACE\n    {'A': 'C', 'B': 'A', 'C': 'I', 'D': 'P', 'E': 'U', 'F': 'Z', 'G': 'O', 'H': 'B',\n     'I': 'J', 'J': 'Q', 'K': 'V', 'L': 'L', 'M': 'D', 'N': 'K', 'O': 'R', 'P': 'W',\n     'Q': 'E', 'R': 'F', 'S': 'M', 'T': 'S', 'U': 'X', 'V': 'G', 'W': 'H', 'X': 'N',\n     'Y': 'T', 'Z': 'Y'}\n    'XKJGUFMJST'\n\n    >>> mixed_keyword(\"college\", \"UNIVERSITY\", False)  # doctest: +NORMALIZE_WHITESPACE\n    'XKJGUFMJST'\n    \"\"\"\n    keyword = keyword.upper()\n    plaintext = plaintext.upper()\n    alphabet_set = set(alphabet)\n\n    # create a list of unique characters in the keyword - their order matters\n    # it determines how we will map plaintext characters to the ciphertext\n    unique_chars = []\n    for char in keyword:\n        if char in alphabet_set and char not in unique_chars:\n            unique_chars.append(char)\n    # the number of those unique characters will determine the number of rows\n    num_unique_chars_in_keyword = len(unique_chars)\n\n    # create a shifted version of the alphabet\n    shifted_alphabet = unique_chars + [\n        char for char in alphabet if char not in unique_chars\n    ]\n\n    # create a modified alphabet by splitting the shifted alphabet into rows\n    modified_alphabet = [\n        shifted_alphabet[k : k + num_unique_chars_in_keyword]\n        for k in range(0, 26, num_unique_chars_in_keyword)\n    ]\n\n    # map the alphabet characters to the modified alphabet characters\n    # going 'vertically' through the modified alphabet - consider columns first\n    mapping = {}\n    letter_index = 0\n    for column in range(num_unique_chars_in_keyword):\n        for row in modified_alphabet:\n            # if current row (the last one) is too short, break out of loop\n            if len(row) <= column:\n                break\n\n            # map current letter to letter in modified alphabet\n            mapping[alphabet[letter_index]] = row[column]\n            letter_index += 1\n\n    if verbose:\n        print(mapping)\n    # create the encrypted text by mapping the plaintext to the modified alphabet\n    return \"\".join(mapping.get(char, char) for char in plaintext)",
    "docstring": "For keyword: hello\n\nH E L O\nA B C D\nF G I J\nK M N P\nQ R S T\nU V W X\nY Z\nand map vertically\n\n>>> mixed_keyword(\"college\", \"UNIVERSITY\", True)  # doctest: +NORMALIZE_WHITESPACE\n{'A': 'C', 'B': 'A', 'C': 'I', 'D': 'P', 'E': 'U', 'F': 'Z', 'G': 'O', 'H': 'B',\n 'I': 'J', 'J': 'Q', 'K': 'V', 'L': 'L', 'M': 'D', 'N': 'K', 'O': 'R', 'P': 'W',\n 'Q': 'E', 'R': 'F', 'S': 'M', 'T': 'S', 'U': 'X', 'V': 'G', 'W': 'H', 'X': 'N',\n 'Y': 'T', 'Z': 'Y'}\n'XKJGUFMJST'\n\n>>> mixed_keyword(\"college\", \"UNIVERSITY\", False)  # doctest: +NORMALIZE_WHITESPACE\n'XKJGUFMJST'"
  },
  {
    "function": "translate_message",
    "code": "def translate_message(\n    key: str, message: str, mode: Literal[\"encrypt\", \"decrypt\"]\n) -> str:\n    \"\"\"\n    >>> translate_message(\"QWERTYUIOPASDFGHJKLZXCVBNM\",\"Hello World\",\"encrypt\")\n    'Pcssi Bidsm'\n    \"\"\"\n    chars_a = LETTERS if mode == \"decrypt\" else key\n    chars_b = key if mode == \"decrypt\" else LETTERS\n    translated = \"\"\n    # loop through each symbol in the message\n    for symbol in message:\n        if symbol.upper() in chars_a:\n            # encrypt/decrypt the symbol\n            sym_index = chars_a.find(symbol.upper())\n            if symbol.isupper():\n                translated += chars_b[sym_index].upper()\n            else:\n                translated += chars_b[sym_index].lower()\n        else:\n            # symbol is not in LETTERS, just add it\n            translated += symbol\n    return translated",
    "docstring": ">>> translate_message(\"QWERTYUIOPASDFGHJKLZXCVBNM\",\"Hello World\",\"encrypt\")\n'Pcssi Bidsm'"
  },
  {
    "function": "encrypt_message",
    "code": "def encrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(\"QWERTYUIOPASDFGHJKLZXCVBNM\", \"Hello World\")\n    'Pcssi Bidsm'\n    \"\"\"\n    return translate_message(key, message, \"encrypt\")",
    "docstring": ">>> encrypt_message(\"QWERTYUIOPASDFGHJKLZXCVBNM\", \"Hello World\")\n'Pcssi Bidsm'"
  },
  {
    "function": "decrypt_message",
    "code": "def decrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> decrypt_message(\"QWERTYUIOPASDFGHJKLZXCVBNM\", \"Hello World\")\n    'Itssg Vgksr'\n    \"\"\"\n    return translate_message(key, message, \"decrypt\")",
    "docstring": ">>> decrypt_message(\"QWERTYUIOPASDFGHJKLZXCVBNM\", \"Hello World\")\n'Itssg Vgksr'"
  },
  {
    "function": "encrypt",
    "code": "def encrypt(message: str) -> str:\n    \"\"\"\n    >>> encrypt(\"Sos!\")\n    '... --- ... -.-.--'\n    >>> encrypt(\"SOS!\") == encrypt(\"sos!\")\n    True\n    \"\"\"\n    return \" \".join(MORSE_CODE_DICT[char] for char in message.upper())",
    "docstring": ">>> encrypt(\"Sos!\")\n'... --- ... -.-.--'\n>>> encrypt(\"SOS!\") == encrypt(\"sos!\")\nTrue"
  },
  {
    "function": "decrypt",
    "code": "def decrypt(message: str) -> str:\n    \"\"\"\n    >>> decrypt('... --- ... -.-.--')\n    'SOS!'\n    \"\"\"\n    return \"\".join(REVERSE_DICT[char] for char in message.split())",
    "docstring": ">>> decrypt('... --- ... -.-.--')\n'SOS!'"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    >>> s = \"\".join(MORSE_CODE_DICT)\n    >>> decrypt(encrypt(s)) == s\n    True\n    \"\"\"\n    message = \"Morse code here!\"\n    print(message)\n    message = encrypt(message)\n    print(message)\n    message = decrypt(message)\n    print(message)",
    "docstring": ">>> s = \"\".join(MORSE_CODE_DICT)\n>>> decrypt(encrypt(s)) == s\nTrue"
  },
  {
    "function": "generate_valid_block_size",
    "code": "def generate_valid_block_size(message_length: int) -> int:\n    \"\"\"\n    Generate a valid block size that is a factor of the message length.\n\n    Args:\n        message_length (int): The length of the message.\n\n    Returns:\n        int: A valid block size.\n\n    Example:\n        >>> random.seed(1)\n        >>> generate_valid_block_size(12)\n        3\n    \"\"\"\n    block_sizes = [\n        block_size\n        for block_size in range(2, message_length + 1)\n        if message_length % block_size == 0\n    ]\n    return random.choice(block_sizes)",
    "docstring": "Generate a valid block size that is a factor of the message length.\n\nArgs:\n    message_length (int): The length of the message.\n\nReturns:\n    int: A valid block size.\n\nExample:\n    >>> random.seed(1)\n    >>> generate_valid_block_size(12)\n    3"
  },
  {
    "function": "generate_permutation_key",
    "code": "def generate_permutation_key(block_size: int) -> list[int]:\n    \"\"\"\n    Generate a random permutation key of a specified block size.\n\n    Args:\n        block_size (int): The size of each permutation block.\n\n    Returns:\n        list[int]: A list containing a random permutation of digits.\n\n    Example:\n        >>> random.seed(0)\n        >>> generate_permutation_key(4)\n        [2, 0, 1, 3]\n    \"\"\"\n    digits = list(range(block_size))\n    random.shuffle(digits)\n    return digits",
    "docstring": "Generate a random permutation key of a specified block size.\n\nArgs:\n    block_size (int): The size of each permutation block.\n\nReturns:\n    list[int]: A list containing a random permutation of digits.\n\nExample:\n    >>> random.seed(0)\n    >>> generate_permutation_key(4)\n    [2, 0, 1, 3]"
  },
  {
    "function": "encrypt",
    "code": "def encrypt(\n    message: str, key: list[int] | None = None, block_size: int | None = None\n) -> tuple[str, list[int]]:\n    \"\"\"\n    Encrypt a message using a permutation cipher with block rearrangement using a key.\n\n    Args:\n        message (str): The plaintext message to be encrypted.\n        key (list[int]): The permutation key for decryption.\n        block_size (int): The size of each permutation block.\n\n    Returns:\n        tuple: A tuple containing the encrypted message and the encryption key.\n\n    Example:\n        >>> encrypted_message, key = encrypt(\"HELLO WORLD\")\n        >>> decrypted_message = decrypt(encrypted_message, key)\n        >>> decrypted_message\n        'HELLO WORLD'\n    \"\"\"\n    message = message.upper()\n    message_length = len(message)\n\n    if key is None or block_size is None:\n        block_size = generate_valid_block_size(message_length)\n        key = generate_permutation_key(block_size)\n\n    encrypted_message = \"\"\n\n    for i in range(0, message_length, block_size):\n        block = message[i : i + block_size]\n        rearranged_block = [block[digit] for digit in key]\n        encrypted_message += \"\".join(rearranged_block)\n\n    return encrypted_message, key",
    "docstring": "Encrypt a message using a permutation cipher with block rearrangement using a key.\n\nArgs:\n    message (str): The plaintext message to be encrypted.\n    key (list[int]): The permutation key for decryption.\n    block_size (int): The size of each permutation block.\n\nReturns:\n    tuple: A tuple containing the encrypted message and the encryption key.\n\nExample:\n    >>> encrypted_message, key = encrypt(\"HELLO WORLD\")\n    >>> decrypted_message = decrypt(encrypted_message, key)\n    >>> decrypted_message\n    'HELLO WORLD'"
  },
  {
    "function": "decrypt",
    "code": "def decrypt(encrypted_message: str, key: list[int]) -> str:\n    \"\"\"\n    Decrypt an encrypted message using a permutation cipher with block rearrangement.\n\n    Args:\n        encrypted_message (str): The encrypted message.\n        key (list[int]): The permutation key for decryption.\n\n    Returns:\n        str: The decrypted plaintext message.\n\n    Example:\n        >>> encrypted_message, key = encrypt(\"HELLO WORLD\")\n        >>> decrypted_message = decrypt(encrypted_message, key)\n        >>> decrypted_message\n        'HELLO WORLD'\n    \"\"\"\n    key_length = len(key)\n    decrypted_message = \"\"\n\n    for i in range(0, len(encrypted_message), key_length):\n        block = encrypted_message[i : i + key_length]\n        original_block = [\"\"] * key_length\n        for j, digit in enumerate(key):\n            original_block[digit] = block[j]\n        decrypted_message += \"\".join(original_block)\n\n    return decrypted_message",
    "docstring": "Decrypt an encrypted message using a permutation cipher with block rearrangement.\n\nArgs:\n    encrypted_message (str): The encrypted message.\n    key (list[int]): The permutation key for decryption.\n\nReturns:\n    str: The decrypted plaintext message.\n\nExample:\n    >>> encrypted_message, key = encrypt(\"HELLO WORLD\")\n    >>> decrypted_message = decrypt(encrypted_message, key)\n    >>> decrypted_message\n    'HELLO WORLD'"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Driver function to pass message to get encrypted, then decrypted.\n\n    Example:\n    >>> main()\n    Decrypted message: HELLO WORLD\n    \"\"\"\n    message = \"HELLO WORLD\"\n    encrypted_message, key = encrypt(message)\n\n    decrypted_message = decrypt(encrypted_message, key)\n    print(f\"Decrypted message: {decrypted_message}\")",
    "docstring": "Driver function to pass message to get encrypted, then decrypted.\n\nExample:\n>>> main()\nDecrypted message: HELLO WORLD"
  },
  {
    "function": "prepare_input",
    "code": "def prepare_input(dirty: str) -> str:\n    \"\"\"\n    Prepare the plaintext by up-casing it\n    and separating repeated letters with X's\n    \"\"\"\n\n    dirty = \"\".join([c.upper() for c in dirty if c in string.ascii_letters])\n    clean = \"\"\n\n    if len(dirty) < 2:\n        return dirty\n\n    for i in range(len(dirty) - 1):\n        clean += dirty[i]\n\n        if dirty[i] == dirty[i + 1]:\n            clean += \"X\"\n\n    clean += dirty[-1]\n\n    if len(clean) & 1:\n        clean += \"X\"\n\n    return clean",
    "docstring": "Prepare the plaintext by up-casing it\nand separating repeated letters with X's"
  },
  {
    "function": "encode",
    "code": "def encode(plaintext: str, key: str) -> str:\n    \"\"\"\n    Encode the given plaintext using the Playfair cipher.\n    Takes the plaintext and the key as input and returns the encoded string.\n\n    >>> encode(\"Hello\", \"MONARCHY\")\n    'CFSUPM'\n    >>> encode(\"attack on the left flank\", \"EMERGENCY\")\n    'DQZSBYFSDZFMFNLOHFDRSG'\n    >>> encode(\"Sorry!\", \"SPECIAL\")\n    'AVXETX'\n    >>> encode(\"Number 1\", \"NUMBER\")\n    'UMBENF'\n    >>> encode(\"Photosynthesis!\", \"THE SUN\")\n    'OEMHQHVCHESUKE'\n    \"\"\"\n\n    table = generate_table(key)\n    plaintext = prepare_input(plaintext)\n    ciphertext = \"\"\n\n    for char1, char2 in chunker(plaintext, 2):\n        row1, col1 = divmod(table.index(char1), 5)\n        row2, col2 = divmod(table.index(char2), 5)\n\n        if row1 == row2:\n            ciphertext += table[row1 * 5 + (col1 + 1) % 5]\n            ciphertext += table[row2 * 5 + (col2 + 1) % 5]\n        elif col1 == col2:\n            ciphertext += table[((row1 + 1) % 5) * 5 + col1]\n            ciphertext += table[((row2 + 1) % 5) * 5 + col2]\n        else:  # rectangle\n            ciphertext += table[row1 * 5 + col2]\n            ciphertext += table[row2 * 5 + col1]\n\n    return ciphertext",
    "docstring": "Encode the given plaintext using the Playfair cipher.\nTakes the plaintext and the key as input and returns the encoded string.\n\n>>> encode(\"Hello\", \"MONARCHY\")\n'CFSUPM'\n>>> encode(\"attack on the left flank\", \"EMERGENCY\")\n'DQZSBYFSDZFMFNLOHFDRSG'\n>>> encode(\"Sorry!\", \"SPECIAL\")\n'AVXETX'\n>>> encode(\"Number 1\", \"NUMBER\")\n'UMBENF'\n>>> encode(\"Photosynthesis!\", \"THE SUN\")\n'OEMHQHVCHESUKE'"
  },
  {
    "function": "decode",
    "code": "def decode(ciphertext: str, key: str) -> str:\n    \"\"\"\n    Decode the input string using the provided key.\n\n    >>> decode(\"BMZFAZRZDH\", \"HAZARD\")\n    'FIREHAZARD'\n    >>> decode(\"HNBWBPQT\", \"AUTOMOBILE\")\n    'DRIVINGX'\n    >>> decode(\"SLYSSAQS\", \"CASTLE\")\n    'ATXTACKX'\n    \"\"\"\n\n    table = generate_table(key)\n    plaintext = \"\"\n\n    for char1, char2 in chunker(ciphertext, 2):\n        row1, col1 = divmod(table.index(char1), 5)\n        row2, col2 = divmod(table.index(char2), 5)\n\n        if row1 == row2:\n            plaintext += table[row1 * 5 + (col1 - 1) % 5]\n            plaintext += table[row2 * 5 + (col2 - 1) % 5]\n        elif col1 == col2:\n            plaintext += table[((row1 - 1) % 5) * 5 + col1]\n            plaintext += table[((row2 - 1) % 5) * 5 + col2]\n        else:  # rectangle\n            plaintext += table[row1 * 5 + col2]\n            plaintext += table[row2 * 5 + col1]\n\n    return plaintext",
    "docstring": "Decode the input string using the provided key.\n\n>>> decode(\"BMZFAZRZDH\", \"HAZARD\")\n'FIREHAZARD'\n>>> decode(\"HNBWBPQT\", \"AUTOMOBILE\")\n'DRIVINGX'\n>>> decode(\"SLYSSAQS\", \"CASTLE\")\n'ATXTACKX'"
  },
  {
    "function": "generate_table",
    "code": "def generate_table(key: str) -> list[tuple[str, str]]:\n    \"\"\"\n    >>> generate_table('marvin')  # doctest: +NORMALIZE_WHITESPACE\n    [('ABCDEFGHIJKLM', 'UVWXYZNOPQRST'), ('ABCDEFGHIJKLM', 'NOPQRSTUVWXYZ'),\n     ('ABCDEFGHIJKLM', 'STUVWXYZNOPQR'), ('ABCDEFGHIJKLM', 'QRSTUVWXYZNOP'),\n     ('ABCDEFGHIJKLM', 'WXYZNOPQRSTUV'), ('ABCDEFGHIJKLM', 'UVWXYZNOPQRST')]\n    \"\"\"\n    return [alphabet[char] for char in key.upper()]",
    "docstring": ">>> generate_table('marvin')  # doctest: +NORMALIZE_WHITESPACE\n[('ABCDEFGHIJKLM', 'UVWXYZNOPQRST'), ('ABCDEFGHIJKLM', 'NOPQRSTUVWXYZ'),\n ('ABCDEFGHIJKLM', 'STUVWXYZNOPQR'), ('ABCDEFGHIJKLM', 'QRSTUVWXYZNOP'),\n ('ABCDEFGHIJKLM', 'WXYZNOPQRSTUV'), ('ABCDEFGHIJKLM', 'UVWXYZNOPQRST')]"
  },
  {
    "function": "encrypt",
    "code": "def encrypt(key: str, words: str) -> str:\n    \"\"\"\n    >>> encrypt('marvin', 'jessica')\n    'QRACRWU'\n    \"\"\"\n    cipher = \"\"\n    count = 0\n    table = generate_table(key)\n    for char in words.upper():\n        cipher += get_opponent(table[count], char)\n        count = (count + 1) % len(table)\n    return cipher",
    "docstring": ">>> encrypt('marvin', 'jessica')\n'QRACRWU'"
  },
  {
    "function": "decrypt",
    "code": "def decrypt(key: str, words: str) -> str:\n    \"\"\"\n    >>> decrypt('marvin', 'QRACRWU')\n    'JESSICA'\n    \"\"\"\n    return encrypt(key, words)",
    "docstring": ">>> decrypt('marvin', 'QRACRWU')\n'JESSICA'"
  },
  {
    "function": "get_position",
    "code": "def get_position(table: tuple[str, str], char: str) -> tuple[int, int]:\n    \"\"\"\n    >>> get_position(generate_table('marvin')[0], 'M')\n    (0, 12)\n    \"\"\"\n    # `char` is either in the 0th row or the 1st row\n    row = 0 if char in table[0] else 1\n    col = table[row].index(char)\n    return row, col",
    "docstring": ">>> get_position(generate_table('marvin')[0], 'M')\n(0, 12)"
  },
  {
    "function": "get_opponent",
    "code": "def get_opponent(table: tuple[str, str], char: str) -> str:\n    \"\"\"\n    >>> get_opponent(generate_table('marvin')[0], 'M')\n    'T'\n    \"\"\"\n    row, col = get_position(table, char.upper())\n    if row == 1:\n        return table[0][col]\n    else:\n        return table[1][col] if row == 0 else char",
    "docstring": ">>> get_opponent(generate_table('marvin')[0], 'M')\n'T'"
  },
  {
    "function": "encrypt",
    "code": "def encrypt(input_string: str, key: int) -> str:\n    \"\"\"\n    Shuffles the character of a string by placing each of them\n    in a grid (the height is dependent on the key) in a zigzag\n    formation and reading it left to right.\n\n    >>> encrypt(\"Hello World\", 4)\n    'HWe olordll'\n\n    >>> encrypt(\"This is a message\", 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Height of grid can't be 0 or negative\n\n    >>> encrypt(b\"This is a byte string\", 5)\n    Traceback (most recent call last):\n        ...\n    TypeError: sequence item 0: expected str instance, int found\n    \"\"\"\n    temp_grid: list[list[str]] = [[] for _ in range(key)]\n    lowest = key - 1\n\n    if key <= 0:\n        raise ValueError(\"Height of grid can't be 0 or negative\")\n    if key == 1 or len(input_string) <= key:\n        return input_string\n\n    for position, character in enumerate(input_string):\n        num = position % (lowest * 2)  # puts it in bounds\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\n        temp_grid[num].append(character)\n    grid = [\"\".join(row) for row in temp_grid]\n    output_string = \"\".join(grid)\n\n    return output_string",
    "docstring": "Shuffles the character of a string by placing each of them\nin a grid (the height is dependent on the key) in a zigzag\nformation and reading it left to right.\n\n>>> encrypt(\"Hello World\", 4)\n'HWe olordll'\n\n>>> encrypt(\"This is a message\", 0)\nTraceback (most recent call last):\n    ...\nValueError: Height of grid can't be 0 or negative\n\n>>> encrypt(b\"This is a byte string\", 5)\nTraceback (most recent call last):\n    ...\nTypeError: sequence item 0: expected str instance, int found"
  },
  {
    "function": "decrypt",
    "code": "def decrypt(input_string: str, key: int) -> str:\n    \"\"\"\n    Generates a template based on the key and fills it in with\n    the characters of the input string and then reading it in\n    a zigzag formation.\n\n    >>> decrypt(\"HWe olordll\", 4)\n    'Hello World'\n\n    >>> decrypt(\"This is a message\", -10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Height of grid can't be 0 or negative\n\n    >>> decrypt(\"My key is very big\", 100)\n    'My key is very big'\n    \"\"\"\n    grid = []\n    lowest = key - 1\n\n    if key <= 0:\n        raise ValueError(\"Height of grid can't be 0 or negative\")\n    if key == 1:\n        return input_string\n\n    temp_grid: list[list[str]] = [[] for _ in range(key)]  # generates template\n    for position in range(len(input_string)):\n        num = position % (lowest * 2)  # puts it in bounds\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\n        temp_grid[num].append(\"*\")\n\n    counter = 0\n    for row in temp_grid:  # fills in the characters\n        splice = input_string[counter : counter + len(row)]\n        grid.append(list(splice))\n        counter += len(row)\n\n    output_string = \"\"  # reads as zigzag\n    for position in range(len(input_string)):\n        num = position % (lowest * 2)  # puts it in bounds\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\n        output_string += grid[num][0]\n        grid[num].pop(0)\n    return output_string",
    "docstring": "Generates a template based on the key and fills it in with\nthe characters of the input string and then reading it in\na zigzag formation.\n\n>>> decrypt(\"HWe olordll\", 4)\n'Hello World'\n\n>>> decrypt(\"This is a message\", -10)\nTraceback (most recent call last):\n    ...\nValueError: Height of grid can't be 0 or negative\n\n>>> decrypt(\"My key is very big\", 100)\n'My key is very big'"
  },
  {
    "function": "bruteforce",
    "code": "def bruteforce(input_string: str) -> dict[int, str]:\n    \"\"\"Uses decrypt function by guessing every key\n\n    >>> bruteforce(\"HWe olordll\")[4]\n    'Hello World'\n    \"\"\"\n    results = {}\n    for key_guess in range(1, len(input_string)):  # tries every key\n        results[key_guess] = decrypt(input_string, key_guess)\n    return results",
    "docstring": "Uses decrypt function by guessing every key\n\n>>> bruteforce(\"HWe olordll\")[4]\n'Hello World'"
  },
  {
    "function": "dencrypt",
    "code": "def dencrypt(s: str, n: int = 13) -> str:\n    \"\"\"\n    https://en.wikipedia.org/wiki/ROT13\n\n    >>> msg = \"My secret bank account number is 173-52946 so don't tell anyone!!\"\n    >>> s = dencrypt(msg)\n    >>> s\n    \"Zl frperg onax nppbhag ahzore vf 173-52946 fb qba'g gryy nalbar!!\"\n    >>> dencrypt(s) == msg\n    True\n    \"\"\"\n    out = \"\"\n    for c in s:\n        if \"A\" <= c <= \"Z\":\n            out += chr(ord(\"A\") + (ord(c) - ord(\"A\") + n) % 26)\n        elif \"a\" <= c <= \"z\":\n            out += chr(ord(\"a\") + (ord(c) - ord(\"a\") + n) % 26)\n        else:\n            out += c\n    return out",
    "docstring": "https://en.wikipedia.org/wiki/ROT13\n\n>>> msg = \"My secret bank account number is 173-52946 so don't tell anyone!!\"\n>>> s = dencrypt(msg)\n>>> s\n\"Zl frperg onax nppbhag ahzore vf 173-52946 fb qba'g gryy nalbar!!\"\n>>> dencrypt(s) == msg\nTrue"
  },
  {
    "function": "rsafactor",
    "code": "def rsafactor(d: int, e: int, n: int) -> list[int]:\n    \"\"\"\n    This function returns the factors of N, where p*q=N\n\n    Return: [p, q]\n\n    We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.\n    The pair (N, e) is the public key. As its name suggests, it is public and is used to\n    encrypt messages.\n    The pair (N, d) is the secret key or private key and is known only to the recipient\n    of encrypted messages.\n\n    >>> rsafactor(3, 16971, 25777)\n    [149, 173]\n    >>> rsafactor(7331, 11, 27233)\n    [113, 241]\n    >>> rsafactor(4021, 13, 17711)\n    [89, 199]\n    \"\"\"\n    k = d * e - 1\n    p = 0\n    q = 0\n    while p == 0:\n        g = random.randint(2, n - 1)\n        t = k\n        while True:\n            if t % 2 == 0:\n                t = t // 2\n                x = (g**t) % n\n                y = math.gcd(x - 1, n)\n                if x > 1 and y > 1:\n                    p = y\n                    q = n // y\n                    break  # find the correct factors\n            else:\n                break  # t is not divisible by 2, break and choose another g\n    return sorted([p, q])",
    "docstring": "This function returns the factors of N, where p*q=N\n\nReturn: [p, q]\n\nWe call N the RSA modulus, e the encryption exponent, and d the decryption exponent.\nThe pair (N, e) is the public key. As its name suggests, it is public and is used to\nencrypt messages.\nThe pair (N, d) is the secret key or private key and is known only to the recipient\nof encrypted messages.\n\n>>> rsafactor(3, 16971, 25777)\n[149, 173]\n>>> rsafactor(7331, 11, 27233)\n[113, 241]\n>>> rsafactor(4021, 13, 17711)\n[89, 199]"
  },
  {
    "function": "generate_key",
    "code": "def generate_key(key_size: int) -> tuple[tuple[int, int], tuple[int, int]]:\n    \"\"\"\n    >>> random.seed(0) # for repeatability\n    >>> public_key, private_key = generate_key(8)\n    >>> public_key\n    (26569, 239)\n    >>> private_key\n    (26569, 2855)\n    \"\"\"\n    p = rabin_miller.generate_large_prime(key_size)\n    q = rabin_miller.generate_large_prime(key_size)\n    n = p * q\n\n    # Generate e that is relatively prime to (p - 1) * (q - 1)\n    while True:\n        e = random.randrange(2 ** (key_size - 1), 2 ** (key_size))\n        if gcd_by_iterative(e, (p - 1) * (q - 1)) == 1:\n            break\n\n    # Calculate d that is mod inverse of e\n    d = cryptomath_module.find_mod_inverse(e, (p - 1) * (q - 1))\n\n    public_key = (n, e)\n    private_key = (n, d)\n    return (public_key, private_key)",
    "docstring": ">>> random.seed(0) # for repeatability\n>>> public_key, private_key = generate_key(8)\n>>> public_key\n(26569, 239)\n>>> private_key\n(26569, 2855)"
  },
  {
    "function": "running_key_encrypt",
    "code": "def running_key_encrypt(key: str, plaintext: str) -> str:\n    \"\"\"\n    Encrypts the plaintext using the Running Key Cipher.\n\n    :param key: The running key (long piece of text).\n    :param plaintext: The plaintext to be encrypted.\n    :return: The ciphertext.\n    \"\"\"\n    plaintext = plaintext.replace(\" \", \"\").upper()\n    key = key.replace(\" \", \"\").upper()\n    key_length = len(key)\n    ciphertext = []\n    ord_a = ord(\"A\")\n\n    for i, char in enumerate(plaintext):\n        p = ord(char) - ord_a\n        k = ord(key[i % key_length]) - ord_a\n        c = (p + k) % 26\n        ciphertext.append(chr(c + ord_a))\n\n    return \"\".join(ciphertext)",
    "docstring": "Encrypts the plaintext using the Running Key Cipher.\n\n:param key: The running key (long piece of text).\n:param plaintext: The plaintext to be encrypted.\n:return: The ciphertext."
  },
  {
    "function": "running_key_decrypt",
    "code": "def running_key_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts the ciphertext using the Running Key Cipher.\n\n    :param key: The running key (long piece of text).\n    :param ciphertext: The ciphertext to be decrypted.\n    :return: The plaintext.\n    \"\"\"\n    ciphertext = ciphertext.replace(\" \", \"\").upper()\n    key = key.replace(\" \", \"\").upper()\n    key_length = len(key)\n    plaintext = []\n    ord_a = ord(\"A\")\n\n    for i, char in enumerate(ciphertext):\n        c = ord(char) - ord_a\n        k = ord(key[i % key_length]) - ord_a\n        p = (c - k) % 26\n        plaintext.append(chr(p + ord_a))\n\n    return \"\".join(plaintext)",
    "docstring": "Decrypts the ciphertext using the Running Key Cipher.\n\n:param key: The running key (long piece of text).\n:param ciphertext: The ciphertext to be decrypted.\n:return: The plaintext."
  },
  {
    "function": "test_running_key_encrypt",
    "code": "def test_running_key_encrypt() -> None:\n    \"\"\"\n    >>> key = \"How does the duck know that? said Victor\"\n    >>> ciphertext = running_key_encrypt(key, \"DEFEND THIS\")\n    >>> running_key_decrypt(key, ciphertext) == \"DEFENDTHIS\"\n    True\n    \"\"\"",
    "docstring": ">>> key = \"How does the duck know that? said Victor\"\n>>> ciphertext = running_key_encrypt(key, \"DEFEND THIS\")\n>>> running_key_decrypt(key, ciphertext) == \"DEFENDTHIS\"\nTrue"
  },
  {
    "function": "test_end_to_end",
    "code": "def test_end_to_end(msg: str = \"Hello, this is a modified Caesar cipher\") -> str:\n    \"\"\"\n    >>> test_end_to_end()\n    'Hello, this is a modified Caesar cipher'\n    \"\"\"\n    cip1 = ShuffledShiftCipher()\n    return cip1.decrypt(cip1.encrypt(msg))",
    "docstring": ">>> test_end_to_end()\n'Hello, this is a modified Caesar cipher'"
  },
  {
    "function": "remove_duplicates",
    "code": "def remove_duplicates(key: str) -> str:\n    \"\"\"\n    Removes duplicate alphabetic characters in a keyword (letter is ignored after its\n    first appearance).\n\n    :param key: Keyword to use\n    :return: String with duplicates removed\n\n    >>> remove_duplicates('Hello World!!')\n    'Helo Wrd'\n    \"\"\"\n\n    key_no_dups = \"\"\n    for ch in key:\n        if ch == \" \" or (ch not in key_no_dups and ch.isalpha()):\n            key_no_dups += ch\n    return key_no_dups",
    "docstring": "Removes duplicate alphabetic characters in a keyword (letter is ignored after its\nfirst appearance).\n\n:param key: Keyword to use\n:return: String with duplicates removed\n\n>>> remove_duplicates('Hello World!!')\n'Helo Wrd'"
  },
  {
    "function": "create_cipher_map",
    "code": "def create_cipher_map(key: str) -> dict[str, str]:\n    \"\"\"\n    Returns a cipher map given a keyword.\n\n    :param key: keyword to use\n    :return: dictionary cipher map\n    \"\"\"\n    # Create a list of the letters in the alphabet\n    alphabet = [chr(i + 65) for i in range(26)]\n    # Remove duplicate characters from key\n    key = remove_duplicates(key.upper())\n    offset = len(key)\n    # First fill cipher with key characters\n    cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}\n    # Then map remaining characters in alphabet to\n    # the alphabet from the beginning\n    for i in range(len(cipher_alphabet), 26):\n        char = alphabet[i - offset]\n        # Ensure we are not mapping letters to letters previously mapped\n        while char in key:\n            offset -= 1\n            char = alphabet[i - offset]\n        cipher_alphabet[alphabet[i]] = char\n    return cipher_alphabet",
    "docstring": "Returns a cipher map given a keyword.\n\n:param key: keyword to use\n:return: dictionary cipher map"
  },
  {
    "function": "encipher",
    "code": "def encipher(message: str, cipher_map: dict[str, str]) -> str:\n    \"\"\"\n    Enciphers a message given a cipher map.\n\n    :param message: Message to encipher\n    :param cipher_map: Cipher map\n    :return: enciphered string\n\n    >>> encipher('Hello World!!', create_cipher_map('Goodbye!!'))\n    'CYJJM VMQJB!!'\n    \"\"\"\n    return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())",
    "docstring": "Enciphers a message given a cipher map.\n\n:param message: Message to encipher\n:param cipher_map: Cipher map\n:return: enciphered string\n\n>>> encipher('Hello World!!', create_cipher_map('Goodbye!!'))\n'CYJJM VMQJB!!'"
  },
  {
    "function": "decipher",
    "code": "def decipher(message: str, cipher_map: dict[str, str]) -> str:\n    \"\"\"\n    Deciphers a message given a cipher map\n\n    :param message: Message to decipher\n    :param cipher_map: Dictionary mapping to use\n    :return: Deciphered string\n\n    >>> cipher_map = create_cipher_map('Goodbye!!')\n    >>> decipher(encipher('Hello World!!', cipher_map), cipher_map)\n    'HELLO WORLD!!'\n    \"\"\"\n    # Reverse our cipher mappings\n    rev_cipher_map = {v: k for k, v in cipher_map.items()}\n    return \"\".join(rev_cipher_map.get(ch, ch) for ch in message.upper())",
    "docstring": "Deciphers a message given a cipher map\n\n:param message: Message to decipher\n:param cipher_map: Dictionary mapping to use\n:return: Deciphered string\n\n>>> cipher_map = create_cipher_map('Goodbye!!')\n>>> decipher(encipher('Hello World!!', cipher_map), cipher_map)\n'HELLO WORLD!!'"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Handles I/O\n\n    :return: void\n    \"\"\"\n    message = input(\"Enter message to encode or decode: \").strip()\n    key = input(\"Enter keyword: \").strip()\n    option = input(\"Encipher or decipher? E/D:\").strip()[0].lower()\n    try:\n        func = {\"e\": encipher, \"d\": decipher}[option]\n    except KeyError:\n        raise KeyError(\"invalid input option\")\n    cipher_map = create_cipher_map(key)\n    print(func(message, cipher_map))",
    "docstring": "Handles I/O\n\n:return: void"
  },
  {
    "function": "encrypt_message",
    "code": "def encrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Harshil Darji')\n    'Ilcrism Olcvs'\n    \"\"\"\n    return translate_message(key, message, \"encrypt\")",
    "docstring": ">>> encrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Harshil Darji')\n'Ilcrism Olcvs'"
  },
  {
    "function": "decrypt_message",
    "code": "def decrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> decrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Ilcrism Olcvs')\n    'Harshil Darji'\n    \"\"\"\n    return translate_message(key, message, \"decrypt\")",
    "docstring": ">>> decrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Ilcrism Olcvs')\n'Harshil Darji'"
  },
  {
    "function": "encrypt_message",
    "code": "def encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)",
    "docstring": ">>> encrypt_message(6, 'Harshil Darji')\n'Hlia rDsahrij'"
  },
  {
    "function": "decrypt_message",
    "code": "def decrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> decrypt_message(6, 'Hlia rDsahrij')\n    'Harshil Darji'\n    \"\"\"\n    num_cols = math.ceil(len(message) / key)\n    num_rows = key\n    num_shaded_boxes = (num_cols * num_rows) - len(message)\n    plain_text = [\"\"] * num_cols\n    col = 0\n    row = 0\n\n    for symbol in message:\n        plain_text[col] += symbol\n        col += 1\n\n        if (col == num_cols) or (\n            (col == num_cols - 1) and (row >= num_rows - num_shaded_boxes)\n        ):\n            col = 0\n            row += 1\n\n    return \"\".join(plain_text)",
    "docstring": ">>> decrypt_message(6, 'Hlia rDsahrij')\n'Harshil Darji'"
  },
  {
    "function": "__encrypt_part",
    "code": "def __encrypt_part(message_part: str, character_to_number: dict[str, str]) -> str:\n    \"\"\"\n    Arrange the triagram value of each letter of `message_part` vertically and join\n    them horizontally.\n\n    >>> __encrypt_part('ASK', TEST_CHARACTER_TO_NUMBER)\n    '132111112'\n    \"\"\"\n    one, two, three = \"\", \"\", \"\"\n    for each in (character_to_number[character] for character in message_part):\n        one += each[0]\n        two += each[1]\n        three += each[2]\n\n    return one + two + three",
    "docstring": "Arrange the triagram value of each letter of `message_part` vertically and join\nthem horizontally.\n\n>>> __encrypt_part('ASK', TEST_CHARACTER_TO_NUMBER)\n'132111112'"
  },
  {
    "function": "__decrypt_part",
    "code": "def __decrypt_part(\n    message_part: str, character_to_number: dict[str, str]\n) -> tuple[str, str, str]:\n    \"\"\"\n    Convert each letter of the input string into their respective trigram values, join\n    them and split them into three equal groups of strings which are returned.\n\n    >>> __decrypt_part('ABCDE', TEST_CHARACTER_TO_NUMBER)\n    ('11111', '21131', '21122')\n    \"\"\"\n    this_part = \"\".join(character_to_number[character] for character in message_part)\n    result = []\n    tmp = \"\"\n    for digit in this_part:\n        tmp += digit\n        if len(tmp) == len(message_part):\n            result.append(tmp)\n            tmp = \"\"\n\n    return result[0], result[1], result[2]",
    "docstring": "Convert each letter of the input string into their respective trigram values, join\nthem and split them into three equal groups of strings which are returned.\n\n>>> __decrypt_part('ABCDE', TEST_CHARACTER_TO_NUMBER)\n('11111', '21131', '21122')"
  },
  {
    "function": "__prepare",
    "code": "def __prepare(\n    message: str, alphabet: str\n) -> tuple[str, str, dict[str, str], dict[str, str]]:\n    \"\"\"\n    A helper function that generates the triagrams and assigns each letter of the\n    alphabet to its corresponding triagram and stores this in a dictionary\n    (`character_to_number` and `number_to_character`) after confirming if the\n    alphabet's length is ``27``.\n\n    >>> test = __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVwxYZ+')\n    >>> expected = ('IAMABOY','ABCDEFGHIJKLMNOPQRSTUVWXYZ+',\n    ... TEST_CHARACTER_TO_NUMBER, TEST_NUMBER_TO_CHARACTER)\n    >>> test == expected\n    True\n\n    Testing with incomplete alphabet\n\n    >>> __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVw')\n    Traceback (most recent call last):\n        ...\n    KeyError: 'Length of alphabet has to be 27.'\n\n    Testing with extra long alphabets\n\n    >>> __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVwxyzzwwtyyujjgfd')\n    Traceback (most recent call last):\n        ...\n    KeyError: 'Length of alphabet has to be 27.'\n\n    Testing with punctuation not in the given alphabet\n\n    >>> __prepare('am i a boy?','abCdeFghijkLmnopqrStuVwxYZ+')\n    Traceback (most recent call last):\n        ...\n    ValueError: Each message character has to be included in alphabet!\n\n    Testing with numbers\n\n    >>> __prepare(500,'abCdeFghijkLmnopqrStuVwxYZ+')\n    Traceback (most recent call last):\n        ...\n    AttributeError: 'int' object has no attribute 'replace'\n    \"\"\"\n    # Validate message and alphabet, set to upper and remove spaces\n    alphabet = alphabet.replace(\" \", \"\").upper()\n    message = message.replace(\" \", \"\").upper()\n\n    # Check length and characters\n    if len(alphabet) != 27:\n        raise KeyError(\"Length of alphabet has to be 27.\")\n    if any(char not in alphabet for char in message):\n        raise ValueError(\"Each message character has to be included in alphabet!\")\n\n    # Generate dictionares\n    character_to_number = dict(zip(alphabet, TEST_CHARACTER_TO_NUMBER.values()))\n    number_to_character = {\n        number: letter for letter, number in character_to_number.items()\n    }\n\n    return message, alphabet, character_to_number, number_to_character",
    "docstring": "A helper function that generates the triagrams and assigns each letter of the\nalphabet to its corresponding triagram and stores this in a dictionary\n(`character_to_number` and `number_to_character`) after confirming if the\nalphabet's length is ``27``.\n\n>>> test = __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVwxYZ+')\n>>> expected = ('IAMABOY','ABCDEFGHIJKLMNOPQRSTUVWXYZ+',\n... TEST_CHARACTER_TO_NUMBER, TEST_NUMBER_TO_CHARACTER)\n>>> test == expected\nTrue\n\nTesting with incomplete alphabet\n\n>>> __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVw')\nTraceback (most recent call last):\n    ...\nKeyError: 'Length of alphabet has to be 27.'\n\nTesting with extra long alphabets\n\n>>> __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVwxyzzwwtyyujjgfd')\nTraceback (most recent call last):\n    ...\nKeyError: 'Length of alphabet has to be 27.'\n\nTesting with punctuation not in the given alphabet\n\n>>> __prepare('am i a boy?','abCdeFghijkLmnopqrStuVwxYZ+')\nTraceback (most recent call last):\n    ...\nValueError: Each message character has to be included in alphabet!\n\nTesting with numbers\n\n>>> __prepare(500,'abCdeFghijkLmnopqrStuVwxYZ+')\nTraceback (most recent call last):\n    ...\nAttributeError: 'int' object has no attribute 'replace'"
  },
  {
    "function": "encrypt_message",
    "code": "def encrypt_message(\n    message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5\n) -> str:\n    \"\"\"\n    encrypt_message\n    ===============\n\n    Encrypts a message using the trifid_cipher. Any punctuatuion chars that\n    would be used should be added to the alphabet.\n\n    PARAMETERS\n    ----------\n\n    *   `message`: The message you want to encrypt.\n    *   `alphabet` (optional): The characters to be used for the cipher .\n    *   `period` (optional): The number of characters you want in a group whilst\n        encrypting.\n\n    >>> encrypt_message('I am a boy')\n    'BCDGBQY'\n\n    >>> encrypt_message(' ')\n    ''\n\n    >>> encrypt_message('   aide toi le c  iel      ta id  era    ',\n    ... 'FELIXMARDSTBCGHJKNOPQUVWYZ+',5)\n    'FMJFVOISSUFTFPUFEQQC'\n\n    \"\"\"\n    message, alphabet, character_to_number, number_to_character = __prepare(\n        message, alphabet\n    )\n\n    encrypted_numeric = \"\"\n    for i in range(0, len(message) + 1, period):\n        encrypted_numeric += __encrypt_part(\n            message[i : i + period], character_to_number\n        )\n\n    encrypted = \"\"\n    for i in range(0, len(encrypted_numeric), 3):\n        encrypted += number_to_character[encrypted_numeric[i : i + 3]]\n    return encrypted",
    "docstring": "encrypt_message\n===============\n\nEncrypts a message using the trifid_cipher. Any punctuatuion chars that\nwould be used should be added to the alphabet.\n\nPARAMETERS\n----------\n\n*   `message`: The message you want to encrypt.\n*   `alphabet` (optional): The characters to be used for the cipher .\n*   `period` (optional): The number of characters you want in a group whilst\n    encrypting.\n\n>>> encrypt_message('I am a boy')\n'BCDGBQY'\n\n>>> encrypt_message(' ')\n''\n\n>>> encrypt_message('   aide toi le c  iel      ta id  era    ',\n... 'FELIXMARDSTBCGHJKNOPQUVWYZ+',5)\n'FMJFVOISSUFTFPUFEQQC'"
  },
  {
    "function": "decrypt_message",
    "code": "def decrypt_message(\n    message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5\n) -> str:\n    \"\"\"\n    decrypt_message\n    ===============\n\n    Decrypts a trifid_cipher encrypted message.\n\n    PARAMETERS\n    ----------\n\n    *   `message`: The message you want to decrypt.\n    *   `alphabet` (optional): The characters used for the cipher.\n    *   `period` (optional): The number of characters used in grouping when it\n        was encrypted.\n\n    >>> decrypt_message('BCDGBQY')\n    'IAMABOY'\n\n    Decrypting with your own alphabet and period\n\n    >>> decrypt_message('FMJFVOISSUFTFPUFEQQC','FELIXMARDSTBCGHJKNOPQUVWYZ+',5)\n    'AIDETOILECIELTAIDERA'\n    \"\"\"\n    message, alphabet, character_to_number, number_to_character = __prepare(\n        message, alphabet\n    )\n\n    decrypted_numeric = []\n    for i in range(0, len(message), period):\n        a, b, c = __decrypt_part(message[i : i + period], character_to_number)\n\n        for j in range(len(a)):\n            decrypted_numeric.append(a[j] + b[j] + c[j])\n\n    return \"\".join(number_to_character[each] for each in decrypted_numeric)",
    "docstring": "decrypt_message\n===============\n\nDecrypts a trifid_cipher encrypted message.\n\nPARAMETERS\n----------\n\n*   `message`: The message you want to decrypt.\n*   `alphabet` (optional): The characters used for the cipher.\n*   `period` (optional): The number of characters used in grouping when it\n    was encrypted.\n\n>>> decrypt_message('BCDGBQY')\n'IAMABOY'\n\nDecrypting with your own alphabet and period\n\n>>> decrypt_message('FMJFVOISSUFTFPUFEQQC','FELIXMARDSTBCGHJKNOPQUVWYZ+',5)\n'AIDETOILECIELTAIDERA'"
  },
  {
    "function": "vernam_encrypt",
    "code": "def vernam_encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_encrypt(\"HELLO\",\"KEY\")\n    'RIJVS'\n    \"\"\"\n    ciphertext = \"\"\n    for i in range(len(plaintext)):\n        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65\n        while ct > 25:\n            ct = ct - 26\n        ciphertext += chr(65 + ct)\n    return ciphertext",
    "docstring": ">>> vernam_encrypt(\"HELLO\",\"KEY\")\n'RIJVS'"
  },
  {
    "function": "vernam_decrypt",
    "code": "def vernam_decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_decrypt(\"RIJVS\",\"KEY\")\n    'HELLO'\n    \"\"\"\n    decrypted_text = \"\"\n    for i in range(len(ciphertext)):\n        ct = ord(ciphertext[i]) - ord(key[i % len(key)])\n        while ct < 0:\n            ct = 26 + ct\n        decrypted_text += chr(65 + ct)\n    return decrypted_text",
    "docstring": ">>> vernam_decrypt(\"RIJVS\",\"KEY\")\n'HELLO'"
  },
  {
    "function": "encrypt_message",
    "code": "def encrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message('HDarji', 'This is Harshil Darji from Dharmaj.')\n    'Akij ra Odrjqqs Gaisq muod Mphumrs.'\n    \"\"\"\n    return translate_message(key, message, \"encrypt\")",
    "docstring": ">>> encrypt_message('HDarji', 'This is Harshil Darji from Dharmaj.')\n'Akij ra Odrjqqs Gaisq muod Mphumrs.'"
  },
  {
    "function": "decrypt_message",
    "code": "def decrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> decrypt_message('HDarji', 'Akij ra Odrjqqs Gaisq muod Mphumrs.')\n    'This is Harshil Darji from Dharmaj.'\n    \"\"\"\n    return translate_message(key, message, \"decrypt\")",
    "docstring": ">>> decrypt_message('HDarji', 'Akij ra Odrjqqs Gaisq muod Mphumrs.')\n'This is Harshil Darji from Dharmaj.'"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Get images list and annotations list from input dir.\n    Update new images and annotations.\n    Save images and annotations in output dir.\n    \"\"\"\n    img_paths, annos = get_dataset(LABEL_DIR, IMAGE_DIR)\n    print(\"Processing...\")\n    new_images, new_annos, paths = update_image_and_anno(img_paths, annos, FLIP_TYPE)\n\n    for index, image in enumerate(new_images):\n        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n        letter_code = random_chars(32)\n        file_name = paths[index].split(os.sep)[-1].rsplit(\".\", 1)[0]\n        file_root = f\"{OUTPUT_DIR}/{file_name}_FLIP_{letter_code}\"\n        cv2.imwrite(f\"{file_root}.jpg\", image, [cv2.IMWRITE_JPEG_QUALITY, 85])\n        print(f\"Success {index + 1}/{len(new_images)} with {file_name}\")\n        annos_list = []\n        for anno in new_annos[index]:\n            obj = f\"{anno[0]} {anno[1]} {anno[2]} {anno[3]} {anno[4]}\"\n            annos_list.append(obj)\n        with open(f\"{file_root}.txt\", \"w\") as outfile:\n            outfile.write(\"\\n\".join(line for line in annos_list))",
    "docstring": "Get images list and annotations list from input dir.\nUpdate new images and annotations.\nSave images and annotations in output dir."
  },
  {
    "function": "get_dataset",
    "code": "def get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:\n    \"\"\"\n    - label_dir <type: str>: Path to label include annotation of images\n    - img_dir <type: str>: Path to folder contain images\n    Return <type: list>: List of images path and labels\n    \"\"\"\n    img_paths = []\n    labels = []\n    for label_file in glob.glob(os.path.join(label_dir, \"*.txt\")):\n        label_name = label_file.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        with open(label_file) as in_file:\n            obj_lists = in_file.readlines()\n        img_path = os.path.join(img_dir, f\"{label_name}.jpg\")\n\n        boxes = []\n        for obj_list in obj_lists:\n            obj = obj_list.rstrip(\"\\n\").split(\" \")\n            boxes.append(\n                [\n                    int(obj[0]),\n                    float(obj[1]),\n                    float(obj[2]),\n                    float(obj[3]),\n                    float(obj[4]),\n                ]\n            )\n        if not boxes:\n            continue\n        img_paths.append(img_path)\n        labels.append(boxes)\n    return img_paths, labels",
    "docstring": "- label_dir <type: str>: Path to label include annotation of images\n- img_dir <type: str>: Path to folder contain images\nReturn <type: list>: List of images path and labels"
  },
  {
    "function": "update_image_and_anno",
    "code": "def update_image_and_anno(\n    img_list: list, anno_list: list, flip_type: int = 1\n) -> tuple[list, list, list]:\n    \"\"\"\n    - img_list <type: list>: list of all images\n    - anno_list <type: list>: list of all annotations of specific image\n    - flip_type <type: int>: 0 is vertical, 1 is horizontal\n    Return:\n        - new_imgs_list <type: narray>: image after resize\n        - new_annos_lists <type: list>: list of new annotation after scale\n        - path_list <type: list>: list the name of image file\n    \"\"\"\n    new_annos_lists = []\n    path_list = []\n    new_imgs_list = []\n    for idx in range(len(img_list)):\n        new_annos = []\n        path = img_list[idx]\n        path_list.append(path)\n        img_annos = anno_list[idx]\n        img = cv2.imread(path)\n        if flip_type == 1:\n            new_img = cv2.flip(img, flip_type)\n            for bbox in img_annos:\n                x_center_new = 1 - bbox[1]\n                new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])\n        elif flip_type == 0:\n            new_img = cv2.flip(img, flip_type)\n            for bbox in img_annos:\n                y_center_new = 1 - bbox[2]\n                new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])\n        new_annos_lists.append(new_annos)\n        new_imgs_list.append(new_img)\n    return new_imgs_list, new_annos_lists, path_list",
    "docstring": "- img_list <type: list>: list of all images\n- anno_list <type: list>: list of all annotations of specific image\n- flip_type <type: int>: 0 is vertical, 1 is horizontal\nReturn:\n    - new_imgs_list <type: narray>: image after resize\n    - new_annos_lists <type: list>: list of new annotation after scale\n    - path_list <type: list>: list the name of image file"
  },
  {
    "function": "random_chars",
    "code": "def random_chars(number_char: int = 32) -> str:\n    \"\"\"\n    Automatic generate random 32 characters.\n    Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n    >>> len(random_chars(32))\n    32\n    \"\"\"\n    assert number_char > 1, \"The number of character should greater than 1\"\n    letter_code = ascii_lowercase + digits\n    return \"\".join(random.choice(letter_code) for _ in range(number_char))",
    "docstring": "Automatic generate random 32 characters.\nGet random string code: '7b7ad245cdff75241935e4dd860f3bad'\n>>> len(random_chars(32))\n32"
  },
  {
    "function": "root_mean_square_error",
    "code": "def root_mean_square_error(original: np.ndarray, reference: np.ndarray) -> float:\n    \"\"\"Simple implementation of Root Mean Squared Error\n    for two N dimensional numpy arrays.\n\n    Examples:\n        >>> root_mean_square_error(np.array([1, 2, 3]), np.array([1, 2, 3]))\n        0.0\n        >>> root_mean_square_error(np.array([1, 2, 3]), np.array([2, 2, 2]))\n        0.816496580927726\n        >>> root_mean_square_error(np.array([1, 2, 3]), np.array([6, 4, 2]))\n        3.1622776601683795\n    \"\"\"\n    return float(np.sqrt(((original - reference) ** 2).mean()))",
    "docstring": "Simple implementation of Root Mean Squared Error\nfor two N dimensional numpy arrays.\n\nExamples:\n    >>> root_mean_square_error(np.array([1, 2, 3]), np.array([1, 2, 3]))\n    0.0\n    >>> root_mean_square_error(np.array([1, 2, 3]), np.array([2, 2, 2]))\n    0.816496580927726\n    >>> root_mean_square_error(np.array([1, 2, 3]), np.array([6, 4, 2]))\n    3.1622776601683795"
  },
  {
    "function": "normalize_image",
    "code": "def normalize_image(\n    image: np.ndarray, cap: float = 255.0, data_type: np.dtype = np.uint8\n) -> np.ndarray:\n    \"\"\"\n    Normalizes image in Numpy 2D array format, between ranges 0-cap,\n    as to fit uint8 type.\n\n    Args:\n        image: 2D numpy array representing image as matrix, with values in any range\n        cap: Maximum cap amount for normalization\n        data_type: numpy data type to set output variable to\n    Returns:\n        return 2D numpy array of type uint8, corresponding to limited range matrix\n\n    Examples:\n        >>> normalize_image(np.array([[1, 2, 3], [4, 5, 10]]),\n        ...                 cap=1.0, data_type=np.float64)\n        array([[0.        , 0.11111111, 0.22222222],\n               [0.33333333, 0.44444444, 1.        ]])\n        >>> normalize_image(np.array([[4, 4, 3], [1, 7, 2]]))\n        array([[127, 127,  85],\n               [  0, 255,  42]], dtype=uint8)\n    \"\"\"\n    normalized = (image - np.min(image)) / (np.max(image) - np.min(image)) * cap\n    return normalized.astype(data_type)",
    "docstring": "Normalizes image in Numpy 2D array format, between ranges 0-cap,\nas to fit uint8 type.\n\nArgs:\n    image: 2D numpy array representing image as matrix, with values in any range\n    cap: Maximum cap amount for normalization\n    data_type: numpy data type to set output variable to\nReturns:\n    return 2D numpy array of type uint8, corresponding to limited range matrix\n\nExamples:\n    >>> normalize_image(np.array([[1, 2, 3], [4, 5, 10]]),\n    ...                 cap=1.0, data_type=np.float64)\n    array([[0.        , 0.11111111, 0.22222222],\n           [0.33333333, 0.44444444, 1.        ]])\n    >>> normalize_image(np.array([[4, 4, 3], [1, 7, 2]]))\n    array([[127, 127,  85],\n           [  0, 255,  42]], dtype=uint8)"
  },
  {
    "function": "normalize_array",
    "code": "def normalize_array(array: np.ndarray, cap: float = 1) -> np.ndarray:\n    \"\"\"Normalizes a 1D array, between ranges 0-cap.\n\n    Args:\n        array: List containing values to be normalized between cap range.\n        cap: Maximum cap amount for normalization.\n    Returns:\n        return 1D numpy array, corresponding to limited range array\n\n    Examples:\n        >>> normalize_array(np.array([2, 3, 5, 7]))\n        array([0. , 0.2, 0.6, 1. ])\n        >>> normalize_array(np.array([[5], [7], [11], [13]]))\n        array([[0.  ],\n               [0.25],\n               [0.75],\n               [1.  ]])\n    \"\"\"\n    diff = np.max(array) - np.min(array)\n    return (array - np.min(array)) / (1 if diff == 0 else diff) * cap",
    "docstring": "Normalizes a 1D array, between ranges 0-cap.\n\nArgs:\n    array: List containing values to be normalized between cap range.\n    cap: Maximum cap amount for normalization.\nReturns:\n    return 1D numpy array, corresponding to limited range array\n\nExamples:\n    >>> normalize_array(np.array([2, 3, 5, 7]))\n    array([0. , 0.2, 0.6, 1. ])\n    >>> normalize_array(np.array([[5], [7], [11], [13]]))\n    array([[0.  ],\n           [0.25],\n           [0.75],\n           [1.  ]])"
  },
  {
    "function": "grayscale",
    "code": "def grayscale(image: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Uses luminance weights to transform RGB channel to greyscale, by\n    taking the dot product between the channel and the weights.\n\n    Example:\n        >>> grayscale(np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                     [[56,  56,  56], [128, 255, 107]]]))\n        array([[158,  97],\n               [ 56, 200]], dtype=uint8)\n    \"\"\"\n    return np.dot(image[:, :, 0:3], [0.299, 0.587, 0.114]).astype(np.uint8)",
    "docstring": "Uses luminance weights to transform RGB channel to greyscale, by\ntaking the dot product between the channel and the weights.\n\nExample:\n    >>> grayscale(np.array([[[108, 201, 72], [255, 11,  127]],\n    ...                     [[56,  56,  56], [128, 255, 107]]]))\n    array([[158,  97],\n           [ 56, 200]], dtype=uint8)"
  },
  {
    "function": "binarize",
    "code": "def binarize(image: np.ndarray, threshold: float = 127.0) -> np.ndarray:\n    \"\"\"\n    Binarizes a grayscale image based on a given threshold value,\n    setting values to 1 or 0 accordingly.\n\n    Examples:\n        >>> binarize(np.array([[128, 255], [101, 156]]))\n        array([[1, 1],\n               [0, 1]])\n        >>> binarize(np.array([[0.07, 1], [0.51, 0.3]]), threshold=0.5)\n        array([[0, 1],\n               [1, 0]])\n    \"\"\"\n    return np.where(image > threshold, 1, 0)",
    "docstring": "Binarizes a grayscale image based on a given threshold value,\nsetting values to 1 or 0 accordingly.\n\nExamples:\n    >>> binarize(np.array([[128, 255], [101, 156]]))\n    array([[1, 1],\n           [0, 1]])\n    >>> binarize(np.array([[0.07, 1], [0.51, 0.3]]), threshold=0.5)\n    array([[0, 1],\n           [1, 0]])"
  },
  {
    "function": "transform",
    "code": "def transform(\n    image: np.ndarray, kind: str, kernel: np.ndarray | None = None\n) -> np.ndarray:\n    \"\"\"\n    Simple image transformation using one of two available filter functions:\n    Erosion and Dilation.\n\n    Args:\n        image: binarized input image, onto which to apply transformation\n        kind: Can be either 'erosion', in which case the :func:np.max\n              function is called, or 'dilation', when :func:np.min is used instead.\n        kernel: n x n kernel with shape < :attr:image.shape,\n              to be used when applying convolution to original image\n\n    Returns:\n        returns a numpy array with same shape as input image,\n        corresponding to applied binary transformation.\n\n    Examples:\n        >>> img = np.array([[1, 0.5], [0.2, 0.7]])\n        >>> img = binarize(img, threshold=0.5)\n        >>> transform(img, 'erosion')\n        array([[1, 1],\n               [1, 1]], dtype=uint8)\n        >>> transform(img, 'dilation')\n        array([[0, 0],\n               [0, 0]], dtype=uint8)\n    \"\"\"\n    if kernel is None:\n        kernel = np.ones((3, 3))\n\n    if kind == \"erosion\":\n        constant = 1\n        apply = np.max\n    else:\n        constant = 0\n        apply = np.min\n\n    center_x, center_y = (x // 2 for x in kernel.shape)\n\n    # Use padded image when applying convolution\n    # to not go out of bounds of the original the image\n    transformed = np.zeros(image.shape, dtype=np.uint8)\n    padded = np.pad(image, 1, \"constant\", constant_values=constant)\n\n    for x in range(center_x, padded.shape[0] - center_x):\n        for y in range(center_y, padded.shape[1] - center_y):\n            center = padded[\n                x - center_x : x + center_x + 1, y - center_y : y + center_y + 1\n            ]\n            # Apply transformation method to the centered section of the image\n            transformed[x - center_x, y - center_y] = apply(center[kernel == 1])\n\n    return transformed",
    "docstring": "Simple image transformation using one of two available filter functions:\nErosion and Dilation.\n\nArgs:\n    image: binarized input image, onto which to apply transformation\n    kind: Can be either 'erosion', in which case the :func:np.max\n          function is called, or 'dilation', when :func:np.min is used instead.\n    kernel: n x n kernel with shape < :attr:image.shape,\n          to be used when applying convolution to original image\n\nReturns:\n    returns a numpy array with same shape as input image,\n    corresponding to applied binary transformation.\n\nExamples:\n    >>> img = np.array([[1, 0.5], [0.2, 0.7]])\n    >>> img = binarize(img, threshold=0.5)\n    >>> transform(img, 'erosion')\n    array([[1, 1],\n           [1, 1]], dtype=uint8)\n    >>> transform(img, 'dilation')\n    array([[0, 0],\n           [0, 0]], dtype=uint8)"
  },
  {
    "function": "opening_filter",
    "code": "def opening_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:\n    \"\"\"\n    Opening filter, defined as the sequence of\n    erosion and then a dilation filter on the same image.\n\n    Examples:\n        >>> img = np.array([[1, 0.5], [0.2, 0.7]])\n        >>> img = binarize(img, threshold=0.5)\n        >>> opening_filter(img)\n        array([[1, 1],\n               [1, 1]], dtype=uint8)\n    \"\"\"\n    if kernel is None:\n        np.ones((3, 3))\n\n    return transform(transform(image, \"dilation\", kernel), \"erosion\", kernel)",
    "docstring": "Opening filter, defined as the sequence of\nerosion and then a dilation filter on the same image.\n\nExamples:\n    >>> img = np.array([[1, 0.5], [0.2, 0.7]])\n    >>> img = binarize(img, threshold=0.5)\n    >>> opening_filter(img)\n    array([[1, 1],\n           [1, 1]], dtype=uint8)"
  },
  {
    "function": "closing_filter",
    "code": "def closing_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:\n    \"\"\"\n    Opening filter, defined as the sequence of\n    dilation and then erosion filter on the same image.\n\n    Examples:\n        >>> img = np.array([[1, 0.5], [0.2, 0.7]])\n        >>> img = binarize(img, threshold=0.5)\n        >>> closing_filter(img)\n        array([[0, 0],\n               [0, 0]], dtype=uint8)\n    \"\"\"\n    if kernel is None:\n        kernel = np.ones((3, 3))\n    return transform(transform(image, \"erosion\", kernel), \"dilation\", kernel)",
    "docstring": "Opening filter, defined as the sequence of\ndilation and then erosion filter on the same image.\n\nExamples:\n    >>> img = np.array([[1, 0.5], [0.2, 0.7]])\n    >>> img = binarize(img, threshold=0.5)\n    >>> closing_filter(img)\n    array([[0, 0],\n           [0, 0]], dtype=uint8)"
  },
  {
    "function": "binary_mask",
    "code": "def binary_mask(\n    image_gray: np.ndarray, image_map: np.ndarray\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Apply binary mask, or thresholding based\n    on bit mask value (mapping mask is binary).\n\n    Returns the mapped true value mask and its complementary false value mask.\n\n    Example:\n        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                 [[56,  56,  56], [128, 255, 107]]])\n        >>> gray = grayscale(img)\n        >>> binary = binarize(gray)\n        >>> morphological = opening_filter(binary)\n        >>> binary_mask(gray, morphological)\n        (array([[1, 1],\n               [1, 1]], dtype=uint8), array([[158,  97],\n               [ 56, 200]], dtype=uint8))\n    \"\"\"\n    true_mask, false_mask = image_gray.copy(), image_gray.copy()\n    true_mask[image_map == 1] = 1\n    false_mask[image_map == 0] = 0\n\n    return true_mask, false_mask",
    "docstring": "Apply binary mask, or thresholding based\non bit mask value (mapping mask is binary).\n\nReturns the mapped true value mask and its complementary false value mask.\n\nExample:\n    >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n    ...                 [[56,  56,  56], [128, 255, 107]]])\n    >>> gray = grayscale(img)\n    >>> binary = binarize(gray)\n    >>> morphological = opening_filter(binary)\n    >>> binary_mask(gray, morphological)\n    (array([[1, 1],\n           [1, 1]], dtype=uint8), array([[158,  97],\n           [ 56, 200]], dtype=uint8))"
  },
  {
    "function": "matrix_concurrency",
    "code": "def matrix_concurrency(image: np.ndarray, coordinate: tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Calculate sample co-occurrence matrix based on input image\n    as well as selected coordinates on image.\n\n    Implementation is made using basic iteration,\n    as function to be performed (np.max) is non-linear and therefore\n    not callable on the frequency domain.\n\n    Example:\n        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                 [[56,  56,  56], [128, 255, 107]]])\n        >>> gray = grayscale(img)\n        >>> binary = binarize(gray)\n        >>> morphological = opening_filter(binary)\n        >>> mask_1 = binary_mask(gray, morphological)[0]\n        >>> matrix_concurrency(mask_1, (0, 1))\n        array([[0., 0.],\n               [0., 0.]])\n    \"\"\"\n    matrix = np.zeros([np.max(image) + 1, np.max(image) + 1])\n\n    offset_x, offset_y = coordinate\n\n    for x in range(1, image.shape[0] - 1):\n        for y in range(1, image.shape[1] - 1):\n            base_pixel = image[x, y]\n            offset_pixel = image[x + offset_x, y + offset_y]\n\n            matrix[base_pixel, offset_pixel] += 1\n    matrix_sum = np.sum(matrix)\n    return matrix / (1 if matrix_sum == 0 else matrix_sum)",
    "docstring": "Calculate sample co-occurrence matrix based on input image\nas well as selected coordinates on image.\n\nImplementation is made using basic iteration,\nas function to be performed (np.max) is non-linear and therefore\nnot callable on the frequency domain.\n\nExample:\n    >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n    ...                 [[56,  56,  56], [128, 255, 107]]])\n    >>> gray = grayscale(img)\n    >>> binary = binarize(gray)\n    >>> morphological = opening_filter(binary)\n    >>> mask_1 = binary_mask(gray, morphological)[0]\n    >>> matrix_concurrency(mask_1, (0, 1))\n    array([[0., 0.],\n           [0., 0.]])"
  },
  {
    "function": "haralick_descriptors",
    "code": "def haralick_descriptors(matrix: np.ndarray) -> list[float]:\n    \"\"\"Calculates all 8 Haralick descriptors based on co-occurrence input matrix.\n    All descriptors are as follows:\n    Maximum probability, Inverse Difference, Homogeneity, Entropy,\n    Energy, Dissimilarity, Contrast and Correlation\n\n    Args:\n        matrix: Co-occurrence matrix to use as base for calculating descriptors.\n\n    Returns:\n        Reverse ordered list of resulting descriptors\n\n    Example:\n        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                 [[56,  56,  56], [128, 255, 107]]])\n        >>> gray = grayscale(img)\n        >>> binary = binarize(gray)\n        >>> morphological = opening_filter(binary)\n        >>> mask_1 = binary_mask(gray, morphological)[0]\n        >>> concurrency = matrix_concurrency(mask_1, (0, 1))\n        >>> [float(f) for f in haralick_descriptors(concurrency)]\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    \"\"\"\n    # Function np.indices could be used for bigger input types,\n    # but np.ogrid works just fine\n    i, j = np.ogrid[0 : matrix.shape[0], 0 : matrix.shape[1]]  # np.indices()\n\n    # Pre-calculate frequent multiplication and subtraction\n    prod = np.multiply(i, j)\n    sub = np.subtract(i, j)\n\n    # Calculate numerical value of Maximum Probability\n    maximum_prob = np.max(matrix)\n    # Using the definition for each descriptor individually to calculate its matrix\n    correlation = prod * matrix\n    energy = np.power(matrix, 2)\n    contrast = matrix * np.power(sub, 2)\n\n    dissimilarity = matrix * np.abs(sub)\n    inverse_difference = matrix / (1 + np.abs(sub))\n    homogeneity = matrix / (1 + np.power(sub, 2))\n    entropy = -(matrix[matrix > 0] * np.log(matrix[matrix > 0]))\n\n    # Sum values for descriptors ranging from the first one to the last,\n    # as all are their respective origin matrix and not the resulting value yet.\n    return [\n        maximum_prob,\n        correlation.sum(),\n        energy.sum(),\n        contrast.sum(),\n        dissimilarity.sum(),\n        inverse_difference.sum(),\n        homogeneity.sum(),\n        entropy.sum(),\n    ]",
    "docstring": "Calculates all 8 Haralick descriptors based on co-occurrence input matrix.\nAll descriptors are as follows:\nMaximum probability, Inverse Difference, Homogeneity, Entropy,\nEnergy, Dissimilarity, Contrast and Correlation\n\nArgs:\n    matrix: Co-occurrence matrix to use as base for calculating descriptors.\n\nReturns:\n    Reverse ordered list of resulting descriptors\n\nExample:\n    >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n    ...                 [[56,  56,  56], [128, 255, 107]]])\n    >>> gray = grayscale(img)\n    >>> binary = binarize(gray)\n    >>> morphological = opening_filter(binary)\n    >>> mask_1 = binary_mask(gray, morphological)[0]\n    >>> concurrency = matrix_concurrency(mask_1, (0, 1))\n    >>> [float(f) for f in haralick_descriptors(concurrency)]\n    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]"
  },
  {
    "function": "get_descriptors",
    "code": "def get_descriptors(\n    masks: tuple[np.ndarray, np.ndarray], coordinate: tuple[int, int]\n) -> np.ndarray:\n    \"\"\"\n    Calculate all Haralick descriptors for a sequence of\n    different co-occurrence matrices, given input masks and coordinates.\n\n    Example:\n        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                 [[56,  56,  56], [128, 255, 107]]])\n        >>> gray = grayscale(img)\n        >>> binary = binarize(gray)\n        >>> morphological = opening_filter(binary)\n        >>> get_descriptors(binary_mask(gray, morphological), (0, 1))\n        array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])\n    \"\"\"\n    descriptors = np.array(\n        [haralick_descriptors(matrix_concurrency(mask, coordinate)) for mask in masks]\n    )\n\n    # Concatenate each individual descriptor into\n    # one single list containing sequence of descriptors\n    return np.concatenate(descriptors, axis=None)",
    "docstring": "Calculate all Haralick descriptors for a sequence of\ndifferent co-occurrence matrices, given input masks and coordinates.\n\nExample:\n    >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n    ...                 [[56,  56,  56], [128, 255, 107]]])\n    >>> gray = grayscale(img)\n    >>> binary = binarize(gray)\n    >>> morphological = opening_filter(binary)\n    >>> get_descriptors(binary_mask(gray, morphological), (0, 1))\n    array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])"
  },
  {
    "function": "euclidean",
    "code": "def euclidean(point_1: np.ndarray, point_2: np.ndarray) -> float:\n    \"\"\"\n    Simple method for calculating the euclidean distance between two points,\n    with type np.ndarray.\n\n    Example:\n        >>> a = np.array([1, 0, -2])\n        >>> b = np.array([2, -1, 1])\n        >>> euclidean(a, b)\n        3.3166247903554\n    \"\"\"\n    return float(np.sqrt(np.sum(np.square(point_1 - point_2))))",
    "docstring": "Simple method for calculating the euclidean distance between two points,\nwith type np.ndarray.\n\nExample:\n    >>> a = np.array([1, 0, -2])\n    >>> b = np.array([2, -1, 1])\n    >>> euclidean(a, b)\n    3.3166247903554"
  },
  {
    "function": "get_distances",
    "code": "def get_distances(descriptors: np.ndarray, base: int) -> list[tuple[int, float]]:\n    \"\"\"\n    Calculate all Euclidean distances between a selected base descriptor\n    and all other Haralick descriptors\n    The resulting comparison is return in decreasing order,\n    showing which descriptor is the most similar to the selected base.\n\n    Args:\n        descriptors: Haralick descriptors to compare with base index\n        base: Haralick descriptor index to use as base when calculating respective\n        euclidean distance to other descriptors.\n\n    Returns:\n        Ordered distances between descriptors\n\n    Example:\n        >>> index = 1\n        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                 [[56,  56,  56], [128, 255, 107]]])\n        >>> gray = grayscale(img)\n        >>> binary = binarize(gray)\n        >>> morphological = opening_filter(binary)\n        >>> get_distances(get_descriptors(\n        ...                 binary_mask(gray, morphological), (0, 1)),\n        ...               index)\n        [(0, 0.0), (1, 0.0), (2, 0.0), (3, 0.0), (4, 0.0), (5, 0.0), \\\n(6, 0.0), (7, 0.0), (8, 0.0), (9, 0.0), (10, 0.0), (11, 0.0), (12, 0.0), \\\n(13, 0.0), (14, 0.0), (15, 0.0)]\n    \"\"\"\n    distances = np.array(\n        [euclidean(descriptor, descriptors[base]) for descriptor in descriptors]\n    )\n    # Normalize distances between range [0, 1]\n    normalized_distances: list[float] = normalize_array(distances, 1).tolist()\n    enum_distances = list(enumerate(normalized_distances))\n    enum_distances.sort(key=lambda tup: tup[1], reverse=True)\n    return enum_distances",
    "docstring": "Calculate all Euclidean distances between a selected base descriptor\nand all other Haralick descriptors\nThe resulting comparison is return in decreasing order,\nshowing which descriptor is the most similar to the selected base.\n\nArgs:\n    descriptors: Haralick descriptors to compare with base index\n    base: Haralick descriptor index to use as base when calculating respective\n    euclidean distance to other descriptors.\n\nReturns:\n    Ordered distances between descriptors\n\nExample:\n    >>> index = 1\n    >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n    ...                 [[56,  56,  56], [128, 255, 107]]])\n    >>> gray = grayscale(img)\n    >>> binary = binarize(gray)\n    >>> morphological = opening_filter(binary)\n    >>> get_distances(get_descriptors(\n    ...                 binary_mask(gray, morphological), (0, 1)),\n    ...               index)\n    [(0, 0.0), (1, 0.0), (2, 0.0), (3, 0.0), (4, 0.0), (5, 0.0), (6, 0.0), (7, 0.0), (8, 0.0), (9, 0.0), (10, 0.0), (11, 0.0), (12, 0.0), (13, 0.0), (14, 0.0), (15, 0.0)]"
  },
  {
    "function": "warp",
    "code": "def warp(\n    image: np.ndarray, horizontal_flow: np.ndarray, vertical_flow: np.ndarray\n) -> np.ndarray:\n    \"\"\"\n    Warps the pixels of an image into a new image using the horizontal and vertical\n    flows.\n    Pixels that are warped from an invalid location are set to 0.\n\n    Parameters:\n        image: Grayscale image\n        horizontal_flow: Horizontal flow\n        vertical_flow: Vertical flow\n\n    Returns: Warped image\n\n    >>> warp(np.array([[0, 1, 2], [0, 3, 0], [2, 2, 2]]), \\\n    np.array([[0, 1, -1], [-1, 0, 0], [1, 1, 1]]), \\\n    np.array([[0, 0, 0], [0, 1, 0], [0, 0, 1]]))\n    array([[0, 0, 0],\n           [3, 1, 0],\n           [0, 2, 3]])\n    \"\"\"\n    flow = np.stack((horizontal_flow, vertical_flow), 2)\n\n    # Create a grid of all pixel coordinates and subtract the flow to get the\n    # target pixels coordinates\n    grid = np.stack(\n        np.meshgrid(np.arange(0, image.shape[1]), np.arange(0, image.shape[0])), 2\n    )\n    grid = np.round(grid - flow).astype(np.int32)\n\n    # Find the locations outside of the original image\n    invalid = (grid < 0) | (grid >= np.array([image.shape[1], image.shape[0]]))\n    grid[invalid] = 0\n\n    warped = image[grid[:, :, 1], grid[:, :, 0]]\n\n    # Set pixels at invalid locations to 0\n    warped[invalid[:, :, 0] | invalid[:, :, 1]] = 0\n\n    return warped",
    "docstring": "Warps the pixels of an image into a new image using the horizontal and vertical\nflows.\nPixels that are warped from an invalid location are set to 0.\n\nParameters:\n    image: Grayscale image\n    horizontal_flow: Horizontal flow\n    vertical_flow: Vertical flow\n\nReturns: Warped image\n\n>>> warp(np.array([[0, 1, 2], [0, 3, 0], [2, 2, 2]]),     np.array([[0, 1, -1], [-1, 0, 0], [1, 1, 1]]),     np.array([[0, 0, 0], [0, 1, 0], [0, 0, 1]]))\narray([[0, 0, 0],\n       [3, 1, 0],\n       [0, 2, 3]])"
  },
  {
    "function": "horn_schunck",
    "code": "def horn_schunck(\n    image0: np.ndarray,\n    image1: np.ndarray,\n    num_iter: SupportsIndex,\n    alpha: float | None = None,\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    This function performs the Horn-Schunck algorithm and returns the estimated\n    optical flow. It is assumed that the input images are grayscale and\n    normalized to be in [0, 1].\n\n    Parameters:\n        image0: First image of the sequence\n        image1: Second image of the sequence\n        alpha: Regularization constant\n        num_iter: Number of iterations performed\n\n    Returns: estimated horizontal & vertical flow\n\n    >>> np.round(horn_schunck(np.array([[0, 0, 2], [0, 0, 2]]), \\\n    np.array([[0, 2, 0], [0, 2, 0]]), alpha=0.1, num_iter=110)).\\\n    astype(np.int32)\n    array([[[ 0, -1, -1],\n            [ 0, -1, -1]],\n    <BLANKLINE>\n           [[ 0,  0,  0],\n            [ 0,  0,  0]]], dtype=int32)\n    \"\"\"\n    if alpha is None:\n        alpha = 0.1\n\n    # Initialize flow\n    horizontal_flow = np.zeros_like(image0)\n    vertical_flow = np.zeros_like(image0)\n\n    # Prepare kernels for the calculation of the derivatives and the average velocity\n    kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25\n    kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25\n    kernel_t = np.array([[1, 1], [1, 1]]) * 0.25\n    kernel_laplacian = np.array(\n        [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]\n    )\n\n    # Iteratively refine the flow\n    for _ in range(num_iter):\n        warped_image = warp(image0, horizontal_flow, vertical_flow)\n        derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)\n        derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)\n        derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)\n\n        avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)\n        avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)\n\n        # This updates the flow as proposed in the paper (Step 12)\n        update = (\n            derivative_x * avg_horizontal_velocity\n            + derivative_y * avg_vertical_velocity\n            + derivative_t\n        )\n        update = update / (alpha**2 + derivative_x**2 + derivative_y**2)\n\n        horizontal_flow = avg_horizontal_velocity - derivative_x * update\n        vertical_flow = avg_vertical_velocity - derivative_y * update\n\n    return horizontal_flow, vertical_flow",
    "docstring": "This function performs the Horn-Schunck algorithm and returns the estimated\noptical flow. It is assumed that the input images are grayscale and\nnormalized to be in [0, 1].\n\nParameters:\n    image0: First image of the sequence\n    image1: Second image of the sequence\n    alpha: Regularization constant\n    num_iter: Number of iterations performed\n\nReturns: estimated horizontal & vertical flow\n\n>>> np.round(horn_schunck(np.array([[0, 0, 2], [0, 0, 2]]),     np.array([[0, 2, 0], [0, 2, 0]]), alpha=0.1, num_iter=110)).    astype(np.int32)\narray([[[ 0, -1, -1],\n        [ 0, -1, -1]],\n<BLANKLINE>\n       [[ 0,  0,  0],\n        [ 0,  0,  0]]], dtype=int32)"
  },
  {
    "function": "segment_image",
    "code": "def segment_image(image: np.ndarray, thresholds: list[int]) -> np.ndarray:\n    \"\"\"\n    Performs image segmentation based on intensity thresholds.\n\n    Args:\n        image: Input grayscale image as a 2D array.\n        thresholds: Intensity thresholds to define segments.\n\n    Returns:\n        A labeled 2D array where each region corresponds to a threshold range.\n\n    Example:\n        >>> img = np.array([[80, 120, 180], [40, 90, 150], [20, 60, 100]])\n        >>> segment_image(img, [50, 100, 150])\n        array([[1, 2, 3],\n               [0, 1, 2],\n               [0, 1, 1]], dtype=int32)\n    \"\"\"\n    # Initialize segmented array with zeros\n    segmented = np.zeros_like(image, dtype=np.int32)\n\n    # Assign labels based on thresholds\n    for i, threshold in enumerate(thresholds):\n        segmented[image > threshold] = i + 1\n\n    return segmented",
    "docstring": "Performs image segmentation based on intensity thresholds.\n\nArgs:\n    image: Input grayscale image as a 2D array.\n    thresholds: Intensity thresholds to define segments.\n\nReturns:\n    A labeled 2D array where each region corresponds to a threshold range.\n\nExample:\n    >>> img = np.array([[80, 120, 180], [40, 90, 150], [20, 60, 100]])\n    >>> segment_image(img, [50, 100, 150])\n    array([[1, 2, 3],\n           [0, 1, 2],\n           [0, 1, 1]], dtype=int32)"
  },
  {
    "function": "mean_threshold",
    "code": "def mean_threshold(image: Image) -> Image:\n    \"\"\"\n    image: is a grayscale PIL image object\n    \"\"\"\n    height, width = image.size\n    mean = 0\n    pixels = image.load()\n    for i in range(width):\n        for j in range(height):\n            pixel = pixels[j, i]\n            mean += pixel\n    mean //= width * height\n\n    for j in range(width):\n        for i in range(height):\n            pixels[i, j] = 255 if pixels[i, j] > mean else 0\n    return image",
    "docstring": "image: is a grayscale PIL image object"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Get images list and annotations list from input dir.\n    Update new images and annotations.\n    Save images and annotations in output dir.\n    \"\"\"\n    img_paths, annos = get_dataset(LABEL_DIR, IMG_DIR)\n    for index in range(NUMBER_IMAGES):\n        idxs = random.sample(range(len(annos)), 4)\n        new_image, new_annos, path = update_image_and_anno(\n            img_paths,\n            annos,\n            idxs,\n            OUTPUT_SIZE,\n            SCALE_RANGE,\n            filter_scale=FILTER_TINY_SCALE,\n        )\n\n        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n        letter_code = random_chars(32)\n        file_name = path.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        file_root = f\"{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}\"\n        cv2.imwrite(f\"{file_root}.jpg\", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])\n        print(f\"Succeeded {index + 1}/{NUMBER_IMAGES} with {file_name}\")\n        annos_list = []\n        for anno in new_annos:\n            width = anno[3] - anno[1]\n            height = anno[4] - anno[2]\n            x_center = anno[1] + width / 2\n            y_center = anno[2] + height / 2\n            obj = f\"{anno[0]} {x_center} {y_center} {width} {height}\"\n            annos_list.append(obj)\n        with open(f\"{file_root}.txt\", \"w\") as outfile:\n            outfile.write(\"\\n\".join(line for line in annos_list))",
    "docstring": "Get images list and annotations list from input dir.\nUpdate new images and annotations.\nSave images and annotations in output dir."
  },
  {
    "function": "get_dataset",
    "code": "def get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:\n    \"\"\"\n    - label_dir <type: str>: Path to label include annotation of images\n    - img_dir <type: str>: Path to folder contain images\n    Return <type: list>: List of images path and labels\n    \"\"\"\n    img_paths = []\n    labels = []\n    for label_file in glob.glob(os.path.join(label_dir, \"*.txt\")):\n        label_name = label_file.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        with open(label_file) as in_file:\n            obj_lists = in_file.readlines()\n        img_path = os.path.join(img_dir, f\"{label_name}.jpg\")\n\n        boxes = []\n        for obj_list in obj_lists:\n            obj = obj_list.rstrip(\"\\n\").split(\" \")\n            xmin = float(obj[1]) - float(obj[3]) / 2\n            ymin = float(obj[2]) - float(obj[4]) / 2\n            xmax = float(obj[1]) + float(obj[3]) / 2\n            ymax = float(obj[2]) + float(obj[4]) / 2\n\n            boxes.append([int(obj[0]), xmin, ymin, xmax, ymax])\n        if not boxes:\n            continue\n        img_paths.append(img_path)\n        labels.append(boxes)\n    return img_paths, labels",
    "docstring": "- label_dir <type: str>: Path to label include annotation of images\n- img_dir <type: str>: Path to folder contain images\nReturn <type: list>: List of images path and labels"
  },
  {
    "function": "update_image_and_anno",
    "code": "def update_image_and_anno(\n    all_img_list: list,\n    all_annos: list,\n    idxs: list[int],\n    output_size: tuple[int, int],\n    scale_range: tuple[float, float],\n    filter_scale: float = 0.0,\n) -> tuple[list, list, str]:\n    \"\"\"\n    - all_img_list <type: list>: list of all images\n    - all_annos <type: list>: list of all annotations of specific image\n    - idxs <type: list>: index of image in list\n    - output_size <type: tuple>: size of output image (Height, Width)\n    - scale_range <type: tuple>: range of scale image\n    - filter_scale <type: float>: the condition of downscale image and bounding box\n    Return:\n        - output_img <type: narray>: image after resize\n        - new_anno <type: list>: list of new annotation after scale\n        - path[0] <type: string>: get the name of image file\n    \"\"\"\n    output_img = np.zeros([output_size[0], output_size[1], 3], dtype=np.uint8)\n    scale_x = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])\n    scale_y = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])\n    divid_point_x = int(scale_x * output_size[1])\n    divid_point_y = int(scale_y * output_size[0])\n\n    new_anno = []\n    path_list = []\n    for i, index in enumerate(idxs):\n        path = all_img_list[index]\n        path_list.append(path)\n        img_annos = all_annos[index]\n        img = cv2.imread(path)\n        if i == 0:  # top-left\n            img = cv2.resize(img, (divid_point_x, divid_point_y))\n            output_img[:divid_point_y, :divid_point_x, :] = img\n            for bbox in img_annos:\n                xmin = bbox[1] * scale_x\n                ymin = bbox[2] * scale_y\n                xmax = bbox[3] * scale_x\n                ymax = bbox[4] * scale_y\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\n        elif i == 1:  # top-right\n            img = cv2.resize(img, (output_size[1] - divid_point_x, divid_point_y))\n            output_img[:divid_point_y, divid_point_x : output_size[1], :] = img\n            for bbox in img_annos:\n                xmin = scale_x + bbox[1] * (1 - scale_x)\n                ymin = bbox[2] * scale_y\n                xmax = scale_x + bbox[3] * (1 - scale_x)\n                ymax = bbox[4] * scale_y\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\n        elif i == 2:  # bottom-left\n            img = cv2.resize(img, (divid_point_x, output_size[0] - divid_point_y))\n            output_img[divid_point_y : output_size[0], :divid_point_x, :] = img\n            for bbox in img_annos:\n                xmin = bbox[1] * scale_x\n                ymin = scale_y + bbox[2] * (1 - scale_y)\n                xmax = bbox[3] * scale_x\n                ymax = scale_y + bbox[4] * (1 - scale_y)\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\n        else:  # bottom-right\n            img = cv2.resize(\n                img, (output_size[1] - divid_point_x, output_size[0] - divid_point_y)\n            )\n            output_img[\n                divid_point_y : output_size[0], divid_point_x : output_size[1], :\n            ] = img\n            for bbox in img_annos:\n                xmin = scale_x + bbox[1] * (1 - scale_x)\n                ymin = scale_y + bbox[2] * (1 - scale_y)\n                xmax = scale_x + bbox[3] * (1 - scale_x)\n                ymax = scale_y + bbox[4] * (1 - scale_y)\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\n\n    # Remove bounding box small than scale of filter\n    if filter_scale > 0:\n        new_anno = [\n            anno\n            for anno in new_anno\n            if filter_scale < (anno[3] - anno[1]) and filter_scale < (anno[4] - anno[2])\n        ]\n\n    return output_img, new_anno, path_list[0]",
    "docstring": "- all_img_list <type: list>: list of all images\n- all_annos <type: list>: list of all annotations of specific image\n- idxs <type: list>: index of image in list\n- output_size <type: tuple>: size of output image (Height, Width)\n- scale_range <type: tuple>: range of scale image\n- filter_scale <type: float>: the condition of downscale image and bounding box\nReturn:\n    - output_img <type: narray>: image after resize\n    - new_anno <type: list>: list of new annotation after scale\n    - path[0] <type: string>: get the name of image file"
  },
  {
    "function": "random_chars",
    "code": "def random_chars(number_char: int) -> str:\n    \"\"\"\n    Automatic generate random 32 characters.\n    Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n    >>> len(random_chars(32))\n    32\n    \"\"\"\n    assert number_char > 1, \"The number of character should greater than 1\"\n    letter_code = ascii_lowercase + digits\n    return \"\".join(random.choice(letter_code) for _ in range(number_char))",
    "docstring": "Automatic generate random 32 characters.\nGet random string code: '7b7ad245cdff75241935e4dd860f3bad'\n>>> len(random_chars(32))\n32"
  },
  {
    "function": "maxpooling",
    "code": "def maxpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:\n    \"\"\"\n    This function is used to perform maxpooling on the input array of 2D matrix(image)\n    Args:\n        arr: numpy array\n        size: size of pooling matrix\n        stride: the number of pixels shifts over the input matrix\n    Returns:\n        numpy array of maxpooled matrix\n    Sample Input Output:\n    >>> maxpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)\n    array([[ 6.,  8.],\n           [14., 16.]])\n    >>> maxpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)\n    array([[241., 180.],\n           [241., 157.]])\n    \"\"\"\n    arr = np.array(arr)\n    if arr.shape[0] != arr.shape[1]:\n        raise ValueError(\"The input array is not a square matrix\")\n    i = 0\n    j = 0\n    mat_i = 0\n    mat_j = 0\n\n    # compute the shape of the output matrix\n    maxpool_shape = (arr.shape[0] - size) // stride + 1\n    # initialize the output matrix with zeros of shape maxpool_shape\n    updated_arr = np.zeros((maxpool_shape, maxpool_shape))\n\n    while i < arr.shape[0]:\n        if i + size > arr.shape[0]:\n            # if the end of the matrix is reached, break\n            break\n        while j < arr.shape[1]:\n            # if the end of the matrix is reached, break\n            if j + size > arr.shape[1]:\n                break\n            # compute the maximum of the pooling matrix\n            updated_arr[mat_i][mat_j] = np.max(arr[i : i + size, j : j + size])\n            # shift the pooling matrix by stride of column pixels\n            j += stride\n            mat_j += 1\n\n        # shift the pooling matrix by stride of row pixels\n        i += stride\n        mat_i += 1\n\n        # reset the column index to 0\n        j = 0\n        mat_j = 0\n\n    return updated_arr",
    "docstring": "This function is used to perform maxpooling on the input array of 2D matrix(image)\nArgs:\n    arr: numpy array\n    size: size of pooling matrix\n    stride: the number of pixels shifts over the input matrix\nReturns:\n    numpy array of maxpooled matrix\nSample Input Output:\n>>> maxpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)\narray([[ 6.,  8.],\n       [14., 16.]])\n>>> maxpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)\narray([[241., 180.],\n       [241., 157.]])"
  },
  {
    "function": "avgpooling",
    "code": "def avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:\n    \"\"\"\n    This function is used to perform avgpooling on the input array of 2D matrix(image)\n    Args:\n        arr: numpy array\n        size: size of pooling matrix\n        stride: the number of pixels shifts over the input matrix\n    Returns:\n        numpy array of avgpooled matrix\n    Sample Input Output:\n    >>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)\n    array([[ 3.,  5.],\n           [11., 13.]])\n    >>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)\n    array([[161., 102.],\n           [114.,  69.]])\n    \"\"\"\n    arr = np.array(arr)\n    if arr.shape[0] != arr.shape[1]:\n        raise ValueError(\"The input array is not a square matrix\")\n    i = 0\n    j = 0\n    mat_i = 0\n    mat_j = 0\n\n    # compute the shape of the output matrix\n    avgpool_shape = (arr.shape[0] - size) // stride + 1\n    # initialize the output matrix with zeros of shape avgpool_shape\n    updated_arr = np.zeros((avgpool_shape, avgpool_shape))\n\n    while i < arr.shape[0]:\n        # if the end of the matrix is reached, break\n        if i + size > arr.shape[0]:\n            break\n        while j < arr.shape[1]:\n            # if the end of the matrix is reached, break\n            if j + size > arr.shape[1]:\n                break\n            # compute the average of the pooling matrix\n            updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))\n            # shift the pooling matrix by stride of column pixels\n            j += stride\n            mat_j += 1\n\n        # shift the pooling matrix by stride of row pixels\n        i += stride\n        mat_i += 1\n        # reset the column index to 0\n        j = 0\n        mat_j = 0\n\n    return updated_arr",
    "docstring": "This function is used to perform avgpooling on the input array of 2D matrix(image)\nArgs:\n    arr: numpy array\n    size: size of pooling matrix\n    stride: the number of pixels shifts over the input matrix\nReturns:\n    numpy array of avgpooled matrix\nSample Input Output:\n>>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)\narray([[ 3.,  5.],\n       [11., 13.]])\n>>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)\narray([[161., 102.],\n       [114.,  69.]])"
  },
  {
    "function": "length_conversion",
    "code": "def length_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between astronomical length units.\n\n    >>> length_conversion(1, \"meter\", \"kilometer\")\n    0.001\n    >>> length_conversion(1, \"meter\", \"megametre\")\n    1e-06\n    >>> length_conversion(1, \"gigametre\", \"meter\")\n    1000000000\n    >>> length_conversion(1, \"gigametre\", \"terametre\")\n    0.001\n    >>> length_conversion(1, \"petametre\", \"terametre\")\n    1000\n    >>> length_conversion(1, \"petametre\", \"exametre\")\n    0.001\n    >>> length_conversion(1, \"terametre\", \"zettametre\")\n    1e-09\n    >>> length_conversion(1, \"yottametre\", \"zettametre\")\n    1000\n    >>> length_conversion(4, \"wrongUnit\", \"inch\")\n    Traceback (most recent call last):\n      ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'.\n    Conversion abbreviations are: m, km, Mm, Gm, Tm, Pm, Em, Zm, Ym\n    \"\"\"\n\n    from_sanitized = from_type.lower().strip(\"s\")\n    to_sanitized = to_type.lower().strip(\"s\")\n\n    from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)\n    to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)\n\n    if from_sanitized not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'from_type' value: {from_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    if to_sanitized not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'to_type' value: {to_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    from_exponent = METRIC_CONVERSION[from_sanitized]\n    to_exponent = METRIC_CONVERSION[to_sanitized]\n    exponent = 1\n\n    if from_exponent > to_exponent:\n        exponent = from_exponent - to_exponent\n    else:\n        exponent = -(to_exponent - from_exponent)\n\n    return value * pow(10, exponent)",
    "docstring": "Conversion between astronomical length units.\n\n>>> length_conversion(1, \"meter\", \"kilometer\")\n0.001\n>>> length_conversion(1, \"meter\", \"megametre\")\n1e-06\n>>> length_conversion(1, \"gigametre\", \"meter\")\n1000000000\n>>> length_conversion(1, \"gigametre\", \"terametre\")\n0.001\n>>> length_conversion(1, \"petametre\", \"terametre\")\n1000\n>>> length_conversion(1, \"petametre\", \"exametre\")\n0.001\n>>> length_conversion(1, \"terametre\", \"zettametre\")\n1e-09\n>>> length_conversion(1, \"yottametre\", \"zettametre\")\n1000\n>>> length_conversion(4, \"wrongUnit\", \"inch\")\nTraceback (most recent call last):\n  ...\nValueError: Invalid 'from_type' value: 'wrongUnit'.\nConversion abbreviations are: m, km, Mm, Gm, Tm, Pm, Em, Zm, Ym"
  },
  {
    "function": "bin_to_decimal",
    "code": "def bin_to_decimal(bin_string: str) -> int:\n    \"\"\"\n    Convert a binary value to its decimal equivalent\n\n    >>> bin_to_decimal(\"101\")\n    5\n    >>> bin_to_decimal(\" 1010   \")\n    10\n    >>> bin_to_decimal(\"-11101\")\n    -29\n    >>> bin_to_decimal(\"0\")\n    0\n    >>> bin_to_decimal(\"a\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    >>> bin_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> bin_to_decimal(\"39\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    \"\"\"\n    bin_string = str(bin_string).strip()\n    if not bin_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = bin_string[0] == \"-\"\n    if is_negative:\n        bin_string = bin_string[1:]\n    if not all(char in \"01\" for char in bin_string):\n        raise ValueError(\"Non-binary value was passed to the function\")\n    decimal_number = 0\n    for char in bin_string:\n        decimal_number = 2 * decimal_number + int(char)\n    return -decimal_number if is_negative else decimal_number",
    "docstring": "Convert a binary value to its decimal equivalent\n\n>>> bin_to_decimal(\"101\")\n5\n>>> bin_to_decimal(\" 1010   \")\n10\n>>> bin_to_decimal(\"-11101\")\n-29\n>>> bin_to_decimal(\"0\")\n0\n>>> bin_to_decimal(\"a\")\nTraceback (most recent call last):\n    ...\nValueError: Non-binary value was passed to the function\n>>> bin_to_decimal(\"\")\nTraceback (most recent call last):\n    ...\nValueError: Empty string was passed to the function\n>>> bin_to_decimal(\"39\")\nTraceback (most recent call last):\n    ...\nValueError: Non-binary value was passed to the function"
  },
  {
    "function": "bin_to_hexadecimal",
    "code": "def bin_to_hexadecimal(binary_str: str) -> str:\n    \"\"\"\n    Converting a binary string into hexadecimal using Grouping Method\n\n    >>> bin_to_hexadecimal('101011111')\n    '0x15f'\n    >>> bin_to_hexadecimal(' 1010   ')\n    '0x0a'\n    >>> bin_to_hexadecimal('-11101')\n    '-0x1d'\n    >>> bin_to_hexadecimal('a')\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    >>> bin_to_hexadecimal('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    # Sanitising parameter\n    binary_str = str(binary_str).strip()\n\n    # Exceptions\n    if not binary_str:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = binary_str[0] == \"-\"\n    binary_str = binary_str[1:] if is_negative else binary_str\n    if not all(char in \"01\" for char in binary_str):\n        raise ValueError(\"Non-binary value was passed to the function\")\n\n    binary_str = (\n        \"0\" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str\n    )\n\n    hexadecimal = []\n    for x in range(0, len(binary_str), 4):\n        hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])\n    hexadecimal_str = \"0x\" + \"\".join(hexadecimal)\n\n    return \"-\" + hexadecimal_str if is_negative else hexadecimal_str",
    "docstring": "Converting a binary string into hexadecimal using Grouping Method\n\n>>> bin_to_hexadecimal('101011111')\n'0x15f'\n>>> bin_to_hexadecimal(' 1010   ')\n'0x0a'\n>>> bin_to_hexadecimal('-11101')\n'-0x1d'\n>>> bin_to_hexadecimal('a')\nTraceback (most recent call last):\n    ...\nValueError: Non-binary value was passed to the function\n>>> bin_to_hexadecimal('')\nTraceback (most recent call last):\n    ...\nValueError: Empty string was passed to the function"
  },
  {
    "function": "convert_small_number",
    "code": "def convert_small_number(num: int) -> str:\n    \"\"\"\n    Converts small, non-negative integers with irregular constructions in English (i.e.,\n    numbers under 100) into words.\n\n    >>> convert_small_number(0)\n    'zero'\n    >>> convert_small_number(5)\n    'five'\n    >>> convert_small_number(10)\n    'ten'\n    >>> convert_small_number(15)\n    'fifteen'\n    >>> convert_small_number(20)\n    'twenty'\n    >>> convert_small_number(25)\n    'twenty-five'\n    >>> convert_small_number(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: This function only accepts non-negative integers\n    >>> convert_small_number(123)\n    Traceback (most recent call last):\n    ...\n    ValueError: This function only converts numbers less than 100\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"This function only accepts non-negative integers\")\n    if num >= 100:\n        raise ValueError(\"This function only converts numbers less than 100\")\n    tens, ones = divmod(num, 10)\n    if tens == 0:\n        return NumberWords.ONES.value[ones] or \"zero\"\n    if tens == 1:\n        return NumberWords.TEENS.value[ones]\n    return (\n        NumberWords.TENS.value[tens]\n        + (\"-\" if NumberWords.ONES.value[ones] else \"\")\n        + NumberWords.ONES.value[ones]\n    )",
    "docstring": "Converts small, non-negative integers with irregular constructions in English (i.e.,\nnumbers under 100) into words.\n\n>>> convert_small_number(0)\n'zero'\n>>> convert_small_number(5)\n'five'\n>>> convert_small_number(10)\n'ten'\n>>> convert_small_number(15)\n'fifteen'\n>>> convert_small_number(20)\n'twenty'\n>>> convert_small_number(25)\n'twenty-five'\n>>> convert_small_number(-1)\nTraceback (most recent call last):\n...\nValueError: This function only accepts non-negative integers\n>>> convert_small_number(123)\nTraceback (most recent call last):\n...\nValueError: This function only converts numbers less than 100"
  },
  {
    "function": "convert_number",
    "code": "def convert_number(\n    num: int, system: Literal[\"short\", \"long\", \"indian\"] = \"short\"\n) -> str:\n    \"\"\"\n    Converts an integer to English words.\n\n    :param num: The integer to be converted\n    :param system: The numbering system (short, long, or Indian)\n\n    >>> convert_number(0)\n    'zero'\n    >>> convert_number(1)\n    'one'\n    >>> convert_number(100)\n    'one hundred'\n    >>> convert_number(-100)\n    'negative one hundred'\n    >>> convert_number(123_456_789_012_345) # doctest: +NORMALIZE_WHITESPACE\n    'one hundred twenty-three trillion four hundred fifty-six billion\n    seven hundred eighty-nine million twelve thousand three hundred forty-five'\n    >>> convert_number(123_456_789_012_345, \"long\") # doctest: +NORMALIZE_WHITESPACE\n    'one hundred twenty-three thousand four hundred fifty-six milliard\n    seven hundred eighty-nine million twelve thousand three hundred forty-five'\n    >>> convert_number(12_34_56_78_90_12_345, \"indian\") # doctest: +NORMALIZE_WHITESPACE\n    'one crore crore twenty-three lakh crore\n    forty-five thousand six hundred seventy-eight crore\n    ninety lakh twelve thousand three hundred forty-five'\n    >>> convert_number(10**18)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input number is too large\n    >>> convert_number(10**21, \"long\")\n    Traceback (most recent call last):\n    ...\n    ValueError: Input number is too large\n    >>> convert_number(10**19, \"indian\")\n    Traceback (most recent call last):\n    ...\n    ValueError: Input number is too large\n    \"\"\"\n    word_groups = []\n\n    if num < 0:\n        word_groups.append(\"negative\")\n        num *= -1\n\n    if num > NumberingSystem.max_value(system):\n        raise ValueError(\"Input number is too large\")\n\n    for power, unit in NumberingSystem[system.upper()].value:\n        digit_group, num = divmod(num, 10**power)\n        if digit_group > 0:\n            word_group = (\n                convert_number(digit_group, system)\n                if digit_group >= 100\n                else convert_small_number(digit_group)\n            )\n            word_groups.append(f\"{word_group} {unit}\")\n    if num > 0 or not word_groups:  # word_groups is only empty if input num was 0\n        word_groups.append(convert_small_number(num))\n    return \" \".join(word_groups)",
    "docstring": "Converts an integer to English words.\n\n:param num: The integer to be converted\n:param system: The numbering system (short, long, or Indian)\n\n>>> convert_number(0)\n'zero'\n>>> convert_number(1)\n'one'\n>>> convert_number(100)\n'one hundred'\n>>> convert_number(-100)\n'negative one hundred'\n>>> convert_number(123_456_789_012_345) # doctest: +NORMALIZE_WHITESPACE\n'one hundred twenty-three trillion four hundred fifty-six billion\nseven hundred eighty-nine million twelve thousand three hundred forty-five'\n>>> convert_number(123_456_789_012_345, \"long\") # doctest: +NORMALIZE_WHITESPACE\n'one hundred twenty-three thousand four hundred fifty-six milliard\nseven hundred eighty-nine million twelve thousand three hundred forty-five'\n>>> convert_number(12_34_56_78_90_12_345, \"indian\") # doctest: +NORMALIZE_WHITESPACE\n'one crore crore twenty-three lakh crore\nforty-five thousand six hundred seventy-eight crore\nninety lakh twelve thousand three hundred forty-five'\n>>> convert_number(10**18)\nTraceback (most recent call last):\n...\nValueError: Input number is too large\n>>> convert_number(10**21, \"long\")\nTraceback (most recent call last):\n...\nValueError: Input number is too large\n>>> convert_number(10**19, \"indian\")\nTraceback (most recent call last):\n...\nValueError: Input number is too large"
  },
  {
    "function": "decimal_to_any",
    "code": "def decimal_to_any(num: int, base: int) -> str:\n    \"\"\"\n    Convert a positive integer to another base as str.\n    >>> decimal_to_any(0, 2)\n    '0'\n    >>> decimal_to_any(5, 4)\n    '11'\n    >>> decimal_to_any(20, 3)\n    '202'\n    >>> decimal_to_any(58, 16)\n    '3A'\n    >>> decimal_to_any(243, 17)\n    'E5'\n    >>> decimal_to_any(34923, 36)\n    'QY3'\n    >>> decimal_to_any(10, 11)\n    'A'\n    >>> decimal_to_any(16, 16)\n    '10'\n    >>> decimal_to_any(36, 36)\n    '10'\n    >>> # negatives will error\n    >>> decimal_to_any(-45, 8)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: parameter must be positive int\n    >>> # floats will error\n    >>> decimal_to_any(34.4, 6) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: int() can't convert non-string with explicit base\n    >>> # a float base will error\n    >>> decimal_to_any(5, 2.5) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # a str base will error\n    >>> decimal_to_any(10, '16') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    >>> # a base less than 2 will error\n    >>> decimal_to_any(7, 0) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be >= 2\n    >>> # a base greater than 36 will error\n    >>> decimal_to_any(34, 37) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be <= 36\n    \"\"\"\n    if isinstance(num, float):\n        raise TypeError(\"int() can't convert non-string with explicit base\")\n    if num < 0:\n        raise ValueError(\"parameter must be positive int\")\n    if isinstance(base, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n    if isinstance(base, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if base in (0, 1):\n        raise ValueError(\"base must be >= 2\")\n    if base > 36:\n        raise ValueError(\"base must be <= 36\")\n    new_value = \"\"\n    mod = 0\n    div = 0\n    while div != 1:\n        div, mod = divmod(num, base)\n        if base >= 11 and 9 < mod < 36:\n            actual_value = ALPHABET_VALUES[str(mod)]\n        else:\n            actual_value = str(mod)\n        new_value += actual_value\n        div = num // base\n        num = div\n        if div == 0:\n            return str(new_value[::-1])\n        elif div == 1:\n            new_value += str(div)\n            return str(new_value[::-1])\n\n    return new_value[::-1]",
    "docstring": "Convert a positive integer to another base as str.\n>>> decimal_to_any(0, 2)\n'0'\n>>> decimal_to_any(5, 4)\n'11'\n>>> decimal_to_any(20, 3)\n'202'\n>>> decimal_to_any(58, 16)\n'3A'\n>>> decimal_to_any(243, 17)\n'E5'\n>>> decimal_to_any(34923, 36)\n'QY3'\n>>> decimal_to_any(10, 11)\n'A'\n>>> decimal_to_any(16, 16)\n'10'\n>>> decimal_to_any(36, 36)\n'10'\n>>> # negatives will error\n>>> decimal_to_any(-45, 8)  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nValueError: parameter must be positive int\n>>> # floats will error\n>>> decimal_to_any(34.4, 6) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nTypeError: int() can't convert non-string with explicit base\n>>> # a float base will error\n>>> decimal_to_any(5, 2.5) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nTypeError: 'float' object cannot be interpreted as an integer\n>>> # a str base will error\n>>> decimal_to_any(10, '16') # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nTypeError: 'str' object cannot be interpreted as an integer\n>>> # a base less than 2 will error\n>>> decimal_to_any(7, 0) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nValueError: base must be >= 2\n>>> # a base greater than 36 will error\n>>> decimal_to_any(34, 37) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nValueError: base must be <= 36"
  },
  {
    "function": "decimal_to_binary_iterative",
    "code": "def decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)",
    "docstring": "Convert an Integer Decimal Number to a Binary Number as str.\n>>> decimal_to_binary_iterative(0)\n'0b0'\n>>> decimal_to_binary_iterative(2)\n'0b10'\n>>> decimal_to_binary_iterative(7)\n'0b111'\n>>> decimal_to_binary_iterative(35)\n'0b100011'\n>>> # negatives work too\n>>> decimal_to_binary_iterative(-2)\n'-0b10'\n>>> # other floats will error\n>>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nTypeError: 'float' object cannot be interpreted as an integer\n>>> # strings will error as well\n>>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nTypeError: 'str' object cannot be interpreted as an integer"
  },
  {
    "function": "decimal_to_binary_recursive_helper",
    "code": "def decimal_to_binary_recursive_helper(decimal: int) -> str:\n    \"\"\"\n    Take a positive integer value and return its binary equivalent.\n    >>> decimal_to_binary_recursive_helper(1000)\n    '1111101000'\n    >>> decimal_to_binary_recursive_helper(\"72\")\n    '1001000'\n    >>> decimal_to_binary_recursive_helper(\"number\")\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: 'number'\n    \"\"\"\n    decimal = int(decimal)\n    if decimal in (0, 1):  # Exit cases for the recursion\n        return str(decimal)\n    div, mod = divmod(decimal, 2)\n    return decimal_to_binary_recursive_helper(div) + str(mod)",
    "docstring": "Take a positive integer value and return its binary equivalent.\n>>> decimal_to_binary_recursive_helper(1000)\n'1111101000'\n>>> decimal_to_binary_recursive_helper(\"72\")\n'1001000'\n>>> decimal_to_binary_recursive_helper(\"number\")\nTraceback (most recent call last):\n    ...\nValueError: invalid literal for int() with base 10: 'number'"
  },
  {
    "function": "decimal_to_binary_recursive",
    "code": "def decimal_to_binary_recursive(number: str) -> str:\n    \"\"\"\n    Take an integer value and raise ValueError for wrong inputs,\n    call the function above and return the output with prefix \"0b\" & \"-0b\"\n    for positive and negative integers respectively.\n    >>> decimal_to_binary_recursive(0)\n    '0b0'\n    >>> decimal_to_binary_recursive(40)\n    '0b101000'\n    >>> decimal_to_binary_recursive(-40)\n    '-0b101000'\n    >>> decimal_to_binary_recursive(40.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value is not an integer\n    >>> decimal_to_binary_recursive(\"forty\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value is not an integer\n    \"\"\"\n    number = str(number).strip()\n    if not number:\n        raise ValueError(\"No input value was provided\")\n    negative = \"-\" if number.startswith(\"-\") else \"\"\n    number = number.lstrip(\"-\")\n    if not number.isnumeric():\n        raise ValueError(\"Input value is not an integer\")\n    return f\"{negative}0b{decimal_to_binary_recursive_helper(int(number))}\"",
    "docstring": "Take an integer value and raise ValueError for wrong inputs,\ncall the function above and return the output with prefix \"0b\" & \"-0b\"\nfor positive and negative integers respectively.\n>>> decimal_to_binary_recursive(0)\n'0b0'\n>>> decimal_to_binary_recursive(40)\n'0b101000'\n>>> decimal_to_binary_recursive(-40)\n'-0b101000'\n>>> decimal_to_binary_recursive(40.8)\nTraceback (most recent call last):\n    ...\nValueError: Input value is not an integer\n>>> decimal_to_binary_recursive(\"forty\")\nTraceback (most recent call last):\n    ...\nValueError: Input value is not an integer"
  },
  {
    "function": "decimal_to_hexadecimal",
    "code": "def decimal_to_hexadecimal(decimal: float) -> str:\n    \"\"\"\n    take integer decimal value, return hexadecimal representation as str beginning\n    with 0x\n    >>> decimal_to_hexadecimal(5)\n    '0x5'\n    >>> decimal_to_hexadecimal(15)\n    '0xf'\n    >>> decimal_to_hexadecimal(37)\n    '0x25'\n    >>> decimal_to_hexadecimal(255)\n    '0xff'\n    >>> decimal_to_hexadecimal(4096)\n    '0x1000'\n    >>> decimal_to_hexadecimal(999098)\n    '0xf3eba'\n    >>> # negatives work too\n    >>> decimal_to_hexadecimal(-256)\n    '-0x100'\n    >>> # floats are acceptable if equivalent to an int\n    >>> decimal_to_hexadecimal(17.0)\n    '0x11'\n    >>> # other floats will error\n    >>> decimal_to_hexadecimal(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # strings will error as well\n    >>> decimal_to_hexadecimal('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # results are the same when compared to Python's default hex function\n    >>> decimal_to_hexadecimal(-256) == hex(-256)\n    True\n    \"\"\"\n    assert isinstance(decimal, (int, float))\n    assert decimal == int(decimal)\n    decimal = int(decimal)\n    hexadecimal = \"\"\n    negative = False\n    if decimal < 0:\n        negative = True\n        decimal *= -1\n    while decimal > 0:\n        decimal, remainder = divmod(decimal, 16)\n        hexadecimal = values[remainder] + hexadecimal\n    hexadecimal = \"0x\" + hexadecimal\n    if negative:\n        hexadecimal = \"-\" + hexadecimal\n    return hexadecimal",
    "docstring": "take integer decimal value, return hexadecimal representation as str beginning\nwith 0x\n>>> decimal_to_hexadecimal(5)\n'0x5'\n>>> decimal_to_hexadecimal(15)\n'0xf'\n>>> decimal_to_hexadecimal(37)\n'0x25'\n>>> decimal_to_hexadecimal(255)\n'0xff'\n>>> decimal_to_hexadecimal(4096)\n'0x1000'\n>>> decimal_to_hexadecimal(999098)\n'0xf3eba'\n>>> # negatives work too\n>>> decimal_to_hexadecimal(-256)\n'-0x100'\n>>> # floats are acceptable if equivalent to an int\n>>> decimal_to_hexadecimal(17.0)\n'0x11'\n>>> # other floats will error\n>>> decimal_to_hexadecimal(16.16) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nAssertionError\n>>> # strings will error as well\n>>> decimal_to_hexadecimal('0xfffff') # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nAssertionError\n>>> # results are the same when compared to Python's default hex function\n>>> decimal_to_hexadecimal(-256) == hex(-256)\nTrue"
  },
  {
    "function": "decimal_to_octal",
    "code": "def decimal_to_octal(num: int) -> str:\n    \"\"\"Convert a Decimal Number to an Octal Number.\n\n    >>> all(decimal_to_octal(i) == oct(i) for i\n    ...     in (0, 2, 8, 64, 65, 216, 255, 256, 512))\n    True\n    \"\"\"\n    octal = 0\n    counter = 0\n    while num > 0:\n        remainder = num % 8\n        octal = octal + (remainder * math.floor(math.pow(10, counter)))\n        counter += 1\n        num = math.floor(num / 8)  # basically /= 8 without remainder if any\n        # This formatting removes trailing '.0' from `octal`.\n    return f\"0o{int(octal)}\"",
    "docstring": "Convert a Decimal Number to an Octal Number.\n\n>>> all(decimal_to_octal(i) == oct(i) for i\n...     in (0, 2, 8, 64, 65, 216, 255, 256, 512))\nTrue"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"Print octal equivalents of decimal numbers.\"\"\"\n    print(\"\\n2 in octal is:\")\n    print(decimal_to_octal(2))  # = 2\n    print(\"\\n8 in octal is:\")\n    print(decimal_to_octal(8))  # = 10\n    print(\"\\n65 in octal is:\")\n    print(decimal_to_octal(65))  # = 101\n    print(\"\\n216 in octal is:\")\n    print(decimal_to_octal(216))  # = 330\n    print(\"\\n512 in octal is:\")\n    print(decimal_to_octal(512))  # = 1000\n    print(\"\\n\")",
    "docstring": "Print octal equivalents of decimal numbers."
  },
  {
    "function": "energy_conversion",
    "code": "def energy_conversion(from_type: str, to_type: str, value: float) -> float:\n    \"\"\"\n    Conversion of energy units.\n    >>> energy_conversion(\"joule\", \"joule\", 1)\n    1.0\n    >>> energy_conversion(\"joule\", \"kilojoule\", 1)\n    0.001\n    >>> energy_conversion(\"joule\", \"megajoule\", 1)\n    1e-06\n    >>> energy_conversion(\"joule\", \"gigajoule\", 1)\n    1e-09\n    >>> energy_conversion(\"joule\", \"wattsecond\", 1)\n    1.0\n    >>> energy_conversion(\"joule\", \"watthour\", 1)\n    0.0002777777777777778\n    >>> energy_conversion(\"joule\", \"kilowatthour\", 1)\n    2.7777777777777776e-07\n    >>> energy_conversion(\"joule\", \"newtonmeter\", 1)\n    1.0\n    >>> energy_conversion(\"joule\", \"calorie_nutr\", 1)\n    0.00023884589662749592\n    >>> energy_conversion(\"joule\", \"kilocalorie_nutr\", 1)\n    2.388458966274959e-07\n    >>> energy_conversion(\"joule\", \"electronvolt\", 1)\n    6.241509074460763e+18\n    >>> energy_conversion(\"joule\", \"britishthermalunit_it\", 1)\n    0.0009478171226670134\n    >>> energy_conversion(\"joule\", \"footpound\", 1)\n    0.7375621211696556\n    >>> energy_conversion(\"joule\", \"megajoule\", 1000)\n    0.001\n    >>> energy_conversion(\"calorie_nutr\", \"kilocalorie_nutr\", 1000)\n    1.0\n    >>> energy_conversion(\"kilowatthour\", \"joule\", 10)\n    36000000.0\n    >>> energy_conversion(\"britishthermalunit_it\", \"footpound\", 1)\n    778.1692306784539\n    >>> energy_conversion(\"watthour\", \"joule\", \"a\") # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    TypeError: unsupported operand type(s) for /: 'str' and 'float'\n    >>> energy_conversion(\"wrongunit\", \"joule\", 1) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    ValueError: Incorrect 'from_type' or 'to_type' value: 'wrongunit', 'joule'\n    Valid values are: joule, ... footpound\n    >>> energy_conversion(\"joule\", \"wrongunit\", 1) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    ValueError: Incorrect 'from_type' or 'to_type' value: 'joule', 'wrongunit'\n    Valid values are: joule, ... footpound\n    >>> energy_conversion(\"123\", \"abc\", 1) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    ValueError: Incorrect 'from_type' or 'to_type' value: '123', 'abc'\n    Valid values are: joule, ... footpound\n    \"\"\"\n    if to_type not in ENERGY_CONVERSION or from_type not in ENERGY_CONVERSION:\n        msg = (\n            f\"Incorrect 'from_type' or 'to_type' value: {from_type!r}, {to_type!r}\\n\"\n            f\"Valid values are: {', '.join(ENERGY_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    return value * ENERGY_CONVERSION[from_type] / ENERGY_CONVERSION[to_type]",
    "docstring": "Conversion of energy units.\n>>> energy_conversion(\"joule\", \"joule\", 1)\n1.0\n>>> energy_conversion(\"joule\", \"kilojoule\", 1)\n0.001\n>>> energy_conversion(\"joule\", \"megajoule\", 1)\n1e-06\n>>> energy_conversion(\"joule\", \"gigajoule\", 1)\n1e-09\n>>> energy_conversion(\"joule\", \"wattsecond\", 1)\n1.0\n>>> energy_conversion(\"joule\", \"watthour\", 1)\n0.0002777777777777778\n>>> energy_conversion(\"joule\", \"kilowatthour\", 1)\n2.7777777777777776e-07\n>>> energy_conversion(\"joule\", \"newtonmeter\", 1)\n1.0\n>>> energy_conversion(\"joule\", \"calorie_nutr\", 1)\n0.00023884589662749592\n>>> energy_conversion(\"joule\", \"kilocalorie_nutr\", 1)\n2.388458966274959e-07\n>>> energy_conversion(\"joule\", \"electronvolt\", 1)\n6.241509074460763e+18\n>>> energy_conversion(\"joule\", \"britishthermalunit_it\", 1)\n0.0009478171226670134\n>>> energy_conversion(\"joule\", \"footpound\", 1)\n0.7375621211696556\n>>> energy_conversion(\"joule\", \"megajoule\", 1000)\n0.001\n>>> energy_conversion(\"calorie_nutr\", \"kilocalorie_nutr\", 1000)\n1.0\n>>> energy_conversion(\"kilowatthour\", \"joule\", 10)\n36000000.0\n>>> energy_conversion(\"britishthermalunit_it\", \"footpound\", 1)\n778.1692306784539\n>>> energy_conversion(\"watthour\", \"joule\", \"a\") # doctest: +ELLIPSIS\nTraceback (most recent call last):\n  ...\nTypeError: unsupported operand type(s) for /: 'str' and 'float'\n>>> energy_conversion(\"wrongunit\", \"joule\", 1) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n  ...\nValueError: Incorrect 'from_type' or 'to_type' value: 'wrongunit', 'joule'\nValid values are: joule, ... footpound\n>>> energy_conversion(\"joule\", \"wrongunit\", 1) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n  ...\nValueError: Incorrect 'from_type' or 'to_type' value: 'joule', 'wrongunit'\nValid values are: joule, ... footpound\n>>> energy_conversion(\"123\", \"abc\", 1) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n  ...\nValueError: Incorrect 'from_type' or 'to_type' value: '123', 'abc'\nValid values are: joule, ... footpound"
  },
  {
    "function": "excel_title_to_column",
    "code": "def excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer",
    "docstring": "Given a string column_title that represents\nthe column title in an Excel sheet, return\nits corresponding column number.\n\n>>> excel_title_to_column(\"A\")\n1\n>>> excel_title_to_column(\"B\")\n2\n>>> excel_title_to_column(\"AB\")\n28\n>>> excel_title_to_column(\"Z\")\n26"
  },
  {
    "function": "hex_to_decimal",
    "code": "def hex_to_decimal(hex_string: str) -> int:\n    \"\"\"\n    Convert a hexadecimal value to its decimal equivalent\n    #https://www.programiz.com/python-programming/methods/built-in/hex\n\n    >>> hex_to_decimal(\"a\")\n    10\n    >>> hex_to_decimal(\"12f\")\n    303\n    >>> hex_to_decimal(\"   12f   \")\n    303\n    >>> hex_to_decimal(\"FfFf\")\n    65535\n    >>> hex_to_decimal(\"-Ff\")\n    -255\n    >>> hex_to_decimal(\"F-f\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-hexadecimal value was passed to the function\n    >>> hex_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> hex_to_decimal(\"12m\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-hexadecimal value was passed to the function\n    \"\"\"\n    hex_string = hex_string.strip().lower()\n    if not hex_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = hex_string[0] == \"-\"\n    if is_negative:\n        hex_string = hex_string[1:]\n    if not all(char in hex_table for char in hex_string):\n        raise ValueError(\"Non-hexadecimal value was passed to the function\")\n    decimal_number = 0\n    for char in hex_string:\n        decimal_number = 16 * decimal_number + hex_table[char]\n    return -decimal_number if is_negative else decimal_number",
    "docstring": "Convert a hexadecimal value to its decimal equivalent\n#https://www.programiz.com/python-programming/methods/built-in/hex\n\n>>> hex_to_decimal(\"a\")\n10\n>>> hex_to_decimal(\"12f\")\n303\n>>> hex_to_decimal(\"   12f   \")\n303\n>>> hex_to_decimal(\"FfFf\")\n65535\n>>> hex_to_decimal(\"-Ff\")\n-255\n>>> hex_to_decimal(\"F-f\")\nTraceback (most recent call last):\n    ...\nValueError: Non-hexadecimal value was passed to the function\n>>> hex_to_decimal(\"\")\nTraceback (most recent call last):\n    ...\nValueError: Empty string was passed to the function\n>>> hex_to_decimal(\"12m\")\nTraceback (most recent call last):\n    ...\nValueError: Non-hexadecimal value was passed to the function"
  },
  {
    "function": "hex_to_bin",
    "code": "def hex_to_bin(hex_num: str) -> int:\n    \"\"\"\n    Convert a hexadecimal value to its binary equivalent\n    #https://stackoverflow.com/questions/1425493/convert-hex-to-binary\n    Here, we have used the bitwise right shift operator: >>\n    Shifts the bits of the number to the right and fills 0 on voids left as a result.\n    Similar effect as of dividing the number with some power of two.\n    Example:\n    a = 10\n    a >> 1 = 5\n\n    >>> hex_to_bin(\"AC\")\n    10101100\n    >>> hex_to_bin(\"9A4\")\n    100110100100\n    >>> hex_to_bin(\"   12f   \")\n    100101111\n    >>> hex_to_bin(\"FfFf\")\n    1111111111111111\n    >>> hex_to_bin(\"-fFfF\")\n    -1111111111111111\n    >>> hex_to_bin(\"F-f\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid value was passed to the function\n    >>> hex_to_bin(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: No value was passed to the function\n    \"\"\"\n\n    hex_num = hex_num.strip()\n    if not hex_num:\n        raise ValueError(\"No value was passed to the function\")\n\n    is_negative = hex_num[0] == \"-\"\n    if is_negative:\n        hex_num = hex_num[1:]\n\n    try:\n        int_num = int(hex_num, 16)\n    except ValueError:\n        raise ValueError(\"Invalid value was passed to the function\")\n\n    bin_str = \"\"\n    while int_num > 0:\n        bin_str = str(int_num % 2) + bin_str\n        int_num >>= 1\n\n    return int((\"-\" + bin_str) if is_negative else bin_str)",
    "docstring": "Convert a hexadecimal value to its binary equivalent\n#https://stackoverflow.com/questions/1425493/convert-hex-to-binary\nHere, we have used the bitwise right shift operator: >>\nShifts the bits of the number to the right and fills 0 on voids left as a result.\nSimilar effect as of dividing the number with some power of two.\nExample:\na = 10\na >> 1 = 5\n\n>>> hex_to_bin(\"AC\")\n10101100\n>>> hex_to_bin(\"9A4\")\n100110100100\n>>> hex_to_bin(\"   12f   \")\n100101111\n>>> hex_to_bin(\"FfFf\")\n1111111111111111\n>>> hex_to_bin(\"-fFfF\")\n-1111111111111111\n>>> hex_to_bin(\"F-f\")\nTraceback (most recent call last):\n    ...\nValueError: Invalid value was passed to the function\n>>> hex_to_bin(\"\")\nTraceback (most recent call last):\n    ...\nValueError: No value was passed to the function"
  },
  {
    "function": "ipv4_to_decimal",
    "code": "def ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    Convert an IPv4 address to its decimal representation.\n\n    Args:\n        ip_address: A string representing an IPv4 address (e.g., \"192.168.0.1\").\n\n    Returns:\n        int: The decimal representation of the IP address.\n\n    >>> ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    >>> ipv4_to_decimal(\"10.0.255\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid IPv4 address format\n    >>> ipv4_to_decimal(\"10.0.0.256\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid IPv4 octet 256\n    \"\"\"\n\n    octets = [int(octet) for octet in ipv4_address.split(\".\")]\n    if len(octets) != 4:\n        raise ValueError(\"Invalid IPv4 address format\")\n\n    decimal_ipv4 = 0\n    for octet in octets:\n        if not 0 <= octet <= 255:\n            raise ValueError(f\"Invalid IPv4 octet {octet}\")  # noqa: EM102\n        decimal_ipv4 = (decimal_ipv4 << 8) + int(octet)\n\n    return decimal_ipv4",
    "docstring": "Convert an IPv4 address to its decimal representation.\n\nArgs:\n    ip_address: A string representing an IPv4 address (e.g., \"192.168.0.1\").\n\nReturns:\n    int: The decimal representation of the IP address.\n\n>>> ipv4_to_decimal(\"192.168.0.1\")\n3232235521\n>>> ipv4_to_decimal(\"10.0.0.255\")\n167772415\n>>> ipv4_to_decimal(\"10.0.255\")\nTraceback (most recent call last):\n    ...\nValueError: Invalid IPv4 address format\n>>> ipv4_to_decimal(\"10.0.0.256\")\nTraceback (most recent call last):\n    ...\nValueError: Invalid IPv4 octet 256"
  },
  {
    "function": "alt_ipv4_to_decimal",
    "code": "def alt_ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    >>> alt_ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> alt_ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    \"\"\"\n    return int(\"0x\" + \"\".join(f\"{int(i):02x}\" for i in ipv4_address.split(\".\")), 16)",
    "docstring": ">>> alt_ipv4_to_decimal(\"192.168.0.1\")\n3232235521\n>>> alt_ipv4_to_decimal(\"10.0.0.255\")\n167772415"
  },
  {
    "function": "decimal_to_ipv4",
    "code": "def decimal_to_ipv4(decimal_ipv4: int) -> str:\n    \"\"\"\n    Convert a decimal representation of an IP address to its IPv4 format.\n\n    Args:\n        decimal_ipv4: An integer representing the decimal IP address.\n\n    Returns:\n        The IPv4 representation of the decimal IP address.\n\n    >>> decimal_to_ipv4(3232235521)\n    '192.168.0.1'\n    >>> decimal_to_ipv4(167772415)\n    '10.0.0.255'\n    >>> decimal_to_ipv4(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid decimal IPv4 address\n    \"\"\"\n\n    if not (0 <= decimal_ipv4 <= 4294967295):\n        raise ValueError(\"Invalid decimal IPv4 address\")\n\n    ip_parts = []\n    for _ in range(4):\n        ip_parts.append(str(decimal_ipv4 & 255))\n        decimal_ipv4 >>= 8\n\n    return \".\".join(reversed(ip_parts))",
    "docstring": "Convert a decimal representation of an IP address to its IPv4 format.\n\nArgs:\n    decimal_ipv4: An integer representing the decimal IP address.\n\nReturns:\n    The IPv4 representation of the decimal IP address.\n\n>>> decimal_to_ipv4(3232235521)\n'192.168.0.1'\n>>> decimal_to_ipv4(167772415)\n'10.0.0.255'\n>>> decimal_to_ipv4(-1)\nTraceback (most recent call last):\n    ...\nValueError: Invalid decimal IPv4 address"
  },
  {
    "function": "length_conversion",
    "code": "def length_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between length units.\n\n    >>> length_conversion(4, \"METER\", \"FEET\")\n    13.12336\n    >>> length_conversion(4, \"M\", \"FT\")\n    13.12336\n    >>> length_conversion(1, \"meter\", \"kilometer\")\n    0.001\n    >>> length_conversion(1, \"kilometer\", \"inch\")\n    39370.1\n    >>> length_conversion(3, \"kilometer\", \"mile\")\n    1.8641130000000001\n    >>> length_conversion(2, \"feet\", \"meter\")\n    0.6096\n    >>> length_conversion(4, \"feet\", \"yard\")\n    1.333329312\n    >>> length_conversion(1, \"inch\", \"meter\")\n    0.0254\n    >>> length_conversion(2, \"inch\", \"mile\")\n    3.15656468e-05\n    >>> length_conversion(2, \"centimeter\", \"millimeter\")\n    20.0\n    >>> length_conversion(2, \"centimeter\", \"yard\")\n    0.0218722\n    >>> length_conversion(4, \"yard\", \"meter\")\n    3.6576\n    >>> length_conversion(4, \"yard\", \"kilometer\")\n    0.0036576\n    >>> length_conversion(3, \"foot\", \"meter\")\n    0.9144000000000001\n    >>> length_conversion(3, \"foot\", \"inch\")\n    36.00001944\n    >>> length_conversion(4, \"mile\", \"kilometer\")\n    6.43736\n    >>> length_conversion(2, \"miles\", \"InChEs\")\n    126719.753468\n    >>> length_conversion(3, \"millimeter\", \"centimeter\")\n    0.3\n    >>> length_conversion(3, \"mm\", \"in\")\n    0.1181103\n    >>> length_conversion(4, \"wrongUnit\", \"inch\")\n    Traceback (most recent call last):\n      ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'.\n    Conversion abbreviations are: mm, cm, m, km, in, ft, yd, mi\n    \"\"\"\n    new_from = from_type.lower().rstrip(\"s\")\n    new_from = TYPE_CONVERSION.get(new_from, new_from)\n    new_to = to_type.lower().rstrip(\"s\")\n    new_to = TYPE_CONVERSION.get(new_to, new_to)\n    if new_from not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'from_type' value: {from_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    if new_to not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'to_type' value: {to_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    return (\n        value\n        * METRIC_CONVERSION[new_from].from_factor\n        * METRIC_CONVERSION[new_to].to_factor\n    )",
    "docstring": "Conversion between length units.\n\n>>> length_conversion(4, \"METER\", \"FEET\")\n13.12336\n>>> length_conversion(4, \"M\", \"FT\")\n13.12336\n>>> length_conversion(1, \"meter\", \"kilometer\")\n0.001\n>>> length_conversion(1, \"kilometer\", \"inch\")\n39370.1\n>>> length_conversion(3, \"kilometer\", \"mile\")\n1.8641130000000001\n>>> length_conversion(2, \"feet\", \"meter\")\n0.6096\n>>> length_conversion(4, \"feet\", \"yard\")\n1.333329312\n>>> length_conversion(1, \"inch\", \"meter\")\n0.0254\n>>> length_conversion(2, \"inch\", \"mile\")\n3.15656468e-05\n>>> length_conversion(2, \"centimeter\", \"millimeter\")\n20.0\n>>> length_conversion(2, \"centimeter\", \"yard\")\n0.0218722\n>>> length_conversion(4, \"yard\", \"meter\")\n3.6576\n>>> length_conversion(4, \"yard\", \"kilometer\")\n0.0036576\n>>> length_conversion(3, \"foot\", \"meter\")\n0.9144000000000001\n>>> length_conversion(3, \"foot\", \"inch\")\n36.00001944\n>>> length_conversion(4, \"mile\", \"kilometer\")\n6.43736\n>>> length_conversion(2, \"miles\", \"InChEs\")\n126719.753468\n>>> length_conversion(3, \"millimeter\", \"centimeter\")\n0.3\n>>> length_conversion(3, \"mm\", \"in\")\n0.1181103\n>>> length_conversion(4, \"wrongUnit\", \"inch\")\nTraceback (most recent call last):\n  ...\nValueError: Invalid 'from_type' value: 'wrongUnit'.\nConversion abbreviations are: mm, cm, m, km, in, ft, yd, mi"
  },
  {
    "function": "molarity_to_normality",
    "code": "def molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\n    \"\"\"\n    Convert molarity to normality.\n      Volume is taken in litres.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n      >>> molarity_to_normality(2, 3.1, 0.31)\n      20\n      >>> molarity_to_normality(4, 11.4, 5.7)\n      8\n    \"\"\"\n    return round(float(moles / volume) * nfactor)",
    "docstring": "Convert molarity to normality.\n  Volume is taken in litres.\n\n  Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n  Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n  >>> molarity_to_normality(2, 3.1, 0.31)\n  20\n  >>> molarity_to_normality(4, 11.4, 5.7)\n  8"
  },
  {
    "function": "moles_to_pressure",
    "code": "def moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to pressure.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_pressure(0.82, 3, 300)\n      90\n      >>> moles_to_pressure(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (volume)))",
    "docstring": "Convert moles to pressure.\n  Ideal gas laws are used.\n  Temperature is taken in kelvin.\n  Volume is taken in litres.\n  Pressure has atm as SI unit.\n\n  Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n  Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n  Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n  >>> moles_to_pressure(0.82, 3, 300)\n  90\n  >>> moles_to_pressure(8.2, 5, 200)\n  10"
  },
  {
    "function": "moles_to_volume",
    "code": "def moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to volume.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_volume(0.82, 3, 300)\n      90\n      >>> moles_to_volume(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (pressure)))",
    "docstring": "Convert moles to volume.\n  Ideal gas laws are used.\n  Temperature is taken in kelvin.\n  Volume is taken in litres.\n  Pressure has atm as SI unit.\n\n  Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n  Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n  Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n  >>> moles_to_volume(0.82, 3, 300)\n  90\n  >>> moles_to_volume(8.2, 5, 200)\n  10"
  },
  {
    "function": "pressure_and_volume_to_temperature",
    "code": "def pressure_and_volume_to_temperature(\n    pressure: float, moles: float, volume: float\n) -> float:\n    \"\"\"\n    Convert pressure and volume to temperature.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> pressure_and_volume_to_temperature(0.82, 1, 2)\n      20\n      >>> pressure_and_volume_to_temperature(8.2, 5, 3)\n      60\n    \"\"\"\n    return round(float((pressure * volume) / (0.0821 * moles)))",
    "docstring": "Convert pressure and volume to temperature.\n  Ideal gas laws are used.\n  Temperature is taken in kelvin.\n  Volume is taken in litres.\n  Pressure has atm as SI unit.\n\n  Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n  Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n  Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n  >>> pressure_and_volume_to_temperature(0.82, 1, 2)\n  20\n  >>> pressure_and_volume_to_temperature(8.2, 5, 3)\n  60"
  },
  {
    "function": "octal_to_binary",
    "code": "def octal_to_binary(octal_number: str) -> str:\n    \"\"\"\n    Convert an Octal number to Binary.\n\n    >>> octal_to_binary(\"17\")\n    '001111'\n    >>> octal_to_binary(\"7\")\n    '111'\n    >>> octal_to_binary(\"Av\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"@#\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    if not octal_number:\n        raise ValueError(\"Empty string was passed to the function\")\n\n    binary_number = \"\"\n    octal_digits = \"01234567\"\n    for digit in octal_number:\n        if digit not in octal_digits:\n            raise ValueError(\"Non-octal value was passed to the function\")\n\n        binary_digit = \"\"\n        value = int(digit)\n        for _ in range(3):\n            binary_digit = str(value % 2) + binary_digit\n            value //= 2\n        binary_number += binary_digit\n\n    return binary_number",
    "docstring": "Convert an Octal number to Binary.\n\n>>> octal_to_binary(\"17\")\n'001111'\n>>> octal_to_binary(\"7\")\n'111'\n>>> octal_to_binary(\"Av\")\nTraceback (most recent call last):\n    ...\nValueError: Non-octal value was passed to the function\n>>> octal_to_binary(\"@#\")\nTraceback (most recent call last):\n    ...\nValueError: Non-octal value was passed to the function\n>>> octal_to_binary(\"\")\nTraceback (most recent call last):\n    ...\nValueError: Empty string was passed to the function"
  },
  {
    "function": "oct_to_decimal",
    "code": "def oct_to_decimal(oct_string: str) -> int:\n    \"\"\"\n    Convert a octal value to its decimal equivalent\n\n    >>> oct_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> oct_to_decimal(\"-\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"e\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"8\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"-e\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"-8\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"1\")\n    1\n    >>> oct_to_decimal(\"-1\")\n    -1\n    >>> oct_to_decimal(\"12\")\n    10\n    >>> oct_to_decimal(\" 12   \")\n    10\n    >>> oct_to_decimal(\"-45\")\n    -37\n    >>> oct_to_decimal(\"-\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"0\")\n    0\n    >>> oct_to_decimal(\"-4055\")\n    -2093\n    >>> oct_to_decimal(\"2-0Fm\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> oct_to_decimal(\"19\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    \"\"\"\n    oct_string = str(oct_string).strip()\n    if not oct_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = oct_string[0] == \"-\"\n    if is_negative:\n        oct_string = oct_string[1:]\n    if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):\n        raise ValueError(\"Non-octal value was passed to the function\")\n    decimal_number = 0\n    for char in oct_string:\n        decimal_number = 8 * decimal_number + int(char)\n    if is_negative:\n        decimal_number = -decimal_number\n    return decimal_number",
    "docstring": "Convert a octal value to its decimal equivalent\n\n>>> oct_to_decimal(\"\")\nTraceback (most recent call last):\n    ...\nValueError: Empty string was passed to the function\n>>> oct_to_decimal(\"-\")\nTraceback (most recent call last):\n    ...\nValueError: Non-octal value was passed to the function\n>>> oct_to_decimal(\"e\")\nTraceback (most recent call last):\n    ...\nValueError: Non-octal value was passed to the function\n>>> oct_to_decimal(\"8\")\nTraceback (most recent call last):\n    ...\nValueError: Non-octal value was passed to the function\n>>> oct_to_decimal(\"-e\")\nTraceback (most recent call last):\n    ...\nValueError: Non-octal value was passed to the function\n>>> oct_to_decimal(\"-8\")\nTraceback (most recent call last):\n    ...\nValueError: Non-octal value was passed to the function\n>>> oct_to_decimal(\"1\")\n1\n>>> oct_to_decimal(\"-1\")\n-1\n>>> oct_to_decimal(\"12\")\n10\n>>> oct_to_decimal(\" 12   \")\n10\n>>> oct_to_decimal(\"-45\")\n-37\n>>> oct_to_decimal(\"-\")\nTraceback (most recent call last):\n    ...\nValueError: Non-octal value was passed to the function\n>>> oct_to_decimal(\"0\")\n0\n>>> oct_to_decimal(\"-4055\")\n-2093\n>>> oct_to_decimal(\"2-0Fm\")\nTraceback (most recent call last):\n    ...\nValueError: Non-octal value was passed to the function\n>>> oct_to_decimal(\"\")\nTraceback (most recent call last):\n    ...\nValueError: Empty string was passed to the function\n>>> oct_to_decimal(\"19\")\nTraceback (most recent call last):\n    ...\nValueError: Non-octal value was passed to the function"
  },
  {
    "function": "octal_to_hex",
    "code": "def octal_to_hex(octal: str) -> str:\n    \"\"\"\n    Convert an Octal number to Hexadecimal number.\n    For more information: https://en.wikipedia.org/wiki/Octal\n\n    >>> octal_to_hex(\"100\")\n    '0x40'\n    >>> octal_to_hex(\"235\")\n    '0x9D'\n    >>> octal_to_hex(17)\n    Traceback (most recent call last):\n        ...\n    TypeError: Expected a string as input\n    >>> octal_to_hex(\"Av\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Not a Valid Octal Number\n    >>> octal_to_hex(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n\n    if not isinstance(octal, str):\n        raise TypeError(\"Expected a string as input\")\n    if octal.startswith(\"0o\"):\n        octal = octal[2:]\n    if octal == \"\":\n        raise ValueError(\"Empty string was passed to the function\")\n    if any(char not in \"01234567\" for char in octal):\n        raise ValueError(\"Not a Valid Octal Number\")\n\n    decimal = 0\n    for char in octal:\n        decimal <<= 3\n        decimal |= int(char)\n\n    hex_char = \"0123456789ABCDEF\"\n\n    revhex = \"\"\n    while decimal:\n        revhex += hex_char[decimal & 15]\n        decimal >>= 4\n\n    return \"0x\" + revhex[::-1]",
    "docstring": "Convert an Octal number to Hexadecimal number.\nFor more information: https://en.wikipedia.org/wiki/Octal\n\n>>> octal_to_hex(\"100\")\n'0x40'\n>>> octal_to_hex(\"235\")\n'0x9D'\n>>> octal_to_hex(17)\nTraceback (most recent call last):\n    ...\nTypeError: Expected a string as input\n>>> octal_to_hex(\"Av\")\nTraceback (most recent call last):\n    ...\nValueError: Not a Valid Octal Number\n>>> octal_to_hex(\"\")\nTraceback (most recent call last):\n    ...\nValueError: Empty string was passed to the function"
  },
  {
    "function": "convert_si_prefix",
    "code": "def convert_si_prefix(\n    known_amount: float,\n    known_prefix: str | SIUnit,\n    unknown_prefix: str | SIUnit,\n) -> float:\n    \"\"\"\n    Wikipedia reference: https://en.wikipedia.org/wiki/Binary_prefix\n    Wikipedia reference: https://en.wikipedia.org/wiki/International_System_of_Units\n    >>> convert_si_prefix(1, SIUnit.giga, SIUnit.mega)\n    1000\n    >>> convert_si_prefix(1, SIUnit.mega, SIUnit.giga)\n    0.001\n    >>> convert_si_prefix(1, SIUnit.kilo, SIUnit.kilo)\n    1\n    >>> convert_si_prefix(1, 'giga', 'mega')\n    1000\n    >>> convert_si_prefix(1, 'gIGa', 'mEGa')\n    1000\n    \"\"\"\n    if isinstance(known_prefix, str):\n        known_prefix = SIUnit[known_prefix.lower()]\n    if isinstance(unknown_prefix, str):\n        unknown_prefix = SIUnit[unknown_prefix.lower()]\n    unknown_amount: float = known_amount * (\n        10 ** (known_prefix.value - unknown_prefix.value)\n    )\n    return unknown_amount",
    "docstring": "Wikipedia reference: https://en.wikipedia.org/wiki/Binary_prefix\nWikipedia reference: https://en.wikipedia.org/wiki/International_System_of_Units\n>>> convert_si_prefix(1, SIUnit.giga, SIUnit.mega)\n1000\n>>> convert_si_prefix(1, SIUnit.mega, SIUnit.giga)\n0.001\n>>> convert_si_prefix(1, SIUnit.kilo, SIUnit.kilo)\n1\n>>> convert_si_prefix(1, 'giga', 'mega')\n1000\n>>> convert_si_prefix(1, 'gIGa', 'mEGa')\n1000"
  },
  {
    "function": "convert_binary_prefix",
    "code": "def convert_binary_prefix(\n    known_amount: float,\n    known_prefix: str | BinaryUnit,\n    unknown_prefix: str | BinaryUnit,\n) -> float:\n    \"\"\"\n    Wikipedia reference: https://en.wikipedia.org/wiki/Metric_prefix\n    >>> convert_binary_prefix(1, BinaryUnit.giga, BinaryUnit.mega)\n    1024\n    >>> convert_binary_prefix(1, BinaryUnit.mega, BinaryUnit.giga)\n    0.0009765625\n    >>> convert_binary_prefix(1, BinaryUnit.kilo, BinaryUnit.kilo)\n    1\n    >>> convert_binary_prefix(1, 'giga', 'mega')\n    1024\n    >>> convert_binary_prefix(1, 'gIGa', 'mEGa')\n    1024\n    \"\"\"\n    if isinstance(known_prefix, str):\n        known_prefix = BinaryUnit[known_prefix.lower()]\n    if isinstance(unknown_prefix, str):\n        unknown_prefix = BinaryUnit[unknown_prefix.lower()]\n    unknown_amount: float = known_amount * (\n        2 ** ((known_prefix.value - unknown_prefix.value) * 10)\n    )\n    return unknown_amount",
    "docstring": "Wikipedia reference: https://en.wikipedia.org/wiki/Metric_prefix\n>>> convert_binary_prefix(1, BinaryUnit.giga, BinaryUnit.mega)\n1024\n>>> convert_binary_prefix(1, BinaryUnit.mega, BinaryUnit.giga)\n0.0009765625\n>>> convert_binary_prefix(1, BinaryUnit.kilo, BinaryUnit.kilo)\n1\n>>> convert_binary_prefix(1, 'giga', 'mega')\n1024\n>>> convert_binary_prefix(1, 'gIGa', 'mEGa')\n1024"
  },
  {
    "function": "add_si_prefix",
    "code": "def add_si_prefix(value: float) -> str:\n    \"\"\"\n    Function that converts a number to his version with SI prefix\n    @input value (an integer)\n    @example:\n    >>> add_si_prefix(10000)\n    '10.0 kilo'\n    \"\"\"\n    prefixes = SIUnit.get_positive() if value > 0 else SIUnit.get_negative()\n    for name_prefix, value_prefix in prefixes.items():\n        numerical_part = value / (10**value_prefix)\n        if numerical_part > 1:\n            return f\"{numerical_part!s} {name_prefix}\"\n    return str(value)",
    "docstring": "Function that converts a number to his version with SI prefix\n@input value (an integer)\n@example:\n>>> add_si_prefix(10000)\n'10.0 kilo'"
  },
  {
    "function": "add_binary_prefix",
    "code": "def add_binary_prefix(value: float) -> str:\n    \"\"\"\n    Function that converts a number to his version with Binary prefix\n    @input value (an integer)\n    @example:\n    >>> add_binary_prefix(65536)\n    '64.0 kilo'\n    \"\"\"\n    for prefix in BinaryUnit:\n        numerical_part = value / (2**prefix.value)\n        if numerical_part > 1:\n            return f\"{numerical_part!s} {prefix.name}\"\n    return str(value)",
    "docstring": "Function that converts a number to his version with Binary prefix\n@input value (an integer)\n@example:\n>>> add_binary_prefix(65536)\n'64.0 kilo'"
  },
  {
    "function": "pressure_conversion",
    "code": "def pressure_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between pressure units.\n    >>> pressure_conversion(4, \"atm\", \"pascal\")\n    405300\n    >>> pressure_conversion(1, \"pascal\", \"psi\")\n    0.00014401981999999998\n    >>> pressure_conversion(1, \"bar\", \"atm\")\n    0.986923\n    >>> pressure_conversion(3, \"kilopascal\", \"bar\")\n    0.029999991892499998\n    >>> pressure_conversion(2, \"megapascal\", \"psi\")\n    290.074434314\n    >>> pressure_conversion(4, \"psi\", \"torr\")\n    206.85984\n    >>> pressure_conversion(1, \"inHg\", \"atm\")\n    0.0334211\n    >>> pressure_conversion(1, \"torr\", \"psi\")\n    0.019336718261000002\n    >>> pressure_conversion(4, \"wrongUnit\", \"atm\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\n    atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr\n    \"\"\"\n    if from_type not in PRESSURE_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"\n            + \", \".join(PRESSURE_CONVERSION)\n        )\n    if to_type not in PRESSURE_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"\n            + \", \".join(PRESSURE_CONVERSION)\n        )\n    return (\n        value\n        * PRESSURE_CONVERSION[from_type].from_factor\n        * PRESSURE_CONVERSION[to_type].to_factor\n    )",
    "docstring": "Conversion between pressure units.\n>>> pressure_conversion(4, \"atm\", \"pascal\")\n405300\n>>> pressure_conversion(1, \"pascal\", \"psi\")\n0.00014401981999999998\n>>> pressure_conversion(1, \"bar\", \"atm\")\n0.986923\n>>> pressure_conversion(3, \"kilopascal\", \"bar\")\n0.029999991892499998\n>>> pressure_conversion(2, \"megapascal\", \"psi\")\n290.074434314\n>>> pressure_conversion(4, \"psi\", \"torr\")\n206.85984\n>>> pressure_conversion(1, \"inHg\", \"atm\")\n0.0334211\n>>> pressure_conversion(1, \"torr\", \"psi\")\n0.019336718261000002\n>>> pressure_conversion(4, \"wrongUnit\", \"atm\")\nTraceback (most recent call last):\n    ...\nValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\natm, pascal, bar, kilopascal, megapascal, psi, inHg, torr"
  },
  {
    "function": "rectangular_to_polar",
    "code": "def rectangular_to_polar(real: float, img: float) -> tuple[float, float]:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Polar_coordinate_system\n\n    >>> rectangular_to_polar(5,-5)\n    (7.07, -45.0)\n    >>> rectangular_to_polar(-1,1)\n    (1.41, 135.0)\n    >>> rectangular_to_polar(-1,-1)\n    (1.41, -135.0)\n    >>> rectangular_to_polar(1e-10,1e-10)\n    (0.0, 45.0)\n    >>> rectangular_to_polar(-1e-10,1e-10)\n    (0.0, 135.0)\n    >>> rectangular_to_polar(9.75,5.93)\n    (11.41, 31.31)\n    >>> rectangular_to_polar(10000,99999)\n    (100497.76, 84.29)\n    \"\"\"\n\n    mod = round(math.sqrt((real**2) + (img**2)), 2)\n    ang = round(math.degrees(math.atan2(img, real)), 2)\n    return (mod, ang)",
    "docstring": "https://en.wikipedia.org/wiki/Polar_coordinate_system\n\n>>> rectangular_to_polar(5,-5)\n(7.07, -45.0)\n>>> rectangular_to_polar(-1,1)\n(1.41, 135.0)\n>>> rectangular_to_polar(-1,-1)\n(1.41, -135.0)\n>>> rectangular_to_polar(1e-10,1e-10)\n(0.0, 45.0)\n>>> rectangular_to_polar(-1e-10,1e-10)\n(0.0, 135.0)\n>>> rectangular_to_polar(9.75,5.93)\n(11.41, 31.31)\n>>> rectangular_to_polar(10000,99999)\n(100497.76, 84.29)"
  },
  {
    "function": "rgb_to_cmyk",
    "code": "def rgb_to_cmyk(r_input: int, g_input: int, b_input: int) -> tuple[int, int, int, int]:\n    \"\"\"\n    Simple RGB to CMYK conversion. Returns percentages of CMYK paint.\n    https://www.programmingalgorithms.com/algorithm/rgb-to-cmyk/\n\n    Note: this is a very popular algorithm that converts colors linearly and gives\n    only approximate results. Actual preparation for printing requires advanced color\n    conversion considering the color profiles and parameters of the target device.\n\n    >>> rgb_to_cmyk(255, 200, \"a\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected int, found (<class 'int'>, <class 'int'>, <class 'str'>)\n\n    >>> rgb_to_cmyk(255, 255, 999)\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected int of the range 0..255\n\n    >>> rgb_to_cmyk(255, 255, 255)  # white\n    (0, 0, 0, 0)\n\n    >>> rgb_to_cmyk(128, 128, 128)  # gray\n    (0, 0, 0, 50)\n\n    >>> rgb_to_cmyk(0, 0, 0)    # black\n    (0, 0, 0, 100)\n\n    >>> rgb_to_cmyk(255, 0, 0)  # red\n    (0, 100, 100, 0)\n\n    >>> rgb_to_cmyk(0, 255, 0)  # green\n    (100, 0, 100, 0)\n\n    >>> rgb_to_cmyk(0, 0, 255)    # blue\n    (100, 100, 0, 0)\n    \"\"\"\n\n    if (\n        not isinstance(r_input, int)\n        or not isinstance(g_input, int)\n        or not isinstance(b_input, int)\n    ):\n        msg = f\"Expected int, found {type(r_input), type(g_input), type(b_input)}\"\n        raise ValueError(msg)\n\n    if not 0 <= r_input < 256 or not 0 <= g_input < 256 or not 0 <= b_input < 256:\n        raise ValueError(\"Expected int of the range 0..255\")\n\n    # changing range from 0..255 to 0..1\n    r = r_input / 255\n    g = g_input / 255\n    b = b_input / 255\n\n    k = 1 - max(r, g, b)\n\n    if k == 1:  # pure black\n        return 0, 0, 0, 100\n\n    c = round(100 * (1 - r - k) / (1 - k))\n    m = round(100 * (1 - g - k) / (1 - k))\n    y = round(100 * (1 - b - k) / (1 - k))\n    k = round(100 * k)\n\n    return c, m, y, k",
    "docstring": "Simple RGB to CMYK conversion. Returns percentages of CMYK paint.\nhttps://www.programmingalgorithms.com/algorithm/rgb-to-cmyk/\n\nNote: this is a very popular algorithm that converts colors linearly and gives\nonly approximate results. Actual preparation for printing requires advanced color\nconversion considering the color profiles and parameters of the target device.\n\n>>> rgb_to_cmyk(255, 200, \"a\")\nTraceback (most recent call last):\n    ...\nValueError: Expected int, found (<class 'int'>, <class 'int'>, <class 'str'>)\n\n>>> rgb_to_cmyk(255, 255, 999)\nTraceback (most recent call last):\n    ...\nValueError: Expected int of the range 0..255\n\n>>> rgb_to_cmyk(255, 255, 255)  # white\n(0, 0, 0, 0)\n\n>>> rgb_to_cmyk(128, 128, 128)  # gray\n(0, 0, 0, 50)\n\n>>> rgb_to_cmyk(0, 0, 0)    # black\n(0, 0, 0, 100)\n\n>>> rgb_to_cmyk(255, 0, 0)  # red\n(0, 100, 100, 0)\n\n>>> rgb_to_cmyk(0, 255, 0)  # green\n(100, 0, 100, 0)\n\n>>> rgb_to_cmyk(0, 0, 255)    # blue\n(100, 100, 0, 0)"
  },
  {
    "function": "hsv_to_rgb",
    "code": "def hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]",
    "docstring": "Conversion from the HSV-representation to the RGB-representation.\nExpected RGB-values taken from\nhttps://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n>>> hsv_to_rgb(0, 0, 0)\n[0, 0, 0]\n>>> hsv_to_rgb(0, 0, 1)\n[255, 255, 255]\n>>> hsv_to_rgb(0, 1, 1)\n[255, 0, 0]\n>>> hsv_to_rgb(60, 1, 1)\n[255, 255, 0]\n>>> hsv_to_rgb(120, 1, 1)\n[0, 255, 0]\n>>> hsv_to_rgb(240, 1, 1)\n[0, 0, 255]\n>>> hsv_to_rgb(300, 1, 1)\n[255, 0, 255]\n>>> hsv_to_rgb(180, 0.5, 0.5)\n[64, 128, 128]\n>>> hsv_to_rgb(234, 0.14, 0.88)\n[193, 196, 224]\n>>> hsv_to_rgb(330, 0.75, 0.5)\n[128, 32, 80]"
  },
  {
    "function": "rgb_to_hsv",
    "code": "def rgb_to_hsv(red: int, green: int, blue: int) -> list[float]:\n    \"\"\"\n    Conversion from the RGB-representation to the HSV-representation.\n    The tested values are the reverse values from the hsv_to_rgb-doctests.\n    Function \"approximately_equal_hsv\" is needed because of small deviations due to\n    rounding for the RGB-values.\n\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 0), [0, 0, 0])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 255), [0, 0, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 0), [0, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 0), [60, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 255, 0), [120, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 255), [240, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 255), [300, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(64, 128, 128), [180, 0.5, 0.5])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(193, 196, 224), [234, 0.14, 0.88])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(128, 32, 80), [330, 0.75, 0.5])\n    True\n    \"\"\"\n    if red < 0 or red > 255:\n        raise Exception(\"red should be between 0 and 255\")\n\n    if green < 0 or green > 255:\n        raise Exception(\"green should be between 0 and 255\")\n\n    if blue < 0 or blue > 255:\n        raise Exception(\"blue should be between 0 and 255\")\n\n    float_red = red / 255\n    float_green = green / 255\n    float_blue = blue / 255\n    value = max(float_red, float_green, float_blue)\n    chroma = value - min(float_red, float_green, float_blue)\n    saturation = 0 if value == 0 else chroma / value\n\n    if chroma == 0:\n        hue = 0.0\n    elif value == float_red:\n        hue = 60 * (0 + (float_green - float_blue) / chroma)\n    elif value == float_green:\n        hue = 60 * (2 + (float_blue - float_red) / chroma)\n    else:\n        hue = 60 * (4 + (float_red - float_green) / chroma)\n\n    hue = (hue + 360) % 360\n\n    return [hue, saturation, value]",
    "docstring": "Conversion from the RGB-representation to the HSV-representation.\nThe tested values are the reverse values from the hsv_to_rgb-doctests.\nFunction \"approximately_equal_hsv\" is needed because of small deviations due to\nrounding for the RGB-values.\n\n>>> approximately_equal_hsv(rgb_to_hsv(0, 0, 0), [0, 0, 0])\nTrue\n>>> approximately_equal_hsv(rgb_to_hsv(255, 255, 255), [0, 0, 1])\nTrue\n>>> approximately_equal_hsv(rgb_to_hsv(255, 0, 0), [0, 1, 1])\nTrue\n>>> approximately_equal_hsv(rgb_to_hsv(255, 255, 0), [60, 1, 1])\nTrue\n>>> approximately_equal_hsv(rgb_to_hsv(0, 255, 0), [120, 1, 1])\nTrue\n>>> approximately_equal_hsv(rgb_to_hsv(0, 0, 255), [240, 1, 1])\nTrue\n>>> approximately_equal_hsv(rgb_to_hsv(255, 0, 255), [300, 1, 1])\nTrue\n>>> approximately_equal_hsv(rgb_to_hsv(64, 128, 128), [180, 0.5, 0.5])\nTrue\n>>> approximately_equal_hsv(rgb_to_hsv(193, 196, 224), [234, 0.14, 0.88])\nTrue\n>>> approximately_equal_hsv(rgb_to_hsv(128, 32, 80), [330, 0.75, 0.5])\nTrue"
  },
  {
    "function": "approximately_equal_hsv",
    "code": "def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value",
    "docstring": "Utility-function to check that two hsv-colors are approximately equal\n\n>>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\nTrue\n>>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\nTrue\n>>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\nFalse\n>>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\nFalse"
  },
  {
    "function": "roman_to_int",
    "code": "def roman_to_int(roman: str) -> int:\n    \"\"\"\n    LeetCode No. 13 Roman to Integer\n    Given a roman numeral, convert it to an integer.\n    Input is guaranteed to be within the range from 1 to 3999.\n    https://en.wikipedia.org/wiki/Roman_numerals\n    >>> tests = {\"III\": 3, \"CLIV\": 154, \"MIX\": 1009, \"MMD\": 2500, \"MMMCMXCIX\": 3999}\n    >>> all(roman_to_int(key) == value for key, value in tests.items())\n    True\n    \"\"\"\n    vals = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n    total = 0\n    place = 0\n    while place < len(roman):\n        if (place + 1 < len(roman)) and (vals[roman[place]] < vals[roman[place + 1]]):\n            total += vals[roman[place + 1]] - vals[roman[place]]\n            place += 2\n        else:\n            total += vals[roman[place]]\n            place += 1\n    return total",
    "docstring": "LeetCode No. 13 Roman to Integer\nGiven a roman numeral, convert it to an integer.\nInput is guaranteed to be within the range from 1 to 3999.\nhttps://en.wikipedia.org/wiki/Roman_numerals\n>>> tests = {\"III\": 3, \"CLIV\": 154, \"MIX\": 1009, \"MMD\": 2500, \"MMMCMXCIX\": 3999}\n>>> all(roman_to_int(key) == value for key, value in tests.items())\nTrue"
  },
  {
    "function": "int_to_roman",
    "code": "def int_to_roman(number: int) -> str:\n    \"\"\"\n    Given a integer, convert it to an roman numeral.\n    https://en.wikipedia.org/wiki/Roman_numerals\n    >>> tests = {\"III\": 3, \"CLIV\": 154, \"MIX\": 1009, \"MMD\": 2500, \"MMMCMXCIX\": 3999}\n    >>> all(int_to_roman(value) == key for key, value in tests.items())\n    True\n    \"\"\"\n    result = []\n    for arabic, roman in ROMAN:\n        (factor, number) = divmod(number, arabic)\n        result.append(roman * factor)\n        if number == 0:\n            break\n    return \"\".join(result)",
    "docstring": "Given a integer, convert it to an roman numeral.\nhttps://en.wikipedia.org/wiki/Roman_numerals\n>>> tests = {\"III\": 3, \"CLIV\": 154, \"MIX\": 1009, \"MMD\": 2500, \"MMMCMXCIX\": 3999}\n>>> all(int_to_roman(value) == key for key, value in tests.items())\nTrue"
  },
  {
    "function": "convert_speed",
    "code": "def convert_speed(speed: float, unit_from: str, unit_to: str) -> float:\n    \"\"\"\n    Convert speed from one unit to another using the speed_chart above.\n\n    \"km/h\": 1.0,\n    \"m/s\": 3.6,\n    \"mph\": 1.609344,\n    \"knot\": 1.852,\n\n    >>> convert_speed(100, \"km/h\", \"m/s\")\n    27.778\n    >>> convert_speed(100, \"km/h\", \"mph\")\n    62.137\n    >>> convert_speed(100, \"km/h\", \"knot\")\n    53.996\n    >>> convert_speed(100, \"m/s\", \"km/h\")\n    360.0\n    >>> convert_speed(100, \"m/s\", \"mph\")\n    223.694\n    >>> convert_speed(100, \"m/s\", \"knot\")\n    194.384\n    >>> convert_speed(100, \"mph\", \"km/h\")\n    160.934\n    >>> convert_speed(100, \"mph\", \"m/s\")\n    44.704\n    >>> convert_speed(100, \"mph\", \"knot\")\n    86.898\n    >>> convert_speed(100, \"knot\", \"km/h\")\n    185.2\n    >>> convert_speed(100, \"knot\", \"m/s\")\n    51.444\n    >>> convert_speed(100, \"knot\", \"mph\")\n    115.078\n    \"\"\"\n    if unit_to not in speed_chart or unit_from not in speed_chart_inverse:\n        msg = (\n            f\"Incorrect 'from_type' or 'to_type' value: {unit_from!r}, {unit_to!r}\\n\"\n            f\"Valid values are: {', '.join(speed_chart_inverse)}\"\n        )\n        raise ValueError(msg)\n    return round(speed * speed_chart[unit_from] * speed_chart_inverse[unit_to], 3)",
    "docstring": "Convert speed from one unit to another using the speed_chart above.\n\n\"km/h\": 1.0,\n\"m/s\": 3.6,\n\"mph\": 1.609344,\n\"knot\": 1.852,\n\n>>> convert_speed(100, \"km/h\", \"m/s\")\n27.778\n>>> convert_speed(100, \"km/h\", \"mph\")\n62.137\n>>> convert_speed(100, \"km/h\", \"knot\")\n53.996\n>>> convert_speed(100, \"m/s\", \"km/h\")\n360.0\n>>> convert_speed(100, \"m/s\", \"mph\")\n223.694\n>>> convert_speed(100, \"m/s\", \"knot\")\n194.384\n>>> convert_speed(100, \"mph\", \"km/h\")\n160.934\n>>> convert_speed(100, \"mph\", \"m/s\")\n44.704\n>>> convert_speed(100, \"mph\", \"knot\")\n86.898\n>>> convert_speed(100, \"knot\", \"km/h\")\n185.2\n>>> convert_speed(100, \"knot\", \"m/s\")\n51.444\n>>> convert_speed(100, \"knot\", \"mph\")\n115.078"
  },
  {
    "function": "celsius_to_fahrenheit",
    "code": "def celsius_to_fahrenheit(celsius: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Celsius to Fahrenheit and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n\n    >>> celsius_to_fahrenheit(273.354, 3)\n    524.037\n    >>> celsius_to_fahrenheit(273.354, 0)\n    524.0\n    >>> celsius_to_fahrenheit(-40.0)\n    -40.0\n    >>> celsius_to_fahrenheit(-20.0)\n    -4.0\n    >>> celsius_to_fahrenheit(0)\n    32.0\n    >>> celsius_to_fahrenheit(20)\n    68.0\n    >>> celsius_to_fahrenheit(\"40\")\n    104.0\n    >>> celsius_to_fahrenheit(\"celsius\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'celsius'\n    \"\"\"\n    return round((float(celsius) * 9 / 5) + 32, ndigits)",
    "docstring": "Convert a given value from Celsius to Fahrenheit and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Celsius\nWikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n\n>>> celsius_to_fahrenheit(273.354, 3)\n524.037\n>>> celsius_to_fahrenheit(273.354, 0)\n524.0\n>>> celsius_to_fahrenheit(-40.0)\n-40.0\n>>> celsius_to_fahrenheit(-20.0)\n-4.0\n>>> celsius_to_fahrenheit(0)\n32.0\n>>> celsius_to_fahrenheit(20)\n68.0\n>>> celsius_to_fahrenheit(\"40\")\n104.0\n>>> celsius_to_fahrenheit(\"celsius\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'celsius'"
  },
  {
    "function": "celsius_to_kelvin",
    "code": "def celsius_to_kelvin(celsius: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Celsius to Kelvin and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n\n    >>> celsius_to_kelvin(273.354, 3)\n    546.504\n    >>> celsius_to_kelvin(273.354, 0)\n    547.0\n    >>> celsius_to_kelvin(0)\n    273.15\n    >>> celsius_to_kelvin(20.0)\n    293.15\n    >>> celsius_to_kelvin(\"40\")\n    313.15\n    >>> celsius_to_kelvin(\"celsius\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'celsius'\n    \"\"\"\n    return round(float(celsius) + 273.15, ndigits)",
    "docstring": "Convert a given value from Celsius to Kelvin and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Celsius\nWikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n\n>>> celsius_to_kelvin(273.354, 3)\n546.504\n>>> celsius_to_kelvin(273.354, 0)\n547.0\n>>> celsius_to_kelvin(0)\n273.15\n>>> celsius_to_kelvin(20.0)\n293.15\n>>> celsius_to_kelvin(\"40\")\n313.15\n>>> celsius_to_kelvin(\"celsius\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'celsius'"
  },
  {
    "function": "celsius_to_rankine",
    "code": "def celsius_to_rankine(celsius: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Celsius to Rankine and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n\n    >>> celsius_to_rankine(273.354, 3)\n    983.707\n    >>> celsius_to_rankine(273.354, 0)\n    984.0\n    >>> celsius_to_rankine(0)\n    491.67\n    >>> celsius_to_rankine(20.0)\n    527.67\n    >>> celsius_to_rankine(\"40\")\n    563.67\n    >>> celsius_to_rankine(\"celsius\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'celsius'\n    \"\"\"\n    return round((float(celsius) * 9 / 5) + 491.67, ndigits)",
    "docstring": "Convert a given value from Celsius to Rankine and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Celsius\nWikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n\n>>> celsius_to_rankine(273.354, 3)\n983.707\n>>> celsius_to_rankine(273.354, 0)\n984.0\n>>> celsius_to_rankine(0)\n491.67\n>>> celsius_to_rankine(20.0)\n527.67\n>>> celsius_to_rankine(\"40\")\n563.67\n>>> celsius_to_rankine(\"celsius\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'celsius'"
  },
  {
    "function": "fahrenheit_to_celsius",
    "code": "def fahrenheit_to_celsius(fahrenheit: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Fahrenheit to Celsius and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n\n    >>> fahrenheit_to_celsius(273.354, 3)\n    134.086\n    >>> fahrenheit_to_celsius(273.354, 0)\n    134.0\n    >>> fahrenheit_to_celsius(0)\n    -17.78\n    >>> fahrenheit_to_celsius(20.0)\n    -6.67\n    >>> fahrenheit_to_celsius(40.0)\n    4.44\n    >>> fahrenheit_to_celsius(60)\n    15.56\n    >>> fahrenheit_to_celsius(80)\n    26.67\n    >>> fahrenheit_to_celsius(\"100\")\n    37.78\n    >>> fahrenheit_to_celsius(\"fahrenheit\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'fahrenheit'\n    \"\"\"\n    return round((float(fahrenheit) - 32) * 5 / 9, ndigits)",
    "docstring": "Convert a given value from Fahrenheit to Celsius and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\nWikipedia reference: https://en.wikipedia.org/wiki/Celsius\n\n>>> fahrenheit_to_celsius(273.354, 3)\n134.086\n>>> fahrenheit_to_celsius(273.354, 0)\n134.0\n>>> fahrenheit_to_celsius(0)\n-17.78\n>>> fahrenheit_to_celsius(20.0)\n-6.67\n>>> fahrenheit_to_celsius(40.0)\n4.44\n>>> fahrenheit_to_celsius(60)\n15.56\n>>> fahrenheit_to_celsius(80)\n26.67\n>>> fahrenheit_to_celsius(\"100\")\n37.78\n>>> fahrenheit_to_celsius(\"fahrenheit\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'fahrenheit'"
  },
  {
    "function": "fahrenheit_to_kelvin",
    "code": "def fahrenheit_to_kelvin(fahrenheit: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Fahrenheit to Kelvin and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n\n    >>> fahrenheit_to_kelvin(273.354, 3)\n    407.236\n    >>> fahrenheit_to_kelvin(273.354, 0)\n    407.0\n    >>> fahrenheit_to_kelvin(0)\n    255.37\n    >>> fahrenheit_to_kelvin(20.0)\n    266.48\n    >>> fahrenheit_to_kelvin(40.0)\n    277.59\n    >>> fahrenheit_to_kelvin(60)\n    288.71\n    >>> fahrenheit_to_kelvin(80)\n    299.82\n    >>> fahrenheit_to_kelvin(\"100\")\n    310.93\n    >>> fahrenheit_to_kelvin(\"fahrenheit\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'fahrenheit'\n    \"\"\"\n    return round(((float(fahrenheit) - 32) * 5 / 9) + 273.15, ndigits)",
    "docstring": "Convert a given value from Fahrenheit to Kelvin and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\nWikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n\n>>> fahrenheit_to_kelvin(273.354, 3)\n407.236\n>>> fahrenheit_to_kelvin(273.354, 0)\n407.0\n>>> fahrenheit_to_kelvin(0)\n255.37\n>>> fahrenheit_to_kelvin(20.0)\n266.48\n>>> fahrenheit_to_kelvin(40.0)\n277.59\n>>> fahrenheit_to_kelvin(60)\n288.71\n>>> fahrenheit_to_kelvin(80)\n299.82\n>>> fahrenheit_to_kelvin(\"100\")\n310.93\n>>> fahrenheit_to_kelvin(\"fahrenheit\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'fahrenheit'"
  },
  {
    "function": "fahrenheit_to_rankine",
    "code": "def fahrenheit_to_rankine(fahrenheit: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Fahrenheit to Rankine and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n\n    >>> fahrenheit_to_rankine(273.354, 3)\n    733.024\n    >>> fahrenheit_to_rankine(273.354, 0)\n    733.0\n    >>> fahrenheit_to_rankine(0)\n    459.67\n    >>> fahrenheit_to_rankine(20.0)\n    479.67\n    >>> fahrenheit_to_rankine(40.0)\n    499.67\n    >>> fahrenheit_to_rankine(60)\n    519.67\n    >>> fahrenheit_to_rankine(80)\n    539.67\n    >>> fahrenheit_to_rankine(\"100\")\n    559.67\n    >>> fahrenheit_to_rankine(\"fahrenheit\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'fahrenheit'\n    \"\"\"\n    return round(float(fahrenheit) + 459.67, ndigits)",
    "docstring": "Convert a given value from Fahrenheit to Rankine and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\nWikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n\n>>> fahrenheit_to_rankine(273.354, 3)\n733.024\n>>> fahrenheit_to_rankine(273.354, 0)\n733.0\n>>> fahrenheit_to_rankine(0)\n459.67\n>>> fahrenheit_to_rankine(20.0)\n479.67\n>>> fahrenheit_to_rankine(40.0)\n499.67\n>>> fahrenheit_to_rankine(60)\n519.67\n>>> fahrenheit_to_rankine(80)\n539.67\n>>> fahrenheit_to_rankine(\"100\")\n559.67\n>>> fahrenheit_to_rankine(\"fahrenheit\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'fahrenheit'"
  },
  {
    "function": "kelvin_to_celsius",
    "code": "def kelvin_to_celsius(kelvin: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Kelvin to Celsius and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n\n    >>> kelvin_to_celsius(273.354, 3)\n    0.204\n    >>> kelvin_to_celsius(273.354, 0)\n    0.0\n    >>> kelvin_to_celsius(273.15)\n    0.0\n    >>> kelvin_to_celsius(300)\n    26.85\n    >>> kelvin_to_celsius(\"315.5\")\n    42.35\n    >>> kelvin_to_celsius(\"kelvin\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'kelvin'\n    \"\"\"\n    return round(float(kelvin) - 273.15, ndigits)",
    "docstring": "Convert a given value from Kelvin to Celsius and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Kelvin\nWikipedia reference: https://en.wikipedia.org/wiki/Celsius\n\n>>> kelvin_to_celsius(273.354, 3)\n0.204\n>>> kelvin_to_celsius(273.354, 0)\n0.0\n>>> kelvin_to_celsius(273.15)\n0.0\n>>> kelvin_to_celsius(300)\n26.85\n>>> kelvin_to_celsius(\"315.5\")\n42.35\n>>> kelvin_to_celsius(\"kelvin\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'kelvin'"
  },
  {
    "function": "kelvin_to_fahrenheit",
    "code": "def kelvin_to_fahrenheit(kelvin: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Kelvin to Fahrenheit and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n\n    >>> kelvin_to_fahrenheit(273.354, 3)\n    32.367\n    >>> kelvin_to_fahrenheit(273.354, 0)\n    32.0\n    >>> kelvin_to_fahrenheit(273.15)\n    32.0\n    >>> kelvin_to_fahrenheit(300)\n    80.33\n    >>> kelvin_to_fahrenheit(\"315.5\")\n    108.23\n    >>> kelvin_to_fahrenheit(\"kelvin\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'kelvin'\n    \"\"\"\n    return round(((float(kelvin) - 273.15) * 9 / 5) + 32, ndigits)",
    "docstring": "Convert a given value from Kelvin to Fahrenheit and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Kelvin\nWikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n\n>>> kelvin_to_fahrenheit(273.354, 3)\n32.367\n>>> kelvin_to_fahrenheit(273.354, 0)\n32.0\n>>> kelvin_to_fahrenheit(273.15)\n32.0\n>>> kelvin_to_fahrenheit(300)\n80.33\n>>> kelvin_to_fahrenheit(\"315.5\")\n108.23\n>>> kelvin_to_fahrenheit(\"kelvin\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'kelvin'"
  },
  {
    "function": "kelvin_to_rankine",
    "code": "def kelvin_to_rankine(kelvin: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Kelvin to Rankine and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n\n    >>> kelvin_to_rankine(273.354, 3)\n    492.037\n    >>> kelvin_to_rankine(273.354, 0)\n    492.0\n    >>> kelvin_to_rankine(0)\n    0.0\n    >>> kelvin_to_rankine(20.0)\n    36.0\n    >>> kelvin_to_rankine(\"40\")\n    72.0\n    >>> kelvin_to_rankine(\"kelvin\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'kelvin'\n    \"\"\"\n    return round((float(kelvin) * 9 / 5), ndigits)",
    "docstring": "Convert a given value from Kelvin to Rankine and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Kelvin\nWikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n\n>>> kelvin_to_rankine(273.354, 3)\n492.037\n>>> kelvin_to_rankine(273.354, 0)\n492.0\n>>> kelvin_to_rankine(0)\n0.0\n>>> kelvin_to_rankine(20.0)\n36.0\n>>> kelvin_to_rankine(\"40\")\n72.0\n>>> kelvin_to_rankine(\"kelvin\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'kelvin'"
  },
  {
    "function": "rankine_to_celsius",
    "code": "def rankine_to_celsius(rankine: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Rankine to Celsius and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n\n    >>> rankine_to_celsius(273.354, 3)\n    -121.287\n    >>> rankine_to_celsius(273.354, 0)\n    -121.0\n    >>> rankine_to_celsius(273.15)\n    -121.4\n    >>> rankine_to_celsius(300)\n    -106.48\n    >>> rankine_to_celsius(\"315.5\")\n    -97.87\n    >>> rankine_to_celsius(\"rankine\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'rankine'\n    \"\"\"\n    return round((float(rankine) - 491.67) * 5 / 9, ndigits)",
    "docstring": "Convert a given value from Rankine to Celsius and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\nWikipedia reference: https://en.wikipedia.org/wiki/Celsius\n\n>>> rankine_to_celsius(273.354, 3)\n-121.287\n>>> rankine_to_celsius(273.354, 0)\n-121.0\n>>> rankine_to_celsius(273.15)\n-121.4\n>>> rankine_to_celsius(300)\n-106.48\n>>> rankine_to_celsius(\"315.5\")\n-97.87\n>>> rankine_to_celsius(\"rankine\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'rankine'"
  },
  {
    "function": "rankine_to_fahrenheit",
    "code": "def rankine_to_fahrenheit(rankine: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Rankine to Fahrenheit and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n\n    >>> rankine_to_fahrenheit(273.15)\n    -186.52\n    >>> rankine_to_fahrenheit(300)\n    -159.67\n    >>> rankine_to_fahrenheit(\"315.5\")\n    -144.17\n    >>> rankine_to_fahrenheit(\"rankine\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'rankine'\n    \"\"\"\n    return round(float(rankine) - 459.67, ndigits)",
    "docstring": "Convert a given value from Rankine to Fahrenheit and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\nWikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n\n>>> rankine_to_fahrenheit(273.15)\n-186.52\n>>> rankine_to_fahrenheit(300)\n-159.67\n>>> rankine_to_fahrenheit(\"315.5\")\n-144.17\n>>> rankine_to_fahrenheit(\"rankine\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'rankine'"
  },
  {
    "function": "rankine_to_kelvin",
    "code": "def rankine_to_kelvin(rankine: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Rankine to Kelvin and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n\n    >>> rankine_to_kelvin(0)\n    0.0\n    >>> rankine_to_kelvin(20.0)\n    11.11\n    >>> rankine_to_kelvin(\"40\")\n    22.22\n    >>> rankine_to_kelvin(\"rankine\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'rankine'\n    \"\"\"\n    return round((float(rankine) * 5 / 9), ndigits)",
    "docstring": "Convert a given value from Rankine to Kelvin and round it to 2 decimal places.\nWikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\nWikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n\n>>> rankine_to_kelvin(0)\n0.0\n>>> rankine_to_kelvin(20.0)\n11.11\n>>> rankine_to_kelvin(\"40\")\n22.22\n>>> rankine_to_kelvin(\"rankine\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'rankine'"
  },
  {
    "function": "reaumur_to_kelvin",
    "code": "def reaumur_to_kelvin(reaumur: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from reaumur to Kelvin and round it to 2 decimal places.\n    Reference:- http://www.csgnetwork.com/temp2conv.html\n\n    >>> reaumur_to_kelvin(0)\n    273.15\n    >>> reaumur_to_kelvin(20.0)\n    298.15\n    >>> reaumur_to_kelvin(40)\n    323.15\n    >>> reaumur_to_kelvin(\"reaumur\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'reaumur'\n    \"\"\"\n    return round((float(reaumur) * 1.25 + 273.15), ndigits)",
    "docstring": "Convert a given value from reaumur to Kelvin and round it to 2 decimal places.\nReference:- http://www.csgnetwork.com/temp2conv.html\n\n>>> reaumur_to_kelvin(0)\n273.15\n>>> reaumur_to_kelvin(20.0)\n298.15\n>>> reaumur_to_kelvin(40)\n323.15\n>>> reaumur_to_kelvin(\"reaumur\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'reaumur'"
  },
  {
    "function": "reaumur_to_fahrenheit",
    "code": "def reaumur_to_fahrenheit(reaumur: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from reaumur to fahrenheit and round it to 2 decimal places.\n    Reference:- http://www.csgnetwork.com/temp2conv.html\n\n    >>> reaumur_to_fahrenheit(0)\n    32.0\n    >>> reaumur_to_fahrenheit(20.0)\n    77.0\n    >>> reaumur_to_fahrenheit(40)\n    122.0\n    >>> reaumur_to_fahrenheit(\"reaumur\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'reaumur'\n    \"\"\"\n    return round((float(reaumur) * 2.25 + 32), ndigits)",
    "docstring": "Convert a given value from reaumur to fahrenheit and round it to 2 decimal places.\nReference:- http://www.csgnetwork.com/temp2conv.html\n\n>>> reaumur_to_fahrenheit(0)\n32.0\n>>> reaumur_to_fahrenheit(20.0)\n77.0\n>>> reaumur_to_fahrenheit(40)\n122.0\n>>> reaumur_to_fahrenheit(\"reaumur\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'reaumur'"
  },
  {
    "function": "reaumur_to_celsius",
    "code": "def reaumur_to_celsius(reaumur: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from reaumur to celsius and round it to 2 decimal places.\n    Reference:- http://www.csgnetwork.com/temp2conv.html\n\n    >>> reaumur_to_celsius(0)\n    0.0\n    >>> reaumur_to_celsius(20.0)\n    25.0\n    >>> reaumur_to_celsius(40)\n    50.0\n    >>> reaumur_to_celsius(\"reaumur\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'reaumur'\n    \"\"\"\n    return round((float(reaumur) * 1.25), ndigits)",
    "docstring": "Convert a given value from reaumur to celsius and round it to 2 decimal places.\nReference:- http://www.csgnetwork.com/temp2conv.html\n\n>>> reaumur_to_celsius(0)\n0.0\n>>> reaumur_to_celsius(20.0)\n25.0\n>>> reaumur_to_celsius(40)\n50.0\n>>> reaumur_to_celsius(\"reaumur\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'reaumur'"
  },
  {
    "function": "reaumur_to_rankine",
    "code": "def reaumur_to_rankine(reaumur: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from reaumur to rankine and round it to 2 decimal places.\n    Reference:- http://www.csgnetwork.com/temp2conv.html\n\n    >>> reaumur_to_rankine(0)\n    491.67\n    >>> reaumur_to_rankine(20.0)\n    536.67\n    >>> reaumur_to_rankine(40)\n    581.67\n    >>> reaumur_to_rankine(\"reaumur\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'reaumur'\n    \"\"\"\n    return round((float(reaumur) * 2.25 + 32 + 459.67), ndigits)",
    "docstring": "Convert a given value from reaumur to rankine and round it to 2 decimal places.\nReference:- http://www.csgnetwork.com/temp2conv.html\n\n>>> reaumur_to_rankine(0)\n491.67\n>>> reaumur_to_rankine(20.0)\n536.67\n>>> reaumur_to_rankine(40)\n581.67\n>>> reaumur_to_rankine(\"reaumur\")\nTraceback (most recent call last):\n    ...\nValueError: could not convert string to float: 'reaumur'"
  },
  {
    "function": "convert_time",
    "code": "def convert_time(time_value: float, unit_from: str, unit_to: str) -> float:\n    \"\"\"\n    Convert time from one unit to another using the time_chart above.\n\n    >>> convert_time(3600, \"seconds\", \"hours\")\n    1.0\n    >>> convert_time(3500, \"Seconds\", \"Hours\")\n    0.972\n    >>> convert_time(1, \"DaYs\", \"hours\")\n    24.0\n    >>> convert_time(120, \"minutes\", \"SeCoNdS\")\n    7200.0\n    >>> convert_time(2, \"WEEKS\", \"days\")\n    14.0\n    >>> convert_time(0.5, \"hours\", \"MINUTES\")\n    30.0\n    >>> convert_time(-3600, \"seconds\", \"hours\")\n    Traceback (most recent call last):\n        ...\n    ValueError: 'time_value' must be a non-negative number.\n    >>> convert_time(\"Hello\", \"hours\", \"minutes\")\n    Traceback (most recent call last):\n        ...\n    ValueError: 'time_value' must be a non-negative number.\n    >>> convert_time([0, 1, 2], \"weeks\", \"days\")\n    Traceback (most recent call last):\n        ...\n    ValueError: 'time_value' must be a non-negative number.\n    >>> convert_time(1, \"cool\", \"century\")  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid unit cool is not in seconds, minutes, hours, days, weeks, ...\n    >>> convert_time(1, \"seconds\", \"hot\")  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid unit hot is not in seconds, minutes, hours, days, weeks, ...\n    \"\"\"\n    if not isinstance(time_value, (int, float)) or time_value < 0:\n        msg = \"'time_value' must be a non-negative number.\"\n        raise ValueError(msg)\n\n    unit_from = unit_from.lower()\n    unit_to = unit_to.lower()\n    if unit_from not in time_chart or unit_to not in time_chart:\n        invalid_unit = unit_from if unit_from not in time_chart else unit_to\n        msg = f\"Invalid unit {invalid_unit} is not in {', '.join(time_chart)}.\"\n        raise ValueError(msg)\n\n    return round(\n        time_value * time_chart[unit_from] * time_chart_inverse[unit_to],\n        3,\n    )",
    "docstring": "Convert time from one unit to another using the time_chart above.\n\n>>> convert_time(3600, \"seconds\", \"hours\")\n1.0\n>>> convert_time(3500, \"Seconds\", \"Hours\")\n0.972\n>>> convert_time(1, \"DaYs\", \"hours\")\n24.0\n>>> convert_time(120, \"minutes\", \"SeCoNdS\")\n7200.0\n>>> convert_time(2, \"WEEKS\", \"days\")\n14.0\n>>> convert_time(0.5, \"hours\", \"MINUTES\")\n30.0\n>>> convert_time(-3600, \"seconds\", \"hours\")\nTraceback (most recent call last):\n    ...\nValueError: 'time_value' must be a non-negative number.\n>>> convert_time(\"Hello\", \"hours\", \"minutes\")\nTraceback (most recent call last):\n    ...\nValueError: 'time_value' must be a non-negative number.\n>>> convert_time([0, 1, 2], \"weeks\", \"days\")\nTraceback (most recent call last):\n    ...\nValueError: 'time_value' must be a non-negative number.\n>>> convert_time(1, \"cool\", \"century\")  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nValueError: Invalid unit cool is not in seconds, minutes, hours, days, weeks, ...\n>>> convert_time(1, \"seconds\", \"hot\")  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nValueError: Invalid unit hot is not in seconds, minutes, hours, days, weeks, ..."
  },
  {
    "function": "volume_conversion",
    "code": "def volume_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between volume units.\n    >>> volume_conversion(4, \"cubic meter\", \"litre\")\n    4000\n    >>> volume_conversion(1, \"litre\", \"gallon\")\n    0.264172\n    >>> volume_conversion(1, \"kilolitre\", \"cubic meter\")\n    1\n    >>> volume_conversion(3, \"gallon\", \"cubic yard\")\n    0.017814279\n    >>> volume_conversion(2, \"cubic yard\", \"litre\")\n    1529.1\n    >>> volume_conversion(4, \"cubic foot\", \"cup\")\n    473.396\n    >>> volume_conversion(1, \"cup\", \"kilolitre\")\n    0.000236588\n    >>> volume_conversion(4, \"wrongUnit\", \"litre\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\n    cubic meter, litre, kilolitre, gallon, cubic yard, cubic foot, cup\n    \"\"\"\n    if from_type not in METRIC_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"\n            + \", \".join(METRIC_CONVERSION)\n        )\n    if to_type not in METRIC_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"\n            + \", \".join(METRIC_CONVERSION)\n        )\n    return (\n        value\n        * METRIC_CONVERSION[from_type].from_factor\n        * METRIC_CONVERSION[to_type].to_factor\n    )",
    "docstring": "Conversion between volume units.\n>>> volume_conversion(4, \"cubic meter\", \"litre\")\n4000\n>>> volume_conversion(1, \"litre\", \"gallon\")\n0.264172\n>>> volume_conversion(1, \"kilolitre\", \"cubic meter\")\n1\n>>> volume_conversion(3, \"gallon\", \"cubic yard\")\n0.017814279\n>>> volume_conversion(2, \"cubic yard\", \"litre\")\n1529.1\n>>> volume_conversion(4, \"cubic foot\", \"cup\")\n473.396\n>>> volume_conversion(1, \"cup\", \"kilolitre\")\n0.000236588\n>>> volume_conversion(4, \"wrongUnit\", \"litre\")\nTraceback (most recent call last):\n    ...\nValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\ncubic meter, litre, kilolitre, gallon, cubic yard, cubic foot, cup"
  },
  {
    "function": "weight_conversion",
    "code": "def weight_conversion(from_type: str, to_type: str, value: float) -> float:\n    \"\"\"\n    Conversion of weight unit with the help of KILOGRAM_CHART\n\n    \"kilogram\" : 1,\n    \"gram\" : pow(10, 3),\n    \"milligram\" : pow(10, 6),\n    \"metric-ton\" : pow(10, -3),\n    \"long-ton\" : 0.0009842073,\n    \"short-ton\" : 0.0011023122,\n    \"pound\" : 2.2046244202,\n    \"stone\": 0.1574731728,\n    \"ounce\" : 35.273990723,\n    \"carrat\" : 5000,\n    \"atomic-mass-unit\" : 6.022136652E+26\n\n    >>> weight_conversion(\"kilogram\",\"kilogram\",4)\n    4\n    >>> weight_conversion(\"kilogram\",\"gram\",1)\n    1000\n    >>> weight_conversion(\"kilogram\",\"milligram\",4)\n    4000000\n    >>> weight_conversion(\"kilogram\",\"metric-ton\",4)\n    0.004\n    >>> weight_conversion(\"kilogram\",\"long-ton\",3)\n    0.0029526219\n    >>> weight_conversion(\"kilogram\",\"short-ton\",1)\n    0.0011023122\n    >>> weight_conversion(\"kilogram\",\"pound\",4)\n    8.8184976808\n    >>> weight_conversion(\"kilogram\",\"stone\",5)\n    0.7873658640000001\n    >>> weight_conversion(\"kilogram\",\"ounce\",4)\n    141.095962892\n    >>> weight_conversion(\"kilogram\",\"carrat\",3)\n    15000\n    >>> weight_conversion(\"kilogram\",\"atomic-mass-unit\",1)\n    6.022136652e+26\n    >>> weight_conversion(\"gram\",\"kilogram\",1)\n    0.001\n    >>> weight_conversion(\"gram\",\"gram\",3)\n    3.0\n    >>> weight_conversion(\"gram\",\"milligram\",2)\n    2000.0\n    >>> weight_conversion(\"gram\",\"metric-ton\",4)\n    4e-06\n    >>> weight_conversion(\"gram\",\"long-ton\",3)\n    2.9526219e-06\n    >>> weight_conversion(\"gram\",\"short-ton\",3)\n    3.3069366000000003e-06\n    >>> weight_conversion(\"gram\",\"pound\",3)\n    0.0066138732606\n    >>> weight_conversion(\"gram\",\"stone\",4)\n    0.0006298926912000001\n    >>> weight_conversion(\"gram\",\"ounce\",1)\n    0.035273990723\n    >>> weight_conversion(\"gram\",\"carrat\",2)\n    10.0\n    >>> weight_conversion(\"gram\",\"atomic-mass-unit\",1)\n    6.022136652e+23\n    >>> weight_conversion(\"milligram\",\"kilogram\",1)\n    1e-06\n    >>> weight_conversion(\"milligram\",\"gram\",2)\n    0.002\n    >>> weight_conversion(\"milligram\",\"milligram\",3)\n    3.0\n    >>> weight_conversion(\"milligram\",\"metric-ton\",3)\n    3e-09\n    >>> weight_conversion(\"milligram\",\"long-ton\",3)\n    2.9526219e-09\n    >>> weight_conversion(\"milligram\",\"short-ton\",1)\n    1.1023122e-09\n    >>> weight_conversion(\"milligram\",\"pound\",3)\n    6.6138732605999995e-06\n    >>> weight_conversion(\"milligram\",\"ounce\",2)\n    7.054798144599999e-05\n    >>> weight_conversion(\"milligram\",\"carrat\",1)\n    0.005\n    >>> weight_conversion(\"milligram\",\"atomic-mass-unit\",1)\n    6.022136652e+20\n    >>> weight_conversion(\"metric-ton\",\"kilogram\",2)\n    2000\n    >>> weight_conversion(\"metric-ton\",\"gram\",2)\n    2000000\n    >>> weight_conversion(\"metric-ton\",\"milligram\",3)\n    3000000000\n    >>> weight_conversion(\"metric-ton\",\"metric-ton\",2)\n    2.0\n    >>> weight_conversion(\"metric-ton\",\"long-ton\",3)\n    2.9526219\n    >>> weight_conversion(\"metric-ton\",\"short-ton\",2)\n    2.2046244\n    >>> weight_conversion(\"metric-ton\",\"pound\",3)\n    6613.8732606\n    >>> weight_conversion(\"metric-ton\",\"ounce\",4)\n    141095.96289199998\n    >>> weight_conversion(\"metric-ton\",\"carrat\",4)\n    20000000\n    >>> weight_conversion(\"metric-ton\",\"atomic-mass-unit\",1)\n    6.022136652e+29\n    >>> weight_conversion(\"long-ton\",\"kilogram\",4)\n    4064.18432\n    >>> weight_conversion(\"long-ton\",\"gram\",4)\n    4064184.32\n    >>> weight_conversion(\"long-ton\",\"milligram\",3)\n    3048138240.0\n    >>> weight_conversion(\"long-ton\",\"metric-ton\",4)\n    4.06418432\n    >>> weight_conversion(\"long-ton\",\"long-ton\",3)\n    2.999999907217152\n    >>> weight_conversion(\"long-ton\",\"short-ton\",1)\n    1.119999989746176\n    >>> weight_conversion(\"long-ton\",\"pound\",3)\n    6720.000000049448\n    >>> weight_conversion(\"long-ton\",\"ounce\",1)\n    35840.000000060514\n    >>> weight_conversion(\"long-ton\",\"carrat\",4)\n    20320921.599999998\n    >>> weight_conversion(\"long-ton\",\"atomic-mass-unit\",4)\n    2.4475073353955697e+30\n    >>> weight_conversion(\"short-ton\",\"kilogram\",3)\n    2721.5519999999997\n    >>> weight_conversion(\"short-ton\",\"gram\",3)\n    2721552.0\n    >>> weight_conversion(\"short-ton\",\"milligram\",1)\n    907184000.0\n    >>> weight_conversion(\"short-ton\",\"metric-ton\",4)\n    3.628736\n    >>> weight_conversion(\"short-ton\",\"long-ton\",3)\n    2.6785713457296\n    >>> weight_conversion(\"short-ton\",\"short-ton\",3)\n    2.9999999725344\n    >>> weight_conversion(\"short-ton\",\"pound\",2)\n    4000.0000000294335\n    >>> weight_conversion(\"short-ton\",\"ounce\",4)\n    128000.00000021611\n    >>> weight_conversion(\"short-ton\",\"carrat\",4)\n    18143680.0\n    >>> weight_conversion(\"short-ton\",\"atomic-mass-unit\",1)\n    5.463186016507968e+29\n    >>> weight_conversion(\"pound\",\"kilogram\",4)\n    1.814368\n    >>> weight_conversion(\"pound\",\"gram\",2)\n    907.184\n    >>> weight_conversion(\"pound\",\"milligram\",3)\n    1360776.0\n    >>> weight_conversion(\"pound\",\"metric-ton\",3)\n    0.001360776\n    >>> weight_conversion(\"pound\",\"long-ton\",2)\n    0.0008928571152432\n    >>> weight_conversion(\"pound\",\"short-ton\",1)\n    0.0004999999954224\n    >>> weight_conversion(\"pound\",\"pound\",3)\n    3.0000000000220752\n    >>> weight_conversion(\"pound\",\"ounce\",1)\n    16.000000000027015\n    >>> weight_conversion(\"pound\",\"carrat\",1)\n    2267.96\n    >>> weight_conversion(\"pound\",\"atomic-mass-unit\",4)\n    1.0926372033015936e+27\n    >>> weight_conversion(\"stone\",\"kilogram\",5)\n    31.751450000000002\n    >>> weight_conversion(\"stone\",\"gram\",2)\n    12700.58\n    >>> weight_conversion(\"stone\",\"milligram\",3)\n    19050870.0\n    >>> weight_conversion(\"stone\",\"metric-ton\",3)\n    0.01905087\n    >>> weight_conversion(\"stone\",\"long-ton\",3)\n    0.018750005325351003\n    >>> weight_conversion(\"stone\",\"short-ton\",3)\n    0.021000006421614002\n    >>> weight_conversion(\"stone\",\"pound\",2)\n    28.00000881870372\n    >>> weight_conversion(\"stone\",\"ounce\",1)\n    224.00007054835967\n    >>> weight_conversion(\"stone\",\"carrat\",2)\n    63502.9\n    >>> weight_conversion(\"ounce\",\"kilogram\",3)\n    0.0850485\n    >>> weight_conversion(\"ounce\",\"gram\",3)\n    85.0485\n    >>> weight_conversion(\"ounce\",\"milligram\",4)\n    113398.0\n    >>> weight_conversion(\"ounce\",\"metric-ton\",4)\n    0.000113398\n    >>> weight_conversion(\"ounce\",\"long-ton\",4)\n    0.0001116071394054\n    >>> weight_conversion(\"ounce\",\"short-ton\",4)\n    0.0001249999988556\n    >>> weight_conversion(\"ounce\",\"pound\",1)\n    0.0625000000004599\n    >>> weight_conversion(\"ounce\",\"ounce\",2)\n    2.000000000003377\n    >>> weight_conversion(\"ounce\",\"carrat\",1)\n    141.7475\n    >>> weight_conversion(\"ounce\",\"atomic-mass-unit\",1)\n    1.70724563015874e+25\n    >>> weight_conversion(\"carrat\",\"kilogram\",1)\n    0.0002\n    >>> weight_conversion(\"carrat\",\"gram\",4)\n    0.8\n    >>> weight_conversion(\"carrat\",\"milligram\",2)\n    400.0\n    >>> weight_conversion(\"carrat\",\"metric-ton\",2)\n    4.0000000000000003e-07\n    >>> weight_conversion(\"carrat\",\"long-ton\",3)\n    5.9052438e-07\n    >>> weight_conversion(\"carrat\",\"short-ton\",4)\n    8.818497600000002e-07\n    >>> weight_conversion(\"carrat\",\"pound\",1)\n    0.00044092488404000004\n    >>> weight_conversion(\"carrat\",\"ounce\",2)\n    0.0141095962892\n    >>> weight_conversion(\"carrat\",\"carrat\",4)\n    4.0\n    >>> weight_conversion(\"carrat\",\"atomic-mass-unit\",4)\n    4.8177093216e+23\n    >>> weight_conversion(\"atomic-mass-unit\",\"kilogram\",4)\n    6.642160796e-27\n    >>> weight_conversion(\"atomic-mass-unit\",\"gram\",2)\n    3.321080398e-24\n    >>> weight_conversion(\"atomic-mass-unit\",\"milligram\",2)\n    3.3210803980000002e-21\n    >>> weight_conversion(\"atomic-mass-unit\",\"metric-ton\",3)\n    4.9816205970000004e-30\n    >>> weight_conversion(\"atomic-mass-unit\",\"long-ton\",3)\n    4.9029473573977584e-30\n    >>> weight_conversion(\"atomic-mass-unit\",\"short-ton\",1)\n    1.830433719948128e-30\n    >>> weight_conversion(\"atomic-mass-unit\",\"pound\",3)\n    1.0982602420317504e-26\n    >>> weight_conversion(\"atomic-mass-unit\",\"ounce\",2)\n    1.1714775914938915e-25\n    >>> weight_conversion(\"atomic-mass-unit\",\"carrat\",2)\n    1.660540199e-23\n    >>> weight_conversion(\"atomic-mass-unit\",\"atomic-mass-unit\",2)\n    1.999999998903455\n    >>> weight_conversion(\"slug\", \"kilogram\", 1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Invalid 'from_type' or 'to_type' value: 'slug', 'kilogram'\n    Supported values are: kilogram, gram, milligram, metric-ton, long-ton, short-ton, \\\npound, stone, ounce, carrat, atomic-mass-unit\n    \"\"\"\n    if to_type not in KILOGRAM_CHART or from_type not in WEIGHT_TYPE_CHART:\n        msg = (\n            f\"Invalid 'from_type' or 'to_type' value: {from_type!r}, {to_type!r}\\n\"\n            f\"Supported values are: {', '.join(WEIGHT_TYPE_CHART)}\"\n        )\n        raise ValueError(msg)\n    return value * KILOGRAM_CHART[to_type] * WEIGHT_TYPE_CHART[from_type]",
    "docstring": "Conversion of weight unit with the help of KILOGRAM_CHART\n\n\"kilogram\" : 1,\n\"gram\" : pow(10, 3),\n\"milligram\" : pow(10, 6),\n\"metric-ton\" : pow(10, -3),\n\"long-ton\" : 0.0009842073,\n\"short-ton\" : 0.0011023122,\n\"pound\" : 2.2046244202,\n\"stone\": 0.1574731728,\n\"ounce\" : 35.273990723,\n\"carrat\" : 5000,\n\"atomic-mass-unit\" : 6.022136652E+26\n\n>>> weight_conversion(\"kilogram\",\"kilogram\",4)\n4\n>>> weight_conversion(\"kilogram\",\"gram\",1)\n1000\n>>> weight_conversion(\"kilogram\",\"milligram\",4)\n4000000\n>>> weight_conversion(\"kilogram\",\"metric-ton\",4)\n0.004\n>>> weight_conversion(\"kilogram\",\"long-ton\",3)\n0.0029526219\n>>> weight_conversion(\"kilogram\",\"short-ton\",1)\n0.0011023122\n>>> weight_conversion(\"kilogram\",\"pound\",4)\n8.8184976808\n>>> weight_conversion(\"kilogram\",\"stone\",5)\n0.7873658640000001\n>>> weight_conversion(\"kilogram\",\"ounce\",4)\n141.095962892\n>>> weight_conversion(\"kilogram\",\"carrat\",3)\n15000\n>>> weight_conversion(\"kilogram\",\"atomic-mass-unit\",1)\n6.022136652e+26\n>>> weight_conversion(\"gram\",\"kilogram\",1)\n0.001\n>>> weight_conversion(\"gram\",\"gram\",3)\n3.0\n>>> weight_conversion(\"gram\",\"milligram\",2)\n2000.0\n>>> weight_conversion(\"gram\",\"metric-ton\",4)\n4e-06\n>>> weight_conversion(\"gram\",\"long-ton\",3)\n2.9526219e-06\n>>> weight_conversion(\"gram\",\"short-ton\",3)\n3.3069366000000003e-06\n>>> weight_conversion(\"gram\",\"pound\",3)\n0.0066138732606\n>>> weight_conversion(\"gram\",\"stone\",4)\n0.0006298926912000001\n>>> weight_conversion(\"gram\",\"ounce\",1)\n0.035273990723\n>>> weight_conversion(\"gram\",\"carrat\",2)\n10.0\n>>> weight_conversion(\"gram\",\"atomic-mass-unit\",1)\n6.022136652e+23\n>>> weight_conversion(\"milligram\",\"kilogram\",1)\n1e-06\n>>> weight_conversion(\"milligram\",\"gram\",2)\n0.002\n>>> weight_conversion(\"milligram\",\"milligram\",3)\n3.0\n>>> weight_conversion(\"milligram\",\"metric-ton\",3)\n3e-09\n>>> weight_conversion(\"milligram\",\"long-ton\",3)\n2.9526219e-09\n>>> weight_conversion(\"milligram\",\"short-ton\",1)\n1.1023122e-09\n>>> weight_conversion(\"milligram\",\"pound\",3)\n6.6138732605999995e-06\n>>> weight_conversion(\"milligram\",\"ounce\",2)\n7.054798144599999e-05\n>>> weight_conversion(\"milligram\",\"carrat\",1)\n0.005\n>>> weight_conversion(\"milligram\",\"atomic-mass-unit\",1)\n6.022136652e+20\n>>> weight_conversion(\"metric-ton\",\"kilogram\",2)\n2000\n>>> weight_conversion(\"metric-ton\",\"gram\",2)\n2000000\n>>> weight_conversion(\"metric-ton\",\"milligram\",3)\n3000000000\n>>> weight_conversion(\"metric-ton\",\"metric-ton\",2)\n2.0\n>>> weight_conversion(\"metric-ton\",\"long-ton\",3)\n2.9526219\n>>> weight_conversion(\"metric-ton\",\"short-ton\",2)\n2.2046244\n>>> weight_conversion(\"metric-ton\",\"pound\",3)\n6613.8732606\n>>> weight_conversion(\"metric-ton\",\"ounce\",4)\n141095.96289199998\n>>> weight_conversion(\"metric-ton\",\"carrat\",4)\n20000000\n>>> weight_conversion(\"metric-ton\",\"atomic-mass-unit\",1)\n6.022136652e+29\n>>> weight_conversion(\"long-ton\",\"kilogram\",4)\n4064.18432\n>>> weight_conversion(\"long-ton\",\"gram\",4)\n4064184.32\n>>> weight_conversion(\"long-ton\",\"milligram\",3)\n3048138240.0\n>>> weight_conversion(\"long-ton\",\"metric-ton\",4)\n4.06418432\n>>> weight_conversion(\"long-ton\",\"long-ton\",3)\n2.999999907217152\n>>> weight_conversion(\"long-ton\",\"short-ton\",1)\n1.119999989746176\n>>> weight_conversion(\"long-ton\",\"pound\",3)\n6720.000000049448\n>>> weight_conversion(\"long-ton\",\"ounce\",1)\n35840.000000060514\n>>> weight_conversion(\"long-ton\",\"carrat\",4)\n20320921.599999998\n>>> weight_conversion(\"long-ton\",\"atomic-mass-unit\",4)\n2.4475073353955697e+30\n>>> weight_conversion(\"short-ton\",\"kilogram\",3)\n2721.5519999999997\n>>> weight_conversion(\"short-ton\",\"gram\",3)\n2721552.0\n>>> weight_conversion(\"short-ton\",\"milligram\",1)\n907184000.0\n>>> weight_conversion(\"short-ton\",\"metric-ton\",4)\n3.628736\n>>> weight_conversion(\"short-ton\",\"long-ton\",3)\n2.6785713457296\n>>> weight_conversion(\"short-ton\",\"short-ton\",3)\n2.9999999725344\n>>> weight_conversion(\"short-ton\",\"pound\",2)\n4000.0000000294335\n>>> weight_conversion(\"short-ton\",\"ounce\",4)\n128000.00000021611\n>>> weight_conversion(\"short-ton\",\"carrat\",4)\n18143680.0\n>>> weight_conversion(\"short-ton\",\"atomic-mass-unit\",1)\n5.463186016507968e+29\n>>> weight_conversion(\"pound\",\"kilogram\",4)\n1.814368\n>>> weight_conversion(\"pound\",\"gram\",2)\n907.184\n>>> weight_conversion(\"pound\",\"milligram\",3)\n1360776.0\n>>> weight_conversion(\"pound\",\"metric-ton\",3)\n0.001360776\n>>> weight_conversion(\"pound\",\"long-ton\",2)\n0.0008928571152432\n>>> weight_conversion(\"pound\",\"short-ton\",1)\n0.0004999999954224\n>>> weight_conversion(\"pound\",\"pound\",3)\n3.0000000000220752\n>>> weight_conversion(\"pound\",\"ounce\",1)\n16.000000000027015\n>>> weight_conversion(\"pound\",\"carrat\",1)\n2267.96\n>>> weight_conversion(\"pound\",\"atomic-mass-unit\",4)\n1.0926372033015936e+27\n>>> weight_conversion(\"stone\",\"kilogram\",5)\n31.751450000000002\n>>> weight_conversion(\"stone\",\"gram\",2)\n12700.58\n>>> weight_conversion(\"stone\",\"milligram\",3)\n19050870.0\n>>> weight_conversion(\"stone\",\"metric-ton\",3)\n0.01905087\n>>> weight_conversion(\"stone\",\"long-ton\",3)\n0.018750005325351003\n>>> weight_conversion(\"stone\",\"short-ton\",3)\n0.021000006421614002\n>>> weight_conversion(\"stone\",\"pound\",2)\n28.00000881870372\n>>> weight_conversion(\"stone\",\"ounce\",1)\n224.00007054835967\n>>> weight_conversion(\"stone\",\"carrat\",2)\n63502.9\n>>> weight_conversion(\"ounce\",\"kilogram\",3)\n0.0850485\n>>> weight_conversion(\"ounce\",\"gram\",3)\n85.0485\n>>> weight_conversion(\"ounce\",\"milligram\",4)\n113398.0\n>>> weight_conversion(\"ounce\",\"metric-ton\",4)\n0.000113398\n>>> weight_conversion(\"ounce\",\"long-ton\",4)\n0.0001116071394054\n>>> weight_conversion(\"ounce\",\"short-ton\",4)\n0.0001249999988556\n>>> weight_conversion(\"ounce\",\"pound\",1)\n0.0625000000004599\n>>> weight_conversion(\"ounce\",\"ounce\",2)\n2.000000000003377\n>>> weight_conversion(\"ounce\",\"carrat\",1)\n141.7475\n>>> weight_conversion(\"ounce\",\"atomic-mass-unit\",1)\n1.70724563015874e+25\n>>> weight_conversion(\"carrat\",\"kilogram\",1)\n0.0002\n>>> weight_conversion(\"carrat\",\"gram\",4)\n0.8\n>>> weight_conversion(\"carrat\",\"milligram\",2)\n400.0\n>>> weight_conversion(\"carrat\",\"metric-ton\",2)\n4.0000000000000003e-07\n>>> weight_conversion(\"carrat\",\"long-ton\",3)\n5.9052438e-07\n>>> weight_conversion(\"carrat\",\"short-ton\",4)\n8.818497600000002e-07\n>>> weight_conversion(\"carrat\",\"pound\",1)\n0.00044092488404000004\n>>> weight_conversion(\"carrat\",\"ounce\",2)\n0.0141095962892\n>>> weight_conversion(\"carrat\",\"carrat\",4)\n4.0\n>>> weight_conversion(\"carrat\",\"atomic-mass-unit\",4)\n4.8177093216e+23\n>>> weight_conversion(\"atomic-mass-unit\",\"kilogram\",4)\n6.642160796e-27\n>>> weight_conversion(\"atomic-mass-unit\",\"gram\",2)\n3.321080398e-24\n>>> weight_conversion(\"atomic-mass-unit\",\"milligram\",2)\n3.3210803980000002e-21\n>>> weight_conversion(\"atomic-mass-unit\",\"metric-ton\",3)\n4.9816205970000004e-30\n>>> weight_conversion(\"atomic-mass-unit\",\"long-ton\",3)\n4.9029473573977584e-30\n>>> weight_conversion(\"atomic-mass-unit\",\"short-ton\",1)\n1.830433719948128e-30\n>>> weight_conversion(\"atomic-mass-unit\",\"pound\",3)\n1.0982602420317504e-26\n>>> weight_conversion(\"atomic-mass-unit\",\"ounce\",2)\n1.1714775914938915e-25\n>>> weight_conversion(\"atomic-mass-unit\",\"carrat\",2)\n1.660540199e-23\n>>> weight_conversion(\"atomic-mass-unit\",\"atomic-mass-unit\",2)\n1.999999998903455\n>>> weight_conversion(\"slug\", \"kilogram\", 1)\nTraceback (most recent call last):\n...\nValueError: Invalid 'from_type' or 'to_type' value: 'slug', 'kilogram'\nSupported values are: kilogram, gram, milligram, metric-ton, long-ton, short-ton, pound, stone, ounce, carrat, atomic-mass-unit"
  },
  {
    "function": "all_rotations",
    "code": "def all_rotations(s: str) -> list[str]:\n    \"\"\"\n    :param s: The string that will be rotated len(s) times.\n    :return: A list with the rotations.\n    :raises TypeError: If s is not an instance of str.\n    Examples:\n\n    >>> all_rotations(\"^BANANA|\") # doctest: +NORMALIZE_WHITESPACE\n    ['^BANANA|', 'BANANA|^', 'ANANA|^B', 'NANA|^BA', 'ANA|^BAN', 'NA|^BANA',\n    'A|^BANAN', '|^BANANA']\n    >>> all_rotations(\"a_asa_da_casa\") # doctest: +NORMALIZE_WHITESPACE\n    ['a_asa_da_casa', '_asa_da_casaa', 'asa_da_casaa_', 'sa_da_casaa_a',\n    'a_da_casaa_as', '_da_casaa_asa', 'da_casaa_asa_', 'a_casaa_asa_d',\n    '_casaa_asa_da', 'casaa_asa_da_', 'asaa_asa_da_c', 'saa_asa_da_ca',\n    'aa_asa_da_cas']\n    >>> all_rotations(\"panamabanana\") # doctest: +NORMALIZE_WHITESPACE\n    ['panamabanana', 'anamabananap', 'namabananapa', 'amabananapan',\n    'mabananapana', 'abananapanam', 'bananapanama', 'ananapanamab',\n    'nanapanamaba', 'anapanamaban', 'napanamabana', 'apanamabanan']\n    >>> all_rotations(5)\n    Traceback (most recent call last):\n        ...\n    TypeError: The parameter s type must be str.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"The parameter s type must be str.\")\n\n    return [s[i:] + s[:i] for i in range(len(s))]",
    "docstring": ":param s: The string that will be rotated len(s) times.\n:return: A list with the rotations.\n:raises TypeError: If s is not an instance of str.\nExamples:\n\n>>> all_rotations(\"^BANANA|\") # doctest: +NORMALIZE_WHITESPACE\n['^BANANA|', 'BANANA|^', 'ANANA|^B', 'NANA|^BA', 'ANA|^BAN', 'NA|^BANA',\n'A|^BANAN', '|^BANANA']\n>>> all_rotations(\"a_asa_da_casa\") # doctest: +NORMALIZE_WHITESPACE\n['a_asa_da_casa', '_asa_da_casaa', 'asa_da_casaa_', 'sa_da_casaa_a',\n'a_da_casaa_as', '_da_casaa_asa', 'da_casaa_asa_', 'a_casaa_asa_d',\n'_casaa_asa_da', 'casaa_asa_da_', 'asaa_asa_da_c', 'saa_asa_da_ca',\n'aa_asa_da_cas']\n>>> all_rotations(\"panamabanana\") # doctest: +NORMALIZE_WHITESPACE\n['panamabanana', 'anamabananap', 'namabananapa', 'amabananapan',\n'mabananapana', 'abananapanam', 'bananapanama', 'ananapanamab',\n'nanapanamaba', 'anapanamaban', 'napanamabana', 'apanamabanan']\n>>> all_rotations(5)\nTraceback (most recent call last):\n    ...\nTypeError: The parameter s type must be str."
  },
  {
    "function": "bwt_transform",
    "code": "def bwt_transform(s: str) -> BWTTransformDict:\n    \"\"\"\n    :param s: The string that will be used at bwt algorithm\n    :return: the string composed of the last char of each row of the ordered\n    rotations and the index of the original string at ordered rotations list\n    :raises TypeError: If the s parameter type is not str\n    :raises ValueError: If the s parameter is empty\n    Examples:\n\n    >>> bwt_transform(\"^BANANA\")\n    {'bwt_string': 'BNN^AAA', 'idx_original_string': 6}\n    >>> bwt_transform(\"a_asa_da_casa\")\n    {'bwt_string': 'aaaadss_c__aa', 'idx_original_string': 3}\n    >>> bwt_transform(\"panamabanana\")\n    {'bwt_string': 'mnpbnnaaaaaa', 'idx_original_string': 11}\n    >>> bwt_transform(4)\n    Traceback (most recent call last):\n        ...\n    TypeError: The parameter s type must be str.\n    >>> bwt_transform('')\n    Traceback (most recent call last):\n        ...\n    ValueError: The parameter s must not be empty.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"The parameter s type must be str.\")\n    if not s:\n        raise ValueError(\"The parameter s must not be empty.\")\n\n    rotations = all_rotations(s)\n    rotations.sort()  # sort the list of rotations in alphabetically order\n    # make a string composed of the last char of each rotation\n    response: BWTTransformDict = {\n        \"bwt_string\": \"\".join([word[-1] for word in rotations]),\n        \"idx_original_string\": rotations.index(s),\n    }\n    return response",
    "docstring": ":param s: The string that will be used at bwt algorithm\n:return: the string composed of the last char of each row of the ordered\nrotations and the index of the original string at ordered rotations list\n:raises TypeError: If the s parameter type is not str\n:raises ValueError: If the s parameter is empty\nExamples:\n\n>>> bwt_transform(\"^BANANA\")\n{'bwt_string': 'BNN^AAA', 'idx_original_string': 6}\n>>> bwt_transform(\"a_asa_da_casa\")\n{'bwt_string': 'aaaadss_c__aa', 'idx_original_string': 3}\n>>> bwt_transform(\"panamabanana\")\n{'bwt_string': 'mnpbnnaaaaaa', 'idx_original_string': 11}\n>>> bwt_transform(4)\nTraceback (most recent call last):\n    ...\nTypeError: The parameter s type must be str.\n>>> bwt_transform('')\nTraceback (most recent call last):\n    ...\nValueError: The parameter s must not be empty."
  },
  {
    "function": "reverse_bwt",
    "code": "def reverse_bwt(bwt_string: str, idx_original_string: int) -> str:\n    \"\"\"\n    :param bwt_string: The string returned from bwt algorithm execution\n    :param idx_original_string: A 0-based index of the string that was used to\n    generate bwt_string at ordered rotations list\n    :return: The string used to generate bwt_string when bwt was executed\n    :raises TypeError: If the bwt_string parameter type is not str\n    :raises ValueError: If the bwt_string parameter is empty\n    :raises TypeError: If the idx_original_string type is not int or if not\n    possible to cast it to int\n    :raises ValueError: If the idx_original_string value is lower than 0 or\n    greater than len(bwt_string) - 1\n\n    >>> reverse_bwt(\"BNN^AAA\", 6)\n    '^BANANA'\n    >>> reverse_bwt(\"aaaadss_c__aa\", 3)\n    'a_asa_da_casa'\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", 11)\n    'panamabanana'\n    >>> reverse_bwt(4, 11)\n    Traceback (most recent call last):\n        ...\n    TypeError: The parameter bwt_string type must be str.\n    >>> reverse_bwt(\"\", 11)\n    Traceback (most recent call last):\n        ...\n    ValueError: The parameter bwt_string must not be empty.\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", \"asd\") # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    TypeError: The parameter idx_original_string type must be int or passive\n    of cast to int.\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The parameter idx_original_string must not be lower than 0.\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", 12) # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: The parameter idx_original_string must be lower than\n    len(bwt_string).\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", 11.0)\n    'panamabanana'\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", 11.4)\n    'panamabanana'\n    \"\"\"\n    if not isinstance(bwt_string, str):\n        raise TypeError(\"The parameter bwt_string type must be str.\")\n    if not bwt_string:\n        raise ValueError(\"The parameter bwt_string must not be empty.\")\n    try:\n        idx_original_string = int(idx_original_string)\n    except ValueError:\n        raise TypeError(\n            \"The parameter idx_original_string type must be int or passive\"\n            \" of cast to int.\"\n        )\n    if idx_original_string < 0:\n        raise ValueError(\"The parameter idx_original_string must not be lower than 0.\")\n    if idx_original_string >= len(bwt_string):\n        raise ValueError(\n            \"The parameter idx_original_string must be lower than len(bwt_string).\"\n        )\n\n    ordered_rotations = [\"\"] * len(bwt_string)\n    for _ in range(len(bwt_string)):\n        for i in range(len(bwt_string)):\n            ordered_rotations[i] = bwt_string[i] + ordered_rotations[i]\n        ordered_rotations.sort()\n    return ordered_rotations[idx_original_string]",
    "docstring": ":param bwt_string: The string returned from bwt algorithm execution\n:param idx_original_string: A 0-based index of the string that was used to\ngenerate bwt_string at ordered rotations list\n:return: The string used to generate bwt_string when bwt was executed\n:raises TypeError: If the bwt_string parameter type is not str\n:raises ValueError: If the bwt_string parameter is empty\n:raises TypeError: If the idx_original_string type is not int or if not\npossible to cast it to int\n:raises ValueError: If the idx_original_string value is lower than 0 or\ngreater than len(bwt_string) - 1\n\n>>> reverse_bwt(\"BNN^AAA\", 6)\n'^BANANA'\n>>> reverse_bwt(\"aaaadss_c__aa\", 3)\n'a_asa_da_casa'\n>>> reverse_bwt(\"mnpbnnaaaaaa\", 11)\n'panamabanana'\n>>> reverse_bwt(4, 11)\nTraceback (most recent call last):\n    ...\nTypeError: The parameter bwt_string type must be str.\n>>> reverse_bwt(\"\", 11)\nTraceback (most recent call last):\n    ...\nValueError: The parameter bwt_string must not be empty.\n>>> reverse_bwt(\"mnpbnnaaaaaa\", \"asd\") # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nTypeError: The parameter idx_original_string type must be int or passive\nof cast to int.\n>>> reverse_bwt(\"mnpbnnaaaaaa\", -1)\nTraceback (most recent call last):\n    ...\nValueError: The parameter idx_original_string must not be lower than 0.\n>>> reverse_bwt(\"mnpbnnaaaaaa\", 12) # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: The parameter idx_original_string must be lower than\nlen(bwt_string).\n>>> reverse_bwt(\"mnpbnnaaaaaa\", 11.0)\n'panamabanana'\n>>> reverse_bwt(\"mnpbnnaaaaaa\", 11.4)\n'panamabanana'"
  },
  {
    "function": "parse_file",
    "code": "def parse_file(file_path: str) -> list[Letter]:\n    \"\"\"\n    Read the file and build a dict of all letters and their\n    frequencies, then convert the dict into a list of Letters.\n    \"\"\"\n    chars: dict[str, int] = {}\n    with open(file_path) as f:\n        while True:\n            c = f.read(1)\n            if not c:\n                break\n            chars[c] = chars[c] + 1 if c in chars else 1\n    return sorted((Letter(c, f) for c, f in chars.items()), key=lambda x: x.freq)",
    "docstring": "Read the file and build a dict of all letters and their\nfrequencies, then convert the dict into a list of Letters."
  },
  {
    "function": "build_tree",
    "code": "def build_tree(letters: list[Letter]) -> Letter | TreeNode:\n    \"\"\"\n    Run through the list of Letters and build the min heap\n    for the Huffman Tree.\n    \"\"\"\n    response: list[Letter | TreeNode] = list(letters)\n    while len(response) > 1:\n        left = response.pop(0)\n        right = response.pop(0)\n        total_freq = left.freq + right.freq\n        node = TreeNode(total_freq, left, right)\n        response.append(node)\n        response.sort(key=lambda x: x.freq)\n    return response[0]",
    "docstring": "Run through the list of Letters and build the min heap\nfor the Huffman Tree."
  },
  {
    "function": "traverse_tree",
    "code": "def traverse_tree(root: Letter | TreeNode, bitstring: str) -> list[Letter]:\n    \"\"\"\n    Recursively traverse the Huffman Tree to set each\n    Letter's bitstring dictionary, and return the list of Letters\n    \"\"\"\n    if isinstance(root, Letter):\n        root.bitstring[root.letter] = bitstring\n        return [root]\n    treenode: TreeNode = root\n    letters = []\n    letters += traverse_tree(treenode.left, bitstring + \"0\")\n    letters += traverse_tree(treenode.right, bitstring + \"1\")\n    return letters",
    "docstring": "Recursively traverse the Huffman Tree to set each\nLetter's bitstring dictionary, and return the list of Letters"
  },
  {
    "function": "huffman",
    "code": "def huffman(file_path: str) -> None:\n    \"\"\"\n    Parse the file, build the tree, then run through the file\n    again, using the letters dictionary to find and print out the\n    bitstring for each letter.\n    \"\"\"\n    letters_list = parse_file(file_path)\n    root = build_tree(letters_list)\n    letters = {\n        k: v for letter in traverse_tree(root, \"\") for k, v in letter.bitstring.items()\n    }\n    print(f\"Huffman Coding  of {file_path}: \")\n    with open(file_path) as f:\n        while True:\n            c = f.read(1)\n            if not c:\n                break\n            print(letters[c], end=\" \")\n    print()",
    "docstring": "Parse the file, build the tree, then run through the file\nagain, using the letters dictionary to find and print out the\nbitstring for each letter."
  },
  {
    "function": "read_file_binary",
    "code": "def read_file_binary(file_path: str) -> str:\n    \"\"\"\n    Reads given file as bytes and returns them as a long string\n    \"\"\"\n    result = \"\"\n    try:\n        with open(file_path, \"rb\") as binary_file:\n            data = binary_file.read()\n        for dat in data:\n            curr_byte = f\"{dat:08b}\"\n            result += curr_byte\n        return result\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()",
    "docstring": "Reads given file as bytes and returns them as a long string"
  },
  {
    "function": "add_key_to_lexicon",
    "code": "def add_key_to_lexicon(\n    lexicon: dict[str, str], curr_string: str, index: int, last_match_id: str\n) -> None:\n    \"\"\"\n    Adds new strings (curr_string + \"0\",  curr_string + \"1\") to the lexicon\n    \"\"\"\n    lexicon.pop(curr_string)\n    lexicon[curr_string + \"0\"] = last_match_id\n\n    if math.log2(index).is_integer():\n        for curr_key, value in lexicon.items():\n            lexicon[curr_key] = f\"0{value}\"\n\n    lexicon[curr_string + \"1\"] = bin(index)[2:]",
    "docstring": "Adds new strings (curr_string + \"0\",  curr_string + \"1\") to the lexicon"
  },
  {
    "function": "compress_data",
    "code": "def compress_data(data_bits: str) -> str:\n    \"\"\"\n    Compresses given data_bits using Lempel-Ziv-Welch compression algorithm\n    and returns the result as a string\n    \"\"\"\n    lexicon = {\"0\": \"0\", \"1\": \"1\"}\n    result, curr_string = \"\", \"\"\n    index = len(lexicon)\n\n    for i in range(len(data_bits)):\n        curr_string += data_bits[i]\n        if curr_string not in lexicon:\n            continue\n\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n        add_key_to_lexicon(lexicon, curr_string, index, last_match_id)\n        index += 1\n        curr_string = \"\"\n\n    while curr_string != \"\" and curr_string not in lexicon:\n        curr_string += \"0\"\n\n    if curr_string != \"\":\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n\n    return result",
    "docstring": "Compresses given data_bits using Lempel-Ziv-Welch compression algorithm\nand returns the result as a string"
  },
  {
    "function": "add_file_length",
    "code": "def add_file_length(source_path: str, compressed: str) -> str:\n    \"\"\"\n    Adds given file's length in front (using Elias  gamma coding) of the compressed\n    string\n    \"\"\"\n    file_length = os.path.getsize(source_path)\n    file_length_binary = bin(file_length)[2:]\n    length_length = len(file_length_binary)\n\n    return \"0\" * (length_length - 1) + file_length_binary + compressed",
    "docstring": "Adds given file's length in front (using Elias  gamma coding) of the compressed\nstring"
  },
  {
    "function": "write_file_binary",
    "code": "def write_file_binary(file_path: str, to_write: str) -> None:\n    \"\"\"\n    Writes given to_write string (should only consist of 0's and 1's) as bytes in the\n    file\n    \"\"\"\n    byte_length = 8\n    try:\n        with open(file_path, \"wb\") as opened_file:\n            result_byte_array = [\n                to_write[i : i + byte_length]\n                for i in range(0, len(to_write), byte_length)\n            ]\n\n            if len(result_byte_array[-1]) % byte_length == 0:\n                result_byte_array.append(\"10000000\")\n            else:\n                result_byte_array[-1] += \"1\" + \"0\" * (\n                    byte_length - len(result_byte_array[-1]) - 1\n                )\n\n            for elem in result_byte_array:\n                opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()",
    "docstring": "Writes given to_write string (should only consist of 0's and 1's) as bytes in the\nfile"
  },
  {
    "function": "compress",
    "code": "def compress(source_path: str, destination_path: str) -> None:\n    \"\"\"\n    Reads source file, compresses it and writes the compressed result in destination\n    file\n    \"\"\"\n    data_bits = read_file_binary(source_path)\n    compressed = compress_data(data_bits)\n    compressed = add_file_length(source_path, compressed)\n    write_file_binary(destination_path, compressed)",
    "docstring": "Reads source file, compresses it and writes the compressed result in destination\nfile"
  },
  {
    "function": "read_file_binary",
    "code": "def read_file_binary(file_path: str) -> str:\n    \"\"\"\n    Reads given file as bytes and returns them as a long string\n    \"\"\"\n    result = \"\"\n    try:\n        with open(file_path, \"rb\") as binary_file:\n            data = binary_file.read()\n        for dat in data:\n            curr_byte = f\"{dat:08b}\"\n            result += curr_byte\n        return result\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()",
    "docstring": "Reads given file as bytes and returns them as a long string"
  },
  {
    "function": "decompress_data",
    "code": "def decompress_data(data_bits: str) -> str:\n    \"\"\"\n    Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm\n    and returns the result as a string\n    \"\"\"\n    lexicon = {\"0\": \"0\", \"1\": \"1\"}\n    result, curr_string = \"\", \"\"\n    index = len(lexicon)\n\n    for i in range(len(data_bits)):\n        curr_string += data_bits[i]\n        if curr_string not in lexicon:\n            continue\n\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n        lexicon[curr_string] = last_match_id + \"0\"\n\n        if math.log2(index).is_integer():\n            new_lex = {}\n            for curr_key in list(lexicon):\n                new_lex[\"0\" + curr_key] = lexicon.pop(curr_key)\n            lexicon = new_lex\n\n        lexicon[bin(index)[2:]] = last_match_id + \"1\"\n        index += 1\n        curr_string = \"\"\n    return result",
    "docstring": "Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm\nand returns the result as a string"
  },
  {
    "function": "write_file_binary",
    "code": "def write_file_binary(file_path: str, to_write: str) -> None:\n    \"\"\"\n    Writes given to_write string (should only consist of 0's and 1's) as bytes in the\n    file\n    \"\"\"\n    byte_length = 8\n    try:\n        with open(file_path, \"wb\") as opened_file:\n            result_byte_array = [\n                to_write[i : i + byte_length]\n                for i in range(0, len(to_write), byte_length)\n            ]\n\n            if len(result_byte_array[-1]) % byte_length == 0:\n                result_byte_array.append(\"10000000\")\n            else:\n                result_byte_array[-1] += \"1\" + \"0\" * (\n                    byte_length - len(result_byte_array[-1]) - 1\n                )\n\n            for elem in result_byte_array[:-1]:\n                opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()",
    "docstring": "Writes given to_write string (should only consist of 0's and 1's) as bytes in the\nfile"
  },
  {
    "function": "remove_prefix",
    "code": "def remove_prefix(data_bits: str) -> str:\n    \"\"\"\n    Removes size prefix, that compressed file should have\n    Returns the result\n    \"\"\"\n    counter = 0\n    for letter in data_bits:\n        if letter == \"1\":\n            break\n        counter += 1\n\n    data_bits = data_bits[counter:]\n    data_bits = data_bits[counter + 1 :]\n    return data_bits",
    "docstring": "Removes size prefix, that compressed file should have\nReturns the result"
  },
  {
    "function": "compress",
    "code": "def compress(source_path: str, destination_path: str) -> None:\n    \"\"\"\n    Reads source file, decompresses it and writes the result in destination file\n    \"\"\"\n    data_bits = read_file_binary(source_path)\n    data_bits = remove_prefix(data_bits)\n    decompressed = decompress_data(data_bits)\n    write_file_binary(destination_path, decompressed)",
    "docstring": "Reads source file, decompresses it and writes the result in destination file"
  },
  {
    "function": "run_length_encode",
    "code": "def run_length_encode(text: str) -> list:\n    \"\"\"\n    Performs Run Length Encoding\n    >>> run_length_encode(\"AAAABBBCCDAA\")\n    [('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]\n    >>> run_length_encode(\"A\")\n    [('A', 1)]\n    >>> run_length_encode(\"AA\")\n    [('A', 2)]\n    >>> run_length_encode(\"AAADDDDDDFFFCCCAAVVVV\")\n    [('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]\n    \"\"\"\n    encoded = []\n    count = 1\n\n    for i in range(len(text)):\n        if i + 1 < len(text) and text[i] == text[i + 1]:\n            count += 1\n        else:\n            encoded.append((text[i], count))\n            count = 1\n\n    return encoded",
    "docstring": "Performs Run Length Encoding\n>>> run_length_encode(\"AAAABBBCCDAA\")\n[('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]\n>>> run_length_encode(\"A\")\n[('A', 1)]\n>>> run_length_encode(\"AA\")\n[('A', 2)]\n>>> run_length_encode(\"AAADDDDDDFFFCCCAAVVVV\")\n[('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]"
  },
  {
    "function": "run_length_decode",
    "code": "def run_length_decode(encoded: list) -> str:\n    \"\"\"\n    Performs Run Length Decoding\n    >>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)])\n    'AAAABBBCCDAA'\n    >>> run_length_decode([('A', 1)])\n    'A'\n    >>> run_length_decode([('A', 2)])\n    'AA'\n    >>> run_length_decode([('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)])\n    'AAADDDDDDFFFCCCAAVVVV'\n    \"\"\"\n    return \"\".join(char * length for char, length in encoded)",
    "docstring": "Performs Run Length Decoding\n>>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)])\n'AAAABBBCCDAA'\n>>> run_length_decode([('A', 1)])\n'A'\n>>> run_length_decode([('A', 2)])\n'AA'\n>>> run_length_decode([('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)])\n'AAADDDDDDFFFCCCAAVVVV'"
  },
  {
    "function": "equilibrium_index",
    "code": "def equilibrium_index(arr: list[int]) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5])\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1])\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3])\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i, value in enumerate(arr):\n        total_sum -= value\n        if left_sum == total_sum:\n            return i\n        left_sum += value\n\n    return -1",
    "docstring": "Find the equilibrium index of an array.\n\nArgs:\n    arr (list[int]): The input array of integers.\n\nReturns:\n    int: The equilibrium index or -1 if no equilibrium index exists.\n\nExamples:\n    >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])\n    3\n    >>> equilibrium_index([1, 2, 3, 4, 5])\n    -1\n    >>> equilibrium_index([1, 1, 1, 1, 1])\n    2\n    >>> equilibrium_index([2, 4, 6, 8, 10, 3])\n    -1"
  },
  {
    "function": "find_triplets_with_0_sum",
    "code": "def find_triplets_with_0_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Given a list of integers, return elements a, b, c such that a + b + c = 0.\n    Args:\n        nums: list of integers\n    Returns:\n        list of lists of integers where sum(each_list) == 0\n    Examples:\n        >>> find_triplets_with_0_sum([-1, 0, 1, 2, -1, -4])\n        [[-1, -1, 2], [-1, 0, 1]]\n        >>> find_triplets_with_0_sum([])\n        []\n        >>> find_triplets_with_0_sum([0, 0, 0])\n        [[0, 0, 0]]\n        >>> find_triplets_with_0_sum([1, 2, 3, 0, -1, -2, -3])\n        [[-3, 0, 3], [-3, 1, 2], [-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]\n    \"\"\"\n    return [\n        list(x)\n        for x in sorted({abc for abc in combinations(sorted(nums), 3) if not sum(abc)})\n    ]",
    "docstring": "Given a list of integers, return elements a, b, c such that a + b + c = 0.\nArgs:\n    nums: list of integers\nReturns:\n    list of lists of integers where sum(each_list) == 0\nExamples:\n    >>> find_triplets_with_0_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> find_triplets_with_0_sum([])\n    []\n    >>> find_triplets_with_0_sum([0, 0, 0])\n    [[0, 0, 0]]\n    >>> find_triplets_with_0_sum([1, 2, 3, 0, -1, -2, -3])\n    [[-3, 0, 3], [-3, 1, 2], [-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]"
  },
  {
    "function": "find_triplets_with_0_sum_hashing",
    "code": "def find_triplets_with_0_sum_hashing(arr: list[int]) -> list[list[int]]:\n    \"\"\"\n    Function for finding the triplets with a given sum in the array using hashing.\n\n    Given a list of integers, return elements a, b, c such that a + b + c = 0.\n\n    Args:\n        nums: list of integers\n    Returns:\n        list of lists of integers where sum(each_list) == 0\n    Examples:\n        >>> find_triplets_with_0_sum_hashing([-1, 0, 1, 2, -1, -4])\n        [[-1, 0, 1], [-1, -1, 2]]\n        >>> find_triplets_with_0_sum_hashing([])\n        []\n        >>> find_triplets_with_0_sum_hashing([0, 0, 0])\n        [[0, 0, 0]]\n        >>> find_triplets_with_0_sum_hashing([1, 2, 3, 0, -1, -2, -3])\n        [[-1, 0, 1], [-3, 1, 2], [-2, 0, 2], [-2, -1, 3], [-3, 0, 3]]\n\n    Time complexity: O(N^2)\n    Auxiliary Space: O(N)\n\n    \"\"\"\n    target_sum = 0\n\n    # Initialize the final output array with blank.\n    output_arr = []\n\n    # Set the initial element as arr[i].\n    for index, item in enumerate(arr[:-2]):\n        # to store second elements that can complement the final sum.\n        set_initialize = set()\n\n        # current sum needed for reaching the target sum\n        current_sum = target_sum - item\n\n        # Traverse the subarray arr[i+1:].\n        for other_item in arr[index + 1 :]:\n            # required value for the second element\n            required_value = current_sum - other_item\n\n            # Verify if the desired value exists in the set.\n            if required_value in set_initialize:\n                # finding triplet elements combination.\n                combination_array = sorted([item, other_item, required_value])\n                if combination_array not in output_arr:\n                    output_arr.append(combination_array)\n\n            # Include the current element in the set\n            # for subsequent complement verification.\n            set_initialize.add(other_item)\n\n    # Return all the triplet combinations.\n    return output_arr",
    "docstring": "Function for finding the triplets with a given sum in the array using hashing.\n\nGiven a list of integers, return elements a, b, c such that a + b + c = 0.\n\nArgs:\n    nums: list of integers\nReturns:\n    list of lists of integers where sum(each_list) == 0\nExamples:\n    >>> find_triplets_with_0_sum_hashing([-1, 0, 1, 2, -1, -4])\n    [[-1, 0, 1], [-1, -1, 2]]\n    >>> find_triplets_with_0_sum_hashing([])\n    []\n    >>> find_triplets_with_0_sum_hashing([0, 0, 0])\n    [[0, 0, 0]]\n    >>> find_triplets_with_0_sum_hashing([1, 2, 3, 0, -1, -2, -3])\n    [[-1, 0, 1], [-3, 1, 2], [-2, 0, 2], [-2, -1, 3], [-3, 0, 3]]\n\nTime complexity: O(N^2)\nAuxiliary Space: O(N)"
  },
  {
    "function": "index_2d_array_in_1d",
    "code": "def index_2d_array_in_1d(array: list[list[int]], index: int) -> int:\n    \"\"\"\n    Retrieves the value of the one-dimensional index from a two-dimensional array.\n\n    Args:\n        array: A 2D array of integers where all rows are the same size and all\n               columns are the same size.\n        index: A 1D index.\n\n    Returns:\n        int: The 0-indexed value of the 1D index in the array.\n\n    Examples:\n    >>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], 5)\n    5\n    >>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: index out of range\n    >>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], 12)\n    Traceback (most recent call last):\n        ...\n    ValueError: index out of range\n    >>> index_2d_array_in_1d([[]], 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: no items in array\n    \"\"\"\n    rows = len(array)\n    cols = len(array[0])\n\n    if rows == 0 or cols == 0:\n        raise ValueError(\"no items in array\")\n\n    if index < 0 or index >= rows * cols:\n        raise ValueError(\"index out of range\")\n\n    return array[index // cols][index % cols]",
    "docstring": "Retrieves the value of the one-dimensional index from a two-dimensional array.\n\nArgs:\n    array: A 2D array of integers where all rows are the same size and all\n           columns are the same size.\n    index: A 1D index.\n\nReturns:\n    int: The 0-indexed value of the 1D index in the array.\n\nExamples:\n>>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], 5)\n5\n>>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], -1)\nTraceback (most recent call last):\n    ...\nValueError: index out of range\n>>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], 12)\nTraceback (most recent call last):\n    ...\nValueError: index out of range\n>>> index_2d_array_in_1d([[]], 0)\nTraceback (most recent call last):\n    ...\nValueError: no items in array"
  },
  {
    "function": "partition",
    "code": "def partition(arr: list[int], low: int, high: int) -> int:\n    \"\"\"\n    Partitions list based on the pivot element.\n\n    This function rearranges the elements in the input list 'elements' such that\n    all elements greater than or equal to the chosen pivot are on the right side\n    of the pivot, and all elements smaller than the pivot are on the left side.\n\n    Args:\n        arr: The list to be partitioned\n        low: The lower index of the list\n        high: The higher index of the list\n\n    Returns:\n        int: The index of pivot element after partitioning\n\n        Examples:\n        >>> partition([3, 1, 4, 5, 9, 2, 6, 5, 3, 5], 0, 9)\n        4\n        >>> partition([7, 1, 4, 5, 9, 2, 6, 5, 8], 0, 8)\n        1\n        >>> partition(['apple', 'cherry', 'date', 'banana'], 0, 3)\n        2\n        >>> partition([3.1, 1.2, 5.6, 4.7], 0, 3)\n        1\n    \"\"\"\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] >= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1",
    "docstring": "Partitions list based on the pivot element.\n\nThis function rearranges the elements in the input list 'elements' such that\nall elements greater than or equal to the chosen pivot are on the right side\nof the pivot, and all elements smaller than the pivot are on the left side.\n\nArgs:\n    arr: The list to be partitioned\n    low: The lower index of the list\n    high: The higher index of the list\n\nReturns:\n    int: The index of pivot element after partitioning\n\n    Examples:\n    >>> partition([3, 1, 4, 5, 9, 2, 6, 5, 3, 5], 0, 9)\n    4\n    >>> partition([7, 1, 4, 5, 9, 2, 6, 5, 8], 0, 8)\n    1\n    >>> partition(['apple', 'cherry', 'date', 'banana'], 0, 3)\n    2\n    >>> partition([3.1, 1.2, 5.6, 4.7], 0, 3)\n    1"
  },
  {
    "function": "kth_largest_element",
    "code": "def kth_largest_element(arr: list[int], position: int) -> int:\n    \"\"\"\n    Finds the kth largest element in a list.\n    Should deliver similar results to:\n    ```python\n    def kth_largest_element(arr, position):\n        return sorted(arr)[-position]\n    ```\n\n    Args:\n        nums: The list of numbers.\n        k: The position of the desired kth largest element.\n\n    Returns:\n        int: The kth largest element.\n\n    Examples:\n        >>> kth_largest_element([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3)\n        5\n        >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], 1)\n        9\n        >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], -2)\n        Traceback (most recent call last):\n        ...\n        ValueError: Invalid value of 'position'\n        >>> kth_largest_element([9, 1, 3, 6, 7, 9, 8, 4, 2, 4, 9], 110)\n        Traceback (most recent call last):\n        ...\n        ValueError: Invalid value of 'position'\n        >>> kth_largest_element([1, 2, 4, 3, 5, 9, 7, 6, 5, 9, 3], 0)\n        Traceback (most recent call last):\n        ...\n        ValueError: Invalid value of 'position'\n        >>> kth_largest_element(['apple', 'cherry', 'date', 'banana'], 2)\n        'cherry'\n        >>> kth_largest_element([3.1, 1.2, 5.6, 4.7,7.9,5,0], 2)\n        5.6\n        >>> kth_largest_element([-2, -5, -4, -1], 1)\n        -1\n        >>> kth_largest_element([], 1)\n        -1\n        >>> kth_largest_element([3.1, 1.2, 5.6, 4.7, 7.9, 5, 0], 1.5)\n        Traceback (most recent call last):\n        ...\n        ValueError: The position should be an integer\n        >>> kth_largest_element((4, 6, 1, 2), 4)\n        Traceback (most recent call last):\n        ...\n        TypeError: 'tuple' object does not support item assignment\n    \"\"\"\n    if not arr:\n        return -1\n    if not isinstance(position, int):\n        raise ValueError(\"The position should be an integer\")\n    if not 1 <= position <= len(arr):\n        raise ValueError(\"Invalid value of 'position'\")\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        if low > len(arr) - 1 or high < 0:\n            return -1\n        pivot_index = partition(arr, low, high)\n        if pivot_index == position - 1:\n            return arr[pivot_index]\n        elif pivot_index > position - 1:\n            high = pivot_index - 1\n        else:\n            low = pivot_index + 1\n    return -1",
    "docstring": "Finds the kth largest element in a list.\nShould deliver similar results to:\n```python\ndef kth_largest_element(arr, position):\n    return sorted(arr)[-position]\n```\n\nArgs:\n    nums: The list of numbers.\n    k: The position of the desired kth largest element.\n\nReturns:\n    int: The kth largest element.\n\nExamples:\n    >>> kth_largest_element([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3)\n    5\n    >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], 1)\n    9\n    >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], -2)\n    Traceback (most recent call last):\n    ...\n    ValueError: Invalid value of 'position'\n    >>> kth_largest_element([9, 1, 3, 6, 7, 9, 8, 4, 2, 4, 9], 110)\n    Traceback (most recent call last):\n    ...\n    ValueError: Invalid value of 'position'\n    >>> kth_largest_element([1, 2, 4, 3, 5, 9, 7, 6, 5, 9, 3], 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Invalid value of 'position'\n    >>> kth_largest_element(['apple', 'cherry', 'date', 'banana'], 2)\n    'cherry'\n    >>> kth_largest_element([3.1, 1.2, 5.6, 4.7,7.9,5,0], 2)\n    5.6\n    >>> kth_largest_element([-2, -5, -4, -1], 1)\n    -1\n    >>> kth_largest_element([], 1)\n    -1\n    >>> kth_largest_element([3.1, 1.2, 5.6, 4.7, 7.9, 5, 0], 1.5)\n    Traceback (most recent call last):\n    ...\n    ValueError: The position should be an integer\n    >>> kth_largest_element((4, 6, 1, 2), 4)\n    Traceback (most recent call last):\n    ...\n    TypeError: 'tuple' object does not support item assignment"
  },
  {
    "function": "find_median_sorted_arrays",
    "code": "def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:\n    \"\"\"\n    Find the median of two arrays.\n\n    Args:\n        nums1: The first array.\n        nums2: The second array.\n\n    Returns:\n    The median of the two arrays.\n\n    Examples:\n        >>> find_median_sorted_arrays([1, 3], [2])\n        2.0\n\n        >>> find_median_sorted_arrays([1, 2], [3, 4])\n        2.5\n\n        >>> find_median_sorted_arrays([0, 0], [0, 0])\n        0.0\n\n        >>> find_median_sorted_arrays([], [])\n        Traceback (most recent call last):\n            ...\n        ValueError: Both input arrays are empty.\n\n        >>> find_median_sorted_arrays([], [1])\n        1.0\n\n        >>> find_median_sorted_arrays([-1000], [1000])\n        0.0\n\n        >>> find_median_sorted_arrays([-1.1, -2.2], [-3.3, -4.4])\n        -2.75\n    \"\"\"\n    if not nums1 and not nums2:\n        raise ValueError(\"Both input arrays are empty.\")\n\n    # Merge the arrays into a single sorted array.\n    merged = sorted(nums1 + nums2)\n    total = len(merged)\n\n    if total % 2 == 1:  # If the total number of elements is odd\n        return float(merged[total // 2])  # then return the middle element\n\n    # If the total number of elements is even, calculate\n    # the average of the two middle elements as the median.\n    middle1 = merged[total // 2 - 1]\n    middle2 = merged[total // 2]\n    return (float(middle1) + float(middle2)) / 2.0",
    "docstring": "Find the median of two arrays.\n\nArgs:\n    nums1: The first array.\n    nums2: The second array.\n\nReturns:\nThe median of the two arrays.\n\nExamples:\n    >>> find_median_sorted_arrays([1, 3], [2])\n    2.0\n\n    >>> find_median_sorted_arrays([1, 2], [3, 4])\n    2.5\n\n    >>> find_median_sorted_arrays([0, 0], [0, 0])\n    0.0\n\n    >>> find_median_sorted_arrays([], [])\n    Traceback (most recent call last):\n        ...\n    ValueError: Both input arrays are empty.\n\n    >>> find_median_sorted_arrays([], [1])\n    1.0\n\n    >>> find_median_sorted_arrays([-1000], [1000])\n    0.0\n\n    >>> find_median_sorted_arrays([-1.1, -2.2], [-3.3, -4.4])\n    -2.75"
  },
  {
    "function": "is_monotonic",
    "code": "def is_monotonic(nums: list[int]) -> bool:\n    \"\"\"\n    Check if a list is monotonic.\n\n    >>> is_monotonic([1, 2, 2, 3])\n    True\n    >>> is_monotonic([6, 5, 4, 4])\n    True\n    >>> is_monotonic([1, 3, 2])\n    False\n    >>> is_monotonic([1,2,3,4,5,6,5])\n    False\n    >>> is_monotonic([-3,-2,-1])\n    True\n    >>> is_monotonic([-5,-6,-7])\n    True\n    >>> is_monotonic([0,0,0])\n    True\n    >>> is_monotonic([-100,0,100])\n    True\n    \"\"\"\n    return all(nums[i] <= nums[i + 1] for i in range(len(nums) - 1)) or all(\n        nums[i] >= nums[i + 1] for i in range(len(nums) - 1)\n    )",
    "docstring": "Check if a list is monotonic.\n\n>>> is_monotonic([1, 2, 2, 3])\nTrue\n>>> is_monotonic([6, 5, 4, 4])\nTrue\n>>> is_monotonic([1, 3, 2])\nFalse\n>>> is_monotonic([1,2,3,4,5,6,5])\nFalse\n>>> is_monotonic([-3,-2,-1])\nTrue\n>>> is_monotonic([-5,-6,-7])\nTrue\n>>> is_monotonic([0,0,0])\nTrue\n>>> is_monotonic([-100,0,100])\nTrue"
  },
  {
    "function": "pairs_with_sum",
    "code": "def pairs_with_sum(arr: list, req_sum: int) -> int:\n    \"\"\"\n    Return the no. of pairs with sum \"sum\"\n    >>> pairs_with_sum([1, 5, 7, 1], 6)\n    2\n    >>> pairs_with_sum([1, 1, 1, 1, 1, 1, 1, 1], 2)\n    28\n    >>> pairs_with_sum([1, 7, 6, 2, 5, 4, 3, 1, 9, 8], 7)\n    4\n    \"\"\"\n    return len([1 for a, b in combinations(arr, 2) if a + b == req_sum])",
    "docstring": "Return the no. of pairs with sum \"sum\"\n>>> pairs_with_sum([1, 5, 7, 1], 6)\n2\n>>> pairs_with_sum([1, 1, 1, 1, 1, 1, 1, 1], 2)\n28\n>>> pairs_with_sum([1, 7, 6, 2, 5, 4, 3, 1, 9, 8], 7)\n4"
  },
  {
    "function": "permute_recursive",
    "code": "def permute_recursive(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Return all permutations.\n\n    >>> permute_recursive([1, 2, 3])\n    [[3, 2, 1], [2, 3, 1], [1, 3, 2], [3, 1, 2], [2, 1, 3], [1, 2, 3]]\n    \"\"\"\n    result: list[list[int]] = []\n    if len(nums) == 0:\n        return [[]]\n    for _ in range(len(nums)):\n        n = nums.pop(0)\n        permutations = permute_recursive(nums.copy())\n        for perm in permutations:\n            perm.append(n)\n        result.extend(permutations)\n        nums.append(n)\n    return result",
    "docstring": "Return all permutations.\n\n>>> permute_recursive([1, 2, 3])\n[[3, 2, 1], [2, 3, 1], [1, 3, 2], [3, 1, 2], [2, 1, 3], [1, 2, 3]]"
  },
  {
    "function": "permute_backtrack",
    "code": "def permute_backtrack(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Return all permutations of the given list.\n\n    >>> permute_backtrack([1, 2, 3])\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]\n    \"\"\"\n\n    def backtrack(start: int) -> None:\n        if start == len(nums) - 1:\n            output.append(nums[:])\n        else:\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack\n\n    output: list[list[int]] = []\n    backtrack(0)\n    return output",
    "docstring": "Return all permutations of the given list.\n\n>>> permute_backtrack([1, 2, 3])\n[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]"
  },
  {
    "function": "product_sum",
    "code": "def product_sum(arr: list[int | list], depth: int) -> int:\n    \"\"\"\n    Recursively calculates the product sum of an array.\n\n    The product sum of an array is defined as the sum of its elements multiplied by\n    their respective depths.  If an element is a list, its product sum is calculated\n    recursively by multiplying the sum of its elements with its depth plus one.\n\n    Args:\n        arr: The array of integers and nested lists.\n        depth: The current depth level.\n\n    Returns:\n        int: The product sum of the array.\n\n    Examples:\n        >>> product_sum([1, 2, 3], 1)\n        6\n        >>> product_sum([-1, 2, [-3, 4]], 2)\n        8\n        >>> product_sum([1, 2, 3], -1)\n        -6\n        >>> product_sum([1, 2, 3], 0)\n        0\n        >>> product_sum([1, 2, 3], 7)\n        42\n        >>> product_sum((1, 2, 3), 7)\n        42\n        >>> product_sum({1, 2, 3}, 7)\n        42\n        >>> product_sum([1, -1], 1)\n        0\n        >>> product_sum([1, -2], 1)\n        -1\n        >>> product_sum([-3.5, [1, [0.5]]], 1)\n        1.5\n\n    \"\"\"\n    total_sum = 0\n    for ele in arr:\n        total_sum += product_sum(ele, depth + 1) if isinstance(ele, list) else ele\n    return total_sum * depth",
    "docstring": "Recursively calculates the product sum of an array.\n\nThe product sum of an array is defined as the sum of its elements multiplied by\ntheir respective depths.  If an element is a list, its product sum is calculated\nrecursively by multiplying the sum of its elements with its depth plus one.\n\nArgs:\n    arr: The array of integers and nested lists.\n    depth: The current depth level.\n\nReturns:\n    int: The product sum of the array.\n\nExamples:\n    >>> product_sum([1, 2, 3], 1)\n    6\n    >>> product_sum([-1, 2, [-3, 4]], 2)\n    8\n    >>> product_sum([1, 2, 3], -1)\n    -6\n    >>> product_sum([1, 2, 3], 0)\n    0\n    >>> product_sum([1, 2, 3], 7)\n    42\n    >>> product_sum((1, 2, 3), 7)\n    42\n    >>> product_sum({1, 2, 3}, 7)\n    42\n    >>> product_sum([1, -1], 1)\n    0\n    >>> product_sum([1, -2], 1)\n    -1\n    >>> product_sum([-3.5, [1, [0.5]]], 1)\n    1.5"
  },
  {
    "function": "product_sum_array",
    "code": "def product_sum_array(array: list[int | list]) -> int:\n    \"\"\"\n    Calculates the product sum of an array.\n\n    Args:\n        array (List[Union[int, List]]): The array of integers and nested lists.\n\n    Returns:\n        int: The product sum of the array.\n\n    Examples:\n        >>> product_sum_array([1, 2, 3])\n        6\n        >>> product_sum_array([1, [2, 3]])\n        11\n        >>> product_sum_array([1, [2, [3, 4]]])\n        47\n        >>> product_sum_array([0])\n        0\n        >>> product_sum_array([-3.5, [1, [0.5]]])\n        1.5\n        >>> product_sum_array([1, -2])\n        -1\n\n    \"\"\"\n    return product_sum(array, 1)",
    "docstring": "Calculates the product sum of an array.\n\nArgs:\n    array (List[Union[int, List]]): The array of integers and nested lists.\n\nReturns:\n    int: The product sum of the array.\n\nExamples:\n    >>> product_sum_array([1, 2, 3])\n    6\n    >>> product_sum_array([1, [2, 3]])\n    11\n    >>> product_sum_array([1, [2, [3, 4]]])\n    47\n    >>> product_sum_array([0])\n    0\n    >>> product_sum_array([-3.5, [1, [0.5]]])\n    1.5\n    >>> product_sum_array([1, -2])\n    -1"
  },
  {
    "function": "rotate_array",
    "code": "def rotate_array(arr: list[int], steps: int) -> list[int]:\n    \"\"\"\n    Rotates a list to the right by steps positions.\n\n    Parameters:\n    arr (List[int]): The list of integers to rotate.\n    steps (int): Number of positions to rotate. Can be negative for left rotation.\n\n    Returns:\n    List[int]: Rotated list.\n\n    Examples:\n    >>> rotate_array([1, 2, 3, 4, 5], 2)\n    [4, 5, 1, 2, 3]\n    >>> rotate_array([1, 2, 3, 4, 5], -2)\n    [3, 4, 5, 1, 2]\n    >>> rotate_array([1, 2, 3, 4, 5], 7)\n    [4, 5, 1, 2, 3]\n    >>> rotate_array([], 3)\n    []\n    \"\"\"\n\n    n = len(arr)\n    if n == 0:\n        return arr\n\n    steps = steps % n\n\n    if steps < 0:\n        steps += n\n\n    def reverse(start: int, end: int) -> None:\n        \"\"\"\n        Reverses a portion of the list in place from index start to end.\n\n        Parameters:\n        start (int): Starting index of the portion to reverse.\n        end (int): Ending index of the portion to reverse.\n\n        Returns:\n        None\n\n        Examples:\n        >>> example = [1, 2, 3, 4, 5]\n        >>> def reverse_test(arr, start, end):\n        ...     while start < end:\n        ...         arr[start], arr[end] = arr[end], arr[start]\n        ...         start += 1\n        ...         end -= 1\n        >>> reverse_test(example, 0, 2)\n        >>> example\n        [3, 2, 1, 4, 5]\n        >>> reverse_test(example, 2, 4)\n        >>> example\n        [3, 2, 5, 4, 1]\n        \"\"\"\n\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    reverse(0, n - 1)\n    reverse(0, steps - 1)\n    reverse(steps, n - 1)\n\n    return arr",
    "docstring": "Rotates a list to the right by steps positions.\n\nParameters:\narr (List[int]): The list of integers to rotate.\nsteps (int): Number of positions to rotate. Can be negative for left rotation.\n\nReturns:\nList[int]: Rotated list.\n\nExamples:\n>>> rotate_array([1, 2, 3, 4, 5], 2)\n[4, 5, 1, 2, 3]\n>>> rotate_array([1, 2, 3, 4, 5], -2)\n[3, 4, 5, 1, 2]\n>>> rotate_array([1, 2, 3, 4, 5], 7)\n[4, 5, 1, 2, 3]\n>>> rotate_array([], 3)\n[]"
  },
  {
    "function": "build_sparse_table",
    "code": "def build_sparse_table(number_list: list[int]) -> list[list[int]]:\n    \"\"\"\n    Precompute range minimum queries with power of two length and store the precomputed\n    values in a table.\n\n    >>> build_sparse_table([8, 1, 0, 3, 4, 9, 3])\n    [[8, 1, 0, 3, 4, 9, 3], [1, 0, 0, 3, 4, 3, 0], [0, 0, 0, 3, 0, 0, 0]]\n    >>> build_sparse_table([3, 1, 9])\n    [[3, 1, 9], [1, 1, 0]]\n    >>> build_sparse_table([])\n    Traceback (most recent call last):\n    ...\n    ValueError: empty number list not allowed\n    \"\"\"\n    if not number_list:\n        raise ValueError(\"empty number list not allowed\")\n\n    length = len(number_list)\n    # Initialise sparse_table -- sparse_table[j][i] represents the minimum value of the\n    # subset of length (2 ** j) of number_list, starting from index i.\n\n    # smallest power of 2 subset length that fully covers number_list\n    row = int(log2(length)) + 1\n    sparse_table = [[0 for i in range(length)] for j in range(row)]\n\n    # minimum of subset of length 1 is that value itself\n    for i, value in enumerate(number_list):\n        sparse_table[0][i] = value\n    j = 1\n\n    # compute the minimum value for all intervals with size (2 ** j)\n    while (1 << j) <= length:\n        i = 0\n        # while subset starting from i still have at least (2 ** j) elements\n        while (i + (1 << j) - 1) < length:\n            # split range [i, i + 2 ** j] and find minimum of 2 halves\n            sparse_table[j][i] = min(\n                sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]\n            )\n            i += 1\n        j += 1\n    return sparse_table",
    "docstring": "Precompute range minimum queries with power of two length and store the precomputed\nvalues in a table.\n\n>>> build_sparse_table([8, 1, 0, 3, 4, 9, 3])\n[[8, 1, 0, 3, 4, 9, 3], [1, 0, 0, 3, 4, 3, 0], [0, 0, 0, 3, 0, 0, 0]]\n>>> build_sparse_table([3, 1, 9])\n[[3, 1, 9], [1, 1, 0]]\n>>> build_sparse_table([])\nTraceback (most recent call last):\n...\nValueError: empty number list not allowed"
  },
  {
    "function": "query",
    "code": "def query(sparse_table: list[list[int]], left_bound: int, right_bound: int) -> int:\n    \"\"\"\n    >>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 0, 4)\n    0\n    >>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 4, 6)\n    3\n    >>> query(build_sparse_table([3, 1, 9]), 2, 2)\n    9\n    >>> query(build_sparse_table([3, 1, 9]), 0, 1)\n    1\n    >>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 0, 11)\n    Traceback (most recent call last):\n    ...\n    IndexError: list index out of range\n    >>> query(build_sparse_table([]), 0, 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: empty number list not allowed\n    \"\"\"\n    if left_bound < 0 or right_bound >= len(sparse_table[0]):\n        raise IndexError(\"list index out of range\")\n\n    # highest subset length of power of 2 that is within range [left_bound, right_bound]\n    j = int(log2(right_bound - left_bound + 1))\n\n    # minimum of 2 overlapping smaller subsets:\n    # [left_bound, left_bound + 2 ** j - 1] and [right_bound - 2 ** j + 1, right_bound]\n    return min(sparse_table[j][right_bound - (1 << j) + 1], sparse_table[j][left_bound])",
    "docstring": ">>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 0, 4)\n0\n>>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 4, 6)\n3\n>>> query(build_sparse_table([3, 1, 9]), 2, 2)\n9\n>>> query(build_sparse_table([3, 1, 9]), 0, 1)\n1\n>>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 0, 11)\nTraceback (most recent call last):\n...\nIndexError: list index out of range\n>>> query(build_sparse_table([]), 0, 0)\nTraceback (most recent call last):\n...\nValueError: empty number list not allowed"
  },
  {
    "function": "cross",
    "code": "def cross(items_a, items_b):\n    \"\"\"\n    Cross product of elements in A and elements in B.\n\n    >>> cross('AB', '12')\n    ['A1', 'A2', 'B1', 'B2']\n    >>> cross('ABC', '123')\n    ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']\n    >>> cross('ABC', '1234')\n    ['A1', 'A2', 'A3', 'A4', 'B1', 'B2', 'B3', 'B4', 'C1', 'C2', 'C3', 'C4']\n    >>> cross('', '12')\n    []\n    >>> cross('A', '')\n    []\n    >>> cross('', '')\n    []\n    \"\"\"\n    return [a + b for a in items_a for b in items_b]",
    "docstring": "Cross product of elements in A and elements in B.\n\n>>> cross('AB', '12')\n['A1', 'A2', 'B1', 'B2']\n>>> cross('ABC', '123')\n['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']\n>>> cross('ABC', '1234')\n['A1', 'A2', 'A3', 'A4', 'B1', 'B2', 'B3', 'B4', 'C1', 'C2', 'C3', 'C4']\n>>> cross('', '12')\n[]\n>>> cross('A', '')\n[]\n>>> cross('', '')\n[]"
  },
  {
    "function": "test",
    "code": "def test():\n    \"\"\"A set of unit tests.\"\"\"\n    assert len(squares) == 81\n    assert len(unitlist) == 27\n    assert all(len(units[s]) == 3 for s in squares)\n    assert all(len(peers[s]) == 20 for s in squares)\n    assert units[\"C2\"] == [\n        [\"A2\", \"B2\", \"C2\", \"D2\", \"E2\", \"F2\", \"G2\", \"H2\", \"I2\"],\n        [\"C1\", \"C2\", \"C3\", \"C4\", \"C5\", \"C6\", \"C7\", \"C8\", \"C9\"],\n        [\"A1\", \"A2\", \"A3\", \"B1\", \"B2\", \"B3\", \"C1\", \"C2\", \"C3\"],\n    ]\n    # fmt: off\n    assert peers[\"C2\"] == {\n        \"A2\", \"B2\", \"D2\", \"E2\", \"F2\", \"G2\", \"H2\", \"I2\", \"C1\", \"C3\",\n        \"C4\", \"C5\", \"C6\", \"C7\", \"C8\", \"C9\", \"A1\", \"A3\", \"B1\", \"B3\"\n    }\n    # fmt: on\n    print(\"All tests pass.\")",
    "docstring": "A set of unit tests."
  },
  {
    "function": "parse_grid",
    "code": "def parse_grid(grid):\n    \"\"\"\n    Convert grid to a dict of possible values, {square: digits}, or\n    return False if a contradiction is detected.\n    \"\"\"\n    ## To start, every square can be any digit; then assign values from the grid.\n    values = dict.fromkeys(squares, digits)\n    for s, d in grid_values(grid).items():\n        if d in digits and not assign(values, s, d):\n            return False  ## (Fail if we can't assign d to square s.)\n    return values",
    "docstring": "Convert grid to a dict of possible values, {square: digits}, or\nreturn False if a contradiction is detected."
  },
  {
    "function": "grid_values",
    "code": "def grid_values(grid):\n    \"\"\"\n    Convert grid into a dict of {square: char} with '0' or '.' for empties.\n    \"\"\"\n    chars = [c for c in grid if c in digits or c in \"0.\"]\n    assert len(chars) == 81\n    return dict(zip(squares, chars))",
    "docstring": "Convert grid into a dict of {square: char} with '0' or '.' for empties."
  },
  {
    "function": "assign",
    "code": "def assign(values, s, d):\n    \"\"\"\n    Eliminate all the other values (except d) from values[s] and propagate.\n    Return values, except return False if a contradiction is detected.\n    \"\"\"\n    other_values = values[s].replace(d, \"\")\n    if all(eliminate(values, s, d2) for d2 in other_values):\n        return values\n    else:\n        return False",
    "docstring": "Eliminate all the other values (except d) from values[s] and propagate.\nReturn values, except return False if a contradiction is detected."
  },
  {
    "function": "eliminate",
    "code": "def eliminate(values, s, d):\n    \"\"\"\n    Eliminate d from values[s]; propagate when values or places <= 2.\n    Return values, except return False if a contradiction is detected.\n    \"\"\"\n    if d not in values[s]:\n        return values  ## Already eliminated\n    values[s] = values[s].replace(d, \"\")\n    ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.\n    if len(values[s]) == 0:\n        return False  ## Contradiction: removed last value\n    elif len(values[s]) == 1:\n        d2 = values[s]\n        if not all(eliminate(values, s2, d2) for s2 in peers[s]):\n            return False\n    ## (2) If a unit u is reduced to only one place for a value d, then put it there.\n    for u in units[s]:\n        dplaces = [s for s in u if d in values[s]]\n        if len(dplaces) == 0:\n            return False  ## Contradiction: no place for this value\n        # d can only be in one place in unit; assign it there\n        elif len(dplaces) == 1 and not assign(values, dplaces[0], d):\n            return False\n    return values",
    "docstring": "Eliminate d from values[s]; propagate when values or places <= 2.\nReturn values, except return False if a contradiction is detected."
  },
  {
    "function": "display",
    "code": "def display(values):\n    \"\"\"\n    Display these values as a 2-D grid.\n    \"\"\"\n    width = 1 + max(len(values[s]) for s in squares)\n    line = \"+\".join([\"-\" * (width * 3)] * 3)\n    for r in rows:\n        print(\n            \"\".join(\n                values[r + c].center(width) + (\"|\" if c in \"36\" else \"\") for c in cols\n            )\n        )\n        if r in \"CF\":\n            print(line)\n    print()",
    "docstring": "Display these values as a 2-D grid."
  },
  {
    "function": "solve",
    "code": "def solve(grid):\n    \"\"\"\n    Solve the grid.\n    \"\"\"\n    return search(parse_grid(grid))",
    "docstring": "Solve the grid."
  },
  {
    "function": "some",
    "code": "def some(seq):\n    \"\"\"Return some element of seq that is true.\"\"\"\n    for e in seq:\n        if e:\n            return e\n    return False",
    "docstring": "Return some element of seq that is true."
  },
  {
    "function": "search",
    "code": "def search(values):\n    \"\"\"\n    Using depth-first search and propagation, try all possible values.\n    \"\"\"\n    if values is False:\n        return False  ## Failed earlier\n    if all(len(values[s]) == 1 for s in squares):\n        return values  ## Solved!\n    ## Chose the unfilled square s with the fewest possibilities\n    _n, s = min((len(values[s]), s) for s in squares if len(values[s]) > 1)\n    return some(search(assign(values.copy(), s, d)) for d in values[s])",
    "docstring": "Using depth-first search and propagation, try all possible values."
  },
  {
    "function": "solve_all",
    "code": "def solve_all(grids, name=\"\", showif=0.0):\n    \"\"\"\n    Attempt to solve a sequence of grids. Report results.\n    When showif is a number of seconds, display puzzles that take longer.\n    When showif is None, don't display any puzzles.\n    \"\"\"\n\n    def time_solve(grid):\n        start = time.monotonic()\n        values = solve(grid)\n        t = time.monotonic() - start\n        ## Display puzzles that take long enough\n        if showif is not None and t > showif:\n            display(grid_values(grid))\n            if values:\n                display(values)\n            print(f\"({t:.5f} seconds)\\n\")\n        return (t, solved(values))\n\n    times, results = zip(*[time_solve(grid) for grid in grids])\n    if (n := len(grids)) > 1:\n        print(\n            \"Solved %d of %d %s puzzles (avg %.2f secs (%d Hz), max %.2f secs).\"  # noqa: UP031\n            % (sum(results), n, name, sum(times) / n, n / sum(times), max(times))\n        )",
    "docstring": "Attempt to solve a sequence of grids. Report results.\nWhen showif is a number of seconds, display puzzles that take longer.\nWhen showif is None, don't display any puzzles."
  },
  {
    "function": "solved",
    "code": "def solved(values):\n    \"\"\"\n    A puzzle is solved if each unit is a permutation of the digits 1 to 9.\n    \"\"\"\n\n    def unitsolved(unit):\n        return {values[s] for s in unit} == set(digits)\n\n    return values is not False and all(unitsolved(unit) for unit in unitlist)",
    "docstring": "A puzzle is solved if each unit is a permutation of the digits 1 to 9."
  },
  {
    "function": "from_file",
    "code": "def from_file(filename, sep=\"\\n\"):\n    \"Parse a file into a list of strings, separated by sep.\"\n    with open(filename) as file:\n        return file.read().strip().split(sep)",
    "docstring": "Parse a file into a list of strings, separated by sep."
  },
  {
    "function": "random_puzzle",
    "code": "def random_puzzle(assignments=17):\n    \"\"\"\n    Make a random puzzle with N or more assignments. Restart on contradictions.\n    Note the resulting puzzle is not guaranteed to be solvable, but empirically\n    about 99.8% of them are solvable. Some have multiple solutions.\n    \"\"\"\n    values = dict.fromkeys(squares, digits)\n    for s in shuffled(squares):\n        if not assign(values, s, random.choice(values[s])):\n            break\n        ds = [values[s] for s in squares if len(values[s]) == 1]\n        if len(ds) >= assignments and len(set(ds)) >= 8:\n            return \"\".join(values[s] if len(values[s]) == 1 else \".\" for s in squares)\n    return random_puzzle(assignments)  ## Give up and make a new puzzle",
    "docstring": "Make a random puzzle with N or more assignments. Restart on contradictions.\nNote the resulting puzzle is not guaranteed to be solvable, but empirically\nabout 99.8% of them are solvable. Some have multiple solutions."
  },
  {
    "function": "shuffled",
    "code": "def shuffled(seq):\n    \"\"\"\n    Return a randomly shuffled copy of the input sequence.\n    \"\"\"\n    seq = list(seq)\n    random.shuffle(seq)\n    return seq",
    "docstring": "Return a randomly shuffled copy of the input sequence."
  },
  {
    "function": "right_rotation",
    "code": "def right_rotation(node: MyNode) -> MyNode:\n    r\"\"\"\n            A                      B\n           / \\                    / \\\n          B   C                  Bl  A\n         / \\       -->          /   / \\\n        Bl  Br                 UB Br  C\n       /\n     UB\n    UB = unbalanced node\n    \"\"\"\n    print(\"left rotation node:\", node.get_data())\n    ret = node.get_left()\n    assert ret is not None\n    node.set_left(ret.get_right())\n    ret.set_right(node)\n    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1\n    node.set_height(h1)\n    h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1\n    ret.set_height(h2)\n    return ret",
    "docstring": "A                      B\n       / \\                    / \\\n      B   C                  Bl  A\n     / \\       -->          /   / \\\n    Bl  Br                 UB Br  C\n   /\n UB\nUB = unbalanced node"
  },
  {
    "function": "left_rotation",
    "code": "def left_rotation(node: MyNode) -> MyNode:\n    \"\"\"\n    a mirror symmetry rotation of the left_rotation\n    \"\"\"\n    print(\"right rotation node:\", node.get_data())\n    ret = node.get_right()\n    assert ret is not None\n    node.set_right(ret.get_left())\n    ret.set_left(node)\n    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1\n    node.set_height(h1)\n    h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1\n    ret.set_height(h2)\n    return ret",
    "docstring": "a mirror symmetry rotation of the left_rotation"
  },
  {
    "function": "lr_rotation",
    "code": "def lr_rotation(node: MyNode) -> MyNode:\n    r\"\"\"\n            A              A                    Br\n           / \\            / \\                  /  \\\n          B   C    LR    Br  C       RR       B    A\n         / \\       -->  /  \\         -->    /     / \\\n        Bl  Br         B   UB              Bl    UB  C\n             \\        /\n             UB     Bl\n    RR = right_rotation   LR = left_rotation\n    \"\"\"\n    left_child = node.get_left()\n    assert left_child is not None\n    node.set_left(left_rotation(left_child))\n    return right_rotation(node)",
    "docstring": "A              A                    Br\n       / \\            / \\                  /  \\\n      B   C    LR    Br  C       RR       B    A\n     / \\       -->  /  \\         -->    /     / \\\n    Bl  Br         B   UB              Bl    UB  C\n         \\        /\n         UB     Bl\nRR = right_rotation   LR = left_rotation"
  },
  {
    "function": "inorder",
    "code": "def inorder(curr_node: Node | None) -> list[Node]:\n    \"\"\"\n    inorder (left, self, right)\n    \"\"\"\n    node_list = []\n    if curr_node is not None:\n        node_list = [*inorder(curr_node.left), curr_node, *inorder(curr_node.right)]\n    return node_list",
    "docstring": "inorder (left, self, right)"
  },
  {
    "function": "postorder",
    "code": "def postorder(curr_node: Node | None) -> list[Node]:\n    \"\"\"\n    postOrder (left, right, self)\n    \"\"\"\n    node_list = []\n    if curr_node is not None:\n        node_list = postorder(curr_node.left) + postorder(curr_node.right) + [curr_node]\n    return node_list",
    "docstring": "postOrder (left, right, self)"
  },
  {
    "function": "binary_search_tree_example",
    "code": "def binary_search_tree_example() -> None:\n    r\"\"\"\n    Example\n                  8\n                 / \\\n                3   10\n               / \\    \\\n              1   6    14\n                 / \\   /\n                4   7 13\n                \\\n                5\n\n    Example After Deletion\n                  4\n                 / \\\n                1   7\n                     \\\n                      5\n\n    \"\"\"\n\n    t = BinarySearchTree()\n    t.put(8)\n    t.put(3)\n    t.put(6)\n    t.put(1)\n    t.put(10)\n    t.put(14)\n    t.put(13)\n    t.put(4)\n    t.put(7)\n    t.put(5)\n\n    print(\n        \"\"\"\n            8\n           / \\\\\n          3   10\n         / \\\\    \\\\\n        1   6    14\n           / \\\\   /\n          4   7 13\n           \\\\\n            5\n        \"\"\"\n    )\n\n    print(\"Label 6 exists:\", t.exists(6))\n    print(\"Label 13 exists:\", t.exists(13))\n    print(\"Label -1 exists:\", t.exists(-1))\n    print(\"Label 12 exists:\", t.exists(12))\n\n    # Prints all the elements of the list in inorder traversal\n    inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]\n    print(\"Inorder traversal:\", inorder_traversal_nodes)\n\n    # Prints all the elements of the list in preorder traversal\n    preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]\n    print(\"Preorder traversal:\", preorder_traversal_nodes)\n\n    print(\"Max. label:\", t.get_max_label())\n    print(\"Min. label:\", t.get_min_label())\n\n    # Delete elements\n    print(\"\\nDeleting elements 13, 10, 8, 3, 6, 14\")\n    print(\n        \"\"\"\n          4\n         / \\\\\n        1   7\n             \\\\\n              5\n        \"\"\"\n    )\n    t.remove(13)\n    t.remove(10)\n    t.remove(8)\n    t.remove(3)\n    t.remove(6)\n    t.remove(14)\n\n    # Prints all the elements of the list in inorder traversal after delete\n    inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]\n    print(\"Inorder traversal after delete:\", inorder_traversal_nodes)\n\n    # Prints all the elements of the list in preorder traversal after delete\n    preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]\n    print(\"Preorder traversal after delete:\", preorder_traversal_nodes)\n\n    print(\"Max. label:\", t.get_max_label())\n    print(\"Min. label:\", t.get_min_label())",
    "docstring": "Example\n              8\n             / \\\n            3   10\n           / \\    \\\n          1   6    14\n             / \\   /\n            4   7 13\n            \\\n            5\n\nExample After Deletion\n              4\n             / \\\n            1   7\n                 \\\n                  5"
  },
  {
    "function": "binary_tree_mirror",
    "code": "def binary_tree_mirror(binary_tree: dict, root: int = 1) -> dict:\n    \"\"\"\n    >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 7: [8,9]}, 1)\n    {1: [3, 2], 2: [5, 4], 3: [7, 6], 7: [9, 8]}\n    >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 1)\n    {1: [3, 2], 2: [5, 4], 3: [7, 6], 4: [11, 10]}\n    >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: root 5 is not present in the binary_tree\n    >>> binary_tree_mirror({}, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: binary tree cannot be empty\n    \"\"\"\n    if not binary_tree:\n        raise ValueError(\"binary tree cannot be empty\")\n    if root not in binary_tree:\n        msg = f\"root {root} is not present in the binary_tree\"\n        raise ValueError(msg)\n    binary_tree_mirror_dictionary = dict(binary_tree)\n    binary_tree_mirror_dict(binary_tree_mirror_dictionary, root)\n    return binary_tree_mirror_dictionary",
    "docstring": ">>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 7: [8,9]}, 1)\n{1: [3, 2], 2: [5, 4], 3: [7, 6], 7: [9, 8]}\n>>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 1)\n{1: [3, 2], 2: [5, 4], 3: [7, 6], 4: [11, 10]}\n>>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 5)\nTraceback (most recent call last):\n    ...\nValueError: root 5 is not present in the binary_tree\n>>> binary_tree_mirror({}, 5)\nTraceback (most recent call last):\n    ...\nValueError: binary tree cannot be empty"
  },
  {
    "function": "make_tree",
    "code": "def make_tree() -> Node | None:\n    r\"\"\"\n    The below tree\n        1\n       / \\\n      2   3\n     / \\\n    4   5\n    \"\"\"\n    tree = Node(1)\n    tree.left = Node(2)\n    tree.right = Node(3)\n    tree.left.left = Node(4)\n    tree.left.right = Node(5)\n    return tree",
    "docstring": "The below tree\n    1\n   / \\\n  2   3\n / \\\n4   5"
  },
  {
    "function": "preorder",
    "code": "def preorder(root: Node | None) -> Generator[int]:\n    \"\"\"\n    Pre-order traversal visits root node, left subtree, right subtree.\n    >>> list(preorder(make_tree()))\n    [1, 2, 4, 5, 3]\n    \"\"\"\n    if not root:\n        return\n    yield root.data\n    yield from preorder(root.left)\n    yield from preorder(root.right)",
    "docstring": "Pre-order traversal visits root node, left subtree, right subtree.\n>>> list(preorder(make_tree()))\n[1, 2, 4, 5, 3]"
  },
  {
    "function": "postorder",
    "code": "def postorder(root: Node | None) -> Generator[int]:\n    \"\"\"\n    Post-order traversal visits left subtree, right subtree, root node.\n    >>> list(postorder(make_tree()))\n    [4, 5, 2, 3, 1]\n    \"\"\"\n    if not root:\n        return\n    yield from postorder(root.left)\n    yield from postorder(root.right)\n    yield root.data",
    "docstring": "Post-order traversal visits left subtree, right subtree, root node.\n>>> list(postorder(make_tree()))\n[4, 5, 2, 3, 1]"
  },
  {
    "function": "inorder",
    "code": "def inorder(root: Node | None) -> Generator[int]:\n    \"\"\"\n    In-order traversal visits left subtree, root node, right subtree.\n    >>> list(inorder(make_tree()))\n    [4, 2, 5, 1, 3]\n    \"\"\"\n    if not root:\n        return\n    yield from inorder(root.left)\n    yield root.data\n    yield from inorder(root.right)",
    "docstring": "In-order traversal visits left subtree, root node, right subtree.\n>>> list(inorder(make_tree()))\n[4, 2, 5, 1, 3]"
  },
  {
    "function": "reverse_inorder",
    "code": "def reverse_inorder(root: Node | None) -> Generator[int]:\n    \"\"\"\n    Reverse in-order traversal visits right subtree, root node, left subtree.\n    >>> list(reverse_inorder(make_tree()))\n    [3, 1, 5, 2, 4]\n    \"\"\"\n    if not root:\n        return\n    yield from reverse_inorder(root.right)\n    yield root.data\n    yield from reverse_inorder(root.left)",
    "docstring": "Reverse in-order traversal visits right subtree, root node, left subtree.\n>>> list(reverse_inorder(make_tree()))\n[3, 1, 5, 2, 4]"
  },
  {
    "function": "height",
    "code": "def height(root: Node | None) -> int:\n    \"\"\"\n    Recursive function for calculating the height of the binary tree.\n    >>> height(None)\n    0\n    >>> height(make_tree())\n    3\n    \"\"\"\n    return (max(height(root.left), height(root.right)) + 1) if root else 0",
    "docstring": "Recursive function for calculating the height of the binary tree.\n>>> height(None)\n0\n>>> height(make_tree())\n3"
  },
  {
    "function": "level_order",
    "code": "def level_order(root: Node | None) -> Generator[int]:\n    \"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    >>> list(level_order(make_tree()))\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    if root is None:\n        return\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        yield node.data\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)",
    "docstring": "Returns a list of nodes value from a whole binary tree in Level Order Traverse.\nLevel Order traverse: Visit nodes of the tree level-by-level.\n>>> list(level_order(make_tree()))\n[1, 2, 3, 4, 5]"
  },
  {
    "function": "get_nodes_from_left_to_right",
    "code": "def get_nodes_from_left_to_right(root: Node | None, level: int) -> Generator[int]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    >>> list(get_nodes_from_left_to_right(make_tree(), 1))\n    [1]\n    >>> list(get_nodes_from_left_to_right(make_tree(), 2))\n    [2, 3]\n    \"\"\"\n\n    def populate_output(root: Node | None, level: int) -> Generator[int]:\n        if not root:\n            return\n        if level == 1:\n            yield root.data\n        elif level > 1:\n            yield from populate_output(root.left, level - 1)\n            yield from populate_output(root.right, level - 1)\n\n    yield from populate_output(root, level)",
    "docstring": "Returns a list of nodes value from a particular level:\nLeft to right direction of the binary tree.\n>>> list(get_nodes_from_left_to_right(make_tree(), 1))\n[1]\n>>> list(get_nodes_from_left_to_right(make_tree(), 2))\n[2, 3]"
  },
  {
    "function": "get_nodes_from_right_to_left",
    "code": "def get_nodes_from_right_to_left(root: Node | None, level: int) -> Generator[int]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    >>> list(get_nodes_from_right_to_left(make_tree(), 1))\n    [1]\n    >>> list(get_nodes_from_right_to_left(make_tree(), 2))\n    [3, 2]\n    \"\"\"\n\n    def populate_output(root: Node | None, level: int) -> Generator[int]:\n        if not root:\n            return\n        if level == 1:\n            yield root.data\n        elif level > 1:\n            yield from populate_output(root.right, level - 1)\n            yield from populate_output(root.left, level - 1)\n\n    yield from populate_output(root, level)",
    "docstring": "Returns a list of nodes value from a particular level:\nRight to left direction of the binary tree.\n>>> list(get_nodes_from_right_to_left(make_tree(), 1))\n[1]\n>>> list(get_nodes_from_right_to_left(make_tree(), 2))\n[3, 2]"
  },
  {
    "function": "zigzag",
    "code": "def zigzag(root: Node | None) -> Generator[int]:\n    \"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    >>> list(zigzag(make_tree()))\n    [1, 3, 2, 4, 5]\n    \"\"\"\n    if root is None:\n        return\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        if not flag:\n            yield from get_nodes_from_left_to_right(root, h)\n            flag = 1\n        else:\n            yield from get_nodes_from_right_to_left(root, h)\n            flag = 0",
    "docstring": "ZigZag traverse:\nReturns a list of nodes value from left to right and right to left, alternatively.\n>>> list(zigzag(make_tree()))\n[1, 3, 2, 4, 5]"
  },
  {
    "function": "make_tree",
    "code": "def make_tree() -> TreeNode:\n    \"\"\"\n    >>> make_tree().val\n    3\n    \"\"\"\n    return TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))",
    "docstring": ">>> make_tree().val\n3"
  },
  {
    "function": "binary_tree_right_side_view",
    "code": "def binary_tree_right_side_view(root: TreeNode) -> list[int]:\n    r\"\"\"\n    Function returns the right side view of binary tree.\n\n       3       <-  3\n     / \\\n    9   20    <-  20\n       /  \\\n      15   7  <-  7\n\n    >>> binary_tree_right_side_view(make_tree())\n    [3, 20, 7]\n    >>> binary_tree_right_side_view(None)\n    []\n    \"\"\"\n\n    def depth_first_search(\n        root: TreeNode | None, depth: int, right_view: list[int]\n    ) -> None:\n        \"\"\"\n        A depth first search preorder traversal to append the values at\n        right side of tree.\n        \"\"\"\n        if not root:\n            return\n\n        if depth == len(right_view):\n            right_view.append(root.val)\n\n        depth_first_search(root.right, depth + 1, right_view)\n        depth_first_search(root.left, depth + 1, right_view)\n\n    right_view: list = []\n    if not root:\n        return right_view\n\n    depth_first_search(root, 0, right_view)\n    return right_view",
    "docstring": "Function returns the right side view of binary tree.\n\n   3       <-  3\n / \\\n9   20    <-  20\n   /  \\\n  15   7  <-  7\n\n>>> binary_tree_right_side_view(make_tree())\n[3, 20, 7]\n>>> binary_tree_right_side_view(None)\n[]"
  },
  {
    "function": "binary_tree_left_side_view",
    "code": "def binary_tree_left_side_view(root: TreeNode) -> list[int]:\n    r\"\"\"\n    Function returns the left side view of binary tree.\n\n    3  ->    3\n            / \\\n    9  ->  9   20\n              /  \\\n    15 ->    15   7\n\n    >>> binary_tree_left_side_view(make_tree())\n    [3, 9, 15]\n    >>> binary_tree_left_side_view(None)\n    []\n    \"\"\"\n\n    def depth_first_search(\n        root: TreeNode | None, depth: int, left_view: list[int]\n    ) -> None:\n        \"\"\"\n        A depth first search preorder traversal to append the values\n        at left side of tree.\n        \"\"\"\n        if not root:\n            return\n\n        if depth == len(left_view):\n            left_view.append(root.val)\n\n        depth_first_search(root.left, depth + 1, left_view)\n        depth_first_search(root.right, depth + 1, left_view)\n\n    left_view: list = []\n    if not root:\n        return left_view\n\n    depth_first_search(root, 0, left_view)\n    return left_view",
    "docstring": "Function returns the left side view of binary tree.\n\n3  ->    3\n        / \\\n9  ->  9   20\n          /  \\\n15 ->    15   7\n\n>>> binary_tree_left_side_view(make_tree())\n[3, 9, 15]\n>>> binary_tree_left_side_view(None)\n[]"
  },
  {
    "function": "binary_tree_top_side_view",
    "code": "def binary_tree_top_side_view(root: TreeNode) -> list[int]:\n    r\"\"\"\n    Function returns the top side view of binary tree.\n\n    9 3 20 7\n    \u2b07 \u2b07 \u2b07  \u2b07\n\n      3\n     / \\\n    9   20\n       /  \\\n      15   7\n\n    >>> binary_tree_top_side_view(make_tree())\n    [9, 3, 20, 7]\n    >>> binary_tree_top_side_view(None)\n    []\n    \"\"\"\n\n    def breadth_first_search(root: TreeNode, top_view: list[int]) -> None:\n        \"\"\"\n        A breadth first search traversal with defaultdict ds to append\n        the values of tree from top view\n        \"\"\"\n        queue = [(root, 0)]\n        lookup = defaultdict(list)\n\n        while queue:\n            first = queue.pop(0)\n            node, hd = first\n\n            lookup[hd].append(node.val)\n\n            if node.left:\n                queue.append((node.left, hd - 1))\n            if node.right:\n                queue.append((node.right, hd + 1))\n\n        for pair in sorted(lookup.items(), key=lambda each: each[0]):\n            top_view.append(pair[1][0])\n\n    top_view: list = []\n    if not root:\n        return top_view\n\n    breadth_first_search(root, top_view)\n    return top_view",
    "docstring": "Function returns the top side view of binary tree.\n\n9 3 20 7\n\u2b07 \u2b07 \u2b07  \u2b07\n\n  3\n / \\\n9   20\n   /  \\\n  15   7\n\n>>> binary_tree_top_side_view(make_tree())\n[9, 3, 20, 7]\n>>> binary_tree_top_side_view(None)\n[]"
  },
  {
    "function": "binary_tree_bottom_side_view",
    "code": "def binary_tree_bottom_side_view(root: TreeNode) -> list[int]:\n    r\"\"\"\n    Function returns the bottom side view of binary tree\n\n      3\n     / \\\n    9   20\n       /  \\\n      15   7\n    \u2191  \u2191 \u2191  \u2191\n    9 15 20 7\n\n    >>> binary_tree_bottom_side_view(make_tree())\n    [9, 15, 20, 7]\n    >>> binary_tree_bottom_side_view(None)\n    []\n    \"\"\"\n    from collections import defaultdict\n\n    def breadth_first_search(root: TreeNode, bottom_view: list[int]) -> None:\n        \"\"\"\n        A breadth first search traversal with defaultdict ds to append\n        the values of tree from bottom view\n        \"\"\"\n        queue = [(root, 0)]\n        lookup = defaultdict(list)\n\n        while queue:\n            first = queue.pop(0)\n            node, hd = first\n            lookup[hd].append(node.val)\n\n            if node.left:\n                queue.append((node.left, hd - 1))\n            if node.right:\n                queue.append((node.right, hd + 1))\n\n        for pair in sorted(lookup.items(), key=lambda each: each[0]):\n            bottom_view.append(pair[1][-1])\n\n    bottom_view: list = []\n    if not root:\n        return bottom_view\n\n    breadth_first_search(root, bottom_view)\n    return bottom_view",
    "docstring": "Function returns the bottom side view of binary tree\n\n  3\n / \\\n9   20\n   /  \\\n  15   7\n\u2191  \u2191 \u2191  \u2191\n9 15 20 7\n\n>>> binary_tree_bottom_side_view(make_tree())\n[9, 15, 20, 7]\n>>> binary_tree_bottom_side_view(None)\n[]"
  },
  {
    "function": "distribute_coins",
    "code": "def distribute_coins(root: TreeNode | None) -> int:\n    \"\"\"\n    >>> distribute_coins(TreeNode(3, TreeNode(0), TreeNode(0)))\n    2\n    >>> distribute_coins(TreeNode(0, TreeNode(3), TreeNode(0)))\n    3\n    >>> distribute_coins(TreeNode(0, TreeNode(0), TreeNode(3)))\n    3\n    >>> distribute_coins(None)\n    0\n    >>> distribute_coins(TreeNode(0, TreeNode(0), TreeNode(0)))\n    Traceback (most recent call last):\n     ...\n    ValueError: The nodes number should be same as the number of coins\n    >>> distribute_coins(TreeNode(0, TreeNode(1), TreeNode(1)))\n    Traceback (most recent call last):\n     ...\n    ValueError: The nodes number should be same as the number of coins\n    \"\"\"\n\n    if root is None:\n        return 0\n\n    # Validation\n    def count_nodes(node: TreeNode | None) -> int:\n        \"\"\"\n        >>> count_nodes(None)\n        0\n        \"\"\"\n        if node is None:\n            return 0\n\n        return count_nodes(node.left) + count_nodes(node.right) + 1\n\n    def count_coins(node: TreeNode | None) -> int:\n        \"\"\"\n        >>> count_coins(None)\n        0\n        \"\"\"\n        if node is None:\n            return 0\n\n        return count_coins(node.left) + count_coins(node.right) + node.data\n\n    if count_nodes(root) != count_coins(root):\n        raise ValueError(\"The nodes number should be same as the number of coins\")\n\n    # Main calculation\n    def get_distrib(node: TreeNode | None) -> CoinsDistribResult:\n        \"\"\"\n        >>> get_distrib(None)\n        namedtuple(\"CoinsDistribResult\", \"0 2\")\n        \"\"\"\n\n        if node is None:\n            return CoinsDistribResult(0, 1)\n\n        left_distrib_moves, left_distrib_excess = get_distrib(node.left)\n        right_distrib_moves, right_distrib_excess = get_distrib(node.right)\n\n        coins_to_left = 1 - left_distrib_excess\n        coins_to_right = 1 - right_distrib_excess\n\n        result_moves = (\n            left_distrib_moves\n            + right_distrib_moves\n            + abs(coins_to_left)\n            + abs(coins_to_right)\n        )\n        result_excess = node.data - coins_to_left - coins_to_right\n\n        return CoinsDistribResult(result_moves, result_excess)\n\n    return get_distrib(root)[0]",
    "docstring": ">>> distribute_coins(TreeNode(3, TreeNode(0), TreeNode(0)))\n2\n>>> distribute_coins(TreeNode(0, TreeNode(3), TreeNode(0)))\n3\n>>> distribute_coins(TreeNode(0, TreeNode(0), TreeNode(3)))\n3\n>>> distribute_coins(None)\n0\n>>> distribute_coins(TreeNode(0, TreeNode(0), TreeNode(0)))\nTraceback (most recent call last):\n ...\nValueError: The nodes number should be same as the number of coins\n>>> distribute_coins(TreeNode(0, TreeNode(1), TreeNode(1)))\nTraceback (most recent call last):\n ...\nValueError: The nodes number should be same as the number of coins"
  },
  {
    "function": "build_tree",
    "code": "def build_tree() -> TreeNode:\n    \"\"\"\n    Build and return a sample binary tree.\n\n    Returns:\n        TreeNode: The root of the binary tree.\n\n    Examples:\n        >>> root = build_tree()\n        >>> root.data\n        1\n        >>> root.left.data\n        2\n        >>> root.right.data\n        5\n        >>> root.left.left.data\n        3\n        >>> root.left.right.data\n        4\n        >>> root.right.right.data\n        6\n    \"\"\"\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(5)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.right = TreeNode(6)\n    return root",
    "docstring": "Build and return a sample binary tree.\n\nReturns:\n    TreeNode: The root of the binary tree.\n\nExamples:\n    >>> root = build_tree()\n    >>> root.data\n    1\n    >>> root.left.data\n    2\n    >>> root.right.data\n    5\n    >>> root.left.left.data\n    3\n    >>> root.left.right.data\n    4\n    >>> root.right.right.data\n    6"
  },
  {
    "function": "flatten",
    "code": "def flatten(root: TreeNode | None) -> None:\n    \"\"\"\n    Flatten a binary tree into a linked list in-place, where the linked list is\n    represented using the right pointers of the tree nodes.\n\n    Args:\n        root (TreeNode): The root of the binary tree to be flattened.\n\n    Examples:\n        >>> root = TreeNode(1)\n        >>> root.left = TreeNode(2)\n        >>> root.right = TreeNode(5)\n        >>> root.left.left = TreeNode(3)\n        >>> root.left.right = TreeNode(4)\n        >>> root.right.right = TreeNode(6)\n        >>> flatten(root)\n        >>> root.data\n        1\n        >>> root.right.right is None\n        False\n        >>> root.right.right = TreeNode(3)\n        >>> root.right.right.right is None\n        True\n    \"\"\"\n    if not root:\n        return\n\n    # Flatten the left subtree\n    flatten(root.left)\n\n    # Save the right subtree\n    right_subtree = root.right\n\n    # Make the left subtree the new right subtree\n    root.right = root.left\n    root.left = None\n\n    # Find the end of the new right subtree\n    current = root\n    while current.right:\n        current = current.right\n\n    # Append the original right subtree to the end\n    current.right = right_subtree\n\n    # Flatten the updated right subtree\n    flatten(right_subtree)",
    "docstring": "Flatten a binary tree into a linked list in-place, where the linked list is\nrepresented using the right pointers of the tree nodes.\n\nArgs:\n    root (TreeNode): The root of the binary tree to be flattened.\n\nExamples:\n    >>> root = TreeNode(1)\n    >>> root.left = TreeNode(2)\n    >>> root.right = TreeNode(5)\n    >>> root.left.left = TreeNode(3)\n    >>> root.left.right = TreeNode(4)\n    >>> root.right.right = TreeNode(6)\n    >>> flatten(root)\n    >>> root.data\n    1\n    >>> root.right.right is None\n    False\n    >>> root.right.right = TreeNode(3)\n    >>> root.right.right.right is None\n    True"
  },
  {
    "function": "display_linked_list",
    "code": "def display_linked_list(root: TreeNode | None) -> None:\n    \"\"\"\n    Display the flattened linked list.\n\n    Args:\n        root (TreeNode | None): The root of the flattened linked list.\n\n    Examples:\n        >>> root = TreeNode(1)\n        >>> root.right = TreeNode(2)\n        >>> root.right.right = TreeNode(3)\n        >>> display_linked_list(root)\n        1 2 3\n        >>> root = None\n        >>> display_linked_list(root)\n\n    \"\"\"\n    current = root\n    while current:\n        if current.right is None:\n            print(current.data, end=\"\")\n            break\n        print(current.data, end=\" \")\n        current = current.right",
    "docstring": "Display the flattened linked list.\n\nArgs:\n    root (TreeNode | None): The root of the flattened linked list.\n\nExamples:\n    >>> root = TreeNode(1)\n    >>> root.right = TreeNode(2)\n    >>> root.right.right = TreeNode(3)\n    >>> display_linked_list(root)\n    1 2 3\n    >>> root = None\n    >>> display_linked_list(root)"
  },
  {
    "function": "floor_ceiling",
    "code": "def floor_ceiling(root: Node | None, key: int) -> tuple[int | None, int | None]:\n    \"\"\"\n    Find the floor and ceiling values for a given key in a Binary Search Tree (BST).\n\n    Args:\n        root: The root of the binary search tree.\n        key: The key for which to find the floor and ceiling.\n\n    Returns:\n        A tuple containing the floor and ceiling values, respectively.\n\n    Examples:\n        >>> root = Node(10)\n        >>> root.left = Node(5)\n        >>> root.right = Node(20)\n        >>> root.left.left = Node(3)\n        >>> root.left.right = Node(7)\n        >>> root.right.left = Node(15)\n        >>> root.right.right = Node(25)\n        >>> tuple(root)\n        (3, 5, 7, 10, 15, 20, 25)\n        >>> floor_ceiling(root, 8)\n        (7, 10)\n        >>> floor_ceiling(root, 14)\n        (10, 15)\n        >>> floor_ceiling(root, -1)\n        (None, 3)\n        >>> floor_ceiling(root, 30)\n        (25, None)\n    \"\"\"\n    floor_val = None\n    ceiling_val = None\n\n    while root:\n        if root.key == key:\n            floor_val = root.key\n            ceiling_val = root.key\n            break\n\n        if key < root.key:\n            ceiling_val = root.key\n            root = root.left\n        else:\n            floor_val = root.key\n            root = root.right\n\n    return floor_val, ceiling_val",
    "docstring": "Find the floor and ceiling values for a given key in a Binary Search Tree (BST).\n\nArgs:\n    root: The root of the binary search tree.\n    key: The key for which to find the floor and ceiling.\n\nReturns:\n    A tuple containing the floor and ceiling values, respectively.\n\nExamples:\n    >>> root = Node(10)\n    >>> root.left = Node(5)\n    >>> root.right = Node(20)\n    >>> root.left.left = Node(3)\n    >>> root.left.right = Node(7)\n    >>> root.right.left = Node(15)\n    >>> root.right.right = Node(25)\n    >>> tuple(root)\n    (3, 5, 7, 10, 15, 20, 25)\n    >>> floor_ceiling(root, 8)\n    (7, 10)\n    >>> floor_ceiling(root, 14)\n    (10, 15)\n    >>> floor_ceiling(root, -1)\n    (None, 3)\n    >>> floor_ceiling(root, 30)\n    (25, None)"
  },
  {
    "function": "insert",
    "code": "def insert(node: BinaryTreeNode | None, new_value: int) -> BinaryTreeNode | None:\n    \"\"\"\n    If the binary search tree is empty, make a new node and declare it as root.\n    >>> node_a = BinaryTreeNode(12345)\n    >>> node_b = insert(node_a, 67890)\n    >>> node_a.left_child == node_b.left_child\n    True\n    >>> node_a.right_child == node_b.right_child\n    True\n    >>> node_a.data == node_b.data\n    True\n    \"\"\"\n    if node is None:\n        node = BinaryTreeNode(new_value)\n        return node\n\n    # binary search tree is not empty,\n    # so we will insert it into the tree\n    # if new_value is less than value of data in node,\n    #  add it to left subtree and proceed recursively\n    if new_value < node.data:\n        node.left_child = insert(node.left_child, new_value)\n    else:\n        # if new_value is greater than value of data in node,\n        #  add it to right subtree and proceed recursively\n        node.right_child = insert(node.right_child, new_value)\n    return node",
    "docstring": "If the binary search tree is empty, make a new node and declare it as root.\n>>> node_a = BinaryTreeNode(12345)\n>>> node_b = insert(node_a, 67890)\n>>> node_a.left_child == node_b.left_child\nTrue\n>>> node_a.right_child == node_b.right_child\nTrue\n>>> node_a.data == node_b.data\nTrue"
  },
  {
    "function": "inorder",
    "code": "def inorder(node: None | BinaryTreeNode) -> list[int]:  # if node is None,return\n    \"\"\"\n    >>> inorder(make_tree())\n    [6, 10, 14, 15, 20, 25, 60]\n    \"\"\"\n    if node:\n        inorder_array = inorder(node.left_child)\n        inorder_array = [*inorder_array, node.data]\n        inorder_array = inorder_array + inorder(node.right_child)\n    else:\n        inorder_array = []\n    return inorder_array",
    "docstring": ">>> inorder(make_tree())\n[6, 10, 14, 15, 20, 25, 60]"
  },
  {
    "function": "swap",
    "code": "def swap(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    >>> swap(3,-4)\n    (-4, 3)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b",
    "docstring": "Return a tuple (b, a) when given two integers a and b\n>>> swap(2,3)\n(3, 2)\n>>> swap(3,4)\n(4, 3)\n>>> swap(67, 12)\n(12, 67)\n>>> swap(3,-4)\n(-4, 3)"
  },
  {
    "function": "create_sparse",
    "code": "def create_sparse(max_node: int, parent: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    creating sparse table which saves each nodes 2^i-th parent\n    >>> max_node = 6\n    >>> parent = [[0, 0, 1, 1, 2, 2, 3]] + [[0] * 7 for _ in range(19)]\n    >>> parent = create_sparse(max_node=max_node, parent=parent)\n    >>> parent[0]\n    [0, 0, 1, 1, 2, 2, 3]\n    >>> parent[1]\n    [0, 0, 0, 0, 1, 1, 1]\n    >>> parent[2]\n    [0, 0, 0, 0, 0, 0, 0]\n\n    >>> max_node = 1\n    >>> parent = [[0, 0]] + [[0] * 2 for _ in range(19)]\n    >>> parent = create_sparse(max_node=max_node, parent=parent)\n    >>> parent[0]\n    [0, 0]\n    >>> parent[1]\n    [0, 0]\n    \"\"\"\n    j = 1\n    while (1 << j) < max_node:\n        for i in range(1, max_node + 1):\n            parent[j][i] = parent[j - 1][parent[j - 1][i]]\n        j += 1\n    return parent",
    "docstring": "creating sparse table which saves each nodes 2^i-th parent\n>>> max_node = 6\n>>> parent = [[0, 0, 1, 1, 2, 2, 3]] + [[0] * 7 for _ in range(19)]\n>>> parent = create_sparse(max_node=max_node, parent=parent)\n>>> parent[0]\n[0, 0, 1, 1, 2, 2, 3]\n>>> parent[1]\n[0, 0, 0, 0, 1, 1, 1]\n>>> parent[2]\n[0, 0, 0, 0, 0, 0, 0]\n\n>>> max_node = 1\n>>> parent = [[0, 0]] + [[0] * 2 for _ in range(19)]\n>>> parent = create_sparse(max_node=max_node, parent=parent)\n>>> parent[0]\n[0, 0]\n>>> parent[1]\n[0, 0]"
  },
  {
    "function": "lowest_common_ancestor",
    "code": "def lowest_common_ancestor(\n    u: int, v: int, level: list[int], parent: list[list[int]]\n) -> int:\n    \"\"\"\n    Return the lowest common ancestor between u and v\n\n    >>> level = [-1, 0, 1, 1, 2, 2, 2]\n    >>> parent = [[0, 0, 1, 1, 2, 2, 3],[0, 0, 0, 0, 1, 1, 1]] + \\\n                    [[0] * 7 for _ in range(17)]\n    >>> lowest_common_ancestor(u=4, v=5, level=level, parent=parent)\n    2\n    >>> lowest_common_ancestor(u=4, v=6, level=level, parent=parent)\n    1\n    >>> lowest_common_ancestor(u=2, v=3, level=level, parent=parent)\n    1\n    >>> lowest_common_ancestor(u=6, v=6, level=level, parent=parent)\n    6\n    \"\"\"\n    # u must be deeper in the tree than v\n    if level[u] < level[v]:\n        u, v = swap(u, v)\n    # making depth of u same as depth of v\n    for i in range(18, -1, -1):\n        if level[u] - (1 << i) >= level[v]:\n            u = parent[i][u]\n    # at the same depth if u==v that mean lca is found\n    if u == v:\n        return u\n    # moving both nodes upwards till lca in found\n    for i in range(18, -1, -1):\n        if parent[i][u] not in [0, parent[i][v]]:\n            u, v = parent[i][u], parent[i][v]\n    # returning longest common ancestor of u,v\n    return parent[0][u]",
    "docstring": "Return the lowest common ancestor between u and v\n\n>>> level = [-1, 0, 1, 1, 2, 2, 2]\n>>> parent = [[0, 0, 1, 1, 2, 2, 3],[0, 0, 0, 0, 1, 1, 1]] +                     [[0] * 7 for _ in range(17)]\n>>> lowest_common_ancestor(u=4, v=5, level=level, parent=parent)\n2\n>>> lowest_common_ancestor(u=4, v=6, level=level, parent=parent)\n1\n>>> lowest_common_ancestor(u=2, v=3, level=level, parent=parent)\n1\n>>> lowest_common_ancestor(u=6, v=6, level=level, parent=parent)\n6"
  },
  {
    "function": "breadth_first_search",
    "code": "def breadth_first_search(\n    level: list[int],\n    parent: list[list[int]],\n    max_node: int,\n    graph: dict[int, list[int]],\n    root: int = 1,\n) -> tuple[list[int], list[list[int]]]:\n    \"\"\"\n    sets every nodes direct parent\n    parent of root node is set to 0\n    calculates depth of each node from root node\n    >>> level = [-1] * 7\n    >>> parent = [[0] * 7 for _ in range(20)]\n    >>> graph = {1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [], 6: []}\n    >>> level, parent = breadth_first_search(\n    ...     level=level, parent=parent, max_node=6, graph=graph, root=1)\n    >>> level\n    [-1, 0, 1, 1, 2, 2, 2]\n    >>> parent[0]\n    [0, 0, 1, 1, 2, 2, 3]\n\n\n    >>> level = [-1] * 2\n    >>> parent = [[0] * 2 for _ in range(20)]\n    >>> graph = {1: []}\n    >>> level, parent = breadth_first_search(\n    ...     level=level, parent=parent, max_node=1, graph=graph, root=1)\n    >>> level\n    [-1, 0]\n    >>> parent[0]\n    [0, 0]\n    \"\"\"\n    level[root] = 0\n    q: Queue[int] = Queue(maxsize=max_node)\n    q.put(root)\n    while q.qsize() != 0:\n        u = q.get()\n        for v in graph[u]:\n            if level[v] == -1:\n                level[v] = level[u] + 1\n                q.put(v)\n                parent[0][v] = u\n    return level, parent",
    "docstring": "sets every nodes direct parent\nparent of root node is set to 0\ncalculates depth of each node from root node\n>>> level = [-1] * 7\n>>> parent = [[0] * 7 for _ in range(20)]\n>>> graph = {1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [], 6: []}\n>>> level, parent = breadth_first_search(\n...     level=level, parent=parent, max_node=6, graph=graph, root=1)\n>>> level\n[-1, 0, 1, 1, 2, 2, 2]\n>>> parent[0]\n[0, 0, 1, 1, 2, 2, 3]\n\n\n>>> level = [-1] * 2\n>>> parent = [[0] * 2 for _ in range(20)]\n>>> graph = {1: []}\n>>> level, parent = breadth_first_search(\n...     level=level, parent=parent, max_node=1, graph=graph, root=1)\n>>> level\n[-1, 0]\n>>> parent[0]\n[0, 0]"
  },
  {
    "function": "max_sum_bst",
    "code": "def max_sum_bst(root: TreeNode | None) -> int:\n    \"\"\"\n    The solution traverses a binary tree to find the maximum sum of\n    keys in any subtree that is a Binary Search Tree (BST). It uses\n    recursion to validate BST properties and calculates sums, returning\n    the highest sum found among all valid BST subtrees.\n\n    >>> t1 = TreeNode(4)\n    >>> t1.left = TreeNode(3)\n    >>> t1.left.left = TreeNode(1)\n    >>> t1.left.right = TreeNode(2)\n    >>> print(max_sum_bst(t1))\n    2\n    >>> t2 = TreeNode(-4)\n    >>> t2.left = TreeNode(-2)\n    >>> t2.right = TreeNode(-5)\n    >>> print(max_sum_bst(t2))\n    0\n    >>> t3 = TreeNode(1)\n    >>> t3.left = TreeNode(4)\n    >>> t3.left.left = TreeNode(2)\n    >>> t3.left.right = TreeNode(4)\n    >>> t3.right = TreeNode(3)\n    >>> t3.right.left = TreeNode(2)\n    >>> t3.right.right = TreeNode(5)\n    >>> t3.right.right.left = TreeNode(4)\n    >>> t3.right.right.right = TreeNode(6)\n    >>> print(max_sum_bst(t3))\n    20\n    \"\"\"\n    ans: int = 0\n\n    def solver(node: TreeNode | None) -> tuple[bool, int, int, int]:\n        \"\"\"\n        Returns the maximum sum by making recursive calls\n        >>> t1 = TreeNode(1)\n        >>> print(solver(t1))\n        1\n        \"\"\"\n        nonlocal ans\n\n        if not node:\n            return True, INT_MAX, INT_MIN, 0  # Valid BST, min, max, sum\n\n        is_left_valid, min_left, max_left, sum_left = solver(node.left)\n        is_right_valid, min_right, max_right, sum_right = solver(node.right)\n\n        if is_left_valid and is_right_valid and max_left < node.val < min_right:\n            total_sum = sum_left + sum_right + node.val\n            ans = max(ans, total_sum)\n            return True, min(min_left, node.val), max(max_right, node.val), total_sum\n\n        return False, -1, -1, -1  # Not a valid BST\n\n    solver(root)\n    return ans",
    "docstring": "The solution traverses a binary tree to find the maximum sum of\nkeys in any subtree that is a Binary Search Tree (BST). It uses\nrecursion to validate BST properties and calculates sums, returning\nthe highest sum found among all valid BST subtrees.\n\n>>> t1 = TreeNode(4)\n>>> t1.left = TreeNode(3)\n>>> t1.left.left = TreeNode(1)\n>>> t1.left.right = TreeNode(2)\n>>> print(max_sum_bst(t1))\n2\n>>> t2 = TreeNode(-4)\n>>> t2.left = TreeNode(-2)\n>>> t2.right = TreeNode(-5)\n>>> print(max_sum_bst(t2))\n0\n>>> t3 = TreeNode(1)\n>>> t3.left = TreeNode(4)\n>>> t3.left.left = TreeNode(2)\n>>> t3.left.right = TreeNode(4)\n>>> t3.right = TreeNode(3)\n>>> t3.right.left = TreeNode(2)\n>>> t3.right.right = TreeNode(5)\n>>> t3.right.right.left = TreeNode(4)\n>>> t3.right.right.right = TreeNode(6)\n>>> print(max_sum_bst(t3))\n20"
  },
  {
    "function": "merge_two_binary_trees",
    "code": "def merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:\n    \"\"\"\n    Returns root node of the merged tree.\n\n    >>> tree1 = Node(5)\n    >>> tree1.left = Node(6)\n    >>> tree1.right = Node(7)\n    >>> tree1.left.left = Node(2)\n    >>> tree2 = Node(4)\n    >>> tree2.left = Node(5)\n    >>> tree2.right = Node(8)\n    >>> tree2.left.right = Node(1)\n    >>> tree2.right.right = Node(4)\n    >>> merged_tree = merge_two_binary_trees(tree1, tree2)\n    >>> print_preorder(merged_tree)\n    9\n    11\n    2\n    1\n    15\n    4\n    \"\"\"\n    if tree1 is None:\n        return tree2\n    if tree2 is None:\n        return tree1\n\n    tree1.value = tree1.value + tree2.value\n    tree1.left = merge_two_binary_trees(tree1.left, tree2.left)\n    tree1.right = merge_two_binary_trees(tree1.right, tree2.right)\n    return tree1",
    "docstring": "Returns root node of the merged tree.\n\n>>> tree1 = Node(5)\n>>> tree1.left = Node(6)\n>>> tree1.right = Node(7)\n>>> tree1.left.left = Node(2)\n>>> tree2 = Node(4)\n>>> tree2.left = Node(5)\n>>> tree2.right = Node(8)\n>>> tree2.left.right = Node(1)\n>>> tree2.right.right = Node(4)\n>>> merged_tree = merge_two_binary_trees(tree1, tree2)\n>>> print_preorder(merged_tree)\n9\n11\n2\n1\n15\n4"
  },
  {
    "function": "print_preorder",
    "code": "def print_preorder(root: Node | None) -> None:\n    \"\"\"\n    Print pre-order traversal of the tree.\n\n    >>> root = Node(1)\n    >>> root.left = Node(2)\n    >>> root.right = Node(3)\n    >>> print_preorder(root)\n    1\n    2\n    3\n    >>> print_preorder(root.right)\n    3\n    \"\"\"\n    if root:\n        print(root.value)\n        print_preorder(root.left)\n        print_preorder(root.right)",
    "docstring": "Print pre-order traversal of the tree.\n\n>>> root = Node(1)\n>>> root.left = Node(2)\n>>> root.right = Node(3)\n>>> print_preorder(root)\n1\n2\n3\n>>> print_preorder(root.right)\n3"
  },
  {
    "function": "make_tree_seven",
    "code": "def make_tree_seven() -> Node:\n    r\"\"\"\n    Return a binary tree with 7 nodes that looks like this:\n    ::\n\n           1\n         /   \\\n        2     3\n       / \\   / \\\n      4   5 6   7\n\n    >>> tree_seven = make_tree_seven()\n    >>> len(tree_seven)\n    7\n    >>> list(tree_seven)\n    [4, 2, 5, 1, 6, 3, 7]\n    \"\"\"\n    tree = Node(1)\n    tree.left = Node(2)\n    tree.right = Node(3)\n    tree.left.left = Node(4)\n    tree.left.right = Node(5)\n    tree.right.left = Node(6)\n    tree.right.right = Node(7)\n    return tree",
    "docstring": "Return a binary tree with 7 nodes that looks like this:\n::\n\n       1\n     /   \\\n    2     3\n   / \\   / \\\n  4   5 6   7\n\n>>> tree_seven = make_tree_seven()\n>>> len(tree_seven)\n7\n>>> list(tree_seven)\n[4, 2, 5, 1, 6, 3, 7]"
  },
  {
    "function": "make_tree_nine",
    "code": "def make_tree_nine() -> Node:\n    r\"\"\"\n    Return a binary tree with 9 nodes that looks like this:\n    ::\n\n            1\n           / \\\n          2   3\n         / \\   \\\n        4   5   6\n       / \\   \\\n      7   8   9\n\n    >>> tree_nine = make_tree_nine()\n    >>> len(tree_nine)\n    9\n    >>> list(tree_nine)\n    [7, 4, 8, 2, 5, 9, 1, 3, 6]\n    \"\"\"\n    tree = Node(1)\n    tree.left = Node(2)\n    tree.right = Node(3)\n    tree.left.left = Node(4)\n    tree.left.right = Node(5)\n    tree.right.right = Node(6)\n    tree.left.left.left = Node(7)\n    tree.left.left.right = Node(8)\n    tree.left.right.right = Node(9)\n    return tree",
    "docstring": "Return a binary tree with 9 nodes that looks like this:\n::\n\n        1\n       / \\\n      2   3\n     / \\   \\\n    4   5   6\n   / \\   \\\n  7   8   9\n\n>>> tree_nine = make_tree_nine()\n>>> len(tree_nine)\n9\n>>> list(tree_nine)\n[7, 4, 8, 2, 5, 9, 1, 3, 6]"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    r\"\"\"\n    Mirror binary trees with the given root and returns the root\n\n    >>> tree = make_tree_nine()\n    >>> tuple(tree)\n    (7, 4, 8, 2, 5, 9, 1, 3, 6)\n    >>> tuple(tree.mirror())\n    (6, 3, 1, 9, 5, 2, 8, 4, 7)\n\n    nine_tree::\n\n            1\n           / \\\n          2   3\n         / \\   \\\n        4   5   6\n       / \\   \\\n      7   8   9\n\n    The mirrored tree looks like this::\n\n          1\n         / \\\n        3   2\n       /   / \\\n      6   5   4\n         /   / \\\n        9   8   7\n    \"\"\"\n    trees = {\"zero\": Node(0), \"seven\": make_tree_seven(), \"nine\": make_tree_nine()}\n    for name, tree in trees.items():\n        print(f\"      The {name} tree: {tuple(tree)}\")\n        # (0,)\n        # (4, 2, 5, 1, 6, 3, 7)\n        # (7, 4, 8, 2, 5, 9, 1, 3, 6)\n        print(f\"Mirror of {name} tree: {tuple(tree.mirror())}\")",
    "docstring": "Mirror binary trees with the given root and returns the root\n\n>>> tree = make_tree_nine()\n>>> tuple(tree)\n(7, 4, 8, 2, 5, 9, 1, 3, 6)\n>>> tuple(tree.mirror())\n(6, 3, 1, 9, 5, 2, 8, 4, 7)\n\nnine_tree::\n\n        1\n       / \\\n      2   3\n     / \\   \\\n    4   5   6\n   / \\   \\\n  7   8   9\n\nThe mirrored tree looks like this::\n\n      1\n     / \\\n    3   2\n   /   / \\\n  6   5   4\n     /   / \\\n    9   8   7"
  },
  {
    "function": "binomial_coefficient",
    "code": "def binomial_coefficient(n: int, k: int) -> int:\n    \"\"\"\n    Since Here we Find the Binomial Coefficient:\n    https://en.wikipedia.org/wiki/Binomial_coefficient\n    C(n,k) = n! / k!(n-k)!\n    :param n: 2 times of Number of nodes\n    :param k: Number of nodes\n    :return:  Integer Value\n\n    >>> binomial_coefficient(4, 2)\n    6\n    \"\"\"\n    result = 1  # To kept the Calculated Value\n    # Since C(n, k) = C(n, n-k)\n    k = min(k, n - k)\n    # Calculate C(n,k)\n    for i in range(k):\n        result *= n - i\n        result //= i + 1\n    return result",
    "docstring": "Since Here we Find the Binomial Coefficient:\nhttps://en.wikipedia.org/wiki/Binomial_coefficient\nC(n,k) = n! / k!(n-k)!\n:param n: 2 times of Number of nodes\n:param k: Number of nodes\n:return:  Integer Value\n\n>>> binomial_coefficient(4, 2)\n6"
  },
  {
    "function": "catalan_number",
    "code": "def catalan_number(node_count: int) -> int:\n    \"\"\"\n    We can find Catalan number many ways but here we use Binomial Coefficient because it\n    does the job in O(n)\n\n    return the Catalan number of n using 2nCn/(n+1).\n    :param n: number of nodes\n    :return: Catalan number of n nodes\n\n    >>> catalan_number(5)\n    42\n    >>> catalan_number(6)\n    132\n    \"\"\"\n    return binomial_coefficient(2 * node_count, node_count) // (node_count + 1)",
    "docstring": "We can find Catalan number many ways but here we use Binomial Coefficient because it\ndoes the job in O(n)\n\nreturn the Catalan number of n using 2nCn/(n+1).\n:param n: number of nodes\n:return: Catalan number of n nodes\n\n>>> catalan_number(5)\n42\n>>> catalan_number(6)\n132"
  },
  {
    "function": "factorial",
    "code": "def factorial(n: int) -> int:\n    \"\"\"\n    Return the factorial of a number.\n    :param n: Number to find the Factorial of.\n    :return: Factorial of n.\n\n    >>> import math\n    >>> all(factorial(i) == math.factorial(i) for i in range(10))\n    True\n    >>> factorial(-5)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() not defined for negative values\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"factorial() not defined for negative values\")\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result",
    "docstring": "Return the factorial of a number.\n:param n: Number to find the Factorial of.\n:return: Factorial of n.\n\n>>> import math\n>>> all(factorial(i) == math.factorial(i) for i in range(10))\nTrue\n>>> factorial(-5)  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nValueError: factorial() not defined for negative values"
  },
  {
    "function": "binary_tree_count",
    "code": "def binary_tree_count(node_count: int) -> int:\n    \"\"\"\n    Return the number of possible of binary trees.\n    :param n: number of nodes\n    :return: Number of possible binary trees\n\n    >>> binary_tree_count(5)\n    5040\n    >>> binary_tree_count(6)\n    95040\n    \"\"\"\n    return catalan_number(node_count) * factorial(node_count)",
    "docstring": "Return the number of possible of binary trees.\n:param n: number of nodes\n:return: Number of possible binary trees\n\n>>> binary_tree_count(5)\n5040\n>>> binary_tree_count(6)\n95040"
  },
  {
    "function": "color",
    "code": "def color(node: RedBlackTree | None) -> int:\n    \"\"\"Returns the color of a node, allowing for None leaves.\"\"\"\n    if node is None:\n        return 0\n    else:\n        return node.color",
    "docstring": "Returns the color of a node, allowing for None leaves."
  },
  {
    "function": "test_rotations",
    "code": "def test_rotations() -> bool:\n    \"\"\"Test that the rotate_left and rotate_right functions work.\"\"\"\n    # Make a tree to test on\n    tree = RedBlackTree(0)\n    tree.left = RedBlackTree(-10, parent=tree)\n    tree.right = RedBlackTree(10, parent=tree)\n    tree.left.left = RedBlackTree(-20, parent=tree.left)\n    tree.left.right = RedBlackTree(-5, parent=tree.left)\n    tree.right.left = RedBlackTree(5, parent=tree.right)\n    tree.right.right = RedBlackTree(20, parent=tree.right)\n    # Make the right rotation\n    left_rot = RedBlackTree(10)\n    left_rot.left = RedBlackTree(0, parent=left_rot)\n    left_rot.left.left = RedBlackTree(-10, parent=left_rot.left)\n    left_rot.left.right = RedBlackTree(5, parent=left_rot.left)\n    left_rot.left.left.left = RedBlackTree(-20, parent=left_rot.left.left)\n    left_rot.left.left.right = RedBlackTree(-5, parent=left_rot.left.left)\n    left_rot.right = RedBlackTree(20, parent=left_rot)\n    tree = tree.rotate_left()\n    if tree != left_rot:\n        return False\n    tree = tree.rotate_right()\n    tree = tree.rotate_right()\n    # Make the left rotation\n    right_rot = RedBlackTree(-10)\n    right_rot.left = RedBlackTree(-20, parent=right_rot)\n    right_rot.right = RedBlackTree(0, parent=right_rot)\n    right_rot.right.left = RedBlackTree(-5, parent=right_rot.right)\n    right_rot.right.right = RedBlackTree(10, parent=right_rot.right)\n    right_rot.right.right.left = RedBlackTree(5, parent=right_rot.right.right)\n    right_rot.right.right.right = RedBlackTree(20, parent=right_rot.right.right)\n    return tree == right_rot",
    "docstring": "Test that the rotate_left and rotate_right functions work."
  },
  {
    "function": "test_insertion_speed",
    "code": "def test_insertion_speed() -> bool:\n    \"\"\"Test that the tree balances inserts to O(log(n)) by doing a lot\n    of them.\n    \"\"\"\n    tree = RedBlackTree(-1)\n    for i in range(300000):\n        tree = tree.insert(i)\n    return True",
    "docstring": "Test that the tree balances inserts to O(log(n)) by doing a lot\nof them."
  },
  {
    "function": "test_insert",
    "code": "def test_insert() -> bool:\n    \"\"\"Test the insert() method of the tree correctly balances, colors,\n    and inserts.\n    \"\"\"\n    tree = RedBlackTree(0)\n    tree.insert(8)\n    tree.insert(-8)\n    tree.insert(4)\n    tree.insert(12)\n    tree.insert(10)\n    tree.insert(11)\n    ans = RedBlackTree(0, 0)\n    ans.left = RedBlackTree(-8, 0, ans)\n    ans.right = RedBlackTree(8, 1, ans)\n    ans.right.left = RedBlackTree(4, 0, ans.right)\n    ans.right.right = RedBlackTree(11, 0, ans.right)\n    ans.right.right.left = RedBlackTree(10, 1, ans.right.right)\n    ans.right.right.right = RedBlackTree(12, 1, ans.right.right)\n    return tree == ans",
    "docstring": "Test the insert() method of the tree correctly balances, colors,\nand inserts."
  },
  {
    "function": "test_insert_and_search",
    "code": "def test_insert_and_search() -> bool:\n    \"\"\"Tests searching through the tree for values.\"\"\"\n    tree = RedBlackTree(0)\n    tree.insert(8)\n    tree.insert(-8)\n    tree.insert(4)\n    tree.insert(12)\n    tree.insert(10)\n    tree.insert(11)\n    if any(i in tree for i in (5, -6, -10, 13)):\n        # Found something not in there\n        return False\n    # Find all these things in there\n    return all(i in tree for i in (11, 12, -8, 0))",
    "docstring": "Tests searching through the tree for values."
  },
  {
    "function": "test_insert_delete",
    "code": "def test_insert_delete() -> bool:\n    \"\"\"Test the insert() and delete() method of the tree, verifying the\n    insertion and removal of elements, and the balancing of the tree.\n    \"\"\"\n    tree = RedBlackTree(0)\n    tree = tree.insert(-12)\n    tree = tree.insert(8)\n    tree = tree.insert(-8)\n    tree = tree.insert(15)\n    tree = tree.insert(4)\n    tree = tree.insert(12)\n    tree = tree.insert(10)\n    tree = tree.insert(9)\n    tree = tree.insert(11)\n    tree = tree.remove(15)\n    tree = tree.remove(-12)\n    tree = tree.remove(9)\n    if not tree.check_color_properties():\n        return False\n    return list(tree.inorder_traverse()) == [-8, 0, 4, 8, 10, 11, 12]",
    "docstring": "Test the insert() and delete() method of the tree, verifying the\ninsertion and removal of elements, and the balancing of the tree."
  },
  {
    "function": "test_floor_ceil",
    "code": "def test_floor_ceil() -> bool:\n    \"\"\"Tests the floor and ceiling functions in the tree.\"\"\"\n    tree = RedBlackTree(0)\n    tree.insert(-16)\n    tree.insert(16)\n    tree.insert(8)\n    tree.insert(24)\n    tree.insert(20)\n    tree.insert(22)\n    tuples = [(-20, None, -16), (-10, -16, 0), (8, 8, 8), (50, 24, None)]\n    for val, floor, ceil in tuples:\n        if tree.floor(val) != floor or tree.ceil(val) != ceil:\n            return False\n    return True",
    "docstring": "Tests the floor and ceiling functions in the tree."
  },
  {
    "function": "test_min_max",
    "code": "def test_min_max() -> bool:\n    \"\"\"Tests the min and max functions in the tree.\"\"\"\n    tree = RedBlackTree(0)\n    tree.insert(-16)\n    tree.insert(16)\n    tree.insert(8)\n    tree.insert(24)\n    tree.insert(20)\n    tree.insert(22)\n    return not (tree.get_max() != 22 or tree.get_min() != -16)",
    "docstring": "Tests the min and max functions in the tree."
  },
  {
    "function": "test_tree_traversal",
    "code": "def test_tree_traversal() -> bool:\n    \"\"\"Tests the three different tree traversal functions.\"\"\"\n    tree = RedBlackTree(0)\n    tree = tree.insert(-16)\n    tree.insert(16)\n    tree.insert(8)\n    tree.insert(24)\n    tree.insert(20)\n    tree.insert(22)\n    if list(tree.inorder_traverse()) != [-16, 0, 8, 16, 20, 22, 24]:\n        return False\n    if list(tree.preorder_traverse()) != [0, -16, 16, 8, 22, 20, 24]:\n        return False\n    return list(tree.postorder_traverse()) == [-16, 8, 20, 24, 22, 16, 0]",
    "docstring": "Tests the three different tree traversal functions."
  },
  {
    "function": "test_tree_chaining",
    "code": "def test_tree_chaining() -> bool:\n    \"\"\"Tests the three different tree chaining functions.\"\"\"\n    tree = RedBlackTree(0)\n    tree = tree.insert(-16).insert(16).insert(8).insert(24).insert(20).insert(22)\n    if list(tree.inorder_traverse()) != [-16, 0, 8, 16, 20, 22, 24]:\n        return False\n    if list(tree.preorder_traverse()) != [0, -16, 16, 8, 22, 20, 24]:\n        return False\n    return list(tree.postorder_traverse()) == [-16, 8, 20, 24, 22, 16, 0]",
    "docstring": "Tests the three different tree chaining functions."
  },
  {
    "function": "deserialize",
    "code": "def deserialize(data: str) -> TreeNode | None:\n    \"\"\"\n    Deserialize a string to a binary tree.\n\n    Args:\n        data(str): The serialized string.\n\n    Returns:\n        The root of the binary tree.\n\n    >>> root = TreeNode.five_tree()\n    >>> serialzed_data = repr(root)\n    >>> deserialized = deserialize(serialzed_data)\n    >>> root == deserialized\n    True\n    >>> root is deserialized  # two separate trees\n    False\n    >>> root.right.right.value = 6\n    >>> root == deserialized\n    False\n    >>> serialzed_data = repr(root)\n    >>> deserialized = deserialize(serialzed_data)\n    >>> root == deserialized\n    True\n    >>> deserialize(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Data cannot be empty.\n    \"\"\"\n\n    if not data:\n        raise ValueError(\"Data cannot be empty.\")\n\n    # Split the serialized string by a comma to get node values\n    nodes = data.split(\",\")\n\n    def build_tree() -> TreeNode | None:\n        # Get the next value from the list\n        value = nodes.pop(0)\n\n        if value == \"null\":\n            return None\n\n        node = TreeNode(int(value))\n        node.left = build_tree()  # Recursively build left subtree\n        node.right = build_tree()  # Recursively build right subtree\n        return node\n\n    return build_tree()",
    "docstring": "Deserialize a string to a binary tree.\n\nArgs:\n    data(str): The serialized string.\n\nReturns:\n    The root of the binary tree.\n\n>>> root = TreeNode.five_tree()\n>>> serialzed_data = repr(root)\n>>> deserialized = deserialize(serialzed_data)\n>>> root == deserialized\nTrue\n>>> root is deserialized  # two separate trees\nFalse\n>>> root.right.right.value = 6\n>>> root == deserialized\nFalse\n>>> serialzed_data = repr(root)\n>>> deserialized = deserialize(serialzed_data)\n>>> root == deserialized\nTrue\n>>> deserialize(\"\")\nTraceback (most recent call last):\n    ...\nValueError: Data cannot be empty."
  },
  {
    "function": "make_symmetric_tree",
    "code": "def make_symmetric_tree() -> Node:\n    r\"\"\"\n    Create a symmetric tree for testing.\n\n    The tree looks like this:\n           1\n         /   \\\n        2     2\n      / \\    / \\\n     3   4   4  3\n\n    Returns:\n    Node: Root node of a symmetric tree.\n\n    Example:\n    >>> tree = make_symmetric_tree()\n    >>> tree.data\n    1\n    >>> tree.left.data == tree.right.data\n    True\n    >>> tree.left.left.data == tree.right.right.data\n    True\n    \"\"\"\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(2)\n    root.left.left = Node(3)\n    root.left.right = Node(4)\n    root.right.left = Node(4)\n    root.right.right = Node(3)\n    return root",
    "docstring": "Create a symmetric tree for testing.\n\nThe tree looks like this:\n       1\n     /   \\\n    2     2\n  / \\    / \\\n 3   4   4  3\n\nReturns:\nNode: Root node of a symmetric tree.\n\nExample:\n>>> tree = make_symmetric_tree()\n>>> tree.data\n1\n>>> tree.left.data == tree.right.data\nTrue\n>>> tree.left.left.data == tree.right.right.data\nTrue"
  },
  {
    "function": "make_asymmetric_tree",
    "code": "def make_asymmetric_tree() -> Node:\n    r\"\"\"\n    Create an asymmetric tree for testing.\n\n    The tree looks like this:\n           1\n         /   \\\n        2     2\n      / \\    / \\\n     3   4   3  4\n\n    Returns:\n    Node: Root node of an asymmetric tree.\n\n    Example:\n    >>> tree = make_asymmetric_tree()\n    >>> tree.data\n    1\n    >>> tree.left.data == tree.right.data\n    True\n    >>> tree.left.left.data == tree.right.right.data\n    False\n    \"\"\"\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(2)\n    root.left.left = Node(3)\n    root.left.right = Node(4)\n    root.right.left = Node(3)\n    root.right.right = Node(4)\n    return root",
    "docstring": "Create an asymmetric tree for testing.\n\nThe tree looks like this:\n       1\n     /   \\\n    2     2\n  / \\    / \\\n 3   4   3  4\n\nReturns:\nNode: Root node of an asymmetric tree.\n\nExample:\n>>> tree = make_asymmetric_tree()\n>>> tree.data\n1\n>>> tree.left.data == tree.right.data\nTrue\n>>> tree.left.left.data == tree.right.right.data\nFalse"
  },
  {
    "function": "is_symmetric_tree",
    "code": "def is_symmetric_tree(tree: Node) -> bool:\n    \"\"\"\n    Check if a binary tree is symmetric (i.e., a mirror of itself).\n\n    Parameters:\n    tree: The root node of the binary tree.\n\n    Returns:\n    bool: True if the tree is symmetric, False otherwise.\n\n    Example:\n    >>> is_symmetric_tree(make_symmetric_tree())\n    True\n    >>> is_symmetric_tree(make_asymmetric_tree())\n    False\n    \"\"\"\n    if tree:\n        return is_mirror(tree.left, tree.right)\n    return True  # An empty tree is considered symmetric.",
    "docstring": "Check if a binary tree is symmetric (i.e., a mirror of itself).\n\nParameters:\ntree: The root node of the binary tree.\n\nReturns:\nbool: True if the tree is symmetric, False otherwise.\n\nExample:\n>>> is_symmetric_tree(make_symmetric_tree())\nTrue\n>>> is_symmetric_tree(make_asymmetric_tree())\nFalse"
  },
  {
    "function": "is_mirror",
    "code": "def is_mirror(left: Node | None, right: Node | None) -> bool:\n    \"\"\"\n    Check if two subtrees are mirror images of each other.\n\n    Parameters:\n    left: The root node of the left subtree.\n    right: The root node of the right subtree.\n\n    Returns:\n    bool: True if the two subtrees are mirrors of each other, False otherwise.\n\n    Example:\n    >>> tree1 = make_symmetric_tree()\n    >>> is_mirror(tree1.left, tree1.right)\n    True\n    >>> tree2 = make_asymmetric_tree()\n    >>> is_mirror(tree2.left, tree2.right)\n    False\n    \"\"\"\n    if left is None and right is None:\n        # Both sides are empty, which is symmetric.\n        return True\n    if left is None or right is None:\n        # One side is empty while the other is not, which is not symmetric.\n        return False\n    if left.data == right.data:\n        # The values match, so check the subtrees recursively.\n        return is_mirror(left.left, right.right) and is_mirror(left.right, right.left)\n    return False",
    "docstring": "Check if two subtrees are mirror images of each other.\n\nParameters:\nleft: The root node of the left subtree.\nright: The root node of the right subtree.\n\nReturns:\nbool: True if the two subtrees are mirrors of each other, False otherwise.\n\nExample:\n>>> tree1 = make_symmetric_tree()\n>>> is_mirror(tree1.left, tree1.right)\nTrue\n>>> tree2 = make_asymmetric_tree()\n>>> is_mirror(tree2.left, tree2.right)\nFalse"
  },
  {
    "function": "split",
    "code": "def split(root: Node | None, value: int) -> tuple[Node | None, Node | None]:\n    \"\"\"\n    We split current tree into 2 trees with value:\n\n    Left tree contains all values less than split value.\n    Right tree contains all values greater or equal, than split value\n    \"\"\"\n    if root is None or root.value is None:  # None tree is split into 2 Nones\n        return None, None\n    elif value < root.value:\n        \"\"\"\n        Right tree's root will be current node.\n        Now we split(with the same value) current node's left son\n        Left tree: left part of that split\n        Right tree's left son: right part of that split\n        \"\"\"\n        left, root.left = split(root.left, value)\n        return left, root\n    else:\n        \"\"\"\n        Just symmetric to previous case\n        \"\"\"\n        root.right, right = split(root.right, value)\n        return root, right",
    "docstring": "We split current tree into 2 trees with value:\n\nLeft tree contains all values less than split value.\nRight tree contains all values greater or equal, than split value"
  },
  {
    "function": "merge",
    "code": "def merge(left: Node | None, right: Node | None) -> Node | None:\n    \"\"\"\n    We merge 2 trees into one.\n    Note: all left tree's values must be less than all right tree's\n    \"\"\"\n    if (not left) or (not right):  # If one node is None, return the other\n        return left or right\n    elif left.prior < right.prior:\n        \"\"\"\n        Left will be root because it has more priority\n        Now we need to merge left's right son and right tree\n        \"\"\"\n        left.right = merge(left.right, right)\n        return left\n    else:\n        \"\"\"\n        Symmetric as well\n        \"\"\"\n        right.left = merge(left, right.left)\n        return right",
    "docstring": "We merge 2 trees into one.\nNote: all left tree's values must be less than all right tree's"
  },
  {
    "function": "insert",
    "code": "def insert(root: Node | None, value: int) -> Node | None:\n    \"\"\"\n    Insert element\n\n    Split current tree with a value into left, right,\n    Insert new node into the middle\n    Merge left, node, right into root\n    \"\"\"\n    node = Node(value)\n    left, right = split(root, value)\n    return merge(merge(left, node), right)",
    "docstring": "Insert element\n\nSplit current tree with a value into left, right,\nInsert new node into the middle\nMerge left, node, right into root"
  },
  {
    "function": "erase",
    "code": "def erase(root: Node | None, value: int) -> Node | None:\n    \"\"\"\n    Erase element\n\n    Split all nodes with values less into left,\n    Split all nodes with values greater into right.\n    Merge left, right\n    \"\"\"\n    left, right = split(root, value - 1)\n    _, right = split(right, value)\n    return merge(left, right)",
    "docstring": "Erase element\n\nSplit all nodes with values less into left,\nSplit all nodes with values greater into right.\nMerge left, right"
  },
  {
    "function": "inorder",
    "code": "def inorder(root: Node | None) -> None:\n    \"\"\"\n    Just recursive print of a tree\n    \"\"\"\n    if not root:  # None\n        return\n    else:\n        inorder(root.left)\n        print(root.value, end=\",\")\n        inorder(root.right)",
    "docstring": "Just recursive print of a tree"
  },
  {
    "function": "interact_treap",
    "code": "def interact_treap(root: Node | None, args: str) -> Node | None:\n    \"\"\"\n    Commands:\n    + value to add value into treap\n    - value to erase all nodes with value\n\n        >>> root = interact_treap(None, \"+1\")\n        >>> inorder(root)\n        1,\n        >>> root = interact_treap(root, \"+3 +5 +17 +19 +2 +16 +4 +0\")\n        >>> inorder(root)\n        0,1,2,3,4,5,16,17,19,\n        >>> root = interact_treap(root, \"+4 +4 +4\")\n        >>> inorder(root)\n        0,1,2,3,4,4,4,4,5,16,17,19,\n        >>> root = interact_treap(root, \"-0\")\n        >>> inorder(root)\n        1,2,3,4,4,4,4,5,16,17,19,\n        >>> root = interact_treap(root, \"-4\")\n        >>> inorder(root)\n        1,2,3,5,16,17,19,\n        >>> root = interact_treap(root, \"=0\")\n        Unknown command\n    \"\"\"\n    for arg in args.split():\n        if arg[0] == \"+\":\n            root = insert(root, int(arg[1:]))\n\n        elif arg[0] == \"-\":\n            root = erase(root, int(arg[1:]))\n\n        else:\n            print(\"Unknown command\")\n\n    return root",
    "docstring": "Commands:\n+ value to add value into treap\n- value to erase all nodes with value\n\n    >>> root = interact_treap(None, \"+1\")\n    >>> inorder(root)\n    1,\n    >>> root = interact_treap(root, \"+3 +5 +17 +19 +2 +16 +4 +0\")\n    >>> inorder(root)\n    0,1,2,3,4,5,16,17,19,\n    >>> root = interact_treap(root, \"+4 +4 +4\")\n    >>> inorder(root)\n    0,1,2,3,4,4,4,4,5,16,17,19,\n    >>> root = interact_treap(root, \"-0\")\n    >>> inorder(root)\n    1,2,3,4,4,4,4,5,16,17,19,\n    >>> root = interact_treap(root, \"-4\")\n    >>> inorder(root)\n    1,2,3,5,16,17,19,\n    >>> root = interact_treap(root, \"=0\")\n    Unknown command"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"After each command, program prints treap\"\"\"\n    root = None\n    print(\n        \"enter numbers to create a tree, + value to add value into treap, \"\n        \"- value to erase all nodes with value. 'q' to quit. \"\n    )\n\n    args = input()\n    while args != \"q\":\n        root = interact_treap(root, args)\n        print(root)\n        args = input()\n\n    print(\"good by!\")",
    "docstring": "After each command, program prints treap"
  },
  {
    "function": "build_tree",
    "code": "def build_tree(arr: list[int]) -> Node | None:\n    \"\"\"\n    Builds the tree for arr and returns the root\n    of the constructed tree\n\n    >>> build_tree(test_array)\n    Node(min_value=0 max_value=9)\n    \"\"\"\n    root = Node(len(arr))\n    root.minn, root.maxx = min(arr), max(arr)\n    # Leaf node case where the node contains only one unique value\n    if root.minn == root.maxx:\n        return root\n    \"\"\"\n    Take the mean of min and max element of arr as the pivot and\n    partition arr into left_arr and right_arr with all elements <= pivot in the\n    left_arr and the rest in right_arr, maintaining the order of the elements,\n    then recursively build trees for left_arr and right_arr\n    \"\"\"\n    pivot = (root.minn + root.maxx) // 2\n\n    left_arr: list[int] = []\n    right_arr: list[int] = []\n\n    for index, num in enumerate(arr):\n        if num <= pivot:\n            left_arr.append(num)\n        else:\n            right_arr.append(num)\n        root.map_left[index] = len(left_arr)\n    root.left = build_tree(left_arr)\n    root.right = build_tree(right_arr)\n    return root",
    "docstring": "Builds the tree for arr and returns the root\nof the constructed tree\n\n>>> build_tree(test_array)\nNode(min_value=0 max_value=9)"
  },
  {
    "function": "rank_till_index",
    "code": "def rank_till_index(node: Node | None, num: int, index: int) -> int:\n    \"\"\"\n    Returns the number of occurrences of num in interval [0, index] in the list\n\n    >>> root = build_tree(test_array)\n    >>> rank_till_index(root, 6, 6)\n    1\n    >>> rank_till_index(root, 2, 0)\n    1\n    >>> rank_till_index(root, 1, 10)\n    2\n    >>> rank_till_index(root, 17, 7)\n    0\n    >>> rank_till_index(root, 0, 9)\n    1\n    \"\"\"\n    if index < 0 or node is None:\n        return 0\n    # Leaf node cases\n    if node.minn == node.maxx:\n        return index + 1 if node.minn == num else 0\n    pivot = (node.minn + node.maxx) // 2\n    if num <= pivot:\n        # go the left subtree and map index to the left subtree\n        return rank_till_index(node.left, num, node.map_left[index] - 1)\n    else:\n        # go to the right subtree and map index to the right subtree\n        return rank_till_index(node.right, num, index - node.map_left[index])",
    "docstring": "Returns the number of occurrences of num in interval [0, index] in the list\n\n>>> root = build_tree(test_array)\n>>> rank_till_index(root, 6, 6)\n1\n>>> rank_till_index(root, 2, 0)\n1\n>>> rank_till_index(root, 1, 10)\n2\n>>> rank_till_index(root, 17, 7)\n0\n>>> rank_till_index(root, 0, 9)\n1"
  },
  {
    "function": "rank",
    "code": "def rank(node: Node | None, num: int, start: int, end: int) -> int:\n    \"\"\"\n    Returns the number of occurrences of num in interval [start, end] in the list\n\n    >>> root = build_tree(test_array)\n    >>> rank(root, 6, 3, 13)\n    2\n    >>> rank(root, 2, 0, 19)\n    4\n    >>> rank(root, 9, 2 ,2)\n    0\n    >>> rank(root, 0, 5, 10)\n    2\n    \"\"\"\n    if start > end:\n        return 0\n    rank_till_end = rank_till_index(node, num, end)\n    rank_before_start = rank_till_index(node, num, start - 1)\n    return rank_till_end - rank_before_start",
    "docstring": "Returns the number of occurrences of num in interval [start, end] in the list\n\n>>> root = build_tree(test_array)\n>>> rank(root, 6, 3, 13)\n2\n>>> rank(root, 2, 0, 19)\n4\n>>> rank(root, 9, 2 ,2)\n0\n>>> rank(root, 0, 5, 10)\n2"
  },
  {
    "function": "quantile",
    "code": "def quantile(node: Node | None, index: int, start: int, end: int) -> int:\n    \"\"\"\n    Returns the index'th smallest element in interval [start, end] in the list\n    index is 0-indexed\n\n    >>> root = build_tree(test_array)\n    >>> quantile(root, 2, 2, 5)\n    5\n    >>> quantile(root, 5, 2, 13)\n    4\n    >>> quantile(root, 0, 6, 6)\n    8\n    >>> quantile(root, 4, 2, 5)\n    -1\n    \"\"\"\n    if index > (end - start) or start > end or node is None:\n        return -1\n    # Leaf node case\n    if node.minn == node.maxx:\n        return node.minn\n    # Number of elements in the left subtree in interval [start, end]\n    num_elements_in_left_tree = node.map_left[end] - (\n        node.map_left[start - 1] if start else 0\n    )\n    if num_elements_in_left_tree > index:\n        return quantile(\n            node.left,\n            index,\n            (node.map_left[start - 1] if start else 0),\n            node.map_left[end] - 1,\n        )\n    else:\n        return quantile(\n            node.right,\n            index - num_elements_in_left_tree,\n            start - (node.map_left[start - 1] if start else 0),\n            end - node.map_left[end],\n        )",
    "docstring": "Returns the index'th smallest element in interval [start, end] in the list\nindex is 0-indexed\n\n>>> root = build_tree(test_array)\n>>> quantile(root, 2, 2, 5)\n5\n>>> quantile(root, 5, 2, 13)\n4\n>>> quantile(root, 0, 6, 6)\n8\n>>> quantile(root, 4, 2, 5)\n-1"
  },
  {
    "function": "range_counting",
    "code": "def range_counting(\n    node: Node | None, start: int, end: int, start_num: int, end_num: int\n) -> int:\n    \"\"\"\n    Returns the number of elements in range [start_num, end_num]\n    in interval [start, end] in the list\n\n    >>> root = build_tree(test_array)\n    >>> range_counting(root, 1, 10, 3, 7)\n    3\n    >>> range_counting(root, 2, 2, 1, 4)\n    1\n    >>> range_counting(root, 0, 19, 0, 100)\n    20\n    >>> range_counting(root, 1, 0, 1, 100)\n    0\n    >>> range_counting(root, 0, 17, 100, 1)\n    0\n    \"\"\"\n    if (\n        start > end\n        or node is None\n        or start_num > end_num\n        or node.minn > end_num\n        or node.maxx < start_num\n    ):\n        return 0\n    if start_num <= node.minn and node.maxx <= end_num:\n        return end - start + 1\n    left = range_counting(\n        node.left,\n        (node.map_left[start - 1] if start else 0),\n        node.map_left[end] - 1,\n        start_num,\n        end_num,\n    )\n    right = range_counting(\n        node.right,\n        start - (node.map_left[start - 1] if start else 0),\n        end - node.map_left[end],\n        start_num,\n        end_num,\n    )\n    return left + right",
    "docstring": "Returns the number of elements in range [start_num, end_num]\nin interval [start, end] in the list\n\n>>> root = build_tree(test_array)\n>>> range_counting(root, 1, 10, 3, 7)\n3\n>>> range_counting(root, 2, 2, 1, 4)\n1\n>>> range_counting(root, 0, 19, 0, 100)\n20\n>>> range_counting(root, 1, 0, 1, 100)\n0\n>>> range_counting(root, 0, 17, 100, 1)\n0"
  },
  {
    "function": "make_set",
    "code": "def make_set(x: Node) -> None:\n    \"\"\"\n    Make x as a set.\n    \"\"\"\n    # rank is the distance from x to its' parent\n    # root's rank is 0\n    x.rank = 0\n    x.parent = x",
    "docstring": "Make x as a set."
  },
  {
    "function": "union_set",
    "code": "def union_set(x: Node, y: Node) -> None:\n    \"\"\"\n    Union of two sets.\n    set with bigger rank should be parent, so that the\n    disjoint set tree will be more flat.\n    \"\"\"\n    x, y = find_set(x), find_set(y)\n    if x == y:\n        return\n\n    elif x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1",
    "docstring": "Union of two sets.\nset with bigger rank should be parent, so that the\ndisjoint set tree will be more flat."
  },
  {
    "function": "find_set",
    "code": "def find_set(x: Node) -> Node:\n    \"\"\"\n    Return the parent of x\n    \"\"\"\n    if x != x.parent:\n        x.parent = find_set(x.parent)\n    return x.parent",
    "docstring": "Return the parent of x"
  },
  {
    "function": "find_python_set",
    "code": "def find_python_set(node: Node) -> set:\n    \"\"\"\n    Return a Python Standard Library set that contains i.\n    \"\"\"\n    sets = ({0, 1, 2}, {3, 4, 5})\n    for s in sets:\n        if node.data in s:\n            return s\n    msg = f\"{node.data} is not in {sets}\"\n    raise ValueError(msg)",
    "docstring": "Return a Python Standard Library set that contains i."
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and (number >= 0), (\n        \"'number' must been an int and positive\"\n    )\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or not number % 2:\n        # Negatives, 0, 1 and all even numbers are not primes\n        return False\n\n    odd_numbers = range(3, int(math.sqrt(number) + 1), 2)\n    return not any(not number % i for i in odd_numbers)",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\n\nA number is prime if it has exactly two factors: 1 and itself.\n\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(87)\nFalse\n>>> is_prime(563)\nTrue\n>>> is_prime(2999)\nTrue\n>>> is_prime(67483)\nFalse"
  },
  {
    "function": "test_heap",
    "code": "def test_heap() -> None:\n    \"\"\"\n    >>> h = Heap()  # Max-heap\n    >>> h.insert_item(5, 34)\n    >>> h.insert_item(6, 31)\n    >>> h.insert_item(7, 37)\n    >>> h.get_top()\n    [7, 37]\n    >>> h.extract_top()\n    [7, 37]\n    >>> h.extract_top()\n    [5, 34]\n    >>> h.extract_top()\n    [6, 31]\n    >>> h = Heap(key=lambda x: -x)  # Min heap\n    >>> h.insert_item(5, 34)\n    >>> h.insert_item(6, 31)\n    >>> h.insert_item(7, 37)\n    >>> h.get_top()\n    [6, -31]\n    >>> h.extract_top()\n    [6, -31]\n    >>> h.extract_top()\n    [5, -34]\n    >>> h.extract_top()\n    [7, -37]\n    >>> h.insert_item(8, 45)\n    >>> h.insert_item(9, 40)\n    >>> h.insert_item(10, 50)\n    >>> h.get_top()\n    [9, -40]\n    >>> h.update_item(10, 30)\n    >>> h.get_top()\n    [10, -30]\n    >>> h.delete_item(10)\n    >>> h.get_top()\n    [9, -40]\n    \"\"\"",
    "docstring": ">>> h = Heap()  # Max-heap\n>>> h.insert_item(5, 34)\n>>> h.insert_item(6, 31)\n>>> h.insert_item(7, 37)\n>>> h.get_top()\n[7, 37]\n>>> h.extract_top()\n[7, 37]\n>>> h.extract_top()\n[5, 34]\n>>> h.extract_top()\n[6, 31]\n>>> h = Heap(key=lambda x: -x)  # Min heap\n>>> h.insert_item(5, 34)\n>>> h.insert_item(6, 31)\n>>> h.insert_item(7, 37)\n>>> h.get_top()\n[6, -31]\n>>> h.extract_top()\n[6, -31]\n>>> h.extract_top()\n[5, -34]\n>>> h.extract_top()\n[7, -37]\n>>> h.insert_item(8, 45)\n>>> h.insert_item(9, 40)\n>>> h.insert_item(10, 50)\n>>> h.get_top()\n[9, -40]\n>>> h.update_item(10, 30)\n>>> h.get_top()\n[10, -30]\n>>> h.delete_item(10)\n>>> h.get_top()\n[9, -40]"
  },
  {
    "function": "build_kdtree",
    "code": "def build_kdtree(points: list[list[float]], depth: int = 0) -> KDNode | None:\n    \"\"\"\n    Builds a KD-Tree from a list of points.\n\n    Args:\n        points: The list of points to build the KD-Tree from.\n        depth: The current depth in the tree\n                     (used to determine axis for splitting).\n\n    Returns:\n        The root node of the KD-Tree,\n                       or None if no points are provided.\n    \"\"\"\n    if not points:\n        return None\n\n    k = len(points[0])  # Dimensionality of the points\n    axis = depth % k\n\n    # Sort point list and choose median as pivot element\n    points.sort(key=lambda point: point[axis])\n    median_idx = len(points) // 2\n\n    # Create node and construct subtrees\n    left_points = points[:median_idx]\n    right_points = points[median_idx + 1 :]\n\n    return KDNode(\n        point=points[median_idx],\n        left=build_kdtree(left_points, depth + 1),\n        right=build_kdtree(right_points, depth + 1),\n    )",
    "docstring": "Builds a KD-Tree from a list of points.\n\nArgs:\n    points: The list of points to build the KD-Tree from.\n    depth: The current depth in the tree\n                 (used to determine axis for splitting).\n\nReturns:\n    The root node of the KD-Tree,\n                   or None if no points are provided."
  },
  {
    "function": "nearest_neighbour_search",
    "code": "def nearest_neighbour_search(\n    root: KDNode | None, query_point: list[float]\n) -> tuple[list[float] | None, float, int]:\n    \"\"\"\n    Performs a nearest neighbor search in a KD-Tree for a given query point.\n\n    Args:\n        root (KDNode | None): The root node of the KD-Tree.\n        query_point (list[float]): The point for which the nearest neighbor\n                                    is being searched.\n\n    Returns:\n        tuple[list[float] | None, float, int]:\n            - The nearest point found in the KD-Tree to the query point,\n              or None if no point is found.\n            - The squared distance to the nearest point.\n            - The number of nodes visited during the search.\n    \"\"\"\n    nearest_point: list[float] | None = None\n    nearest_dist: float = float(\"inf\")\n    nodes_visited: int = 0\n\n    def search(node: KDNode | None, depth: int = 0) -> None:\n        \"\"\"\n        Recursively searches for the nearest neighbor in the KD-Tree.\n\n        Args:\n            node: The current node in the KD-Tree.\n            depth: The current depth in the KD-Tree.\n        \"\"\"\n        nonlocal nearest_point, nearest_dist, nodes_visited\n        if node is None:\n            return\n\n        nodes_visited += 1\n\n        # Calculate the current distance (squared distance)\n        current_point = node.point\n        current_dist = sum(\n            (query_coord - point_coord) ** 2\n            for query_coord, point_coord in zip(query_point, current_point)\n        )\n\n        # Update nearest point if the current node is closer\n        if nearest_point is None or current_dist < nearest_dist:\n            nearest_point = current_point\n            nearest_dist = current_dist\n\n        # Determine which subtree to search first (based on axis and query point)\n        k = len(query_point)  # Dimensionality of points\n        axis = depth % k\n\n        if query_point[axis] <= current_point[axis]:\n            nearer_subtree = node.left\n            further_subtree = node.right\n        else:\n            nearer_subtree = node.right\n            further_subtree = node.left\n\n        # Search the nearer subtree first\n        search(nearer_subtree, depth + 1)\n\n        # If the further subtree has a closer point\n        if (query_point[axis] - current_point[axis]) ** 2 < nearest_dist:\n            search(further_subtree, depth + 1)\n\n    search(root, 0)\n    return nearest_point, nearest_dist, nodes_visited",
    "docstring": "Performs a nearest neighbor search in a KD-Tree for a given query point.\n\nArgs:\n    root (KDNode | None): The root node of the KD-Tree.\n    query_point (list[float]): The point for which the nearest neighbor\n                                is being searched.\n\nReturns:\n    tuple[list[float] | None, float, int]:\n        - The nearest point found in the KD-Tree to the query point,\n          or None if no point is found.\n        - The squared distance to the nearest point.\n        - The number of nodes visited during the search."
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Demonstrates the use of KD-Tree by building it from random points\n    in a 10-dimensional hypercube and performing a nearest neighbor search.\n    \"\"\"\n    num_points: int = 5000\n    cube_size: float = 10.0  # Size of the hypercube (edge length)\n    num_dimensions: int = 10\n\n    # Generate random points within the hypercube\n    points: np.ndarray = hypercube_points(num_points, cube_size, num_dimensions)\n    hypercube_kdtree = build_kdtree(points.tolist())\n\n    # Generate a random query point within the same space\n    rng = np.random.default_rng()\n    query_point: list[float] = rng.random(num_dimensions).tolist()\n\n    # Perform nearest neighbor search\n    nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(\n        hypercube_kdtree, query_point\n    )\n\n    # Print the results\n    print(f\"Query point: {query_point}\")\n    print(f\"Nearest point: {nearest_point}\")\n    print(f\"Distance: {nearest_dist:.4f}\")\n    print(f\"Nodes visited: {nodes_visited}\")",
    "docstring": "Demonstrates the use of KD-Tree by building it from random points\nin a 10-dimensional hypercube and performing a nearest neighbor search."
  },
  {
    "function": "hypercube_points",
    "code": "def hypercube_points(\n    num_points: int, hypercube_size: float, num_dimensions: int\n) -> np.ndarray:\n    \"\"\"\n    Generates random points uniformly distributed within an n-dimensional hypercube.\n\n    Args:\n        num_points: Number of points to generate.\n        hypercube_size: Size of the hypercube.\n        num_dimensions: Number of dimensions of the hypercube.\n\n    Returns:\n        An array of shape (num_points, num_dimensions)\n                    with generated points.\n    \"\"\"\n    rng = np.random.default_rng()\n    shape = (num_points, num_dimensions)\n    return hypercube_size * rng.random(shape)",
    "docstring": "Generates random points uniformly distributed within an n-dimensional hypercube.\n\nArgs:\n    num_points: Number of points to generate.\n    hypercube_size: Size of the hypercube.\n    num_dimensions: Number of dimensions of the hypercube.\n\nReturns:\n    An array of shape (num_points, num_dimensions)\n                with generated points."
  },
  {
    "function": "test_build_kdtree",
    "code": "def test_build_kdtree(num_points, cube_size, num_dimensions, depth, expected_result):\n    \"\"\"\n    Test that KD-Tree is built correctly.\n\n    Cases:\n        - Empty points list.\n        - Positive depth value.\n        - Negative depth value.\n    \"\"\"\n    points = (\n        hypercube_points(num_points, cube_size, num_dimensions).tolist()\n        if num_points > 0\n        else []\n    )\n\n    kdtree = build_kdtree(points, depth=depth)\n\n    if expected_result is None:\n        # Empty points list case\n        assert kdtree is None, f\"Expected None for empty points list, got {kdtree}\"\n    else:\n        # Check if root node is not None\n        assert kdtree is not None, \"Expected a KDNode, got None\"\n\n        # Check if root has correct dimensions\n        assert len(kdtree.point) == num_dimensions, (\n            f\"Expected point dimension {num_dimensions}, got {len(kdtree.point)}\"\n        )\n\n        # Check that the tree is balanced to some extent (simplistic check)\n        assert isinstance(kdtree, KDNode), (\n            f\"Expected KDNode instance, got {type(kdtree)}\"\n        )",
    "docstring": "Test that KD-Tree is built correctly.\n\nCases:\n    - Empty points list.\n    - Positive depth value.\n    - Negative depth value."
  },
  {
    "function": "test_nearest_neighbour_search",
    "code": "def test_nearest_neighbour_search():\n    \"\"\"\n    Test the nearest neighbor search function.\n    \"\"\"\n    num_points = 10\n    cube_size = 10.0\n    num_dimensions = 2\n    points = hypercube_points(num_points, cube_size, num_dimensions)\n    kdtree = build_kdtree(points.tolist())\n\n    rng = np.random.default_rng()\n    query_point = rng.random(num_dimensions).tolist()\n\n    nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(\n        kdtree, query_point\n    )\n\n    # Check that nearest point is not None\n    assert nearest_point is not None\n\n    # Check that distance is a non-negative number\n    assert nearest_dist >= 0\n\n    # Check that nodes visited is a non-negative integer\n    assert nodes_visited >= 0",
    "docstring": "Test the nearest neighbor search function."
  },
  {
    "function": "test_edge_cases",
    "code": "def test_edge_cases():\n    \"\"\"\n    Test edge cases such as an empty KD-Tree.\n    \"\"\"\n    empty_kdtree = build_kdtree([])\n    query_point = [0.0] * 2  # Using a default 2D query point\n\n    nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(\n        empty_kdtree, query_point\n    )\n\n    # With an empty KD-Tree, nearest_point should be None\n    assert nearest_point is None\n    assert nearest_dist == float(\"inf\")\n    assert nodes_visited == 0",
    "docstring": "Test edge cases such as an empty KD-Tree."
  },
  {
    "function": "test_circular_linked_list",
    "code": "def test_circular_linked_list() -> None:\n    \"\"\"\n    Test cases for the CircularLinkedList class.\n    >>> test_circular_linked_list()\n    \"\"\"\n    circular_linked_list = CircularLinkedList()\n    assert len(circular_linked_list) == 0\n    assert circular_linked_list.is_empty() is True\n    assert str(circular_linked_list) == \"\"\n\n    try:\n        circular_linked_list.delete_front()\n        raise AssertionError  # This should not happen\n    except IndexError:\n        assert True  # This should happen\n\n    try:\n        circular_linked_list.delete_tail()\n        raise AssertionError  # This should not happen\n    except IndexError:\n        assert True  # This should happen\n\n    try:\n        circular_linked_list.delete_nth(-1)\n        raise AssertionError\n    except IndexError:\n        assert True\n\n    try:\n        circular_linked_list.delete_nth(0)\n        raise AssertionError\n    except IndexError:\n        assert True\n\n    assert circular_linked_list.is_empty() is True\n    for i in range(5):\n        assert len(circular_linked_list) == i\n        circular_linked_list.insert_nth(i, i + 1)\n    assert str(circular_linked_list) == \"->\".join(str(i) for i in range(1, 6))\n\n    circular_linked_list.insert_tail(6)\n    assert str(circular_linked_list) == \"->\".join(str(i) for i in range(1, 7))\n    circular_linked_list.insert_head(0)\n    assert str(circular_linked_list) == \"->\".join(str(i) for i in range(7))\n\n    assert circular_linked_list.delete_front() == 0\n    assert circular_linked_list.delete_tail() == 6\n    assert str(circular_linked_list) == \"->\".join(str(i) for i in range(1, 6))\n    assert circular_linked_list.delete_nth(2) == 3\n\n    circular_linked_list.insert_nth(2, 3)\n    assert str(circular_linked_list) == \"->\".join(str(i) for i in range(1, 6))\n\n    assert circular_linked_list.is_empty() is False",
    "docstring": "Test cases for the CircularLinkedList class.\n>>> test_circular_linked_list()"
  },
  {
    "function": "create_linked_list",
    "code": "def create_linked_list() -> None:\n    \"\"\"\n    >>> new_linked_list = LinkedList()\n    >>> new_linked_list.get_head_data() is None\n    True\n    >>> new_linked_list.get_tail_data() is None\n    True\n    >>> new_linked_list.is_empty()\n    True\n    >>> new_linked_list.insert(10)\n    >>> new_linked_list.get_head_data()\n    10\n    >>> new_linked_list.get_tail_data()\n    10\n    >>> new_linked_list.insert_at_position(position=3, value=20)\n    >>> new_linked_list.get_head_data()\n    10\n    >>> new_linked_list.get_tail_data()\n    20\n    >>> new_linked_list.set_head(Node(1000))\n    >>> new_linked_list.get_head_data()\n    1000\n    >>> new_linked_list.get_tail_data()\n    20\n    >>> new_linked_list.set_tail(Node(2000))\n    >>> new_linked_list.get_head_data()\n    1000\n    >>> new_linked_list.get_tail_data()\n    2000\n    >>> for value in new_linked_list:\n    ...    print(value)\n    1000\n    10\n    20\n    2000\n    >>> new_linked_list.is_empty()\n    False\n    >>> for value in new_linked_list:\n    ...    print(value)\n    1000\n    10\n    20\n    2000\n    >>> 10 in new_linked_list\n    True\n    >>> new_linked_list.delete_value(value=10)\n    >>> 10 in new_linked_list\n    False\n    >>> new_linked_list.delete_value(value=2000)\n    >>> new_linked_list.get_tail_data()\n    20\n    >>> new_linked_list.delete_value(value=1000)\n    >>> new_linked_list.get_tail_data()\n    20\n    >>> new_linked_list.get_head_data()\n    20\n    >>> for value in new_linked_list:\n    ...    print(value)\n    20\n    >>> new_linked_list.delete_value(value=20)\n    >>> for value in new_linked_list:\n    ...    print(value)\n    >>> for value in range(1,10):\n    ...    new_linked_list.insert(value=value)\n    >>> for value in new_linked_list:\n    ...    print(value)\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    >>> linked_list = LinkedList()\n    >>> linked_list.insert_at_position(position=1, value=10)\n    >>> str(linked_list)\n    '10'\n    >>> linked_list.insert_at_position(position=2, value=20)\n    >>> str(linked_list)\n    '10 20'\n    >>> linked_list.insert_at_position(position=1, value=30)\n    >>> str(linked_list)\n    '30 10 20'\n    >>> linked_list.insert_at_position(position=3, value=40)\n    >>> str(linked_list)\n    '30 10 40 20'\n    >>> linked_list.insert_at_position(position=5, value=50)\n    >>> str(linked_list)\n    '30 10 40 20 50'\n    \"\"\"",
    "docstring": ">>> new_linked_list = LinkedList()\n>>> new_linked_list.get_head_data() is None\nTrue\n>>> new_linked_list.get_tail_data() is None\nTrue\n>>> new_linked_list.is_empty()\nTrue\n>>> new_linked_list.insert(10)\n>>> new_linked_list.get_head_data()\n10\n>>> new_linked_list.get_tail_data()\n10\n>>> new_linked_list.insert_at_position(position=3, value=20)\n>>> new_linked_list.get_head_data()\n10\n>>> new_linked_list.get_tail_data()\n20\n>>> new_linked_list.set_head(Node(1000))\n>>> new_linked_list.get_head_data()\n1000\n>>> new_linked_list.get_tail_data()\n20\n>>> new_linked_list.set_tail(Node(2000))\n>>> new_linked_list.get_head_data()\n1000\n>>> new_linked_list.get_tail_data()\n2000\n>>> for value in new_linked_list:\n...    print(value)\n1000\n10\n20\n2000\n>>> new_linked_list.is_empty()\nFalse\n>>> for value in new_linked_list:\n...    print(value)\n1000\n10\n20\n2000\n>>> 10 in new_linked_list\nTrue\n>>> new_linked_list.delete_value(value=10)\n>>> 10 in new_linked_list\nFalse\n>>> new_linked_list.delete_value(value=2000)\n>>> new_linked_list.get_tail_data()\n20\n>>> new_linked_list.delete_value(value=1000)\n>>> new_linked_list.get_tail_data()\n20\n>>> new_linked_list.get_head_data()\n20\n>>> for value in new_linked_list:\n...    print(value)\n20\n>>> new_linked_list.delete_value(value=20)\n>>> for value in new_linked_list:\n...    print(value)\n>>> for value in range(1,10):\n...    new_linked_list.insert(value=value)\n>>> for value in new_linked_list:\n...    print(value)\n1\n2\n3\n4\n5\n6\n7\n8\n9\n>>> linked_list = LinkedList()\n>>> linked_list.insert_at_position(position=1, value=10)\n>>> str(linked_list)\n'10'\n>>> linked_list.insert_at_position(position=2, value=20)\n>>> str(linked_list)\n'10 20'\n>>> linked_list.insert_at_position(position=1, value=30)\n>>> str(linked_list)\n'30 10 20'\n>>> linked_list.insert_at_position(position=3, value=40)\n>>> str(linked_list)\n'30 10 40 20'\n>>> linked_list.insert_at_position(position=5, value=50)\n>>> str(linked_list)\n'30 10 40 20 50'"
  },
  {
    "function": "make_linked_list",
    "code": "def make_linked_list(elements_list: list | tuple) -> Node:\n    \"\"\"\n    Creates a Linked List from the elements of the given sequence\n    (list/tuple) and returns the head of the Linked List.\n\n    >>> make_linked_list([])\n    Traceback (most recent call last):\n        ...\n    ValueError: The Elements List is empty\n    >>> make_linked_list(())\n    Traceback (most recent call last):\n        ...\n    ValueError: The Elements List is empty\n    >>> make_linked_list([1])\n    <1> ---> <END>\n    >>> make_linked_list((1,))\n    <1> ---> <END>\n    >>> make_linked_list([1, 3, 5, 32, 44, 12, 43])\n    <1> ---> <3> ---> <5> ---> <32> ---> <44> ---> <12> ---> <43> ---> <END>\n    >>> make_linked_list((1, 3, 5, 32, 44, 12, 43))\n    <1> ---> <3> ---> <5> ---> <32> ---> <44> ---> <12> ---> <43> ---> <END>\n    \"\"\"\n\n    # if elements_list is empty\n    if not elements_list:\n        raise ValueError(\"The Elements List is empty\")\n\n    # Set first element as Head\n    head = Node(elements_list[0])\n    current = head\n    # Loop through elements from position 1\n    for data in elements_list[1:]:\n        current.next = Node(data)\n        current = current.next\n    return head",
    "docstring": "Creates a Linked List from the elements of the given sequence\n(list/tuple) and returns the head of the Linked List.\n\n>>> make_linked_list([])\nTraceback (most recent call last):\n    ...\nValueError: The Elements List is empty\n>>> make_linked_list(())\nTraceback (most recent call last):\n    ...\nValueError: The Elements List is empty\n>>> make_linked_list([1])\n<1> ---> <END>\n>>> make_linked_list((1,))\n<1> ---> <END>\n>>> make_linked_list([1, 3, 5, 32, 44, 12, 43])\n<1> ---> <3> ---> <5> ---> <32> ---> <44> ---> <12> ---> <43> ---> <END>\n>>> make_linked_list((1, 3, 5, 32, 44, 12, 43))\n<1> ---> <3> ---> <5> ---> <32> ---> <44> ---> <12> ---> <43> ---> <END>"
  },
  {
    "function": "is_palindrome",
    "code": "def is_palindrome(head: ListNode | None) -> bool:\n    \"\"\"\n    Check if a linked list is a palindrome.\n\n    Args:\n        head: The head of the linked list.\n\n    Returns:\n        bool: True if the linked list is a palindrome, False otherwise.\n\n    Examples:\n        >>> is_palindrome(None)\n        True\n\n        >>> is_palindrome(ListNode(1))\n        True\n\n        >>> is_palindrome(ListNode(1, ListNode(2)))\n        False\n\n        >>> is_palindrome(ListNode(1, ListNode(2, ListNode(1))))\n        True\n\n        >>> is_palindrome(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))\n        True\n    \"\"\"\n    if not head:\n        return True\n    # split the list to two parts\n    fast: ListNode | None = head.next_node\n    slow: ListNode | None = head\n    while fast and fast.next_node:\n        fast = fast.next_node.next_node\n        slow = slow.next_node if slow else None\n    if slow:\n        # slow will always be defined,\n        # adding this check to resolve mypy static check\n        second = slow.next_node\n        slow.next_node = None  # Don't forget here! But forget still works!\n    # reverse the second part\n    node: ListNode | None = None\n    while second:\n        nxt = second.next_node\n        second.next_node = node\n        node = second\n        second = nxt\n    # compare two parts\n    # second part has the same or one less node\n    while node and head:\n        if node.val != head.val:\n            return False\n        node = node.next_node\n        head = head.next_node\n    return True",
    "docstring": "Check if a linked list is a palindrome.\n\nArgs:\n    head: The head of the linked list.\n\nReturns:\n    bool: True if the linked list is a palindrome, False otherwise.\n\nExamples:\n    >>> is_palindrome(None)\n    True\n\n    >>> is_palindrome(ListNode(1))\n    True\n\n    >>> is_palindrome(ListNode(1, ListNode(2)))\n    False\n\n    >>> is_palindrome(ListNode(1, ListNode(2, ListNode(1))))\n    True\n\n    >>> is_palindrome(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))\n    True"
  },
  {
    "function": "is_palindrome_stack",
    "code": "def is_palindrome_stack(head: ListNode | None) -> bool:\n    \"\"\"\n    Check if a linked list is a palindrome using a stack.\n\n    Args:\n        head (ListNode): The head of the linked list.\n\n    Returns:\n        bool: True if the linked list is a palindrome, False otherwise.\n\n    Examples:\n        >>> is_palindrome_stack(None)\n        True\n\n        >>> is_palindrome_stack(ListNode(1))\n        True\n\n        >>> is_palindrome_stack(ListNode(1, ListNode(2)))\n        False\n\n        >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(1))))\n        True\n\n        >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))\n        True\n    \"\"\"\n    if not head or not head.next_node:\n        return True\n\n    # 1. Get the midpoint (slow)\n    slow: ListNode | None = head\n    fast: ListNode | None = head\n    while fast and fast.next_node:\n        fast = fast.next_node.next_node\n        slow = slow.next_node if slow else None\n\n    # slow will always be defined,\n    # adding this check to resolve mypy static check\n    if slow:\n        stack = [slow.val]\n\n        # 2. Push the second half into the stack\n        while slow.next_node:\n            slow = slow.next_node\n            stack.append(slow.val)\n\n        # 3. Comparison\n        cur: ListNode | None = head\n        while stack and cur:\n            if stack.pop() != cur.val:\n                return False\n            cur = cur.next_node\n\n    return True",
    "docstring": "Check if a linked list is a palindrome using a stack.\n\nArgs:\n    head (ListNode): The head of the linked list.\n\nReturns:\n    bool: True if the linked list is a palindrome, False otherwise.\n\nExamples:\n    >>> is_palindrome_stack(None)\n    True\n\n    >>> is_palindrome_stack(ListNode(1))\n    True\n\n    >>> is_palindrome_stack(ListNode(1, ListNode(2)))\n    False\n\n    >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(1))))\n    True\n\n    >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))\n    True"
  },
  {
    "function": "is_palindrome_dict",
    "code": "def is_palindrome_dict(head: ListNode | None) -> bool:\n    \"\"\"\n    Check if a linked list is a palindrome using a dictionary.\n\n    Args:\n        head (ListNode): The head of the linked list.\n\n    Returns:\n        bool: True if the linked list is a palindrome, False otherwise.\n\n    Examples:\n        >>> is_palindrome_dict(None)\n        True\n\n        >>> is_palindrome_dict(ListNode(1))\n        True\n\n        >>> is_palindrome_dict(ListNode(1, ListNode(2)))\n        False\n\n        >>> is_palindrome_dict(ListNode(1, ListNode(2, ListNode(1))))\n        True\n\n        >>> is_palindrome_dict(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))\n        True\n\n        >>> is_palindrome_dict(\n        ...     ListNode(\n        ...         1, ListNode(2, ListNode(1, ListNode(3, ListNode(2, ListNode(1)))))\n        ...     )\n        ... )\n        False\n    \"\"\"\n    if not head or not head.next_node:\n        return True\n    d: dict[int, list[int]] = {}\n    pos = 0\n    while head:\n        if head.val in d:\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next_node\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            for step, i in enumerate(range(len(v))):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n        if middle > 1:\n            return False\n    return True",
    "docstring": "Check if a linked list is a palindrome using a dictionary.\n\nArgs:\n    head (ListNode): The head of the linked list.\n\nReturns:\n    bool: True if the linked list is a palindrome, False otherwise.\n\nExamples:\n    >>> is_palindrome_dict(None)\n    True\n\n    >>> is_palindrome_dict(ListNode(1))\n    True\n\n    >>> is_palindrome_dict(ListNode(1, ListNode(2)))\n    False\n\n    >>> is_palindrome_dict(ListNode(1, ListNode(2, ListNode(1))))\n    True\n\n    >>> is_palindrome_dict(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))\n    True\n\n    >>> is_palindrome_dict(\n    ...     ListNode(\n    ...         1, ListNode(2, ListNode(1, ListNode(3, ListNode(2, ListNode(1)))))\n    ...     )\n    ... )\n    False"
  },
  {
    "function": "merge_lists",
    "code": "def merge_lists(\n    sll_one: SortedLinkedList, sll_two: SortedLinkedList\n) -> SortedLinkedList:\n    \"\"\"\n    >>> SSL = SortedLinkedList\n    >>> merged = merge_lists(SSL(test_data_odd), SSL(test_data_even))\n    >>> len(merged)\n    16\n    >>> str(merged)\n    '-11 -> -2 -> -1 -> 0 -> 0 -> 1 -> 2 -> 3 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10'\n    >>> list(merged) == list(sorted(test_data_odd + test_data_even))\n    True\n    \"\"\"\n    return SortedLinkedList(list(sll_one) + list(sll_two))",
    "docstring": ">>> SSL = SortedLinkedList\n>>> merged = merge_lists(SSL(test_data_odd), SSL(test_data_even))\n>>> len(merged)\n16\n>>> str(merged)\n'-11 -> -2 -> -1 -> 0 -> 0 -> 1 -> 2 -> 3 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10'\n>>> list(merged) == list(sorted(test_data_odd + test_data_even))\nTrue"
  },
  {
    "function": "make_linked_list",
    "code": "def make_linked_list(elements_list: Iterable[int]) -> LinkedList:\n    \"\"\"Creates a Linked List from the elements of the given sequence\n    (list/tuple) and returns the head of the Linked List.\n    >>> make_linked_list([])\n    Traceback (most recent call last):\n        ...\n    Exception: The Elements List is empty\n    >>> make_linked_list([7])\n    7\n    >>> make_linked_list(['abc'])\n    abc\n    >>> make_linked_list([7, 25])\n    7 -> 25\n    \"\"\"\n    if not elements_list:\n        raise Exception(\"The Elements List is empty\")\n\n    linked_list = LinkedList()\n    linked_list.extend(elements_list)\n    return linked_list",
    "docstring": "Creates a Linked List from the elements of the given sequence\n(list/tuple) and returns the head of the Linked List.\n>>> make_linked_list([])\nTraceback (most recent call last):\n    ...\nException: The Elements List is empty\n>>> make_linked_list([7])\n7\n>>> make_linked_list(['abc'])\nabc\n>>> make_linked_list([7, 25])\n7 -> 25"
  },
  {
    "function": "in_reverse",
    "code": "def in_reverse(linked_list: LinkedList) -> str:\n    \"\"\"Prints the elements of the given Linked List in reverse order\n    >>> in_reverse(LinkedList())\n    ''\n    >>> in_reverse(make_linked_list([69, 88, 73]))\n    '73 <- 88 <- 69'\n    \"\"\"\n    return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))",
    "docstring": "Prints the elements of the given Linked List in reverse order\n>>> in_reverse(LinkedList())\n''\n>>> in_reverse(make_linked_list([69, 88, 73]))\n'73 <- 88 <- 69'"
  },
  {
    "function": "print_linked_list",
    "code": "def print_linked_list(head: Node | None) -> None:\n    \"\"\"\n        Print the entire linked list iteratively.\n\n        This function prints the elements of a linked list separated by '->'.\n\n        Parameters:\n            head (Node | None): The head of the linked list to be printed,\n    or None if the linked list is empty.\n\n        >>> head = insert_node(None, 0)\n        >>> head = insert_node(head, 2)\n        >>> head = insert_node(head, 1)\n        >>> print_linked_list(head)\n        0->2->1\n        >>> head = insert_node(head, 4)\n        >>> head = insert_node(head, 5)\n        >>> print_linked_list(head)\n        0->2->1->4->5\n    \"\"\"\n    if head is None:\n        return\n    while head.next_node is not None:\n        print(head.data, end=\"->\")\n        head = head.next_node\n    print(head.data)",
    "docstring": "Print the entire linked list iteratively.\n\n    This function prints the elements of a linked list separated by '->'.\n\n    Parameters:\n        head (Node | None): The head of the linked list to be printed,\nor None if the linked list is empty.\n\n    >>> head = insert_node(None, 0)\n    >>> head = insert_node(head, 2)\n    >>> head = insert_node(head, 1)\n    >>> print_linked_list(head)\n    0->2->1\n    >>> head = insert_node(head, 4)\n    >>> head = insert_node(head, 5)\n    >>> print_linked_list(head)\n    0->2->1->4->5"
  },
  {
    "function": "insert_node",
    "code": "def insert_node(head: Node | None, data: int) -> Node:\n    \"\"\"\n    Insert a new node at the end of a linked list and return the new head.\n\n    Parameters:\n        head (Node | None): The head of the linked list.\n        data (int): The data to be inserted into the new node.\n\n    Returns:\n        Node: The new head of the linked list.\n\n    >>> head = insert_node(None, 10)\n    >>> head = insert_node(head, 9)\n    >>> head = insert_node(head, 8)\n    >>> print_linked_list(head)\n    10->9->8\n    \"\"\"\n    new_node = Node(data)\n    # If the linked list is empty, the new_node becomes the head\n    if head is None:\n        return new_node\n\n    temp_node = head\n    while temp_node.next_node:\n        temp_node = temp_node.next_node\n\n    temp_node.next_node = new_node\n    return head",
    "docstring": "Insert a new node at the end of a linked list and return the new head.\n\nParameters:\n    head (Node | None): The head of the linked list.\n    data (int): The data to be inserted into the new node.\n\nReturns:\n    Node: The new head of the linked list.\n\n>>> head = insert_node(None, 10)\n>>> head = insert_node(head, 9)\n>>> head = insert_node(head, 8)\n>>> print_linked_list(head)\n10->9->8"
  },
  {
    "function": "rotate_to_the_right",
    "code": "def rotate_to_the_right(head: Node, places: int) -> Node:\n    \"\"\"\n    Rotate a linked list to the right by places times.\n\n    Parameters:\n        head: The head of the linked list.\n        places: The number of places to rotate.\n\n    Returns:\n        Node: The head of the rotated linked list.\n\n    >>> rotate_to_the_right(None, places=1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The linked list is empty.\n    >>> head = insert_node(None, 1)\n    >>> rotate_to_the_right(head, places=1) == head\n    True\n    >>> head = insert_node(None, 1)\n    >>> head = insert_node(head, 2)\n    >>> head = insert_node(head, 3)\n    >>> head = insert_node(head, 4)\n    >>> head = insert_node(head, 5)\n    >>> new_head = rotate_to_the_right(head, places=2)\n    >>> print_linked_list(new_head)\n    4->5->1->2->3\n    \"\"\"\n    # Check if the list is empty or has only one element\n    if not head:\n        raise ValueError(\"The linked list is empty.\")\n\n    if head.next_node is None:\n        return head\n\n    # Calculate the length of the linked list\n    length = 1\n    temp_node = head\n    while temp_node.next_node is not None:\n        length += 1\n        temp_node = temp_node.next_node\n\n    # Adjust the value of places to avoid places longer than the list.\n    places %= length\n\n    if places == 0:\n        return head  # As no rotation is needed.\n\n    # Find the new head position after rotation.\n    new_head_index = length - places\n\n    # Traverse to the new head position\n    temp_node = head\n    for _ in range(new_head_index - 1):\n        assert temp_node.next_node\n        temp_node = temp_node.next_node\n\n    # Update pointers to perform rotation\n    assert temp_node.next_node\n    new_head = temp_node.next_node\n    temp_node.next_node = None\n    temp_node = new_head\n    while temp_node.next_node:\n        temp_node = temp_node.next_node\n    temp_node.next_node = head\n\n    assert new_head\n    return new_head",
    "docstring": "Rotate a linked list to the right by places times.\n\nParameters:\n    head: The head of the linked list.\n    places: The number of places to rotate.\n\nReturns:\n    Node: The head of the rotated linked list.\n\n>>> rotate_to_the_right(None, places=1)\nTraceback (most recent call last):\n    ...\nValueError: The linked list is empty.\n>>> head = insert_node(None, 1)\n>>> rotate_to_the_right(head, places=1) == head\nTrue\n>>> head = insert_node(None, 1)\n>>> head = insert_node(head, 2)\n>>> head = insert_node(head, 3)\n>>> head = insert_node(head, 4)\n>>> head = insert_node(head, 5)\n>>> new_head = rotate_to_the_right(head, places=2)\n>>> print_linked_list(new_head)\n4->5->1->2->3"
  },
  {
    "function": "test_singly_linked_list_2",
    "code": "def test_singly_linked_list_2() -> None:\n    \"\"\"\n    This section of the test used varying data types for input.\n    >>> test_singly_linked_list_2()\n    \"\"\"\n    test_input = [\n        -9,\n        100,\n        Node(77345112),\n        \"dlrow olleH\",\n        7,\n        5555,\n        0,\n        -192.55555,\n        \"Hello, world!\",\n        77.9,\n        Node(10),\n        None,\n        None,\n        12.20,\n    ]\n    linked_list = LinkedList()\n\n    for i in test_input:\n        linked_list.insert_tail(i)\n\n    # Check if it's empty or not\n    assert linked_list.is_empty() is False\n    assert (\n        str(linked_list)\n        == \"-9 -> 100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> \"\n        \"0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None -> 12.2\"\n    )\n\n    # Delete the head\n    result = linked_list.delete_head()\n    assert result == -9\n    assert (\n        str(linked_list) == \"100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> 0 -> \"\n        \"-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None -> 12.2\"\n    )\n\n    # Delete the tail\n    result = linked_list.delete_tail()\n    assert result == 12.2\n    assert (\n        str(linked_list) == \"100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> 0 -> \"\n        \"-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None\"\n    )\n\n    # Delete a node in specific location in linked list\n    result = linked_list.delete_nth(10)\n    assert result is None\n    assert (\n        str(linked_list) == \"100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> 0 -> \"\n        \"-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None\"\n    )\n\n    # Add a Node instance to its head\n    linked_list.insert_head(Node(\"Hello again, world!\"))\n    assert (\n        str(linked_list)\n        == \"Node(Hello again, world!) -> 100 -> Node(77345112) -> dlrow olleH -> \"\n        \"7 -> 5555 -> 0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None\"\n    )\n\n    # Add None to its tail\n    linked_list.insert_tail(None)\n    assert (\n        str(linked_list)\n        == \"Node(Hello again, world!) -> 100 -> Node(77345112) -> dlrow olleH -> 7 -> \"\n        \"5555 -> 0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None\"\n    )\n\n    # Reverse the linked list\n    linked_list.reverse()\n    assert (\n        str(linked_list)\n        == \"None -> None -> Node(10) -> 77.9 -> Hello, world! -> -192.55555 -> 0 -> \"\n        \"5555 -> 7 -> dlrow olleH -> Node(77345112) -> 100 -> Node(Hello again, world!)\"\n    )",
    "docstring": "This section of the test used varying data types for input.\n>>> test_singly_linked_list_2()"
  },
  {
    "function": "balanced_parentheses",
    "code": "def balanced_parentheses(parentheses: str) -> bool:\n    \"\"\"Use a stack to check if a string of parentheses is balanced.\n    >>> balanced_parentheses(\"([]{})\")\n    True\n    >>> balanced_parentheses(\"[()]{}{[()()]()}\")\n    True\n    >>> balanced_parentheses(\"[(])\")\n    False\n    >>> balanced_parentheses(\"1+2*3-4\")\n    True\n    >>> balanced_parentheses(\"\")\n    True\n    \"\"\"\n    stack: Stack[str] = Stack()\n    bracket_pairs = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}\n    for bracket in parentheses:\n        if bracket in bracket_pairs:\n            stack.push(bracket)\n        elif bracket in (\")\", \"]\", \"}\") and (\n            stack.is_empty() or bracket_pairs[stack.pop()] != bracket\n        ):\n            return False\n    return stack.is_empty()",
    "docstring": "Use a stack to check if a string of parentheses is balanced.\n>>> balanced_parentheses(\"([]{})\")\nTrue\n>>> balanced_parentheses(\"[()]{}{[()()]()}\")\nTrue\n>>> balanced_parentheses(\"[(])\")\nFalse\n>>> balanced_parentheses(\"1+2*3-4\")\nTrue\n>>> balanced_parentheses(\"\")\nTrue"
  },
  {
    "function": "dijkstras_two_stack_algorithm",
    "code": "def dijkstras_two_stack_algorithm(equation: str) -> int:\n    \"\"\"\n    DocTests\n    >>> dijkstras_two_stack_algorithm(\"(5 + 3)\")\n    8\n    >>> dijkstras_two_stack_algorithm(\"((9 - (2 + 9)) + (8 - 1))\")\n    5\n    >>> dijkstras_two_stack_algorithm(\"((((3 - 2) - (2 + 3)) + (2 - 4)) + 3)\")\n    -3\n\n    :param equation: a string\n    :return: result: an integer\n    \"\"\"\n    operators = {\"*\": op.mul, \"/\": op.truediv, \"+\": op.add, \"-\": op.sub}\n\n    operand_stack: Stack[int] = Stack()\n    operator_stack: Stack[str] = Stack()\n\n    for i in equation:\n        if i.isdigit():\n            # RULE 1\n            operand_stack.push(int(i))\n        elif i in operators:\n            # RULE 2\n            operator_stack.push(i)\n        elif i == \")\":\n            # RULE 4\n            opr = operator_stack.peek()\n            operator_stack.pop()\n            num1 = operand_stack.peek()\n            operand_stack.pop()\n            num2 = operand_stack.peek()\n            operand_stack.pop()\n\n            total = operators[opr](num2, num1)\n            operand_stack.push(total)\n\n    # RULE 5\n    return operand_stack.peek()",
    "docstring": "DocTests\n>>> dijkstras_two_stack_algorithm(\"(5 + 3)\")\n8\n>>> dijkstras_two_stack_algorithm(\"((9 - (2 + 9)) + (8 - 1))\")\n5\n>>> dijkstras_two_stack_algorithm(\"((((3 - 2) - (2 + 3)) + (2 - 4)) + 3)\")\n-3\n\n:param equation: a string\n:return: result: an integer"
  },
  {
    "function": "precedence",
    "code": "def precedence(char: str) -> int:\n    \"\"\"\n    Return integer value representing an operator's precedence, or\n    order of operation.\n    https://en.wikipedia.org/wiki/Order_of_operations\n    \"\"\"\n    return PRECEDENCES.get(char, -1)",
    "docstring": "Return integer value representing an operator's precedence, or\norder of operation.\nhttps://en.wikipedia.org/wiki/Order_of_operations"
  },
  {
    "function": "associativity",
    "code": "def associativity(char: str) -> Literal[\"LR\", \"RL\"]:\n    \"\"\"\n    Return the associativity of the operator `char`.\n    https://en.wikipedia.org/wiki/Operator_associativity\n    \"\"\"\n    return ASSOCIATIVITIES[char]",
    "docstring": "Return the associativity of the operator `char`.\nhttps://en.wikipedia.org/wiki/Operator_associativity"
  },
  {
    "function": "infix_to_postfix",
    "code": "def infix_to_postfix(expression_str: str) -> str:\n    \"\"\"\n    >>> infix_to_postfix(\"(1*(2+3)+4))\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Mismatched parentheses\n    >>> infix_to_postfix(\"\")\n    ''\n    >>> infix_to_postfix(\"3+2\")\n    '3 2 +'\n    >>> infix_to_postfix(\"(3+4)*5-6\")\n    '3 4 + 5 * 6 -'\n    >>> infix_to_postfix(\"(1+2)*3/4-5\")\n    '1 2 + 3 * 4 / 5 -'\n    >>> infix_to_postfix(\"a+b*c+(d*e+f)*g\")\n    'a b c * + d e * f + g * +'\n    >>> infix_to_postfix(\"x^y/(5*z)+2\")\n    'x y ^ 5 z * / 2 +'\n    >>> infix_to_postfix(\"2^3^2\")\n    '2 3 2 ^ ^'\n    \"\"\"\n    if not balanced_parentheses(expression_str):\n        raise ValueError(\"Mismatched parentheses\")\n    stack: Stack[str] = Stack()\n    postfix = []\n    for char in expression_str:\n        if char.isalpha() or char.isdigit():\n            postfix.append(char)\n        elif char == \"(\":\n            stack.push(char)\n        elif char == \")\":\n            while not stack.is_empty() and stack.peek() != \"(\":\n                postfix.append(stack.pop())\n            stack.pop()\n        else:\n            while True:\n                if stack.is_empty():\n                    stack.push(char)\n                    break\n\n                char_precedence = precedence(char)\n                tos_precedence = precedence(stack.peek())\n\n                if char_precedence > tos_precedence:\n                    stack.push(char)\n                    break\n                if char_precedence < tos_precedence:\n                    postfix.append(stack.pop())\n                    continue\n                # Precedences are equal\n                if associativity(char) == \"RL\":\n                    stack.push(char)\n                    break\n                postfix.append(stack.pop())\n\n    while not stack.is_empty():\n        postfix.append(stack.pop())\n    return \" \".join(postfix)",
    "docstring": ">>> infix_to_postfix(\"(1*(2+3)+4))\")\nTraceback (most recent call last):\n    ...\nValueError: Mismatched parentheses\n>>> infix_to_postfix(\"\")\n''\n>>> infix_to_postfix(\"3+2\")\n'3 2 +'\n>>> infix_to_postfix(\"(3+4)*5-6\")\n'3 4 + 5 * 6 -'\n>>> infix_to_postfix(\"(1+2)*3/4-5\")\n'1 2 + 3 * 4 / 5 -'\n>>> infix_to_postfix(\"a+b*c+(d*e+f)*g\")\n'a b c * + d e * f + g * +'\n>>> infix_to_postfix(\"x^y/(5*z)+2\")\n'x y ^ 5 z * / 2 +'\n>>> infix_to_postfix(\"2^3^2\")\n'2 3 2 ^ ^'"
  },
  {
    "function": "infix_2_postfix",
    "code": "def infix_2_postfix(infix: str) -> str:\n    \"\"\"\n    >>> infix_2_postfix(\"a+b^c\")  # doctest: +NORMALIZE_WHITESPACE\n     Symbol  |  Stack  | Postfix\n    ----------------------------\n       a     |         | a\n       +     | +       | a\n       b     | +       | ab\n       ^     | +^      | ab\n       c     | +^      | abc\n             | +       | abc^\n             |         | abc^+\n    'abc^+'\n\n    >>> infix_2_postfix(\"1*((-a)*2+b)\")   # doctest: +NORMALIZE_WHITESPACE\n      Symbol  |    Stack     |   Postfix\n    -------------------------------------------\n       1     |              | 1\n       *     | *            | 1\n       (     | *(           | 1\n       (     | *((          | 1\n       -     | *((-         | 1\n       a     | *((-         | 1a\n       )     | *(           | 1a-\n       *     | *(*          | 1a-\n       2     | *(*          | 1a-2\n       +     | *(+          | 1a-2*\n       b     | *(+          | 1a-2*b\n       )     | *            | 1a-2*b+\n             |              | 1a-2*b+*\n    '1a-2*b+*'\n\n    >>> infix_2_postfix(\"\")\n     Symbol  |  Stack  | Postfix\n    ----------------------------\n    ''\n\n    >>> infix_2_postfix(\"(()\")\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid expression\n\n    >>> infix_2_postfix(\"())\")\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n    stack = []\n    post_fix = []\n    priority = {\n        \"^\": 3,\n        \"*\": 2,\n        \"/\": 2,\n        \"%\": 2,\n        \"+\": 1,\n        \"-\": 1,\n    }  # Priority of each operator\n    print_width = max(len(infix), 7)\n\n    # Print table header for output\n    print(\n        \"Symbol\".center(8),\n        \"Stack\".center(print_width),\n        \"Postfix\".center(print_width),\n        sep=\" | \",\n    )\n    print(\"-\" * (print_width * 3 + 7))\n\n    for x in infix:\n        if x.isalpha() or x.isdigit():\n            post_fix.append(x)  # if x is Alphabet / Digit, add it to Postfix\n        elif x == \"(\":\n            stack.append(x)  # if x is \"(\" push to Stack\n        elif x == \")\":  # if x is \")\" pop stack until \"(\" is encountered\n            if len(stack) == 0:  # close bracket without open bracket\n                raise IndexError(\"list index out of range\")\n\n            while stack[-1] != \"(\":\n                post_fix.append(stack.pop())  # Pop stack & add the content to Postfix\n            stack.pop()\n        elif len(stack) == 0:\n            stack.append(x)  # If stack is empty, push x to stack\n        else:  # while priority of x is not > priority of element in the stack\n            while stack and stack[-1] != \"(\" and priority[x] <= priority[stack[-1]]:\n                post_fix.append(stack.pop())  # pop stack & add to Postfix\n            stack.append(x)  # push x to stack\n\n        print(\n            x.center(8),\n            (\"\".join(stack)).ljust(print_width),\n            (\"\".join(post_fix)).ljust(print_width),\n            sep=\" | \",\n        )  # Output in tabular format\n\n    while len(stack) > 0:  # while stack is not empty\n        if stack[-1] == \"(\":  # open bracket with no close bracket\n            raise ValueError(\"invalid expression\")\n\n        post_fix.append(stack.pop())  # pop stack & add to Postfix\n        print(\n            \" \".center(8),\n            (\"\".join(stack)).ljust(print_width),\n            (\"\".join(post_fix)).ljust(print_width),\n            sep=\" | \",\n        )  # Output in tabular format\n\n    return \"\".join(post_fix)  # return Postfix as str",
    "docstring": ">>> infix_2_postfix(\"a+b^c\")  # doctest: +NORMALIZE_WHITESPACE\n Symbol  |  Stack  | Postfix\n----------------------------\n   a     |         | a\n   +     | +       | a\n   b     | +       | ab\n   ^     | +^      | ab\n   c     | +^      | abc\n         | +       | abc^\n         |         | abc^+\n'abc^+'\n\n>>> infix_2_postfix(\"1*((-a)*2+b)\")   # doctest: +NORMALIZE_WHITESPACE\n  Symbol  |    Stack     |   Postfix\n-------------------------------------------\n   1     |              | 1\n   *     | *            | 1\n   (     | *(           | 1\n   (     | *((          | 1\n   -     | *((-         | 1\n   a     | *((-         | 1a\n   )     | *(           | 1a-\n   *     | *(*          | 1a-\n   2     | *(*          | 1a-2\n   +     | *(+          | 1a-2*\n   b     | *(+          | 1a-2*b\n   )     | *            | 1a-2*b+\n         |              | 1a-2*b+*\n'1a-2*b+*'\n\n>>> infix_2_postfix(\"\")\n Symbol  |  Stack  | Postfix\n----------------------------\n''\n\n>>> infix_2_postfix(\"(()\")\nTraceback (most recent call last):\n    ...\nValueError: invalid expression\n\n>>> infix_2_postfix(\"())\")\nTraceback (most recent call last):\n    ...\nIndexError: list index out of range"
  },
  {
    "function": "infix_2_prefix",
    "code": "def infix_2_prefix(infix: str) -> str:\n    \"\"\"\n    >>> infix_2_prefix(\"a+b^c\")  # doctest: +NORMALIZE_WHITESPACE\n     Symbol  |  Stack  | Postfix\n    ----------------------------\n       c     |         | c\n       ^     | ^       | c\n       b     | ^       | cb\n       +     | +       | cb^\n       a     | +       | cb^a\n             |         | cb^a+\n    '+a^bc'\n\n    >>> infix_2_prefix(\"1*((-a)*2+b)\") # doctest: +NORMALIZE_WHITESPACE\n     Symbol  |    Stack     |   Postfix\n    -------------------------------------------\n       (     | (            |\n       b     | (            | b\n       +     | (+           | b\n       2     | (+           | b2\n       *     | (+*          | b2\n       (     | (+*(         | b2\n       a     | (+*(         | b2a\n       -     | (+*(-        | b2a\n       )     | (+*          | b2a-\n       )     |              | b2a-*+\n       *     | *            | b2a-*+\n       1     | *            | b2a-*+1\n             |              | b2a-*+1*\n    '*1+*-a2b'\n\n    >>> infix_2_prefix('')\n     Symbol  |  Stack  | Postfix\n    ----------------------------\n    ''\n\n    >>> infix_2_prefix('(()')\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n\n    >>> infix_2_prefix('())')\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid expression\n    \"\"\"\n    reversed_infix = list(infix[::-1])  # reverse the infix equation\n\n    for i in range(len(reversed_infix)):\n        if reversed_infix[i] == \"(\":\n            reversed_infix[i] = \")\"  # change \"(\" to \")\"\n        elif reversed_infix[i] == \")\":\n            reversed_infix[i] = \"(\"  # change \")\" to \"(\"\n\n    # call infix_2_postfix on Infix, return reverse of Postfix\n    return (infix_2_postfix(\"\".join(reversed_infix)))[::-1]",
    "docstring": ">>> infix_2_prefix(\"a+b^c\")  # doctest: +NORMALIZE_WHITESPACE\n Symbol  |  Stack  | Postfix\n----------------------------\n   c     |         | c\n   ^     | ^       | c\n   b     | ^       | cb\n   +     | +       | cb^\n   a     | +       | cb^a\n         |         | cb^a+\n'+a^bc'\n\n>>> infix_2_prefix(\"1*((-a)*2+b)\") # doctest: +NORMALIZE_WHITESPACE\n Symbol  |    Stack     |   Postfix\n-------------------------------------------\n   (     | (            |\n   b     | (            | b\n   +     | (+           | b\n   2     | (+           | b2\n   *     | (+*          | b2\n   (     | (+*(         | b2\n   a     | (+*(         | b2a\n   -     | (+*(-        | b2a\n   )     | (+*          | b2a-\n   )     |              | b2a-*+\n   *     | *            | b2a-*+\n   1     | *            | b2a-*+1\n         |              | b2a-*+1*\n'*1+*-a2b'\n\n>>> infix_2_prefix('')\n Symbol  |  Stack  | Postfix\n----------------------------\n''\n\n>>> infix_2_prefix('(()')\nTraceback (most recent call last):\n    ...\nIndexError: list index out of range\n\n>>> infix_2_prefix('())')\nTraceback (most recent call last):\n    ...\nValueError: invalid expression"
  },
  {
    "function": "largest_rectangle_area",
    "code": "def largest_rectangle_area(heights: list[int]) -> int:\n    \"\"\"\n    Inputs an array of integers representing the heights of bars,\n    and returns the area of the largest rectangle that can be formed\n\n    >>> largest_rectangle_area([2, 1, 5, 6, 2, 3])\n    10\n\n    >>> largest_rectangle_area([2, 4])\n    4\n\n    >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6])\n    12\n\n    >>> largest_rectangle_area([1])\n    1\n    \"\"\"\n    stack: list[int] = []\n    max_area = 0\n    heights = [*heights, 0]  # make a new list by appending the sentinel 0\n    n = len(heights)\n\n    for i in range(n):\n        # make sure the stack remains in increasing order\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]  # height of the bar\n            # if stack is empty, it means entire width can be taken from index 0 to i-1\n            w = i if not stack else i - stack[-1] - 1  # calculate width\n            max_area = max(max_area, h * w)\n\n        stack.append(i)\n\n    return max_area",
    "docstring": "Inputs an array of integers representing the heights of bars,\nand returns the area of the largest rectangle that can be formed\n\n>>> largest_rectangle_area([2, 1, 5, 6, 2, 3])\n10\n\n>>> largest_rectangle_area([2, 4])\n4\n\n>>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6])\n12\n\n>>> largest_rectangle_area([1])\n1"
  },
  {
    "function": "lexical_order",
    "code": "def lexical_order(max_number: int) -> Iterator[int]:\n    \"\"\"\n    Generate numbers in lexical order from 1 to max_number.\n\n    >>> \" \".join(map(str, lexical_order(13)))\n    '1 10 11 12 13 2 3 4 5 6 7 8 9'\n    >>> list(lexical_order(1))\n    [1]\n    >>> \" \".join(map(str, lexical_order(20)))\n    '1 10 11 12 13 14 15 16 17 18 19 2 20 3 4 5 6 7 8 9'\n    >>> \" \".join(map(str, lexical_order(25)))\n    '1 10 11 12 13 14 15 16 17 18 19 2 20 21 22 23 24 25 3 4 5 6 7 8 9'\n    >>> list(lexical_order(12))\n    [1, 10, 11, 12, 2, 3, 4, 5, 6, 7, 8, 9]\n    \"\"\"\n\n    stack = [1]\n\n    while stack:\n        num = stack.pop()\n        if num > max_number:\n            continue\n\n        yield num\n        if (num % 10) != 9:\n            stack.append(num + 1)\n\n        stack.append(num * 10)",
    "docstring": "Generate numbers in lexical order from 1 to max_number.\n\n>>> \" \".join(map(str, lexical_order(13)))\n'1 10 11 12 13 2 3 4 5 6 7 8 9'\n>>> list(lexical_order(1))\n[1]\n>>> \" \".join(map(str, lexical_order(20)))\n'1 10 11 12 13 14 15 16 17 18 19 2 20 3 4 5 6 7 8 9'\n>>> \" \".join(map(str, lexical_order(25)))\n'1 10 11 12 13 14 15 16 17 18 19 2 20 21 22 23 24 25 3 4 5 6 7 8 9'\n>>> list(lexical_order(12))\n[1, 10, 11, 12, 2, 3, 4, 5, 6, 7, 8, 9]"
  },
  {
    "function": "next_greatest_element_slow",
    "code": "def next_greatest_element_slow(arr: list[float]) -> list[float]:\n    \"\"\"\n    Get the Next Greatest Element (NGE) for each element in the array\n    by checking all subsequent elements to find the next greater one.\n\n    This is a brute-force implementation, and it has a time complexity\n    of O(n^2), where n is the size of the array.\n\n    Args:\n        arr: List of numbers for which the NGE is calculated.\n\n    Returns:\n        List containing the next greatest elements. If no\n        greater element is found, -1 is placed in the result.\n\n    Example:\n    >>> next_greatest_element_slow(arr) == expect\n    True\n    \"\"\"\n\n    result = []\n    arr_size = len(arr)\n\n    for i in range(arr_size):\n        next_element: float = -1\n        for j in range(i + 1, arr_size):\n            if arr[i] < arr[j]:\n                next_element = arr[j]\n                break\n        result.append(next_element)\n    return result",
    "docstring": "Get the Next Greatest Element (NGE) for each element in the array\nby checking all subsequent elements to find the next greater one.\n\nThis is a brute-force implementation, and it has a time complexity\nof O(n^2), where n is the size of the array.\n\nArgs:\n    arr: List of numbers for which the NGE is calculated.\n\nReturns:\n    List containing the next greatest elements. If no\n    greater element is found, -1 is placed in the result.\n\nExample:\n>>> next_greatest_element_slow(arr) == expect\nTrue"
  },
  {
    "function": "next_greatest_element_fast",
    "code": "def next_greatest_element_fast(arr: list[float]) -> list[float]:\n    \"\"\"\n    Find the Next Greatest Element (NGE) for each element in the array\n    using a more readable approach. This implementation utilizes\n    enumerate() for the outer loop and slicing for the inner loop.\n\n    While this improves readability over next_greatest_element_slow(),\n    it still has a time complexity of O(n^2).\n\n    Args:\n        arr: List of numbers for which the NGE is calculated.\n\n    Returns:\n        List containing the next greatest elements. If no\n        greater element is found, -1 is placed in the result.\n\n    Example:\n    >>> next_greatest_element_fast(arr) == expect\n    True\n    \"\"\"\n    result = []\n    for i, outer in enumerate(arr):\n        next_item: float = -1\n        for inner in arr[i + 1 :]:\n            if outer < inner:\n                next_item = inner\n                break\n        result.append(next_item)\n    return result",
    "docstring": "Find the Next Greatest Element (NGE) for each element in the array\nusing a more readable approach. This implementation utilizes\nenumerate() for the outer loop and slicing for the inner loop.\n\nWhile this improves readability over next_greatest_element_slow(),\nit still has a time complexity of O(n^2).\n\nArgs:\n    arr: List of numbers for which the NGE is calculated.\n\nReturns:\n    List containing the next greatest elements. If no\n    greater element is found, -1 is placed in the result.\n\nExample:\n>>> next_greatest_element_fast(arr) == expect\nTrue"
  },
  {
    "function": "next_greatest_element",
    "code": "def next_greatest_element(arr: list[float]) -> list[float]:\n    \"\"\"\n    Efficient solution to find the Next Greatest Element (NGE) for all elements\n    using a stack. The time complexity is reduced to O(n), making it suitable\n    for larger arrays.\n\n    The stack keeps track of elements for which the next greater element hasn't\n    been found yet. By iterating through the array in reverse (from the last\n    element to the first), the stack is used to efficiently determine the next\n    greatest element for each element.\n\n    Args:\n        arr: List of numbers for which the NGE is calculated.\n\n    Returns:\n        List containing the next greatest elements. If no\n        greater element is found, -1 is placed in the result.\n\n    Example:\n    >>> next_greatest_element(arr) == expect\n    True\n    \"\"\"\n    arr_size = len(arr)\n    stack: list[float] = []\n    result: list[float] = [-1] * arr_size\n\n    for index in reversed(range(arr_size)):\n        if stack:\n            while stack[-1] <= arr[index]:\n                stack.pop()\n                if not stack:\n                    break\n        if stack:\n            result[index] = stack[-1]\n        stack.append(arr[index])\n    return result",
    "docstring": "Efficient solution to find the Next Greatest Element (NGE) for all elements\nusing a stack. The time complexity is reduced to O(n), making it suitable\nfor larger arrays.\n\nThe stack keeps track of elements for which the next greater element hasn't\nbeen found yet. By iterating through the array in reverse (from the last\nelement to the first), the stack is used to efficiently determine the next\ngreatest element for each element.\n\nArgs:\n    arr: List of numbers for which the NGE is calculated.\n\nReturns:\n    List containing the next greatest elements. If no\n    greater element is found, -1 is placed in the result.\n\nExample:\n>>> next_greatest_element(arr) == expect\nTrue"
  },
  {
    "function": "parse_token",
    "code": "def parse_token(token: str | float) -> float | str:\n    \"\"\"\n    Converts the given data to the appropriate number if it is indeed a number, else\n    returns the data as it is with a False flag. This function also serves as a check\n    of whether the input is a number or not.\n\n    Parameters\n    ----------\n    token: The data that needs to be converted to the appropriate operator or number.\n\n    Returns\n    -------\n    float or str\n        Returns a float if `token` is a number or a str if `token` is an operator\n    \"\"\"\n    if token in OPERATORS:\n        return token\n    try:\n        return float(token)\n    except ValueError:\n        msg = f\"{token} is neither a number nor a valid operator\"\n        raise ValueError(msg)",
    "docstring": "Converts the given data to the appropriate number if it is indeed a number, else\nreturns the data as it is with a False flag. This function also serves as a check\nof whether the input is a number or not.\n\nParameters\n----------\ntoken: The data that needs to be converted to the appropriate operator or number.\n\nReturns\n-------\nfloat or str\n    Returns a float if `token` is a number or a str if `token` is an operator"
  },
  {
    "function": "evaluate",
    "code": "def evaluate(post_fix: list[str], verbose: bool = False) -> float:\n    \"\"\"\n    Evaluate postfix expression using a stack.\n    >>> evaluate([\"0\"])\n    0.0\n    >>> evaluate([\"-0\"])\n    -0.0\n    >>> evaluate([\"1\"])\n    1.0\n    >>> evaluate([\"-1\"])\n    -1.0\n    >>> evaluate([\"-1.1\"])\n    -1.1\n    >>> evaluate([\"2\", \"1\", \"+\", \"3\", \"*\"])\n    9.0\n    >>> evaluate([\"2\", \"1.9\", \"+\", \"3\", \"*\"])\n    11.7\n    >>> evaluate([\"2\", \"-1.9\", \"+\", \"3\", \"*\"])\n    0.30000000000000027\n    >>> evaluate([\"4\", \"13\", \"5\", \"/\", \"+\"])\n    6.6\n    >>> evaluate([\"2\", \"-\", \"3\", \"+\"])\n    1.0\n    >>> evaluate([\"-4\", \"5\", \"*\", \"6\", \"-\"])\n    -26.0\n    >>> evaluate([])\n    0\n    >>> evaluate([\"4\", \"-\", \"6\", \"7\", \"/\", \"9\", \"8\"])\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: Input is not a valid postfix expression\n\n    Parameters\n    ----------\n    post_fix:\n        The postfix expression is tokenized into operators and operands and stored\n        as a Python list\n\n    verbose:\n        Display stack contents while evaluating the expression if verbose is True\n\n    Returns\n    -------\n    float\n        The evaluated value\n    \"\"\"\n    if not post_fix:\n        return 0\n    # Checking the list to find out whether the postfix expression is valid\n    valid_expression = [parse_token(token) for token in post_fix]\n    if verbose:\n        # print table header\n        print(\"Symbol\".center(8), \"Action\".center(12), \"Stack\", sep=\" | \")\n        print(\"-\" * (30 + len(post_fix)))\n    stack = []\n    for x in valid_expression:\n        if x not in OPERATORS:\n            stack.append(x)  # append x to stack\n            if verbose:\n                # output in tabular format\n                print(\n                    f\"{x}\".rjust(8),\n                    f\"push({x})\".ljust(12),\n                    stack,\n                    sep=\" | \",\n                )\n            continue\n        # If x is operator\n        # If only 1 value is inside the stack and + or - is encountered\n        # then this is unary + or - case\n        if x in UNARY_OP_SYMBOLS and len(stack) < 2:\n            b = stack.pop()  # pop stack\n            if x == \"-\":\n                b *= -1  # negate b\n            stack.append(b)\n            if verbose:\n                # output in tabular format\n                print(\n                    \"\".rjust(8),\n                    f\"pop({b})\".ljust(12),\n                    stack,\n                    sep=\" | \",\n                )\n                print(\n                    str(x).rjust(8),\n                    f\"push({x}{b})\".ljust(12),\n                    stack,\n                    sep=\" | \",\n                )\n            continue\n        b = stack.pop()  # pop stack\n        if verbose:\n            # output in tabular format\n            print(\n                \"\".rjust(8),\n                f\"pop({b})\".ljust(12),\n                stack,\n                sep=\" | \",\n            )\n\n        a = stack.pop()  # pop stack\n        if verbose:\n            # output in tabular format\n            print(\n                \"\".rjust(8),\n                f\"pop({a})\".ljust(12),\n                stack,\n                sep=\" | \",\n            )\n        # evaluate the 2 values popped from stack & push result to stack\n        stack.append(OPERATORS[x](a, b))  # type: ignore[index]\n        if verbose:\n            # output in tabular format\n            print(\n                f\"{x}\".rjust(8),\n                f\"push({a}{x}{b})\".ljust(12),\n                stack,\n                sep=\" | \",\n            )\n    # If everything is executed correctly, the stack will contain\n    # only one element which is the result\n    if len(stack) != 1:\n        raise ArithmeticError(\"Input is not a valid postfix expression\")\n    return float(stack[0])",
    "docstring": "Evaluate postfix expression using a stack.\n>>> evaluate([\"0\"])\n0.0\n>>> evaluate([\"-0\"])\n-0.0\n>>> evaluate([\"1\"])\n1.0\n>>> evaluate([\"-1\"])\n-1.0\n>>> evaluate([\"-1.1\"])\n-1.1\n>>> evaluate([\"2\", \"1\", \"+\", \"3\", \"*\"])\n9.0\n>>> evaluate([\"2\", \"1.9\", \"+\", \"3\", \"*\"])\n11.7\n>>> evaluate([\"2\", \"-1.9\", \"+\", \"3\", \"*\"])\n0.30000000000000027\n>>> evaluate([\"4\", \"13\", \"5\", \"/\", \"+\"])\n6.6\n>>> evaluate([\"2\", \"-\", \"3\", \"+\"])\n1.0\n>>> evaluate([\"-4\", \"5\", \"*\", \"6\", \"-\"])\n-26.0\n>>> evaluate([])\n0\n>>> evaluate([\"4\", \"-\", \"6\", \"7\", \"/\", \"9\", \"8\"])\nTraceback (most recent call last):\n...\nArithmeticError: Input is not a valid postfix expression\n\nParameters\n----------\npost_fix:\n    The postfix expression is tokenized into operators and operands and stored\n    as a Python list\n\nverbose:\n    Display stack contents while evaluating the expression if verbose is True\n\nReturns\n-------\nfloat\n    The evaluated value"
  },
  {
    "function": "is_operand",
    "code": "def is_operand(c):\n    \"\"\"\n    Return True if the given char c is an operand, e.g. it is a number\n\n    >>> is_operand(\"1\")\n    True\n    >>> is_operand(\"+\")\n    False\n    \"\"\"\n    return c.isdigit()",
    "docstring": "Return True if the given char c is an operand, e.g. it is a number\n\n>>> is_operand(\"1\")\nTrue\n>>> is_operand(\"+\")\nFalse"
  },
  {
    "function": "evaluate",
    "code": "def evaluate(expression):\n    \"\"\"\n    Evaluate a given expression in prefix notation.\n    Asserts that the given expression is valid.\n\n    >>> evaluate(\"+ 9 * 2 6\")\n    21\n    >>> evaluate(\"/ * 10 2 + 4 1 \")\n    4.0\n    >>> evaluate(\"2\")\n    2\n    >>> evaluate(\"+ * 2 3 / 8 4\")\n    8.0\n    \"\"\"\n    stack = []\n\n    # iterate over the string in reverse order\n    for c in expression.split()[::-1]:\n        # push operand to stack\n        if is_operand(c):\n            stack.append(int(c))\n\n        else:\n            # pop values from stack can calculate the result\n            # push the result onto the stack again\n            o1 = stack.pop()\n            o2 = stack.pop()\n            stack.append(operators[c](o1, o2))\n\n    return stack.pop()",
    "docstring": "Evaluate a given expression in prefix notation.\nAsserts that the given expression is valid.\n\n>>> evaluate(\"+ 9 * 2 6\")\n21\n>>> evaluate(\"/ * 10 2 + 4 1 \")\n4.0\n>>> evaluate(\"2\")\n2\n>>> evaluate(\"+ * 2 3 / 8 4\")\n8.0"
  },
  {
    "function": "evaluate_recursive",
    "code": "def evaluate_recursive(expression: list[str]):\n    \"\"\"\n    Alternative recursive implementation\n\n    >>> evaluate_recursive(['2'])\n    2\n    >>> expression = ['+', '*', '2', '3', '/', '8', '4']\n    >>> evaluate_recursive(expression)\n    8.0\n    >>> expression\n    []\n    >>> evaluate_recursive(['+', '9', '*', '2', '6'])\n    21\n    >>> evaluate_recursive(['/', '*', '10', '2', '+', '4', '1'])\n    4.0\n    \"\"\"\n\n    op = expression.pop(0)\n    if is_operand(op):\n        return int(op)\n\n    operation = operators[op]\n\n    a = evaluate_recursive(expression)\n    b = evaluate_recursive(expression)\n    return operation(a, b)",
    "docstring": "Alternative recursive implementation\n\n>>> evaluate_recursive(['2'])\n2\n>>> expression = ['+', '*', '2', '3', '/', '8', '4']\n>>> evaluate_recursive(expression)\n8.0\n>>> expression\n[]\n>>> evaluate_recursive(['+', '9', '*', '2', '6'])\n21\n>>> evaluate_recursive(['/', '*', '10', '2', '+', '4', '1'])\n4.0"
  },
  {
    "function": "calculate_span",
    "code": "def calculate_span(price: list[int]) -> list[int]:\n    \"\"\"\n    Calculate the span values for a given list of stock prices.\n    Args:\n        price: List of stock prices.\n    Returns:\n        List of span values.\n\n    >>> calculate_span([10, 4, 5, 90, 120, 80])\n    [1, 1, 2, 4, 5, 1]\n    >>> calculate_span([100, 50, 60, 70, 80, 90])\n    [1, 1, 2, 3, 4, 5]\n    >>> calculate_span([5, 4, 3, 2, 1])\n    [1, 1, 1, 1, 1]\n    >>> calculate_span([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> calculate_span([10, 20, 30, 40, 50])\n    [1, 2, 3, 4, 5]\n    >>> calculate_span([100, 80, 60, 70, 60, 75, 85])\n    [1, 1, 1, 2, 1, 4, 6]\n    \"\"\"\n    n = len(price)\n    s = [0] * n\n    # Create a stack and push index of fist element to it\n    st = []\n    st.append(0)\n\n    # Span value of first element is always 1\n    s[0] = 1\n\n    # Calculate span values for rest of the elements\n    for i in range(1, n):\n        # Pop elements from stack while stack is not\n        # empty and top of stack is smaller than price[i]\n        while len(st) > 0 and price[st[-1]] <= price[i]:\n            st.pop()\n\n        # If stack becomes empty, then price[i] is greater\n        # than all elements on left of it, i.e. price[0],\n        # price[1], ..price[i-1]. Else the price[i]  is\n        # greater than elements after top of stack\n        s[i] = i + 1 if len(st) <= 0 else (i - st[-1])\n\n        # Push this element to stack\n        st.append(i)\n\n    return s",
    "docstring": "Calculate the span values for a given list of stock prices.\nArgs:\n    price: List of stock prices.\nReturns:\n    List of span values.\n\n>>> calculate_span([10, 4, 5, 90, 120, 80])\n[1, 1, 2, 4, 5, 1]\n>>> calculate_span([100, 50, 60, 70, 80, 90])\n[1, 1, 2, 3, 4, 5]\n>>> calculate_span([5, 4, 3, 2, 1])\n[1, 1, 1, 1, 1]\n>>> calculate_span([1, 2, 3, 4, 5])\n[1, 2, 3, 4, 5]\n>>> calculate_span([10, 20, 30, 40, 50])\n[1, 2, 3, 4, 5]\n>>> calculate_span([100, 80, 60, 70, 60, 75, 85])\n[1, 1, 1, 2, 1, 4, 6]"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Demonstrate the usage of the SuffixTree class.\n\n    - Initializes a SuffixTree with a predefined text.\n    - Defines a list of patterns to search for within the suffix tree.\n    - Searches for each pattern in the suffix tree.\n\n    Patterns tested:\n        - \"ana\" (found) --> True\n        - \"ban\" (found) --> True\n        - \"na\" (found) --> True\n        - \"xyz\" (not found) --> False\n        - \"mon\" (found) --> True\n    \"\"\"\n    text = \"monkey banana\"\n    suffix_tree = SuffixTree(text)\n\n    patterns = [\"ana\", \"ban\", \"na\", \"xyz\", \"mon\"]\n    for pattern in patterns:\n        found = suffix_tree.search(pattern)\n        print(f\"Pattern '{pattern}' found: {found}\")",
    "docstring": "Demonstrate the usage of the SuffixTree class.\n\n- Initializes a SuffixTree with a predefined text.\n- Defines a list of patterns to search for within the suffix tree.\n- Searches for each pattern in the suffix tree.\n\nPatterns tested:\n    - \"ana\" (found) --> True\n    - \"ban\" (found) --> True\n    - \"na\" (found) --> True\n    - \"xyz\" (not found) --> False\n    - \"mon\" (found) --> True"
  },
  {
    "function": "print_words",
    "code": "def print_words(node: TrieNode, word: str) -> None:\n    \"\"\"\n    Prints all the words in a Trie\n    :param node: root node of Trie\n    :param word: Word variable should be empty at start\n    :return: None\n    \"\"\"\n    if node.is_leaf:\n        print(word, end=\" \")\n\n    for key, value in node.nodes.items():\n        print_words(value, word + key)",
    "docstring": "Prints all the words in a Trie\n:param node: root node of Trie\n:param word: Word variable should be empty at start\n:return: None"
  },
  {
    "function": "change_brightness",
    "code": "def change_brightness(img: Image, level: float) -> Image:\n    \"\"\"\n    Change the brightness of a PIL Image to a given level.\n    \"\"\"\n\n    def brightness(c: int) -> float:\n        \"\"\"\n        Fundamental Transformation/Operation that'll be performed on\n        every bit.\n        \"\"\"\n        return 128 + level + (c - 128)\n\n    if not -255.0 <= level <= 255.0:\n        raise ValueError(\"level must be between -255.0 (black) and 255.0 (white)\")\n    return img.point(brightness)",
    "docstring": "Change the brightness of a PIL Image to a given level."
  },
  {
    "function": "change_contrast",
    "code": "def change_contrast(img: Image, level: int) -> Image:\n    \"\"\"\n    Function to change contrast\n    \"\"\"\n    factor = (259 * (level + 255)) / (255 * (259 - level))\n\n    def contrast(c: int) -> int:\n        \"\"\"\n        Fundamental Transformation/Operation that'll be performed on\n        every bit.\n        \"\"\"\n        return int(128 + factor * (c - 128))\n\n    return img.point(contrast)",
    "docstring": "Function to change contrast"
  },
  {
    "function": "make_sepia",
    "code": "def make_sepia(img, factor: int):\n    \"\"\"\n    Function create sepia tone.\n    Source: https://en.wikipedia.org/wiki/Sepia_(color)\n    \"\"\"\n    pixel_h, pixel_v = img.shape[0], img.shape[1]\n\n    def to_grayscale(blue, green, red):\n        \"\"\"\n        Helper function to create pixel's greyscale representation\n        Src: https://pl.wikipedia.org/wiki/YUV\n        \"\"\"\n        return 0.2126 * red + 0.587 * green + 0.114 * blue\n\n    def normalize(value):\n        \"\"\"Helper function to normalize R/G/B value -> return 255 if value > 255\"\"\"\n        return min(value, 255)\n\n    for i in range(pixel_h):\n        for j in range(pixel_v):\n            greyscale = int(to_grayscale(*img[i][j]))\n            img[i][j] = [\n                normalize(greyscale),\n                normalize(greyscale + factor),\n                normalize(greyscale + 2 * factor),\n            ]\n\n    return img",
    "docstring": "Function create sepia tone.\nSource: https://en.wikipedia.org/wiki/Sepia_(color)"
  },
  {
    "function": "suppress_non_maximum",
    "code": "def suppress_non_maximum(image_shape, gradient_direction, sobel_grad):\n    \"\"\"\n    Non-maximum suppression. If the edge strength of the current pixel is the largest\n    compared to the other pixels in the mask with the same direction, the value will be\n    preserved. Otherwise, the value will be suppressed.\n    \"\"\"\n    destination = np.zeros(image_shape)\n\n    for row in range(1, image_shape[0] - 1):\n        for col in range(1, image_shape[1] - 1):\n            direction = gradient_direction[row, col]\n\n            if (\n                0 <= direction < PI / 8\n                or 15 * PI / 8 <= direction <= 2 * PI\n                or 7 * PI / 8 <= direction <= 9 * PI / 8\n            ):\n                w = sobel_grad[row, col - 1]\n                e = sobel_grad[row, col + 1]\n                if sobel_grad[row, col] >= w and sobel_grad[row, col] >= e:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                PI / 8 <= direction < 3 * PI / 8\n                or 9 * PI / 8 <= direction < 11 * PI / 8\n            ):\n                sw = sobel_grad[row + 1, col - 1]\n                ne = sobel_grad[row - 1, col + 1]\n                if sobel_grad[row, col] >= sw and sobel_grad[row, col] >= ne:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                3 * PI / 8 <= direction < 5 * PI / 8\n                or 11 * PI / 8 <= direction < 13 * PI / 8\n            ):\n                n = sobel_grad[row - 1, col]\n                s = sobel_grad[row + 1, col]\n                if sobel_grad[row, col] >= n and sobel_grad[row, col] >= s:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                5 * PI / 8 <= direction < 7 * PI / 8\n                or 13 * PI / 8 <= direction < 15 * PI / 8\n            ):\n                nw = sobel_grad[row - 1, col - 1]\n                se = sobel_grad[row + 1, col + 1]\n                if sobel_grad[row, col] >= nw and sobel_grad[row, col] >= se:\n                    destination[row, col] = sobel_grad[row, col]\n\n    return destination",
    "docstring": "Non-maximum suppression. If the edge strength of the current pixel is the largest\ncompared to the other pixels in the mask with the same direction, the value will be\npreserved. Otherwise, the value will be suppressed."
  },
  {
    "function": "detect_high_low_threshold",
    "code": "def detect_high_low_threshold(\n    image_shape, destination, threshold_low, threshold_high, weak, strong\n):\n    \"\"\"\n    High-Low threshold detection. If an edge pixel's gradient value is higher\n    than the high threshold value, it is marked as a strong edge pixel. If an\n    edge pixel's gradient value is smaller than the high threshold value and\n    larger than the low threshold value, it is marked as a weak edge pixel. If\n    an edge pixel's value is smaller than the low threshold value, it will be\n    suppressed.\n    \"\"\"\n    for row in range(1, image_shape[0] - 1):\n        for col in range(1, image_shape[1] - 1):\n            if destination[row, col] >= threshold_high:\n                destination[row, col] = strong\n            elif destination[row, col] <= threshold_low:\n                destination[row, col] = 0\n            else:\n                destination[row, col] = weak",
    "docstring": "High-Low threshold detection. If an edge pixel's gradient value is higher\nthan the high threshold value, it is marked as a strong edge pixel. If an\nedge pixel's gradient value is smaller than the high threshold value and\nlarger than the low threshold value, it is marked as a weak edge pixel. If\nan edge pixel's value is smaller than the low threshold value, it will be\nsuppressed."
  },
  {
    "function": "track_edge",
    "code": "def track_edge(image_shape, destination, weak, strong):\n    \"\"\"\n    Edge tracking. Usually a weak edge pixel caused from true edges will be connected\n    to a strong edge pixel while noise responses are unconnected. As long as there is\n    one strong edge pixel that is involved in its 8-connected neighborhood, that weak\n    edge point can be identified as one that should be preserved.\n    \"\"\"\n    for row in range(1, image_shape[0]):\n        for col in range(1, image_shape[1]):\n            if destination[row, col] == weak:\n                if 255 in (\n                    destination[row, col + 1],\n                    destination[row, col - 1],\n                    destination[row - 1, col],\n                    destination[row + 1, col],\n                    destination[row - 1, col - 1],\n                    destination[row + 1, col - 1],\n                    destination[row - 1, col + 1],\n                    destination[row + 1, col + 1],\n                ):\n                    destination[row, col] = strong\n                else:\n                    destination[row, col] = 0",
    "docstring": "Edge tracking. Usually a weak edge pixel caused from true edges will be connected\nto a strong edge pixel while noise responses are unconnected. As long as there is\none strong edge pixel that is involved in its 8-connected neighborhood, that weak\nedge point can be identified as one that should be preserved."
  },
  {
    "function": "gabor_filter_kernel",
    "code": "def gabor_filter_kernel(\n    ksize: int, sigma: int, theta: int, lambd: int, gamma: int, psi: int\n) -> np.ndarray:\n    \"\"\"\n    :param ksize:   The kernelsize of the convolutional filter (ksize x ksize)\n    :param sigma:   standard deviation of the gaussian bell curve\n    :param theta:   The orientation of the normal to the parallel stripes\n                    of Gabor function.\n    :param lambd:   Wavelength of the sinusoidal component.\n    :param gamma:   The spatial aspect ratio and specifies the ellipticity\n                    of the support of Gabor function.\n    :param psi:     The phase offset of the sinusoidal function.\n\n    >>> gabor_filter_kernel(3, 8, 0, 10, 0, 0).tolist()\n    [[0.8027212023735046, 1.0, 0.8027212023735046], [0.8027212023735046, 1.0, \\\n0.8027212023735046], [0.8027212023735046, 1.0, 0.8027212023735046]]\n\n    \"\"\"\n\n    # prepare kernel\n    # the kernel size have to be odd\n    if (ksize % 2) == 0:\n        ksize = ksize + 1\n    gabor = np.zeros((ksize, ksize), dtype=np.float32)\n\n    # each value\n    for y in range(ksize):\n        for x in range(ksize):\n            # distance from center\n            px = x - ksize // 2\n            py = y - ksize // 2\n\n            # degree to radiant\n            _theta = theta / 180 * np.pi\n            cos_theta = np.cos(_theta)\n            sin_theta = np.sin(_theta)\n\n            # get kernel x\n            _x = cos_theta * px + sin_theta * py\n\n            # get kernel y\n            _y = -sin_theta * px + cos_theta * py\n\n            # fill kernel\n            gabor[y, x] = np.exp(-(_x**2 + gamma**2 * _y**2) / (2 * sigma**2)) * np.cos(\n                2 * np.pi * _x / lambd + psi\n            )\n\n    return gabor",
    "docstring": ":param ksize:   The kernelsize of the convolutional filter (ksize x ksize)\n:param sigma:   standard deviation of the gaussian bell curve\n:param theta:   The orientation of the normal to the parallel stripes\n                of Gabor function.\n:param lambd:   Wavelength of the sinusoidal component.\n:param gamma:   The spatial aspect ratio and specifies the ellipticity\n                of the support of Gabor function.\n:param psi:     The phase offset of the sinusoidal function.\n\n>>> gabor_filter_kernel(3, 8, 0, 10, 0, 0).tolist()\n[[0.8027212023735046, 1.0, 0.8027212023735046], [0.8027212023735046, 1.0, 0.8027212023735046], [0.8027212023735046, 1.0, 0.8027212023735046]]"
  },
  {
    "function": "my_laplacian",
    "code": "def my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:\n    \"\"\"\n    :param src: the source image, which should be a grayscale or color image.\n    :param ksize: the size of the kernel used to compute the Laplacian filter,\n                  which can be 1, 3, 5, or 7.\n\n    >>> my_laplacian(src=np.array([]), ksize=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: ksize must be in (1, 3, 5, 7)\n    \"\"\"\n    kernels = {\n        1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),\n        3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),\n        5: np.array(\n            [\n                [0, 0, -1, 0, 0],\n                [0, -1, -2, -1, 0],\n                [-1, -2, 16, -2, -1],\n                [0, -1, -2, -1, 0],\n                [0, 0, -1, 0, 0],\n            ]\n        ),\n        7: np.array(\n            [\n                [0, 0, 0, -1, 0, 0, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, -2, -7, -10, -7, -2, 0],\n                [-1, -3, -10, 68, -10, -3, -1],\n                [0, -2, -7, -10, -7, -2, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, 0, 0, -1, 0, 0, 0],\n            ]\n        ),\n    }\n    if ksize not in kernels:\n        msg = f\"ksize must be in {tuple(kernels)}\"\n        raise ValueError(msg)\n\n    # Apply the Laplacian kernel using convolution\n    return filter2D(\n        src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)\n    )",
    "docstring": ":param src: the source image, which should be a grayscale or color image.\n:param ksize: the size of the kernel used to compute the Laplacian filter,\n              which can be 1, 3, 5, or 7.\n\n>>> my_laplacian(src=np.array([]), ksize=0)\nTraceback (most recent call last):\n    ...\nValueError: ksize must be in (1, 3, 5, 7)"
  },
  {
    "function": "get_neighbors_pixel",
    "code": "def get_neighbors_pixel(\n    image: np.ndarray, x_coordinate: int, y_coordinate: int, center: int\n) -> int:\n    \"\"\"\n    Comparing local neighborhood pixel value with threshold value of centre pixel.\n    Exception is required when neighborhood value of a center pixel value is null.\n    i.e. values present at boundaries.\n\n    :param image: The image we're working with\n    :param x_coordinate: x-coordinate of the  pixel\n    :param y_coordinate: The y coordinate of the pixel\n    :param center: center pixel value\n    :return: The value of the pixel is being returned.\n    \"\"\"\n\n    try:\n        return int(image[x_coordinate][y_coordinate] >= center)\n    except (IndexError, TypeError):\n        return 0",
    "docstring": "Comparing local neighborhood pixel value with threshold value of centre pixel.\nException is required when neighborhood value of a center pixel value is null.\ni.e. values present at boundaries.\n\n:param image: The image we're working with\n:param x_coordinate: x-coordinate of the  pixel\n:param y_coordinate: The y coordinate of the pixel\n:param center: center pixel value\n:return: The value of the pixel is being returned."
  },
  {
    "function": "local_binary_value",
    "code": "def local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:\n    \"\"\"\n    It takes an image, an x and y coordinate, and returns the\n    decimal value of the local binary patternof the pixel\n    at that coordinate\n\n    :param image: the image to be processed\n    :param x_coordinate: x coordinate of the pixel\n    :param y_coordinate: the y coordinate of the pixel\n    :return: The decimal value of the binary value of the pixels\n    around the center pixel.\n    \"\"\"\n    center = image[x_coordinate][y_coordinate]\n    powers = [1, 2, 4, 8, 16, 32, 64, 128]\n\n    # skip get_neighbors_pixel if center is null\n    if center is None:\n        return 0\n\n    # Starting from the top right, assigning value to pixels clockwise\n    binary_values = [\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),\n        get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),\n    ]\n\n    # Converting the binary value to decimal.\n    return sum(\n        binary_value * power for binary_value, power in zip(binary_values, powers)\n    )",
    "docstring": "It takes an image, an x and y coordinate, and returns the\ndecimal value of the local binary patternof the pixel\nat that coordinate\n\n:param image: the image to be processed\n:param x_coordinate: x coordinate of the pixel\n:param y_coordinate: the y coordinate of the pixel\n:return: The decimal value of the binary value of the pixels\naround the center pixel."
  },
  {
    "function": "median_filter",
    "code": "def median_filter(gray_img, mask=3):\n    \"\"\"\n    :param gray_img: gray image\n    :param mask: mask size\n    :return: image with median filter\n    \"\"\"\n    # set image borders\n    bd = int(mask / 2)\n    # copy image size\n    median_img = zeros_like(gray_img)\n    for i in range(bd, gray_img.shape[0] - bd):\n        for j in range(bd, gray_img.shape[1] - bd):\n            # get mask according with mask\n            kernel = ravel(gray_img[i - bd : i + bd + 1, j - bd : j + bd + 1])\n            # calculate mask median\n            median = sort(kernel)[int8(divide((multiply(mask, mask)), 2) + 1)]\n            median_img[i, j] = median\n    return median_img",
    "docstring": ":param gray_img: gray image\n:param mask: mask size\n:return: image with median filter"
  },
  {
    "function": "rgb_to_gray",
    "code": "def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return gray image from rgb image\n    >>> rgb_to_gray(np.array([[[127, 255, 0]]]))\n    array([[187.6453]])\n    >>> rgb_to_gray(np.array([[[0, 0, 0]]]))\n    array([[0.]])\n    >>> rgb_to_gray(np.array([[[2, 4, 1]]]))\n    array([[3.0598]])\n    >>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]]))\n    array([[159.0524,  90.0635, 117.6989]])\n    \"\"\"\n    r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]\n    return 0.2989 * r + 0.5870 * g + 0.1140 * b",
    "docstring": "Return gray image from rgb image\n>>> rgb_to_gray(np.array([[[127, 255, 0]]]))\narray([[187.6453]])\n>>> rgb_to_gray(np.array([[[0, 0, 0]]]))\narray([[0.]])\n>>> rgb_to_gray(np.array([[[2, 4, 1]]]))\narray([[3.0598]])\n>>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]]))\narray([[159.0524,  90.0635, 117.6989]])"
  },
  {
    "function": "gray_to_binary",
    "code": "def gray_to_binary(gray: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return binary image from gray image\n    >>> gray_to_binary(np.array([[127, 255, 0]]))\n    array([[False,  True, False]])\n    >>> gray_to_binary(np.array([[0]]))\n    array([[False]])\n    >>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]]))\n    array([[False, False, False]])\n    >>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]]))\n    array([[False,  True, False],\n           [False,  True, False],\n           [False,  True, False]])\n    \"\"\"\n    return (gray > 127) & (gray <= 255)",
    "docstring": "Return binary image from gray image\n>>> gray_to_binary(np.array([[127, 255, 0]]))\narray([[False,  True, False]])\n>>> gray_to_binary(np.array([[0]]))\narray([[False]])\n>>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]]))\narray([[False, False, False]])\n>>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]]))\narray([[False,  True, False],\n       [False,  True, False],\n       [False,  True, False]])"
  },
  {
    "function": "dilation",
    "code": "def dilation(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return dilated image\n    >>> dilation(np.array([[True, False, True]]), np.array([[0, 1, 0]]))\n    array([[False, False, False]])\n    >>> dilation(np.array([[False, False, True]]), np.array([[1, 0, 1]]))\n    array([[False, False, False]])\n    \"\"\"\n    output = np.zeros_like(image)\n    image_padded = np.zeros(\n        (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)\n    )\n\n    # Copy image to padded image\n    image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image\n\n    # Iterate over image & apply kernel\n    for x in range(image.shape[1]):\n        for y in range(image.shape[0]):\n            summation = (\n                kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]\n            ).sum()\n            output[y, x] = int(summation > 0)\n    return output",
    "docstring": "Return dilated image\n>>> dilation(np.array([[True, False, True]]), np.array([[0, 1, 0]]))\narray([[False, False, False]])\n>>> dilation(np.array([[False, False, True]]), np.array([[1, 0, 1]]))\narray([[False, False, False]])"
  },
  {
    "function": "rgb_to_gray",
    "code": "def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return gray image from rgb image\n\n    >>> rgb_to_gray(np.array([[[127, 255, 0]]]))\n    array([[187.6453]])\n    >>> rgb_to_gray(np.array([[[0, 0, 0]]]))\n    array([[0.]])\n    >>> rgb_to_gray(np.array([[[2, 4, 1]]]))\n    array([[3.0598]])\n    >>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]]))\n    array([[159.0524,  90.0635, 117.6989]])\n    \"\"\"\n    r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]\n    return 0.2989 * r + 0.5870 * g + 0.1140 * b",
    "docstring": "Return gray image from rgb image\n\n>>> rgb_to_gray(np.array([[[127, 255, 0]]]))\narray([[187.6453]])\n>>> rgb_to_gray(np.array([[[0, 0, 0]]]))\narray([[0.]])\n>>> rgb_to_gray(np.array([[[2, 4, 1]]]))\narray([[3.0598]])\n>>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]]))\narray([[159.0524,  90.0635, 117.6989]])"
  },
  {
    "function": "gray_to_binary",
    "code": "def gray_to_binary(gray: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return binary image from gray image\n\n    >>> gray_to_binary(np.array([[127, 255, 0]]))\n    array([[False,  True, False]])\n    >>> gray_to_binary(np.array([[0]]))\n    array([[False]])\n    >>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]]))\n    array([[False, False, False]])\n    >>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]]))\n    array([[False,  True, False],\n           [False,  True, False],\n           [False,  True, False]])\n    \"\"\"\n    return (gray > 127) & (gray <= 255)",
    "docstring": "Return binary image from gray image\n\n>>> gray_to_binary(np.array([[127, 255, 0]]))\narray([[False,  True, False]])\n>>> gray_to_binary(np.array([[0]]))\narray([[False]])\n>>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]]))\narray([[False, False, False]])\n>>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]]))\narray([[False,  True, False],\n       [False,  True, False],\n       [False,  True, False]])"
  },
  {
    "function": "erosion",
    "code": "def erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return eroded image\n\n    >>> erosion(np.array([[True, True, False]]), np.array([[0, 1, 0]]))\n    array([[False, False, False]])\n    >>> erosion(np.array([[True, False, False]]), np.array([[1, 1, 0]]))\n    array([[False, False, False]])\n    \"\"\"\n    output = np.zeros_like(image)\n    image_padded = np.zeros(\n        (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)\n    )\n\n    # Copy image to padded image\n    image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image\n\n    # Iterate over image & apply kernel\n    for x in range(image.shape[1]):\n        for y in range(image.shape[0]):\n            summation = (\n                kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]\n            ).sum()\n            output[y, x] = int(summation == 5)\n    return output",
    "docstring": "Return eroded image\n\n>>> erosion(np.array([[True, True, False]]), np.array([[0, 1, 0]]))\narray([[False, False, False]])\n>>> erosion(np.array([[True, False, False]]), np.array([[1, 1, 0]]))\narray([[False, False, False]])"
  },
  {
    "function": "get_rotation",
    "code": "def get_rotation(\n    img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int\n) -> np.ndarray:\n    \"\"\"\n    Get image rotation\n    :param img: np.ndarray\n    :param pt1: 3x2 list\n    :param pt2: 3x2 list\n    :param rows: columns image shape\n    :param cols: rows image shape\n    :return: np.ndarray\n    \"\"\"\n    matrix = cv2.getAffineTransform(pt1, pt2)\n    return cv2.warpAffine(img, matrix, (rows, cols))",
    "docstring": "Get image rotation\n:param img: np.ndarray\n:param pt1: 3x2 list\n:param pt2: 3x2 list\n:param rows: columns image shape\n:param cols: rows image shape\n:return: np.ndarray"
  },
  {
    "function": "euclidean_distance_sqr",
    "code": "def euclidean_distance_sqr(point1, point2):\n    \"\"\"\n    >>> euclidean_distance_sqr([1,2],[2,4])\n    5\n    \"\"\"\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2",
    "docstring": ">>> euclidean_distance_sqr([1,2],[2,4])\n5"
  },
  {
    "function": "column_based_sort",
    "code": "def column_based_sort(array, column=0):\n    \"\"\"\n    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\n    [(3, 0), (5, 1), (4, 2)]\n    \"\"\"\n    return sorted(array, key=lambda x: x[column])",
    "docstring": ">>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\n[(3, 0), (5, 1), (4, 2)]"
  },
  {
    "function": "dis_between_closest_pair",
    "code": "def dis_between_closest_pair(points, points_counts, min_dis=float(\"inf\")):\n    \"\"\"\n    brute force approach to find distance between closest pair points\n\n    Parameters :\n    points, points_count, min_dis (list(tuple(int, int)), int, int)\n\n    Returns :\n    min_dis (float):  distance between closest pair of points\n\n    >>> dis_between_closest_pair([[1,2],[2,4],[5,7],[8,9],[11,0]],5)\n    5\n\n    \"\"\"\n\n    for i in range(points_counts - 1):\n        for j in range(i + 1, points_counts):\n            current_dis = euclidean_distance_sqr(points[i], points[j])\n            min_dis = min(min_dis, current_dis)\n    return min_dis",
    "docstring": "brute force approach to find distance between closest pair points\n\nParameters :\npoints, points_count, min_dis (list(tuple(int, int)), int, int)\n\nReturns :\nmin_dis (float):  distance between closest pair of points\n\n>>> dis_between_closest_pair([[1,2],[2,4],[5,7],[8,9],[11,0]],5)\n5"
  },
  {
    "function": "dis_between_closest_in_strip",
    "code": "def dis_between_closest_in_strip(points, points_counts, min_dis=float(\"inf\")):\n    \"\"\"\n    closest pair of points in strip\n\n    Parameters :\n    points, points_count, min_dis (list(tuple(int, int)), int, int)\n\n    Returns :\n    min_dis (float):  distance btw closest pair of points in the strip (< min_dis)\n\n    >>> dis_between_closest_in_strip([[1,2],[2,4],[5,7],[8,9],[11,0]],5)\n    85\n    \"\"\"\n\n    for i in range(min(6, points_counts - 1), points_counts):\n        for j in range(max(0, i - 6), i):\n            current_dis = euclidean_distance_sqr(points[i], points[j])\n            min_dis = min(min_dis, current_dis)\n    return min_dis",
    "docstring": "closest pair of points in strip\n\nParameters :\npoints, points_count, min_dis (list(tuple(int, int)), int, int)\n\nReturns :\nmin_dis (float):  distance btw closest pair of points in the strip (< min_dis)\n\n>>> dis_between_closest_in_strip([[1,2],[2,4],[5,7],[8,9],[11,0]],5)\n85"
  },
  {
    "function": "closest_pair_of_points_sqr",
    "code": "def closest_pair_of_points_sqr(points_sorted_on_x, points_sorted_on_y, points_counts):\n    \"\"\"divide and conquer approach\n\n    Parameters :\n    points, points_count (list(tuple(int, int)), int)\n\n    Returns :\n    (float):  distance btw closest pair of points\n\n    >>> closest_pair_of_points_sqr([(1, 2), (3, 4)], [(5, 6), (7, 8)], 2)\n    8\n    \"\"\"\n\n    # base case\n    if points_counts <= 3:\n        return dis_between_closest_pair(points_sorted_on_x, points_counts)\n\n    # recursion\n    mid = points_counts // 2\n    closest_in_left = closest_pair_of_points_sqr(\n        points_sorted_on_x, points_sorted_on_y[:mid], mid\n    )\n    closest_in_right = closest_pair_of_points_sqr(\n        points_sorted_on_y, points_sorted_on_y[mid:], points_counts - mid\n    )\n    closest_pair_dis = min(closest_in_left, closest_in_right)\n\n    \"\"\"\n    cross_strip contains the points, whose Xcoords are at a\n    distance(< closest_pair_dis) from mid's Xcoord\n    \"\"\"\n\n    cross_strip = []\n    for point in points_sorted_on_x:\n        if abs(point[0] - points_sorted_on_x[mid][0]) < closest_pair_dis:\n            cross_strip.append(point)\n\n    closest_in_strip = dis_between_closest_in_strip(\n        cross_strip, len(cross_strip), closest_pair_dis\n    )\n    return min(closest_pair_dis, closest_in_strip)",
    "docstring": "divide and conquer approach\n\nParameters :\npoints, points_count (list(tuple(int, int)), int)\n\nReturns :\n(float):  distance btw closest pair of points\n\n>>> closest_pair_of_points_sqr([(1, 2), (3, 4)], [(5, 6), (7, 8)], 2)\n8"
  },
  {
    "function": "closest_pair_of_points",
    "code": "def closest_pair_of_points(points, points_counts):\n    \"\"\"\n    >>> closest_pair_of_points([(2, 3), (12, 30)], len([(2, 3), (12, 30)]))\n    28.792360097775937\n    \"\"\"\n    points_sorted_on_x = column_based_sort(points, column=0)\n    points_sorted_on_y = column_based_sort(points, column=1)\n    return (\n        closest_pair_of_points_sqr(\n            points_sorted_on_x, points_sorted_on_y, points_counts\n        )\n    ) ** 0.5",
    "docstring": ">>> closest_pair_of_points([(2, 3), (12, 30)], len([(2, 3), (12, 30)]))\n28.792360097775937"
  },
  {
    "function": "_construct_points",
    "code": "def _construct_points(\n    list_of_tuples: list[Point] | list[list[float]] | Iterable[list[float]],\n) -> list[Point]:\n    \"\"\"\n    constructs a list of points from an array-like object of numbers\n\n    Arguments\n    ---------\n\n    list_of_tuples: array-like object of type numbers. Acceptable types so far\n    are lists, tuples and sets.\n\n    Returns\n    --------\n    points: a list where each item is of type Point. This contains only objects\n    which can be converted into a Point.\n\n    Examples\n    -------\n    >>> _construct_points([[1, 1], [2, -1], [0.3, 4]])\n    [(1.0, 1.0), (2.0, -1.0), (0.3, 4.0)]\n    >>> _construct_points([1, 2])\n    Ignoring deformed point 1. All points must have at least 2 coordinates.\n    Ignoring deformed point 2. All points must have at least 2 coordinates.\n    []\n    >>> _construct_points([])\n    []\n    >>> _construct_points(None)\n    []\n    \"\"\"\n\n    points: list[Point] = []\n    if list_of_tuples:\n        for p in list_of_tuples:\n            if isinstance(p, Point):\n                points.append(p)\n            else:\n                try:\n                    points.append(Point(p[0], p[1]))\n                except (IndexError, TypeError):\n                    print(\n                        f\"Ignoring deformed point {p}. All points\"\n                        \" must have at least 2 coordinates.\"\n                    )\n    return points",
    "docstring": "constructs a list of points from an array-like object of numbers\n\nArguments\n---------\n\nlist_of_tuples: array-like object of type numbers. Acceptable types so far\nare lists, tuples and sets.\n\nReturns\n--------\npoints: a list where each item is of type Point. This contains only objects\nwhich can be converted into a Point.\n\nExamples\n-------\n>>> _construct_points([[1, 1], [2, -1], [0.3, 4]])\n[(1.0, 1.0), (2.0, -1.0), (0.3, 4.0)]\n>>> _construct_points([1, 2])\nIgnoring deformed point 1. All points must have at least 2 coordinates.\nIgnoring deformed point 2. All points must have at least 2 coordinates.\n[]\n>>> _construct_points([])\n[]\n>>> _construct_points(None)\n[]"
  },
  {
    "function": "_validate_input",
    "code": "def _validate_input(points: list[Point] | list[list[float]]) -> list[Point]:\n    \"\"\"\n    validates an input instance before a convex-hull algorithms uses it\n\n    Parameters\n    ---------\n    points: array-like, the 2d points to validate before using with\n    a convex-hull algorithm. The elements of points must be either lists, tuples or\n    Points.\n\n    Returns\n    -------\n    points: array_like, an iterable of all well-defined Points constructed passed in.\n\n\n    Exception\n    ---------\n    ValueError: if points is empty or None, or if a wrong data structure like a scalar\n                 is passed\n\n    TypeError: if an iterable but non-indexable object (eg. dictionary) is passed.\n                The exception to this a set which we'll convert to a list before using\n\n\n    Examples\n    -------\n    >>> _validate_input([[1, 2]])\n    [(1.0, 2.0)]\n    >>> _validate_input([(1, 2)])\n    [(1.0, 2.0)]\n    >>> _validate_input([Point(2, 1), Point(-1, 2)])\n    [(2.0, 1.0), (-1.0, 2.0)]\n    >>> _validate_input([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Expecting a list of points but got []\n    >>> _validate_input(1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Expecting an iterable object but got an non-iterable type 1\n    \"\"\"\n\n    if not hasattr(points, \"__iter__\"):\n        msg = f\"Expecting an iterable object but got an non-iterable type {points}\"\n        raise ValueError(msg)\n\n    if not points:\n        msg = f\"Expecting a list of points but got {points}\"\n        raise ValueError(msg)\n\n    return _construct_points(points)",
    "docstring": "validates an input instance before a convex-hull algorithms uses it\n\nParameters\n---------\npoints: array-like, the 2d points to validate before using with\na convex-hull algorithm. The elements of points must be either lists, tuples or\nPoints.\n\nReturns\n-------\npoints: array_like, an iterable of all well-defined Points constructed passed in.\n\n\nException\n---------\nValueError: if points is empty or None, or if a wrong data structure like a scalar\n             is passed\n\nTypeError: if an iterable but non-indexable object (eg. dictionary) is passed.\n            The exception to this a set which we'll convert to a list before using\n\n\nExamples\n-------\n>>> _validate_input([[1, 2]])\n[(1.0, 2.0)]\n>>> _validate_input([(1, 2)])\n[(1.0, 2.0)]\n>>> _validate_input([Point(2, 1), Point(-1, 2)])\n[(2.0, 1.0), (-1.0, 2.0)]\n>>> _validate_input([])\nTraceback (most recent call last):\n    ...\nValueError: Expecting a list of points but got []\n>>> _validate_input(1)\nTraceback (most recent call last):\n    ...\nValueError: Expecting an iterable object but got an non-iterable type 1"
  },
  {
    "function": "_det",
    "code": "def _det(a: Point, b: Point, c: Point) -> float:\n    \"\"\"\n    Computes the sign perpendicular distance of a 2d point c from a line segment\n    ab. The sign indicates the direction of c relative to ab.\n    A Positive value means c is above ab (to the left), while a negative value\n    means c is below ab (to the right). 0 means all three points are on a straight line.\n\n    As a side note, 0.5 * abs|det| is the area of triangle abc\n\n    Parameters\n    ----------\n    a: point, the point on the left end of line segment ab\n    b: point, the point on the right end of line segment ab\n    c: point, the point for which the direction and location is desired.\n\n    Returns\n    --------\n    det: float, abs(det) is the distance of c from ab. The sign\n    indicates which side of line segment ab c is. det is computed as\n    (a_xb_y + c_xa_y + b_xc_y) - (a_yb_x + c_ya_x + b_yc_x)\n\n    Examples\n    ----------\n    >>> _det(Point(1, 1), Point(1, 2), Point(1, 5))\n    0.0\n    >>> _det(Point(0, 0), Point(10, 0), Point(0, 10))\n    100.0\n    >>> _det(Point(0, 0), Point(10, 0), Point(0, -10))\n    -100.0\n    \"\"\"\n\n    det = (a.x * b.y + b.x * c.y + c.x * a.y) - (a.y * b.x + b.y * c.x + c.y * a.x)\n    return det",
    "docstring": "Computes the sign perpendicular distance of a 2d point c from a line segment\nab. The sign indicates the direction of c relative to ab.\nA Positive value means c is above ab (to the left), while a negative value\nmeans c is below ab (to the right). 0 means all three points are on a straight line.\n\nAs a side note, 0.5 * abs|det| is the area of triangle abc\n\nParameters\n----------\na: point, the point on the left end of line segment ab\nb: point, the point on the right end of line segment ab\nc: point, the point for which the direction and location is desired.\n\nReturns\n--------\ndet: float, abs(det) is the distance of c from ab. The sign\nindicates which side of line segment ab c is. det is computed as\n(a_xb_y + c_xa_y + b_xc_y) - (a_yb_x + c_ya_x + b_yc_x)\n\nExamples\n----------\n>>> _det(Point(1, 1), Point(1, 2), Point(1, 5))\n0.0\n>>> _det(Point(0, 0), Point(10, 0), Point(0, 10))\n100.0\n>>> _det(Point(0, 0), Point(10, 0), Point(0, -10))\n-100.0"
  },
  {
    "function": "convex_hull_bf",
    "code": "def convex_hull_bf(points: list[Point]) -> list[Point]:\n    \"\"\"\n    Constructs the convex hull of a set of 2D points using a brute force algorithm.\n    The algorithm basically considers all combinations of points (i, j) and uses the\n    definition of convexity to determine whether (i, j) is part of the convex hull or\n    not.  (i, j) is part of the convex hull if and only iff there are no points on both\n    sides of the line segment connecting the ij, and there is no point k such that k is\n    on either end of the ij.\n\n    Runtime: O(n^3) - definitely horrible\n\n    Parameters\n    ---------\n    points: array-like of object of Points, lists or tuples.\n    The set of  2d points for which the convex-hull is needed\n\n    Returns\n    ------\n    convex_set: list, the convex-hull of points sorted in non-decreasing order.\n\n    See Also\n    --------\n    convex_hull_recursive,\n\n     Examples\n     ---------\n     >>> convex_hull_bf([[0, 0], [1, 0], [10, 1]])\n     [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\n     >>> convex_hull_bf([[0, 0], [1, 0], [10, 0]])\n     [(0.0, 0.0), (10.0, 0.0)]\n     >>> convex_hull_bf([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\n     ...                 [-0.75, 1]])\n     [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n     >>> convex_hull_bf([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\n     ...                 (2, -1), (2, -4), (1, -3)])\n     [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]\n    \"\"\"\n\n    points = sorted(_validate_input(points))\n    n = len(points)\n    convex_set = set()\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            points_left_of_ij = points_right_of_ij = False\n            ij_part_of_convex_hull = True\n            for k in range(n):\n                if k not in {i, j}:\n                    det_k = _det(points[i], points[j], points[k])\n\n                    if det_k > 0:\n                        points_left_of_ij = True\n                    elif det_k < 0:\n                        points_right_of_ij = True\n                    # point[i], point[j], point[k] all lie on a straight line\n                    # if point[k] is to the left of point[i] or it's to the\n                    # right of point[j], then point[i], point[j] cannot be\n                    # part of the convex hull of A\n                    elif points[k] < points[i] or points[k] > points[j]:\n                        ij_part_of_convex_hull = False\n                        break\n\n                if points_left_of_ij and points_right_of_ij:\n                    ij_part_of_convex_hull = False\n                    break\n\n            if ij_part_of_convex_hull:\n                convex_set.update([points[i], points[j]])\n\n    return sorted(convex_set)",
    "docstring": "Constructs the convex hull of a set of 2D points using a brute force algorithm.\nThe algorithm basically considers all combinations of points (i, j) and uses the\ndefinition of convexity to determine whether (i, j) is part of the convex hull or\nnot.  (i, j) is part of the convex hull if and only iff there are no points on both\nsides of the line segment connecting the ij, and there is no point k such that k is\non either end of the ij.\n\nRuntime: O(n^3) - definitely horrible\n\nParameters\n---------\npoints: array-like of object of Points, lists or tuples.\nThe set of  2d points for which the convex-hull is needed\n\nReturns\n------\nconvex_set: list, the convex-hull of points sorted in non-decreasing order.\n\nSee Also\n--------\nconvex_hull_recursive,\n\n Examples\n ---------\n >>> convex_hull_bf([[0, 0], [1, 0], [10, 1]])\n [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\n >>> convex_hull_bf([[0, 0], [1, 0], [10, 0]])\n [(0.0, 0.0), (10.0, 0.0)]\n >>> convex_hull_bf([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\n ...                 [-0.75, 1]])\n [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n >>> convex_hull_bf([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\n ...                 (2, -1), (2, -4), (1, -3)])\n [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]"
  },
  {
    "function": "convex_hull_recursive",
    "code": "def convex_hull_recursive(points: list[Point]) -> list[Point]:\n    \"\"\"\n    Constructs the convex hull of a set of 2D points using a divide-and-conquer strategy\n    The algorithm exploits the geometric properties of the problem by repeatedly\n    partitioning the set of points into smaller hulls, and finding the convex hull of\n    these smaller hulls.  The union of the convex hull from smaller hulls is the\n    solution to the convex hull of the larger problem.\n\n    Parameter\n    ---------\n    points: array-like of object of Points, lists or tuples.\n    The set of  2d points for which the convex-hull is needed\n\n    Runtime: O(n log n)\n\n    Returns\n    -------\n    convex_set: list, the convex-hull of points sorted in non-decreasing order.\n\n    Examples\n    ---------\n    >>> convex_hull_recursive([[0, 0], [1, 0], [10, 1]])\n    [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\n    >>> convex_hull_recursive([[0, 0], [1, 0], [10, 0]])\n    [(0.0, 0.0), (10.0, 0.0)]\n    >>> convex_hull_recursive([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\n    ...                        [-0.75, 1]])\n    [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n    >>> convex_hull_recursive([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\n    ...                        (2, -1), (2, -4), (1, -3)])\n    [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]\n\n    \"\"\"\n    points = sorted(_validate_input(points))\n    n = len(points)\n\n    # divide all the points into an upper hull and a lower hull\n    # the left most point and the right most point are definitely\n    # members of the convex hull by definition.\n    # use these two anchors to divide all the points into two hulls,\n    # an upper hull and a lower hull.\n\n    # all points to the left (above) the line joining the extreme points belong to the\n    # upper hull\n    # all points to the right (below) the line joining the extreme points below to the\n    # lower hull\n    # ignore all points on the line joining the extreme points since they cannot be\n    # part of the convex hull\n\n    left_most_point = points[0]\n    right_most_point = points[n - 1]\n\n    convex_set = {left_most_point, right_most_point}\n    upper_hull = []\n    lower_hull = []\n\n    for i in range(1, n - 1):\n        det = _det(left_most_point, right_most_point, points[i])\n\n        if det > 0:\n            upper_hull.append(points[i])\n        elif det < 0:\n            lower_hull.append(points[i])\n\n    _construct_hull(upper_hull, left_most_point, right_most_point, convex_set)\n    _construct_hull(lower_hull, right_most_point, left_most_point, convex_set)\n\n    return sorted(convex_set)",
    "docstring": "Constructs the convex hull of a set of 2D points using a divide-and-conquer strategy\nThe algorithm exploits the geometric properties of the problem by repeatedly\npartitioning the set of points into smaller hulls, and finding the convex hull of\nthese smaller hulls.  The union of the convex hull from smaller hulls is the\nsolution to the convex hull of the larger problem.\n\nParameter\n---------\npoints: array-like of object of Points, lists or tuples.\nThe set of  2d points for which the convex-hull is needed\n\nRuntime: O(n log n)\n\nReturns\n-------\nconvex_set: list, the convex-hull of points sorted in non-decreasing order.\n\nExamples\n---------\n>>> convex_hull_recursive([[0, 0], [1, 0], [10, 1]])\n[(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\n>>> convex_hull_recursive([[0, 0], [1, 0], [10, 0]])\n[(0.0, 0.0), (10.0, 0.0)]\n>>> convex_hull_recursive([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\n...                        [-0.75, 1]])\n[(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n>>> convex_hull_recursive([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\n...                        (2, -1), (2, -4), (1, -3)])\n[(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]"
  },
  {
    "function": "_construct_hull",
    "code": "def _construct_hull(\n    points: list[Point], left: Point, right: Point, convex_set: set[Point]\n) -> None:\n    \"\"\"\n\n    Parameters\n    ---------\n    points: list or None, the hull of points from which to choose the next convex-hull\n        point\n    left: Point, the point to the left  of line segment joining left and right\n    right: The point to the right of the line segment joining left and right\n    convex_set: set, the current convex-hull. The state of convex-set gets updated by\n        this function\n\n    Note\n    ----\n    For the line segment 'ab', 'a' is on the left and 'b' on the right.\n    but the reverse is true for the line segment 'ba'.\n\n    Returns\n    -------\n    Nothing, only updates the state of convex-set\n    \"\"\"\n    if points:\n        extreme_point = None\n        extreme_point_distance = float(\"-inf\")\n        candidate_points = []\n\n        for p in points:\n            det = _det(left, right, p)\n\n            if det > 0:\n                candidate_points.append(p)\n\n                if det > extreme_point_distance:\n                    extreme_point_distance = det\n                    extreme_point = p\n\n        if extreme_point:\n            _construct_hull(candidate_points, left, extreme_point, convex_set)\n            convex_set.add(extreme_point)\n            _construct_hull(candidate_points, extreme_point, right, convex_set)",
    "docstring": "Parameters\n---------\npoints: list or None, the hull of points from which to choose the next convex-hull\n    point\nleft: Point, the point to the left  of line segment joining left and right\nright: The point to the right of the line segment joining left and right\nconvex_set: set, the current convex-hull. The state of convex-set gets updated by\n    this function\n\nNote\n----\nFor the line segment 'ab', 'a' is on the left and 'b' on the right.\nbut the reverse is true for the line segment 'ba'.\n\nReturns\n-------\nNothing, only updates the state of convex-set"
  },
  {
    "function": "convex_hull_melkman",
    "code": "def convex_hull_melkman(points: list[Point]) -> list[Point]:\n    \"\"\"\n    Constructs the convex hull of a set of 2D points using the melkman algorithm.\n    The algorithm works by iteratively inserting points of a simple polygonal chain\n    (meaning that no line segments between two consecutive points cross each other).\n    Sorting the points yields such a polygonal chain.\n\n    For a detailed description, see http://cgm.cs.mcgill.ca/~athens/cs601/Melkman.html\n\n    Runtime: O(n log n) - O(n) if points are already sorted in the input\n\n    Parameters\n    ---------\n    points: array-like of object of Points, lists or tuples.\n    The set of 2d points for which the convex-hull is needed\n\n    Returns\n    ------\n    convex_set: list, the convex-hull of points sorted in non-decreasing order.\n\n    See Also\n    --------\n\n    Examples\n    ---------\n    >>> convex_hull_melkman([[0, 0], [1, 0], [10, 1]])\n    [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\n    >>> convex_hull_melkman([[0, 0], [1, 0], [10, 0]])\n    [(0.0, 0.0), (10.0, 0.0)]\n    >>> convex_hull_melkman([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\n    ...                 [-0.75, 1]])\n    [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n    >>> convex_hull_melkman([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\n    ...                 (2, -1), (2, -4), (1, -3)])\n    [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]\n    \"\"\"\n    points = sorted(_validate_input(points))\n    n = len(points)\n\n    convex_hull = points[:2]\n    for i in range(2, n):\n        det = _det(convex_hull[1], convex_hull[0], points[i])\n        if det > 0:\n            convex_hull.insert(0, points[i])\n            break\n        elif det < 0:\n            convex_hull.append(points[i])\n            break\n        else:\n            convex_hull[1] = points[i]\n    i += 1\n\n    for j in range(i, n):\n        if (\n            _det(convex_hull[0], convex_hull[-1], points[j]) > 0\n            and _det(convex_hull[-1], convex_hull[0], points[1]) < 0\n        ):\n            # The point lies within the convex hull\n            continue\n\n        convex_hull.insert(0, points[j])\n        convex_hull.append(points[j])\n        while _det(convex_hull[0], convex_hull[1], convex_hull[2]) >= 0:\n            del convex_hull[1]\n        while _det(convex_hull[-1], convex_hull[-2], convex_hull[-3]) <= 0:\n            del convex_hull[-2]\n\n    # `convex_hull` is contains the convex hull in circular order\n    return sorted(convex_hull[1:] if len(convex_hull) > 3 else convex_hull)",
    "docstring": "Constructs the convex hull of a set of 2D points using the melkman algorithm.\nThe algorithm works by iteratively inserting points of a simple polygonal chain\n(meaning that no line segments between two consecutive points cross each other).\nSorting the points yields such a polygonal chain.\n\nFor a detailed description, see http://cgm.cs.mcgill.ca/~athens/cs601/Melkman.html\n\nRuntime: O(n log n) - O(n) if points are already sorted in the input\n\nParameters\n---------\npoints: array-like of object of Points, lists or tuples.\nThe set of 2d points for which the convex-hull is needed\n\nReturns\n------\nconvex_set: list, the convex-hull of points sorted in non-decreasing order.\n\nSee Also\n--------\n\nExamples\n---------\n>>> convex_hull_melkman([[0, 0], [1, 0], [10, 1]])\n[(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\n>>> convex_hull_melkman([[0, 0], [1, 0], [10, 0]])\n[(0.0, 0.0), (10.0, 0.0)]\n>>> convex_hull_melkman([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\n...                 [-0.75, 1]])\n[(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n>>> convex_hull_melkman([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\n...                 (2, -1), (2, -4), (1, -3)])\n[(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]"
  },
  {
    "function": "heaps",
    "code": "def heaps(arr: list) -> list:\n    \"\"\"\n    Pure python implementation of the Heap's algorithm (recursive version),\n    returning all permutations of a list.\n    >>> heaps([])\n    [()]\n    >>> heaps([0])\n    [(0,)]\n    >>> heaps([-1, 1])\n    [(-1, 1), (1, -1)]\n    >>> heaps([1, 2, 3])\n    [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]\n    >>> from itertools import permutations\n    >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))\n    True\n    >>> all(sorted(heaps(x)) == sorted(permutations(x))\n    ...     for x in ([], [0], [-1, 1], [1, 2, 3]))\n    True\n    \"\"\"\n\n    if len(arr) <= 1:\n        return [tuple(arr)]\n\n    res = []\n\n    def generate(k: int, arr: list):\n        if k == 1:\n            res.append(tuple(arr[:]))\n            return\n\n        generate(k - 1, arr)\n\n        for i in range(k - 1):\n            if k % 2 == 0:  # k is even\n                arr[i], arr[k - 1] = arr[k - 1], arr[i]\n            else:  # k is odd\n                arr[0], arr[k - 1] = arr[k - 1], arr[0]\n            generate(k - 1, arr)\n\n    generate(len(arr), arr)\n    return res",
    "docstring": "Pure python implementation of the Heap's algorithm (recursive version),\nreturning all permutations of a list.\n>>> heaps([])\n[()]\n>>> heaps([0])\n[(0,)]\n>>> heaps([-1, 1])\n[(-1, 1), (1, -1)]\n>>> heaps([1, 2, 3])\n[(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]\n>>> from itertools import permutations\n>>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))\nTrue\n>>> all(sorted(heaps(x)) == sorted(permutations(x))\n...     for x in ([], [0], [-1, 1], [1, 2, 3]))\nTrue"
  },
  {
    "function": "heaps",
    "code": "def heaps(arr: list) -> list:\n    \"\"\"\n    Pure python implementation of the iterative Heap's algorithm,\n    returning all permutations of a list.\n    >>> heaps([])\n    [()]\n    >>> heaps([0])\n    [(0,)]\n    >>> heaps([-1, 1])\n    [(-1, 1), (1, -1)]\n    >>> heaps([1, 2, 3])\n    [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]\n    >>> from itertools import permutations\n    >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))\n    True\n    >>> all(sorted(heaps(x)) == sorted(permutations(x))\n    ...     for x in ([], [0], [-1, 1], [1, 2, 3]))\n    True\n    \"\"\"\n\n    if len(arr) <= 1:\n        return [tuple(arr)]\n\n    res = []\n\n    def generate(n: int, arr: list):\n        c = [0] * n\n        res.append(tuple(arr))\n\n        i = 0\n        while i < n:\n            if c[i] < i:\n                if i % 2 == 0:\n                    arr[0], arr[i] = arr[i], arr[0]\n                else:\n                    arr[c[i]], arr[i] = arr[i], arr[c[i]]\n                res.append(tuple(arr))\n                c[i] += 1\n                i = 0\n            else:\n                c[i] = 0\n                i += 1\n\n    generate(len(arr), arr)\n    return res",
    "docstring": "Pure python implementation of the iterative Heap's algorithm,\nreturning all permutations of a list.\n>>> heaps([])\n[()]\n>>> heaps([0])\n[(0,)]\n>>> heaps([-1, 1])\n[(-1, 1), (1, -1)]\n>>> heaps([1, 2, 3])\n[(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]\n>>> from itertools import permutations\n>>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))\nTrue\n>>> all(sorted(heaps(x)) == sorted(permutations(x))\n...     for x in ([], [0], [-1, 1], [1, 2, 3]))\nTrue"
  },
  {
    "function": "count_inversions_bf",
    "code": "def count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions",
    "docstring": "Counts the number of inversions using a naive brute-force algorithm\nParameters\n----------\narr: arr: array-like, the list containing the items for which the number\nof inversions is desired. The elements of `arr` must be comparable.\nReturns\n-------\nnum_inversions: The total number of inversions in `arr`\nExamples\n---------\n >>> count_inversions_bf([1, 4, 2, 4, 1])\n 4\n >>> count_inversions_bf([1, 1, 2, 4, 4])\n 0\n >>> count_inversions_bf([])\n 0"
  },
  {
    "function": "count_inversions_recursive",
    "code": "def count_inversions_recursive(arr):\n    \"\"\"\n    Counts the number of inversions using a divide-and-conquer algorithm\n    Parameters\n    -----------\n    arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    C: a sorted copy of `arr`.\n    num_inversions: int, the total number of inversions in 'arr'\n    Examples\n    --------\n    >>> count_inversions_recursive([1, 4, 2, 4, 1])\n    ([1, 1, 2, 4, 4], 4)\n    >>> count_inversions_recursive([1, 1, 2, 4, 4])\n    ([1, 1, 2, 4, 4], 0)\n    >>> count_inversions_recursive([])\n    ([], 0)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    p = arr[0:mid]\n    q = arr[mid:]\n\n    a, inversion_p = count_inversions_recursive(p)\n    b, inversions_q = count_inversions_recursive(q)\n    c, cross_inversions = _count_cross_inversions(a, b)\n\n    num_inversions = inversion_p + inversions_q + cross_inversions\n    return c, num_inversions",
    "docstring": "Counts the number of inversions using a divide-and-conquer algorithm\nParameters\n-----------\narr: array-like, the list containing the items for which the number\nof inversions is desired. The elements of `arr` must be comparable.\nReturns\n-------\nC: a sorted copy of `arr`.\nnum_inversions: int, the total number of inversions in 'arr'\nExamples\n--------\n>>> count_inversions_recursive([1, 4, 2, 4, 1])\n([1, 1, 2, 4, 4], 4)\n>>> count_inversions_recursive([1, 1, 2, 4, 4])\n([1, 1, 2, 4, 4], 0)\n>>> count_inversions_recursive([])\n([], 0)"
  },
  {
    "function": "_count_cross_inversions",
    "code": "def _count_cross_inversions(p, q):\n    \"\"\"\n    Counts the inversions across two sorted arrays.\n    And combine the two arrays into one sorted array\n    For all 1<= i<=len(P) and for all 1 <= j <= len(Q),\n    if P[i] > Q[j], then (i, j) is a cross inversion\n    Parameters\n    ----------\n    P: array-like, sorted in non-decreasing order\n    Q: array-like, sorted in non-decreasing order\n    Returns\n    ------\n    R: array-like, a sorted array of the elements of `P` and `Q`\n    num_inversion: int, the number of inversions across `P` and `Q`\n    Examples\n    --------\n    >>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\n    ([0, 1, 2, 2, 3, 5], 4)\n    >>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\n    ([1, 2, 3, 3, 4, 5], 0)\n    \"\"\"\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion",
    "docstring": "Counts the inversions across two sorted arrays.\nAnd combine the two arrays into one sorted array\nFor all 1<= i<=len(P) and for all 1 <= j <= len(Q),\nif P[i] > Q[j], then (i, j) is a cross inversion\nParameters\n----------\nP: array-like, sorted in non-decreasing order\nQ: array-like, sorted in non-decreasing order\nReturns\n------\nR: array-like, a sorted array of the elements of `P` and `Q`\nnum_inversion: int, the number of inversions across `P` and `Q`\nExamples\n--------\n>>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\n([0, 1, 2, 2, 3, 5], 4)\n>>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\n([1, 2, 3, 3, 4, 5], 0)"
  },
  {
    "function": "random_pivot",
    "code": "def random_pivot(lst):\n    \"\"\"\n    Choose a random pivot for the list.\n    We can use a more sophisticated algorithm here, such as the median-of-medians\n    algorithm.\n    \"\"\"\n    return choice(lst)",
    "docstring": "Choose a random pivot for the list.\nWe can use a more sophisticated algorithm here, such as the median-of-medians\nalgorithm."
  },
  {
    "function": "kth_number",
    "code": "def kth_number(lst: list[int], k: int) -> int:\n    \"\"\"\n    Return the kth smallest number in lst.\n    >>> kth_number([2, 1, 3, 4, 5], 3)\n    3\n    >>> kth_number([2, 1, 3, 4, 5], 1)\n    1\n    >>> kth_number([2, 1, 3, 4, 5], 5)\n    5\n    >>> kth_number([3, 2, 5, 6, 7, 8], 2)\n    3\n    >>> kth_number([25, 21, 98, 100, 76, 22, 43, 60, 89, 87], 4)\n    43\n    \"\"\"\n    # pick a pivot and separate into list based on pivot.\n    pivot = random_pivot(lst)\n\n    # partition based on pivot\n    # linear time\n    small = [e for e in lst if e < pivot]\n    big = [e for e in lst if e > pivot]\n\n    # if we get lucky, pivot might be the element we want.\n    # we can easily see this:\n    # small (elements smaller than k)\n    # + pivot (kth element)\n    # + big (elements larger than k)\n    if len(small) == k - 1:\n        return pivot\n    # pivot is in elements bigger than k\n    elif len(small) < k - 1:\n        return kth_number(big, k - len(small) - 1)\n    # pivot is in elements smaller than k\n    else:\n        return kth_number(small, k)",
    "docstring": "Return the kth smallest number in lst.\n>>> kth_number([2, 1, 3, 4, 5], 3)\n3\n>>> kth_number([2, 1, 3, 4, 5], 1)\n1\n>>> kth_number([2, 1, 3, 4, 5], 5)\n5\n>>> kth_number([3, 2, 5, 6, 7, 8], 2)\n3\n>>> kth_number([25, 21, 98, 100, 76, 22, 43, 60, 89, 87], 4)\n43"
  },
  {
    "function": "max_difference",
    "code": "def max_difference(a: list[int]) -> tuple[int, int]:\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second",
    "docstring": "We are given an array A[1..n] of integers, n >= 1. We want to\nfind a pair of indices (i, j) such that\n1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\nExplanation:\nhttps://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n>>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n(1, 9)"
  },
  {
    "function": "max_subarray",
    "code": "def max_subarray(\n    arr: Sequence[float], low: int, high: int\n) -> tuple[int | None, int | None, float]:\n    \"\"\"\n    Solves the maximum subarray problem using divide and conquer.\n    :param arr:     the given array of numbers\n    :param low:     the start index\n    :param high:    the end index\n    :return:        the start index of the maximum subarray, the end index of the\n                    maximum subarray, and the maximum subarray sum\n\n    >>> nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (3, 6, 6)\n    >>> nums = [2, 8, 9]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (0, 2, 19)\n    >>> nums = [0, 0]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (0, 0, 0)\n    >>> nums = [-1.0, 0.0, 1.0]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (2, 2, 1.0)\n    >>> nums = [-2, -3, -1, -4, -6]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (2, 2, -1)\n    >>> max_subarray([], 0, 0)\n    (None, None, 0)\n    \"\"\"\n    if not arr:\n        return None, None, 0\n    if low == high:\n        return low, high, arr[low]\n\n    mid = (low + high) // 2\n    left_low, left_high, left_sum = max_subarray(arr, low, mid)\n    right_low, right_high, right_sum = max_subarray(arr, mid + 1, high)\n    cross_left, cross_right, cross_sum = max_cross_sum(arr, low, mid, high)\n    if left_sum >= right_sum and left_sum >= cross_sum:\n        return left_low, left_high, left_sum\n    elif right_sum >= left_sum and right_sum >= cross_sum:\n        return right_low, right_high, right_sum\n    return cross_left, cross_right, cross_sum",
    "docstring": "Solves the maximum subarray problem using divide and conquer.\n:param arr:     the given array of numbers\n:param low:     the start index\n:param high:    the end index\n:return:        the start index of the maximum subarray, the end index of the\n                maximum subarray, and the maximum subarray sum\n\n>>> nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n>>> max_subarray(nums, 0, len(nums) - 1)\n(3, 6, 6)\n>>> nums = [2, 8, 9]\n>>> max_subarray(nums, 0, len(nums) - 1)\n(0, 2, 19)\n>>> nums = [0, 0]\n>>> max_subarray(nums, 0, len(nums) - 1)\n(0, 0, 0)\n>>> nums = [-1.0, 0.0, 1.0]\n>>> max_subarray(nums, 0, len(nums) - 1)\n(2, 2, 1.0)\n>>> nums = [-2, -3, -1, -4, -6]\n>>> max_subarray(nums, 0, len(nums) - 1)\n(2, 2, -1)\n>>> max_subarray([], 0, 0)\n(None, None, 0)"
  },
  {
    "function": "merge",
    "code": "def merge(left_half: list, right_half: list) -> list:\n    \"\"\"Helper function for mergesort.\n\n    >>> left_half = [-2]\n    >>> right_half = [-1]\n    >>> merge(left_half, right_half)\n    [-2, -1]\n\n    >>> left_half = [1,2,3]\n    >>> right_half = [4,5,6]\n    >>> merge(left_half, right_half)\n    [1, 2, 3, 4, 5, 6]\n\n    >>> left_half = [-2]\n    >>> right_half = [-1]\n    >>> merge(left_half, right_half)\n    [-2, -1]\n\n    >>> left_half = [12, 15]\n    >>> right_half = [13, 14]\n    >>> merge(left_half, right_half)\n    [12, 13, 14, 15]\n\n    >>> left_half = []\n    >>> right_half = []\n    >>> merge(left_half, right_half)\n    []\n    \"\"\"\n    sorted_array = [None] * (len(right_half) + len(left_half))\n\n    pointer1 = 0  # pointer to current index for left Half\n    pointer2 = 0  # pointer to current index for the right Half\n    index = 0  # pointer to current index for the sorted array Half\n\n    while pointer1 < len(left_half) and pointer2 < len(right_half):\n        if left_half[pointer1] < right_half[pointer2]:\n            sorted_array[index] = left_half[pointer1]\n            pointer1 += 1\n            index += 1\n        else:\n            sorted_array[index] = right_half[pointer2]\n            pointer2 += 1\n            index += 1\n    while pointer1 < len(left_half):\n        sorted_array[index] = left_half[pointer1]\n        pointer1 += 1\n        index += 1\n\n    while pointer2 < len(right_half):\n        sorted_array[index] = right_half[pointer2]\n        pointer2 += 1\n        index += 1\n\n    return sorted_array",
    "docstring": "Helper function for mergesort.\n\n>>> left_half = [-2]\n>>> right_half = [-1]\n>>> merge(left_half, right_half)\n[-2, -1]\n\n>>> left_half = [1,2,3]\n>>> right_half = [4,5,6]\n>>> merge(left_half, right_half)\n[1, 2, 3, 4, 5, 6]\n\n>>> left_half = [-2]\n>>> right_half = [-1]\n>>> merge(left_half, right_half)\n[-2, -1]\n\n>>> left_half = [12, 15]\n>>> right_half = [13, 14]\n>>> merge(left_half, right_half)\n[12, 13, 14, 15]\n\n>>> left_half = []\n>>> right_half = []\n>>> merge(left_half, right_half)\n[]"
  },
  {
    "function": "merge_sort",
    "code": "def merge_sort(array: list) -> list:\n    \"\"\"Returns a list of sorted array elements using merge sort.\n\n    >>> from random import shuffle\n    >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]\n    >>> shuffle(array)\n    >>> merge_sort(array)\n    [-200, -10, -2, 3, 11, 99, 100, 100000]\n\n    >>> shuffle(array)\n    >>> merge_sort(array)\n    [-200, -10, -2, 3, 11, 99, 100, 100000]\n\n    >>> array = [-200]\n    >>> merge_sort(array)\n    [-200]\n\n    >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]\n    >>> shuffle(array)\n    >>> sorted(array) == merge_sort(array)\n    True\n\n    >>> array = [-2]\n    >>> merge_sort(array)\n    [-2]\n\n    >>> array = []\n    >>> merge_sort(array)\n    []\n\n    >>> array = [10000000, 1, -1111111111, 101111111112, 9000002]\n    >>> sorted(array) == merge_sort(array)\n    True\n    \"\"\"\n    if len(array) <= 1:\n        return array\n    # the actual formula to calculate the middle element = left + (right - left) // 2\n    # this avoids integer overflow in case of large N\n    middle = 0 + (len(array) - 0) // 2\n\n    # Split the array into halves till the array length becomes equal to One\n    # merge the arrays of single length returned by mergeSort function and\n    # pass them into the merge arrays function which merges the array\n    left_half = array[:middle]\n    right_half = array[middle:]\n\n    return merge(merge_sort(left_half), merge_sort(right_half))",
    "docstring": "Returns a list of sorted array elements using merge sort.\n\n>>> from random import shuffle\n>>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]\n>>> shuffle(array)\n>>> merge_sort(array)\n[-200, -10, -2, 3, 11, 99, 100, 100000]\n\n>>> shuffle(array)\n>>> merge_sort(array)\n[-200, -10, -2, 3, 11, 99, 100, 100000]\n\n>>> array = [-200]\n>>> merge_sort(array)\n[-200]\n\n>>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]\n>>> shuffle(array)\n>>> sorted(array) == merge_sort(array)\nTrue\n\n>>> array = [-2]\n>>> merge_sort(array)\n[-2]\n\n>>> array = []\n>>> merge_sort(array)\n[]\n\n>>> array = [10000000, 1, -1111111111, 101111111112, 9000002]\n>>> sorted(array) == merge_sort(array)\nTrue"
  },
  {
    "function": "peak",
    "code": "def peak(lst: list[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])",
    "docstring": "Return the peak value of `lst`.\n>>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n5\n>>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n10\n>>> peak([1, 9, 8, 7])\n9\n>>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n7\n>>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n4"
  },
  {
    "function": "actual_power",
    "code": "def actual_power(a: int, b: int) -> int:\n    \"\"\"\n    Function using divide and conquer to calculate a^b.\n    It only works for integer a,b.\n\n    :param a: The base of the power operation, an integer.\n    :param b: The exponent of the power operation, a non-negative integer.\n    :return: The result of a^b.\n\n    Examples:\n    >>> actual_power(3, 2)\n    9\n    >>> actual_power(5, 3)\n    125\n    >>> actual_power(2, 5)\n    32\n    >>> actual_power(7, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    half = actual_power(a, b // 2)\n\n    if (b % 2) == 0:\n        return half * half\n    else:\n        return a * half * half",
    "docstring": "Function using divide and conquer to calculate a^b.\nIt only works for integer a,b.\n\n:param a: The base of the power operation, an integer.\n:param b: The exponent of the power operation, a non-negative integer.\n:return: The result of a^b.\n\nExamples:\n>>> actual_power(3, 2)\n9\n>>> actual_power(5, 3)\n125\n>>> actual_power(2, 5)\n32\n>>> actual_power(7, 0)\n1"
  },
  {
    "function": "power",
    "code": "def power(a: int, b: int) -> float:\n    \"\"\"\n    :param a: The base (integer).\n    :param b: The exponent (integer).\n    :return: The result of a^b, as a float for negative exponents.\n\n    >>> power(4,6)\n    4096\n    >>> power(2,3)\n    8\n    >>> power(-2,3)\n    -8\n    >>> power(2,-3)\n    0.125\n    >>> power(-2,-3)\n    -0.125\n    \"\"\"\n    if b < 0:\n        return 1 / actual_power(a, -b)\n    return actual_power(a, b)",
    "docstring": ":param a: The base (integer).\n:param b: The exponent (integer).\n:return: The result of a^b, as a float for negative exponents.\n\n>>> power(4,6)\n4096\n>>> power(2,3)\n8\n>>> power(-2,3)\n-8\n>>> power(2,-3)\n0.125\n>>> power(-2,-3)\n-0.125"
  },
  {
    "function": "default_matrix_multiplication",
    "code": "def default_matrix_multiplication(a: list, b: list) -> list:\n    \"\"\"\n    Multiplication only for 2x2 matrices\n    \"\"\"\n    if len(a) != 2 or len(a[0]) != 2 or len(b) != 2 or len(b[0]) != 2:\n        raise Exception(\"Matrices are not 2x2\")\n    new_matrix = [\n        [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n        [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]],\n    ]\n    return new_matrix",
    "docstring": "Multiplication only for 2x2 matrices"
  },
  {
    "function": "split_matrix",
    "code": "def split_matrix(a: list) -> tuple[list, list, list, list]:\n    \"\"\"\n    Given an even length matrix, returns the top_left, top_right, bot_left, bot_right\n    quadrant.\n\n    >>> split_matrix([[4,3,2,4],[2,3,1,1],[6,5,4,3],[8,4,1,6]])\n    ([[4, 3], [2, 3]], [[2, 4], [1, 1]], [[6, 5], [8, 4]], [[4, 3], [1, 6]])\n    >>> split_matrix([\n    ...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6],\n    ...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6]\n    ... ])  # doctest: +NORMALIZE_WHITESPACE\n    ([[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4],\n      [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1],\n      [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3],\n      [8, 4, 1, 6]])\n    \"\"\"\n    if len(a) % 2 != 0 or len(a[0]) % 2 != 0:\n        raise Exception(\"Odd matrices are not supported!\")\n\n    matrix_length = len(a)\n    mid = matrix_length // 2\n\n    top_right = [[a[i][j] for j in range(mid, matrix_length)] for i in range(mid)]\n    bot_right = [\n        [a[i][j] for j in range(mid, matrix_length)] for i in range(mid, matrix_length)\n    ]\n\n    top_left = [[a[i][j] for j in range(mid)] for i in range(mid)]\n    bot_left = [[a[i][j] for j in range(mid)] for i in range(mid, matrix_length)]\n\n    return top_left, top_right, bot_left, bot_right",
    "docstring": "Given an even length matrix, returns the top_left, top_right, bot_left, bot_right\nquadrant.\n\n>>> split_matrix([[4,3,2,4],[2,3,1,1],[6,5,4,3],[8,4,1,6]])\n([[4, 3], [2, 3]], [[2, 4], [1, 1]], [[6, 5], [8, 4]], [[4, 3], [1, 6]])\n>>> split_matrix([\n...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6],\n...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6]\n... ])  # doctest: +NORMALIZE_WHITESPACE\n([[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4],\n  [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1],\n  [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3],\n  [8, 4, 1, 6]])"
  },
  {
    "function": "actual_strassen",
    "code": "def actual_strassen(matrix_a: list, matrix_b: list) -> list:\n    \"\"\"\n    Recursive function to calculate the product of two matrices, using the Strassen\n    Algorithm. It only supports square matrices of any size that is a power of 2.\n    \"\"\"\n    if matrix_dimensions(matrix_a) == (2, 2):\n        return default_matrix_multiplication(matrix_a, matrix_b)\n\n    a, b, c, d = split_matrix(matrix_a)\n    e, f, g, h = split_matrix(matrix_b)\n\n    t1 = actual_strassen(a, matrix_subtraction(f, h))\n    t2 = actual_strassen(matrix_addition(a, b), h)\n    t3 = actual_strassen(matrix_addition(c, d), e)\n    t4 = actual_strassen(d, matrix_subtraction(g, e))\n    t5 = actual_strassen(matrix_addition(a, d), matrix_addition(e, h))\n    t6 = actual_strassen(matrix_subtraction(b, d), matrix_addition(g, h))\n    t7 = actual_strassen(matrix_subtraction(a, c), matrix_addition(e, f))\n\n    top_left = matrix_addition(matrix_subtraction(matrix_addition(t5, t4), t2), t6)\n    top_right = matrix_addition(t1, t2)\n    bot_left = matrix_addition(t3, t4)\n    bot_right = matrix_subtraction(matrix_subtraction(matrix_addition(t1, t5), t3), t7)\n\n    # construct the new matrix from our 4 quadrants\n    new_matrix = []\n    for i in range(len(top_right)):\n        new_matrix.append(top_left[i] + top_right[i])\n    for i in range(len(bot_right)):\n        new_matrix.append(bot_left[i] + bot_right[i])\n    return new_matrix",
    "docstring": "Recursive function to calculate the product of two matrices, using the Strassen\nAlgorithm. It only supports square matrices of any size that is a power of 2."
  },
  {
    "function": "strassen",
    "code": "def strassen(matrix1: list, matrix2: list) -> list:\n    \"\"\"\n    >>> strassen([[2,1,3],[3,4,6],[1,4,2],[7,6,7]], [[4,2,3,4],[2,1,1,1],[8,6,4,2]])\n    [[34, 23, 19, 15], [68, 46, 37, 28], [28, 18, 15, 12], [96, 62, 55, 48]]\n    >>> strassen([[3,7,5,6,9],[1,5,3,7,8],[1,4,4,5,7]], [[2,4],[5,2],[1,7],[5,5],[7,8]])\n    [[139, 163], [121, 134], [100, 121]]\n    \"\"\"\n    if matrix_dimensions(matrix1)[1] != matrix_dimensions(matrix2)[0]:\n        msg = (\n            \"Unable to multiply these matrices, please check the dimensions.\\n\"\n            f\"Matrix A: {matrix1}\\n\"\n            f\"Matrix B: {matrix2}\"\n        )\n        raise Exception(msg)\n    dimension1 = matrix_dimensions(matrix1)\n    dimension2 = matrix_dimensions(matrix2)\n\n    if dimension1[0] == dimension1[1] and dimension2[0] == dimension2[1]:\n        return [matrix1, matrix2]\n\n    maximum = max(*dimension1, *dimension2)\n    maxim = int(math.pow(2, math.ceil(math.log2(maximum))))\n    new_matrix1 = matrix1\n    new_matrix2 = matrix2\n\n    # Adding zeros to the matrices to convert them both into square matrices of equal\n    # dimensions that are a power of 2\n    for i in range(maxim):\n        if i < dimension1[0]:\n            for _ in range(dimension1[1], maxim):\n                new_matrix1[i].append(0)\n        else:\n            new_matrix1.append([0] * maxim)\n        if i < dimension2[0]:\n            for _ in range(dimension2[1], maxim):\n                new_matrix2[i].append(0)\n        else:\n            new_matrix2.append([0] * maxim)\n\n    final_matrix = actual_strassen(new_matrix1, new_matrix2)\n\n    # Removing the additional zeros\n    for i in range(maxim):\n        if i < dimension1[0]:\n            for _ in range(dimension2[1], maxim):\n                final_matrix[i].pop()\n        else:\n            final_matrix.pop()\n    return final_matrix",
    "docstring": ">>> strassen([[2,1,3],[3,4,6],[1,4,2],[7,6,7]], [[4,2,3,4],[2,1,1,1],[8,6,4,2]])\n[[34, 23, 19, 15], [68, 46, 37, 28], [28, 18, 15, 12], [96, 62, 55, 48]]\n>>> strassen([[3,7,5,6,9],[1,5,3,7,8],[1,4,4,5,7]], [[2,4],[5,2],[1,7],[5,5],[7,8]])\n[[139, 163], [121, 134], [100, 121]]"
  },
  {
    "function": "abbr",
    "code": "def abbr(a: str, b: str) -> bool:\n    \"\"\"\n    >>> abbr(\"daBcd\", \"ABC\")\n    True\n    >>> abbr(\"dBcd\", \"ABC\")\n    False\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m + 1):\n            if dp[i][j]:\n                if j < m and a[i].upper() == b[j]:\n                    dp[i + 1][j + 1] = True\n                if a[i].islower():\n                    dp[i + 1][j] = True\n    return dp[n][m]",
    "docstring": ">>> abbr(\"daBcd\", \"ABC\")\nTrue\n>>> abbr(\"dBcd\", \"ABC\")\nFalse"
  },
  {
    "function": "all_construct",
    "code": "def all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\n    \"\"\"\n    returns the list containing all the possible\n    combinations a string(`target`) can be constructed from\n    the given list of substrings(`word_bank`)\n\n    >>> all_construct(\"hello\", [\"he\", \"l\", \"o\"])\n    [['he', 'l', 'l', 'o']]\n    >>> all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"])\n    [['purp', 'le'], ['p', 'ur', 'p', 'le']]\n    \"\"\"\n\n    word_bank = word_bank or []\n    # create a table\n    table_size: int = len(target) + 1\n\n    table: list[list[list[str]]] = []\n    for _ in range(table_size):\n        table.append([])\n    # seed value\n    table[0] = [[]]  # because empty string has empty combination\n\n    # iterate through the indices\n    for i in range(table_size):\n        # condition\n        if table[i] != []:\n            for word in word_bank:\n                # slice condition\n                if target[i : i + len(word)] == word:\n                    new_combinations: list[list[str]] = [\n                        [word, *way] for way in table[i]\n                    ]\n                    # adds the word to every combination the current position holds\n                    # now,push that combination to the table[i+len(word)]\n                    table[i + len(word)] += new_combinations\n\n    # combinations are in reverse order so reverse for better output\n    for combination in table[len(target)]:\n        combination.reverse()\n\n    return table[len(target)]",
    "docstring": "returns the list containing all the possible\ncombinations a string(`target`) can be constructed from\nthe given list of substrings(`word_bank`)\n\n>>> all_construct(\"hello\", [\"he\", \"l\", \"o\"])\n[['he', 'l', 'l', 'o']]\n>>> all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"])\n[['purp', 'le'], ['p', 'ur', 'p', 'le']]"
  },
  {
    "function": "catalan_numbers",
    "code": "def catalan_numbers(upper_limit: int) -> \"list[int]\":\n    \"\"\"\n    Return a list of the Catalan number sequence from 0 through `upper_limit`.\n\n    >>> catalan_numbers(5)\n    [1, 1, 2, 5, 14, 42]\n    >>> catalan_numbers(2)\n    [1, 1, 2]\n    >>> catalan_numbers(-1)\n    Traceback (most recent call last):\n    ValueError: Limit for the Catalan sequence must be \u2265 0\n    \"\"\"\n    if upper_limit < 0:\n        raise ValueError(\"Limit for the Catalan sequence must be \u2265 0\")\n\n    catalan_list = [0] * (upper_limit + 1)\n\n    # Base case: C(0) = C(1) = 1\n    catalan_list[0] = 1\n    if upper_limit > 0:\n        catalan_list[1] = 1\n\n    # Recurrence relation: C(i) = sum(C(j).C(i-j-1)), from j = 0 to i\n    for i in range(2, upper_limit + 1):\n        for j in range(i):\n            catalan_list[i] += catalan_list[j] * catalan_list[i - j - 1]\n\n    return catalan_list",
    "docstring": "Return a list of the Catalan number sequence from 0 through `upper_limit`.\n\n>>> catalan_numbers(5)\n[1, 1, 2, 5, 14, 42]\n>>> catalan_numbers(2)\n[1, 1, 2]\n>>> catalan_numbers(-1)\nTraceback (most recent call last):\nValueError: Limit for the Catalan sequence must be \u2265 0"
  },
  {
    "function": "climb_stairs",
    "code": "def climb_stairs(number_of_steps: int) -> int:\n    \"\"\"\n    LeetCdoe No.70: Climbing Stairs\n    Distinct ways to climb a number_of_steps staircase where each time you can either\n    climb 1 or 2 steps.\n\n    Args:\n        number_of_steps: number of steps on the staircase\n\n    Returns:\n        Distinct ways to climb a number_of_steps staircase\n\n    Raises:\n        AssertionError: number_of_steps not positive integer\n\n    >>> climb_stairs(3)\n    3\n    >>> climb_stairs(1)\n    1\n    >>> climb_stairs(-7)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError: number_of_steps needs to be positive integer, your input -7\n    \"\"\"\n    assert isinstance(number_of_steps, int) and number_of_steps > 0, (\n        f\"number_of_steps needs to be positive integer, your input {number_of_steps}\"\n    )\n    if number_of_steps == 1:\n        return 1\n    previous, current = 1, 1\n    for _ in range(number_of_steps - 1):\n        current, previous = current + previous, current\n    return current",
    "docstring": "LeetCdoe No.70: Climbing Stairs\nDistinct ways to climb a number_of_steps staircase where each time you can either\nclimb 1 or 2 steps.\n\nArgs:\n    number_of_steps: number of steps on the staircase\n\nReturns:\n    Distinct ways to climb a number_of_steps staircase\n\nRaises:\n    AssertionError: number_of_steps not positive integer\n\n>>> climb_stairs(3)\n3\n>>> climb_stairs(1)\n1\n>>> climb_stairs(-7)  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nAssertionError: number_of_steps needs to be positive integer, your input -7"
  },
  {
    "function": "combination_sum_iv",
    "code": "def combination_sum_iv(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)",
    "docstring": "Function checks the all possible combinations, and returns the count\nof possible combination in exponential Time Complexity.\n\n>>> combination_sum_iv([1,2,5], 5)\n9"
  },
  {
    "function": "combination_sum_iv_dp_array",
    "code": "def combination_sum_iv_dp_array(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)",
    "docstring": "Function checks the all possible combinations, and returns the count\nof possible combination in O(N^2) Time Complexity as we are using Dynamic\nprogramming array here.\n\n>>> combination_sum_iv_dp_array([1,2,5], 5)\n9"
  },
  {
    "function": "combination_sum_iv_bottom_up",
    "code": "def combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations with using bottom up approach,\n    and returns the count of possible combination in O(N^2) Time Complexity\n    as we are using Dynamic programming array here.\n\n    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    dp_array = [0] * (target + 1)\n    dp_array[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - array[j] >= 0:\n                dp_array[i] += dp_array[i - array[j]]\n\n    return dp_array[target]",
    "docstring": "Function checks the all possible combinations with using bottom up approach,\nand returns the count of possible combination in O(N^2) Time Complexity\nas we are using Dynamic programming array here.\n\n>>> combination_sum_iv_bottom_up(3, [1,2,5], 5)\n9"
  },
  {
    "function": "factorial",
    "code": "def factorial(num: int) -> int:\n    \"\"\"\n    >>> factorial(7)\n    5040\n    >>> factorial(-1)\n    Traceback (most recent call last):\n      ...\n    ValueError: Number should not be negative.\n    >>> [factorial(i) for i in range(10)]\n    [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Number should not be negative.\")\n\n    return 1 if num in (0, 1) else num * factorial(num - 1)",
    "docstring": ">>> factorial(7)\n5040\n>>> factorial(-1)\nTraceback (most recent call last):\n  ...\nValueError: Number should not be negative.\n>>> [factorial(i) for i in range(10)]\n[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]"
  },
  {
    "function": "fibonacci",
    "code": "def fibonacci(n: int) -> int:\n    \"\"\"\n    return F(n)\n    >>> [fibonacci(i) for i in range(13)]\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Negative arguments are not supported\")\n    return _fib(n)[0]",
    "docstring": "return F(n)\n>>> [fibonacci(i) for i in range(13)]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]"
  },
  {
    "function": "fizz_buzz",
    "code": "def fizz_buzz(number: int, iterations: int) -> str:\n    \"\"\"\n    | Plays FizzBuzz.\n    | Prints Fizz if number is a multiple of ``3``.\n    | Prints Buzz if its a multiple of ``5``.\n    | Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``.\n    | Else Prints The Number Itself.\n\n    >>> fizz_buzz(1,7)\n    '1 2 Fizz 4 Buzz Fizz 7 '\n    >>> fizz_buzz(1,0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(-5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(10,-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(1.5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(1,5.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: iterations must be defined as integers\n    \"\"\"\n    if not isinstance(iterations, int):\n        raise ValueError(\"iterations must be defined as integers\")\n    if not isinstance(number, int) or not number >= 1:\n        raise ValueError(\n            \"\"\"starting number must be\n                         and integer and be more than 0\"\"\"\n        )\n    if not iterations >= 1:\n        raise ValueError(\"Iterations must be done more than 0 times to play FizzBuzz\")\n\n    out = \"\"\n    while number <= iterations:\n        if number % 3 == 0:\n            out += \"Fizz\"\n        if number % 5 == 0:\n            out += \"Buzz\"\n        if 0 not in (number % 3, number % 5):\n            out += str(number)\n\n        # print(out)\n        number += 1\n        out += \" \"\n    return out",
    "docstring": "| Plays FizzBuzz.\n| Prints Fizz if number is a multiple of ``3``.\n| Prints Buzz if its a multiple of ``5``.\n| Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``.\n| Else Prints The Number Itself.\n\n>>> fizz_buzz(1,7)\n'1 2 Fizz 4 Buzz Fizz 7 '\n>>> fizz_buzz(1,0)\nTraceback (most recent call last):\n  ...\nValueError: Iterations must be done more than 0 times to play FizzBuzz\n>>> fizz_buzz(-5,5)\nTraceback (most recent call last):\n    ...\nValueError: starting number must be\n                         and integer and be more than 0\n>>> fizz_buzz(10,-5)\nTraceback (most recent call last):\n    ...\nValueError: Iterations must be done more than 0 times to play FizzBuzz\n>>> fizz_buzz(1.5,5)\nTraceback (most recent call last):\n    ...\nValueError: starting number must be\n                         and integer and be more than 0\n>>> fizz_buzz(1,5.5)\nTraceback (most recent call last):\n    ...\nValueError: iterations must be defined as integers"
  },
  {
    "function": "partition",
    "code": "def partition(m: int) -> int:\n    \"\"\"\n    >>> partition(5)\n    7\n    >>> partition(7)\n    15\n    >>> partition(100)\n    190569292\n    >>> partition(1_000)\n    24061467864032622473692149727991\n    >>> partition(-7)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    >>> partition(0)\n    Traceback (most recent call last):\n        ...\n    IndexError: list assignment index out of range\n    >>> partition(7.8)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    \"\"\"\n    memo: list[list[int]] = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n - k > 0:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1]",
    "docstring": ">>> partition(5)\n7\n>>> partition(7)\n15\n>>> partition(100)\n190569292\n>>> partition(1_000)\n24061467864032622473692149727991\n>>> partition(-7)\nTraceback (most recent call last):\n    ...\nIndexError: list index out of range\n>>> partition(0)\nTraceback (most recent call last):\n    ...\nIndexError: list assignment index out of range\n>>> partition(7.8)\nTraceback (most recent call last):\n    ...\nTypeError: 'float' object cannot be interpreted as an integer"
  },
  {
    "function": "list_of_submasks",
    "code": "def list_of_submasks(mask: int) -> list[int]:\n    \"\"\"\n    Args:\n        mask : number which shows mask ( always integer > 0, zero does not have any\n            submasks )\n\n    Returns:\n        all_submasks : the list of submasks of mask (mask s is called submask of mask\n        m if only bits that were included in original mask are set\n\n    Raises:\n        AssertionError: mask not positive integer\n\n    >>> list_of_submasks(15)\n    [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    >>> list_of_submasks(13)\n    [13, 12, 9, 8, 5, 4, 1]\n    >>> list_of_submasks(-7)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError: mask needs to be positive integer, your input -7\n    >>> list_of_submasks(0)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError: mask needs to be positive integer, your input 0\n\n    \"\"\"\n\n    assert isinstance(mask, int) and mask > 0, (\n        f\"mask needs to be positive integer, your input {mask}\"\n    )\n\n    \"\"\"\n    first submask iterated will be mask itself then operation will be performed\n    to get other submasks till we reach empty submask that is zero ( zero is not\n    included in final submasks list )\n    \"\"\"\n    all_submasks = []\n    submask = mask\n\n    while submask:\n        all_submasks.append(submask)\n        submask = (submask - 1) & mask\n\n    return all_submasks",
    "docstring": "Args:\n    mask : number which shows mask ( always integer > 0, zero does not have any\n        submasks )\n\nReturns:\n    all_submasks : the list of submasks of mask (mask s is called submask of mask\n    m if only bits that were included in original mask are set\n\nRaises:\n    AssertionError: mask not positive integer\n\n>>> list_of_submasks(15)\n[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n>>> list_of_submasks(13)\n[13, 12, 9, 8, 5, 4, 1]\n>>> list_of_submasks(-7)  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nAssertionError: mask needs to be positive integer, your input -7\n>>> list_of_submasks(0)  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nAssertionError: mask needs to be positive integer, your input 0"
  },
  {
    "function": "mf_knapsack",
    "code": "def mf_knapsack(i, wt, val, j):\n    \"\"\"\n    This code involves the concept of memory functions. Here we solve the subproblems\n    which are needed unlike the below example\n    F is a 2D array with ``-1`` s filled up\n    \"\"\"\n    global f  # a global dp table for knapsack\n    if f[i][j] < 0:\n        if j < wt[i - 1]:\n            val = mf_knapsack(i - 1, wt, val, j)\n        else:\n            val = max(\n                mf_knapsack(i - 1, wt, val, j),\n                mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],\n            )\n        f[i][j] = val\n    return f[i][j]",
    "docstring": "This code involves the concept of memory functions. Here we solve the subproblems\nwhich are needed unlike the below example\nF is a 2D array with ``-1`` s filled up"
  },
  {
    "function": "knapsack_with_example_solution",
    "code": "def knapsack_with_example_solution(w: int, wt: list, val: list):\n    \"\"\"\n    Solves the integer weights knapsack problem returns one of\n    the several possible optimal subsets.\n\n    Parameters\n    ----------\n\n    * `w`: int, the total maximum weight for the given knapsack problem.\n    * `wt`: list, the vector of weights for all items where ``wt[i]`` is the weight\n       of the ``i``-th item.\n    * `val`: list, the vector of values for all items where ``val[i]`` is the value\n      of the ``i``-th item\n\n    Returns\n    -------\n\n    * `optimal_val`: float, the optimal value for the given knapsack problem\n    * `example_optional_set`: set, the indices of one of the optimal subsets\n      which gave rise to the optimal value.\n\n    Examples\n    --------\n\n    >>> knapsack_with_example_solution(10, [1, 3, 5, 2], [10, 20, 100, 22])\n    (142, {2, 3, 4})\n    >>> knapsack_with_example_solution(6, [4, 3, 2, 3], [3, 2, 4, 4])\n    (8, {3, 4})\n    >>> knapsack_with_example_solution(6, [4, 3, 2, 3], [3, 2, 4])\n    Traceback (most recent call last):\n        ...\n    ValueError: The number of weights must be the same as the number of values.\n    But got 4 weights and 3 values\n    \"\"\"\n    if not (isinstance(wt, (list, tuple)) and isinstance(val, (list, tuple))):\n        raise ValueError(\n            \"Both the weights and values vectors must be either lists or tuples\"\n        )\n\n    num_items = len(wt)\n    if num_items != len(val):\n        msg = (\n            \"The number of weights must be the same as the number of values.\\n\"\n            f\"But got {num_items} weights and {len(val)} values\"\n        )\n        raise ValueError(msg)\n    for i in range(num_items):\n        if not isinstance(wt[i], int):\n            msg = (\n                \"All weights must be integers but got weight of \"\n                f\"type {type(wt[i])} at index {i}\"\n            )\n            raise TypeError(msg)\n\n    optimal_val, dp_table = knapsack(w, wt, val, num_items)\n    example_optional_set: set = set()\n    _construct_solution(dp_table, wt, num_items, w, example_optional_set)\n\n    return optimal_val, example_optional_set",
    "docstring": "Solves the integer weights knapsack problem returns one of\nthe several possible optimal subsets.\n\nParameters\n----------\n\n* `w`: int, the total maximum weight for the given knapsack problem.\n* `wt`: list, the vector of weights for all items where ``wt[i]`` is the weight\n   of the ``i``-th item.\n* `val`: list, the vector of values for all items where ``val[i]`` is the value\n  of the ``i``-th item\n\nReturns\n-------\n\n* `optimal_val`: float, the optimal value for the given knapsack problem\n* `example_optional_set`: set, the indices of one of the optimal subsets\n  which gave rise to the optimal value.\n\nExamples\n--------\n\n>>> knapsack_with_example_solution(10, [1, 3, 5, 2], [10, 20, 100, 22])\n(142, {2, 3, 4})\n>>> knapsack_with_example_solution(6, [4, 3, 2, 3], [3, 2, 4, 4])\n(8, {3, 4})\n>>> knapsack_with_example_solution(6, [4, 3, 2, 3], [3, 2, 4])\nTraceback (most recent call last):\n    ...\nValueError: The number of weights must be the same as the number of values.\nBut got 4 weights and 3 values"
  },
  {
    "function": "_construct_solution",
    "code": "def _construct_solution(dp: list, wt: list, i: int, j: int, optimal_set: set):\n    \"\"\"\n    Recursively reconstructs one of the optimal subsets given\n    a filled DP table and the vector of weights\n\n    Parameters\n    ----------\n\n    * `dp`: list of list, the table of a solved integer weight dynamic programming\n      problem\n    * `wt`: list or tuple, the vector of weights of the items\n    * `i`: int, the index of the item under consideration\n    * `j`: int, the current possible maximum weight\n    * `optimal_set`: set, the optimal subset so far. This gets modified by the function.\n\n    Returns\n    -------\n\n    ``None``\n    \"\"\"\n    # for the current item i at a maximum weight j to be part of an optimal subset,\n    # the optimal value at (i, j) must be greater than the optimal value at (i-1, j).\n    # where i - 1 means considering only the previous items at the given maximum weight\n    if i > 0 and j > 0:\n        if dp[i - 1][j] == dp[i][j]:\n            _construct_solution(dp, wt, i - 1, j, optimal_set)\n        else:\n            optimal_set.add(i)\n            _construct_solution(dp, wt, i - 1, j - wt[i - 1], optimal_set)",
    "docstring": "Recursively reconstructs one of the optimal subsets given\na filled DP table and the vector of weights\n\nParameters\n----------\n\n* `dp`: list of list, the table of a solved integer weight dynamic programming\n  problem\n* `wt`: list or tuple, the vector of weights of the items\n* `i`: int, the index of the item under consideration\n* `j`: int, the current possible maximum weight\n* `optimal_set`: set, the optimal subset so far. This gets modified by the function.\n\nReturns\n-------\n\n``None``"
  },
  {
    "function": "tf_k_means_cluster",
    "code": "def tf_k_means_cluster(vectors, noofclusters):\n    \"\"\"\n    K-Means Clustering using TensorFlow.\n    'vectors' should be a n*k 2-D NumPy array, where n is the number\n    of vectors of dimensionality k.\n    'noofclusters' should be an integer.\n    \"\"\"\n\n    noofclusters = int(noofclusters)\n    assert noofclusters < len(vectors)\n\n    # Find out the dimensionality\n    dim = len(vectors[0])\n\n    # Will help select random centroids from among the available vectors\n    vector_indices = list(range(len(vectors)))\n    shuffle(vector_indices)\n\n    # GRAPH OF COMPUTATION\n    # We initialize a new graph and set it as the default during each run\n    # of this algorithm. This ensures that as this function is called\n    # multiple times, the default graph doesn't keep getting crowded with\n    # unused ops and Variables from previous function calls.\n\n    graph = tf.Graph()\n\n    with graph.as_default():\n        # SESSION OF COMPUTATION\n\n        sess = tf.Session()\n\n        ##CONSTRUCTING THE ELEMENTS OF COMPUTATION\n\n        ##First lets ensure we have a Variable vector for each centroid,\n        ##initialized to one of the vectors from the available data points\n        centroids = [\n            tf.Variable(vectors[vector_indices[i]]) for i in range(noofclusters)\n        ]\n        ##These nodes will assign the centroid Variables the appropriate\n        ##values\n        centroid_value = tf.placeholder(\"float64\", [dim])\n        cent_assigns = []\n        for centroid in centroids:\n            cent_assigns.append(tf.assign(centroid, centroid_value))\n\n        ##Variables for cluster assignments of individual vectors(initialized\n        ##to 0 at first)\n        assignments = [tf.Variable(0) for i in range(len(vectors))]\n        ##These nodes will assign an assignment Variable the appropriate\n        ##value\n        assignment_value = tf.placeholder(\"int32\")\n        cluster_assigns = []\n        for assignment in assignments:\n            cluster_assigns.append(tf.assign(assignment, assignment_value))\n\n        ##Now lets construct the node that will compute the mean\n        # The placeholder for the input\n        mean_input = tf.placeholder(\"float\", [None, dim])\n        # The Node/op takes the input and computes a mean along the 0th\n        # dimension, i.e. the list of input vectors\n        mean_op = tf.reduce_mean(mean_input, 0)\n\n        ##Node for computing Euclidean distances\n        # Placeholders for input\n        v1 = tf.placeholder(\"float\", [dim])\n        v2 = tf.placeholder(\"float\", [dim])\n        euclid_dist = tf.sqrt(tf.reduce_sum(tf.pow(tf.sub(v1, v2), 2)))\n\n        ##This node will figure out which cluster to assign a vector to,\n        ##based on Euclidean distances of the vector from the centroids.\n        # Placeholder for input\n        centroid_distances = tf.placeholder(\"float\", [noofclusters])\n        cluster_assignment = tf.argmin(centroid_distances, 0)\n\n        ##INITIALIZING STATE VARIABLES\n\n        ##This will help initialization of all Variables defined with respect\n        ##to the graph. The Variable-initializer should be defined after\n        ##all the Variables have been constructed, so that each of them\n        ##will be included in the initialization.\n        init_op = tf.initialize_all_variables()\n\n        # Initialize all variables\n        sess.run(init_op)\n\n        ##CLUSTERING ITERATIONS\n\n        # Now perform the Expectation-Maximization steps of K-Means clustering\n        # iterations. To keep things simple, we will only do a set number of\n        # iterations, instead of using a Stopping Criterion.\n        noofiterations = 100\n        for _ in range(noofiterations):\n            ##EXPECTATION STEP\n            ##Based on the centroid locations till last iteration, compute\n            ##the _expected_ centroid assignments.\n            # Iterate over each vector\n            for vector_n in range(len(vectors)):\n                vect = vectors[vector_n]\n                # Compute Euclidean distance between this vector and each\n                # centroid. Remember that this list cannot be named\n                #'centroid_distances', since that is the input to the\n                # cluster assignment node.\n                distances = [\n                    sess.run(euclid_dist, feed_dict={v1: vect, v2: sess.run(centroid)})\n                    for centroid in centroids\n                ]\n                # Now use the cluster assignment node, with the distances\n                # as the input\n                assignment = sess.run(\n                    cluster_assignment, feed_dict={centroid_distances: distances}\n                )\n                # Now assign the value to the appropriate state variable\n                sess.run(\n                    cluster_assigns[vector_n], feed_dict={assignment_value: assignment}\n                )\n\n            ##MAXIMIZATION STEP\n            # Based on the expected state computed from the Expectation Step,\n            # compute the locations of the centroids so as to maximize the\n            # overall objective of minimizing within-cluster Sum-of-Squares\n            for cluster_n in range(noofclusters):\n                # Collect all the vectors assigned to this cluster\n                assigned_vects = [\n                    vectors[i]\n                    for i in range(len(vectors))\n                    if sess.run(assignments[i]) == cluster_n\n                ]\n                # Compute new centroid location\n                new_location = sess.run(\n                    mean_op, feed_dict={mean_input: array(assigned_vects)}\n                )\n                # Assign value to appropriate variable\n                sess.run(\n                    cent_assigns[cluster_n], feed_dict={centroid_value: new_location}\n                )\n\n        # Return centroids and assignments\n        centroids = sess.run(centroids)\n        assignments = sess.run(assignments)\n        return centroids, assignments",
    "docstring": "K-Means Clustering using TensorFlow.\n'vectors' should be a n*k 2-D NumPy array, where n is the number\nof vectors of dimensionality k.\n'noofclusters' should be an integer."
  },
  {
    "function": "largest_divisible_subset",
    "code": "def largest_divisible_subset(items: list[int]) -> list[int]:\n    \"\"\"\n    Algorithm to find the biggest subset in the given array such that for any 2 elements\n    x and y in the subset, either x divides y or y divides x.\n    >>> largest_divisible_subset([1, 16, 7, 8, 4])\n    [16, 8, 4, 1]\n    >>> largest_divisible_subset([1, 2, 3])\n    [2, 1]\n    >>> largest_divisible_subset([-1, -2, -3])\n    [-3]\n    >>> largest_divisible_subset([1, 2, 4, 8])\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset((1, 2, 4, 8))\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset([1, 1, 1])\n    [1, 1, 1]\n    >>> largest_divisible_subset([0, 0, 0])\n    [0, 0, 0]\n    >>> largest_divisible_subset([-1, -1, -1])\n    [-1, -1, -1]\n    >>> largest_divisible_subset([])\n    []\n    \"\"\"\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result",
    "docstring": "Algorithm to find the biggest subset in the given array such that for any 2 elements\nx and y in the subset, either x divides y or y divides x.\n>>> largest_divisible_subset([1, 16, 7, 8, 4])\n[16, 8, 4, 1]\n>>> largest_divisible_subset([1, 2, 3])\n[2, 1]\n>>> largest_divisible_subset([-1, -2, -3])\n[-3]\n>>> largest_divisible_subset([1, 2, 4, 8])\n[8, 4, 2, 1]\n>>> largest_divisible_subset((1, 2, 4, 8))\n[8, 4, 2, 1]\n>>> largest_divisible_subset([1, 1, 1])\n[1, 1, 1]\n>>> largest_divisible_subset([0, 0, 0])\n[0, 0, 0]\n>>> largest_divisible_subset([-1, -1, -1])\n[-1, -1, -1]\n>>> largest_divisible_subset([])\n[]"
  },
  {
    "function": "longest_common_subsequence",
    "code": "def longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq",
    "docstring": "Finds the longest common subsequence between two strings. Also returns the\nThe subsequence found\n\nParameters\n----------\n\nx: str, one of the strings\ny: str, the other string\n\nReturns\n-------\nL[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\nSeq: str, the subsequence found\n\n>>> longest_common_subsequence(\"programming\", \"gaming\")\n(6, 'gaming')\n>>> longest_common_subsequence(\"physics\", \"smartphone\")\n(2, 'ph')\n>>> longest_common_subsequence(\"computer\", \"food\")\n(1, 'o')\n>>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n(0, '')\n>>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n(0, '')\n>>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n(0, '')\n>>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n(0, '')\n>>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n(3, 'abc')\n>>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n(1, 'a')\n>>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n(0, '')\n>>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n(3, 'ace')\n>>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n(3, 'ABD')"
  },
  {
    "function": "longest_common_substring",
    "code": "def longest_common_substring(text1: str, text2: str) -> str:\n    \"\"\"\n    Finds the longest common substring between two strings.\n\n    >>> longest_common_substring(\"\", \"\")\n    ''\n    >>> longest_common_substring(\"a\",\"\")\n    ''\n    >>> longest_common_substring(\"\", \"a\")\n    ''\n    >>> longest_common_substring(\"a\", \"a\")\n    'a'\n    >>> longest_common_substring(\"abcdef\", \"bcd\")\n    'bcd'\n    >>> longest_common_substring(\"abcdef\", \"xabded\")\n    'ab'\n    >>> longest_common_substring(\"GeeksforGeeks\", \"GeeksQuiz\")\n    'Geeks'\n    >>> longest_common_substring(\"abcdxyz\", \"xyzabcd\")\n    'abcd'\n    >>> longest_common_substring(\"zxabcdezy\", \"yzabcdezx\")\n    'abcdez'\n    >>> longest_common_substring(\"OldSite:GeeksforGeeks.org\", \"NewSite:GeeksQuiz.com\")\n    'Site:Geeks'\n    >>> longest_common_substring(1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: longest_common_substring() takes two strings for inputs\n    \"\"\"\n\n    if not (isinstance(text1, str) and isinstance(text2, str)):\n        raise ValueError(\"longest_common_substring() takes two strings for inputs\")\n\n    if not text1 or not text2:\n        return \"\"\n\n    text1_length = len(text1)\n    text2_length = len(text2)\n\n    dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]\n    end_pos = 0\n    max_length = 0\n\n    for i in range(1, text1_length + 1):\n        for j in range(1, text2_length + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n                if dp[i][j] > max_length:\n                    end_pos = i\n                    max_length = dp[i][j]\n\n    return text1[end_pos - max_length : end_pos]",
    "docstring": "Finds the longest common substring between two strings.\n\n>>> longest_common_substring(\"\", \"\")\n''\n>>> longest_common_substring(\"a\",\"\")\n''\n>>> longest_common_substring(\"\", \"a\")\n''\n>>> longest_common_substring(\"a\", \"a\")\n'a'\n>>> longest_common_substring(\"abcdef\", \"bcd\")\n'bcd'\n>>> longest_common_substring(\"abcdef\", \"xabded\")\n'ab'\n>>> longest_common_substring(\"GeeksforGeeks\", \"GeeksQuiz\")\n'Geeks'\n>>> longest_common_substring(\"abcdxyz\", \"xyzabcd\")\n'abcd'\n>>> longest_common_substring(\"zxabcdezy\", \"yzabcdezx\")\n'abcdez'\n>>> longest_common_substring(\"OldSite:GeeksforGeeks.org\", \"NewSite:GeeksQuiz.com\")\n'Site:Geeks'\n>>> longest_common_substring(1, 1)\nTraceback (most recent call last):\n    ...\nValueError: longest_common_substring() takes two strings for inputs"
  },
  {
    "function": "longest_subsequence",
    "code": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [5, 7]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = array[i:]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq",
    "docstring": "Some examples\n\n>>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n[10, 22, 33, 41, 60, 80]\n>>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n[1, 2, 3, 9]\n>>> longest_subsequence([28, 26, 12, 23, 35, 39])\n[12, 23, 35, 39]\n>>> longest_subsequence([9, 8, 7, 6, 5, 7])\n[5, 7]\n>>> longest_subsequence([1, 1, 1])\n[1, 1, 1]\n>>> longest_subsequence([])\n[]"
  },
  {
    "function": "longest_subsequence",
    "code": "def longest_subsequence(array: list[int]) -> list[int]:\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 50, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [7, 7]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    n = len(array)\n    # The longest increasing subsequence ending at array[i]\n    longest_increasing_subsequence = []\n    for i in range(n):\n        longest_increasing_subsequence.append([array[i]])\n\n    for i in range(1, n):\n        for prev in range(i):\n            # If array[prev] is less than or equal to array[i], then\n            # longest_increasing_subsequence[prev] + array[i]\n            # is a valid increasing subsequence\n\n            # longest_increasing_subsequence[i] is only set to\n            # longest_increasing_subsequence[prev] + array[i] if the length is longer.\n\n            if array[prev] <= array[i] and len(\n                longest_increasing_subsequence[prev]\n            ) + 1 > len(longest_increasing_subsequence[i]):\n                longest_increasing_subsequence[i] = copy.copy(\n                    longest_increasing_subsequence[prev]\n                )\n                longest_increasing_subsequence[i].append(array[i])\n\n    result: list[int] = []\n    for i in range(n):\n        if len(longest_increasing_subsequence[i]) > len(result):\n            result = longest_increasing_subsequence[i]\n\n    return result",
    "docstring": "Some examples\n\n>>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n[10, 22, 33, 50, 60, 80]\n>>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n[1, 2, 3, 9]\n>>> longest_subsequence([9, 8, 7, 6, 5, 7])\n[7, 7]\n>>> longest_subsequence([28, 26, 12, 23, 35, 39])\n[12, 23, 35, 39]\n>>> longest_subsequence([1, 1, 1])\n[1, 1, 1]\n>>> longest_subsequence([])\n[]"
  },
  {
    "function": "longest_increasing_subsequence_length",
    "code": "def longest_increasing_subsequence_length(v: list[int]) -> int:\n    \"\"\"\n    >>> longest_increasing_subsequence_length([2, 5, 3, 7, 11, 8, 10, 13, 6])\n    6\n    >>> longest_increasing_subsequence_length([])\n    0\n    >>> longest_increasing_subsequence_length([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13,\n    ...                                     3, 11, 7, 15])\n    6\n    >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1])\n    1\n    \"\"\"\n    if len(v) == 0:\n        return 0\n\n    tail = [0] * len(v)\n    length = 1\n\n    tail[0] = v[0]\n\n    for i in range(1, len(v)):\n        if v[i] < tail[0]:\n            tail[0] = v[i]\n        elif v[i] > tail[length - 1]:\n            tail[length] = v[i]\n            length += 1\n        else:\n            tail[ceil_index(tail, -1, length - 1, v[i])] = v[i]\n\n    return length",
    "docstring": ">>> longest_increasing_subsequence_length([2, 5, 3, 7, 11, 8, 10, 13, 6])\n6\n>>> longest_increasing_subsequence_length([])\n0\n>>> longest_increasing_subsequence_length([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13,\n...                                     3, 11, 7, 15])\n6\n>>> longest_increasing_subsequence_length([5, 4, 3, 2, 1])\n1"
  },
  {
    "function": "longest_palindromic_subsequence",
    "code": "def longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]",
    "docstring": "This function returns the longest palindromic subsequence in a string\n>>> longest_palindromic_subsequence(\"bbbab\")\n4\n>>> longest_palindromic_subsequence(\"bbabcbcab\")\n7"
  },
  {
    "function": "matrix_chain_multiply",
    "code": "def matrix_chain_multiply(arr: list[int]) -> int:\n    \"\"\"\n    Find the minimum number of multiplcations required to multiply the chain of matrices\n\n    Args:\n        `arr`: The input array of integers.\n\n    Returns:\n        Minimum number of multiplications needed to multiply the chain\n\n    Examples:\n\n    >>> matrix_chain_multiply([1, 2, 3, 4, 3])\n    30\n    >>> matrix_chain_multiply([10])\n    0\n    >>> matrix_chain_multiply([10, 20])\n    0\n    >>> matrix_chain_multiply([19, 2, 19])\n    722\n    >>> matrix_chain_multiply(list(range(1, 100)))\n    323398\n    >>> # matrix_chain_multiply(list(range(1, 251)))\n    # 2626798\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    # initialising 2D dp matrix\n    n = len(arr)\n    dp = [[maxsize for j in range(n)] for i in range(n)]\n    # we want minimum cost of multiplication of matrices\n    # of dimension (i*k) and (k*j). This cost is arr[i-1]*arr[k]*arr[j].\n    for i in range(n - 1, 0, -1):\n        for j in range(i, n):\n            if i == j:\n                dp[i][j] = 0\n                continue\n            for k in range(i, j):\n                dp[i][j] = min(\n                    dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]\n                )\n\n    return dp[1][n - 1]",
    "docstring": "Find the minimum number of multiplcations required to multiply the chain of matrices\n\nArgs:\n    `arr`: The input array of integers.\n\nReturns:\n    Minimum number of multiplications needed to multiply the chain\n\nExamples:\n\n>>> matrix_chain_multiply([1, 2, 3, 4, 3])\n30\n>>> matrix_chain_multiply([10])\n0\n>>> matrix_chain_multiply([10, 20])\n0\n>>> matrix_chain_multiply([19, 2, 19])\n722\n>>> matrix_chain_multiply(list(range(1, 100)))\n323398\n>>> # matrix_chain_multiply(list(range(1, 251)))\n# 2626798"
  },
  {
    "function": "matrix_chain_order",
    "code": "def matrix_chain_order(dims: list[int]) -> int:\n    \"\"\"\n    Source: https://en.wikipedia.org/wiki/Matrix_chain_multiplication\n\n    The dynamic programming solution is faster than cached the recursive solution and\n    can handle larger inputs.\n\n    >>> matrix_chain_order([1, 2, 3, 4, 3])\n    30\n    >>> matrix_chain_order([10])\n    0\n    >>> matrix_chain_order([10, 20])\n    0\n    >>> matrix_chain_order([19, 2, 19])\n    722\n    >>> matrix_chain_order(list(range(1, 100)))\n    323398\n    >>> # matrix_chain_order(list(range(1, 251)))  # Max before RecursionError is raised\n    # 2626798\n    \"\"\"\n\n    @cache\n    def a(i: int, j: int) -> int:\n        return min(\n            (a(i, k) + dims[i] * dims[k] * dims[j] + a(k, j) for k in range(i + 1, j)),\n            default=0,\n        )\n\n    return a(0, len(dims) - 1)",
    "docstring": "Source: https://en.wikipedia.org/wiki/Matrix_chain_multiplication\n\nThe dynamic programming solution is faster than cached the recursive solution and\ncan handle larger inputs.\n\n>>> matrix_chain_order([1, 2, 3, 4, 3])\n30\n>>> matrix_chain_order([10])\n0\n>>> matrix_chain_order([10, 20])\n0\n>>> matrix_chain_order([19, 2, 19])\n722\n>>> matrix_chain_order(list(range(1, 100)))\n323398\n>>> # matrix_chain_order(list(range(1, 251)))  # Max before RecursionError is raised\n# 2626798"
  },
  {
    "function": "matrix_chain_order",
    "code": "def matrix_chain_order(array: list[int]) -> tuple[list[list[int]], list[list[int]]]:\n    \"\"\"\n    >>> matrix_chain_order([10, 30, 5])\n    ([[0, 0, 0], [0, 0, 1500], [0, 0, 0]], [[0, 0, 0], [0, 0, 1], [0, 0, 0]])\n    \"\"\"\n    n = len(array)\n    matrix = [[0 for _ in range(n)] for _ in range(n)]\n    sol = [[0 for _ in range(n)] for _ in range(n)]\n\n    for chain_length in range(2, n):\n        for a in range(1, n - chain_length + 1):\n            b = a + chain_length - 1\n\n            matrix[a][b] = sys.maxsize\n            for c in range(a, b):\n                cost = (\n                    matrix[a][c] + matrix[c + 1][b] + array[a - 1] * array[c] * array[b]\n                )\n                if cost < matrix[a][b]:\n                    matrix[a][b] = cost\n                    sol[a][b] = c\n    return matrix, sol",
    "docstring": ">>> matrix_chain_order([10, 30, 5])\n([[0, 0, 0], [0, 0, 1500], [0, 0, 0]], [[0, 0, 0], [0, 0, 1], [0, 0, 0]])"
  },
  {
    "function": "print_optimal_solution",
    "code": "def print_optimal_solution(optimal_solution: list[list[int]], i: int, j: int):\n    \"\"\"\n    Print order of matrix with Ai as Matrix.\n    \"\"\"\n\n    if i == j:\n        print(\"A\" + str(i), end=\" \")\n    else:\n        print(\"(\", end=\" \")\n        print_optimal_solution(optimal_solution, i, optimal_solution[i][j])\n        print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j)\n        print(\")\", end=\" \")",
    "docstring": "Print order of matrix with Ai as Matrix."
  },
  {
    "function": "main",
    "code": "def main():\n    \"\"\"\n    Size of matrix created from array [30, 35, 15, 5, 10, 20, 25] will be:\n    30*35 35*15 15*5 5*10 10*20 20*25\n    \"\"\"\n\n    array = [30, 35, 15, 5, 10, 20, 25]\n    n = len(array)\n\n    matrix, optimal_solution = matrix_chain_order(array)\n\n    print(\"No. of Operation required: \" + str(matrix[1][n - 1]))\n    print_optimal_solution(optimal_solution, 1, n - 1)",
    "docstring": "Size of matrix created from array [30, 35, 15, 5, 10, 20, 25] will be:\n30*35 35*15 15*5 5*10 10*20 20*25"
  },
  {
    "function": "maximum_non_adjacent_sum",
    "code": "def maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)",
    "docstring": "Find the maximum non-adjacent sum of the integers in the nums input list\n\n>>> maximum_non_adjacent_sum([1, 2, 3])\n4\n>>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n18\n>>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n0\n>>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n500"
  },
  {
    "function": "max_product_subarray",
    "code": "def max_product_subarray(numbers: list[int]) -> int:\n    \"\"\"\n    Returns the maximum product that can be obtained by multiplying a\n    contiguous subarray of the given integer list `numbers`.\n\n    Example:\n\n    >>> max_product_subarray([2, 3, -2, 4])\n    6\n    >>> max_product_subarray((-2, 0, -1))\n    0\n    >>> max_product_subarray([2, 3, -2, 4, -1])\n    48\n    >>> max_product_subarray([-1])\n    -1\n    >>> max_product_subarray([0])\n    0\n    >>> max_product_subarray([])\n    0\n    >>> max_product_subarray(\"\")\n    0\n    >>> max_product_subarray(None)\n    0\n    >>> max_product_subarray([2, 3, -2, 4.5, -1])\n    Traceback (most recent call last):\n        ...\n    ValueError: numbers must be an iterable of integers\n    >>> max_product_subarray(\"ABC\")\n    Traceback (most recent call last):\n        ...\n    ValueError: numbers must be an iterable of integers\n    \"\"\"\n    if not numbers:\n        return 0\n\n    if not isinstance(numbers, (list, tuple)) or not all(\n        isinstance(number, int) for number in numbers\n    ):\n        raise ValueError(\"numbers must be an iterable of integers\")\n\n    max_till_now = min_till_now = max_prod = numbers[0]\n\n    for i in range(1, len(numbers)):\n        # update the maximum and minimum subarray products\n        number = numbers[i]\n        if number < 0:\n            max_till_now, min_till_now = min_till_now, max_till_now\n        max_till_now = max(number, max_till_now * number)\n        min_till_now = min(number, min_till_now * number)\n\n        # update the maximum product found till now\n        max_prod = max(max_prod, max_till_now)\n\n    return max_prod",
    "docstring": "Returns the maximum product that can be obtained by multiplying a\ncontiguous subarray of the given integer list `numbers`.\n\nExample:\n\n>>> max_product_subarray([2, 3, -2, 4])\n6\n>>> max_product_subarray((-2, 0, -1))\n0\n>>> max_product_subarray([2, 3, -2, 4, -1])\n48\n>>> max_product_subarray([-1])\n-1\n>>> max_product_subarray([0])\n0\n>>> max_product_subarray([])\n0\n>>> max_product_subarray(\"\")\n0\n>>> max_product_subarray(None)\n0\n>>> max_product_subarray([2, 3, -2, 4.5, -1])\nTraceback (most recent call last):\n    ...\nValueError: numbers must be an iterable of integers\n>>> max_product_subarray(\"ABC\")\nTraceback (most recent call last):\n    ...\nValueError: numbers must be an iterable of integers"
  },
  {
    "function": "max_subarray_sum",
    "code": "def max_subarray_sum(\n    arr: Sequence[float], allow_empty_subarrays: bool = False\n) -> float:\n    \"\"\"\n    Solves the maximum subarray sum problem using Kadane's algorithm.\n    :param arr: the given array of numbers\n    :param allow_empty_subarrays: if True, then the algorithm considers empty subarrays\n\n    >>> max_subarray_sum([2, 8, 9])\n    19\n    >>> max_subarray_sum([0, 0])\n    0\n    >>> max_subarray_sum([-1.0, 0.0, 1.0])\n    1.0\n    >>> max_subarray_sum([1, 2, 3, 4, -2])\n    10\n    >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n    >>> max_subarray_sum([2, 3, -9, 8, -2])\n    8\n    >>> max_subarray_sum([-2, -3, -1, -4, -6])\n    -1\n    >>> max_subarray_sum([-2, -3, -1, -4, -6], allow_empty_subarrays=True)\n    0\n    >>> max_subarray_sum([])\n    0\n    \"\"\"\n    if not arr:\n        return 0\n\n    max_sum = 0 if allow_empty_subarrays else float(\"-inf\")\n    curr_sum = 0.0\n    for num in arr:\n        curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum",
    "docstring": "Solves the maximum subarray sum problem using Kadane's algorithm.\n:param arr: the given array of numbers\n:param allow_empty_subarrays: if True, then the algorithm considers empty subarrays\n\n>>> max_subarray_sum([2, 8, 9])\n19\n>>> max_subarray_sum([0, 0])\n0\n>>> max_subarray_sum([-1.0, 0.0, 1.0])\n1.0\n>>> max_subarray_sum([1, 2, 3, 4, -2])\n10\n>>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n6\n>>> max_subarray_sum([2, 3, -9, 8, -2])\n8\n>>> max_subarray_sum([-2, -3, -1, -4, -6])\n-1\n>>> max_subarray_sum([-2, -3, -1, -4, -6], allow_empty_subarrays=True)\n0\n>>> max_subarray_sum([])\n0"
  },
  {
    "function": "dp_count",
    "code": "def dp_count(s, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 4)\n    4\n    >>> dp_count([1, 2, 3], 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 10)\n    5\n    >>> dp_count([10], 99)\n    0\n    >>> dp_count([4, 5, 6], 0)\n    1\n    >>> dp_count([1, 2, 3], -5)\n    0\n    \"\"\"\n    if n < 0:\n        return 0\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in s:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]",
    "docstring": ">>> dp_count([1, 2, 3], 4)\n4\n>>> dp_count([1, 2, 3], 7)\n8\n>>> dp_count([2, 5, 3, 6], 10)\n5\n>>> dp_count([10], 99)\n0\n>>> dp_count([4, 5, 6], 0)\n1\n>>> dp_count([1, 2, 3], -5)\n0"
  },
  {
    "function": "minimum_cost_path",
    "code": "def minimum_cost_path(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]",
    "docstring": "Find the minimum cost traced by all possible paths from top left to bottom right in\na given matrix\n\n>>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n6\n\n>>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n7"
  },
  {
    "function": "find_min",
    "code": "def find_min(numbers: list[int]) -> int:\n    \"\"\"\n    >>> find_min([1, 2, 3, 4, 5])\n    1\n    >>> find_min([5, 5, 5, 5, 5])\n    5\n    >>> find_min([5, 5, 5, 5])\n    0\n    >>> find_min([3])\n    3\n    >>> find_min([])\n    0\n    >>> find_min([1, 2, 3, 4])\n    0\n    >>> find_min([0, 0, 0, 0])\n    0\n    >>> find_min([-1, -5, 5, 1])\n    0\n    >>> find_min([-1, -5, 5, 1])\n    0\n    >>> find_min([9, 9, 9, 9, 9])\n    9\n    >>> find_min([1, 5, 10, 3])\n    1\n    >>> find_min([-1, 0, 1])\n    0\n    >>> find_min(range(10, 0, -1))\n    1\n    >>> find_min([-1])\n    Traceback (most recent call last):\n        --\n    IndexError: list assignment index out of range\n    >>> find_min([0, 0, 0, 1, 2, -4])\n    Traceback (most recent call last):\n        ...\n    IndexError: list assignment index out of range\n    >>> find_min([-1, -5, -10, -3])\n    Traceback (most recent call last):\n        ...\n    IndexError: list assignment index out of range\n    \"\"\"\n    n = len(numbers)\n    s = sum(numbers)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i - 1][j]\n\n            if numbers[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - numbers[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff",
    "docstring": ">>> find_min([1, 2, 3, 4, 5])\n1\n>>> find_min([5, 5, 5, 5, 5])\n5\n>>> find_min([5, 5, 5, 5])\n0\n>>> find_min([3])\n3\n>>> find_min([])\n0\n>>> find_min([1, 2, 3, 4])\n0\n>>> find_min([0, 0, 0, 0])\n0\n>>> find_min([-1, -5, 5, 1])\n0\n>>> find_min([-1, -5, 5, 1])\n0\n>>> find_min([9, 9, 9, 9, 9])\n9\n>>> find_min([1, 5, 10, 3])\n1\n>>> find_min([-1, 0, 1])\n0\n>>> find_min(range(10, 0, -1))\n1\n>>> find_min([-1])\nTraceback (most recent call last):\n    --\nIndexError: list assignment index out of range\n>>> find_min([0, 0, 0, 1, 2, -4])\nTraceback (most recent call last):\n    ...\nIndexError: list assignment index out of range\n>>> find_min([-1, -5, -10, -3])\nTraceback (most recent call last):\n    ...\nIndexError: list assignment index out of range"
  },
  {
    "function": "minimum_subarray_sum",
    "code": "def minimum_subarray_sum(target: int, numbers: list[int]) -> int:\n    \"\"\"\n    Return the length of the shortest contiguous subarray in a list of numbers whose sum\n    is at least target.  Reference: https://stackoverflow.com/questions/8269916\n\n    >>> minimum_subarray_sum(7, [2, 3, 1, 2, 4, 3])\n    2\n    >>> minimum_subarray_sum(7, [2, 3, -1, 2, 4, -3])\n    4\n    >>> minimum_subarray_sum(11, [1, 1, 1, 1, 1, 1, 1, 1])\n    0\n    >>> minimum_subarray_sum(10, [1, 2, 3, 4, 5, 6, 7])\n    2\n    >>> minimum_subarray_sum(5, [1, 1, 1, 1, 1, 5])\n    1\n    >>> minimum_subarray_sum(0, [])\n    0\n    >>> minimum_subarray_sum(0, [1, 2, 3])\n    1\n    >>> minimum_subarray_sum(10, [10, 20, 30])\n    1\n    >>> minimum_subarray_sum(7, [1, 1, 1, 1, 1, 1, 10])\n    1\n    >>> minimum_subarray_sum(6, [])\n    0\n    >>> minimum_subarray_sum(2, [1, 2, 3])\n    1\n    >>> minimum_subarray_sum(-6, [])\n    0\n    >>> minimum_subarray_sum(-6, [3, 4, 5])\n    1\n    >>> minimum_subarray_sum(8, None)\n    0\n    >>> minimum_subarray_sum(2, \"ABC\")\n    Traceback (most recent call last):\n        ...\n    ValueError: numbers must be an iterable of integers\n    \"\"\"\n    if not numbers:\n        return 0\n    if target == 0 and target in numbers:\n        return 0\n    if not isinstance(numbers, (list, tuple)) or not all(\n        isinstance(number, int) for number in numbers\n    ):\n        raise ValueError(\"numbers must be an iterable of integers\")\n\n    left = right = curr_sum = 0\n    min_len = sys.maxsize\n\n    while right < len(numbers):\n        curr_sum += numbers[right]\n        while curr_sum >= target and left <= right:\n            min_len = min(min_len, right - left + 1)\n            curr_sum -= numbers[left]\n            left += 1\n        right += 1\n\n    return 0 if min_len == sys.maxsize else min_len",
    "docstring": "Return the length of the shortest contiguous subarray in a list of numbers whose sum\nis at least target.  Reference: https://stackoverflow.com/questions/8269916\n\n>>> minimum_subarray_sum(7, [2, 3, 1, 2, 4, 3])\n2\n>>> minimum_subarray_sum(7, [2, 3, -1, 2, 4, -3])\n4\n>>> minimum_subarray_sum(11, [1, 1, 1, 1, 1, 1, 1, 1])\n0\n>>> minimum_subarray_sum(10, [1, 2, 3, 4, 5, 6, 7])\n2\n>>> minimum_subarray_sum(5, [1, 1, 1, 1, 1, 5])\n1\n>>> minimum_subarray_sum(0, [])\n0\n>>> minimum_subarray_sum(0, [1, 2, 3])\n1\n>>> minimum_subarray_sum(10, [10, 20, 30])\n1\n>>> minimum_subarray_sum(7, [1, 1, 1, 1, 1, 1, 10])\n1\n>>> minimum_subarray_sum(6, [])\n0\n>>> minimum_subarray_sum(2, [1, 2, 3])\n1\n>>> minimum_subarray_sum(-6, [])\n0\n>>> minimum_subarray_sum(-6, [3, 4, 5])\n1\n>>> minimum_subarray_sum(8, None)\n0\n>>> minimum_subarray_sum(2, \"ABC\")\nTraceback (most recent call last):\n    ...\nValueError: numbers must be an iterable of integers"
  },
  {
    "function": "minimum_squares_to_represent_a_number",
    "code": "def minimum_squares_to_represent_a_number(number: int) -> int:\n    \"\"\"\n    Count the number of minimum squares to represent a number\n\n    >>> minimum_squares_to_represent_a_number(25)\n    1\n    >>> minimum_squares_to_represent_a_number(37)\n    2\n    >>> minimum_squares_to_represent_a_number(21)\n    3\n    >>> minimum_squares_to_represent_a_number(58)\n    2\n    >>> minimum_squares_to_represent_a_number(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must not be a negative number\n    >>> minimum_squares_to_represent_a_number(0)\n    1\n    >>> minimum_squares_to_represent_a_number(12.34)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must be a natural number\n    \"\"\"\n    if number != int(number):\n        raise ValueError(\"the value of input must be a natural number\")\n    if number < 0:\n        raise ValueError(\"the value of input must not be a negative number\")\n    if number == 0:\n        return 1\n    answers = [-1] * (number + 1)\n    answers[0] = 0\n    for i in range(1, number + 1):\n        answer = sys.maxsize\n        root = int(math.sqrt(i))\n        for j in range(1, root + 1):\n            current_answer = 1 + answers[i - (j**2)]\n            answer = min(answer, current_answer)\n        answers[i] = answer\n    return answers[number]",
    "docstring": "Count the number of minimum squares to represent a number\n\n>>> minimum_squares_to_represent_a_number(25)\n1\n>>> minimum_squares_to_represent_a_number(37)\n2\n>>> minimum_squares_to_represent_a_number(21)\n3\n>>> minimum_squares_to_represent_a_number(58)\n2\n>>> minimum_squares_to_represent_a_number(-1)\nTraceback (most recent call last):\n    ...\nValueError: the value of input must not be a negative number\n>>> minimum_squares_to_represent_a_number(0)\n1\n>>> minimum_squares_to_represent_a_number(12.34)\nTraceback (most recent call last):\n    ...\nValueError: the value of input must be a natural number"
  },
  {
    "function": "min_steps_to_one",
    "code": "def min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]",
    "docstring": "Minimum steps to 1 implemented using tabulation.\n>>> min_steps_to_one(10)\n3\n>>> min_steps_to_one(15)\n4\n>>> min_steps_to_one(6)\n2\n\n:param number:\n:return int:"
  },
  {
    "function": "mincost_tickets",
    "code": "def mincost_tickets(days: list[int], costs: list[int]) -> int:\n    \"\"\"\n    >>> mincost_tickets([1, 4, 6, 7, 8, 20], [2, 7, 15])\n    11\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31],  [2, 7, 15])\n    17\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    24\n\n    >>> mincost_tickets([2], [2, 90, 150])\n    2\n\n    >>> mincost_tickets([], [2, 90, 150])\n    0\n\n    >>> mincost_tickets('hello', [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter days should be a list of integers\n\n    >>> mincost_tickets([], 'world')\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([0.25, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter days should be a list of integers\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 0.9, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: All days elements should be greater than 0\n\n    >>> mincost_tickets([2, 367], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: All days elements should be less than 366\n\n    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([], [])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [1, 2, 3, 4])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n    \"\"\"\n\n    # Validation\n    if not isinstance(days, list) or not all(isinstance(day, int) for day in days):\n        raise ValueError(\"The parameter days should be a list of integers\")\n\n    if len(costs) != 3 or not all(isinstance(cost, int) for cost in costs):\n        raise ValueError(\"The parameter costs should be a list of three integers\")\n\n    if len(days) == 0:\n        return 0\n\n    if min(days) <= 0:\n        raise ValueError(\"All days elements should be greater than 0\")\n\n    if max(days) >= 366:\n        raise ValueError(\"All days elements should be less than 366\")\n\n    days_set = set(days)\n\n    @functools.cache\n    def dynamic_programming(index: int) -> int:\n        if index > 365:\n            return 0\n\n        if index not in days_set:\n            return dynamic_programming(index + 1)\n\n        return min(\n            costs[0] + dynamic_programming(index + 1),\n            costs[1] + dynamic_programming(index + 7),\n            costs[2] + dynamic_programming(index + 30),\n        )\n\n    return dynamic_programming(1)",
    "docstring": ">>> mincost_tickets([1, 4, 6, 7, 8, 20], [2, 7, 15])\n11\n\n>>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31],  [2, 7, 15])\n17\n\n>>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n24\n\n>>> mincost_tickets([2], [2, 90, 150])\n2\n\n>>> mincost_tickets([], [2, 90, 150])\n0\n\n>>> mincost_tickets('hello', [2, 90, 150])\nTraceback (most recent call last):\n ...\nValueError: The parameter days should be a list of integers\n\n>>> mincost_tickets([], 'world')\nTraceback (most recent call last):\n ...\nValueError: The parameter costs should be a list of three integers\n\n>>> mincost_tickets([0.25, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\nTraceback (most recent call last):\n ...\nValueError: The parameter days should be a list of integers\n\n>>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 0.9, 150])\nTraceback (most recent call last):\n ...\nValueError: The parameter costs should be a list of three integers\n\n>>> mincost_tickets([-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\nTraceback (most recent call last):\n ...\nValueError: All days elements should be greater than 0\n\n>>> mincost_tickets([2, 367], [2, 90, 150])\nTraceback (most recent call last):\n ...\nValueError: All days elements should be less than 366\n\n>>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [])\nTraceback (most recent call last):\n ...\nValueError: The parameter costs should be a list of three integers\n\n>>> mincost_tickets([], [])\nTraceback (most recent call last):\n ...\nValueError: The parameter costs should be a list of three integers\n\n>>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [1, 2, 3, 4])\nTraceback (most recent call last):\n ...\nValueError: The parameter costs should be a list of three integers"
  },
  {
    "function": "min_distance_up_bottom",
    "code": "def min_distance_up_bottom(word1: str, word2: str) -> int:\n    \"\"\"\n    >>> min_distance_up_bottom(\"intention\", \"execution\")\n    5\n    >>> min_distance_up_bottom(\"intention\", \"\")\n    9\n    >>> min_distance_up_bottom(\"\", \"\")\n    0\n    >>> min_distance_up_bottom(\"zooicoarchaeologist\", \"zoologist\")\n    10\n    \"\"\"\n    len_word1 = len(word1)\n    len_word2 = len(word2)\n\n    @functools.cache\n    def min_distance(index1: int, index2: int) -> int:\n        # if first word index overflows - delete all from the second word\n        if index1 >= len_word1:\n            return len_word2 - index2\n        # if second word index overflows - delete all from the first word\n        if index2 >= len_word2:\n            return len_word1 - index1\n        diff = int(word1[index1] != word2[index2])  # current letters not identical\n        return min(\n            1 + min_distance(index1 + 1, index2),\n            1 + min_distance(index1, index2 + 1),\n            diff + min_distance(index1 + 1, index2 + 1),\n        )\n\n    return min_distance(0, 0)",
    "docstring": ">>> min_distance_up_bottom(\"intention\", \"execution\")\n5\n>>> min_distance_up_bottom(\"intention\", \"\")\n9\n>>> min_distance_up_bottom(\"\", \"\")\n0\n>>> min_distance_up_bottom(\"zooicoarchaeologist\", \"zoologist\")\n10"
  },
  {
    "function": "print_binary_search_tree",
    "code": "def print_binary_search_tree(root, key, i, j, parent, is_left):\n    \"\"\"\n    Recursive function to print a BST from a root table.\n\n    >>> key = [3, 8, 9, 10, 17, 21]\n    >>> root = [[0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 3], [0, 0, 2, 3, 3, 3], \\\n                [0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 5]]\n    >>> print_binary_search_tree(root, key, 0, 5, -1, False)\n    8 is the root of the binary search tree.\n    3 is the left child of key 8.\n    10 is the right child of key 8.\n    9 is the left child of key 10.\n    21 is the right child of key 10.\n    17 is the left child of key 21.\n    \"\"\"\n    if i > j or i < 0 or j > len(root) - 1:\n        return\n\n    node = root[i][j]\n    if parent == -1:  # root does not have a parent\n        print(f\"{key[node]} is the root of the binary search tree.\")\n    elif is_left:\n        print(f\"{key[node]} is the left child of key {parent}.\")\n    else:\n        print(f\"{key[node]} is the right child of key {parent}.\")\n\n    print_binary_search_tree(root, key, i, node - 1, key[node], True)\n    print_binary_search_tree(root, key, node + 1, j, key[node], False)",
    "docstring": "Recursive function to print a BST from a root table.\n\n>>> key = [3, 8, 9, 10, 17, 21]\n>>> root = [[0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 3], [0, 0, 2, 3, 3, 3],                 [0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 5]]\n>>> print_binary_search_tree(root, key, 0, 5, -1, False)\n8 is the root of the binary search tree.\n3 is the left child of key 8.\n10 is the right child of key 8.\n9 is the left child of key 10.\n21 is the right child of key 10.\n17 is the left child of key 21."
  },
  {
    "function": "find_optimal_binary_search_tree",
    "code": "def find_optimal_binary_search_tree(nodes):\n    \"\"\"\n    This function calculates and prints the optimal binary search tree.\n    The dynamic programming algorithm below runs in O(n^2) time.\n    Implemented from CLRS (Introduction to Algorithms) book.\n    https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n\n    >>> find_optimal_binary_search_tree([Node(12, 8), Node(10, 34), Node(20, 50), \\\n                                         Node(42, 3), Node(25, 40), Node(37, 30)])\n    Binary search tree nodes:\n    Node(key=10, freq=34)\n    Node(key=12, freq=8)\n    Node(key=20, freq=50)\n    Node(key=25, freq=40)\n    Node(key=37, freq=30)\n    Node(key=42, freq=3)\n    <BLANKLINE>\n    The cost of optimal BST for given tree nodes is 324.\n    20 is the root of the binary search tree.\n    10 is the left child of key 20.\n    12 is the right child of key 10.\n    25 is the right child of key 20.\n    37 is the right child of key 25.\n    42 is the right child of key 37.\n    \"\"\"\n    # Tree nodes must be sorted first, the code below sorts the keys in\n    # increasing order and rearrange its frequencies accordingly.\n    nodes.sort(key=lambda node: node.key)\n\n    n = len(nodes)\n\n    keys = [nodes[i].key for i in range(n)]\n    freqs = [nodes[i].freq for i in range(n)]\n\n    # This 2D array stores the overall tree cost (which's as minimized as possible);\n    # for a single key, cost is equal to frequency of the key.\n    dp = [[freqs[i] if i == j else 0 for j in range(n)] for i in range(n)]\n    # sum[i][j] stores the sum of key frequencies between i and j inclusive in nodes\n    # array\n    total = [[freqs[i] if i == j else 0 for j in range(n)] for i in range(n)]\n    # stores tree roots that will be used later for constructing binary search tree\n    root = [[i if i == j else 0 for j in range(n)] for i in range(n)]\n\n    for interval_length in range(2, n + 1):\n        for i in range(n - interval_length + 1):\n            j = i + interval_length - 1\n\n            dp[i][j] = sys.maxsize  # set the value to \"infinity\"\n            total[i][j] = total[i][j - 1] + freqs[j]\n\n            # Apply Knuth's optimization\n            # Loop without optimization: for r in range(i, j + 1):\n            for r in range(root[i][j - 1], root[i + 1][j] + 1):  # r is a temporal root\n                left = dp[i][r - 1] if r != i else 0  # optimal cost for left subtree\n                right = dp[r + 1][j] if r != j else 0  # optimal cost for right subtree\n                cost = left + total[i][j] + right\n\n                if dp[i][j] > cost:\n                    dp[i][j] = cost\n                    root[i][j] = r\n\n    print(\"Binary search tree nodes:\")\n    for node in nodes:\n        print(node)\n\n    print(f\"\\nThe cost of optimal BST for given tree nodes is {dp[0][n - 1]}.\")\n    print_binary_search_tree(root, keys, 0, n - 1, -1, False)",
    "docstring": "This function calculates and prints the optimal binary search tree.\nThe dynamic programming algorithm below runs in O(n^2) time.\nImplemented from CLRS (Introduction to Algorithms) book.\nhttps://en.wikipedia.org/wiki/Introduction_to_Algorithms\n\n>>> find_optimal_binary_search_tree([Node(12, 8), Node(10, 34), Node(20, 50),                                          Node(42, 3), Node(25, 40), Node(37, 30)])\nBinary search tree nodes:\nNode(key=10, freq=34)\nNode(key=12, freq=8)\nNode(key=20, freq=50)\nNode(key=25, freq=40)\nNode(key=37, freq=30)\nNode(key=42, freq=3)\n<BLANKLINE>\nThe cost of optimal BST for given tree nodes is 324.\n20 is the root of the binary search tree.\n10 is the left child of key 20.\n12 is the right child of key 10.\n25 is the right child of key 20.\n37 is the right child of key 25.\n42 is the right child of key 37."
  },
  {
    "function": "find_minimum_partitions",
    "code": "def find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]",
    "docstring": "Returns the minimum cuts needed for a palindrome partitioning of string\n\n>>> find_minimum_partitions(\"aab\")\n1\n>>> find_minimum_partitions(\"aaa\")\n0\n>>> find_minimum_partitions(\"ababbbabbababa\")\n3"
  },
  {
    "function": "prefix_sum",
    "code": "def prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result",
    "docstring": ">>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n[81, 85, 63]\n>>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n[9, 9, 7]"
  },
  {
    "function": "recursive_match",
    "code": "def recursive_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Recursive matching algorithm.\n\n    | Time complexity: O(2^(\\|text\\| + \\|pattern\\|))\n    | Space complexity: Recursion depth is O(\\|text\\| + \\|pattern\\|).\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> recursive_match('abc', 'a.c')\n    True\n    >>> recursive_match('abc', 'af*.c')\n    True\n    >>> recursive_match('abc', 'a.c*')\n    True\n    >>> recursive_match('abc', 'a.c*d')\n    False\n    >>> recursive_match('aa', '.*')\n    True\n    \"\"\"\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False",
    "docstring": "Recursive matching algorithm.\n\n| Time complexity: O(2^(\\|text\\| + \\|pattern\\|))\n| Space complexity: Recursion depth is O(\\|text\\| + \\|pattern\\|).\n\n:param text: Text to match.\n:param pattern: Pattern to match.\n:return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n>>> recursive_match('abc', 'a.c')\nTrue\n>>> recursive_match('abc', 'af*.c')\nTrue\n>>> recursive_match('abc', 'a.c*')\nTrue\n>>> recursive_match('abc', 'a.c*d')\nFalse\n>>> recursive_match('aa', '.*')\nTrue"
  },
  {
    "function": "dp_match",
    "code": "def dp_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Dynamic programming matching algorithm.\n\n    | Time complexity: O(\\|text\\| * \\|pattern\\|)\n    | Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]",
    "docstring": "Dynamic programming matching algorithm.\n\n| Time complexity: O(\\|text\\| * \\|pattern\\|)\n| Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n:param text: Text to match.\n:param pattern: Pattern to match.\n:return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n>>> dp_match('abc', 'a.c')\nTrue\n>>> dp_match('abc', 'af*.c')\nTrue\n>>> dp_match('abc', 'a.c*')\nTrue\n>>> dp_match('abc', 'a.c*d')\nFalse\n>>> dp_match('aa', '.*')\nTrue"
  },
  {
    "function": "naive_cut_rod_recursive",
    "code": "def naive_cut_rod_recursive(n: int, prices: list):\n    \"\"\"\n    Solves the rod-cutting problem via naively without using the benefit of dynamic\n    programming. The results is the same sub-problems are solved several times\n    leading to an exponential runtime\n\n    Runtime: O(2^n)\n\n    Arguments\n    ---------\n\n    * `n`: int, the length of the rod\n    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n      price for a rod of length ``i``\n\n    Returns\n    -------\n\n    The maximum revenue obtainable for a rod of length `n` given the list of prices\n    for each piece.\n\n    Examples\n    --------\n\n    >>> naive_cut_rod_recursive(4, [1, 5, 8, 9])\n    10\n    >>> naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n    30\n    \"\"\"\n\n    _enforce_args(n, prices)\n    if n == 0:\n        return 0\n    max_revue = float(\"-inf\")\n    for i in range(1, n + 1):\n        max_revue = max(\n            max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)\n        )\n\n    return max_revue",
    "docstring": "Solves the rod-cutting problem via naively without using the benefit of dynamic\nprogramming. The results is the same sub-problems are solved several times\nleading to an exponential runtime\n\nRuntime: O(2^n)\n\nArguments\n---------\n\n* `n`: int, the length of the rod\n* `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n  price for a rod of length ``i``\n\nReturns\n-------\n\nThe maximum revenue obtainable for a rod of length `n` given the list of prices\nfor each piece.\n\nExamples\n--------\n\n>>> naive_cut_rod_recursive(4, [1, 5, 8, 9])\n10\n>>> naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n30"
  },
  {
    "function": "top_down_cut_rod",
    "code": "def top_down_cut_rod(n: int, prices: list):\n    \"\"\"\n    Constructs a top-down dynamic programming solution for the rod-cutting\n    problem via memoization. This function serves as a wrapper for\n    ``_top_down_cut_rod_recursive``\n\n    Runtime: O(n^2)\n\n    Arguments\n    ---------\n\n    * `n`: int, the length of the rod\n    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n      price for a rod of length ``i``\n\n    .. note::\n      For convenience and because Python's lists using ``0``-indexing, ``length(max_rev)\n      = n + 1``, to accommodate for the revenue obtainable from a rod of length ``0``.\n\n    Returns\n    -------\n\n    The maximum revenue obtainable for a rod of length `n` given the list of prices\n    for each piece.\n\n    Examples\n    --------\n\n    >>> top_down_cut_rod(4, [1, 5, 8, 9])\n    10\n    >>> top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n    30\n    \"\"\"\n    _enforce_args(n, prices)\n    max_rev = [float(\"-inf\") for _ in range(n + 1)]\n    return _top_down_cut_rod_recursive(n, prices, max_rev)",
    "docstring": "Constructs a top-down dynamic programming solution for the rod-cutting\nproblem via memoization. This function serves as a wrapper for\n``_top_down_cut_rod_recursive``\n\nRuntime: O(n^2)\n\nArguments\n---------\n\n* `n`: int, the length of the rod\n* `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n  price for a rod of length ``i``\n\n.. note::\n  For convenience and because Python's lists using ``0``-indexing, ``length(max_rev)\n  = n + 1``, to accommodate for the revenue obtainable from a rod of length ``0``.\n\nReturns\n-------\n\nThe maximum revenue obtainable for a rod of length `n` given the list of prices\nfor each piece.\n\nExamples\n--------\n\n>>> top_down_cut_rod(4, [1, 5, 8, 9])\n10\n>>> top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n30"
  },
  {
    "function": "_top_down_cut_rod_recursive",
    "code": "def _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):\n    \"\"\"\n    Constructs a top-down dynamic programming solution for the rod-cutting problem\n    via memoization.\n\n    Runtime: O(n^2)\n\n    Arguments\n    ---------\n\n    * `n`: int, the length of the rod\n    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n      price for a rod of length ``i``\n    * `max_rev`: list, the computed maximum revenue for a piece of rod.\n      ``max_rev[i]`` is the maximum revenue obtainable for a rod of length ``i``\n\n    Returns\n    -------\n\n    The maximum revenue obtainable for a rod of length `n` given the list of prices\n    for each piece.\n    \"\"\"\n    if max_rev[n] >= 0:\n        return max_rev[n]\n    elif n == 0:\n        return 0\n    else:\n        max_revenue = float(\"-inf\")\n        for i in range(1, n + 1):\n            max_revenue = max(\n                max_revenue,\n                prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),\n            )\n\n        max_rev[n] = max_revenue\n\n    return max_rev[n]",
    "docstring": "Constructs a top-down dynamic programming solution for the rod-cutting problem\nvia memoization.\n\nRuntime: O(n^2)\n\nArguments\n---------\n\n* `n`: int, the length of the rod\n* `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n  price for a rod of length ``i``\n* `max_rev`: list, the computed maximum revenue for a piece of rod.\n  ``max_rev[i]`` is the maximum revenue obtainable for a rod of length ``i``\n\nReturns\n-------\n\nThe maximum revenue obtainable for a rod of length `n` given the list of prices\nfor each piece."
  },
  {
    "function": "bottom_up_cut_rod",
    "code": "def bottom_up_cut_rod(n: int, prices: list):\n    \"\"\"\n    Constructs a bottom-up dynamic programming solution for the rod-cutting problem\n\n    Runtime: O(n^2)\n\n    Arguments\n    ---------\n\n    * `n`: int, the maximum length of the rod.\n    * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n      price for a rod of length ``i``\n\n    Returns\n    -------\n\n    The maximum revenue obtainable from cutting a rod of length `n` given\n    the prices for each piece of rod p.\n\n    Examples\n    --------\n\n    >>> bottom_up_cut_rod(4, [1, 5, 8, 9])\n    10\n    >>> bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n    30\n    \"\"\"\n    _enforce_args(n, prices)\n\n    # length(max_rev) = n + 1, to accommodate for the revenue obtainable from a rod of\n    # length 0.\n    max_rev = [float(\"-inf\") for _ in range(n + 1)]\n    max_rev[0] = 0\n\n    for i in range(1, n + 1):\n        max_revenue_i = max_rev[i]\n        for j in range(1, i + 1):\n            max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])\n\n        max_rev[i] = max_revenue_i\n\n    return max_rev[n]",
    "docstring": "Constructs a bottom-up dynamic programming solution for the rod-cutting problem\n\nRuntime: O(n^2)\n\nArguments\n---------\n\n* `n`: int, the maximum length of the rod.\n* `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the\n  price for a rod of length ``i``\n\nReturns\n-------\n\nThe maximum revenue obtainable from cutting a rod of length `n` given\nthe prices for each piece of rod p.\n\nExamples\n--------\n\n>>> bottom_up_cut_rod(4, [1, 5, 8, 9])\n10\n>>> bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n30"
  },
  {
    "function": "_enforce_args",
    "code": "def _enforce_args(n: int, prices: list):\n    \"\"\"\n    Basic checks on the arguments to the rod-cutting algorithms\n\n    * `n`: int, the length of the rod\n    * `prices`: list, the price list for each piece of rod.\n\n    Throws ``ValueError``:\n        if `n` is negative or there are fewer items in the price list than the length of\n        the rod\n    \"\"\"\n    if n < 0:\n        msg = f\"n must be greater than or equal to 0. Got n = {n}\"\n        raise ValueError(msg)\n\n    if n > len(prices):\n        msg = (\n            \"Each integral piece of rod must have a corresponding price. \"\n            f\"Got n = {n} but length of prices = {len(prices)}\"\n        )\n        raise ValueError(msg)",
    "docstring": "Basic checks on the arguments to the rod-cutting algorithms\n\n* `n`: int, the length of the rod\n* `prices`: list, the price list for each piece of rod.\n\nThrows ``ValueError``:\n    if `n` is negative or there are fewer items in the price list than the length of\n    the rod"
  },
  {
    "function": "score_function",
    "code": "def score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch",
    "docstring": "Calculate the score for a character pair based on whether they match or mismatch.\nReturns 1 if the characters match, -1 if they mismatch, and -2 if either of the\ncharacters is a gap.\n>>> score_function('A', 'A')\n1\n>>> score_function('A', 'C')\n-1\n>>> score_function('-', 'A')\n-2\n>>> score_function('A', '-')\n-2\n>>> score_function('-', '-')\n-2"
  },
  {
    "function": "smith_waterman",
    "code": "def smith_waterman(\n    query: str,\n    subject: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> list[list[int]]:\n    \"\"\"\n    Perform the Smith-Waterman local sequence alignment algorithm.\n    Returns a 2D list representing the score matrix. Each value in the matrix\n    corresponds to the score of the best local alignment ending at that point.\n    >>> smith_waterman('ACAC', 'CA')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n    >>> smith_waterman('acac', 'ca')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n    >>> smith_waterman('ACAC', 'ca')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n    >>> smith_waterman('acac', 'CA')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n    >>> smith_waterman('ACAC', '')\n    [[0], [0], [0], [0], [0]]\n    >>> smith_waterman('', 'CA')\n    [[0, 0, 0]]\n    >>> smith_waterman('ACAC', 'CA')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n    >>> smith_waterman('acac', 'ca')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n    >>> smith_waterman('ACAC', 'ca')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n    >>> smith_waterman('acac', 'CA')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n    >>> smith_waterman('ACAC', '')\n    [[0], [0], [0], [0], [0]]\n\n    >>> smith_waterman('', 'CA')\n    [[0, 0, 0]]\n\n    >>> smith_waterman('AGT', 'AGT')\n    [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\n\n    >>> smith_waterman('AGT', 'GTA')\n    [[0, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 2, 0]]\n\n    >>> smith_waterman('AGT', 'GTC')\n    [[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0]]\n\n    >>> smith_waterman('AGT', 'G')\n    [[0, 0], [0, 0], [0, 1], [0, 0]]\n\n    >>> smith_waterman('G', 'AGT')\n    [[0, 0, 0, 0], [0, 0, 1, 0]]\n\n    >>> smith_waterman('AGT', 'AGTCT')\n    [[0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0], [0, 0, 0, 3, 1, 1]]\n\n    >>> smith_waterman('AGTCT', 'AGT')\n    [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 0, 1], [0, 0, 0, 1]]\n\n    >>> smith_waterman('AGTCT', 'GTC')\n    [[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 1, 1]]\n    \"\"\"\n    # make both query and subject uppercase\n    query = query.upper()\n    subject = subject.upper()\n\n    # Initialize score matrix\n    m = len(query)\n    n = len(subject)\n    score = [[0] * (n + 1) for _ in range(m + 1)]\n    kwargs = {\"match\": match, \"mismatch\": mismatch, \"gap\": gap}\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # Calculate scores for each cell\n            match = score[i - 1][j - 1] + score_function(\n                query[i - 1], subject[j - 1], **kwargs\n            )\n            delete = score[i - 1][j] + gap\n            insert = score[i][j - 1] + gap\n\n            # Take maximum score\n            score[i][j] = max(0, match, delete, insert)\n\n    return score",
    "docstring": "Perform the Smith-Waterman local sequence alignment algorithm.\nReturns a 2D list representing the score matrix. Each value in the matrix\ncorresponds to the score of the best local alignment ending at that point.\n>>> smith_waterman('ACAC', 'CA')\n[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n>>> smith_waterman('acac', 'ca')\n[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n>>> smith_waterman('ACAC', 'ca')\n[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n>>> smith_waterman('acac', 'CA')\n[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n>>> smith_waterman('ACAC', '')\n[[0], [0], [0], [0], [0]]\n>>> smith_waterman('', 'CA')\n[[0, 0, 0]]\n>>> smith_waterman('ACAC', 'CA')\n[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n>>> smith_waterman('acac', 'ca')\n[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n>>> smith_waterman('ACAC', 'ca')\n[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n>>> smith_waterman('acac', 'CA')\n[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n>>> smith_waterman('ACAC', '')\n[[0], [0], [0], [0], [0]]\n\n>>> smith_waterman('', 'CA')\n[[0, 0, 0]]\n\n>>> smith_waterman('AGT', 'AGT')\n[[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\n\n>>> smith_waterman('AGT', 'GTA')\n[[0, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 2, 0]]\n\n>>> smith_waterman('AGT', 'GTC')\n[[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0]]\n\n>>> smith_waterman('AGT', 'G')\n[[0, 0], [0, 0], [0, 1], [0, 0]]\n\n>>> smith_waterman('G', 'AGT')\n[[0, 0, 0, 0], [0, 0, 1, 0]]\n\n>>> smith_waterman('AGT', 'AGTCT')\n[[0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0], [0, 0, 0, 3, 1, 1]]\n\n>>> smith_waterman('AGTCT', 'AGT')\n[[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 0, 1], [0, 0, 0, 1]]\n\n>>> smith_waterman('AGTCT', 'GTC')\n[[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 1, 1]]"
  },
  {
    "function": "traceback",
    "code": "def traceback(score: list[list[int]], query: str, subject: str) -> str:\n    r\"\"\"\n    Perform traceback to find the optimal local alignment.\n    Starts from the highest scoring cell in the matrix and traces back recursively\n    until a 0 score is found. Returns the alignment strings.\n    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'CA')\n    'CA\\nCA'\n    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'ca')\n    'CA\\nCA'\n    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'ca')\n    'CA\\nCA'\n    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'CA')\n    'CA\\nCA'\n    >>> traceback([[0, 0, 0]], 'ACAC', '')\n    ''\n    \"\"\"\n    # make both query and subject uppercase\n    query = query.upper()\n    subject = subject.upper()\n    # find the indices of the maximum value in the score matrix\n    max_value = float(\"-inf\")\n    i_max = j_max = 0\n    for i, row in enumerate(score):\n        for j, value in enumerate(row):\n            if value > max_value:\n                max_value = value\n                i_max, j_max = i, j\n    # Traceback logic to find optimal alignment\n    i = i_max\n    j = j_max\n    align1 = \"\"\n    align2 = \"\"\n    gap = score_function(\"-\", \"-\")\n    # guard against empty query or subject\n    if i == 0 or j == 0:\n        return \"\"\n    while i > 0 and j > 0:\n        if score[i][j] == score[i - 1][j - 1] + score_function(\n            query[i - 1], subject[j - 1]\n        ):\n            # optimal path is a diagonal take both letters\n            align1 = query[i - 1] + align1\n            align2 = subject[j - 1] + align2\n            i -= 1\n            j -= 1\n        elif score[i][j] == score[i - 1][j] + gap:\n            # optimal path is a vertical\n            align1 = query[i - 1] + align1\n            align2 = f\"-{align2}\"\n            i -= 1\n        else:\n            # optimal path is a horizontal\n            align1 = f\"-{align1}\"\n            align2 = subject[j - 1] + align2\n            j -= 1\n\n    return f\"{align1}\\n{align2}\"",
    "docstring": "Perform traceback to find the optimal local alignment.\nStarts from the highest scoring cell in the matrix and traces back recursively\nuntil a 0 score is found. Returns the alignment strings.\n>>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'CA')\n'CA\\nCA'\n>>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'ca')\n'CA\\nCA'\n>>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'ca')\n'CA\\nCA'\n>>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'CA')\n'CA\\nCA'\n>>> traceback([[0, 0, 0]], 'ACAC', '')\n''"
  },
  {
    "function": "subset_combinations",
    "code": "def subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n\n    Args:\n        * `elements`: The list of elements from which combinations will be generated.\n        * `n`: The number of elements in each combination.\n\n    Returns:\n        A list of tuples, each representing a combination of `n` elements.\n\n    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n    >>> subset_combinations(elements=[1, 2, 3], n=1)\n    [(1,), (2,), (3,)]\n    >>> subset_combinations(elements=[1, 2, 3], n=3)\n    [(1, 2, 3)]\n    >>> subset_combinations(elements=[42], n=1)\n    [(42,)]\n    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n    [(6, 7, 8, 9)]\n    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n    [()]\n    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n    >>> subset_combinations(elements=['single'], n=0)\n    [()]\n    >>> subset_combinations(elements=[], n=9)\n    []\n    >>> from itertools import combinations\n    >>> all(subset_combinations(items, n) == list(combinations(items, n))\n    ...     for items, n in (\n    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n    True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]",
    "docstring": "Compute n-element combinations from a given list using dynamic programming.\n\nArgs:\n    * `elements`: The list of elements from which combinations will be generated.\n    * `n`: The number of elements in each combination.\n\nReturns:\n    A list of tuples, each representing a combination of `n` elements.\n\n>>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n[(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n>>> subset_combinations(elements=[1, 2, 3], n=1)\n[(1,), (2,), (3,)]\n>>> subset_combinations(elements=[1, 2, 3], n=3)\n[(1, 2, 3)]\n>>> subset_combinations(elements=[42], n=1)\n[(42,)]\n>>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n[(6, 7, 8, 9)]\n>>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n[()]\n>>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n[(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n>>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n[(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n>>> subset_combinations(elements=['single'], n=0)\n[()]\n>>> subset_combinations(elements=[], n=9)\n[]\n>>> from itertools import combinations\n>>> all(subset_combinations(items, n) == list(combinations(items, n))\n...     for items, n in (\n...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\nTrue"
  },
  {
    "function": "is_sum_subset",
    "code": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    return subset[arr_len][required_sum]",
    "docstring": ">>> is_sum_subset([2, 4, 6, 8], 5)\nFalse\n>>> is_sum_subset([2, 4, 6, 8], 14)\nTrue"
  },
  {
    "function": "trapped_rainwater",
    "code": "def trapped_rainwater(heights: tuple[int, ...]) -> int:\n    \"\"\"\n    The trapped_rainwater function calculates the total amount of rainwater that can be\n    trapped given an array of bar heights.\n    It uses a dynamic programming approach, determining the maximum height of bars on\n    both sides for each bar, and then computing the trapped water above each bar.\n    The function returns the total trapped water.\n\n    >>> trapped_rainwater((0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1))\n    6\n    >>> trapped_rainwater((7, 1, 5, 3, 6, 4))\n    9\n    >>> trapped_rainwater((7, 1, 5, 3, 6, -1))\n    Traceback (most recent call last):\n        ...\n    ValueError: No height can be negative\n    \"\"\"\n    if not heights:\n        return 0\n    if any(h < 0 for h in heights):\n        raise ValueError(\"No height can be negative\")\n    length = len(heights)\n\n    left_max = [0] * length\n    left_max[0] = heights[0]\n    for i, height in enumerate(heights[1:], start=1):\n        left_max[i] = max(height, left_max[i - 1])\n\n    right_max = [0] * length\n    right_max[-1] = heights[-1]\n    for i in range(length - 2, -1, -1):\n        right_max[i] = max(heights[i], right_max[i + 1])\n\n    return sum(\n        min(left, right) - height\n        for left, right, height in zip(left_max, right_max, heights)\n    )",
    "docstring": "The trapped_rainwater function calculates the total amount of rainwater that can be\ntrapped given an array of bar heights.\nIt uses a dynamic programming approach, determining the maximum height of bars on\nboth sides for each bar, and then computing the trapped water above each bar.\nThe function returns the total trapped water.\n\n>>> trapped_rainwater((0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1))\n6\n>>> trapped_rainwater((7, 1, 5, 3, 6, 4))\n9\n>>> trapped_rainwater((7, 1, 5, 3, 6, -1))\nTraceback (most recent call last):\n    ...\nValueError: No height can be negative"
  },
  {
    "function": "tribonacci",
    "code": "def tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp",
    "docstring": "Given a number, return first n Tribonacci Numbers.\n>>> tribonacci(5)\n[0, 0, 1, 1, 2]\n>>> tribonacci(8)\n[0, 0, 1, 1, 2, 4, 7, 13]"
  },
  {
    "function": "viterbi",
    "code": "def viterbi(\n    observations_space: list,\n    states_space: list,\n    initial_probabilities: dict,\n    transition_probabilities: dict,\n    emission_probabilities: dict,\n) -> list:\n    \"\"\"\n    Viterbi Algorithm, to find the most likely path of\n    states from the start and the expected output.\n\n    https://en.wikipedia.org/wiki/Viterbi_algorithm\n\n    Wikipedia example\n\n    >>> observations = [\"normal\", \"cold\", \"dizzy\"]\n    >>> states = [\"Healthy\", \"Fever\"]\n    >>> start_p = {\"Healthy\": 0.6, \"Fever\": 0.4}\n    >>> trans_p = {\n    ...     \"Healthy\": {\"Healthy\": 0.7, \"Fever\": 0.3},\n    ...     \"Fever\": {\"Healthy\": 0.4, \"Fever\": 0.6},\n    ... }\n    >>> emit_p = {\n    ...     \"Healthy\": {\"normal\": 0.5, \"cold\": 0.4, \"dizzy\": 0.1},\n    ...     \"Fever\": {\"normal\": 0.1, \"cold\": 0.3, \"dizzy\": 0.6},\n    ... }\n    >>> viterbi(observations, states, start_p, trans_p, emit_p)\n    ['Healthy', 'Healthy', 'Fever']\n    >>> viterbi((), states, start_p, trans_p, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: There's an empty parameter\n    >>> viterbi(observations, (), start_p, trans_p, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: There's an empty parameter\n    >>> viterbi(observations, states, {}, trans_p, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: There's an empty parameter\n    >>> viterbi(observations, states, start_p, {}, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: There's an empty parameter\n    >>> viterbi(observations, states, start_p, trans_p, {})\n    Traceback (most recent call last):\n        ...\n    ValueError: There's an empty parameter\n    >>> viterbi(\"invalid\", states, start_p, trans_p, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: observations_space must be a list\n    >>> viterbi([\"valid\", 123], states, start_p, trans_p, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: observations_space must be a list of strings\n    >>> viterbi(observations, \"invalid\", start_p, trans_p, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: states_space must be a list\n    >>> viterbi(observations, [\"valid\", 123], start_p, trans_p, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: states_space must be a list of strings\n    >>> viterbi(observations, states, \"invalid\", trans_p, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: initial_probabilities must be a dict\n    >>> viterbi(observations, states, {2:2}, trans_p, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: initial_probabilities all keys must be strings\n    >>> viterbi(observations, states, {\"a\":2}, trans_p, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: initial_probabilities all values must be float\n    >>> viterbi(observations, states, start_p, \"invalid\", emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: transition_probabilities must be a dict\n    >>> viterbi(observations, states, start_p, {\"a\":2}, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: transition_probabilities all values must be dict\n    >>> viterbi(observations, states, start_p, {2:{2:2}}, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: transition_probabilities all keys must be strings\n    >>> viterbi(observations, states, start_p, {\"a\":{2:2}}, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: transition_probabilities all keys must be strings\n    >>> viterbi(observations, states, start_p, {\"a\":{\"b\":2}}, emit_p)\n    Traceback (most recent call last):\n        ...\n    ValueError: transition_probabilities nested dictionary all values must be float\n    >>> viterbi(observations, states, start_p, trans_p, \"invalid\")\n    Traceback (most recent call last):\n        ...\n    ValueError: emission_probabilities must be a dict\n    >>> viterbi(observations, states, start_p, trans_p, None)\n    Traceback (most recent call last):\n        ...\n    ValueError: There's an empty parameter\n\n    \"\"\"\n    _validation(\n        observations_space,\n        states_space,\n        initial_probabilities,\n        transition_probabilities,\n        emission_probabilities,\n    )\n    # Creates data structures and fill initial step\n    probabilities: dict = {}\n    pointers: dict = {}\n    for state in states_space:\n        observation = observations_space[0]\n        probabilities[(state, observation)] = (\n            initial_probabilities[state] * emission_probabilities[state][observation]\n        )\n        pointers[(state, observation)] = None\n\n    # Fills the data structure with the probabilities of\n    # different transitions and pointers to previous states\n    for o in range(1, len(observations_space)):\n        observation = observations_space[o]\n        prior_observation = observations_space[o - 1]\n        for state in states_space:\n            # Calculates the argmax for probability function\n            arg_max = \"\"\n            max_probability = -1\n            for k_state in states_space:\n                probability = (\n                    probabilities[(k_state, prior_observation)]\n                    * transition_probabilities[k_state][state]\n                    * emission_probabilities[state][observation]\n                )\n                if probability > max_probability:\n                    max_probability = probability\n                    arg_max = k_state\n\n            # Update probabilities and pointers dicts\n            probabilities[(state, observation)] = (\n                probabilities[(arg_max, prior_observation)]\n                * transition_probabilities[arg_max][state]\n                * emission_probabilities[state][observation]\n            )\n\n            pointers[(state, observation)] = arg_max\n\n    # The final observation\n    final_observation = observations_space[len(observations_space) - 1]\n\n    # argmax for given final observation\n    arg_max = \"\"\n    max_probability = -1\n    for k_state in states_space:\n        probability = probabilities[(k_state, final_observation)]\n        if probability > max_probability:\n            max_probability = probability\n            arg_max = k_state\n    last_state = arg_max\n\n    # Process pointers backwards\n    previous = last_state\n    result = []\n    for o in range(len(observations_space) - 1, -1, -1):\n        result.append(previous)\n        previous = pointers[previous, observations_space[o]]\n    result.reverse()\n\n    return result",
    "docstring": "Viterbi Algorithm, to find the most likely path of\nstates from the start and the expected output.\n\nhttps://en.wikipedia.org/wiki/Viterbi_algorithm\n\nWikipedia example\n\n>>> observations = [\"normal\", \"cold\", \"dizzy\"]\n>>> states = [\"Healthy\", \"Fever\"]\n>>> start_p = {\"Healthy\": 0.6, \"Fever\": 0.4}\n>>> trans_p = {\n...     \"Healthy\": {\"Healthy\": 0.7, \"Fever\": 0.3},\n...     \"Fever\": {\"Healthy\": 0.4, \"Fever\": 0.6},\n... }\n>>> emit_p = {\n...     \"Healthy\": {\"normal\": 0.5, \"cold\": 0.4, \"dizzy\": 0.1},\n...     \"Fever\": {\"normal\": 0.1, \"cold\": 0.3, \"dizzy\": 0.6},\n... }\n>>> viterbi(observations, states, start_p, trans_p, emit_p)\n['Healthy', 'Healthy', 'Fever']\n>>> viterbi((), states, start_p, trans_p, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: There's an empty parameter\n>>> viterbi(observations, (), start_p, trans_p, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: There's an empty parameter\n>>> viterbi(observations, states, {}, trans_p, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: There's an empty parameter\n>>> viterbi(observations, states, start_p, {}, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: There's an empty parameter\n>>> viterbi(observations, states, start_p, trans_p, {})\nTraceback (most recent call last):\n    ...\nValueError: There's an empty parameter\n>>> viterbi(\"invalid\", states, start_p, trans_p, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: observations_space must be a list\n>>> viterbi([\"valid\", 123], states, start_p, trans_p, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: observations_space must be a list of strings\n>>> viterbi(observations, \"invalid\", start_p, trans_p, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: states_space must be a list\n>>> viterbi(observations, [\"valid\", 123], start_p, trans_p, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: states_space must be a list of strings\n>>> viterbi(observations, states, \"invalid\", trans_p, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: initial_probabilities must be a dict\n>>> viterbi(observations, states, {2:2}, trans_p, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: initial_probabilities all keys must be strings\n>>> viterbi(observations, states, {\"a\":2}, trans_p, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: initial_probabilities all values must be float\n>>> viterbi(observations, states, start_p, \"invalid\", emit_p)\nTraceback (most recent call last):\n    ...\nValueError: transition_probabilities must be a dict\n>>> viterbi(observations, states, start_p, {\"a\":2}, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: transition_probabilities all values must be dict\n>>> viterbi(observations, states, start_p, {2:{2:2}}, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: transition_probabilities all keys must be strings\n>>> viterbi(observations, states, start_p, {\"a\":{2:2}}, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: transition_probabilities all keys must be strings\n>>> viterbi(observations, states, start_p, {\"a\":{\"b\":2}}, emit_p)\nTraceback (most recent call last):\n    ...\nValueError: transition_probabilities nested dictionary all values must be float\n>>> viterbi(observations, states, start_p, trans_p, \"invalid\")\nTraceback (most recent call last):\n    ...\nValueError: emission_probabilities must be a dict\n>>> viterbi(observations, states, start_p, trans_p, None)\nTraceback (most recent call last):\n    ...\nValueError: There's an empty parameter"
  },
  {
    "function": "_validation",
    "code": "def _validation(\n    observations_space: Any,\n    states_space: Any,\n    initial_probabilities: Any,\n    transition_probabilities: Any,\n    emission_probabilities: Any,\n) -> None:\n    \"\"\"\n    >>> observations = [\"normal\", \"cold\", \"dizzy\"]\n    >>> states = [\"Healthy\", \"Fever\"]\n    >>> start_p = {\"Healthy\": 0.6, \"Fever\": 0.4}\n    >>> trans_p = {\n    ...     \"Healthy\": {\"Healthy\": 0.7, \"Fever\": 0.3},\n    ...     \"Fever\": {\"Healthy\": 0.4, \"Fever\": 0.6},\n    ... }\n    >>> emit_p = {\n    ...     \"Healthy\": {\"normal\": 0.5, \"cold\": 0.4, \"dizzy\": 0.1},\n    ...     \"Fever\": {\"normal\": 0.1, \"cold\": 0.3, \"dizzy\": 0.6},\n    ... }\n    >>> _validation(observations, states, start_p, trans_p, emit_p)\n    >>> _validation([], states, start_p, trans_p, emit_p)\n    Traceback (most recent call last):\n            ...\n    ValueError: There's an empty parameter\n    \"\"\"\n    _validate_not_empty(\n        observations_space,\n        states_space,\n        initial_probabilities,\n        transition_probabilities,\n        emission_probabilities,\n    )\n    _validate_lists(observations_space, states_space)\n    _validate_dicts(\n        initial_probabilities, transition_probabilities, emission_probabilities\n    )",
    "docstring": ">>> observations = [\"normal\", \"cold\", \"dizzy\"]\n>>> states = [\"Healthy\", \"Fever\"]\n>>> start_p = {\"Healthy\": 0.6, \"Fever\": 0.4}\n>>> trans_p = {\n...     \"Healthy\": {\"Healthy\": 0.7, \"Fever\": 0.3},\n...     \"Fever\": {\"Healthy\": 0.4, \"Fever\": 0.6},\n... }\n>>> emit_p = {\n...     \"Healthy\": {\"normal\": 0.5, \"cold\": 0.4, \"dizzy\": 0.1},\n...     \"Fever\": {\"normal\": 0.1, \"cold\": 0.3, \"dizzy\": 0.6},\n... }\n>>> _validation(observations, states, start_p, trans_p, emit_p)\n>>> _validation([], states, start_p, trans_p, emit_p)\nTraceback (most recent call last):\n        ...\nValueError: There's an empty parameter"
  },
  {
    "function": "_validate_not_empty",
    "code": "def _validate_not_empty(\n    observations_space: Any,\n    states_space: Any,\n    initial_probabilities: Any,\n    transition_probabilities: Any,\n    emission_probabilities: Any,\n) -> None:\n    \"\"\"\n    >>> _validate_not_empty([\"a\"], [\"b\"], {\"c\":0.5},\n    ... {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n    >>> _validate_not_empty([\"a\"], [\"b\"], {\"c\":0.5}, {}, {\"f\": {\"g\": 0.7}})\n    Traceback (most recent call last):\n            ...\n    ValueError: There's an empty parameter\n    >>> _validate_not_empty([\"a\"], [\"b\"], None, {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n    Traceback (most recent call last):\n            ...\n    ValueError: There's an empty parameter\n    \"\"\"\n    if not all(\n        [\n            observations_space,\n            states_space,\n            initial_probabilities,\n            transition_probabilities,\n            emission_probabilities,\n        ]\n    ):\n        raise ValueError(\"There's an empty parameter\")",
    "docstring": ">>> _validate_not_empty([\"a\"], [\"b\"], {\"c\":0.5},\n... {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n>>> _validate_not_empty([\"a\"], [\"b\"], {\"c\":0.5}, {}, {\"f\": {\"g\": 0.7}})\nTraceback (most recent call last):\n        ...\nValueError: There's an empty parameter\n>>> _validate_not_empty([\"a\"], [\"b\"], None, {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\nTraceback (most recent call last):\n        ...\nValueError: There's an empty parameter"
  },
  {
    "function": "_validate_lists",
    "code": "def _validate_lists(observations_space: Any, states_space: Any) -> None:\n    \"\"\"\n    >>> _validate_lists([\"a\"], [\"b\"])\n    >>> _validate_lists(1234, [\"b\"])\n    Traceback (most recent call last):\n            ...\n    ValueError: observations_space must be a list\n    >>> _validate_lists([\"a\"], [3])\n    Traceback (most recent call last):\n            ...\n    ValueError: states_space must be a list of strings\n    \"\"\"\n    _validate_list(observations_space, \"observations_space\")\n    _validate_list(states_space, \"states_space\")",
    "docstring": ">>> _validate_lists([\"a\"], [\"b\"])\n>>> _validate_lists(1234, [\"b\"])\nTraceback (most recent call last):\n        ...\nValueError: observations_space must be a list\n>>> _validate_lists([\"a\"], [3])\nTraceback (most recent call last):\n        ...\nValueError: states_space must be a list of strings"
  },
  {
    "function": "_validate_list",
    "code": "def _validate_list(_object: Any, var_name: str) -> None:\n    \"\"\"\n    >>> _validate_list([\"a\"], \"mock_name\")\n    >>> _validate_list(\"a\", \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name must be a list\n    >>> _validate_list([0.5], \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name must be a list of strings\n    \"\"\"\n    if not isinstance(_object, list):\n        msg = f\"{var_name} must be a list\"\n        raise ValueError(msg)\n    else:\n        for x in _object:\n            if not isinstance(x, str):\n                msg = f\"{var_name} must be a list of strings\"\n                raise ValueError(msg)",
    "docstring": ">>> _validate_list([\"a\"], \"mock_name\")\n>>> _validate_list(\"a\", \"mock_name\")\nTraceback (most recent call last):\n        ...\nValueError: mock_name must be a list\n>>> _validate_list([0.5], \"mock_name\")\nTraceback (most recent call last):\n        ...\nValueError: mock_name must be a list of strings"
  },
  {
    "function": "_validate_dicts",
    "code": "def _validate_dicts(\n    initial_probabilities: Any,\n    transition_probabilities: Any,\n    emission_probabilities: Any,\n) -> None:\n    \"\"\"\n    >>> _validate_dicts({\"c\":0.5}, {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n    >>> _validate_dicts(\"invalid\", {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n    Traceback (most recent call last):\n            ...\n    ValueError: initial_probabilities must be a dict\n    >>> _validate_dicts({\"c\":0.5}, {2: {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n    Traceback (most recent call last):\n            ...\n    ValueError: transition_probabilities all keys must be strings\n    >>> _validate_dicts({\"c\":0.5}, {\"d\": {\"e\": 0.6}}, {\"f\": {2: 0.7}})\n    Traceback (most recent call last):\n            ...\n    ValueError: emission_probabilities all keys must be strings\n    >>> _validate_dicts({\"c\":0.5}, {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": \"h\"}})\n    Traceback (most recent call last):\n            ...\n    ValueError: emission_probabilities nested dictionary all values must be float\n    \"\"\"\n    _validate_dict(initial_probabilities, \"initial_probabilities\", float)\n    _validate_nested_dict(transition_probabilities, \"transition_probabilities\")\n    _validate_nested_dict(emission_probabilities, \"emission_probabilities\")",
    "docstring": ">>> _validate_dicts({\"c\":0.5}, {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n>>> _validate_dicts(\"invalid\", {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\nTraceback (most recent call last):\n        ...\nValueError: initial_probabilities must be a dict\n>>> _validate_dicts({\"c\":0.5}, {2: {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\nTraceback (most recent call last):\n        ...\nValueError: transition_probabilities all keys must be strings\n>>> _validate_dicts({\"c\":0.5}, {\"d\": {\"e\": 0.6}}, {\"f\": {2: 0.7}})\nTraceback (most recent call last):\n        ...\nValueError: emission_probabilities all keys must be strings\n>>> _validate_dicts({\"c\":0.5}, {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": \"h\"}})\nTraceback (most recent call last):\n        ...\nValueError: emission_probabilities nested dictionary all values must be float"
  },
  {
    "function": "_validate_nested_dict",
    "code": "def _validate_nested_dict(_object: Any, var_name: str) -> None:\n    \"\"\"\n    >>> _validate_nested_dict({\"a\":{\"b\": 0.5}}, \"mock_name\")\n    >>> _validate_nested_dict(\"invalid\", \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name must be a dict\n    >>> _validate_nested_dict({\"a\": 8}, \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name all values must be dict\n    >>> _validate_nested_dict({\"a\":{2: 0.5}}, \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name all keys must be strings\n    >>> _validate_nested_dict({\"a\":{\"b\": 4}}, \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name nested dictionary all values must be float\n    \"\"\"\n    _validate_dict(_object, var_name, dict)\n    for x in _object.values():\n        _validate_dict(x, var_name, float, True)",
    "docstring": ">>> _validate_nested_dict({\"a\":{\"b\": 0.5}}, \"mock_name\")\n>>> _validate_nested_dict(\"invalid\", \"mock_name\")\nTraceback (most recent call last):\n        ...\nValueError: mock_name must be a dict\n>>> _validate_nested_dict({\"a\": 8}, \"mock_name\")\nTraceback (most recent call last):\n        ...\nValueError: mock_name all values must be dict\n>>> _validate_nested_dict({\"a\":{2: 0.5}}, \"mock_name\")\nTraceback (most recent call last):\n        ...\nValueError: mock_name all keys must be strings\n>>> _validate_nested_dict({\"a\":{\"b\": 4}}, \"mock_name\")\nTraceback (most recent call last):\n        ...\nValueError: mock_name nested dictionary all values must be float"
  },
  {
    "function": "_validate_dict",
    "code": "def _validate_dict(\n    _object: Any, var_name: str, value_type: type, nested: bool = False\n) -> None:\n    \"\"\"\n    >>> _validate_dict({\"b\": 0.5}, \"mock_name\", float)\n    >>> _validate_dict(\"invalid\", \"mock_name\", float)\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name must be a dict\n    >>> _validate_dict({\"a\": 8}, \"mock_name\", dict)\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name all values must be dict\n    >>> _validate_dict({2: 0.5}, \"mock_name\",float, True)\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name all keys must be strings\n    >>> _validate_dict({\"b\": 4}, \"mock_name\", float,True)\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name nested dictionary all values must be float\n    \"\"\"\n    if not isinstance(_object, dict):\n        msg = f\"{var_name} must be a dict\"\n        raise ValueError(msg)\n    if not all(isinstance(x, str) for x in _object):\n        msg = f\"{var_name} all keys must be strings\"\n        raise ValueError(msg)\n    if not all(isinstance(x, value_type) for x in _object.values()):\n        nested_text = \"nested dictionary \" if nested else \"\"\n        msg = f\"{var_name} {nested_text}all values must be {value_type.__name__}\"\n        raise ValueError(msg)",
    "docstring": ">>> _validate_dict({\"b\": 0.5}, \"mock_name\", float)\n>>> _validate_dict(\"invalid\", \"mock_name\", float)\nTraceback (most recent call last):\n        ...\nValueError: mock_name must be a dict\n>>> _validate_dict({\"a\": 8}, \"mock_name\", dict)\nTraceback (most recent call last):\n        ...\nValueError: mock_name all values must be dict\n>>> _validate_dict({2: 0.5}, \"mock_name\",float, True)\nTraceback (most recent call last):\n        ...\nValueError: mock_name all keys must be strings\n>>> _validate_dict({\"b\": 4}, \"mock_name\", float,True)\nTraceback (most recent call last):\n        ...\nValueError: mock_name nested dictionary all values must be float"
  },
  {
    "function": "is_match",
    "code": "def is_match(string: str, pattern: str) -> bool:\n    \"\"\"\n    >>> is_match(\"\", \"\")\n    True\n    >>> is_match(\"aa\", \"a\")\n    False\n    >>> is_match(\"abc\", \"abc\")\n    True\n    >>> is_match(\"abc\", \"*c\")\n    True\n    >>> is_match(\"abc\", \"a*\")\n    True\n    >>> is_match(\"abc\", \"*a*\")\n    True\n    >>> is_match(\"abc\", \"?b?\")\n    True\n    >>> is_match(\"abc\", \"*?\")\n    True\n    >>> is_match(\"abc\", \"a*d\")\n    False\n    >>> is_match(\"abc\", \"a*c?\")\n    False\n    >>> is_match('baaabab','*****ba*****ba')\n    False\n    >>> is_match('baaabab','*****ba*****ab')\n    True\n    >>> is_match('aa','*')\n    True\n    \"\"\"\n    dp = [[False] * (len(pattern) + 1) for _ in string + \"1\"]\n    dp[0][0] = True\n    # Fill in the first row\n    for j, char in enumerate(pattern, 1):\n        if char == \"*\":\n            dp[0][j] = dp[0][j - 1]\n    # Fill in the rest of the DP table\n    for i, s_char in enumerate(string, 1):\n        for j, p_char in enumerate(pattern, 1):\n            if p_char in (s_char, \"?\"):\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[len(string)][len(pattern)]",
    "docstring": ">>> is_match(\"\", \"\")\nTrue\n>>> is_match(\"aa\", \"a\")\nFalse\n>>> is_match(\"abc\", \"abc\")\nTrue\n>>> is_match(\"abc\", \"*c\")\nTrue\n>>> is_match(\"abc\", \"a*\")\nTrue\n>>> is_match(\"abc\", \"*a*\")\nTrue\n>>> is_match(\"abc\", \"?b?\")\nTrue\n>>> is_match(\"abc\", \"*?\")\nTrue\n>>> is_match(\"abc\", \"a*d\")\nFalse\n>>> is_match(\"abc\", \"a*c?\")\nFalse\n>>> is_match('baaabab','*****ba*****ba')\nFalse\n>>> is_match('baaabab','*****ba*****ab')\nTrue\n>>> is_match('aa','*')\nTrue"
  },
  {
    "function": "word_break",
    "code": "def word_break(string: str, words: list[str]) -> bool:\n    \"\"\"\n    Return True if numbers have opposite signs False otherwise.\n\n    >>> word_break(\"applepenapple\", [\"apple\",\"pen\"])\n    True\n    >>> word_break(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\n    False\n    >>> word_break(\"cars\", [\"car\",\"ca\",\"rs\"])\n    True\n    >>> word_break('abc', [])\n    False\n    >>> word_break(123, ['a'])\n    Traceback (most recent call last):\n        ...\n    ValueError: the string should be not empty string\n    >>> word_break('', ['a'])\n    Traceback (most recent call last):\n        ...\n    ValueError: the string should be not empty string\n    >>> word_break('abc', [123])\n    Traceback (most recent call last):\n        ...\n    ValueError: the words should be a list of non-empty strings\n    >>> word_break('abc', [''])\n    Traceback (most recent call last):\n        ...\n    ValueError: the words should be a list of non-empty strings\n    \"\"\"\n\n    # Validation\n    if not isinstance(string, str) or len(string) == 0:\n        raise ValueError(\"the string should be not empty string\")\n\n    if not isinstance(words, list) or not all(\n        isinstance(item, str) and len(item) > 0 for item in words\n    ):\n        raise ValueError(\"the words should be a list of non-empty strings\")\n\n    # Build trie\n    trie: dict[str, Any] = {}\n    word_keeper_key = \"WORD_KEEPER\"\n\n    for word in words:\n        trie_node = trie\n        for c in word:\n            if c not in trie_node:\n                trie_node[c] = {}\n\n            trie_node = trie_node[c]\n\n        trie_node[word_keeper_key] = True\n\n    len_string = len(string)\n\n    # Dynamic programming method\n    @functools.cache\n    def is_breakable(index: int) -> bool:\n        \"\"\"\n        >>> string = 'a'\n        >>> is_breakable(1)\n        True\n        \"\"\"\n        if index == len_string:\n            return True\n\n        trie_node: Any = trie\n        for i in range(index, len_string):\n            trie_node = trie_node.get(string[i], None)\n\n            if trie_node is None:\n                return False\n\n            if trie_node.get(word_keeper_key, False) and is_breakable(i + 1):\n                return True\n\n        return False\n\n    return is_breakable(0)",
    "docstring": "Return True if numbers have opposite signs False otherwise.\n\n>>> word_break(\"applepenapple\", [\"apple\",\"pen\"])\nTrue\n>>> word_break(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\nFalse\n>>> word_break(\"cars\", [\"car\",\"ca\",\"rs\"])\nTrue\n>>> word_break('abc', [])\nFalse\n>>> word_break(123, ['a'])\nTraceback (most recent call last):\n    ...\nValueError: the string should be not empty string\n>>> word_break('', ['a'])\nTraceback (most recent call last):\n    ...\nValueError: the string should be not empty string\n>>> word_break('abc', [123])\nTraceback (most recent call last):\n    ...\nValueError: the words should be a list of non-empty strings\n>>> word_break('abc', [''])\nTraceback (most recent call last):\n    ...\nValueError: the words should be a list of non-empty strings"
  },
  {
    "function": "apparent_power",
    "code": "def apparent_power(\n    voltage: float, current: float, voltage_angle: float, current_angle: float\n) -> complex:\n    \"\"\"\n    Calculate the apparent power in a single-phase AC circuit.\n\n    Reference: https://en.wikipedia.org/wiki/AC_power#Apparent_power\n\n    >>> apparent_power(100, 5, 0, 0)\n    (500+0j)\n    >>> apparent_power(100, 5, 90, 0)\n    (3.061616997868383e-14+500j)\n    >>> apparent_power(100, 5, -45, -60)\n    (-129.40952255126027-482.9629131445341j)\n    >>> apparent_power(200, 10, -30, -90)\n    (-999.9999999999998-1732.0508075688776j)\n    \"\"\"\n    # Convert angles from degrees to radians\n    voltage_angle_rad = math.radians(voltage_angle)\n    current_angle_rad = math.radians(current_angle)\n\n    # Convert voltage and current to rectangular form\n    voltage_rect = cmath.rect(voltage, voltage_angle_rad)\n    current_rect = cmath.rect(current, current_angle_rad)\n\n    # Calculate apparent power\n    return voltage_rect * current_rect",
    "docstring": "Calculate the apparent power in a single-phase AC circuit.\n\nReference: https://en.wikipedia.org/wiki/AC_power#Apparent_power\n\n>>> apparent_power(100, 5, 0, 0)\n(500+0j)\n>>> apparent_power(100, 5, 90, 0)\n(3.061616997868383e-14+500j)\n>>> apparent_power(100, 5, -45, -60)\n(-129.40952255126027-482.9629131445341j)\n>>> apparent_power(200, 10, -30, -90)\n(-999.9999999999998-1732.0508075688776j)"
  },
  {
    "function": "builtin_voltage",
    "code": "def builtin_voltage(\n    donor_conc: float,  # donor concentration\n    acceptor_conc: float,  # acceptor concentration\n    intrinsic_conc: float,  # intrinsic concentration\n) -> float:\n    \"\"\"\n    This function can calculate the Builtin Voltage of a pn junction diode.\n    This is calculated from the given three values.\n    Examples -\n    >>> builtin_voltage(donor_conc=1e17, acceptor_conc=1e17, intrinsic_conc=1e10)\n    0.833370010652644\n    >>> builtin_voltage(donor_conc=0, acceptor_conc=1600, intrinsic_conc=200)\n    Traceback (most recent call last):\n      ...\n    ValueError: Donor concentration should be positive\n    >>> builtin_voltage(donor_conc=1000, acceptor_conc=0, intrinsic_conc=1200)\n    Traceback (most recent call last):\n      ...\n    ValueError: Acceptor concentration should be positive\n    >>> builtin_voltage(donor_conc=1000, acceptor_conc=1000, intrinsic_conc=0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Intrinsic concentration should be positive\n    >>> builtin_voltage(donor_conc=1000, acceptor_conc=3000, intrinsic_conc=2000)\n    Traceback (most recent call last):\n      ...\n    ValueError: Donor concentration should be greater than intrinsic concentration\n    >>> builtin_voltage(donor_conc=3000, acceptor_conc=1000, intrinsic_conc=2000)\n    Traceback (most recent call last):\n      ...\n    ValueError: Acceptor concentration should be greater than intrinsic concentration\n    \"\"\"\n\n    if donor_conc <= 0:\n        raise ValueError(\"Donor concentration should be positive\")\n    elif acceptor_conc <= 0:\n        raise ValueError(\"Acceptor concentration should be positive\")\n    elif intrinsic_conc <= 0:\n        raise ValueError(\"Intrinsic concentration should be positive\")\n    elif donor_conc <= intrinsic_conc:\n        raise ValueError(\n            \"Donor concentration should be greater than intrinsic concentration\"\n        )\n    elif acceptor_conc <= intrinsic_conc:\n        raise ValueError(\n            \"Acceptor concentration should be greater than intrinsic concentration\"\n        )\n    else:\n        return (\n            Boltzmann\n            * T\n            * log((donor_conc * acceptor_conc) / intrinsic_conc**2)\n            / physical_constants[\"electron volt\"][0]\n        )",
    "docstring": "This function can calculate the Builtin Voltage of a pn junction diode.\nThis is calculated from the given three values.\nExamples -\n>>> builtin_voltage(donor_conc=1e17, acceptor_conc=1e17, intrinsic_conc=1e10)\n0.833370010652644\n>>> builtin_voltage(donor_conc=0, acceptor_conc=1600, intrinsic_conc=200)\nTraceback (most recent call last):\n  ...\nValueError: Donor concentration should be positive\n>>> builtin_voltage(donor_conc=1000, acceptor_conc=0, intrinsic_conc=1200)\nTraceback (most recent call last):\n  ...\nValueError: Acceptor concentration should be positive\n>>> builtin_voltage(donor_conc=1000, acceptor_conc=1000, intrinsic_conc=0)\nTraceback (most recent call last):\n  ...\nValueError: Intrinsic concentration should be positive\n>>> builtin_voltage(donor_conc=1000, acceptor_conc=3000, intrinsic_conc=2000)\nTraceback (most recent call last):\n  ...\nValueError: Donor concentration should be greater than intrinsic concentration\n>>> builtin_voltage(donor_conc=3000, acceptor_conc=1000, intrinsic_conc=2000)\nTraceback (most recent call last):\n  ...\nValueError: Acceptor concentration should be greater than intrinsic concentration"
  },
  {
    "function": "capacitor_parallel",
    "code": "def capacitor_parallel(capacitors: list[float]) -> float:\n    \"\"\"\n    Ceq = C1 + C2 + ... + Cn\n    Calculate the equivalent resistance for any number of capacitors in parallel.\n    >>> capacitor_parallel([5.71389, 12, 3])\n    20.71389\n    >>> capacitor_parallel([5.71389, 12, -3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitor at index 2 has a negative value!\n    \"\"\"\n    sum_c = 0.0\n    for index, capacitor in enumerate(capacitors):\n        if capacitor < 0:\n            msg = f\"Capacitor at index {index} has a negative value!\"\n            raise ValueError(msg)\n        sum_c += capacitor\n    return sum_c",
    "docstring": "Ceq = C1 + C2 + ... + Cn\nCalculate the equivalent resistance for any number of capacitors in parallel.\n>>> capacitor_parallel([5.71389, 12, 3])\n20.71389\n>>> capacitor_parallel([5.71389, 12, -3])\nTraceback (most recent call last):\n    ...\nValueError: Capacitor at index 2 has a negative value!"
  },
  {
    "function": "capacitor_series",
    "code": "def capacitor_series(capacitors: list[float]) -> float:\n    \"\"\"\n    Ceq = 1/ (1/C1 + 1/C2 + ... + 1/Cn)\n    >>> capacitor_series([5.71389, 12, 3])\n    1.6901062252507735\n    >>> capacitor_series([5.71389, 12, -3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitor at index 2 has a negative or zero value!\n    >>> capacitor_series([5.71389, 12, 0.000])\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitor at index 2 has a negative or zero value!\n    \"\"\"\n\n    first_sum = 0.0\n    for index, capacitor in enumerate(capacitors):\n        if capacitor <= 0:\n            msg = f\"Capacitor at index {index} has a negative or zero value!\"\n            raise ValueError(msg)\n        first_sum += 1 / capacitor\n    return 1 / first_sum",
    "docstring": "Ceq = 1/ (1/C1 + 1/C2 + ... + 1/Cn)\n>>> capacitor_series([5.71389, 12, 3])\n1.6901062252507735\n>>> capacitor_series([5.71389, 12, -3])\nTraceback (most recent call last):\n    ...\nValueError: Capacitor at index 2 has a negative or zero value!\n>>> capacitor_series([5.71389, 12, 0.000])\nTraceback (most recent call last):\n    ...\nValueError: Capacitor at index 2 has a negative or zero value!"
  },
  {
    "function": "carrier_concentration",
    "code": "def carrier_concentration(\n    electron_conc: float,\n    hole_conc: float,\n    intrinsic_conc: float,\n) -> tuple:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Electron Concentration\n    2, Hole Concentration\n    3. Intrinsic Concentration\n    given the other two.\n    Examples -\n    >>> carrier_concentration(electron_conc=25, hole_conc=100, intrinsic_conc=0)\n    ('intrinsic_conc', 50.0)\n    >>> carrier_concentration(electron_conc=0, hole_conc=1600, intrinsic_conc=200)\n    ('electron_conc', 25.0)\n    >>> carrier_concentration(electron_conc=1000, hole_conc=0, intrinsic_conc=1200)\n    ('hole_conc', 1440.0)\n    >>> carrier_concentration(electron_conc=1000, hole_conc=400, intrinsic_conc=1200)\n    Traceback (most recent call last):\n        ...\n    ValueError: You cannot supply more or less than 2 values\n    >>> carrier_concentration(electron_conc=-1000, hole_conc=0, intrinsic_conc=1200)\n    Traceback (most recent call last):\n        ...\n    ValueError: Electron concentration cannot be negative in a semiconductor\n    >>> carrier_concentration(electron_conc=0, hole_conc=-400, intrinsic_conc=1200)\n    Traceback (most recent call last):\n        ...\n    ValueError: Hole concentration cannot be negative in a semiconductor\n    >>> carrier_concentration(electron_conc=0, hole_conc=400, intrinsic_conc=-1200)\n    Traceback (most recent call last):\n        ...\n    ValueError: Intrinsic concentration cannot be negative in a semiconductor\n    \"\"\"\n    if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif electron_conc < 0:\n        raise ValueError(\"Electron concentration cannot be negative in a semiconductor\")\n    elif hole_conc < 0:\n        raise ValueError(\"Hole concentration cannot be negative in a semiconductor\")\n    elif intrinsic_conc < 0:\n        raise ValueError(\n            \"Intrinsic concentration cannot be negative in a semiconductor\"\n        )\n    elif electron_conc == 0:\n        return (\n            \"electron_conc\",\n            intrinsic_conc**2 / hole_conc,\n        )\n    elif hole_conc == 0:\n        return (\n            \"hole_conc\",\n            intrinsic_conc**2 / electron_conc,\n        )\n    elif intrinsic_conc == 0:\n        return (\n            \"intrinsic_conc\",\n            (electron_conc * hole_conc) ** 0.5,\n        )\n    else:\n        return (-1, -1)",
    "docstring": "This function can calculate any one of the three -\n1. Electron Concentration\n2, Hole Concentration\n3. Intrinsic Concentration\ngiven the other two.\nExamples -\n>>> carrier_concentration(electron_conc=25, hole_conc=100, intrinsic_conc=0)\n('intrinsic_conc', 50.0)\n>>> carrier_concentration(electron_conc=0, hole_conc=1600, intrinsic_conc=200)\n('electron_conc', 25.0)\n>>> carrier_concentration(electron_conc=1000, hole_conc=0, intrinsic_conc=1200)\n('hole_conc', 1440.0)\n>>> carrier_concentration(electron_conc=1000, hole_conc=400, intrinsic_conc=1200)\nTraceback (most recent call last):\n    ...\nValueError: You cannot supply more or less than 2 values\n>>> carrier_concentration(electron_conc=-1000, hole_conc=0, intrinsic_conc=1200)\nTraceback (most recent call last):\n    ...\nValueError: Electron concentration cannot be negative in a semiconductor\n>>> carrier_concentration(electron_conc=0, hole_conc=-400, intrinsic_conc=1200)\nTraceback (most recent call last):\n    ...\nValueError: Hole concentration cannot be negative in a semiconductor\n>>> carrier_concentration(electron_conc=0, hole_conc=400, intrinsic_conc=-1200)\nTraceback (most recent call last):\n    ...\nValueError: Intrinsic concentration cannot be negative in a semiconductor"
  },
  {
    "function": "charging_capacitor",
    "code": "def charging_capacitor(\n    source_voltage: float,  # voltage in volts.\n    resistance: float,  # resistance in ohms.\n    capacitance: float,  # capacitance in farads.\n    time_sec: float,  # time in seconds after charging initiation of capacitor.\n) -> float:\n    \"\"\"\n    Find capacitor voltage at any nth second after initiating its charging.\n\n    Examples\n    --------\n    >>> charging_capacitor(source_voltage=.2,resistance=.9,capacitance=8.4,time_sec=.5)\n    0.013\n\n    >>> charging_capacitor(source_voltage=2.2,resistance=3.5,capacitance=2.4,time_sec=9)\n    1.446\n\n    >>> charging_capacitor(source_voltage=15,resistance=200,capacitance=20,time_sec=2)\n    0.007\n\n    >>> charging_capacitor(20, 2000, 30*pow(10,-5), 4)\n    19.975\n\n    >>> charging_capacitor(source_voltage=0,resistance=10.0,capacitance=.30,time_sec=3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Source voltage must be positive.\n\n    >>> charging_capacitor(source_voltage=20,resistance=-2000,capacitance=30,time_sec=4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistance must be positive.\n\n    >>> charging_capacitor(source_voltage=30,resistance=1500,capacitance=0,time_sec=4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitance must be positive.\n    \"\"\"\n\n    if source_voltage <= 0:\n        raise ValueError(\"Source voltage must be positive.\")\n    if resistance <= 0:\n        raise ValueError(\"Resistance must be positive.\")\n    if capacitance <= 0:\n        raise ValueError(\"Capacitance must be positive.\")\n    return round(source_voltage * (1 - exp(-time_sec / (resistance * capacitance))), 3)",
    "docstring": "Find capacitor voltage at any nth second after initiating its charging.\n\nExamples\n--------\n>>> charging_capacitor(source_voltage=.2,resistance=.9,capacitance=8.4,time_sec=.5)\n0.013\n\n>>> charging_capacitor(source_voltage=2.2,resistance=3.5,capacitance=2.4,time_sec=9)\n1.446\n\n>>> charging_capacitor(source_voltage=15,resistance=200,capacitance=20,time_sec=2)\n0.007\n\n>>> charging_capacitor(20, 2000, 30*pow(10,-5), 4)\n19.975\n\n>>> charging_capacitor(source_voltage=0,resistance=10.0,capacitance=.30,time_sec=3)\nTraceback (most recent call last):\n    ...\nValueError: Source voltage must be positive.\n\n>>> charging_capacitor(source_voltage=20,resistance=-2000,capacitance=30,time_sec=4)\nTraceback (most recent call last):\n    ...\nValueError: Resistance must be positive.\n\n>>> charging_capacitor(source_voltage=30,resistance=1500,capacitance=0,time_sec=4)\nTraceback (most recent call last):\n    ...\nValueError: Capacitance must be positive."
  },
  {
    "function": "charging_inductor",
    "code": "def charging_inductor(\n    source_voltage: float,  # source_voltage should be in volts.\n    resistance: float,  # resistance should be in ohms.\n    inductance: float,  # inductance should be in henrys.\n    time: float,  # time should in seconds.\n) -> float:\n    \"\"\"\n    Find inductor current at any nth second after initiating its charging.\n\n    Examples\n    --------\n    >>> charging_inductor(source_voltage=5.8,resistance=1.5,inductance=2.3,time=2)\n    2.817\n\n    >>> charging_inductor(source_voltage=8,resistance=5,inductance=3,time=2)\n    1.543\n\n    >>> charging_inductor(source_voltage=8,resistance=5*pow(10,2),inductance=3,time=2)\n    0.016\n\n    >>> charging_inductor(source_voltage=-8,resistance=100,inductance=15,time=12)\n    Traceback (most recent call last):\n        ...\n    ValueError: Source voltage must be positive.\n\n    >>> charging_inductor(source_voltage=80,resistance=-15,inductance=100,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistance must be positive.\n\n    >>> charging_inductor(source_voltage=12,resistance=200,inductance=-20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductance must be positive.\n\n    >>> charging_inductor(source_voltage=0,resistance=200,inductance=20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Source voltage must be positive.\n\n    >>> charging_inductor(source_voltage=10,resistance=0,inductance=20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistance must be positive.\n\n    >>> charging_inductor(source_voltage=15, resistance=25, inductance=0, time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductance must be positive.\n    \"\"\"\n\n    if source_voltage <= 0:\n        raise ValueError(\"Source voltage must be positive.\")\n    if resistance <= 0:\n        raise ValueError(\"Resistance must be positive.\")\n    if inductance <= 0:\n        raise ValueError(\"Inductance must be positive.\")\n    return round(\n        source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3\n    )",
    "docstring": "Find inductor current at any nth second after initiating its charging.\n\nExamples\n--------\n>>> charging_inductor(source_voltage=5.8,resistance=1.5,inductance=2.3,time=2)\n2.817\n\n>>> charging_inductor(source_voltage=8,resistance=5,inductance=3,time=2)\n1.543\n\n>>> charging_inductor(source_voltage=8,resistance=5*pow(10,2),inductance=3,time=2)\n0.016\n\n>>> charging_inductor(source_voltage=-8,resistance=100,inductance=15,time=12)\nTraceback (most recent call last):\n    ...\nValueError: Source voltage must be positive.\n\n>>> charging_inductor(source_voltage=80,resistance=-15,inductance=100,time=5)\nTraceback (most recent call last):\n    ...\nValueError: Resistance must be positive.\n\n>>> charging_inductor(source_voltage=12,resistance=200,inductance=-20,time=5)\nTraceback (most recent call last):\n    ...\nValueError: Inductance must be positive.\n\n>>> charging_inductor(source_voltage=0,resistance=200,inductance=20,time=5)\nTraceback (most recent call last):\n    ...\nValueError: Source voltage must be positive.\n\n>>> charging_inductor(source_voltage=10,resistance=0,inductance=20,time=5)\nTraceback (most recent call last):\n    ...\nValueError: Resistance must be positive.\n\n>>> charging_inductor(source_voltage=15, resistance=25, inductance=0, time=5)\nTraceback (most recent call last):\n    ...\nValueError: Inductance must be positive."
  },
  {
    "function": "couloumbs_law",
    "code": "def couloumbs_law(\n    force: float, charge1: float, charge2: float, distance: float\n) -> dict[str, float]:\n    \"\"\"\n    Apply Coulomb's Law on any three given values. These can be force, charge1,\n    charge2, or distance, and then in a Python dict return name/value pair of\n    the zero value.\n\n    Coulomb's Law states that the magnitude of the electrostatic force of\n    attraction or repulsion between two point charges is directly proportional\n    to the product of the magnitudes of charges and inversely proportional to\n    the square of the distance between them.\n\n    Reference\n    ----------\n    Coulomb (1785) \"Premier m\u00e9moire sur l'\u00e9lectricit\u00e9 et le magn\u00e9tisme,\"\n    Histoire de l'Acad\u00e9mie Royale des Sciences, pp. 569-577.\n\n    Parameters\n    ----------\n    force : float with units in Newtons\n\n    charge1 : float with units in Coulombs\n\n    charge2 : float with units in Coulombs\n\n    distance : float with units in meters\n\n    Returns\n    -------\n    result : dict name/value pair of the zero value\n\n    >>> couloumbs_law(force=0, charge1=3, charge2=5, distance=2000)\n    {'force': 33705.0}\n\n    >>> couloumbs_law(force=10, charge1=3, charge2=5, distance=0)\n    {'distance': 116112.01488218177}\n\n    >>> couloumbs_law(force=10, charge1=0, charge2=5, distance=2000)\n    {'charge1': 0.0008900756564307966}\n\n    >>> couloumbs_law(force=0, charge1=0, charge2=5, distance=2000)\n    Traceback (most recent call last):\n      ...\n    ValueError: One and only one argument must be 0\n\n    >>> couloumbs_law(force=0, charge1=3, charge2=5, distance=-2000)\n    Traceback (most recent call last):\n      ...\n    ValueError: Distance cannot be negative\n\n    \"\"\"\n\n    charge_product = abs(charge1 * charge2)\n\n    if (force, charge1, charge2, distance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if distance < 0:\n        raise ValueError(\"Distance cannot be negative\")\n    if force == 0:\n        force = COULOMBS_CONSTANT * charge_product / (distance**2)\n        return {\"force\": force}\n    elif charge1 == 0:\n        charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)\n        return {\"charge1\": charge1}\n    elif charge2 == 0:\n        charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)\n        return {\"charge2\": charge2}\n    elif distance == 0:\n        distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5\n        return {\"distance\": distance}\n    raise ValueError(\"Exactly one argument must be 0\")",
    "docstring": "Apply Coulomb's Law on any three given values. These can be force, charge1,\ncharge2, or distance, and then in a Python dict return name/value pair of\nthe zero value.\n\nCoulomb's Law states that the magnitude of the electrostatic force of\nattraction or repulsion between two point charges is directly proportional\nto the product of the magnitudes of charges and inversely proportional to\nthe square of the distance between them.\n\nReference\n----------\nCoulomb (1785) \"Premier m\u00e9moire sur l'\u00e9lectricit\u00e9 et le magn\u00e9tisme,\"\nHistoire de l'Acad\u00e9mie Royale des Sciences, pp. 569-577.\n\nParameters\n----------\nforce : float with units in Newtons\n\ncharge1 : float with units in Coulombs\n\ncharge2 : float with units in Coulombs\n\ndistance : float with units in meters\n\nReturns\n-------\nresult : dict name/value pair of the zero value\n\n>>> couloumbs_law(force=0, charge1=3, charge2=5, distance=2000)\n{'force': 33705.0}\n\n>>> couloumbs_law(force=10, charge1=3, charge2=5, distance=0)\n{'distance': 116112.01488218177}\n\n>>> couloumbs_law(force=10, charge1=0, charge2=5, distance=2000)\n{'charge1': 0.0008900756564307966}\n\n>>> couloumbs_law(force=0, charge1=0, charge2=5, distance=2000)\nTraceback (most recent call last):\n  ...\nValueError: One and only one argument must be 0\n\n>>> couloumbs_law(force=0, charge1=3, charge2=5, distance=-2000)\nTraceback (most recent call last):\n  ...\nValueError: Distance cannot be negative"
  },
  {
    "function": "electrical_impedance",
    "code": "def electrical_impedance(\n    resistance: float, reactance: float, impedance: float\n) -> dict[str, float]:\n    \"\"\"\n    Apply Electrical Impedance formula, on any two given electrical values,\n    which can be resistance, reactance, and impedance, and then in a Python dict\n    return name/value pair of the zero value.\n\n    >>> electrical_impedance(3,4,0)\n    {'impedance': 5.0}\n    >>> electrical_impedance(0,4,5)\n    {'resistance': 3.0}\n    >>> electrical_impedance(3,0,5)\n    {'reactance': 4.0}\n    >>> electrical_impedance(3,4,5)\n    Traceback (most recent call last):\n      ...\n    ValueError: One and only one argument must be 0\n    \"\"\"\n    if (resistance, reactance, impedance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if resistance == 0:\n        return {\"resistance\": sqrt(pow(impedance, 2) - pow(reactance, 2))}\n    elif reactance == 0:\n        return {\"reactance\": sqrt(pow(impedance, 2) - pow(resistance, 2))}\n    elif impedance == 0:\n        return {\"impedance\": sqrt(pow(resistance, 2) + pow(reactance, 2))}\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")",
    "docstring": "Apply Electrical Impedance formula, on any two given electrical values,\nwhich can be resistance, reactance, and impedance, and then in a Python dict\nreturn name/value pair of the zero value.\n\n>>> electrical_impedance(3,4,0)\n{'impedance': 5.0}\n>>> electrical_impedance(0,4,5)\n{'resistance': 3.0}\n>>> electrical_impedance(3,0,5)\n{'reactance': 4.0}\n>>> electrical_impedance(3,4,5)\nTraceback (most recent call last):\n  ...\nValueError: One and only one argument must be 0"
  },
  {
    "function": "electric_conductivity",
    "code": "def electric_conductivity(\n    conductivity: float,\n    electron_conc: float,\n    mobility: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Conductivity\n    2. Electron Concentration\n    3. Electron Mobility\n    This is calculated from the other two provided values\n    Examples -\n    >>> electric_conductivity(conductivity=25, electron_conc=100, mobility=0)\n    ('mobility', 1.5604519068722301e+18)\n    >>> electric_conductivity(conductivity=0, electron_conc=1600, mobility=200)\n    ('conductivity', 5.12672e-14)\n    >>> electric_conductivity(conductivity=1000, electron_conc=0, mobility=1200)\n    ('electron_conc', 5.201506356240767e+18)\n    >>> electric_conductivity(conductivity=-10, electron_conc=100, mobility=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Conductivity cannot be negative\n    >>> electric_conductivity(conductivity=50, electron_conc=-10, mobility=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Electron concentration cannot be negative\n    >>> electric_conductivity(conductivity=50, electron_conc=0, mobility=-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: mobility cannot be negative\n    >>> electric_conductivity(conductivity=50, electron_conc=0, mobility=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: You cannot supply more or less than 2 values\n    >>> electric_conductivity(conductivity=50, electron_conc=200, mobility=300)\n    Traceback (most recent call last):\n        ...\n    ValueError: You cannot supply more or less than 2 values\n    \"\"\"\n    if (conductivity, electron_conc, mobility).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif conductivity < 0:\n        raise ValueError(\"Conductivity cannot be negative\")\n    elif electron_conc < 0:\n        raise ValueError(\"Electron concentration cannot be negative\")\n    elif mobility < 0:\n        raise ValueError(\"mobility cannot be negative\")\n    elif conductivity == 0:\n        return (\n            \"conductivity\",\n            mobility * electron_conc * ELECTRON_CHARGE,\n        )\n    elif electron_conc == 0:\n        return (\n            \"electron_conc\",\n            conductivity / (mobility * ELECTRON_CHARGE),\n        )\n    else:\n        return (\n            \"mobility\",\n            conductivity / (electron_conc * ELECTRON_CHARGE),\n        )",
    "docstring": "This function can calculate any one of the three -\n1. Conductivity\n2. Electron Concentration\n3. Electron Mobility\nThis is calculated from the other two provided values\nExamples -\n>>> electric_conductivity(conductivity=25, electron_conc=100, mobility=0)\n('mobility', 1.5604519068722301e+18)\n>>> electric_conductivity(conductivity=0, electron_conc=1600, mobility=200)\n('conductivity', 5.12672e-14)\n>>> electric_conductivity(conductivity=1000, electron_conc=0, mobility=1200)\n('electron_conc', 5.201506356240767e+18)\n>>> electric_conductivity(conductivity=-10, electron_conc=100, mobility=0)\nTraceback (most recent call last):\n    ...\nValueError: Conductivity cannot be negative\n>>> electric_conductivity(conductivity=50, electron_conc=-10, mobility=0)\nTraceback (most recent call last):\n    ...\nValueError: Electron concentration cannot be negative\n>>> electric_conductivity(conductivity=50, electron_conc=0, mobility=-10)\nTraceback (most recent call last):\n    ...\nValueError: mobility cannot be negative\n>>> electric_conductivity(conductivity=50, electron_conc=0, mobility=0)\nTraceback (most recent call last):\n    ...\nValueError: You cannot supply more or less than 2 values\n>>> electric_conductivity(conductivity=50, electron_conc=200, mobility=300)\nTraceback (most recent call last):\n    ...\nValueError: You cannot supply more or less than 2 values"
  },
  {
    "function": "electric_power",
    "code": "def electric_power(voltage: float, current: float, power: float) -> tuple:\n    \"\"\"\n    This function can calculate any one of the three (voltage, current, power),\n    fundamental value of electrical system.\n    examples are below:\n    >>> electric_power(voltage=0, current=2, power=5)\n    Result(name='voltage', value=2.5)\n    >>> electric_power(voltage=2, current=2, power=0)\n    Result(name='power', value=4.0)\n    >>> electric_power(voltage=-2, current=3, power=0)\n    Result(name='power', value=6.0)\n    >>> electric_power(voltage=2, current=4, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=0, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=2, power=-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Power cannot be negative in any electrical/electronics system\n    >>> electric_power(voltage=2.2, current=2.2, power=0)\n    Result(name='power', value=4.84)\n    >>> electric_power(current=0, power=6, voltage=2)\n    Result(name='current', value=3.0)\n    \"\"\"\n    if (voltage, current, power).count(0) != 1:\n        raise ValueError(\"Exactly one argument must be 0\")\n    elif power < 0:\n        raise ValueError(\n            \"Power cannot be negative in any electrical/electronics system\"\n        )\n    elif voltage == 0:\n        return Result(\"voltage\", power / current)\n    elif current == 0:\n        return Result(\"current\", power / voltage)\n    elif power == 0:\n        return Result(\"power\", float(round(abs(voltage * current), 2)))\n    else:\n        raise AssertionError",
    "docstring": "This function can calculate any one of the three (voltage, current, power),\nfundamental value of electrical system.\nexamples are below:\n>>> electric_power(voltage=0, current=2, power=5)\nResult(name='voltage', value=2.5)\n>>> electric_power(voltage=2, current=2, power=0)\nResult(name='power', value=4.0)\n>>> electric_power(voltage=-2, current=3, power=0)\nResult(name='power', value=6.0)\n>>> electric_power(voltage=2, current=4, power=2)\nTraceback (most recent call last):\n    ...\nValueError: Exactly one argument must be 0\n>>> electric_power(voltage=0, current=0, power=2)\nTraceback (most recent call last):\n    ...\nValueError: Exactly one argument must be 0\n>>> electric_power(voltage=0, current=2, power=-4)\nTraceback (most recent call last):\n    ...\nValueError: Power cannot be negative in any electrical/electronics system\n>>> electric_power(voltage=2.2, current=2.2, power=0)\nResult(name='power', value=4.84)\n>>> electric_power(current=0, power=6, voltage=2)\nResult(name='current', value=3.0)"
  },
  {
    "function": "astable_frequency",
    "code": "def astable_frequency(\n    resistance_1: float, resistance_2: float, capacitance: float\n) -> float:\n    \"\"\"\n    Usage examples:\n    >>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=7)\n    1523.8095238095239\n    >>> astable_frequency(resistance_1=356, resistance_2=234, capacitance=976)\n    1.7905459175553078\n    >>> astable_frequency(resistance_1=2, resistance_2=-1, capacitance=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be positive\n    >>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be positive\n    \"\"\"\n\n    if resistance_1 <= 0 or resistance_2 <= 0 or capacitance <= 0:\n        raise ValueError(\"All values must be positive\")\n    return (1.44 / ((resistance_1 + 2 * resistance_2) * capacitance)) * 10**6",
    "docstring": "Usage examples:\n>>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=7)\n1523.8095238095239\n>>> astable_frequency(resistance_1=356, resistance_2=234, capacitance=976)\n1.7905459175553078\n>>> astable_frequency(resistance_1=2, resistance_2=-1, capacitance=2)\nTraceback (most recent call last):\n    ...\nValueError: All values must be positive\n>>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=0)\nTraceback (most recent call last):\n    ...\nValueError: All values must be positive"
  },
  {
    "function": "astable_duty_cycle",
    "code": "def astable_duty_cycle(resistance_1: float, resistance_2: float) -> float:\n    \"\"\"\n    Usage examples:\n    >>> astable_duty_cycle(resistance_1=45, resistance_2=45)\n    66.66666666666666\n    >>> astable_duty_cycle(resistance_1=356, resistance_2=234)\n    71.60194174757282\n    >>> astable_duty_cycle(resistance_1=2, resistance_2=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be positive\n    >>> astable_duty_cycle(resistance_1=0, resistance_2=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be positive\n    \"\"\"\n\n    if resistance_1 <= 0 or resistance_2 <= 0:\n        raise ValueError(\"All values must be positive\")\n    return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100",
    "docstring": "Usage examples:\n>>> astable_duty_cycle(resistance_1=45, resistance_2=45)\n66.66666666666666\n>>> astable_duty_cycle(resistance_1=356, resistance_2=234)\n71.60194174757282\n>>> astable_duty_cycle(resistance_1=2, resistance_2=-1)\nTraceback (most recent call last):\n    ...\nValueError: All values must be positive\n>>> astable_duty_cycle(resistance_1=0, resistance_2=0)\nTraceback (most recent call last):\n    ...\nValueError: All values must be positive"
  },
  {
    "function": "ind_reactance",
    "code": "def ind_reactance(\n    inductance: float, frequency: float, reactance: float\n) -> dict[str, float]:\n    \"\"\"\n    Calculate inductive reactance, frequency or inductance from two given electrical\n    properties then return name/value pair of the zero value in a Python dict.\n\n    Parameters\n    ----------\n    inductance : float with units in Henries\n\n    frequency : float with units in Hertz\n\n    reactance : float with units in Ohms\n\n    >>> ind_reactance(-35e-6, 1e3, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductance cannot be negative\n\n    >>> ind_reactance(35e-6, -1e3, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Frequency cannot be negative\n\n    >>> ind_reactance(35e-6, 0, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductive reactance cannot be negative\n\n    >>> ind_reactance(0, 10e3, 50)\n    {'inductance': 0.0007957747154594767}\n\n    >>> ind_reactance(35e-3, 0, 50)\n    {'frequency': 227.36420441699332}\n\n    >>> ind_reactance(35e-6, 1e3, 0)\n    {'reactance': 0.2199114857512855}\n\n    \"\"\"\n\n    if (inductance, frequency, reactance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if inductance < 0:\n        raise ValueError(\"Inductance cannot be negative\")\n    if frequency < 0:\n        raise ValueError(\"Frequency cannot be negative\")\n    if reactance < 0:\n        raise ValueError(\"Inductive reactance cannot be negative\")\n    if inductance == 0:\n        return {\"inductance\": reactance / (2 * pi * frequency)}\n    elif frequency == 0:\n        return {\"frequency\": reactance / (2 * pi * inductance)}\n    elif reactance == 0:\n        return {\"reactance\": 2 * pi * frequency * inductance}\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")",
    "docstring": "Calculate inductive reactance, frequency or inductance from two given electrical\nproperties then return name/value pair of the zero value in a Python dict.\n\nParameters\n----------\ninductance : float with units in Henries\n\nfrequency : float with units in Hertz\n\nreactance : float with units in Ohms\n\n>>> ind_reactance(-35e-6, 1e3, 0)\nTraceback (most recent call last):\n    ...\nValueError: Inductance cannot be negative\n\n>>> ind_reactance(35e-6, -1e3, 0)\nTraceback (most recent call last):\n    ...\nValueError: Frequency cannot be negative\n\n>>> ind_reactance(35e-6, 0, -1)\nTraceback (most recent call last):\n    ...\nValueError: Inductive reactance cannot be negative\n\n>>> ind_reactance(0, 10e3, 50)\n{'inductance': 0.0007957747154594767}\n\n>>> ind_reactance(35e-3, 0, 50)\n{'frequency': 227.36420441699332}\n\n>>> ind_reactance(35e-6, 1e3, 0)\n{'reactance': 0.2199114857512855}"
  },
  {
    "function": "ohms_law",
    "code": "def ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:\n    \"\"\"\n    Apply Ohm's Law, on any two given electrical values, which can be voltage, current,\n    and resistance, and then in a Python dict return name/value pair of the zero value.\n\n    >>> ohms_law(voltage=10, resistance=5, current=0)\n    {'current': 2.0}\n    >>> ohms_law(voltage=0, current=0, resistance=10)\n    Traceback (most recent call last):\n      ...\n    ValueError: One and only one argument must be 0\n    >>> ohms_law(voltage=0, current=1, resistance=-2)\n    Traceback (most recent call last):\n      ...\n    ValueError: Resistance cannot be negative\n    >>> ohms_law(resistance=0, voltage=-10, current=1)\n    {'resistance': -10.0}\n    >>> ohms_law(voltage=0, current=-1.5, resistance=2)\n    {'voltage': -3.0}\n    \"\"\"\n    if (voltage, current, resistance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if resistance < 0:\n        raise ValueError(\"Resistance cannot be negative\")\n    if voltage == 0:\n        return {\"voltage\": float(current * resistance)}\n    elif current == 0:\n        return {\"current\": voltage / resistance}\n    elif resistance == 0:\n        return {\"resistance\": voltage / current}\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")",
    "docstring": "Apply Ohm's Law, on any two given electrical values, which can be voltage, current,\nand resistance, and then in a Python dict return name/value pair of the zero value.\n\n>>> ohms_law(voltage=10, resistance=5, current=0)\n{'current': 2.0}\n>>> ohms_law(voltage=0, current=0, resistance=10)\nTraceback (most recent call last):\n  ...\nValueError: One and only one argument must be 0\n>>> ohms_law(voltage=0, current=1, resistance=-2)\nTraceback (most recent call last):\n  ...\nValueError: Resistance cannot be negative\n>>> ohms_law(resistance=0, voltage=-10, current=1)\n{'resistance': -10.0}\n>>> ohms_law(voltage=0, current=-1.5, resistance=2)\n{'voltage': -3.0}"
  },
  {
    "function": "real_power",
    "code": "def real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor",
    "docstring": "Calculate real power from apparent power and power factor.\n\nExamples:\n>>> real_power(100, 0.9)\n90.0\n>>> real_power(0, 0.8)\n0.0\n>>> real_power(100, -0.9)\n-90.0"
  },
  {
    "function": "reactive_power",
    "code": "def reactive_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate reactive power from apparent power and power factor.\n\n    Examples:\n    >>> reactive_power(100, 0.9)\n    43.58898943540673\n    >>> reactive_power(0, 0.8)\n    0.0\n    >>> reactive_power(100, -0.9)\n    43.58898943540673\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * math.sqrt(1 - power_factor**2)",
    "docstring": "Calculate reactive power from apparent power and power factor.\n\nExamples:\n>>> reactive_power(100, 0.9)\n43.58898943540673\n>>> reactive_power(0, 0.8)\n0.0\n>>> reactive_power(100, -0.9)\n43.58898943540673"
  },
  {
    "function": "get_significant_digits",
    "code": "def get_significant_digits(colors: list) -> str:\n    \"\"\"\n    Function returns the digit associated with the color. Function takes a\n    list containing colors as input and returns digits as string\n\n    >>> get_significant_digits(['Black','Blue'])\n    '06'\n\n    >>> get_significant_digits(['Aqua','Blue'])\n    Traceback (most recent call last):\n      ...\n    ValueError: Aqua is not a valid color for significant figure bands\n\n    \"\"\"\n    digit = \"\"\n    for color in colors:\n        if color not in significant_figures_color_values:\n            msg = f\"{color} is not a valid color for significant figure bands\"\n            raise ValueError(msg)\n        digit = digit + str(significant_figures_color_values[color])\n    return str(digit)",
    "docstring": "Function returns the digit associated with the color. Function takes a\nlist containing colors as input and returns digits as string\n\n>>> get_significant_digits(['Black','Blue'])\n'06'\n\n>>> get_significant_digits(['Aqua','Blue'])\nTraceback (most recent call last):\n  ...\nValueError: Aqua is not a valid color for significant figure bands"
  },
  {
    "function": "get_multiplier",
    "code": "def get_multiplier(color: str) -> float:\n    \"\"\"\n    Function returns the multiplier value associated with the color.\n    Function takes color as input and returns multiplier value\n\n    >>> get_multiplier('Gold')\n    0.1\n\n    >>> get_multiplier('Ivory')\n    Traceback (most recent call last):\n      ...\n    ValueError: Ivory is not a valid color for multiplier band\n\n    \"\"\"\n    if color not in multiplier_color_values:\n        msg = f\"{color} is not a valid color for multiplier band\"\n        raise ValueError(msg)\n    return multiplier_color_values[color]",
    "docstring": "Function returns the multiplier value associated with the color.\nFunction takes color as input and returns multiplier value\n\n>>> get_multiplier('Gold')\n0.1\n\n>>> get_multiplier('Ivory')\nTraceback (most recent call last):\n  ...\nValueError: Ivory is not a valid color for multiplier band"
  },
  {
    "function": "get_tolerance",
    "code": "def get_tolerance(color: str) -> float:\n    \"\"\"\n    Function returns the tolerance value associated with the color.\n    Function takes color as input and returns tolerance value.\n\n    >>> get_tolerance('Green')\n    0.5\n\n    >>> get_tolerance('Indigo')\n    Traceback (most recent call last):\n      ...\n    ValueError: Indigo is not a valid color for tolerance band\n\n    \"\"\"\n    if color not in tolerance_color_values:\n        msg = f\"{color} is not a valid color for tolerance band\"\n        raise ValueError(msg)\n    return tolerance_color_values[color]",
    "docstring": "Function returns the tolerance value associated with the color.\nFunction takes color as input and returns tolerance value.\n\n>>> get_tolerance('Green')\n0.5\n\n>>> get_tolerance('Indigo')\nTraceback (most recent call last):\n  ...\nValueError: Indigo is not a valid color for tolerance band"
  },
  {
    "function": "get_temperature_coeffecient",
    "code": "def get_temperature_coeffecient(color: str) -> int:\n    \"\"\"\n    Function returns the temperature coeffecient value associated with the color.\n    Function takes color as input and returns temperature coeffecient value.\n\n    >>> get_temperature_coeffecient('Yellow')\n    25\n\n    >>> get_temperature_coeffecient('Cyan')\n    Traceback (most recent call last):\n      ...\n    ValueError: Cyan is not a valid color for temperature coeffecient band\n\n    \"\"\"\n    if color not in temperature_coeffecient_color_values:\n        msg = f\"{color} is not a valid color for temperature coeffecient band\"\n        raise ValueError(msg)\n    return temperature_coeffecient_color_values[color]",
    "docstring": "Function returns the temperature coeffecient value associated with the color.\nFunction takes color as input and returns temperature coeffecient value.\n\n>>> get_temperature_coeffecient('Yellow')\n25\n\n>>> get_temperature_coeffecient('Cyan')\nTraceback (most recent call last):\n  ...\nValueError: Cyan is not a valid color for temperature coeffecient band"
  },
  {
    "function": "get_band_type_count",
    "code": "def get_band_type_count(total_number_of_bands: int, type_of_band: str) -> int:\n    \"\"\"\n    Function returns the number of bands of a given type in a resistor with n bands\n    Function takes total_number_of_bands and type_of_band as input and returns\n    number of bands belonging to that type in the given resistor\n\n    >>> get_band_type_count(3,'significant')\n    2\n\n    >>> get_band_type_count(2,'significant')\n    Traceback (most recent call last):\n      ...\n    ValueError: 2 is not a valid number of bands\n\n    >>> get_band_type_count(3,'sign')\n    Traceback (most recent call last):\n      ...\n    ValueError: sign is not valid for a 3 band resistor\n\n    >>> get_band_type_count(3,'tolerance')\n    Traceback (most recent call last):\n      ...\n    ValueError: tolerance is not valid for a 3 band resistor\n\n    >>> get_band_type_count(5,'temp_coeffecient')\n    Traceback (most recent call last):\n      ...\n    ValueError: temp_coeffecient is not valid for a 5 band resistor\n\n    \"\"\"\n    if total_number_of_bands not in band_types:\n        msg = f\"{total_number_of_bands} is not a valid number of bands\"\n        raise ValueError(msg)\n    if type_of_band not in band_types[total_number_of_bands]:\n        msg = f\"{type_of_band} is not valid for a {total_number_of_bands} band resistor\"\n        raise ValueError(msg)\n    return band_types[total_number_of_bands][type_of_band]",
    "docstring": "Function returns the number of bands of a given type in a resistor with n bands\nFunction takes total_number_of_bands and type_of_band as input and returns\nnumber of bands belonging to that type in the given resistor\n\n>>> get_band_type_count(3,'significant')\n2\n\n>>> get_band_type_count(2,'significant')\nTraceback (most recent call last):\n  ...\nValueError: 2 is not a valid number of bands\n\n>>> get_band_type_count(3,'sign')\nTraceback (most recent call last):\n  ...\nValueError: sign is not valid for a 3 band resistor\n\n>>> get_band_type_count(3,'tolerance')\nTraceback (most recent call last):\n  ...\nValueError: tolerance is not valid for a 3 band resistor\n\n>>> get_band_type_count(5,'temp_coeffecient')\nTraceback (most recent call last):\n  ...\nValueError: temp_coeffecient is not valid for a 5 band resistor"
  },
  {
    "function": "check_validity",
    "code": "def check_validity(number_of_bands: int, colors: list) -> bool:\n    \"\"\"\n    Function checks if the input provided is valid or not.\n    Function takes number_of_bands and colors as input and returns\n    True if it is valid\n\n    >>> check_validity(3, [\"Black\",\"Blue\",\"Orange\"])\n    True\n\n    >>> check_validity(4, [\"Black\",\"Blue\",\"Orange\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Expecting 4 colors, provided 3 colors\n\n    >>> check_validity(3, [\"Cyan\",\"Red\",\"Yellow\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Cyan is not a valid color\n\n    \"\"\"\n    if number_of_bands >= 3 and number_of_bands <= 6:\n        if number_of_bands == len(colors):\n            for color in colors:\n                if color not in valid_colors:\n                    msg = f\"{color} is not a valid color\"\n                    raise ValueError(msg)\n            return True\n        else:\n            msg = f\"Expecting {number_of_bands} colors, provided {len(colors)} colors\"\n            raise ValueError(msg)\n    else:\n        msg = \"Invalid number of bands. Resistor bands must be 3 to 6\"\n        raise ValueError(msg)",
    "docstring": "Function checks if the input provided is valid or not.\nFunction takes number_of_bands and colors as input and returns\nTrue if it is valid\n\n>>> check_validity(3, [\"Black\",\"Blue\",\"Orange\"])\nTrue\n\n>>> check_validity(4, [\"Black\",\"Blue\",\"Orange\"])\nTraceback (most recent call last):\n  ...\nValueError: Expecting 4 colors, provided 3 colors\n\n>>> check_validity(3, [\"Cyan\",\"Red\",\"Yellow\"])\nTraceback (most recent call last):\n  ...\nValueError: Cyan is not a valid color"
  },
  {
    "function": "calculate_resistance",
    "code": "def calculate_resistance(number_of_bands: int, color_code_list: list) -> dict:\n    \"\"\"\n    Function calculates the total resistance of the resistor using the color codes.\n    Function takes number_of_bands, color_code_list as input and returns\n    resistance\n\n    >>> calculate_resistance(3, [\"Black\",\"Blue\",\"Orange\"])\n    {'resistance': '6000\u03a9 \u00b120% '}\n\n    >>> calculate_resistance(4, [\"Orange\",\"Green\",\"Blue\",\"Gold\"])\n    {'resistance': '35000000\u03a9 \u00b15% '}\n\n    >>> calculate_resistance(5, [\"Violet\",\"Brown\",\"Grey\",\"Silver\",\"Green\"])\n    {'resistance': '7.18\u03a9 \u00b10.5% '}\n\n    >>> calculate_resistance(6, [\"Red\",\"Green\",\"Blue\",\"Yellow\",\"Orange\",\"Grey\"])\n    {'resistance': '2560000\u03a9 \u00b10.05% 1 ppm/K'}\n\n    >>> calculate_resistance(0, [\"Violet\",\"Brown\",\"Grey\",\"Silver\",\"Green\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Invalid number of bands. Resistor bands must be 3 to 6\n\n    >>> calculate_resistance(4, [\"Violet\",\"Brown\",\"Grey\",\"Silver\",\"Green\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Expecting 4 colors, provided 5 colors\n\n    >>> calculate_resistance(4, [\"Violet\",\"Silver\",\"Brown\",\"Grey\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Silver is not a valid color for significant figure bands\n\n    >>> calculate_resistance(4, [\"Violet\",\"Blue\",\"Lime\",\"Grey\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Lime is not a valid color\n\n    \"\"\"\n    is_valid = check_validity(number_of_bands, color_code_list)\n    if is_valid:\n        number_of_significant_bands = get_band_type_count(\n            number_of_bands, \"significant\"\n        )\n        significant_colors = color_code_list[:number_of_significant_bands]\n        significant_digits = int(get_significant_digits(significant_colors))\n        multiplier_color = color_code_list[number_of_significant_bands]\n        multiplier = get_multiplier(multiplier_color)\n        if number_of_bands == 3:\n            tolerance_color = None\n        else:\n            tolerance_color = color_code_list[number_of_significant_bands + 1]\n        tolerance = (\n            20 if tolerance_color is None else get_tolerance(str(tolerance_color))\n        )\n        if number_of_bands != 6:\n            temperature_coeffecient_color = None\n        else:\n            temperature_coeffecient_color = color_code_list[\n                number_of_significant_bands + 2\n            ]\n        temperature_coeffecient = (\n            0\n            if temperature_coeffecient_color is None\n            else get_temperature_coeffecient(str(temperature_coeffecient_color))\n        )\n        resisitance = significant_digits * multiplier\n        if temperature_coeffecient == 0:\n            answer = f\"{resisitance}\u03a9 \u00b1{tolerance}% \"\n        else:\n            answer = f\"{resisitance}\u03a9 \u00b1{tolerance}% {temperature_coeffecient} ppm/K\"\n        return {\"resistance\": answer}\n    else:\n        raise ValueError(\"Input is invalid\")",
    "docstring": "Function calculates the total resistance of the resistor using the color codes.\nFunction takes number_of_bands, color_code_list as input and returns\nresistance\n\n>>> calculate_resistance(3, [\"Black\",\"Blue\",\"Orange\"])\n{'resistance': '6000\u03a9 \u00b120% '}\n\n>>> calculate_resistance(4, [\"Orange\",\"Green\",\"Blue\",\"Gold\"])\n{'resistance': '35000000\u03a9 \u00b15% '}\n\n>>> calculate_resistance(5, [\"Violet\",\"Brown\",\"Grey\",\"Silver\",\"Green\"])\n{'resistance': '7.18\u03a9 \u00b10.5% '}\n\n>>> calculate_resistance(6, [\"Red\",\"Green\",\"Blue\",\"Yellow\",\"Orange\",\"Grey\"])\n{'resistance': '2560000\u03a9 \u00b10.05% 1 ppm/K'}\n\n>>> calculate_resistance(0, [\"Violet\",\"Brown\",\"Grey\",\"Silver\",\"Green\"])\nTraceback (most recent call last):\n  ...\nValueError: Invalid number of bands. Resistor bands must be 3 to 6\n\n>>> calculate_resistance(4, [\"Violet\",\"Brown\",\"Grey\",\"Silver\",\"Green\"])\nTraceback (most recent call last):\n  ...\nValueError: Expecting 4 colors, provided 5 colors\n\n>>> calculate_resistance(4, [\"Violet\",\"Silver\",\"Brown\",\"Grey\"])\nTraceback (most recent call last):\n  ...\nValueError: Silver is not a valid color for significant figure bands\n\n>>> calculate_resistance(4, [\"Violet\",\"Blue\",\"Lime\",\"Grey\"])\nTraceback (most recent call last):\n  ...\nValueError: Lime is not a valid color"
  },
  {
    "function": "resistor_parallel",
    "code": "def resistor_parallel(resistors: list[float]) -> float:\n    \"\"\"\n    Req = 1/ (1/R1 + 1/R2 + ... + 1/Rn)\n\n    >>> resistor_parallel([3.21389, 2, 3])\n    0.8737571620498019\n    >>> resistor_parallel([3.21389, 2, -3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistor at index 2 has a negative or zero value!\n    >>> resistor_parallel([3.21389, 2, 0.000])\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistor at index 2 has a negative or zero value!\n    \"\"\"\n\n    first_sum = 0.00\n    for index, resistor in enumerate(resistors):\n        if resistor <= 0:\n            msg = f\"Resistor at index {index} has a negative or zero value!\"\n            raise ValueError(msg)\n        first_sum += 1 / float(resistor)\n    return 1 / first_sum",
    "docstring": "Req = 1/ (1/R1 + 1/R2 + ... + 1/Rn)\n\n>>> resistor_parallel([3.21389, 2, 3])\n0.8737571620498019\n>>> resistor_parallel([3.21389, 2, -3])\nTraceback (most recent call last):\n    ...\nValueError: Resistor at index 2 has a negative or zero value!\n>>> resistor_parallel([3.21389, 2, 0.000])\nTraceback (most recent call last):\n    ...\nValueError: Resistor at index 2 has a negative or zero value!"
  },
  {
    "function": "resistor_series",
    "code": "def resistor_series(resistors: list[float]) -> float:\n    \"\"\"\n    Req = R1 + R2 + ... + Rn\n\n    Calculate the equivalent resistance for any number of resistors in parallel.\n\n    >>> resistor_series([3.21389, 2, 3])\n    8.21389\n    >>> resistor_series([3.21389, 2, -3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistor at index 2 has a negative value!\n    \"\"\"\n    sum_r = 0.00\n    for index, resistor in enumerate(resistors):\n        sum_r += resistor\n        if resistor < 0:\n            msg = f\"Resistor at index {index} has a negative value!\"\n            raise ValueError(msg)\n    return sum_r",
    "docstring": "Req = R1 + R2 + ... + Rn\n\nCalculate the equivalent resistance for any number of resistors in parallel.\n\n>>> resistor_series([3.21389, 2, 3])\n8.21389\n>>> resistor_series([3.21389, 2, -3])\nTraceback (most recent call last):\n    ...\nValueError: Resistor at index 2 has a negative value!"
  },
  {
    "function": "resonant_frequency",
    "code": "def resonant_frequency(inductance: float, capacitance: float) -> tuple:\n    \"\"\"\n    This function can calculate the resonant frequency of LC circuit,\n    for the given value of inductance and capacitnace.\n\n    Examples are given below:\n    >>> resonant_frequency(inductance=10, capacitance=5)\n    ('Resonant frequency', 0.022507907903927652)\n    >>> resonant_frequency(inductance=0, capacitance=5)\n    Traceback (most recent call last):\n      ...\n    ValueError: Inductance cannot be 0 or negative\n    >>> resonant_frequency(inductance=10, capacitance=0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Capacitance cannot be 0 or negative\n    \"\"\"\n\n    if inductance <= 0:\n        raise ValueError(\"Inductance cannot be 0 or negative\")\n\n    elif capacitance <= 0:\n        raise ValueError(\"Capacitance cannot be 0 or negative\")\n\n    else:\n        return (\n            \"Resonant frequency\",\n            float(1 / (2 * pi * (sqrt(inductance * capacitance)))),\n        )",
    "docstring": "This function can calculate the resonant frequency of LC circuit,\nfor the given value of inductance and capacitnace.\n\nExamples are given below:\n>>> resonant_frequency(inductance=10, capacitance=5)\n('Resonant frequency', 0.022507907903927652)\n>>> resonant_frequency(inductance=0, capacitance=5)\nTraceback (most recent call last):\n  ...\nValueError: Inductance cannot be 0 or negative\n>>> resonant_frequency(inductance=10, capacitance=0)\nTraceback (most recent call last):\n  ...\nValueError: Capacitance cannot be 0 or negative"
  },
  {
    "function": "wheatstone_solver",
    "code": "def wheatstone_solver(\n    resistance_1: float, resistance_2: float, resistance_3: float\n) -> float:\n    \"\"\"\n    This function can calculate the unknown resistance in an wheatstone network,\n    given that the three other resistances in the network are known.\n    The formula to calculate the same is:\n\n    ---------------\n    |Rx=(R2/R1)*R3|\n    ---------------\n\n    Usage examples:\n    >>> wheatstone_solver(resistance_1=2, resistance_2=4, resistance_3=5)\n    10.0\n    >>> wheatstone_solver(resistance_1=356, resistance_2=234, resistance_3=976)\n    641.5280898876405\n    >>> wheatstone_solver(resistance_1=2, resistance_2=-1, resistance_3=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: All resistance values must be positive\n    >>> wheatstone_solver(resistance_1=0, resistance_2=0, resistance_3=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: All resistance values must be positive\n    \"\"\"\n\n    if resistance_1 <= 0 or resistance_2 <= 0 or resistance_3 <= 0:\n        raise ValueError(\"All resistance values must be positive\")\n    else:\n        return float((resistance_2 / resistance_1) * resistance_3)",
    "docstring": "This function can calculate the unknown resistance in an wheatstone network,\ngiven that the three other resistances in the network are known.\nThe formula to calculate the same is:\n\n---------------\n|Rx=(R2/R1)*R3|\n---------------\n\nUsage examples:\n>>> wheatstone_solver(resistance_1=2, resistance_2=4, resistance_3=5)\n10.0\n>>> wheatstone_solver(resistance_1=356, resistance_2=234, resistance_3=976)\n641.5280898876405\n>>> wheatstone_solver(resistance_1=2, resistance_2=-1, resistance_3=2)\nTraceback (most recent call last):\n    ...\nValueError: All resistance values must be positive\n>>> wheatstone_solver(resistance_1=0, resistance_2=0, resistance_3=2)\nTraceback (most recent call last):\n    ...\nValueError: All resistance values must be positive"
  },
  {
    "function": "equated_monthly_installments",
    "code": "def equated_monthly_installments(\n    principal: float, rate_per_annum: float, years_to_repay: int\n) -> float:\n    \"\"\"\n    Formula for amortization amount per month:\n    A = p * r * (1 + r)^n / ((1 + r)^n - 1)\n    where p is the principal, r is the rate of interest per month\n    and n is the number of payments\n\n    >>> equated_monthly_installments(25000, 0.12, 3)\n    830.3577453212793\n    >>> equated_monthly_installments(25000, 0.12, 10)\n    358.67737100646826\n    >>> equated_monthly_installments(0, 0.12, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Principal borrowed must be > 0\n    >>> equated_monthly_installments(25000, -1, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Rate of interest must be >= 0\n    >>> equated_monthly_installments(25000, 0.12, 0)\n    Traceback (most recent call last):\n        ...\n    Exception: Years to repay must be an integer > 0\n    \"\"\"\n    if principal <= 0:\n        raise Exception(\"Principal borrowed must be > 0\")\n    if rate_per_annum < 0:\n        raise Exception(\"Rate of interest must be >= 0\")\n    if years_to_repay <= 0 or not isinstance(years_to_repay, int):\n        raise Exception(\"Years to repay must be an integer > 0\")\n\n    # Yearly rate is divided by 12 to get monthly rate\n    rate_per_month = rate_per_annum / 12\n\n    # Years to repay is multiplied by 12 to get number of payments as payment is monthly\n    number_of_payments = years_to_repay * 12\n\n    return (\n        principal\n        * rate_per_month\n        * (1 + rate_per_month) ** number_of_payments\n        / ((1 + rate_per_month) ** number_of_payments - 1)\n    )",
    "docstring": "Formula for amortization amount per month:\nA = p * r * (1 + r)^n / ((1 + r)^n - 1)\nwhere p is the principal, r is the rate of interest per month\nand n is the number of payments\n\n>>> equated_monthly_installments(25000, 0.12, 3)\n830.3577453212793\n>>> equated_monthly_installments(25000, 0.12, 10)\n358.67737100646826\n>>> equated_monthly_installments(0, 0.12, 3)\nTraceback (most recent call last):\n    ...\nException: Principal borrowed must be > 0\n>>> equated_monthly_installments(25000, -1, 3)\nTraceback (most recent call last):\n    ...\nException: Rate of interest must be >= 0\n>>> equated_monthly_installments(25000, 0.12, 0)\nTraceback (most recent call last):\n    ...\nException: Years to repay must be an integer > 0"
  },
  {
    "function": "exponential_moving_average",
    "code": "def exponential_moving_average(\n    stock_prices: Iterator[float], window_size: int\n) -> Iterator[float]:\n    \"\"\"\n    Yields exponential moving averages of the given stock prices.\n    >>> tuple(exponential_moving_average(iter([2, 5, 3, 8.2, 6, 9, 10]), 3))\n    (2, 3.5, 3.25, 5.725, 5.8625, 7.43125, 8.715625)\n\n    :param stock_prices: A stream of stock prices\n    :param window_size: The number of stock prices that will trigger a new calculation\n                        of the exponential average (window_size > 0)\n    :return: Yields a sequence of exponential moving averages\n\n    Formula:\n\n    st = alpha * xt + (1 - alpha) * st_prev\n\n    Where,\n    st : Exponential moving average at timestamp t\n    xt : stock price in from the stock prices at timestamp t\n    st_prev : Exponential moving average at timestamp t-1\n    alpha : 2/(1 + window_size) - smoothing factor\n\n    Exponential moving average (EMA) is a rule of thumb technique for\n    smoothing time series data using an exponential window function.\n    \"\"\"\n\n    if window_size <= 0:\n        raise ValueError(\"window_size must be > 0\")\n\n    # Calculating smoothing factor\n    alpha = 2 / (1 + window_size)\n\n    # Exponential average at timestamp t\n    moving_average = 0.0\n\n    for i, stock_price in enumerate(stock_prices):\n        if i <= window_size:\n            # Assigning simple moving average till the window_size for the first time\n            # is reached\n            moving_average = (moving_average + stock_price) * 0.5 if i else stock_price\n        else:\n            # Calculating exponential moving average based on current timestamp data\n            # point and previous exponential average value\n            moving_average = (alpha * stock_price) + ((1 - alpha) * moving_average)\n        yield moving_average",
    "docstring": "Yields exponential moving averages of the given stock prices.\n>>> tuple(exponential_moving_average(iter([2, 5, 3, 8.2, 6, 9, 10]), 3))\n(2, 3.5, 3.25, 5.725, 5.8625, 7.43125, 8.715625)\n\n:param stock_prices: A stream of stock prices\n:param window_size: The number of stock prices that will trigger a new calculation\n                    of the exponential average (window_size > 0)\n:return: Yields a sequence of exponential moving averages\n\nFormula:\n\nst = alpha * xt + (1 - alpha) * st_prev\n\nWhere,\nst : Exponential moving average at timestamp t\nxt : stock price in from the stock prices at timestamp t\nst_prev : Exponential moving average at timestamp t-1\nalpha : 2/(1 + window_size) - smoothing factor\n\nExponential moving average (EMA) is a rule of thumb technique for\nsmoothing time series data using an exponential window function."
  },
  {
    "function": "simple_interest",
    "code": "def simple_interest(\n    principal: float, daily_interest_rate: float, days_between_payments: float\n) -> float:\n    \"\"\"\n    >>> simple_interest(18000.0, 0.06, 3)\n    3240.0\n    >>> simple_interest(0.5, 0.06, 3)\n    0.09\n    >>> simple_interest(18000.0, 0.01, 10)\n    1800.0\n    >>> simple_interest(18000.0, 0.0, 3)\n    0.0\n    >>> simple_interest(5500.0, 0.01, 100)\n    5500.0\n    >>> simple_interest(10000.0, -0.06, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: daily_interest_rate must be >= 0\n    >>> simple_interest(-10000.0, 0.06, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: principal must be > 0\n    >>> simple_interest(5500.0, 0.01, -5)\n    Traceback (most recent call last):\n        ...\n    ValueError: days_between_payments must be > 0\n    \"\"\"\n    if days_between_payments <= 0:\n        raise ValueError(\"days_between_payments must be > 0\")\n    if daily_interest_rate < 0:\n        raise ValueError(\"daily_interest_rate must be >= 0\")\n    if principal <= 0:\n        raise ValueError(\"principal must be > 0\")\n    return principal * daily_interest_rate * days_between_payments",
    "docstring": ">>> simple_interest(18000.0, 0.06, 3)\n3240.0\n>>> simple_interest(0.5, 0.06, 3)\n0.09\n>>> simple_interest(18000.0, 0.01, 10)\n1800.0\n>>> simple_interest(18000.0, 0.0, 3)\n0.0\n>>> simple_interest(5500.0, 0.01, 100)\n5500.0\n>>> simple_interest(10000.0, -0.06, 3)\nTraceback (most recent call last):\n    ...\nValueError: daily_interest_rate must be >= 0\n>>> simple_interest(-10000.0, 0.06, 3)\nTraceback (most recent call last):\n    ...\nValueError: principal must be > 0\n>>> simple_interest(5500.0, 0.01, -5)\nTraceback (most recent call last):\n    ...\nValueError: days_between_payments must be > 0"
  },
  {
    "function": "compound_interest",
    "code": "def compound_interest(\n    principal: float,\n    nominal_annual_interest_rate_percentage: float,\n    number_of_compounding_periods: float,\n) -> float:\n    \"\"\"\n    >>> compound_interest(10000.0, 0.05, 3)\n    1576.2500000000014\n    >>> compound_interest(10000.0, 0.05, 1)\n    500.00000000000045\n    >>> compound_interest(0.5, 0.05, 3)\n    0.07881250000000006\n    >>> compound_interest(10000.0, 0.06, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: number_of_compounding_periods must be > 0\n    >>> compound_interest(10000.0, -3.5, 3.0)\n    Traceback (most recent call last):\n        ...\n    ValueError: nominal_annual_interest_rate_percentage must be >= 0\n    >>> compound_interest(-5500.0, 0.01, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: principal must be > 0\n    \"\"\"\n    if number_of_compounding_periods <= 0:\n        raise ValueError(\"number_of_compounding_periods must be > 0\")\n    if nominal_annual_interest_rate_percentage < 0:\n        raise ValueError(\"nominal_annual_interest_rate_percentage must be >= 0\")\n    if principal <= 0:\n        raise ValueError(\"principal must be > 0\")\n\n    return principal * (\n        (1 + nominal_annual_interest_rate_percentage) ** number_of_compounding_periods\n        - 1\n    )",
    "docstring": ">>> compound_interest(10000.0, 0.05, 3)\n1576.2500000000014\n>>> compound_interest(10000.0, 0.05, 1)\n500.00000000000045\n>>> compound_interest(0.5, 0.05, 3)\n0.07881250000000006\n>>> compound_interest(10000.0, 0.06, -4)\nTraceback (most recent call last):\n    ...\nValueError: number_of_compounding_periods must be > 0\n>>> compound_interest(10000.0, -3.5, 3.0)\nTraceback (most recent call last):\n    ...\nValueError: nominal_annual_interest_rate_percentage must be >= 0\n>>> compound_interest(-5500.0, 0.01, 5)\nTraceback (most recent call last):\n    ...\nValueError: principal must be > 0"
  },
  {
    "function": "apr_interest",
    "code": "def apr_interest(\n    principal: float,\n    nominal_annual_percentage_rate: float,\n    number_of_years: float,\n) -> float:\n    \"\"\"\n    >>> apr_interest(10000.0, 0.05, 3)\n    1618.223072263547\n    >>> apr_interest(10000.0, 0.05, 1)\n    512.6749646744732\n    >>> apr_interest(0.5, 0.05, 3)\n    0.08091115361317736\n    >>> apr_interest(10000.0, 0.06, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: number_of_years must be > 0\n    >>> apr_interest(10000.0, -3.5, 3.0)\n    Traceback (most recent call last):\n        ...\n    ValueError: nominal_annual_percentage_rate must be >= 0\n    >>> apr_interest(-5500.0, 0.01, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: principal must be > 0\n    \"\"\"\n    if number_of_years <= 0:\n        raise ValueError(\"number_of_years must be > 0\")\n    if nominal_annual_percentage_rate < 0:\n        raise ValueError(\"nominal_annual_percentage_rate must be >= 0\")\n    if principal <= 0:\n        raise ValueError(\"principal must be > 0\")\n\n    return compound_interest(\n        principal, nominal_annual_percentage_rate / 365, number_of_years * 365\n    )",
    "docstring": ">>> apr_interest(10000.0, 0.05, 3)\n1618.223072263547\n>>> apr_interest(10000.0, 0.05, 1)\n512.6749646744732\n>>> apr_interest(0.5, 0.05, 3)\n0.08091115361317736\n>>> apr_interest(10000.0, 0.06, -4)\nTraceback (most recent call last):\n    ...\nValueError: number_of_years must be > 0\n>>> apr_interest(10000.0, -3.5, 3.0)\nTraceback (most recent call last):\n    ...\nValueError: nominal_annual_percentage_rate must be >= 0\n>>> apr_interest(-5500.0, 0.01, 5)\nTraceback (most recent call last):\n    ...\nValueError: principal must be > 0"
  },
  {
    "function": "present_value",
    "code": "def present_value(discount_rate: float, cash_flows: list[float]) -> float:\n    \"\"\"\n    >>> present_value(0.13, [10, 20.70, -293, 297])\n    4.69\n    >>> present_value(0.07, [-109129.39, 30923.23, 15098.93, 29734,39])\n    -42739.63\n    >>> present_value(0.07, [109129.39, 30923.23, 15098.93, 29734,39])\n    175519.15\n    >>> present_value(-1, [109129.39, 30923.23, 15098.93, 29734,39])\n    Traceback (most recent call last):\n        ...\n    ValueError: Discount rate cannot be negative\n    >>> present_value(0.03, [])\n    Traceback (most recent call last):\n        ...\n    ValueError: Cash flows list cannot be empty\n    \"\"\"\n    if discount_rate < 0:\n        raise ValueError(\"Discount rate cannot be negative\")\n    if not cash_flows:\n        raise ValueError(\"Cash flows list cannot be empty\")\n    present_value = sum(\n        cash_flow / ((1 + discount_rate) ** i) for i, cash_flow in enumerate(cash_flows)\n    )\n    return round(present_value, ndigits=2)",
    "docstring": ">>> present_value(0.13, [10, 20.70, -293, 297])\n4.69\n>>> present_value(0.07, [-109129.39, 30923.23, 15098.93, 29734,39])\n-42739.63\n>>> present_value(0.07, [109129.39, 30923.23, 15098.93, 29734,39])\n175519.15\n>>> present_value(-1, [109129.39, 30923.23, 15098.93, 29734,39])\nTraceback (most recent call last):\n    ...\nValueError: Discount rate cannot be negative\n>>> present_value(0.03, [])\nTraceback (most recent call last):\n    ...\nValueError: Cash flows list cannot be empty"
  },
  {
    "function": "price_plus_tax",
    "code": "def price_plus_tax(price: float, tax_rate: float) -> float:\n    \"\"\"\n    >>> price_plus_tax(100, 0.25)\n    125.0\n    >>> price_plus_tax(125.50, 0.05)\n    131.775\n    \"\"\"\n    return price * (1 + tax_rate)",
    "docstring": ">>> price_plus_tax(100, 0.25)\n125.0\n>>> price_plus_tax(125.50, 0.05)\n131.775"
  },
  {
    "function": "simple_moving_average",
    "code": "def simple_moving_average(\n    data: Sequence[float], window_size: int\n) -> list[float | None]:\n    \"\"\"\n    Calculate the simple moving average (SMA) for some given time series data.\n\n    :param data: A list of numerical data points.\n    :param window_size: An integer representing the size of the SMA window.\n    :return: A list of SMA values with the same length as the input data.\n\n    Examples:\n    >>> sma = simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 3)\n    >>> [round(value, 2) if value is not None else None for value in sma]\n    [None, None, 12.33, 13.33, 14.0, 14.33, 16.0, 17.0, 18.0, 19.0]\n    >>> simple_moving_average([10, 12, 15], 5)\n    [None, None, None]\n    >>> simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Window size must be a positive integer\n    \"\"\"\n    if window_size < 1:\n        raise ValueError(\"Window size must be a positive integer\")\n\n    sma: list[float | None] = []\n\n    for i in range(len(data)):\n        if i < window_size - 1:\n            sma.append(None)  # SMA not available for early data points\n        else:\n            window = data[i - window_size + 1 : i + 1]\n            sma_value = sum(window) / window_size\n            sma.append(sma_value)\n    return sma",
    "docstring": "Calculate the simple moving average (SMA) for some given time series data.\n\n:param data: A list of numerical data points.\n:param window_size: An integer representing the size of the SMA window.\n:return: A list of SMA values with the same length as the input data.\n\nExamples:\n>>> sma = simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 3)\n>>> [round(value, 2) if value is not None else None for value in sma]\n[None, None, 12.33, 13.33, 14.0, 14.33, 16.0, 17.0, 18.0, 19.0]\n>>> simple_moving_average([10, 12, 15], 5)\n[None, None, None]\n>>> simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 0)\nTraceback (most recent call last):\n...\nValueError: Window size must be a positive integer"
  },
  {
    "function": "straight_line_depreciation",
    "code": "def straight_line_depreciation(\n    useful_years: int,\n    purchase_value: float,\n    residual_value: float = 0.0,\n) -> list[float]:\n    \"\"\"\n    Calculate the depreciation expenses over the given period\n    :param useful_years: Number of years the asset will be used\n    :param purchase_value: Purchase expenditure for the asset\n    :param residual_value: Residual value of the asset at the end of its useful life\n    :return: A list of annual depreciation expenses over the asset's useful life\n    >>> straight_line_depreciation(10, 1100.0, 100.0)\n    [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0]\n    >>> straight_line_depreciation(6, 1250.0, 50.0)\n    [200.0, 200.0, 200.0, 200.0, 200.0, 200.0]\n    >>> straight_line_depreciation(4, 1001.0)\n    [250.25, 250.25, 250.25, 250.25]\n    >>> straight_line_depreciation(11, 380.0, 50.0)\n    [30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0]\n    >>> straight_line_depreciation(1, 4985, 100)\n    [4885.0]\n    \"\"\"\n\n    if not isinstance(useful_years, int):\n        raise TypeError(\"Useful years must be an integer\")\n\n    if useful_years < 1:\n        raise ValueError(\"Useful years cannot be less than 1\")\n\n    if not isinstance(purchase_value, (float, int)):\n        raise TypeError(\"Purchase value must be numeric\")\n\n    if not isinstance(residual_value, (float, int)):\n        raise TypeError(\"Residual value must be numeric\")\n\n    if purchase_value < 0.0:\n        raise ValueError(\"Purchase value cannot be less than zero\")\n\n    if purchase_value < residual_value:\n        raise ValueError(\"Purchase value cannot be less than residual value\")\n\n    # Calculate annual depreciation expense\n    depreciable_cost = purchase_value - residual_value\n    annual_depreciation_expense = depreciable_cost / useful_years\n\n    # List of annual depreciation expenses\n    list_of_depreciation_expenses = []\n    accumulated_depreciation_expense = 0.0\n    for period in range(useful_years):\n        if period != useful_years - 1:\n            accumulated_depreciation_expense += annual_depreciation_expense\n            list_of_depreciation_expenses.append(annual_depreciation_expense)\n        else:\n            depreciation_expense_in_end_year = (\n                depreciable_cost - accumulated_depreciation_expense\n            )\n            list_of_depreciation_expenses.append(depreciation_expense_in_end_year)\n\n    return list_of_depreciation_expenses",
    "docstring": "Calculate the depreciation expenses over the given period\n:param useful_years: Number of years the asset will be used\n:param purchase_value: Purchase expenditure for the asset\n:param residual_value: Residual value of the asset at the end of its useful life\n:return: A list of annual depreciation expenses over the asset's useful life\n>>> straight_line_depreciation(10, 1100.0, 100.0)\n[100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0]\n>>> straight_line_depreciation(6, 1250.0, 50.0)\n[200.0, 200.0, 200.0, 200.0, 200.0, 200.0]\n>>> straight_line_depreciation(4, 1001.0)\n[250.25, 250.25, 250.25, 250.25]\n>>> straight_line_depreciation(11, 380.0, 50.0)\n[30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0]\n>>> straight_line_depreciation(1, 4985, 100)\n[4885.0]"
  },
  {
    "function": "pay",
    "code": "def pay(hours_worked: float, pay_rate: float, hours: float = 40) -> float:\n    \"\"\"\n    hours_worked = The total hours worked\n    pay_rate = Amount of money per hour\n    hours = Number of hours that must be worked before you receive time and a half\n\n    >>> pay(41, 1)\n    41.5\n    >>> pay(65, 19)\n    1472.5\n    >>> pay(10, 1)\n    10.0\n    \"\"\"\n    # Check that all input parameters are float or integer\n    assert isinstance(hours_worked, (float, int)), (\n        \"Parameter 'hours_worked' must be of type 'int' or 'float'\"\n    )\n    assert isinstance(pay_rate, (float, int)), (\n        \"Parameter 'pay_rate' must be of type 'int' or 'float'\"\n    )\n    assert isinstance(hours, (float, int)), (\n        \"Parameter 'hours' must be of type 'int' or 'float'\"\n    )\n\n    normal_pay = hours_worked * pay_rate\n    over_time = max(0, hours_worked - hours)\n    over_time_pay = over_time * pay_rate / 2\n    return normal_pay + over_time_pay",
    "docstring": "hours_worked = The total hours worked\npay_rate = Amount of money per hour\nhours = Number of hours that must be worked before you receive time and a half\n\n>>> pay(41, 1)\n41.5\n>>> pay(65, 19)\n1472.5\n>>> pay(10, 1)\n10.0"
  },
  {
    "function": "eval_exponential",
    "code": "def eval_exponential(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate $e^z + c$.\n    >>> float(eval_exponential(0, 0))\n    1.0\n    >>> bool(abs(eval_exponential(1, np.pi*1.j)) < 1e-15)\n    True\n    >>> bool(abs(eval_exponential(1.j, 0)-1-1.j) < 1e-15)\n    True\n    \"\"\"\n    return np.exp(z_values) + c_parameter",
    "docstring": "Evaluate $e^z + c$.\n>>> float(eval_exponential(0, 0))\n1.0\n>>> bool(abs(eval_exponential(1, np.pi*1.j)) < 1e-15)\nTrue\n>>> bool(abs(eval_exponential(1.j, 0)-1-1.j) < 1e-15)\nTrue"
  },
  {
    "function": "eval_quadratic_polynomial",
    "code": "def eval_quadratic_polynomial(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:\n    \"\"\"\n    >>> eval_quadratic_polynomial(0, 2)\n    4\n    >>> eval_quadratic_polynomial(-1, 1)\n    0\n    >>> round(eval_quadratic_polynomial(1.j, 0).imag)\n    1\n    >>> round(eval_quadratic_polynomial(1.j, 0).real)\n    0\n    \"\"\"\n    return z_values * z_values + c_parameter",
    "docstring": ">>> eval_quadratic_polynomial(0, 2)\n4\n>>> eval_quadratic_polynomial(-1, 1)\n0\n>>> round(eval_quadratic_polynomial(1.j, 0).imag)\n1\n>>> round(eval_quadratic_polynomial(1.j, 0).real)\n0"
  },
  {
    "function": "prepare_grid",
    "code": "def prepare_grid(window_size: float, nb_pixels: int) -> np.ndarray:\n    \"\"\"\n    Create a grid of complex values of size nb_pixels*nb_pixels with real and\n     imaginary parts ranging from -window_size to window_size (inclusive).\n    Returns a numpy array.\n\n    >>> prepare_grid(1,3)\n    array([[-1.-1.j, -1.+0.j, -1.+1.j],\n           [ 0.-1.j,  0.+0.j,  0.+1.j],\n           [ 1.-1.j,  1.+0.j,  1.+1.j]])\n    \"\"\"\n    x = np.linspace(-window_size, window_size, nb_pixels)\n    x = x.reshape((nb_pixels, 1))\n    y = np.linspace(-window_size, window_size, nb_pixels)\n    y = y.reshape((1, nb_pixels))\n    return x + 1.0j * y",
    "docstring": "Create a grid of complex values of size nb_pixels*nb_pixels with real and\n imaginary parts ranging from -window_size to window_size (inclusive).\nReturns a numpy array.\n\n>>> prepare_grid(1,3)\narray([[-1.-1.j, -1.+0.j, -1.+1.j],\n       [ 0.-1.j,  0.+0.j,  0.+1.j],\n       [ 1.-1.j,  1.+0.j,  1.+1.j]])"
  },
  {
    "function": "iterate_function",
    "code": "def iterate_function(\n    eval_function: Callable[[Any, np.ndarray], np.ndarray],\n    function_params: Any,\n    nb_iterations: int,\n    z_0: np.ndarray,\n    infinity: float | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Iterate the function \"eval_function\" exactly nb_iterations times.\n    The first argument of the function is a parameter which is contained in\n    function_params. The variable z_0 is an array that contains the initial\n    values to iterate from.\n    This function returns the final iterates.\n\n    >>> iterate_function(eval_quadratic_polynomial, 0, 3, np.array([0,1,2])).shape\n    (3,)\n    >>> complex(np.round(iterate_function(eval_quadratic_polynomial,\n    ... 0,\n    ... 3,\n    ... np.array([0,1,2]))[0]))\n    0j\n    >>> complex(np.round(iterate_function(eval_quadratic_polynomial,\n    ... 0,\n    ... 3,\n    ... np.array([0,1,2]))[1]))\n    (1+0j)\n    >>> complex(np.round(iterate_function(eval_quadratic_polynomial,\n    ... 0,\n    ... 3,\n    ... np.array([0,1,2]))[2]))\n    (256+0j)\n    \"\"\"\n\n    z_n = z_0.astype(\"complex64\")\n    for _ in range(nb_iterations):\n        z_n = eval_function(function_params, z_n)\n        if infinity is not None:\n            np.nan_to_num(z_n, copy=False, nan=infinity)\n            z_n[abs(z_n) == np.inf] = infinity\n    return z_n",
    "docstring": "Iterate the function \"eval_function\" exactly nb_iterations times.\nThe first argument of the function is a parameter which is contained in\nfunction_params. The variable z_0 is an array that contains the initial\nvalues to iterate from.\nThis function returns the final iterates.\n\n>>> iterate_function(eval_quadratic_polynomial, 0, 3, np.array([0,1,2])).shape\n(3,)\n>>> complex(np.round(iterate_function(eval_quadratic_polynomial,\n... 0,\n... 3,\n... np.array([0,1,2]))[0]))\n0j\n>>> complex(np.round(iterate_function(eval_quadratic_polynomial,\n... 0,\n... 3,\n... np.array([0,1,2]))[1]))\n(1+0j)\n>>> complex(np.round(iterate_function(eval_quadratic_polynomial,\n... 0,\n... 3,\n... np.array([0,1,2]))[2]))\n(256+0j)"
  },
  {
    "function": "show_results",
    "code": "def show_results(\n    function_label: str,\n    function_params: Any,\n    escape_radius: float,\n    z_final: np.ndarray,\n) -> None:\n    \"\"\"\n    Plots of whether the absolute value of z_final is greater than\n    the value of escape_radius. Adds the function_label and function_params to\n    the title.\n\n    >>> show_results('80', 0, 1, np.array([[0,1,.5],[.4,2,1.1],[.2,1,1.3]]))\n    \"\"\"\n\n    abs_z_final = (abs(z_final)).transpose()\n    abs_z_final[:, :] = abs_z_final[::-1, :]\n    plt.matshow(abs_z_final < escape_radius)\n    plt.title(f\"Julia set of ${function_label}$, $c={function_params}$\")\n    plt.show()",
    "docstring": "Plots of whether the absolute value of z_final is greater than\nthe value of escape_radius. Adds the function_label and function_params to\nthe title.\n\n>>> show_results('80', 0, 1, np.array([[0,1,.5],[.4,2,1.1],[.2,1,1.3]]))"
  },
  {
    "function": "ignore_overflow_warnings",
    "code": "def ignore_overflow_warnings() -> None:\n    \"\"\"\n    Ignore some overflow and invalid value warnings.\n\n    >>> ignore_overflow_warnings()\n    \"\"\"\n    warnings.filterwarnings(\n        \"ignore\", category=RuntimeWarning, message=\"overflow encountered in multiply\"\n    )\n    warnings.filterwarnings(\n        \"ignore\",\n        category=RuntimeWarning,\n        message=\"invalid value encountered in multiply\",\n    )\n    warnings.filterwarnings(\n        \"ignore\", category=RuntimeWarning, message=\"overflow encountered in absolute\"\n    )\n    warnings.filterwarnings(\n        \"ignore\", category=RuntimeWarning, message=\"overflow encountered in exp\"\n    )",
    "docstring": "Ignore some overflow and invalid value warnings.\n\n>>> ignore_overflow_warnings()"
  },
  {
    "function": "iterate",
    "code": "def iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:\n    \"\"\"\n    Go through the number of iterations determined by the argument \"steps\".\n    Be careful with high values (above 5) since the time to calculate increases\n    exponentially.\n    >>> iterate([np.array([0, 0]), np.array([1, 0])], 1)\n    [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , \\\n0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]\n    \"\"\"\n    vectors = initial_vectors\n    for _ in range(steps):\n        vectors = iteration_step(vectors)\n    return vectors",
    "docstring": "Go through the number of iterations determined by the argument \"steps\".\nBe careful with high values (above 5) since the time to calculate increases\nexponentially.\n>>> iterate([np.array([0, 0]), np.array([1, 0])], 1)\n[array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , 0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]"
  },
  {
    "function": "iteration_step",
    "code": "def iteration_step(vectors: list[np.ndarray]) -> list[np.ndarray]:\n    \"\"\"\n    Loops through each pair of adjacent vectors. Each line between two adjacent\n    vectors is divided into 4 segments by adding 3 additional vectors in-between\n    the original two vectors. The vector in the middle is constructed through a\n    60 degree rotation so it is bent outwards.\n    >>> iteration_step([np.array([0, 0]), np.array([1, 0])])\n    [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , \\\n0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]\n    \"\"\"\n    new_vectors = []\n    for i, start_vector in enumerate(vectors[:-1]):\n        end_vector = vectors[i + 1]\n        new_vectors.append(start_vector)\n        difference_vector = end_vector - start_vector\n        new_vectors.append(start_vector + difference_vector / 3)\n        new_vectors.append(\n            start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)\n        )\n        new_vectors.append(start_vector + difference_vector * 2 / 3)\n    new_vectors.append(vectors[-1])\n    return new_vectors",
    "docstring": "Loops through each pair of adjacent vectors. Each line between two adjacent\nvectors is divided into 4 segments by adding 3 additional vectors in-between\nthe original two vectors. The vector in the middle is constructed through a\n60 degree rotation so it is bent outwards.\n>>> iteration_step([np.array([0, 0]), np.array([1, 0])])\n[array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , 0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]"
  },
  {
    "function": "rotate",
    "code": "def rotate(vector: np.ndarray, angle_in_degrees: float) -> np.ndarray:\n    \"\"\"\n    Standard rotation of a 2D vector with a rotation matrix\n    (see https://en.wikipedia.org/wiki/Rotation_matrix )\n    >>> rotate(np.array([1, 0]), 60)\n    array([0.5      , 0.8660254])\n    >>> rotate(np.array([1, 0]), 90)\n    array([6.123234e-17, 1.000000e+00])\n    \"\"\"\n    theta = np.radians(angle_in_degrees)\n    c, s = np.cos(theta), np.sin(theta)\n    rotation_matrix = np.array(((c, -s), (s, c)))\n    return np.dot(rotation_matrix, vector)",
    "docstring": "Standard rotation of a 2D vector with a rotation matrix\n(see https://en.wikipedia.org/wiki/Rotation_matrix )\n>>> rotate(np.array([1, 0]), 60)\narray([0.5      , 0.8660254])\n>>> rotate(np.array([1, 0]), 90)\narray([6.123234e-17, 1.000000e+00])"
  },
  {
    "function": "plot",
    "code": "def plot(vectors: list[np.ndarray]) -> None:\n    \"\"\"\n    Utility function to plot the vectors using matplotlib.pyplot\n    No doctest was implemented since this function does not have a return value\n    \"\"\"\n    # avoid stretched display of graph\n    axes = plt.gca()\n    axes.set_aspect(\"equal\")\n\n    # matplotlib.pyplot.plot takes a list of all x-coordinates and a list of all\n    # y-coordinates as inputs, which are constructed from the vector-list using\n    # zip()\n    x_coordinates, y_coordinates = zip(*vectors)\n    plt.plot(x_coordinates, y_coordinates)\n    plt.show()",
    "docstring": "Utility function to plot the vectors using matplotlib.pyplot\nNo doctest was implemented since this function does not have a return value"
  },
  {
    "function": "get_distance",
    "code": "def get_distance(x: float, y: float, max_step: int) -> float:\n    \"\"\"\n    Return the relative distance (= step/max_step) after which the complex number\n    constituted by this x-y-pair diverges. Members of the Mandelbrot set do not\n    diverge so their distance is 1.\n\n    >>> get_distance(0, 0, 50)\n    1.0\n    >>> get_distance(0.5, 0.5, 50)\n    0.061224489795918366\n    >>> get_distance(2, 0, 50)\n    0.0\n    \"\"\"\n    a = x\n    b = y\n    for step in range(max_step):  # noqa: B007\n        a_new = a * a - b * b + x\n        b = 2 * a * b + y\n        a = a_new\n\n        # divergence happens for all complex number with an absolute value\n        # greater than 4\n        if a * a + b * b > 4:\n            break\n    return step / (max_step - 1)",
    "docstring": "Return the relative distance (= step/max_step) after which the complex number\nconstituted by this x-y-pair diverges. Members of the Mandelbrot set do not\ndiverge so their distance is 1.\n\n>>> get_distance(0, 0, 50)\n1.0\n>>> get_distance(0.5, 0.5, 50)\n0.061224489795918366\n>>> get_distance(2, 0, 50)\n0.0"
  },
  {
    "function": "get_black_and_white_rgb",
    "code": "def get_black_and_white_rgb(distance: float) -> tuple:\n    \"\"\"\n    Black&white color-coding that ignores the relative distance. The Mandelbrot\n    set is black, everything else is white.\n\n    >>> get_black_and_white_rgb(0)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(0.5)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return (255, 255, 255)",
    "docstring": "Black&white color-coding that ignores the relative distance. The Mandelbrot\nset is black, everything else is white.\n\n>>> get_black_and_white_rgb(0)\n(255, 255, 255)\n>>> get_black_and_white_rgb(0.5)\n(255, 255, 255)\n>>> get_black_and_white_rgb(1)\n(0, 0, 0)"
  },
  {
    "function": "get_color_coded_rgb",
    "code": "def get_color_coded_rgb(distance: float) -> tuple:\n    \"\"\"\n    Color-coding taking the relative distance into account. The Mandelbrot set\n    is black.\n\n    >>> get_color_coded_rgb(0)\n    (255, 0, 0)\n    >>> get_color_coded_rgb(0.5)\n    (0, 255, 255)\n    >>> get_color_coded_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return tuple(round(i * 255) for i in colorsys.hsv_to_rgb(distance, 1, 1))",
    "docstring": "Color-coding taking the relative distance into account. The Mandelbrot set\nis black.\n\n>>> get_color_coded_rgb(0)\n(255, 0, 0)\n>>> get_color_coded_rgb(0.5)\n(0, 255, 255)\n>>> get_color_coded_rgb(1)\n(0, 0, 0)"
  },
  {
    "function": "get_image",
    "code": "def get_image(\n    image_width: int = 800,\n    image_height: int = 600,\n    figure_center_x: float = -0.6,\n    figure_center_y: float = 0,\n    figure_width: float = 3.2,\n    max_step: int = 50,\n    use_distance_color_coding: bool = True,\n) -> Image.Image:\n    \"\"\"\n    Function to generate the image of the Mandelbrot set. Two types of coordinates\n    are used: image-coordinates that refer to the pixels and figure-coordinates\n    that refer to the complex numbers inside and outside the Mandelbrot set. The\n    figure-coordinates in the arguments of this function determine which section\n    of the Mandelbrot set is viewed. The main area of the Mandelbrot set is\n    roughly between \"-1.5 < x < 0.5\" and \"-1 < y < 1\" in the figure-coordinates.\n\n    Commenting out tests that slow down pytest...\n    # 13.35s call     fractals/mandelbrot.py::mandelbrot.get_image\n    # >>> get_image().load()[0,0]\n    (255, 0, 0)\n    # >>> get_image(use_distance_color_coding = False).load()[0,0]\n    (255, 255, 255)\n    \"\"\"\n    img = Image.new(\"RGB\", (image_width, image_height))\n    pixels = img.load()\n\n    # loop through the image-coordinates\n    for image_x in range(image_width):\n        for image_y in range(image_height):\n            # determine the figure-coordinates based on the image-coordinates\n            figure_height = figure_width / image_width * image_height\n            figure_x = figure_center_x + (image_x / image_width - 0.5) * figure_width\n            figure_y = figure_center_y + (image_y / image_height - 0.5) * figure_height\n\n            distance = get_distance(figure_x, figure_y, max_step)\n\n            # color the corresponding pixel based on the selected coloring-function\n            if use_distance_color_coding:\n                pixels[image_x, image_y] = get_color_coded_rgb(distance)\n            else:\n                pixels[image_x, image_y] = get_black_and_white_rgb(distance)\n\n    return img",
    "docstring": "Function to generate the image of the Mandelbrot set. Two types of coordinates\nare used: image-coordinates that refer to the pixels and figure-coordinates\nthat refer to the complex numbers inside and outside the Mandelbrot set. The\nfigure-coordinates in the arguments of this function determine which section\nof the Mandelbrot set is viewed. The main area of the Mandelbrot set is\nroughly between \"-1.5 < x < 0.5\" and \"-1 < y < 1\" in the figure-coordinates.\n\nCommenting out tests that slow down pytest...\n# 13.35s call     fractals/mandelbrot.py::mandelbrot.get_image\n# >>> get_image().load()[0,0]\n(255, 0, 0)\n# >>> get_image(use_distance_color_coding = False).load()[0,0]\n(255, 255, 255)"
  },
  {
    "function": "get_mid",
    "code": "def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2",
    "docstring": "Find the midpoint of two points\n\n>>> get_mid((0, 0), (2, 2))\n(1.0, 1.0)\n>>> get_mid((-3, -3), (3, 3))\n(0.0, 0.0)\n>>> get_mid((1, 0), (3, 2))\n(2.0, 1.0)\n>>> get_mid((0, 0), (1, 1))\n(0.5, 0.5)\n>>> get_mid((0, 0), (0, 0))\n(0.0, 0.0)"
  },
  {
    "function": "triangle",
    "code": "def triangle(\n    vertex1: tuple[float, float],\n    vertex2: tuple[float, float],\n    vertex3: tuple[float, float],\n    depth: int,\n) -> None:\n    \"\"\"\n    Recursively draw the Sierpinski triangle given the vertices of the triangle\n    and the recursion depth\n    \"\"\"\n    my_pen.up()\n    my_pen.goto(vertex1[0], vertex1[1])\n    my_pen.down()\n    my_pen.goto(vertex2[0], vertex2[1])\n    my_pen.goto(vertex3[0], vertex3[1])\n    my_pen.goto(vertex1[0], vertex1[1])\n\n    if depth == 0:\n        return\n\n    triangle(vertex1, get_mid(vertex1, vertex2), get_mid(vertex1, vertex3), depth - 1)\n    triangle(vertex2, get_mid(vertex1, vertex2), get_mid(vertex2, vertex3), depth - 1)\n    triangle(vertex3, get_mid(vertex3, vertex2), get_mid(vertex1, vertex3), depth - 1)",
    "docstring": "Recursively draw the Sierpinski triangle given the vertices of the triangle\nand the recursion depth"
  },
  {
    "function": "draw_cross",
    "code": "def draw_cross(x: float, y: float, length: float):\n    \"\"\"\n    Draw a cross at the specified position and with the specified length.\n    \"\"\"\n    turtle.up()\n    turtle.goto(x - length / 2, y - length / 6)\n    turtle.down()\n    turtle.seth(0)\n    turtle.begin_fill()\n    for _ in range(4):\n        turtle.fd(length / 3)\n        turtle.right(90)\n        turtle.fd(length / 3)\n        turtle.left(90)\n        turtle.fd(length / 3)\n        turtle.left(90)\n    turtle.end_fill()",
    "docstring": "Draw a cross at the specified position and with the specified length."
  },
  {
    "function": "draw_fractal_recursive",
    "code": "def draw_fractal_recursive(x: float, y: float, length: float, depth: float):\n    \"\"\"\n    Recursively draw the Vicsek fractal at the specified position, with the\n    specified length and depth.\n    \"\"\"\n    if depth == 0:\n        draw_cross(x, y, length)\n        return\n\n    draw_fractal_recursive(x, y, length / 3, depth - 1)\n    draw_fractal_recursive(x + length / 3, y, length / 3, depth - 1)\n    draw_fractal_recursive(x - length / 3, y, length / 3, depth - 1)\n    draw_fractal_recursive(x, y + length / 3, length / 3, depth - 1)\n    draw_fractal_recursive(x, y - length / 3, length / 3, depth - 1)",
    "docstring": "Recursively draw the Vicsek fractal at the specified position, with the\nspecified length and depth."
  },
  {
    "function": "draw_vicsek_fractal",
    "code": "def draw_vicsek_fractal(x: float, y: float, length: float, depth: float, color=\"blue\"):\n    \"\"\"\n    Draw the Vicsek fractal at the specified position, with the specified\n    length and depth.\n    \"\"\"\n    turtle.speed(0)\n    turtle.hideturtle()\n    set_color(color)\n    draw_fractal_recursive(x, y, length, depth)\n    turtle.Screen().update()",
    "docstring": "Draw the Vicsek fractal at the specified position, with the specified\nlength and depth."
  },
  {
    "function": "evaluate",
    "code": "def evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))",
    "docstring": "Evaluate how similar the item is with the target by just\ncounting each char in the right position\n>>> evaluate(\"Helxo Worlx\", \"Hello World\")\n('Helxo Worlx', 9.0)"
  },
  {
    "function": "crossover",
    "code": "def crossover(parent_1: str, parent_2: str) -> tuple[str, str]:\n    \"\"\"\n    Slice and combine two strings at a random point.\n    >>> random.seed(42)\n    >>> crossover(\"123456\", \"abcdef\")\n    ('12345f', 'abcde6')\n    \"\"\"\n    random_slice = random.randint(0, len(parent_1) - 1)\n    child_1 = parent_1[:random_slice] + parent_2[random_slice:]\n    child_2 = parent_2[:random_slice] + parent_1[random_slice:]\n    return (child_1, child_2)",
    "docstring": "Slice and combine two strings at a random point.\n>>> random.seed(42)\n>>> crossover(\"123456\", \"abcdef\")\n('12345f', 'abcde6')"
  },
  {
    "function": "mutate",
    "code": "def mutate(child: str, genes: list[str]) -> str:\n    \"\"\"\n    Mutate a random gene of a child with another one from the list.\n    >>> random.seed(123)\n    >>> mutate(\"123456\", list(\"ABCDEF\"))\n    '12345A'\n    \"\"\"\n    child_list = list(child)\n    if random.uniform(0, 1) < MUTATION_PROBABILITY:\n        child_list[random.randint(0, len(child)) - 1] = random.choice(genes)\n    return \"\".join(child_list)",
    "docstring": "Mutate a random gene of a child with another one from the list.\n>>> random.seed(123)\n>>> mutate(\"123456\", list(\"ABCDEF\"))\n'12345A'"
  },
  {
    "function": "select",
    "code": "def select(\n    parent_1: tuple[str, float],\n    population_score: list[tuple[str, float]],\n    genes: list[str],\n) -> list[str]:\n    \"\"\"\n    Select the second parent and generate new population\n\n    >>> random.seed(42)\n    >>> parent_1 = (\"123456\", 8.0)\n    >>> population_score = [(\"abcdef\", 4.0), (\"ghijkl\", 5.0), (\"mnopqr\", 7.0)]\n    >>> genes = list(\"ABCDEF\")\n    >>> child_n = int(min(parent_1[1] + 1, 10))\n    >>> population = []\n    >>> for _ in range(child_n):\n    ...     parent_2 = population_score[random.randrange(len(population_score))][0]\n    ...     child_1, child_2 = crossover(parent_1[0], parent_2)\n    ...     population.extend((mutate(child_1, genes), mutate(child_2, genes)))\n    >>> len(population) == (int(parent_1[1]) + 1) * 2\n    True\n    \"\"\"\n    pop = []\n    # Generate more children proportionally to the fitness score.\n    child_n = int(parent_1[1] * 100) + 1\n    child_n = 10 if child_n >= 10 else child_n\n    for _ in range(child_n):\n        parent_2 = population_score[random.randint(0, N_SELECTED)][0]\n\n        child_1, child_2 = crossover(parent_1[0], parent_2)\n        # Append new string to the population list.\n        pop.append(mutate(child_1, genes))\n        pop.append(mutate(child_2, genes))\n    return pop",
    "docstring": "Select the second parent and generate new population\n\n>>> random.seed(42)\n>>> parent_1 = (\"123456\", 8.0)\n>>> population_score = [(\"abcdef\", 4.0), (\"ghijkl\", 5.0), (\"mnopqr\", 7.0)]\n>>> genes = list(\"ABCDEF\")\n>>> child_n = int(min(parent_1[1] + 1, 10))\n>>> population = []\n>>> for _ in range(child_n):\n...     parent_2 = population_score[random.randrange(len(population_score))][0]\n...     child_1, child_2 = crossover(parent_1[0], parent_2)\n...     population.extend((mutate(child_1, genes), mutate(child_2, genes)))\n>>> len(population) == (int(parent_1[1]) + 1) * 2\nTrue"
  },
  {
    "function": "basic",
    "code": "def basic(target: str, genes: list[str], debug: bool = True) -> tuple[int, int, str]:\n    \"\"\"\n    Verify that the target contains no genes besides the ones inside genes variable.\n\n    >>> from string import ascii_lowercase\n    >>> basic(\"doctest\", ascii_lowercase, debug=False)[2]\n    'doctest'\n    >>> genes = list(ascii_lowercase)\n    >>> genes.remove(\"e\")\n    >>> basic(\"test\", genes)\n    Traceback (most recent call last):\n        ...\n    ValueError: ['e'] is not in genes list, evolution cannot converge\n    >>> genes.remove(\"s\")\n    >>> basic(\"test\", genes)\n    Traceback (most recent call last):\n        ...\n    ValueError: ['e', 's'] is not in genes list, evolution cannot converge\n    >>> genes.remove(\"t\")\n    >>> basic(\"test\", genes)\n    Traceback (most recent call last):\n        ...\n    ValueError: ['e', 's', 't'] is not in genes list, evolution cannot converge\n    \"\"\"\n\n    # Verify if N_POPULATION is bigger than N_SELECTED\n    if N_POPULATION < N_SELECTED:\n        msg = f\"{N_POPULATION} must be bigger than {N_SELECTED}\"\n        raise ValueError(msg)\n    # Verify that the target contains no genes besides the ones inside genes variable.\n    not_in_genes_list = sorted({c for c in target if c not in genes})\n    if not_in_genes_list:\n        msg = f\"{not_in_genes_list} is not in genes list, evolution cannot converge\"\n        raise ValueError(msg)\n\n    # Generate random starting population.\n    population = []\n    for _ in range(N_POPULATION):\n        population.append(\"\".join([random.choice(genes) for i in range(len(target))]))\n\n    # Just some logs to know what the algorithms is doing.\n    generation, total_population = 0, 0\n\n    # This loop will end when we find a perfect match for our target.\n    while True:\n        generation += 1\n        total_population += len(population)\n\n        # Random population created. Now it's time to evaluate.\n\n        # (Option 1) Adding a bit of concurrency can make everything faster,\n        #\n        # import concurrent.futures\n        # population_score: list[tuple[str, float]] = []\n        # with concurrent.futures.ThreadPoolExecutor(\n        #                                   max_workers=NUM_WORKERS) as executor:\n        #     futures = {executor.submit(evaluate, item, target) for item in population}\n        #     concurrent.futures.wait(futures)\n        #     population_score = [item.result() for item in futures]\n        #\n        # but with a simple algorithm like this, it will probably be slower.\n        # (Option 2) We just need to call evaluate for every item inside the population.\n        population_score = [evaluate(item, target) for item in population]\n\n        # Check if there is a matching evolution.\n        population_score = sorted(population_score, key=lambda x: x[1], reverse=True)\n        if population_score[0][0] == target:\n            return (generation, total_population, population_score[0][0])\n\n        # Print the best result every 10 generation.\n        # Just to know that the algorithm is working.\n        if debug and generation % 10 == 0:\n            print(\n                f\"\\nGeneration: {generation}\"\n                f\"\\nTotal Population:{total_population}\"\n                f\"\\nBest score: {population_score[0][1]}\"\n                f\"\\nBest string: {population_score[0][0]}\"\n            )\n\n        # Flush the old population, keeping some of the best evolutions.\n        # Keeping this avoid regression of evolution.\n        population_best = population[: int(N_POPULATION / 3)]\n        population.clear()\n        population.extend(population_best)\n        # Normalize population score to be between 0 and 1.\n        population_score = [\n            (item, score / len(target)) for item, score in population_score\n        ]\n\n        # This is selection\n        for i in range(N_SELECTED):\n            population.extend(select(population_score[int(i)], population_score, genes))\n            # Check if the population has already reached the maximum value and if so,\n            # break the cycle.  If this check is disabled, the algorithm will take\n            # forever to compute large strings, but will also calculate small strings in\n            # a far fewer generations.\n            if len(population) > N_POPULATION:\n                break",
    "docstring": "Verify that the target contains no genes besides the ones inside genes variable.\n\n>>> from string import ascii_lowercase\n>>> basic(\"doctest\", ascii_lowercase, debug=False)[2]\n'doctest'\n>>> genes = list(ascii_lowercase)\n>>> genes.remove(\"e\")\n>>> basic(\"test\", genes)\nTraceback (most recent call last):\n    ...\nValueError: ['e'] is not in genes list, evolution cannot converge\n>>> genes.remove(\"s\")\n>>> basic(\"test\", genes)\nTraceback (most recent call last):\n    ...\nValueError: ['e', 's'] is not in genes list, evolution cannot converge\n>>> genes.remove(\"t\")\n>>> basic(\"test\", genes)\nTraceback (most recent call last):\n    ...\nValueError: ['e', 's', 't'] is not in genes list, evolution cannot converge"
  },
  {
    "function": "haversine_distance",
    "code": "def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    Calculate great circle distance between two points in a sphere,\n    given longitudes and latitudes https://en.wikipedia.org/wiki/Haversine_formula\n\n    We know that the globe is \"sort of\" spherical, so a path between two points\n    isn't exactly a straight line. We need to account for the Earth's curvature\n    when calculating distance from point A to B. This effect is negligible for\n    small distances but adds up as distance increases. The Haversine method treats\n    the earth as a sphere which allows us to \"project\" the two points A and B\n    onto the surface of that sphere and approximate the spherical distance between\n    them. Since the Earth is not a perfect sphere, other methods which model the\n    Earth's ellipsoidal nature are more accurate but a quick and modifiable\n    computation like Haversine can be handy for shorter range distances.\n\n    Args:\n        * `lat1`, `lon1`: latitude and longitude of coordinate 1\n        * `lat2`, `lon2`: latitude and longitude of coordinate 2\n    Returns:\n        geographical distance between two points in metres\n\n    >>> from collections import namedtuple\n    >>> point_2d = namedtuple(\"point_2d\", \"lat lon\")\n    >>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)\n    >>> YOSEMITE = point_2d(37.864742, -119.537521)\n    >>> f\"{haversine_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters\"\n    '254,352 meters'\n    \"\"\"\n    # CONSTANTS per WGS84 https://en.wikipedia.org/wiki/World_Geodetic_System\n    # Distance in metres(m)\n    # Equation parameters\n    # Equation https://en.wikipedia.org/wiki/Haversine_formula#Formulation\n    flattening = (AXIS_A - AXIS_B) / AXIS_A\n    phi_1 = atan((1 - flattening) * tan(radians(lat1)))\n    phi_2 = atan((1 - flattening) * tan(radians(lat2)))\n    lambda_1 = radians(lon1)\n    lambda_2 = radians(lon2)\n    # Equation\n    sin_sq_phi = sin((phi_2 - phi_1) / 2)\n    sin_sq_lambda = sin((lambda_2 - lambda_1) / 2)\n    # Square both values\n    sin_sq_phi *= sin_sq_phi\n    sin_sq_lambda *= sin_sq_lambda\n    h_value = sqrt(sin_sq_phi + (cos(phi_1) * cos(phi_2) * sin_sq_lambda))\n    return 2 * RADIUS * asin(h_value)",
    "docstring": "Calculate great circle distance between two points in a sphere,\ngiven longitudes and latitudes https://en.wikipedia.org/wiki/Haversine_formula\n\nWe know that the globe is \"sort of\" spherical, so a path between two points\nisn't exactly a straight line. We need to account for the Earth's curvature\nwhen calculating distance from point A to B. This effect is negligible for\nsmall distances but adds up as distance increases. The Haversine method treats\nthe earth as a sphere which allows us to \"project\" the two points A and B\nonto the surface of that sphere and approximate the spherical distance between\nthem. Since the Earth is not a perfect sphere, other methods which model the\nEarth's ellipsoidal nature are more accurate but a quick and modifiable\ncomputation like Haversine can be handy for shorter range distances.\n\nArgs:\n    * `lat1`, `lon1`: latitude and longitude of coordinate 1\n    * `lat2`, `lon2`: latitude and longitude of coordinate 2\nReturns:\n    geographical distance between two points in metres\n\n>>> from collections import namedtuple\n>>> point_2d = namedtuple(\"point_2d\", \"lat lon\")\n>>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)\n>>> YOSEMITE = point_2d(37.864742, -119.537521)\n>>> f\"{haversine_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters\"\n'254,352 meters'"
  },
  {
    "function": "lamberts_ellipsoidal_distance",
    "code": "def lamberts_ellipsoidal_distance(\n    lat1: float, lon1: float, lat2: float, lon2: float\n) -> float:\n    \"\"\"\n    Calculate the shortest distance along the surface of an ellipsoid between\n    two points on the surface of earth given longitudes and latitudes\n    https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines\n\n    NOTE: This algorithm uses geodesy/haversine_distance.py to compute central angle,\n        sigma\n\n    Representing the earth as an ellipsoid allows us to approximate distances between\n    points on the surface much better than a sphere. Ellipsoidal formulas treat the\n    Earth as an oblate ellipsoid which means accounting for the flattening that happens\n    at the North and South poles. Lambert's formulae provide accuracy on the order of\n    10 meteres over thousands of kilometeres. Other methods can provide\n    millimeter-level accuracy but this is a simpler method to calculate long range\n    distances without increasing computational intensity.\n\n    Args:\n        lat1, lon1: latitude and longitude of coordinate 1\n        lat2, lon2: latitude and longitude of coordinate 2\n    Returns:\n        geographical distance between two points in metres\n\n    >>> from collections import namedtuple\n    >>> point_2d = namedtuple(\"point_2d\", \"lat lon\")\n    >>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)\n    >>> YOSEMITE = point_2d(37.864742, -119.537521)\n    >>> NEW_YORK = point_2d(40.713019, -74.012647)\n    >>> VENICE = point_2d(45.443012, 12.313071)\n    >>> f\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters\"\n    '254,351 meters'\n    >>> f\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *NEW_YORK):0,.0f} meters\"\n    '4,138,992 meters'\n    >>> f\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *VENICE):0,.0f} meters\"\n    '9,737,326 meters'\n    \"\"\"\n\n    # CONSTANTS per WGS84 https://en.wikipedia.org/wiki/World_Geodetic_System\n    # Distance in metres(m)\n    # Equation Parameters\n    # https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines\n    flattening = (AXIS_A - AXIS_B) / AXIS_A\n    # Parametric latitudes\n    # https://en.wikipedia.org/wiki/Latitude#Parametric_(or_reduced)_latitude\n    b_lat1 = atan((1 - flattening) * tan(radians(lat1)))\n    b_lat2 = atan((1 - flattening) * tan(radians(lat2)))\n\n    # Compute central angle between two points\n    # using haversine theta. sigma =  haversine_distance / equatorial radius\n    sigma = haversine_distance(lat1, lon1, lat2, lon2) / EQUATORIAL_RADIUS\n\n    # Intermediate P and Q values\n    p_value = (b_lat1 + b_lat2) / 2\n    q_value = (b_lat2 - b_lat1) / 2\n\n    # Intermediate X value\n    # X = (sigma - sin(sigma)) * sin^2Pcos^2Q / cos^2(sigma/2)\n    x_numerator = (sin(p_value) ** 2) * (cos(q_value) ** 2)\n    x_demonimator = cos(sigma / 2) ** 2\n    x_value = (sigma - sin(sigma)) * (x_numerator / x_demonimator)\n\n    # Intermediate Y value\n    # Y = (sigma + sin(sigma)) * cos^2Psin^2Q / sin^2(sigma/2)\n    y_numerator = (cos(p_value) ** 2) * (sin(q_value) ** 2)\n    y_denominator = sin(sigma / 2) ** 2\n    y_value = (sigma + sin(sigma)) * (y_numerator / y_denominator)\n\n    return EQUATORIAL_RADIUS * (sigma - ((flattening / 2) * (x_value + y_value)))",
    "docstring": "Calculate the shortest distance along the surface of an ellipsoid between\ntwo points on the surface of earth given longitudes and latitudes\nhttps://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines\n\nNOTE: This algorithm uses geodesy/haversine_distance.py to compute central angle,\n    sigma\n\nRepresenting the earth as an ellipsoid allows us to approximate distances between\npoints on the surface much better than a sphere. Ellipsoidal formulas treat the\nEarth as an oblate ellipsoid which means accounting for the flattening that happens\nat the North and South poles. Lambert's formulae provide accuracy on the order of\n10 meteres over thousands of kilometeres. Other methods can provide\nmillimeter-level accuracy but this is a simpler method to calculate long range\ndistances without increasing computational intensity.\n\nArgs:\n    lat1, lon1: latitude and longitude of coordinate 1\n    lat2, lon2: latitude and longitude of coordinate 2\nReturns:\n    geographical distance between two points in metres\n\n>>> from collections import namedtuple\n>>> point_2d = namedtuple(\"point_2d\", \"lat lon\")\n>>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)\n>>> YOSEMITE = point_2d(37.864742, -119.537521)\n>>> NEW_YORK = point_2d(40.713019, -74.012647)\n>>> VENICE = point_2d(45.443012, 12.313071)\n>>> f\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters\"\n'254,351 meters'\n>>> f\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *NEW_YORK):0,.0f} meters\"\n'4,138,992 meters'\n>>> f\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *VENICE):0,.0f} meters\"\n'9,737,326 meters'"
  },
  {
    "function": "butterfly_pattern",
    "code": "def butterfly_pattern(n: int) -> str:\n    \"\"\"\n    Creates a butterfly pattern of size n and returns it as a string.\n\n    >>> print(butterfly_pattern(3))\n    *   *\n    ** **\n    *****\n    ** **\n    *   *\n    >>> print(butterfly_pattern(5))\n    *       *\n    **     **\n    ***   ***\n    **** ****\n    *********\n    **** ****\n    ***   ***\n    **     **\n    *       *\n    \"\"\"\n    result = []\n\n    # Upper part\n    for i in range(1, n):\n        left_stars = \"*\" * i\n        spaces = \" \" * (2 * (n - i) - 1)\n        right_stars = \"*\" * i\n        result.append(left_stars + spaces + right_stars)\n\n    # Middle part\n    result.append(\"*\" * (2 * n - 1))\n\n    # Lower part\n    for i in range(n - 1, 0, -1):\n        left_stars = \"*\" * i\n        spaces = \" \" * (2 * (n - i) - 1)\n        right_stars = \"*\" * i\n        result.append(left_stars + spaces + right_stars)\n\n    return \"\\n\".join(result)",
    "docstring": "Creates a butterfly pattern of size n and returns it as a string.\n\n>>> print(butterfly_pattern(3))\n*   *\n** **\n*****\n** **\n*   *\n>>> print(butterfly_pattern(5))\n*       *\n**     **\n***   ***\n**** ****\n*********\n**** ****\n***   ***\n**     **\n*       *"
  },
  {
    "function": "digital_differential_analyzer_line",
    "code": "def digital_differential_analyzer_line(\n    p1: tuple[int, int], p2: tuple[int, int]\n) -> list[tuple[int, int]]:\n    \"\"\"\n    Draws a line between two points using the DDA algorithm.\n\n    Args:\n    - p1: Coordinates of the starting point.\n    - p2: Coordinates of the ending point.\n    Returns:\n    - List of coordinate points that form the line.\n\n    >>> digital_differential_analyzer_line((1, 1), (4, 4))\n    [(2, 2), (3, 3), (4, 4)]\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    dx = x2 - x1\n    dy = y2 - y1\n    steps = max(abs(dx), abs(dy))\n    x_increment = dx / float(steps)\n    y_increment = dy / float(steps)\n    coordinates = []\n    x: float = x1\n    y: float = y1\n    for _ in range(steps):\n        x += x_increment\n        y += y_increment\n        coordinates.append((round(x), round(y)))\n    return coordinates",
    "docstring": "Draws a line between two points using the DDA algorithm.\n\nArgs:\n- p1: Coordinates of the starting point.\n- p2: Coordinates of the ending point.\nReturns:\n- List of coordinate points that form the line.\n\n>>> digital_differential_analyzer_line((1, 1), (4, 4))\n[(2, 2), (3, 3), (4, 4)]"
  },
  {
    "function": "convert_to_2d",
    "code": "def convert_to_2d(\n    x: float, y: float, z: float, scale: float, distance: float\n) -> tuple[float, float]:\n    \"\"\"\n    Converts 3d point to a 2d drawable point\n\n    >>> convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0)\n    (7.6923076923076925, 15.384615384615385)\n\n    >>> convert_to_2d(1, 2, 3, 10, 10)\n    (7.6923076923076925, 15.384615384615385)\n\n    >>> convert_to_2d(\"1\", 2, 3, 10, 10)  # '1' is str\n    Traceback (most recent call last):\n        ...\n    TypeError: Input values must either be float or int: ['1', 2, 3, 10, 10]\n    \"\"\"\n    if not all(isinstance(val, (float, int)) for val in locals().values()):\n        msg = f\"Input values must either be float or int: {list(locals().values())}\"\n        raise TypeError(msg)\n    projected_x = ((x * distance) / (z + distance)) * scale\n    projected_y = ((y * distance) / (z + distance)) * scale\n    return projected_x, projected_y",
    "docstring": "Converts 3d point to a 2d drawable point\n\n>>> convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0)\n(7.6923076923076925, 15.384615384615385)\n\n>>> convert_to_2d(1, 2, 3, 10, 10)\n(7.6923076923076925, 15.384615384615385)\n\n>>> convert_to_2d(\"1\", 2, 3, 10, 10)  # '1' is str\nTraceback (most recent call last):\n    ...\nTypeError: Input values must either be float or int: ['1', 2, 3, 10, 10]"
  },
  {
    "function": "rotate",
    "code": "def rotate(\n    x: float, y: float, z: float, axis: str, angle: float\n) -> tuple[float, float, float]:\n    \"\"\"\n    rotate a point around a certain axis with a certain angle\n    angle can be any integer between 1, 360 and axis can be any one of\n    'x', 'y', 'z'\n\n    >>> rotate(1.0, 2.0, 3.0, 'y', 90.0)\n    (3.130524675073759, 2.0, 0.4470070007889556)\n\n    >>> rotate(1, 2, 3, \"z\", 180)\n    (0.999736015495891, -2.0001319704760485, 3)\n\n    >>> rotate('1', 2, 3, \"z\", 90.0)  # '1' is str\n    Traceback (most recent call last):\n        ...\n    TypeError: Input values except axis must either be float or int: ['1', 2, 3, 90.0]\n\n    >>> rotate(1, 2, 3, \"n\", 90)  # 'n' is not a valid axis\n    Traceback (most recent call last):\n        ...\n    ValueError: not a valid axis, choose one of 'x', 'y', 'z'\n\n    >>> rotate(1, 2, 3, \"x\", -90)\n    (1, -2.5049096187183877, -2.5933429780983657)\n\n    >>> rotate(1, 2, 3, \"x\", 450)  # 450 wrap around to 90\n    (1, 3.5776792428178217, -0.44744970165427644)\n    \"\"\"\n    if not isinstance(axis, str):\n        raise TypeError(\"Axis must be a str\")\n    input_variables = locals()\n    del input_variables[\"axis\"]\n    if not all(isinstance(val, (float, int)) for val in input_variables.values()):\n        msg = (\n            \"Input values except axis must either be float or int: \"\n            f\"{list(input_variables.values())}\"\n        )\n        raise TypeError(msg)\n    angle = (angle % 360) / 450 * 180 / math.pi\n    if axis == \"z\":\n        new_x = x * math.cos(angle) - y * math.sin(angle)\n        new_y = y * math.cos(angle) + x * math.sin(angle)\n        new_z = z\n    elif axis == \"x\":\n        new_y = y * math.cos(angle) - z * math.sin(angle)\n        new_z = z * math.cos(angle) + y * math.sin(angle)\n        new_x = x\n    elif axis == \"y\":\n        new_x = x * math.cos(angle) - z * math.sin(angle)\n        new_z = z * math.cos(angle) + x * math.sin(angle)\n        new_y = y\n    else:\n        raise ValueError(\"not a valid axis, choose one of 'x', 'y', 'z'\")\n\n    return new_x, new_y, new_z",
    "docstring": "rotate a point around a certain axis with a certain angle\nangle can be any integer between 1, 360 and axis can be any one of\n'x', 'y', 'z'\n\n>>> rotate(1.0, 2.0, 3.0, 'y', 90.0)\n(3.130524675073759, 2.0, 0.4470070007889556)\n\n>>> rotate(1, 2, 3, \"z\", 180)\n(0.999736015495891, -2.0001319704760485, 3)\n\n>>> rotate('1', 2, 3, \"z\", 90.0)  # '1' is str\nTraceback (most recent call last):\n    ...\nTypeError: Input values except axis must either be float or int: ['1', 2, 3, 90.0]\n\n>>> rotate(1, 2, 3, \"n\", 90)  # 'n' is not a valid axis\nTraceback (most recent call last):\n    ...\nValueError: not a valid axis, choose one of 'x', 'y', 'z'\n\n>>> rotate(1, 2, 3, \"x\", -90)\n(1, -2.5049096187183877, -2.5933429780983657)\n\n>>> rotate(1, 2, 3, \"x\", 450)  # 450 wrap around to 90\n(1, 3.5776792428178217, -0.44744970165427644)"
  },
  {
    "function": "main",
    "code": "def main(\n    cities: dict[int, list[int]],\n    ants_num: int,\n    iterations_num: int,\n    pheromone_evaporation: float,\n    alpha: float,\n    beta: float,\n    q: float,  # Pheromone system parameters Q, which is a constant\n) -> tuple[list[int], float]:\n    \"\"\"\n    Ant colony algorithm main function\n    >>> main(cities=cities, ants_num=10, iterations_num=20,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    ([0, 1, 2, 3, 4, 5, 6, 7, 0], 37.909778143828696)\n    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    ([0, 1, 0], 5.656854249492381)\n    >>> main(cities={0: [0, 0], 1: [2, 2], 4: [4, 4]}, ants_num=5, iterations_num=5,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    Traceback (most recent call last):\n      ...\n    IndexError: list index out of range\n    >>> main(cities={}, ants_num=5, iterations_num=5,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    Traceback (most recent call last):\n      ...\n    StopIteration\n    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=0, iterations_num=5,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    ([], inf)\n    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=0,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    ([], inf)\n    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,\n    ...      pheromone_evaporation=1, alpha=1.0, beta=5.0, q=10)\n    ([0, 1, 0], 5.656854249492381)\n    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,\n    ...      pheromone_evaporation=0, alpha=1.0, beta=5.0, q=10)\n    ([0, 1, 0], 5.656854249492381)\n    \"\"\"\n    # Initialize the pheromone matrix\n    cities_num = len(cities)\n    pheromone = [[1.0] * cities_num] * cities_num\n\n    best_path: list[int] = []\n    best_distance = float(\"inf\")\n    for _ in range(iterations_num):\n        ants_route = []\n        for _ in range(ants_num):\n            unvisited_cities = copy.deepcopy(cities)\n            current_city = {next(iter(cities.keys())): next(iter(cities.values()))}\n            del unvisited_cities[next(iter(current_city.keys()))]\n            ant_route = [next(iter(current_city.keys()))]\n            while unvisited_cities:\n                current_city, unvisited_cities = city_select(\n                    pheromone, current_city, unvisited_cities, alpha, beta\n                )\n                ant_route.append(next(iter(current_city.keys())))\n            ant_route.append(0)\n            ants_route.append(ant_route)\n\n        pheromone, best_path, best_distance = pheromone_update(\n            pheromone,\n            cities,\n            pheromone_evaporation,\n            ants_route,\n            q,\n            best_path,\n            best_distance,\n        )\n    return best_path, best_distance",
    "docstring": "Ant colony algorithm main function\n>>> main(cities=cities, ants_num=10, iterations_num=20,\n...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n([0, 1, 2, 3, 4, 5, 6, 7, 0], 37.909778143828696)\n>>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,\n...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n([0, 1, 0], 5.656854249492381)\n>>> main(cities={0: [0, 0], 1: [2, 2], 4: [4, 4]}, ants_num=5, iterations_num=5,\n...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\nTraceback (most recent call last):\n  ...\nIndexError: list index out of range\n>>> main(cities={}, ants_num=5, iterations_num=5,\n...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\nTraceback (most recent call last):\n  ...\nStopIteration\n>>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=0, iterations_num=5,\n...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n([], inf)\n>>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=0,\n...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n([], inf)\n>>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,\n...      pheromone_evaporation=1, alpha=1.0, beta=5.0, q=10)\n([0, 1, 0], 5.656854249492381)\n>>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,\n...      pheromone_evaporation=0, alpha=1.0, beta=5.0, q=10)\n([0, 1, 0], 5.656854249492381)"
  },
  {
    "function": "distance",
    "code": "def distance(city1: list[int], city2: list[int]) -> float:\n    \"\"\"\n    Calculate the distance between two coordinate points\n    >>> distance([0, 0], [3, 4] )\n    5.0\n    >>> distance([0, 0], [-3, 4] )\n    5.0\n    >>> distance([0, 0], [-3, -4] )\n    5.0\n    \"\"\"\n    return (((city1[0] - city2[0]) ** 2) + ((city1[1] - city2[1]) ** 2)) ** 0.5",
    "docstring": "Calculate the distance between two coordinate points\n>>> distance([0, 0], [3, 4] )\n5.0\n>>> distance([0, 0], [-3, 4] )\n5.0\n>>> distance([0, 0], [-3, -4] )\n5.0"
  },
  {
    "function": "pheromone_update",
    "code": "def pheromone_update(\n    pheromone: list[list[float]],\n    cities: dict[int, list[int]],\n    pheromone_evaporation: float,\n    ants_route: list[list[int]],\n    q: float,  # Pheromone system parameters Q, which is a constant\n    best_path: list[int],\n    best_distance: float,\n) -> tuple[list[list[float]], list[int], float]:\n    \"\"\"\n    Update pheromones on the route and update the best route\n    >>>\n    >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],\n    ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    ([[0.7, 4.235533905932737], [4.235533905932737, 0.7]], [0, 1, 0], 5.656854249492381)\n    >>> pheromone_update(pheromone=[],\n    ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    Traceback (most recent call last):\n      ...\n    IndexError: list index out of range\n    >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],\n    ...                  cities={}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    Traceback (most recent call last):\n      ...\n    KeyError: 0\n    \"\"\"\n    for a in range(len(cities)):  # Update the volatilization of pheromone on all routes\n        for b in range(len(cities)):\n            pheromone[a][b] *= pheromone_evaporation\n    for ant_route in ants_route:\n        total_distance = 0.0\n        for i in range(len(ant_route) - 1):  # Calculate total distance\n            total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])\n        delta_pheromone = q / total_distance\n        for i in range(len(ant_route) - 1):  # Update pheromones\n            pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone\n            pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][\n                ant_route[i + 1]\n            ]\n\n        if total_distance < best_distance:\n            best_path = ant_route\n            best_distance = total_distance\n\n    return pheromone, best_path, best_distance",
    "docstring": "Update pheromones on the route and update the best route\n>>>\n>>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],\n...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,\n...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n...                  best_distance=float(\"inf\"))\n([[0.7, 4.235533905932737], [4.235533905932737, 0.7]], [0, 1, 0], 5.656854249492381)\n>>> pheromone_update(pheromone=[],\n...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,\n...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n...                  best_distance=float(\"inf\"))\nTraceback (most recent call last):\n  ...\nIndexError: list index out of range\n>>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],\n...                  cities={}, pheromone_evaporation=0.7,\n...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n...                  best_distance=float(\"inf\"))\nTraceback (most recent call last):\n  ...\nKeyError: 0"
  },
  {
    "function": "city_select",
    "code": "def city_select(\n    pheromone: list[list[float]],\n    current_city: dict[int, list[int]],\n    unvisited_cities: dict[int, list[int]],\n    alpha: float,\n    beta: float,\n) -> tuple[dict[int, list[int]], dict[int, list[int]]]:\n    \"\"\"\n    Choose the next city for ants\n    >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]},\n    ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)\n    ({1: [2, 2]}, {})\n    >>> city_select(pheromone=[], current_city={0: [0,0]},\n    ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)\n    Traceback (most recent call last):\n      ...\n    IndexError: list index out of range\n    >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={},\n    ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)\n    Traceback (most recent call last):\n      ...\n    StopIteration\n    >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]},\n    ...             unvisited_cities={}, alpha=1.0, beta=5.0)\n    Traceback (most recent call last):\n      ...\n    IndexError: list index out of range\n    \"\"\"\n    probabilities = []\n    for city, value in unvisited_cities.items():\n        city_distance = distance(value, next(iter(current_city.values())))\n        probability = (pheromone[city][next(iter(current_city.keys()))] ** alpha) * (\n            (1 / city_distance) ** beta\n        )\n        probabilities.append(probability)\n\n    chosen_city_i = random.choices(\n        list(unvisited_cities.keys()), weights=probabilities\n    )[0]\n    chosen_city = {chosen_city_i: unvisited_cities[chosen_city_i]}\n    del unvisited_cities[next(iter(chosen_city.keys()))]\n    return chosen_city, unvisited_cities",
    "docstring": "Choose the next city for ants\n>>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]},\n...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)\n({1: [2, 2]}, {})\n>>> city_select(pheromone=[], current_city={0: [0,0]},\n...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)\nTraceback (most recent call last):\n  ...\nIndexError: list index out of range\n>>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={},\n...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)\nTraceback (most recent call last):\n  ...\nStopIteration\n>>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]},\n...             unvisited_cities={}, alpha=1.0, beta=5.0)\nTraceback (most recent call last):\n  ...\nIndexError: list index out of range"
  },
  {
    "function": "search",
    "code": "def search(\n    grid: list[list[int]],\n    init: list[int],\n    goal: list[int],\n    cost: int,\n    heuristic: list[list[int]],\n) -> tuple[list[list[int]], list[list[int]]]:\n    \"\"\"\n    Search for a path on a grid avoiding obstacles.\n    >>> grid = [[0, 1, 0, 0, 0, 0],\n    ...         [0, 1, 0, 0, 0, 0],\n    ...         [0, 1, 0, 0, 0, 0],\n    ...         [0, 1, 0, 0, 1, 0],\n    ...         [0, 0, 0, 0, 1, 0]]\n    >>> init = [0, 0]\n    >>> goal = [len(grid) - 1, len(grid[0]) - 1]\n    >>> cost = 1\n    >>> heuristic = [[0] * len(grid[0]) for _ in range(len(grid))]\n    >>> heuristic = [[0 for row in range(len(grid[0]))] for col in range(len(grid))]\n    >>> for i in range(len(grid)):\n    ...     for j in range(len(grid[0])):\n    ...         heuristic[i][j] = abs(i - goal[0]) + abs(j - goal[1])\n    ...         if grid[i][j] == 1:\n    ...             heuristic[i][j] = 99\n    >>> path, action = search(grid, init, goal, cost, heuristic)\n    >>> path  # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [4, 1], [4, 2], [4, 3], [3, 3],\n    [2, 3], [2, 4], [2, 5], [3, 5], [4, 5]]\n    >>> action  # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0], [2, 0, 0, 0, 3, 3],\n    [2, 0, 0, 0, 0, 2], [2, 3, 3, 3, 0, 2]]\n    \"\"\"\n    closed = [\n        [0 for col in range(len(grid[0]))] for row in range(len(grid))\n    ]  # the reference grid\n    closed[init[0]][init[1]] = 1\n    action = [\n        [0 for col in range(len(grid[0]))] for row in range(len(grid))\n    ]  # the action grid\n\n    x = init[0]\n    y = init[1]\n    g = 0\n    f = g + heuristic[x][y]  # cost from starting cell to destination cell\n    cell = [[f, g, x, y]]\n\n    found = False  # flag that is set when search is complete\n    resign = False  # flag set if we can't find expand\n\n    while not found and not resign:\n        if len(cell) == 0:\n            raise ValueError(\"Algorithm is unable to find solution\")\n        else:  # to choose the least costliest action so as to move closer to the goal\n            cell.sort()\n            cell.reverse()\n            next_cell = cell.pop()\n            x = next_cell[2]\n            y = next_cell[3]\n            g = next_cell[1]\n\n            if x == goal[0] and y == goal[1]:\n                found = True\n            else:\n                for i in range(len(DIRECTIONS)):  # to try out different valid actions\n                    x2 = x + DIRECTIONS[i][0]\n                    y2 = y + DIRECTIONS[i][1]\n                    if (\n                        x2 >= 0\n                        and x2 < len(grid)\n                        and y2 >= 0\n                        and y2 < len(grid[0])\n                        and closed[x2][y2] == 0\n                        and grid[x2][y2] == 0\n                    ):\n                        g2 = g + cost\n                        f2 = g2 + heuristic[x2][y2]\n                        cell.append([f2, g2, x2, y2])\n                        closed[x2][y2] = 1\n                        action[x2][y2] = i\n    invpath = []\n    x = goal[0]\n    y = goal[1]\n    invpath.append([x, y])  # we get the reverse path from here\n    while x != init[0] or y != init[1]:\n        x2 = x - DIRECTIONS[action[x][y]][0]\n        y2 = y - DIRECTIONS[action[x][y]][1]\n        x = x2\n        y = y2\n        invpath.append([x, y])\n\n    path = []\n    for i in range(len(invpath)):\n        path.append(invpath[len(invpath) - 1 - i])\n    return path, action",
    "docstring": "Search for a path on a grid avoiding obstacles.\n>>> grid = [[0, 1, 0, 0, 0, 0],\n...         [0, 1, 0, 0, 0, 0],\n...         [0, 1, 0, 0, 0, 0],\n...         [0, 1, 0, 0, 1, 0],\n...         [0, 0, 0, 0, 1, 0]]\n>>> init = [0, 0]\n>>> goal = [len(grid) - 1, len(grid[0]) - 1]\n>>> cost = 1\n>>> heuristic = [[0] * len(grid[0]) for _ in range(len(grid))]\n>>> heuristic = [[0 for row in range(len(grid[0]))] for col in range(len(grid))]\n>>> for i in range(len(grid)):\n...     for j in range(len(grid[0])):\n...         heuristic[i][j] = abs(i - goal[0]) + abs(j - goal[1])\n...         if grid[i][j] == 1:\n...             heuristic[i][j] = 99\n>>> path, action = search(grid, init, goal, cost, heuristic)\n>>> path  # doctest: +NORMALIZE_WHITESPACE\n[[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [4, 1], [4, 2], [4, 3], [3, 3],\n[2, 3], [2, 4], [2, 5], [3, 5], [4, 5]]\n>>> action  # doctest: +NORMALIZE_WHITESPACE\n[[0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0], [2, 0, 0, 0, 3, 3],\n[2, 0, 0, 0, 0, 2], [2, 3, 3, 3, 0, 2]]"
  },
  {
    "function": "dfs",
    "code": "def dfs(g, s):\n    \"\"\"\n    >>> dfs({1: [2, 3], 2: [4, 5], 3: [], 4: [], 5: []}, 1)\n    1\n    2\n    4\n    5\n    3\n    \"\"\"\n    vis, _s = {s}, [s]\n    print(s)\n    while _s:\n        flag = 0\n        for i in g[_s[-1]]:\n            if i not in vis:\n                _s.append(i)\n                vis.add(i)\n                flag = 1\n                print(i)\n                break\n        if not flag:\n            _s.pop()",
    "docstring": ">>> dfs({1: [2, 3], 2: [4, 5], 3: [], 4: [], 5: []}, 1)\n1\n2\n4\n5\n3"
  },
  {
    "function": "bfs",
    "code": "def bfs(g, s):\n    \"\"\"\n    >>> bfs({1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [], 5: [8], 6: [], 7: [], 8: []}, 1)\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \"\"\"\n    vis, q = {s}, deque([s])\n    print(s)\n    while q:\n        u = q.popleft()\n        for v in g[u]:\n            if v not in vis:\n                vis.add(v)\n                q.append(v)\n                print(v)",
    "docstring": ">>> bfs({1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [], 5: [8], 6: [], 7: [], 8: []}, 1)\n1\n2\n3\n4\n5\n6\n7\n8"
  },
  {
    "function": "dijk",
    "code": "def dijk(g, s):\n    \"\"\"\n    dijk({1: [(2, 7), (3, 9), (6, 14)],\n        2: [(1, 7), (3, 10), (4, 15)],\n        3: [(1, 9), (2, 10), (4, 11), (6, 2)],\n        4: [(2, 15), (3, 11), (5, 6)],\n        5: [(4, 6), (6, 9)],\n        6: [(1, 14), (3, 2), (5, 9)]}, 1)\n    7\n    9\n    11\n    20\n    20\n    \"\"\"\n    dist, known, path = {s: 0}, set(), {s: 0}\n    while True:\n        if len(known) == len(g) - 1:\n            break\n        mini = 100000\n        for key, value in dist:\n            if key not in known and value < mini:\n                mini = value\n                u = key\n        known.add(u)\n        for v in g[u]:\n            if v[0] not in known and dist[u] + v[1] < dist.get(v[0], 100000):\n                dist[v[0]] = dist[u] + v[1]\n                path[v[0]] = u\n    for key, value in dist.items():\n        if key != s:\n            print(value)",
    "docstring": "dijk({1: [(2, 7), (3, 9), (6, 14)],\n    2: [(1, 7), (3, 10), (4, 15)],\n    3: [(1, 9), (2, 10), (4, 11), (6, 2)],\n    4: [(2, 15), (3, 11), (5, 6)],\n    5: [(4, 6), (6, 9)],\n    6: [(1, 14), (3, 2), (5, 9)]}, 1)\n7\n9\n11\n20\n20"
  },
  {
    "function": "adjm",
    "code": "def adjm():\n    r\"\"\"\n    Reading an Adjacency matrix\n\n    Parameters:\n        None\n\n    Returns:\n        tuple: A tuple containing a list of edges and number of edges\n\n    Example:\n    >>> # Simulate user input for 3 nodes\n    >>> input_data = \"4\\n0 1 0 1\\n1 0 1 0\\n0 1 0 1\\n1 0 1 0\\n\"\n    >>> import sys,io\n    >>> original_input = sys.stdin\n    >>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing\n    >>> adjm()\n    ([(0, 1, 0, 1), (1, 0, 1, 0), (0, 1, 0, 1), (1, 0, 1, 0)], 4)\n    >>> sys.stdin = original_input  # Restore original stdin\n    \"\"\"\n    n = int(input().strip())\n    a = []\n    for _ in range(n):\n        a.append(tuple(map(int, input().strip().split())))\n    return a, n",
    "docstring": "Reading an Adjacency matrix\n\nParameters:\n    None\n\nReturns:\n    tuple: A tuple containing a list of edges and number of edges\n\nExample:\n>>> # Simulate user input for 3 nodes\n>>> input_data = \"4\\n0 1 0 1\\n1 0 1 0\\n0 1 0 1\\n1 0 1 0\\n\"\n>>> import sys,io\n>>> original_input = sys.stdin\n>>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing\n>>> adjm()\n([(0, 1, 0, 1), (1, 0, 1, 0), (0, 1, 0, 1), (1, 0, 1, 0)], 4)\n>>> sys.stdin = original_input  # Restore original stdin"
  },
  {
    "function": "edglist",
    "code": "def edglist():\n    r\"\"\"\n    Get the edges and number of edges from the user\n\n    Parameters:\n        None\n\n    Returns:\n        tuple: A tuple containing a list of edges and number of edges\n\n    Example:\n    >>> # Simulate user input for 3 edges and 4 vertices: (1, 2), (2, 3), (3, 4)\n    >>> input_data = \"4 3\\n1 2\\n2 3\\n3 4\\n\"\n    >>> import sys,io\n    >>> original_input = sys.stdin\n    >>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing\n    >>> edglist()\n    ([(1, 2), (2, 3), (3, 4)], 4)\n    >>> sys.stdin = original_input  # Restore original stdin\n    \"\"\"\n    n, m = tuple(map(int, input().split(\" \")))\n    edges = []\n    for _ in range(m):\n        edges.append(tuple(map(int, input().split(\" \"))))\n    return edges, n",
    "docstring": "Get the edges and number of edges from the user\n\nParameters:\n    None\n\nReturns:\n    tuple: A tuple containing a list of edges and number of edges\n\nExample:\n>>> # Simulate user input for 3 edges and 4 vertices: (1, 2), (2, 3), (3, 4)\n>>> input_data = \"4 3\\n1 2\\n2 3\\n3 4\\n\"\n>>> import sys,io\n>>> original_input = sys.stdin\n>>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing\n>>> edglist()\n([(1, 2), (2, 3), (3, 4)], 4)\n>>> sys.stdin = original_input  # Restore original stdin"
  },
  {
    "function": "krusk",
    "code": "def krusk(e_and_n):\n    \"\"\"\n    Sort edges on the basis of distance\n    \"\"\"\n    (e, n) = e_and_n\n    e.sort(reverse=True, key=lambda x: x[2])\n    s = [{i} for i in range(1, n + 1)]\n    while True:\n        if len(s) == 1:\n            break\n        print(s)\n        x = e.pop()\n        for i in range(len(s)):\n            if x[0] in s[i]:\n                break\n        for j in range(len(s)):\n            if x[1] in s[j]:\n                if i == j:\n                    break\n                s[j].update(s[i])\n                s.pop(i)\n                break",
    "docstring": "Sort edges on the basis of distance"
  },
  {
    "function": "find_isolated_nodes",
    "code": "def find_isolated_nodes(graph):\n    \"\"\"\n    Find the isolated node in the graph\n\n    Parameters:\n    graph (dict): A dictionary representing a graph.\n\n    Returns:\n    list: A list of isolated nodes.\n\n    Examples:\n    >>> graph1 = {1: [2, 3], 2: [1, 3], 3: [1, 2], 4: []}\n    >>> find_isolated_nodes(graph1)\n    [4]\n\n    >>> graph2 = {'A': ['B', 'C'], 'B': ['A'], 'C': ['A'], 'D': []}\n    >>> find_isolated_nodes(graph2)\n    ['D']\n\n    >>> graph3 = {'X': [], 'Y': [], 'Z': []}\n    >>> find_isolated_nodes(graph3)\n    ['X', 'Y', 'Z']\n\n    >>> graph4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}\n    >>> find_isolated_nodes(graph4)\n    []\n\n    >>> graph5 = {}\n    >>> find_isolated_nodes(graph5)\n    []\n    \"\"\"\n    isolated = []\n    for node in graph:\n        if not graph[node]:\n            isolated.append(node)\n    return isolated",
    "docstring": "Find the isolated node in the graph\n\nParameters:\ngraph (dict): A dictionary representing a graph.\n\nReturns:\nlist: A list of isolated nodes.\n\nExamples:\n>>> graph1 = {1: [2, 3], 2: [1, 3], 3: [1, 2], 4: []}\n>>> find_isolated_nodes(graph1)\n[4]\n\n>>> graph2 = {'A': ['B', 'C'], 'B': ['A'], 'C': ['A'], 'D': []}\n>>> find_isolated_nodes(graph2)\n['D']\n\n>>> graph3 = {'X': [], 'Y': [], 'Z': []}\n>>> find_isolated_nodes(graph3)\n['X', 'Y', 'Z']\n\n>>> graph4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}\n>>> find_isolated_nodes(graph4)\n[]\n\n>>> graph5 = {}\n>>> find_isolated_nodes(graph5)\n[]"
  },
  {
    "function": "bellman_ford",
    "code": "def bellman_ford(\n    graph: list[dict[str, int]], vertex_count: int, edge_count: int, src: int\n) -> list[float]:\n    \"\"\"\n    Returns shortest paths from a vertex src to all\n    other vertices.\n    >>> edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)]\n    >>> g = [{\"src\": s, \"dst\": d, \"weight\": w} for s, d, w in edges]\n    >>> bellman_ford(g, 4, 4, 0)\n    [0.0, -2.0, 8.0, 5.0]\n    >>> g = [{\"src\": s, \"dst\": d, \"weight\": w} for s, d, w in edges + [(1, 3, 5)]]\n    >>> bellman_ford(g, 4, 5, 0)\n    Traceback (most recent call last):\n     ...\n    Exception: Negative cycle found\n    \"\"\"\n    distance = [float(\"inf\")] * vertex_count\n    distance[src] = 0.0\n\n    for _ in range(vertex_count - 1):\n        for j in range(edge_count):\n            u, v, w = (graph[j][k] for k in [\"src\", \"dst\", \"weight\"])\n\n            if distance[u] != float(\"inf\") and distance[u] + w < distance[v]:\n                distance[v] = distance[u] + w\n\n    negative_cycle_exists = check_negative_cycle(graph, distance, edge_count)\n    if negative_cycle_exists:\n        raise Exception(\"Negative cycle found\")\n\n    return distance",
    "docstring": "Returns shortest paths from a vertex src to all\nother vertices.\n>>> edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)]\n>>> g = [{\"src\": s, \"dst\": d, \"weight\": w} for s, d, w in edges]\n>>> bellman_ford(g, 4, 4, 0)\n[0.0, -2.0, 8.0, 5.0]\n>>> g = [{\"src\": s, \"dst\": d, \"weight\": w} for s, d, w in edges + [(1, 3, 5)]]\n>>> bellman_ford(g, 4, 5, 0)\nTraceback (most recent call last):\n ...\nException: Negative cycle found"
  },
  {
    "function": "bidirectional_search",
    "code": "def bidirectional_search(\n    graph: dict[int, list[int]], start: int, goal: int\n) -> list[int] | None:\n    \"\"\"\n    Perform bidirectional search on a graph to find the shortest path.\n\n    Args:\n        graph: A dictionary where keys are nodes and values are lists of adjacent nodes\n        start: The starting node\n        goal: The target node\n\n    Returns:\n        A list representing the path from start to goal, or None if no path exists\n\n    Examples:\n        >>> graph = {\n        ...     0: [1, 2],\n        ...     1: [0, 3, 4],\n        ...     2: [0, 5, 6],\n        ...     3: [1, 7],\n        ...     4: [1, 8],\n        ...     5: [2, 9],\n        ...     6: [2, 10],\n        ...     7: [3, 11],\n        ...     8: [4, 11],\n        ...     9: [5, 11],\n        ...     10: [6, 11],\n        ...     11: [7, 8, 9, 10],\n        ... }\n        >>> bidirectional_search(graph=graph, start=0, goal=11)\n        [0, 1, 3, 7, 11]\n        >>> bidirectional_search(graph=graph, start=5, goal=5)\n        [5]\n        >>> disconnected_graph = {\n        ...     0: [1, 2],\n        ...     1: [0],\n        ...     2: [0],\n        ...     3: [4],\n        ...     4: [3],\n        ... }\n        >>> bidirectional_search(graph=disconnected_graph, start=0, goal=3) is None\n        True\n    \"\"\"\n    if start == goal:\n        return [start]\n\n    # Check if start and goal are in the graph\n    if start not in graph or goal not in graph:\n        return None\n\n    # Initialize forward and backward search dictionaries\n    # Each maps a node to its parent in the search\n    forward_parents: dict[int, int | None] = {start: None}\n    backward_parents: dict[int, int | None] = {goal: None}\n\n    # Initialize forward and backward search queues\n    forward_queue = deque([start])\n    backward_queue = deque([goal])\n\n    # Intersection node (where the two searches meet)\n    intersection = None\n\n    # Continue until both queues are empty or an intersection is found\n    while forward_queue and backward_queue and intersection is None:\n        # Expand forward search\n        intersection = expand_search(\n            graph=graph,\n            queue=forward_queue,\n            parents=forward_parents,\n            opposite_direction_parents=backward_parents,\n        )\n\n        # If no intersection found, expand backward search\n        if intersection is not None:\n            break\n\n        intersection = expand_search(\n            graph=graph,\n            queue=backward_queue,\n            parents=backward_parents,\n            opposite_direction_parents=forward_parents,\n        )\n\n    # If no intersection found, there's no path\n    if intersection is None:\n        return None\n\n    # Construct path from start to intersection\n    forward_path: list[int] = construct_path(\n        current=intersection, parents=forward_parents\n    )\n    forward_path.reverse()\n\n    # Construct path from intersection to goal\n    backward_path: list[int] = construct_path(\n        current=backward_parents[intersection], parents=backward_parents\n    )\n\n    # Return the complete path\n    return forward_path + backward_path",
    "docstring": "Perform bidirectional search on a graph to find the shortest path.\n\nArgs:\n    graph: A dictionary where keys are nodes and values are lists of adjacent nodes\n    start: The starting node\n    goal: The target node\n\nReturns:\n    A list representing the path from start to goal, or None if no path exists\n\nExamples:\n    >>> graph = {\n    ...     0: [1, 2],\n    ...     1: [0, 3, 4],\n    ...     2: [0, 5, 6],\n    ...     3: [1, 7],\n    ...     4: [1, 8],\n    ...     5: [2, 9],\n    ...     6: [2, 10],\n    ...     7: [3, 11],\n    ...     8: [4, 11],\n    ...     9: [5, 11],\n    ...     10: [6, 11],\n    ...     11: [7, 8, 9, 10],\n    ... }\n    >>> bidirectional_search(graph=graph, start=0, goal=11)\n    [0, 1, 3, 7, 11]\n    >>> bidirectional_search(graph=graph, start=5, goal=5)\n    [5]\n    >>> disconnected_graph = {\n    ...     0: [1, 2],\n    ...     1: [0],\n    ...     2: [0],\n    ...     3: [4],\n    ...     4: [3],\n    ... }\n    >>> bidirectional_search(graph=disconnected_graph, start=0, goal=3) is None\n    True"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Run example of bidirectional search algorithm.\n\n    Examples:\n        >>> main()  # doctest: +NORMALIZE_WHITESPACE\n        Path from 0 to 11: [0, 1, 3, 7, 11]\n        Path from 5 to 5: [5]\n        Path from 0 to 3: None\n    \"\"\"\n    # Example graph represented as an adjacency list\n    example_graph = {\n        0: [1, 2],\n        1: [0, 3, 4],\n        2: [0, 5, 6],\n        3: [1, 7],\n        4: [1, 8],\n        5: [2, 9],\n        6: [2, 10],\n        7: [3, 11],\n        8: [4, 11],\n        9: [5, 11],\n        10: [6, 11],\n        11: [7, 8, 9, 10],\n    }\n\n    # Test case 1: Path exists\n    start, goal = 0, 11\n    path = bidirectional_search(graph=example_graph, start=start, goal=goal)\n    print(f\"Path from {start} to {goal}: {path}\")\n\n    # Test case 2: Start and goal are the same\n    start, goal = 5, 5\n    path = bidirectional_search(graph=example_graph, start=start, goal=goal)\n    print(f\"Path from {start} to {goal}: {path}\")\n\n    # Test case 3: No path exists (disconnected graph)\n    disconnected_graph = {\n        0: [1, 2],\n        1: [0],\n        2: [0],\n        3: [4],\n        4: [3],\n    }\n    start, goal = 0, 3\n    path = bidirectional_search(graph=disconnected_graph, start=start, goal=goal)\n    print(f\"Path from {start} to {goal}: {path}\")",
    "docstring": "Run example of bidirectional search algorithm.\n\nExamples:\n    >>> main()  # doctest: +NORMALIZE_WHITESPACE\n    Path from 0 to 11: [0, 1, 3, 7, 11]\n    Path from 5 to 5: [5]\n    Path from 0 to 3: None"
  },
  {
    "function": "bidirectional_dij",
    "code": "def bidirectional_dij(\n    source: str, destination: str, graph_forward: dict, graph_backward: dict\n) -> int:\n    \"\"\"\n    Bi-directional Dijkstra's algorithm.\n\n    Returns:\n        shortest_path_distance (int): length of the shortest path.\n\n    Warnings:\n        If the destination is not reachable, function returns -1\n\n    >>> bidirectional_dij(\"E\", \"F\", graph_fwd, graph_bwd)\n    3\n    \"\"\"\n    shortest_path_distance = -1\n\n    visited_forward = set()\n    visited_backward = set()\n    cst_fwd = {source: 0}\n    cst_bwd = {destination: 0}\n    parent_forward = {source: None}\n    parent_backward = {destination: None}\n    queue_forward: PriorityQueue[Any] = PriorityQueue()\n    queue_backward: PriorityQueue[Any] = PriorityQueue()\n\n    shortest_distance = np.inf\n\n    queue_forward.put((0, source))\n    queue_backward.put((0, destination))\n\n    if source == destination:\n        return 0\n\n    while not queue_forward.empty() and not queue_backward.empty():\n        _, v_fwd = queue_forward.get()\n        visited_forward.add(v_fwd)\n\n        _, v_bwd = queue_backward.get()\n        visited_backward.add(v_bwd)\n\n        shortest_distance = pass_and_relaxation(\n            graph_forward,\n            v_fwd,\n            visited_forward,\n            visited_backward,\n            cst_fwd,\n            cst_bwd,\n            queue_forward,\n            parent_forward,\n            shortest_distance,\n        )\n\n        shortest_distance = pass_and_relaxation(\n            graph_backward,\n            v_bwd,\n            visited_backward,\n            visited_forward,\n            cst_bwd,\n            cst_fwd,\n            queue_backward,\n            parent_backward,\n            shortest_distance,\n        )\n\n        if cst_fwd[v_fwd] + cst_bwd[v_bwd] >= shortest_distance:\n            break\n\n    if shortest_distance != np.inf:\n        shortest_path_distance = shortest_distance\n    return shortest_path_distance",
    "docstring": "Bi-directional Dijkstra's algorithm.\n\nReturns:\n    shortest_path_distance (int): length of the shortest path.\n\nWarnings:\n    If the destination is not reachable, function returns -1\n\n>>> bidirectional_dij(\"E\", \"F\", graph_fwd, graph_bwd)\n3"
  },
  {
    "function": "test_vector",
    "code": "def test_vector() -> None:\n    \"\"\"\n    >>> g = Graph(8)\n    >>> for u_v_w in ((0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4),\n    ...    (3, 4, 8), (4, 5, 10), (4, 6, 6), (4, 7, 5), (5, 7, 15), (6, 7, 4)):\n    ...        g.add_edge(*u_v_w)\n    >>> g.boruvka()\n    Added edge [0 - 3]\n    Added weight: 5\n    <BLANKLINE>\n    Added edge [0 - 1]\n    Added weight: 10\n    <BLANKLINE>\n    Added edge [2 - 3]\n    Added weight: 4\n    <BLANKLINE>\n    Added edge [4 - 7]\n    Added weight: 5\n    <BLANKLINE>\n    Added edge [4 - 5]\n    Added weight: 10\n    <BLANKLINE>\n    Added edge [6 - 7]\n    Added weight: 4\n    <BLANKLINE>\n    Added edge [3 - 4]\n    Added weight: 8\n    <BLANKLINE>\n    The total weight of the minimal spanning tree is: 46\n    \"\"\"",
    "docstring": ">>> g = Graph(8)\n>>> for u_v_w in ((0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4),\n...    (3, 4, 8), (4, 5, 10), (4, 6, 6), (4, 7, 5), (5, 7, 15), (6, 7, 4)):\n...        g.add_edge(*u_v_w)\n>>> g.boruvka()\nAdded edge [0 - 3]\nAdded weight: 5\n<BLANKLINE>\nAdded edge [0 - 1]\nAdded weight: 10\n<BLANKLINE>\nAdded edge [2 - 3]\nAdded weight: 4\n<BLANKLINE>\nAdded edge [4 - 7]\nAdded weight: 5\n<BLANKLINE>\nAdded edge [4 - 5]\nAdded weight: 10\n<BLANKLINE>\nAdded edge [6 - 7]\nAdded weight: 4\n<BLANKLINE>\nAdded edge [3 - 4]\nAdded weight: 8\n<BLANKLINE>\nThe total weight of the minimal spanning tree is: 46"
  },
  {
    "function": "breadth_first_search",
    "code": "def breadth_first_search(graph: dict, start: str) -> list[str]:\n    \"\"\"\n    Implementation of breadth first search using queue.Queue.\n\n    >>> ''.join(breadth_first_search(G, 'A'))\n    'ABCDEF'\n    \"\"\"\n    explored = {start}\n    result = [start]\n    queue: Queue = Queue()\n    queue.put(start)\n    while not queue.empty():\n        v = queue.get()\n        for w in graph[v]:\n            if w not in explored:\n                explored.add(w)\n                result.append(w)\n                queue.put(w)\n    return result",
    "docstring": "Implementation of breadth first search using queue.Queue.\n\n>>> ''.join(breadth_first_search(G, 'A'))\n'ABCDEF'"
  },
  {
    "function": "breadth_first_search_with_deque",
    "code": "def breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:\n    \"\"\"\n    Implementation of breadth first search using collection.queue.\n\n    >>> ''.join(breadth_first_search_with_deque(G, 'A'))\n    'ABCDEF'\n    \"\"\"\n    visited = {start}\n    result = [start]\n    queue = deque([start])\n    while queue:\n        v = queue.popleft()\n        for child in graph[v]:\n            if child not in visited:\n                visited.add(child)\n                result.append(child)\n                queue.append(child)\n    return result",
    "docstring": "Implementation of breadth first search using collection.queue.\n\n>>> ''.join(breadth_first_search_with_deque(G, 'A'))\n'ABCDEF'"
  },
  {
    "function": "bfs_shortest_path",
    "code": "def bfs_shortest_path(graph: dict, start, goal) -> list[str]:\n    \"\"\"Find the shortest path between `start` and `goal` nodes.\n    Args:\n        graph (dict): node/list of neighboring nodes key/value pairs.\n        start: start node.\n        goal: target node.\n    Returns:\n        Shortest path between `start` and `goal` nodes as a string of nodes.\n        'Not found' string if no path found.\n    Example:\n        >>> bfs_shortest_path(demo_graph, \"G\", \"D\")\n        ['G', 'C', 'A', 'B', 'D']\n        >>> bfs_shortest_path(demo_graph, \"G\", \"G\")\n        ['G']\n        >>> bfs_shortest_path(demo_graph, \"G\", \"Unknown\")\n        []\n    \"\"\"\n    # keep track of explored nodes\n    explored = set()\n    # keep track of all the paths to be checked\n    queue = deque([[start]])\n\n    # return path if start is goal\n    if start == goal:\n        return [start]\n\n    # keeps looping until all possible paths have been checked\n    while queue:\n        # pop the first path from the queue\n        path = queue.popleft()\n        # get the last node from the path\n        node = path[-1]\n        if node not in explored:\n            neighbours = graph[node]\n            # go through all neighbour nodes, construct a new path and\n            # push it into the queue\n            for neighbour in neighbours:\n                new_path = list(path)\n                new_path.append(neighbour)\n                queue.append(new_path)\n                # return path if neighbour is goal\n                if neighbour == goal:\n                    return new_path\n\n            # mark node as explored\n            explored.add(node)\n\n    # in case there's no path between the 2 nodes\n    return []",
    "docstring": "Find the shortest path between `start` and `goal` nodes.\nArgs:\n    graph (dict): node/list of neighboring nodes key/value pairs.\n    start: start node.\n    goal: target node.\nReturns:\n    Shortest path between `start` and `goal` nodes as a string of nodes.\n    'Not found' string if no path found.\nExample:\n    >>> bfs_shortest_path(demo_graph, \"G\", \"D\")\n    ['G', 'C', 'A', 'B', 'D']\n    >>> bfs_shortest_path(demo_graph, \"G\", \"G\")\n    ['G']\n    >>> bfs_shortest_path(demo_graph, \"G\", \"Unknown\")\n    []"
  },
  {
    "function": "bfs_shortest_path_distance",
    "code": "def bfs_shortest_path_distance(graph: dict, start, target) -> int:\n    \"\"\"Find the shortest path distance between `start` and `target` nodes.\n    Args:\n        graph: node/list of neighboring nodes key/value pairs.\n        start: node to start search from.\n        target: node to search for.\n    Returns:\n        Number of edges in the shortest path between `start` and `target` nodes.\n        -1 if no path exists.\n    Example:\n        >>> bfs_shortest_path_distance(demo_graph, \"G\", \"D\")\n        4\n        >>> bfs_shortest_path_distance(demo_graph, \"A\", \"A\")\n        0\n        >>> bfs_shortest_path_distance(demo_graph, \"A\", \"Unknown\")\n        -1\n    \"\"\"\n    if not graph or start not in graph or target not in graph:\n        return -1\n    if start == target:\n        return 0\n    queue = deque([start])\n    visited = set(start)\n    # Keep tab on distances from `start` node.\n    dist = {start: 0, target: -1}\n    while queue:\n        node = queue.popleft()\n        if node == target:\n            dist[target] = (\n                dist[node] if dist[target] == -1 else min(dist[target], dist[node])\n            )\n        for adjacent in graph[node]:\n            if adjacent not in visited:\n                visited.add(adjacent)\n                queue.append(adjacent)\n                dist[adjacent] = dist[node] + 1\n    return dist[target]",
    "docstring": "Find the shortest path distance between `start` and `target` nodes.\nArgs:\n    graph: node/list of neighboring nodes key/value pairs.\n    start: node to start search from.\n    target: node to search for.\nReturns:\n    Number of edges in the shortest path between `start` and `target` nodes.\n    -1 if no path exists.\nExample:\n    >>> bfs_shortest_path_distance(demo_graph, \"G\", \"D\")\n    4\n    >>> bfs_shortest_path_distance(demo_graph, \"A\", \"A\")\n    0\n    >>> bfs_shortest_path_distance(demo_graph, \"A\", \"Unknown\")\n    -1"
  },
  {
    "function": "is_bipartite_dfs",
    "code": "def is_bipartite_dfs(graph: dict[int, list[int]]) -> bool:\n    \"\"\"\n    Check if a graph is bipartite using depth-first search (DFS).\n\n    Args:\n        `graph`: Adjacency list representing the graph.\n\n    Returns:\n        ``True`` if bipartite, ``False`` otherwise.\n\n    Checks if the graph can be divided into two sets of vertices, such that no two\n    vertices within the same set are connected by an edge.\n\n    Examples:\n\n    >>> is_bipartite_dfs({0: [1, 2], 1: [0, 3], 2: [0, 4]})\n    True\n    >>> is_bipartite_dfs({0: [1, 2], 1: [0, 3], 2: [0, 1]})\n    False\n    >>> is_bipartite_dfs({})\n    True\n    >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\n    True\n    >>> is_bipartite_dfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]})\n    False\n    >>> is_bipartite_dfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]})\n    True\n    >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\n    False\n    >>> is_bipartite_dfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\n    False\n\n    >>> # FIXME: This test should fails with KeyError: 4.\n    >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]})\n    False\n    >>> is_bipartite_dfs({0: [-1, 3], 1: [0, -2]})\n    False\n    >>> is_bipartite_dfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]})\n    True\n    >>> is_bipartite_dfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\n    True\n\n    >>> # FIXME: This test should fails with\n    >>> # TypeError: list indices must be integers or...\n    >>> is_bipartite_dfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]})\n    True\n    >>> is_bipartite_dfs({\"a\": [1, 3], \"b\": [0, 2], \"c\": [1, 3], \"d\": [0, 2]})\n    True\n    >>> is_bipartite_dfs({0: [\"b\", \"d\"], 1: [\"a\", \"c\"], 2: [\"b\", \"d\"], 3: [\"a\", \"c\"]})\n    True\n    \"\"\"\n\n    def depth_first_search(node: int, color: int) -> bool:\n        \"\"\"\n        Perform Depth-First Search (DFS) on the graph starting from a node.\n\n        Args:\n            node: The current node being visited.\n            color: The color assigned to the current node.\n\n        Returns:\n            True if the graph is bipartite starting from the current node,\n            False otherwise.\n        \"\"\"\n        if visited[node] == -1:\n            visited[node] = color\n            if node not in graph:\n                return True\n            for neighbor in graph[node]:\n                if not depth_first_search(neighbor, 1 - color):\n                    return False\n        return visited[node] == color\n\n    visited: defaultdict[int, int] = defaultdict(lambda: -1)\n    for node in graph:\n        if visited[node] == -1 and not depth_first_search(node, 0):\n            return False\n    return True",
    "docstring": "Check if a graph is bipartite using depth-first search (DFS).\n\nArgs:\n    `graph`: Adjacency list representing the graph.\n\nReturns:\n    ``True`` if bipartite, ``False`` otherwise.\n\nChecks if the graph can be divided into two sets of vertices, such that no two\nvertices within the same set are connected by an edge.\n\nExamples:\n\n>>> is_bipartite_dfs({0: [1, 2], 1: [0, 3], 2: [0, 4]})\nTrue\n>>> is_bipartite_dfs({0: [1, 2], 1: [0, 3], 2: [0, 1]})\nFalse\n>>> is_bipartite_dfs({})\nTrue\n>>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\nTrue\n>>> is_bipartite_dfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]})\nFalse\n>>> is_bipartite_dfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]})\nTrue\n>>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\nFalse\n>>> is_bipartite_dfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\nFalse\n\n>>> # FIXME: This test should fails with KeyError: 4.\n>>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]})\nFalse\n>>> is_bipartite_dfs({0: [-1, 3], 1: [0, -2]})\nFalse\n>>> is_bipartite_dfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]})\nTrue\n>>> is_bipartite_dfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\nTrue\n\n>>> # FIXME: This test should fails with\n>>> # TypeError: list indices must be integers or...\n>>> is_bipartite_dfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]})\nTrue\n>>> is_bipartite_dfs({\"a\": [1, 3], \"b\": [0, 2], \"c\": [1, 3], \"d\": [0, 2]})\nTrue\n>>> is_bipartite_dfs({0: [\"b\", \"d\"], 1: [\"a\", \"c\"], 2: [\"b\", \"d\"], 3: [\"a\", \"c\"]})\nTrue"
  },
  {
    "function": "is_bipartite_bfs",
    "code": "def is_bipartite_bfs(graph: dict[int, list[int]]) -> bool:\n    \"\"\"\n    Check if a graph is bipartite using a breadth-first search (BFS).\n\n    Args:\n        `graph`: Adjacency list representing the graph.\n\n    Returns:\n        ``True`` if bipartite, ``False`` otherwise.\n\n    Check if the graph can be divided into two sets of vertices, such that no two\n    vertices within the same set are connected by an edge.\n\n    Examples:\n\n    >>> is_bipartite_bfs({0: [1, 2], 1: [0, 3], 2: [0, 4]})\n    True\n    >>> is_bipartite_bfs({0: [1, 2], 1: [0, 2], 2: [0, 1]})\n    False\n    >>> is_bipartite_bfs({})\n    True\n    >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\n    True\n    >>> is_bipartite_bfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]})\n    False\n    >>> is_bipartite_bfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]})\n    True\n    >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\n    False\n    >>> is_bipartite_bfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\n    False\n\n    >>> # FIXME: This test should fails with KeyError: 4.\n    >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]})\n    False\n    >>> is_bipartite_bfs({0: [-1, 3], 1: [0, -2]})\n    False\n    >>> is_bipartite_bfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]})\n    True\n    >>> is_bipartite_bfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\n    True\n\n    >>> # FIXME: This test should fails with\n    >>> # TypeError: list indices must be integers or...\n    >>> is_bipartite_bfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]})\n    True\n    >>> is_bipartite_bfs({\"a\": [1, 3], \"b\": [0, 2], \"c\": [1, 3], \"d\": [0, 2]})\n    True\n    >>> is_bipartite_bfs({0: [\"b\", \"d\"], 1: [\"a\", \"c\"], 2: [\"b\", \"d\"], 3: [\"a\", \"c\"]})\n    True\n    \"\"\"\n    visited: defaultdict[int, int] = defaultdict(lambda: -1)\n    for node in graph:\n        if visited[node] == -1:\n            queue: deque[int] = deque()\n            queue.append(node)\n            visited[node] = 0\n            while queue:\n                curr_node = queue.popleft()\n                if curr_node not in graph:\n                    continue\n                for neighbor in graph[curr_node]:\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = 1 - visited[curr_node]\n                        queue.append(neighbor)\n                    elif visited[neighbor] == visited[curr_node]:\n                        return False\n    return True",
    "docstring": "Check if a graph is bipartite using a breadth-first search (BFS).\n\nArgs:\n    `graph`: Adjacency list representing the graph.\n\nReturns:\n    ``True`` if bipartite, ``False`` otherwise.\n\nCheck if the graph can be divided into two sets of vertices, such that no two\nvertices within the same set are connected by an edge.\n\nExamples:\n\n>>> is_bipartite_bfs({0: [1, 2], 1: [0, 3], 2: [0, 4]})\nTrue\n>>> is_bipartite_bfs({0: [1, 2], 1: [0, 2], 2: [0, 1]})\nFalse\n>>> is_bipartite_bfs({})\nTrue\n>>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\nTrue\n>>> is_bipartite_bfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]})\nFalse\n>>> is_bipartite_bfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]})\nTrue\n>>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\nFalse\n>>> is_bipartite_bfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\nFalse\n\n>>> # FIXME: This test should fails with KeyError: 4.\n>>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]})\nFalse\n>>> is_bipartite_bfs({0: [-1, 3], 1: [0, -2]})\nFalse\n>>> is_bipartite_bfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]})\nTrue\n>>> is_bipartite_bfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\nTrue\n\n>>> # FIXME: This test should fails with\n>>> # TypeError: list indices must be integers or...\n>>> is_bipartite_bfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]})\nTrue\n>>> is_bipartite_bfs({\"a\": [1, 3], \"b\": [0, 2], \"c\": [1, 3], \"d\": [0, 2]})\nTrue\n>>> is_bipartite_bfs({0: [\"b\", \"d\"], 1: [\"a\", \"c\"], 2: [\"b\", \"d\"], 3: [\"a\", \"c\"]})\nTrue"
  },
  {
    "function": "check_cycle",
    "code": "def check_cycle(graph: dict) -> bool:\n    \"\"\"\n    Returns True if graph is cyclic else False\n    >>> check_cycle(graph={0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]})\n    False\n    >>> check_cycle(graph={0:[1, 2], 1:[2], 2:[0, 3], 3:[3]})\n    True\n    \"\"\"\n    # Keep track of visited nodes\n    visited: set[int] = set()\n    # To detect a back edge, keep track of vertices currently in the recursion stack\n    rec_stk: set[int] = set()\n    return any(\n        node not in visited and depth_first_search(graph, node, visited, rec_stk)\n        for node in graph\n    )",
    "docstring": "Returns True if graph is cyclic else False\n>>> check_cycle(graph={0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]})\nFalse\n>>> check_cycle(graph={0:[1, 2], 1:[2], 2:[0, 3], 3:[3]})\nTrue"
  },
  {
    "function": "depth_first_search",
    "code": "def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:\n    \"\"\"\n    Recur for all neighbours.\n    If any neighbour is visited and in rec_stk then graph is cyclic.\n    >>> graph = {0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]}\n    >>> vertex, visited, rec_stk = 0, set(), set()\n    >>> depth_first_search(graph, vertex, visited, rec_stk)\n    False\n    \"\"\"\n    # Mark current node as visited and add to recursion stack\n    visited.add(vertex)\n    rec_stk.add(vertex)\n\n    for node in graph[vertex]:\n        if node not in visited:\n            if depth_first_search(graph, node, visited, rec_stk):\n                return True\n        elif node in rec_stk:\n            return True\n\n    # The node needs to be removed from recursion stack before function ends\n    rec_stk.remove(vertex)\n    return False",
    "docstring": "Recur for all neighbours.\nIf any neighbour is visited and in rec_stk then graph is cyclic.\n>>> graph = {0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]}\n>>> vertex, visited, rec_stk = 0, set(), set()\n>>> depth_first_search(graph, vertex, visited, rec_stk)\nFalse"
  },
  {
    "function": "dfs",
    "code": "def dfs(graph: dict, vert: int, visited: list) -> list:\n    \"\"\"\n    Use depth first search to find all vertices\n    being in the same component as initial vertex\n    >>> dfs(test_graph_1, 0, 5 * [False])\n    [0, 1, 3, 2]\n    >>> dfs(test_graph_2, 0, 6 * [False])\n    [0, 1, 3, 2]\n    \"\"\"\n\n    visited[vert] = True\n    connected_verts = []\n\n    for neighbour in graph[vert]:\n        if not visited[neighbour]:\n            connected_verts += dfs(graph, neighbour, visited)\n\n    return [vert, *connected_verts]",
    "docstring": "Use depth first search to find all vertices\nbeing in the same component as initial vertex\n>>> dfs(test_graph_1, 0, 5 * [False])\n[0, 1, 3, 2]\n>>> dfs(test_graph_2, 0, 6 * [False])\n[0, 1, 3, 2]"
  },
  {
    "function": "connected_components",
    "code": "def connected_components(graph: dict) -> list:\n    \"\"\"\n    This function takes graph as a parameter\n    and then returns the list of connected components\n    >>> connected_components(test_graph_1)\n    [[0, 1, 3, 2], [4, 5, 6]]\n    >>> connected_components(test_graph_2)\n    [[0, 1, 3, 2], [4], [5]]\n    \"\"\"\n\n    graph_size = len(graph)\n    visited = graph_size * [False]\n    components_list = []\n\n    for i in range(graph_size):\n        if not visited[i]:\n            i_connected = dfs(graph, i, visited)\n            components_list.append(i_connected)\n\n    return components_list",
    "docstring": "This function takes graph as a parameter\nand then returns the list of connected components\n>>> connected_components(test_graph_1)\n[[0, 1, 3, 2], [4, 5, 6]]\n>>> connected_components(test_graph_2)\n[[0, 1, 3, 2], [4], [5]]"
  },
  {
    "function": "clone_graph",
    "code": "def clone_graph(node: Node | None) -> Node | None:\n    \"\"\"\n    This function returns a clone of a connected undirected graph.\n    >>> clone_graph(Node(1))\n    Node(value=1, neighbors=[])\n    >>> clone_graph(Node(1, [Node(2)]))\n    Node(value=1, neighbors=[Node(value=2, neighbors=[])])\n    >>> clone_graph(None) is None\n    True\n    \"\"\"\n    if not node:\n        return None\n\n    originals_to_clones = {}  # map nodes to clones\n\n    stack = [node]\n\n    while stack:\n        original = stack.pop()\n\n        if original in originals_to_clones:\n            continue\n\n        originals_to_clones[original] = Node(original.value)\n\n        stack.extend(original.neighbors or [])\n\n    for original, clone in originals_to_clones.items():\n        for neighbor in original.neighbors or []:\n            cloned_neighbor = originals_to_clones[neighbor]\n\n            if not clone.neighbors:\n                clone.neighbors = []\n\n            clone.neighbors.append(cloned_neighbor)\n\n    return originals_to_clones[node]",
    "docstring": "This function returns a clone of a connected undirected graph.\n>>> clone_graph(Node(1))\nNode(value=1, neighbors=[])\n>>> clone_graph(Node(1, [Node(2)]))\nNode(value=1, neighbors=[Node(value=2, neighbors=[])])\n>>> clone_graph(None) is None\nTrue"
  },
  {
    "function": "depth_first_search",
    "code": "def depth_first_search(graph: dict, start: str) -> set[str]:\n    \"\"\"Depth First Search on Graph\n    :param graph: directed graph in dictionary format\n    :param start: starting vertex as a string\n    :returns: the trace of the search\n    >>> input_G = { \"A\": [\"B\", \"C\", \"D\"], \"B\": [\"A\", \"D\", \"E\"],\n    ... \"C\": [\"A\", \"F\"], \"D\": [\"B\", \"D\"], \"E\": [\"B\", \"F\"],\n    ... \"F\": [\"C\", \"E\", \"G\"], \"G\": [\"F\"] }\n    >>> output_G = list({'A', 'B', 'C', 'D', 'E', 'F', 'G'})\n    >>> all(x in output_G for x in list(depth_first_search(input_G, \"A\")))\n    True\n    >>> all(x in output_G for x in list(depth_first_search(input_G, \"G\")))\n    True\n    \"\"\"\n    explored, stack = set(start), [start]\n\n    while stack:\n        v = stack.pop()\n        explored.add(v)\n        # Differences from BFS:\n        # 1) pop last element instead of first one\n        # 2) add adjacent elements to stack without exploring them\n        for adj in reversed(graph[v]):\n            if adj not in explored:\n                stack.append(adj)\n    return explored",
    "docstring": "Depth First Search on Graph\n:param graph: directed graph in dictionary format\n:param start: starting vertex as a string\n:returns: the trace of the search\n>>> input_G = { \"A\": [\"B\", \"C\", \"D\"], \"B\": [\"A\", \"D\", \"E\"],\n... \"C\": [\"A\", \"F\"], \"D\": [\"B\", \"D\"], \"E\": [\"B\", \"F\"],\n... \"F\": [\"C\", \"E\", \"G\"], \"G\": [\"F\"] }\n>>> output_G = list({'A', 'B', 'C', 'D', 'E', 'F', 'G'})\n>>> all(x in output_G for x in list(depth_first_search(input_G, \"A\")))\nTrue\n>>> all(x in output_G for x in list(depth_first_search(input_G, \"G\")))\nTrue"
  },
  {
    "function": "dijkstra",
    "code": "def dijkstra(graph, start, end):\n    \"\"\"Return the cost of the shortest path between vertices start and end.\n\n    >>> dijkstra(G, \"E\", \"C\")\n    6\n    >>> dijkstra(G2, \"E\", \"F\")\n    3\n    >>> dijkstra(G3, \"E\", \"F\")\n    3\n    \"\"\"\n\n    heap = [(0, start)]  # cost from start node,end node\n    visited = set()\n    while heap:\n        (cost, u) = heapq.heappop(heap)\n        if u in visited:\n            continue\n        visited.add(u)\n        if u == end:\n            return cost\n        for v, c in graph[u]:\n            if v in visited:\n                continue\n            next_item = cost + c\n            heapq.heappush(heap, (next_item, v))\n    return -1",
    "docstring": "Return the cost of the shortest path between vertices start and end.\n\n>>> dijkstra(G, \"E\", \"C\")\n6\n>>> dijkstra(G2, \"E\", \"F\")\n3\n>>> dijkstra(G3, \"E\", \"F\")\n3"
  },
  {
    "function": "dijkstra",
    "code": "def dijkstra(\n    grid: np.ndarray,\n    source: tuple[int, int],\n    destination: tuple[int, int],\n    allow_diagonal: bool,\n) -> tuple[float | int, list[tuple[int, int]]]:\n    \"\"\"\n    Implements Dijkstra's algorithm on a binary grid.\n\n    Args:\n        grid (np.ndarray): A 2D numpy array representing the grid.\n        1 represents a walkable node and 0 represents an obstacle.\n        source (Tuple[int, int]): A tuple representing the start node.\n        destination (Tuple[int, int]): A tuple representing the\n        destination node.\n        allow_diagonal (bool): A boolean determining whether\n        diagonal movements are allowed.\n\n    Returns:\n        Tuple[Union[float, int], List[Tuple[int, int]]]:\n        The shortest distance from the start node to the destination node\n        and the shortest path as a list of nodes.\n\n    >>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), False)\n    (4.0, [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)])\n\n    >>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), True)\n    (2.0, [(0, 0), (1, 1), (2, 2)])\n\n    >>> dijkstra(np.array([[1, 1, 1], [0, 0, 1], [0, 1, 1]]), (0, 0), (2, 2), False)\n    (4.0, [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)])\n    \"\"\"\n    rows, cols = grid.shape\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    if allow_diagonal:\n        dx += [-1, -1, 1, 1]\n        dy += [-1, 1, -1, 1]\n\n    queue, visited = [(0, source)], set()\n    matrix = np.full((rows, cols), np.inf)\n    matrix[source] = 0\n    predecessors = np.empty((rows, cols), dtype=object)\n    predecessors[source] = None\n\n    while queue:\n        (dist, (x, y)) = heappop(queue)\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n\n        if (x, y) == destination:\n            path = []\n            while (x, y) != source:\n                path.append((x, y))\n                x, y = predecessors[x, y]\n            path.append(source)  # add the source manually\n            path.reverse()\n            return float(matrix[destination]), path\n\n        for i in range(len(dx)):\n            nx, ny = x + dx[i], y + dy[i]\n            if 0 <= nx < rows and 0 <= ny < cols:\n                next_node = grid[nx][ny]\n                if next_node == 1 and matrix[nx, ny] > dist + 1:\n                    heappush(queue, (dist + 1, (nx, ny)))\n                    matrix[nx, ny] = dist + 1\n                    predecessors[nx, ny] = (x, y)\n\n    return np.inf, []",
    "docstring": "Implements Dijkstra's algorithm on a binary grid.\n\nArgs:\n    grid (np.ndarray): A 2D numpy array representing the grid.\n    1 represents a walkable node and 0 represents an obstacle.\n    source (Tuple[int, int]): A tuple representing the start node.\n    destination (Tuple[int, int]): A tuple representing the\n    destination node.\n    allow_diagonal (bool): A boolean determining whether\n    diagonal movements are allowed.\n\nReturns:\n    Tuple[Union[float, int], List[Tuple[int, int]]]:\n    The shortest distance from the start node to the destination node\n    and the shortest path as a list of nodes.\n\n>>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), False)\n(4.0, [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)])\n\n>>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), True)\n(2.0, [(0, 0), (1, 1), (2, 2)])\n\n>>> dijkstra(np.array([[1, 1, 1], [0, 0, 1], [0, 1, 1]]), (0, 0), (2, 2), False)\n(4.0, [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)])"
  },
  {
    "function": "even_tree",
    "code": "def even_tree():\n    \"\"\"\n    2 1\n    3 1\n    4 3\n    5 2\n    6 1\n    7 2\n    8 6\n    9 8\n    10 8\n    On removing edges (1,3) and (1,6), we can get the desired result 2.\n    \"\"\"\n    dfs(1)",
    "docstring": "2 1\n3 1\n4 3\n5 2\n6 1\n7 2\n8 6\n9 8\n10 8\nOn removing edges (1,3) and (1,6), we can get the desired result 2."
  },
  {
    "function": "compute_bridges",
    "code": "def compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:\n    \"\"\"\n    Return the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi\n    >>> compute_bridges(__get_demo_graph(0))\n    [(3, 4), (2, 3), (2, 5)]\n    >>> compute_bridges(__get_demo_graph(1))\n    [(6, 7), (0, 6), (1, 9), (3, 4), (2, 4), (2, 5)]\n    >>> compute_bridges(__get_demo_graph(2))\n    [(1, 6), (4, 6), (0, 4)]\n    >>> compute_bridges(__get_demo_graph(3))\n    []\n    >>> compute_bridges({})\n    []\n    \"\"\"\n\n    id_ = 0\n    n = len(graph)  # No of vertices in graph\n    low = [0] * n\n    visited = [False] * n\n\n    def dfs(at, parent, bridges, id_):\n        visited[at] = True\n        low[at] = id_\n        id_ += 1\n        for to in graph[at]:\n            if to == parent:\n                pass\n            elif not visited[to]:\n                dfs(to, at, bridges, id_)\n                low[at] = min(low[at], low[to])\n                if id_ <= low[to]:\n                    bridges.append((at, to) if at < to else (to, at))\n            else:\n                # This edge is a back edge and cannot be a bridge\n                low[at] = min(low[at], low[to])\n\n    bridges: list[tuple[int, int]] = []\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, -1, bridges, id_)\n    return bridges",
    "docstring": "Return the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi\n>>> compute_bridges(__get_demo_graph(0))\n[(3, 4), (2, 3), (2, 5)]\n>>> compute_bridges(__get_demo_graph(1))\n[(6, 7), (0, 6), (1, 9), (3, 4), (2, 4), (2, 5)]\n>>> compute_bridges(__get_demo_graph(2))\n[(1, 6), (4, 6), (0, 4)]\n>>> compute_bridges(__get_demo_graph(3))\n[]\n>>> compute_bridges({})\n[]"
  },
  {
    "function": "get_distinct_edge",
    "code": "def get_distinct_edge(edge_array):\n    \"\"\"\n    Return Distinct edges from edge array of multiple graphs\n    >>> sorted(get_distinct_edge(edge_array))\n    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n    \"\"\"\n    distinct_edge = set()\n    for row in edge_array:\n        for item in row:\n            distinct_edge.add(item[0])\n    return list(distinct_edge)",
    "docstring": "Return Distinct edges from edge array of multiple graphs\n>>> sorted(get_distinct_edge(edge_array))\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']"
  },
  {
    "function": "get_bitcode",
    "code": "def get_bitcode(edge_array, distinct_edge):\n    \"\"\"\n    Return bitcode of distinct_edge\n    \"\"\"\n    bitcode = [\"0\"] * len(edge_array)\n    for i, row in enumerate(edge_array):\n        for item in row:\n            if distinct_edge in item[0]:\n                bitcode[i] = \"1\"\n                break\n    return \"\".join(bitcode)",
    "docstring": "Return bitcode of distinct_edge"
  },
  {
    "function": "get_frequency_table",
    "code": "def get_frequency_table(edge_array):\n    \"\"\"\n    Returns Frequency Table\n    \"\"\"\n    distinct_edge = get_distinct_edge(edge_array)\n    frequency_table = {}\n\n    for item in distinct_edge:\n        bit = get_bitcode(edge_array, item)\n        # print('bit',bit)\n        # bt=''.join(bit)\n        s = bit.count(\"1\")\n        frequency_table[item] = [s, bit]\n    # Store [Distinct edge, WT(Bitcode), Bitcode] in descending order\n    sorted_frequency_table = [\n        [k, v[0], v[1]]\n        for k, v in sorted(frequency_table.items(), key=lambda v: v[1][0], reverse=True)\n    ]\n    return sorted_frequency_table",
    "docstring": "Returns Frequency Table"
  },
  {
    "function": "get_nodes",
    "code": "def get_nodes(frequency_table):\n    \"\"\"\n    Returns nodes\n    format nodes={bitcode:edges that represent the bitcode}\n    >>> get_nodes([['ab', 5, '11111'], ['ac', 5, '11111'], ['df', 5, '11111'],\n    ...            ['bd', 5, '11111'], ['bc', 5, '11111']])\n    {'11111': ['ab', 'ac', 'df', 'bd', 'bc']}\n    \"\"\"\n    nodes = {}\n    for _, item in enumerate(frequency_table):\n        nodes.setdefault(item[2], []).append(item[0])\n    return nodes",
    "docstring": "Returns nodes\nformat nodes={bitcode:edges that represent the bitcode}\n>>> get_nodes([['ab', 5, '11111'], ['ac', 5, '11111'], ['df', 5, '11111'],\n...            ['bd', 5, '11111'], ['bc', 5, '11111']])\n{'11111': ['ab', 'ac', 'df', 'bd', 'bc']}"
  },
  {
    "function": "get_cluster",
    "code": "def get_cluster(nodes):\n    \"\"\"\n    Returns cluster\n    format cluster:{WT(bitcode):nodes with same WT}\n    \"\"\"\n    cluster = {}\n    for key, value in nodes.items():\n        cluster.setdefault(key.count(\"1\"), {})[key] = value\n    return cluster",
    "docstring": "Returns cluster\nformat cluster:{WT(bitcode):nodes with same WT}"
  },
  {
    "function": "get_support",
    "code": "def get_support(cluster):\n    \"\"\"\n    Returns support\n    >>> get_support({5: {'11111': ['ab', 'ac', 'df', 'bd', 'bc']},\n    ...              4: {'11101': ['ef', 'eg', 'de', 'fg'], '11011': ['cd']},\n    ...              3: {'11001': ['ad'], '10101': ['dg']},\n    ...              2: {'10010': ['dh', 'bh'], '11000': ['be'], '10100': ['gh'],\n    ...                  '10001': ['ce']},\n    ...              1: {'00100': ['fh', 'eh'], '10000': ['hi']}})\n    [100.0, 80.0, 60.0, 40.0, 20.0]\n    \"\"\"\n    return [i * 100 / len(cluster) for i in cluster]",
    "docstring": "Returns support\n>>> get_support({5: {'11111': ['ab', 'ac', 'df', 'bd', 'bc']},\n...              4: {'11101': ['ef', 'eg', 'de', 'fg'], '11011': ['cd']},\n...              3: {'11001': ['ad'], '10101': ['dg']},\n...              2: {'10010': ['dh', 'bh'], '11000': ['be'], '10100': ['gh'],\n...                  '10001': ['ce']},\n...              1: {'00100': ['fh', 'eh'], '10000': ['hi']}})\n[100.0, 80.0, 60.0, 40.0, 20.0]"
  },
  {
    "function": "create_edge",
    "code": "def create_edge(nodes, graph, cluster, c1):\n    \"\"\"\n    create edge between the nodes\n    \"\"\"\n    for i in cluster[c1]:\n        count = 0\n        c2 = c1 + 1\n        while c2 < max(cluster.keys()):\n            for j in cluster[c2]:\n                \"\"\"\n                creates edge only if the condition satisfies\n                \"\"\"\n                if int(i, 2) & int(j, 2) == int(i, 2):\n                    if tuple(nodes[i]) in graph:\n                        graph[tuple(nodes[i])].append(nodes[j])\n                    else:\n                        graph[tuple(nodes[i])] = [nodes[j]]\n                    count += 1\n            if count == 0:\n                c2 = c2 + 1\n            else:\n                break",
    "docstring": "create edge between the nodes"
  },
  {
    "function": "my_dfs",
    "code": "def my_dfs(graph, start, end, path=None):\n    \"\"\"\n    find different DFS walk from given node to Header node\n    \"\"\"\n    path = (path or []) + [start]\n    if start == end:\n        paths.append(path)\n    for node in graph[start]:\n        if tuple(node) not in path:\n            my_dfs(graph, tuple(node), end, path)",
    "docstring": "find different DFS walk from given node to Header node"
  },
  {
    "function": "find_freq_subgraph_given_support",
    "code": "def find_freq_subgraph_given_support(s, cluster, graph):\n    \"\"\"\n    find edges of multiple frequent subgraphs\n    \"\"\"\n    k = int(s / 100 * (len(cluster) - 1))\n    for i in cluster[k]:\n        my_dfs(graph, tuple(cluster[k][i]), ([\"Header\"],))",
    "docstring": "find edges of multiple frequent subgraphs"
  },
  {
    "function": "freq_subgraphs_edge_list",
    "code": "def freq_subgraphs_edge_list(paths):\n    \"\"\"\n    returns Edge list for frequent subgraphs\n    \"\"\"\n    freq_sub_el = []\n    for edges in paths:\n        el = []\n        for j in range(len(edges) - 1):\n            temp = list(edges[j])\n            for e in temp:\n                edge = (e[0], e[1])\n                el.append(edge)\n        freq_sub_el.append(el)\n    return freq_sub_el",
    "docstring": "returns Edge list for frequent subgraphs"
  },
  {
    "function": "preprocess",
    "code": "def preprocess(edge_array):\n    \"\"\"\n    Preprocess the edge array\n    >>> preprocess([['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'bh-e12',\n    ...              'cd-e2', 'ce-e4', 'de-e1', 'df-e8', 'dg-e5', 'dh-e10', 'ef-e3',\n    ...              'eg-e2', 'fg-e6', 'gh-e6', 'hi-e3']])\n\n    \"\"\"\n    for i in range(len(edge_array)):\n        for j in range(len(edge_array[i])):\n            t = edge_array[i][j].split(\"-\")\n            edge_array[i][j] = t",
    "docstring": "Preprocess the edge array\n>>> preprocess([['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'bh-e12',\n...              'cd-e2', 'ce-e4', 'de-e1', 'df-e8', 'dg-e5', 'dh-e10', 'ef-e3',\n...              'eg-e2', 'fg-e6', 'gh-e6', 'hi-e3']])"
  },
  {
    "function": "stable_matching",
    "code": "def stable_matching(\n    donor_pref: list[list[int]], recipient_pref: list[list[int]]\n) -> list[int]:\n    \"\"\"\n    Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects\n    prefer each other over their partner.  The function accepts the preferences of\n    oegan donors and recipients (where both are assigned numbers from 0 to n-1) and\n    returns a list where the index position corresponds to the donor and value at the\n    index is the organ recipient.\n\n    To better understand the algorithm, see also:\n    https://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README).\n    https://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).\n\n    >>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]]\n    >>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]]\n    >>> stable_matching(donor_pref, recipient_pref)\n    [1, 2, 3, 0]\n    \"\"\"\n    assert len(donor_pref) == len(recipient_pref)\n\n    n = len(donor_pref)\n    unmatched_donors = list(range(n))\n    donor_record = [-1] * n  # who the donor has donated to\n    rec_record = [-1] * n  # who the recipient has received from\n    num_donations = [0] * n\n\n    while unmatched_donors:\n        donor = unmatched_donors[0]\n        donor_preference = donor_pref[donor]\n        recipient = donor_preference[num_donations[donor]]\n        num_donations[donor] += 1\n        rec_preference = recipient_pref[recipient]\n        prev_donor = rec_record[recipient]\n\n        if prev_donor != -1:\n            if rec_preference.index(prev_donor) > rec_preference.index(donor):\n                rec_record[recipient] = donor\n                donor_record[donor] = recipient\n                unmatched_donors.append(prev_donor)\n                unmatched_donors.remove(donor)\n        else:\n            rec_record[recipient] = donor\n            donor_record[donor] = recipient\n            unmatched_donors.remove(donor)\n    return donor_record",
    "docstring": "Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects\nprefer each other over their partner.  The function accepts the preferences of\noegan donors and recipients (where both are assigned numbers from 0 to n-1) and\nreturns a list where the index position corresponds to the donor and value at the\nindex is the organ recipient.\n\nTo better understand the algorithm, see also:\nhttps://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README).\nhttps://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).\n\n>>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]]\n>>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]]\n>>> stable_matching(donor_pref, recipient_pref)\n[1, 2, 3, 0]"
  },
  {
    "function": "floyd_warshall",
    "code": "def floyd_warshall(graph, v):\n    \"\"\"\n    :param graph: 2D array calculated from weight[edge[i, j]]\n    :type graph: List[List[float]]\n    :param v: number of vertices\n    :type v: int\n    :return: shortest distance between all vertex pairs\n    distance[u][v] will contain the shortest distance from vertex u to v.\n\n    1. For all edges from v to n, distance[i][j] = weight(edge(i, j)).\n    3. The algorithm then performs distance[i][j] = min(distance[i][j], distance[i][k] +\n        distance[k][j]) for each possible pair i, j of vertices.\n    4. The above is repeated for each vertex k in the graph.\n    5. Whenever distance[i][j] is given a new minimum value, next vertex[i][j] is\n        updated to the next vertex[i][k].\n    \"\"\"\n\n    dist = [[float(\"inf\") for _ in range(v)] for _ in range(v)]\n\n    for i in range(v):\n        for j in range(v):\n            dist[i][j] = graph[i][j]\n\n            # check vertex k against all other vertices (i, j)\n    for k in range(v):\n        # looping through rows of graph array\n        for i in range(v):\n            # looping through columns of graph array\n            for j in range(v):\n                if (\n                    dist[i][k] != float(\"inf\")\n                    and dist[k][j] != float(\"inf\")\n                    and dist[i][k] + dist[k][j] < dist[i][j]\n                ):\n                    dist[i][j] = dist[i][k] + dist[k][j]\n\n    _print_dist(dist, v)\n    return dist, v",
    "docstring": ":param graph: 2D array calculated from weight[edge[i, j]]\n:type graph: List[List[float]]\n:param v: number of vertices\n:type v: int\n:return: shortest distance between all vertex pairs\ndistance[u][v] will contain the shortest distance from vertex u to v.\n\n1. For all edges from v to n, distance[i][j] = weight(edge(i, j)).\n3. The algorithm then performs distance[i][j] = min(distance[i][j], distance[i][k] +\n    distance[k][j]) for each possible pair i, j of vertices.\n4. The above is repeated for each vertex k in the graph.\n5. Whenever distance[i][j] is given a new minimum value, next vertex[i][j] is\n    updated to the next vertex[i][k]."
  },
  {
    "function": "greedy_min_vertex_cover",
    "code": "def greedy_min_vertex_cover(graph: dict) -> set[int]:\n    \"\"\"\n    Greedy APX Algorithm for min Vertex Cover\n    @input: graph (graph stored in an adjacency list where each vertex\n            is represented with an integer)\n    @example:\n    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\n    >>> greedy_min_vertex_cover(graph)\n    {0, 1, 2, 4}\n    \"\"\"\n    # queue used to store nodes and their rank\n    queue: list[list] = []\n\n    # for each node and his adjacency list add them and the rank of the node to queue\n    # using heapq module the queue will be filled like a Priority Queue\n    # heapq works with a min priority queue, so I used -1*len(v) to build it\n    for key, value in graph.items():\n        # O(log(n))\n        heapq.heappush(queue, [-1 * len(value), (key, value)])\n\n    # chosen_vertices = set of chosen vertices\n    chosen_vertices = set()\n\n    # while queue isn't empty and there are still edges\n    #   (queue[0][0] is the rank of the node with max rank)\n    while queue and queue[0][0] != 0:\n        # extract vertex with max rank from queue and add it to chosen_vertices\n        argmax = heapq.heappop(queue)[1][0]\n        chosen_vertices.add(argmax)\n\n        # Remove all arcs adjacent to argmax\n        for elem in queue:\n            # if v haven't adjacent node, skip\n            if elem[0] == 0:\n                continue\n            # if argmax is reachable from elem\n            # remove argmax from elem's adjacent list and update his rank\n            if argmax in elem[1][1]:\n                index = elem[1][1].index(argmax)\n                del elem[1][1][index]\n                elem[0] += 1\n        # re-order the queue\n        heapq.heapify(queue)\n    return chosen_vertices",
    "docstring": "Greedy APX Algorithm for min Vertex Cover\n@input: graph (graph stored in an adjacency list where each vertex\n        is represented with an integer)\n@example:\n>>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\n>>> greedy_min_vertex_cover(graph)\n{0, 1, 2, 4}"
  },
  {
    "function": "topological_sort",
    "code": "def topological_sort(graph: dict[int, list[int]]) -> list[int] | None:\n    \"\"\"\n    Perform topological sorting of a Directed Acyclic Graph (DAG)\n    using Kahn's Algorithm via Breadth-First Search (BFS).\n\n    Topological sorting is a linear ordering of vertices in a graph such that for\n    every directed edge u \u2192 v, vertex u comes before vertex v in the ordering.\n\n    Parameters:\n    graph: Adjacency list representing the directed graph where keys are\n           vertices, and values are lists of adjacent vertices.\n\n    Returns:\n    The topologically sorted order of vertices if the graph is a DAG.\n    Returns None if the graph contains a cycle.\n\n    Example:\n    >>> graph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []}\n    >>> topological_sort(graph)\n    [0, 1, 2, 3, 4, 5]\n\n    >>> graph_with_cycle = {0: [1], 1: [2], 2: [0]}\n    >>> topological_sort(graph_with_cycle)\n    \"\"\"\n\n    indegree = [0] * len(graph)\n    queue = []\n    topo_order = []\n    processed_vertices_count = 0\n\n    # Calculate the indegree of each vertex\n    for values in graph.values():\n        for i in values:\n            indegree[i] += 1\n\n    # Add all vertices with 0 indegree to the queue\n    for i in range(len(indegree)):\n        if indegree[i] == 0:\n            queue.append(i)\n\n    # Perform BFS\n    while queue:\n        vertex = queue.pop(0)\n        processed_vertices_count += 1\n        topo_order.append(vertex)\n\n        # Traverse neighbors\n        for neighbor in graph[vertex]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if processed_vertices_count != len(graph):\n        return None  # no topological ordering exists due to cycle\n    return topo_order  # valid topological ordering",
    "docstring": "Perform topological sorting of a Directed Acyclic Graph (DAG)\nusing Kahn's Algorithm via Breadth-First Search (BFS).\n\nTopological sorting is a linear ordering of vertices in a graph such that for\nevery directed edge u \u2192 v, vertex u comes before vertex v in the ordering.\n\nParameters:\ngraph: Adjacency list representing the directed graph where keys are\n       vertices, and values are lists of adjacent vertices.\n\nReturns:\nThe topologically sorted order of vertices if the graph is a DAG.\nReturns None if the graph contains a cycle.\n\nExample:\n>>> graph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []}\n>>> topological_sort(graph)\n[0, 1, 2, 3, 4, 5]\n\n>>> graph_with_cycle = {0: [1], 1: [2], 2: [0]}\n>>> topological_sort(graph_with_cycle)"
  },
  {
    "function": "partition_graph",
    "code": "def partition_graph(graph: dict[str, list[str]]) -> set[tuple[str, str]]:\n    \"\"\"\n    Partitions a graph using Karger's Algorithm. Implemented from\n    pseudocode found here:\n    https://en.wikipedia.org/wiki/Karger%27s_algorithm.\n    This function involves random choices, meaning it will not give\n    consistent outputs.\n\n    Args:\n        graph: A dictionary containing adacency lists for the graph.\n            Nodes must be strings.\n\n    Returns:\n        The cutset of the cut found by Karger's Algorithm.\n\n    >>> graph = {'0':['1'], '1':['0']}\n    >>> partition_graph(graph)\n    {('0', '1')}\n    \"\"\"\n    # Dict that maps contracted nodes to a list of all the nodes it \"contains.\"\n    contracted_nodes = {node: {node} for node in graph}\n\n    graph_copy = {node: graph[node][:] for node in graph}\n\n    while len(graph_copy) > 2:\n        # Choose a random edge.\n        u = random.choice(list(graph_copy.keys()))\n        v = random.choice(graph_copy[u])\n\n        # Contract edge (u, v) to new node uv\n        uv = u + v\n        uv_neighbors = list(set(graph_copy[u] + graph_copy[v]))\n        uv_neighbors.remove(u)\n        uv_neighbors.remove(v)\n        graph_copy[uv] = uv_neighbors\n        for neighbor in uv_neighbors:\n            graph_copy[neighbor].append(uv)\n\n        contracted_nodes[uv] = set(contracted_nodes[u].union(contracted_nodes[v]))\n\n        # Remove nodes u and v.\n        del graph_copy[u]\n        del graph_copy[v]\n        for neighbor in uv_neighbors:\n            if u in graph_copy[neighbor]:\n                graph_copy[neighbor].remove(u)\n            if v in graph_copy[neighbor]:\n                graph_copy[neighbor].remove(v)\n\n    # Find cutset.\n    groups = [contracted_nodes[node] for node in graph_copy]\n    return {\n        (node, neighbor)\n        for node in groups[0]\n        for neighbor in graph[node]\n        if neighbor in groups[1]\n    }",
    "docstring": "Partitions a graph using Karger's Algorithm. Implemented from\npseudocode found here:\nhttps://en.wikipedia.org/wiki/Karger%27s_algorithm.\nThis function involves random choices, meaning it will not give\nconsistent outputs.\n\nArgs:\n    graph: A dictionary containing adacency lists for the graph.\n        Nodes must be strings.\n\nReturns:\n    The cutset of the cut found by Karger's Algorithm.\n\n>>> graph = {'0':['1'], '1':['0']}\n>>> partition_graph(graph)\n{('0', '1')}"
  },
  {
    "function": "validate_adjacency_list",
    "code": "def validate_adjacency_list(graph: list[list[int | None]]) -> None:\n    \"\"\"Validates the adjacency list format for the graph.\n\n    Args:\n        graph: A list of lists where each sublist contains the neighbors of a node.\n\n    Raises:\n        ValueError: If the graph is not a list of lists, or if any node has\n                    invalid neighbors (e.g., out-of-range or non-integer values).\n\n    >>> validate_adjacency_list([[1, 2], [0], [0, 1]])\n    >>> validate_adjacency_list([[]])  # No neighbors, valid case\n    >>> validate_adjacency_list([[1], [2], [-1]])  # Invalid neighbor\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid neighbor -1 in node 2 adjacency list.\n    \"\"\"\n    if not isinstance(graph, list):\n        raise ValueError(\"Graph should be a list of lists.\")\n\n    for node_index, neighbors in enumerate(graph):\n        if not isinstance(neighbors, list):\n            no_neighbors_message: str = (\n                f\"Node {node_index} should have a list of neighbors.\"\n            )\n            raise ValueError(no_neighbors_message)\n        for neighbor_index in neighbors:\n            if (\n                not isinstance(neighbor_index, int)\n                or neighbor_index < 0\n                or neighbor_index >= len(graph)\n            ):\n                invalid_neighbor_message: str = (\n                    f\"Invalid neighbor {neighbor_index} in node {node_index} \"\n                    f\"adjacency list.\"\n                )\n                raise ValueError(invalid_neighbor_message)",
    "docstring": "Validates the adjacency list format for the graph.\n\nArgs:\n    graph: A list of lists where each sublist contains the neighbors of a node.\n\nRaises:\n    ValueError: If the graph is not a list of lists, or if any node has\n                invalid neighbors (e.g., out-of-range or non-integer values).\n\n>>> validate_adjacency_list([[1, 2], [0], [0, 1]])\n>>> validate_adjacency_list([[]])  # No neighbors, valid case\n>>> validate_adjacency_list([[1], [2], [-1]])  # Invalid neighbor\nTraceback (most recent call last):\n    ...\nValueError: Invalid neighbor -1 in node 2 adjacency list."
  },
  {
    "function": "lanczos_iteration",
    "code": "def lanczos_iteration(\n    graph: list[list[int | None]], num_eigenvectors: int\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"Constructs the tridiagonal matrix and orthonormal basis vectors using the\n    Lanczos method.\n\n    Args:\n        graph: The graph represented as a list of adjacency lists.\n        num_eigenvectors: The number of largest eigenvalues and eigenvectors\n                          to approximate.\n\n    Returns:\n        A tuple containing:\n            - tridiagonal_matrix: A (num_eigenvectors x num_eigenvectors) symmetric\n                                  matrix.\n            - orthonormal_basis: A (num_nodes x num_eigenvectors) matrix of orthonormal\n                                 basis vectors.\n\n    Raises:\n        ValueError: If num_eigenvectors is less than 1 or greater than the number of\n                    nodes.\n\n    >>> graph = [[1, 2], [0, 2], [0, 1]]\n    >>> T, Q = lanczos_iteration(graph, 2)\n    >>> T.shape == (2, 2) and Q.shape == (3, 2)\n    True\n    \"\"\"\n    num_nodes: int = len(graph)\n    if not (1 <= num_eigenvectors <= num_nodes):\n        raise ValueError(\n            \"Number of eigenvectors must be between 1 and the number of \"\n            \"nodes in the graph.\"\n        )\n\n    orthonormal_basis: np.ndarray = np.zeros((num_nodes, num_eigenvectors))\n    tridiagonal_matrix: np.ndarray = np.zeros((num_eigenvectors, num_eigenvectors))\n\n    rng = np.random.default_rng()\n    initial_vector: np.ndarray = rng.random(num_nodes)\n    initial_vector /= np.sqrt(np.dot(initial_vector, initial_vector))\n    orthonormal_basis[:, 0] = initial_vector\n\n    prev_beta: float = 0.0\n    for iter_index in range(num_eigenvectors):\n        result_vector: np.ndarray = multiply_matrix_vector(\n            graph, orthonormal_basis[:, iter_index]\n        )\n        if iter_index > 0:\n            result_vector -= prev_beta * orthonormal_basis[:, iter_index - 1]\n        alpha_value: float = np.dot(orthonormal_basis[:, iter_index], result_vector)\n        result_vector -= alpha_value * orthonormal_basis[:, iter_index]\n\n        prev_beta = np.sqrt(np.dot(result_vector, result_vector))\n        if iter_index < num_eigenvectors - 1 and prev_beta > 1e-10:\n            orthonormal_basis[:, iter_index + 1] = result_vector / prev_beta\n        tridiagonal_matrix[iter_index, iter_index] = alpha_value\n        if iter_index < num_eigenvectors - 1:\n            tridiagonal_matrix[iter_index, iter_index + 1] = prev_beta\n            tridiagonal_matrix[iter_index + 1, iter_index] = prev_beta\n    return tridiagonal_matrix, orthonormal_basis",
    "docstring": "Constructs the tridiagonal matrix and orthonormal basis vectors using the\nLanczos method.\n\nArgs:\n    graph: The graph represented as a list of adjacency lists.\n    num_eigenvectors: The number of largest eigenvalues and eigenvectors\n                      to approximate.\n\nReturns:\n    A tuple containing:\n        - tridiagonal_matrix: A (num_eigenvectors x num_eigenvectors) symmetric\n                              matrix.\n        - orthonormal_basis: A (num_nodes x num_eigenvectors) matrix of orthonormal\n                             basis vectors.\n\nRaises:\n    ValueError: If num_eigenvectors is less than 1 or greater than the number of\n                nodes.\n\n>>> graph = [[1, 2], [0, 2], [0, 1]]\n>>> T, Q = lanczos_iteration(graph, 2)\n>>> T.shape == (2, 2) and Q.shape == (3, 2)\nTrue"
  },
  {
    "function": "multiply_matrix_vector",
    "code": "def multiply_matrix_vector(\n    graph: list[list[int | None]], vector: np.ndarray\n) -> np.ndarray:\n    \"\"\"Performs multiplication of a graph's adjacency list representation with a vector.\n\n    Args:\n        graph: The adjacency list of the graph.\n        vector: A 1D numpy array representing the vector to multiply.\n\n    Returns:\n        A numpy array representing the product of the adjacency list and the vector.\n\n    Raises:\n        ValueError: If the vector's length does not match the number of nodes in the\n                    graph.\n\n    >>> multiply_matrix_vector([[1, 2], [0, 2], [0, 1]], np.array([1, 1, 1]))\n    array([2., 2., 2.])\n    >>> multiply_matrix_vector([[1, 2], [0, 2], [0, 1]], np.array([0, 1, 0]))\n    array([1., 0., 1.])\n    \"\"\"\n    num_nodes: int = len(graph)\n    if vector.shape[0] != num_nodes:\n        raise ValueError(\"Vector length must match the number of nodes in the graph.\")\n\n    result: np.ndarray = np.zeros(num_nodes)\n    for node_index, neighbors in enumerate(graph):\n        for neighbor_index in neighbors:\n            result[node_index] += vector[neighbor_index]\n    return result",
    "docstring": "Performs multiplication of a graph's adjacency list representation with a vector.\n\nArgs:\n    graph: The adjacency list of the graph.\n    vector: A 1D numpy array representing the vector to multiply.\n\nReturns:\n    A numpy array representing the product of the adjacency list and the vector.\n\nRaises:\n    ValueError: If the vector's length does not match the number of nodes in the\n                graph.\n\n>>> multiply_matrix_vector([[1, 2], [0, 2], [0, 1]], np.array([1, 1, 1]))\narray([2., 2., 2.])\n>>> multiply_matrix_vector([[1, 2], [0, 2], [0, 1]], np.array([0, 1, 0]))\narray([1., 0., 1.])"
  },
  {
    "function": "find_lanczos_eigenvectors",
    "code": "def find_lanczos_eigenvectors(\n    graph: list[list[int | None]], num_eigenvectors: int\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"Computes the largest eigenvalues and their corresponding eigenvectors using the\n    Lanczos method.\n\n    Args:\n        graph: The graph as a list of adjacency lists.\n        num_eigenvectors: Number of largest eigenvalues and eigenvectors to compute.\n\n    Returns:\n        A tuple containing:\n            - eigenvalues: 1D array of the largest eigenvalues in descending order.\n            - eigenvectors: 2D array where each column is an eigenvector corresponding\n                            to an eigenvalue.\n\n    Raises:\n        ValueError: If the graph format is invalid or num_eigenvectors is out of bounds.\n\n    >>> eigenvalues, eigenvectors = find_lanczos_eigenvectors(\n    ...     [[1, 2], [0, 2], [0, 1]], 2\n    ... )\n    >>> len(eigenvalues) == 2 and eigenvectors.shape[1] == 2\n    True\n    \"\"\"\n    validate_adjacency_list(graph)\n    tridiagonal_matrix, orthonormal_basis = lanczos_iteration(graph, num_eigenvectors)\n    eigenvalues, eigenvectors = np.linalg.eigh(tridiagonal_matrix)\n    return eigenvalues[::-1], np.dot(orthonormal_basis, eigenvectors[:, ::-1])",
    "docstring": "Computes the largest eigenvalues and their corresponding eigenvectors using the\nLanczos method.\n\nArgs:\n    graph: The graph as a list of adjacency lists.\n    num_eigenvectors: Number of largest eigenvalues and eigenvectors to compute.\n\nReturns:\n    A tuple containing:\n        - eigenvalues: 1D array of the largest eigenvalues in descending order.\n        - eigenvectors: 2D array where each column is an eigenvector corresponding\n                        to an eigenvalue.\n\nRaises:\n    ValueError: If the graph format is invalid or num_eigenvectors is out of bounds.\n\n>>> eigenvalues, eigenvectors = find_lanczos_eigenvectors(\n...     [[1, 2], [0, 2], [0, 1]], 2\n... )\n>>> len(eigenvalues) == 2 and eigenvectors.shape[1] == 2\nTrue"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Main driver function for testing the implementation with doctests.\n    \"\"\"\n    import doctest\n\n    doctest.testmod()",
    "docstring": "Main driver function for testing the implementation with doctests."
  },
  {
    "function": "get_transitions",
    "code": "def get_transitions(\n    start: str, transitions: list[tuple[str, str, float]], steps: int\n) -> dict[str, int]:\n    \"\"\"\n    Running Markov Chain algorithm and calculating the number of times each node is\n    visited\n\n    >>> transitions = [\n    ... ('a', 'a', 0.9),\n    ... ('a', 'b', 0.075),\n    ... ('a', 'c', 0.025),\n    ... ('b', 'a', 0.15),\n    ... ('b', 'b', 0.8),\n    ... ('b', 'c', 0.05),\n    ... ('c', 'a', 0.25),\n    ... ('c', 'b', 0.25),\n    ... ('c', 'c', 0.5)\n    ... ]\n\n    >>> result = get_transitions('a', transitions, 5000)\n\n    >>> result['a'] > result['b'] > result['c']\n    True\n    \"\"\"\n\n    graph = MarkovChainGraphUndirectedUnweighted()\n\n    for node1, node2, probability in transitions:\n        graph.add_transition_probability(node1, node2, probability)\n\n    visited = Counter(graph.get_nodes())\n    node = start\n\n    for _ in range(steps):\n        node = graph.transition(node)\n        visited[node] += 1\n\n    return visited",
    "docstring": "Running Markov Chain algorithm and calculating the number of times each node is\nvisited\n\n>>> transitions = [\n... ('a', 'a', 0.9),\n... ('a', 'b', 0.075),\n... ('a', 'c', 0.025),\n... ('b', 'a', 0.15),\n... ('b', 'b', 0.8),\n... ('b', 'c', 0.05),\n... ('c', 'a', 0.25),\n... ('c', 'b', 0.25),\n... ('c', 'c', 0.5)\n... ]\n\n>>> result = get_transitions('a', transitions, 5000)\n\n>>> result['a'] > result['b'] > result['c']\nTrue"
  },
  {
    "function": "matching_min_vertex_cover",
    "code": "def matching_min_vertex_cover(graph: dict) -> set:\n    \"\"\"\n    APX Algorithm for min Vertex Cover using Matching Approach\n    @input: graph (graph stored in an adjacency list where each vertex\n            is represented as an integer)\n    @example:\n    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\n    >>> matching_min_vertex_cover(graph)\n    {0, 1, 2, 4}\n    \"\"\"\n    # chosen_vertices = set of chosen vertices\n    chosen_vertices = set()\n    # edges = list of graph's edges\n    edges = get_edges(graph)\n\n    # While there are still elements in edges list, take an arbitrary edge\n    # (from_node, to_node) and add his extremity to chosen_vertices and then\n    # remove all arcs adjacent to the from_node and to_node\n    while edges:\n        from_node, to_node = edges.pop()\n        chosen_vertices.add(from_node)\n        chosen_vertices.add(to_node)\n        for edge in edges.copy():\n            if from_node in edge or to_node in edge:\n                edges.discard(edge)\n    return chosen_vertices",
    "docstring": "APX Algorithm for min Vertex Cover using Matching Approach\n@input: graph (graph stored in an adjacency list where each vertex\n        is represented as an integer)\n@example:\n>>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\n>>> matching_min_vertex_cover(graph)\n{0, 1, 2, 4}"
  },
  {
    "function": "get_edges",
    "code": "def get_edges(graph: dict) -> set:\n    \"\"\"\n    Return a set of couples that represents all of the edges.\n    @input: graph (graph stored in an adjacency list where each vertex is\n            represented as an integer)\n    @example:\n    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3], 3: [0, 1, 2]}\n    >>> get_edges(graph)\n    {(0, 1), (3, 1), (0, 3), (2, 0), (3, 0), (2, 3), (1, 0), (3, 2), (1, 3)}\n    \"\"\"\n    edges = set()\n    for from_node, to_nodes in graph.items():\n        for to_node in to_nodes:\n            edges.add((from_node, to_node))\n    return edges",
    "docstring": "Return a set of couples that represents all of the edges.\n@input: graph (graph stored in an adjacency list where each vertex is\n        represented as an integer)\n@example:\n>>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3], 3: [0, 1, 2]}\n>>> get_edges(graph)\n{(0, 1), (3, 1), (0, 3), (2, 0), (3, 0), (2, 3), (1, 0), (3, 2), (1, 3)}"
  },
  {
    "function": "min_path_sum",
    "code": "def min_path_sum(grid: list) -> int:\n    \"\"\"\n    Find the path from top left to bottom right of array of numbers\n    with the lowest possible sum and return the sum along this path.\n    >>> min_path_sum([\n    ...     [1, 3, 1],\n    ...     [1, 5, 1],\n    ...     [4, 2, 1],\n    ... ])\n    7\n\n    >>> min_path_sum([\n    ...     [1, 0, 5, 6, 7],\n    ...     [8, 9, 0, 4, 2],\n    ...     [4, 4, 4, 5, 1],\n    ...     [9, 6, 3, 1, 0],\n    ...     [8, 4, 3, 2, 7],\n    ... ])\n    20\n\n    >>> min_path_sum(None)\n    Traceback (most recent call last):\n        ...\n    TypeError: The grid does not contain the appropriate information\n\n    >>> min_path_sum([[]])\n    Traceback (most recent call last):\n        ...\n    TypeError: The grid does not contain the appropriate information\n    \"\"\"\n\n    if not grid or not grid[0]:\n        raise TypeError(\"The grid does not contain the appropriate information\")\n\n    for cell_n in range(1, len(grid[0])):\n        grid[0][cell_n] += grid[0][cell_n - 1]\n    row_above = grid[0]\n\n    for row_n in range(1, len(grid)):\n        current_row = grid[row_n]\n        grid[row_n] = fill_row(current_row, row_above)\n        row_above = grid[row_n]\n\n    return grid[-1][-1]",
    "docstring": "Find the path from top left to bottom right of array of numbers\nwith the lowest possible sum and return the sum along this path.\n>>> min_path_sum([\n...     [1, 3, 1],\n...     [1, 5, 1],\n...     [4, 2, 1],\n... ])\n7\n\n>>> min_path_sum([\n...     [1, 0, 5, 6, 7],\n...     [8, 9, 0, 4, 2],\n...     [4, 4, 4, 5, 1],\n...     [9, 6, 3, 1, 0],\n...     [8, 4, 3, 2, 7],\n... ])\n20\n\n>>> min_path_sum(None)\nTraceback (most recent call last):\n    ...\nTypeError: The grid does not contain the appropriate information\n\n>>> min_path_sum([[]])\nTraceback (most recent call last):\n    ...\nTypeError: The grid does not contain the appropriate information"
  },
  {
    "function": "fill_row",
    "code": "def fill_row(current_row: list, row_above: list) -> list:\n    \"\"\"\n    >>> fill_row([2, 2, 2], [1, 2, 3])\n    [3, 4, 5]\n    \"\"\"\n\n    current_row[0] += row_above[0]\n    for cell_n in range(1, len(current_row)):\n        current_row[cell_n] += min(current_row[cell_n - 1], row_above[cell_n])\n\n    return current_row",
    "docstring": ">>> fill_row([2, 2, 2], [1, 2, 3])\n[3, 4, 5]"
  },
  {
    "function": "kruskal",
    "code": "def kruskal(\n    num_nodes: int, edges: list[tuple[int, int, int]]\n) -> list[tuple[int, int, int]]:\n    \"\"\"\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1)])\n    [(2, 3, 1), (0, 1, 3), (1, 2, 5)]\n\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2)])\n    [(2, 3, 1), (0, 2, 1), (0, 1, 3)]\n\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2),\n    ... (2, 1, 1)])\n    [(2, 3, 1), (0, 2, 1), (2, 1, 1)]\n    \"\"\"\n    edges = sorted(edges, key=lambda edge: edge[2])\n\n    parent = list(range(num_nodes))\n\n    def find_parent(i):\n        if i != parent[i]:\n            parent[i] = find_parent(parent[i])\n        return parent[i]\n\n    minimum_spanning_tree_cost = 0\n    minimum_spanning_tree = []\n\n    for edge in edges:\n        parent_a = find_parent(edge[0])\n        parent_b = find_parent(edge[1])\n        if parent_a != parent_b:\n            minimum_spanning_tree_cost += edge[2]\n            minimum_spanning_tree.append(edge)\n            parent[parent_a] = parent_b\n\n    return minimum_spanning_tree",
    "docstring": ">>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1)])\n[(2, 3, 1), (0, 1, 3), (1, 2, 5)]\n\n>>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2)])\n[(2, 3, 1), (0, 2, 1), (0, 1, 3)]\n\n>>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2),\n... (2, 1, 1)])\n[(2, 3, 1), (0, 2, 1), (2, 1, 1)]"
  },
  {
    "function": "prisms_algorithm",
    "code": "def prisms_algorithm(adjacency_list):\n    \"\"\"\n    >>> adjacency_list = {0: [[1, 1], [3, 3]],\n    ...                   1: [[0, 1], [2, 6], [3, 5], [4, 1]],\n    ...                   2: [[1, 6], [4, 5], [5, 2]],\n    ...                   3: [[0, 3], [1, 5], [4, 1]],\n    ...                   4: [[1, 1], [2, 5], [3, 1], [5, 4]],\n    ...                   5: [[2, 2], [4, 4]]}\n    >>> prisms_algorithm(adjacency_list)\n    [(0, 1), (1, 4), (4, 3), (4, 5), (5, 2)]\n    \"\"\"\n\n    heap = Heap()\n\n    visited = [0] * len(adjacency_list)\n    nbr_tv = [-1] * len(adjacency_list)  # Neighboring Tree Vertex of selected vertex\n    # Minimum Distance of explored vertex with neighboring vertex of partial tree\n    # formed in graph\n    distance_tv = []  # Heap of Distance of vertices from their neighboring vertex\n    positions = []\n\n    for vertex in range(len(adjacency_list)):\n        distance_tv.append(sys.maxsize)\n        positions.append(vertex)\n        heap.node_position.append(vertex)\n\n    tree_edges = []\n    visited[0] = 1\n    distance_tv[0] = sys.maxsize\n    for neighbor, distance in adjacency_list[0]:\n        nbr_tv[neighbor] = 0\n        distance_tv[neighbor] = distance\n    heap.heapify(distance_tv, positions)\n\n    for _ in range(1, len(adjacency_list)):\n        vertex = heap.delete_minimum(distance_tv, positions)\n        if visited[vertex] == 0:\n            tree_edges.append((nbr_tv[vertex], vertex))\n            visited[vertex] = 1\n            for neighbor, distance in adjacency_list[vertex]:\n                if (\n                    visited[neighbor] == 0\n                    and distance < distance_tv[heap.get_position(neighbor)]\n                ):\n                    distance_tv[heap.get_position(neighbor)] = distance\n                    heap.bottom_to_top(\n                        distance, heap.get_position(neighbor), distance_tv, positions\n                    )\n                    nbr_tv[neighbor] = vertex\n    return tree_edges",
    "docstring": ">>> adjacency_list = {0: [[1, 1], [3, 3]],\n...                   1: [[0, 1], [2, 6], [3, 5], [4, 1]],\n...                   2: [[1, 6], [4, 5], [5, 2]],\n...                   3: [[0, 3], [1, 5], [4, 1]],\n...                   4: [[1, 1], [2, 5], [3, 1], [5, 4]],\n...                   5: [[2, 2], [4, 4]]}\n>>> prisms_algorithm(adjacency_list)\n[(0, 1), (1, 4), (4, 3), (4, 5), (5, 2)]"
  },
  {
    "function": "get_parent_position",
    "code": "def get_parent_position(position: int) -> int:\n    \"\"\"\n    heap helper function get the position of the parent of the current node\n\n    >>> get_parent_position(1)\n    0\n    >>> get_parent_position(2)\n    0\n    \"\"\"\n    return (position - 1) // 2",
    "docstring": "heap helper function get the position of the parent of the current node\n\n>>> get_parent_position(1)\n0\n>>> get_parent_position(2)\n0"
  },
  {
    "function": "get_child_left_position",
    "code": "def get_child_left_position(position: int) -> int:\n    \"\"\"\n    heap helper function get the position of the left child of the current node\n\n    >>> get_child_left_position(0)\n    1\n    \"\"\"\n    return (2 * position) + 1",
    "docstring": "heap helper function get the position of the left child of the current node\n\n>>> get_child_left_position(0)\n1"
  },
  {
    "function": "get_child_right_position",
    "code": "def get_child_right_position(position: int) -> int:\n    \"\"\"\n    heap helper function get the position of the right child of the current node\n\n    >>> get_child_right_position(0)\n    2\n    \"\"\"\n    return (2 * position) + 2",
    "docstring": "heap helper function get the position of the right child of the current node\n\n>>> get_child_right_position(0)\n2"
  },
  {
    "function": "prims_algo",
    "code": "def prims_algo[T](\n    graph: GraphUndirectedWeighted[T],\n) -> tuple[dict[T, int], dict[T, T | None]]:\n    \"\"\"\n    >>> graph = GraphUndirectedWeighted()\n\n    >>> graph.add_edge(\"a\", \"b\", 3)\n    >>> graph.add_edge(\"b\", \"c\", 10)\n    >>> graph.add_edge(\"c\", \"d\", 5)\n    >>> graph.add_edge(\"a\", \"c\", 15)\n    >>> graph.add_edge(\"b\", \"d\", 100)\n\n    >>> dist, parent = prims_algo(graph)\n\n    >>> abs(dist[\"a\"] - dist[\"b\"])\n    3\n    >>> abs(dist[\"d\"] - dist[\"b\"])\n    15\n    >>> abs(dist[\"a\"] - dist[\"c\"])\n    13\n    \"\"\"\n    # prim's algorithm for minimum spanning tree\n    dist: dict[T, int] = dict.fromkeys(graph.connections, maxsize)\n    parent: dict[T, T | None] = dict.fromkeys(graph.connections)\n\n    priority_queue: MinPriorityQueue[T] = MinPriorityQueue()\n    for node, weight in dist.items():\n        priority_queue.push(node, weight)\n\n    if priority_queue.is_empty():\n        return dist, parent\n\n    # initialization\n    node = priority_queue.extract_min()\n    dist[node] = 0\n    for neighbour in graph.connections[node]:\n        if dist[neighbour] > dist[node] + graph.connections[node][neighbour]:\n            dist[neighbour] = dist[node] + graph.connections[node][neighbour]\n            priority_queue.update_key(neighbour, dist[neighbour])\n            parent[neighbour] = node\n\n    # running prim's algorithm\n    while not priority_queue.is_empty():\n        node = priority_queue.extract_min()\n        for neighbour in graph.connections[node]:\n            if dist[neighbour] > dist[node] + graph.connections[node][neighbour]:\n                dist[neighbour] = dist[node] + graph.connections[node][neighbour]\n                priority_queue.update_key(neighbour, dist[neighbour])\n                parent[neighbour] = node\n    return dist, parent",
    "docstring": ">>> graph = GraphUndirectedWeighted()\n\n>>> graph.add_edge(\"a\", \"b\", 3)\n>>> graph.add_edge(\"b\", \"c\", 10)\n>>> graph.add_edge(\"c\", \"d\", 5)\n>>> graph.add_edge(\"a\", \"c\", 15)\n>>> graph.add_edge(\"b\", \"d\", 100)\n\n>>> dist, parent = prims_algo(graph)\n\n>>> abs(dist[\"a\"] - dist[\"b\"])\n3\n>>> abs(dist[\"d\"] - dist[\"b\"])\n15\n>>> abs(dist[\"a\"] - dist[\"c\"])\n13"
  },
  {
    "function": "prim",
    "code": "def prim(graph: list, root: Vertex) -> list:\n    \"\"\"Prim's Algorithm.\n\n    Runtime:\n        O(mn) with `m` edges and `n` vertices\n\n    Return:\n        List with the edges of a Minimum Spanning Tree\n\n    Usage:\n        prim(graph, graph[0])\n    \"\"\"\n    a = []\n    for u in graph:\n        u.key = math.inf\n        u.pi = None\n    root.key = 0\n    q = graph[:]\n    while q:\n        u = min(q)\n        q.remove(u)\n        for v in u.neighbors:\n            if (v in q) and (u.edges[v.id] < v.key):\n                v.pi = u\n                v.key = u.edges[v.id]\n    for i in range(1, len(graph)):\n        a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))\n    return a",
    "docstring": "Prim's Algorithm.\n\nRuntime:\n    O(mn) with `m` edges and `n` vertices\n\nReturn:\n    List with the edges of a Minimum Spanning Tree\n\nUsage:\n    prim(graph, graph[0])"
  },
  {
    "function": "prim_heap",
    "code": "def prim_heap(graph: list, root: Vertex) -> Iterator[tuple]:\n    \"\"\"Prim's Algorithm with min heap.\n\n    Runtime:\n        O((m + n)log n) with `m` edges and `n` vertices\n\n    Yield:\n        Edges of a Minimum Spanning Tree\n\n    Usage:\n        prim(graph, graph[0])\n    \"\"\"\n    for u in graph:\n        u.key = math.inf\n        u.pi = None\n    root.key = 0\n\n    h = list(graph)\n    hq.heapify(h)\n\n    while h:\n        u = hq.heappop(h)\n        for v in u.neighbors:\n            if (v in h) and (u.edges[v.id] < v.key):\n                v.pi = u\n                v.key = u.edges[v.id]\n                hq.heapify(h)\n\n    for i in range(1, len(graph)):\n        yield (int(graph[i].id) + 1, int(graph[i].pi.id) + 1)",
    "docstring": "Prim's Algorithm with min heap.\n\nRuntime:\n    O((m + n)log n) with `m` edges and `n` vertices\n\nYield:\n    Edges of a Minimum Spanning Tree\n\nUsage:\n    prim(graph, graph[0])"
  },
  {
    "function": "test_vector",
    "code": "def test_vector() -> None:\n    \"\"\"\n    # Creates a list to store x vertices.\n    >>> x = 5\n    >>> G = [Vertex(n) for n in range(x)]\n\n    >>> connect(G, 1, 2, 15)\n    >>> connect(G, 1, 3, 12)\n    >>> connect(G, 2, 4, 13)\n    >>> connect(G, 2, 5, 5)\n    >>> connect(G, 3, 2, 6)\n    >>> connect(G, 3, 4, 6)\n    >>> connect(G, 0, 0, 0)  # Generate the minimum spanning tree:\n    >>> G_heap = G[:]\n    >>> MST = prim(G, G[0])\n    >>> MST_heap = prim_heap(G, G[0])\n    >>> for i in MST:\n    ...     print(i)\n    (2, 3)\n    (3, 1)\n    (4, 3)\n    (5, 2)\n    >>> for i in MST_heap:\n    ...     print(i)\n    (2, 3)\n    (3, 1)\n    (4, 3)\n    (5, 2)\n    \"\"\"",
    "docstring": "# Creates a list to store x vertices.\n>>> x = 5\n>>> G = [Vertex(n) for n in range(x)]\n\n>>> connect(G, 1, 2, 15)\n>>> connect(G, 1, 3, 12)\n>>> connect(G, 2, 4, 13)\n>>> connect(G, 2, 5, 5)\n>>> connect(G, 3, 2, 6)\n>>> connect(G, 3, 4, 6)\n>>> connect(G, 0, 0, 0)  # Generate the minimum spanning tree:\n>>> G_heap = G[:]\n>>> MST = prim(G, G[0])\n>>> MST_heap = prim_heap(G, G[0])\n>>> for i in MST:\n...     print(i)\n(2, 3)\n(3, 1)\n(4, 3)\n(5, 2)\n>>> for i in MST_heap:\n...     print(i)\n(2, 3)\n(3, 1)\n(4, 3)\n(5, 2)"
  },
  {
    "function": "random_graph",
    "code": "def random_graph(\n    vertices_number: int, probability: float, directed: bool = False\n) -> dict:\n    \"\"\"\n    Generate a random graph\n    @input: vertices_number (number of vertices),\n            probability (probability that a generic edge (u,v) exists),\n            directed (if True: graph will be a directed graph,\n                      otherwise it will be an undirected graph)\n    @examples:\n    >>> random.seed(1)\n    >>> random_graph(4, 0.5)\n    {0: [1], 1: [0, 2, 3], 2: [1, 3], 3: [1, 2]}\n    >>> random.seed(1)\n    >>> random_graph(4, 0.5, True)\n    {0: [1], 1: [2, 3], 2: [3], 3: []}\n    \"\"\"\n    graph: dict = {i: [] for i in range(vertices_number)}\n\n    # if probability is greater or equal than 1, then generate a complete graph\n    if probability >= 1:\n        return complete_graph(vertices_number)\n    # if probability is lower or equal than 0, then return a graph without edges\n    if probability <= 0:\n        return graph\n\n    # for each couple of nodes, add an edge from u to v\n    # if the number randomly generated is greater than probability probability\n    for i in range(vertices_number):\n        for j in range(i + 1, vertices_number):\n            if random.random() < probability:\n                graph[i].append(j)\n                if not directed:\n                    # if the graph is undirected, add an edge in from j to i, either\n                    graph[j].append(i)\n    return graph",
    "docstring": "Generate a random graph\n@input: vertices_number (number of vertices),\n        probability (probability that a generic edge (u,v) exists),\n        directed (if True: graph will be a directed graph,\n                  otherwise it will be an undirected graph)\n@examples:\n>>> random.seed(1)\n>>> random_graph(4, 0.5)\n{0: [1], 1: [0, 2, 3], 2: [1, 3], 3: [1, 2]}\n>>> random.seed(1)\n>>> random_graph(4, 0.5, True)\n{0: [1], 1: [2, 3], 2: [3], 3: []}"
  },
  {
    "function": "complete_graph",
    "code": "def complete_graph(vertices_number: int) -> dict:\n    \"\"\"\n    Generate a complete graph with vertices_number vertices.\n    @input: vertices_number (number of vertices),\n            directed (False if the graph is undirected, True otherwise)\n    @example:\n    >>> complete_graph(3)\n    {0: [1, 2], 1: [0, 2], 2: [0, 1]}\n    \"\"\"\n    return {\n        i: [j for j in range(vertices_number) if i != j] for i in range(vertices_number)\n    }",
    "docstring": "Generate a complete graph with vertices_number vertices.\n@input: vertices_number (number of vertices),\n        directed (False if the graph is undirected, True otherwise)\n@example:\n>>> complete_graph(3)\n{0: [1, 2], 1: [0, 2], 2: [0, 1]}"
  },
  {
    "function": "topology_sort",
    "code": "def topology_sort(\n    graph: dict[int, list[int]], vert: int, visited: list[bool]\n) -> list[int]:\n    \"\"\"\n    Use depth first search to sort graph\n    At this time graph is the same as input\n    >>> topology_sort(test_graph_1, 0, 5 * [False])\n    [1, 2, 4, 3, 0]\n    >>> topology_sort(test_graph_2, 0, 6 * [False])\n    [2, 1, 5, 4, 3, 0]\n    \"\"\"\n\n    visited[vert] = True\n    order = []\n\n    for neighbour in graph[vert]:\n        if not visited[neighbour]:\n            order += topology_sort(graph, neighbour, visited)\n\n    order.append(vert)\n\n    return order",
    "docstring": "Use depth first search to sort graph\nAt this time graph is the same as input\n>>> topology_sort(test_graph_1, 0, 5 * [False])\n[1, 2, 4, 3, 0]\n>>> topology_sort(test_graph_2, 0, 6 * [False])\n[2, 1, 5, 4, 3, 0]"
  },
  {
    "function": "find_components",
    "code": "def find_components(\n    reversed_graph: dict[int, list[int]], vert: int, visited: list[bool]\n) -> list[int]:\n    \"\"\"\n    Use depth first search to find strongly connected\n    vertices. Now graph is reversed\n    >>> find_components({0: [1], 1: [2], 2: [0]}, 0, 5 * [False])\n    [0, 1, 2]\n    >>> find_components({0: [2], 1: [0], 2: [0, 1]}, 0, 6 * [False])\n    [0, 2, 1]\n    \"\"\"\n\n    visited[vert] = True\n    component = [vert]\n\n    for neighbour in reversed_graph[vert]:\n        if not visited[neighbour]:\n            component += find_components(reversed_graph, neighbour, visited)\n\n    return component",
    "docstring": "Use depth first search to find strongly connected\nvertices. Now graph is reversed\n>>> find_components({0: [1], 1: [2], 2: [0]}, 0, 5 * [False])\n[0, 1, 2]\n>>> find_components({0: [2], 1: [0], 2: [0, 1]}, 0, 6 * [False])\n[0, 2, 1]"
  },
  {
    "function": "strongly_connected_components",
    "code": "def strongly_connected_components(graph: dict[int, list[int]]) -> list[list[int]]:\n    \"\"\"\n    This function takes graph as a parameter\n    and then returns the list of strongly connected components\n    >>> strongly_connected_components(test_graph_1)\n    [[0, 1, 2], [3], [4]]\n    >>> strongly_connected_components(test_graph_2)\n    [[0, 2, 1], [3, 5, 4]]\n    \"\"\"\n\n    visited = len(graph) * [False]\n    reversed_graph: dict[int, list[int]] = {vert: [] for vert in range(len(graph))}\n\n    for vert, neighbours in graph.items():\n        for neighbour in neighbours:\n            reversed_graph[neighbour].append(vert)\n\n    order = []\n    for i, was_visited in enumerate(visited):\n        if not was_visited:\n            order += topology_sort(graph, i, visited)\n\n    components_list = []\n    visited = len(graph) * [False]\n\n    for i in range(len(graph)):\n        vert = order[len(graph) - i - 1]\n        if not visited[vert]:\n            component = find_components(reversed_graph, vert, visited)\n            components_list.append(component)\n\n    return components_list",
    "docstring": "This function takes graph as a parameter\nand then returns the list of strongly connected components\n>>> strongly_connected_components(test_graph_1)\n[[0, 1, 2], [3], [4]]\n>>> strongly_connected_components(test_graph_2)\n[[0, 2, 1], [3, 5, 4]]"
  },
  {
    "function": "tarjan",
    "code": "def tarjan(g: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Tarjan's algo for finding strongly connected components in a directed graph\n\n    Uses two main attributes of each node to track reachability, the index of that node\n    within a component(index), and the lowest index reachable from that node(lowlink).\n\n    We then perform a dfs of the each component making sure to update these parameters\n    for each node and saving the nodes we visit on the way.\n\n    If ever we find that the lowest reachable node from a current node is equal to the\n    index of the current node then it must be the root of a strongly connected\n    component and so we save it and it's equireachable vertices as a strongly\n    connected component.\n\n    Complexity: strong_connect() is called at most once for each node and has a\n    complexity of O(|E|) as it is DFS.\n    Therefore this has complexity O(|V| + |E|) for a graph G = (V, E)\n\n    >>> tarjan([[2, 3, 4], [2, 3, 4], [0, 1, 3], [0, 1, 2], [1]])\n    [[4, 3, 1, 2, 0]]\n    >>> tarjan([[], [], [], []])\n    [[0], [1], [2], [3]]\n    >>> a = [0, 1, 2, 3, 4, 5, 4]\n    >>> b = [1, 0, 3, 2, 5, 4, 0]\n    >>> n = 7\n    >>> sorted(tarjan(create_graph(n, list(zip(a, b))))) == sorted(\n    ...     tarjan(create_graph(n, list(zip(a[::-1], b[::-1])))))\n    True\n    >>> a = [0, 1, 2, 3, 4, 5, 6]\n    >>> b = [0, 1, 2, 3, 4, 5, 6]\n    >>> sorted(tarjan(create_graph(n, list(zip(a, b)))))\n    [[0], [1], [2], [3], [4], [5], [6]]\n    \"\"\"\n\n    n = len(g)\n    stack: deque[int] = deque()\n    on_stack = [False for _ in range(n)]\n    index_of = [-1 for _ in range(n)]\n    lowlink_of = index_of[:]\n\n    def strong_connect(v: int, index: int, components: list[list[int]]) -> int:\n        index_of[v] = index  # the number when this node is seen\n        lowlink_of[v] = index  # lowest rank node reachable from here\n        index += 1\n        stack.append(v)\n        on_stack[v] = True\n\n        for w in g[v]:\n            if index_of[w] == -1:\n                index = strong_connect(w, index, components)\n                lowlink_of[v] = (\n                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]\n                )\n            elif on_stack[w]:\n                lowlink_of[v] = (\n                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]\n                )\n\n        if lowlink_of[v] == index_of[v]:\n            component = []\n            w = stack.pop()\n            on_stack[w] = False\n            component.append(w)\n            while w != v:\n                w = stack.pop()\n                on_stack[w] = False\n                component.append(w)\n            components.append(component)\n        return index\n\n    components: list[list[int]] = []\n    for v in range(n):\n        if index_of[v] == -1:\n            strong_connect(v, 0, components)\n\n    return components",
    "docstring": "Tarjan's algo for finding strongly connected components in a directed graph\n\nUses two main attributes of each node to track reachability, the index of that node\nwithin a component(index), and the lowest index reachable from that node(lowlink).\n\nWe then perform a dfs of the each component making sure to update these parameters\nfor each node and saving the nodes we visit on the way.\n\nIf ever we find that the lowest reachable node from a current node is equal to the\nindex of the current node then it must be the root of a strongly connected\ncomponent and so we save it and it's equireachable vertices as a strongly\nconnected component.\n\nComplexity: strong_connect() is called at most once for each node and has a\ncomplexity of O(|E|) as it is DFS.\nTherefore this has complexity O(|V| + |E|) for a graph G = (V, E)\n\n>>> tarjan([[2, 3, 4], [2, 3, 4], [0, 1, 3], [0, 1, 2], [1]])\n[[4, 3, 1, 2, 0]]\n>>> tarjan([[], [], [], []])\n[[0], [1], [2], [3]]\n>>> a = [0, 1, 2, 3, 4, 5, 4]\n>>> b = [1, 0, 3, 2, 5, 4, 0]\n>>> n = 7\n>>> sorted(tarjan(create_graph(n, list(zip(a, b))))) == sorted(\n...     tarjan(create_graph(n, list(zip(a[::-1], b[::-1])))))\nTrue\n>>> a = [0, 1, 2, 3, 4, 5, 6]\n>>> b = [0, 1, 2, 3, 4, 5, 6]\n>>> sorted(tarjan(create_graph(n, list(zip(a, b)))))\n[[0], [1], [2], [3], [4], [5], [6]]"
  },
  {
    "function": "create_graph",
    "code": "def create_graph(n: int, edges: list[tuple[int, int]]) -> list[list[int]]:\n    \"\"\"\n    >>> n = 7\n    >>> source = [0, 0, 1, 2, 3, 3, 4, 4, 6]\n    >>> target = [1, 3, 2, 0, 1, 4, 5, 6, 5]\n    >>> edges = list(zip(source, target))\n    >>> create_graph(n, edges)\n    [[1, 3], [2], [0], [1, 4], [5, 6], [], [5]]\n    \"\"\"\n    g: list[list[int]] = [[] for _ in range(n)]\n    for u, v in edges:\n        g[u].append(v)\n    return g",
    "docstring": ">>> n = 7\n>>> source = [0, 0, 1, 2, 3, 3, 4, 4, 6]\n>>> target = [1, 3, 2, 0, 1, 4, 5, 6, 5]\n>>> edges = list(zip(source, target))\n>>> create_graph(n, edges)\n[[1, 3], [2], [0], [1, 4], [5, 6], [], [5]]"
  },
  {
    "function": "max_profit",
    "code": "def max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit",
    "docstring": ">>> max_profit([7, 1, 5, 3, 6, 4])\n5\n>>> max_profit([7, 6, 4, 3, 1])\n0"
  },
  {
    "function": "fractional_cover",
    "code": "def fractional_cover(items: list[Item], capacity: int) -> float:\n    \"\"\"\n    Solve the Fractional Cover Problem.\n\n    Args:\n        items: A list of items, where each item has weight and value attributes.\n        capacity: The maximum weight capacity of the knapsack.\n\n    Returns:\n        The maximum value that can be obtained by selecting fractions of items to cover\n        the knapsack's capacity.\n\n    Raises:\n        ValueError: If capacity is negative.\n\n    Examples:\n    >>> fractional_cover((Item(10, 60), Item(20, 100), Item(30, 120)), capacity=50)\n    240.0\n\n    >>> fractional_cover([Item(20, 100), Item(30, 120), Item(10, 60)], capacity=25)\n    135.0\n\n    >>> fractional_cover([Item(10, 60), Item(20, 100), Item(30, 120)], capacity=60)\n    280.0\n\n    >>> fractional_cover(items=[Item(5, 30), Item(10, 60), Item(15, 90)], capacity=30)\n    180.0\n\n    >>> fractional_cover(items=[], capacity=50)\n    0.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=5)\n    30.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=1)\n    6.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=0)\n    0.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacity cannot be negative\n    \"\"\"\n    if capacity < 0:\n        raise ValueError(\"Capacity cannot be negative\")\n\n    total_value = 0.0\n    remaining_capacity = capacity\n\n    # Sort the items by their value-to-weight ratio in descending order\n    for item in sorted(items, key=attrgetter(\"ratio\"), reverse=True):\n        if remaining_capacity == 0:\n            break\n\n        weight_taken = min(item.weight, remaining_capacity)\n        total_value += weight_taken * item.ratio\n        remaining_capacity -= weight_taken\n\n    return total_value",
    "docstring": "Solve the Fractional Cover Problem.\n\nArgs:\n    items: A list of items, where each item has weight and value attributes.\n    capacity: The maximum weight capacity of the knapsack.\n\nReturns:\n    The maximum value that can be obtained by selecting fractions of items to cover\n    the knapsack's capacity.\n\nRaises:\n    ValueError: If capacity is negative.\n\nExamples:\n>>> fractional_cover((Item(10, 60), Item(20, 100), Item(30, 120)), capacity=50)\n240.0\n\n>>> fractional_cover([Item(20, 100), Item(30, 120), Item(10, 60)], capacity=25)\n135.0\n\n>>> fractional_cover([Item(10, 60), Item(20, 100), Item(30, 120)], capacity=60)\n280.0\n\n>>> fractional_cover(items=[Item(5, 30), Item(10, 60), Item(15, 90)], capacity=30)\n180.0\n\n>>> fractional_cover(items=[], capacity=50)\n0.0\n\n>>> fractional_cover(items=[Item(10, 60)], capacity=5)\n30.0\n\n>>> fractional_cover(items=[Item(10, 60)], capacity=1)\n6.0\n\n>>> fractional_cover(items=[Item(10, 60)], capacity=0)\n0.0\n\n>>> fractional_cover(items=[Item(10, 60)], capacity=-1)\nTraceback (most recent call last):\n    ...\nValueError: Capacity cannot be negative"
  },
  {
    "function": "frac_knapsack",
    "code": "def frac_knapsack(vl, wt, w, n):\n    \"\"\"\n    >>> frac_knapsack([60, 100, 120], [10, 20, 30], 50, 3)\n    240.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 10, 4)\n    105.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 4)\n    95.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6], 8, 4)\n    60.0\n    >>> frac_knapsack([10, 40, 30], [5, 4, 6, 3], 8, 4)\n    60.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 0, 4)\n    0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 0)\n    95.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], -8, 4)\n    0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, -4)\n    95.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 800, 4)\n    130\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 400)\n    95.0\n    >>> frac_knapsack(\"ABCD\", [5, 4, 6, 3], 8, 400)\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for /: 'str' and 'int'\n    \"\"\"\n\n    r = sorted(zip(vl, wt), key=lambda x: x[0] / x[1], reverse=True)\n    vl, wt = [i[0] for i in r], [i[1] for i in r]\n    acc = list(accumulate(wt))\n    k = bisect(acc, w)\n    return (\n        0\n        if k == 0\n        else sum(vl[:k]) + (w - acc[k - 1]) * (vl[k]) / (wt[k])\n        if k != n\n        else sum(vl[:k])\n    )",
    "docstring": ">>> frac_knapsack([60, 100, 120], [10, 20, 30], 50, 3)\n240.0\n>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 10, 4)\n105.0\n>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 4)\n95.0\n>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6], 8, 4)\n60.0\n>>> frac_knapsack([10, 40, 30], [5, 4, 6, 3], 8, 4)\n60.0\n>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 0, 4)\n0\n>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 0)\n95.0\n>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], -8, 4)\n0\n>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, -4)\n95.0\n>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 800, 4)\n130\n>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 400)\n95.0\n>>> frac_knapsack(\"ABCD\", [5, 4, 6, 3], 8, 400)\nTraceback (most recent call last):\n    ...\nTypeError: unsupported operand type(s) for /: 'str' and 'int'"
  },
  {
    "function": "fractional_knapsack",
    "code": "def fractional_knapsack(\n    value: list[int], weight: list[int], capacity: int\n) -> tuple[float, list[float]]:\n    \"\"\"\n    >>> value = [1, 3, 5, 7, 9]\n    >>> weight = [0.9, 0.7, 0.5, 0.3, 0.1]\n    >>> fractional_knapsack(value, weight, 5)\n    (25, [1, 1, 1, 1, 1])\n    >>> fractional_knapsack(value, weight, 15)\n    (25, [1, 1, 1, 1, 1])\n    >>> fractional_knapsack(value, weight, 25)\n    (25, [1, 1, 1, 1, 1])\n    >>> fractional_knapsack(value, weight, 26)\n    (25, [1, 1, 1, 1, 1])\n    >>> fractional_knapsack(value, weight, -1)\n    (-90.0, [0, 0, 0, 0, -10.0])\n    >>> fractional_knapsack([1, 3, 5, 7], weight, 30)\n    (16, [1, 1, 1, 1])\n    >>> fractional_knapsack(value, [0.9, 0.7, 0.5, 0.3, 0.1], 30)\n    (25, [1, 1, 1, 1, 1])\n    >>> fractional_knapsack([], [], 30)\n    (0, [])\n    \"\"\"\n    index = list(range(len(value)))\n    ratio = [v / w for v, w in zip(value, weight)]\n    index.sort(key=lambda i: ratio[i], reverse=True)\n\n    max_value: float = 0\n    fractions: list[float] = [0] * len(value)\n    for i in index:\n        if weight[i] <= capacity:\n            fractions[i] = 1\n            max_value += value[i]\n            capacity -= weight[i]\n        else:\n            fractions[i] = capacity / weight[i]\n            max_value += value[i] * capacity / weight[i]\n            break\n\n    return max_value, fractions",
    "docstring": ">>> value = [1, 3, 5, 7, 9]\n>>> weight = [0.9, 0.7, 0.5, 0.3, 0.1]\n>>> fractional_knapsack(value, weight, 5)\n(25, [1, 1, 1, 1, 1])\n>>> fractional_knapsack(value, weight, 15)\n(25, [1, 1, 1, 1, 1])\n>>> fractional_knapsack(value, weight, 25)\n(25, [1, 1, 1, 1, 1])\n>>> fractional_knapsack(value, weight, 26)\n(25, [1, 1, 1, 1, 1])\n>>> fractional_knapsack(value, weight, -1)\n(-90.0, [0, 0, 0, 0, -10.0])\n>>> fractional_knapsack([1, 3, 5, 7], weight, 30)\n(16, [1, 1, 1, 1])\n>>> fractional_knapsack(value, [0.9, 0.7, 0.5, 0.3, 0.1], 30)\n(25, [1, 1, 1, 1, 1])\n>>> fractional_knapsack([], [], 30)\n(0, [])"
  },
  {
    "function": "get_gas_stations",
    "code": "def get_gas_stations(\n    gas_quantities: list[int], costs: list[int]\n) -> tuple[GasStation, ...]:\n    \"\"\"\n    This function returns a tuple of gas stations.\n\n    Args:\n        gas_quantities: Amount of gas available at each station\n        costs: The cost of gas required to move from one station to the next\n\n    Returns:\n        A tuple of gas stations\n\n    >>> gas_stations = get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2])\n    >>> len(gas_stations)\n    5\n    >>> gas_stations[0]\n    GasStation(gas_quantity=1, cost=3)\n    >>> gas_stations[-1]\n    GasStation(gas_quantity=5, cost=2)\n    \"\"\"\n    return tuple(\n        GasStation(quantity, cost) for quantity, cost in zip(gas_quantities, costs)\n    )",
    "docstring": "This function returns a tuple of gas stations.\n\nArgs:\n    gas_quantities: Amount of gas available at each station\n    costs: The cost of gas required to move from one station to the next\n\nReturns:\n    A tuple of gas stations\n\n>>> gas_stations = get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2])\n>>> len(gas_stations)\n5\n>>> gas_stations[0]\nGasStation(gas_quantity=1, cost=3)\n>>> gas_stations[-1]\nGasStation(gas_quantity=5, cost=2)"
  },
  {
    "function": "can_complete_journey",
    "code": "def can_complete_journey(gas_stations: tuple[GasStation, ...]) -> int:\n    \"\"\"\n    This function returns the index from which to start the journey\n    in order to reach the end.\n\n    Args:\n        gas_quantities [list]: Amount of gas available at each station\n        cost [list]: The cost of gas required to move from one station to the next\n\n    Returns:\n        start [int]: start index needed to complete the journey\n\n    Examples:\n    >>> can_complete_journey(get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]))\n    3\n    >>> can_complete_journey(get_gas_stations([2, 3, 4], [3, 4, 3]))\n    -1\n    \"\"\"\n    total_gas = sum(gas_station.gas_quantity for gas_station in gas_stations)\n    total_cost = sum(gas_station.cost for gas_station in gas_stations)\n    if total_gas < total_cost:\n        return -1\n\n    start = 0\n    net = 0\n    for i, gas_station in enumerate(gas_stations):\n        net += gas_station.gas_quantity - gas_station.cost\n        if net < 0:\n            start = i + 1\n            net = 0\n    return start",
    "docstring": "This function returns the index from which to start the journey\nin order to reach the end.\n\nArgs:\n    gas_quantities [list]: Amount of gas available at each station\n    cost [list]: The cost of gas required to move from one station to the next\n\nReturns:\n    start [int]: start index needed to complete the journey\n\nExamples:\n>>> can_complete_journey(get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]))\n3\n>>> can_complete_journey(get_gas_stations([2, 3, 4], [3, 4, 3]))\n-1"
  },
  {
    "function": "find_minimum_change",
    "code": "def find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer",
    "docstring": "Find the minimum change from the given denominations and value\n>>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n[2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n>>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n[500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n>>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n[]\n>>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n[]\n>>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n[100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]"
  },
  {
    "function": "minimum_waiting_time",
    "code": "def minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))",
    "docstring": "This function takes a list of query times and returns the minimum waiting time\nfor all queries to be completed.\n\nArgs:\n    queries: A list of queries measured in picoseconds\n\nReturns:\n    total_waiting_time: Minimum waiting time measured in picoseconds\n\nExamples:\n>>> minimum_waiting_time([3, 2, 1, 2, 6])\n17\n>>> minimum_waiting_time([3, 2, 1])\n4\n>>> minimum_waiting_time([1, 2, 3, 4])\n10\n>>> minimum_waiting_time([5, 5, 5, 5])\n30\n>>> minimum_waiting_time([])\n0"
  },
  {
    "function": "optimal_merge_pattern",
    "code": "def optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost",
    "docstring": "Function to merge all the files with optimum cost\n\nArgs:\n    files [list]: A list of sizes of different files to be merged\n\nReturns:\n    optimal_merge_cost [int]: Optimal cost to merge all those files\n\nExamples:\n>>> optimal_merge_pattern([2, 3, 4])\n14\n>>> optimal_merge_pattern([5, 10, 20, 30, 30])\n205\n>>> optimal_merge_pattern([8, 8, 8, 8, 8])\n96"
  },
  {
    "function": "smallest_range",
    "code": "def smallest_range(nums: list[list[int]]) -> list[int]:\n    \"\"\"\n    Find the smallest range from each list in nums.\n\n    Uses min heap for efficiency. The range includes at least one number from each list.\n\n    Args:\n        `nums`: List of k sorted integer lists.\n\n    Returns:\n        list: Smallest range as a two-element list.\n\n    Examples:\n\n    >>> smallest_range([[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]])\n    [20, 24]\n    >>> smallest_range([[1, 2, 3], [1, 2, 3], [1, 2, 3]])\n    [1, 1]\n    >>> smallest_range(((1, 2, 3), (1, 2, 3), (1, 2, 3)))\n    [1, 1]\n    >>> smallest_range(((-3, -2, -1), (0, 0, 0), (1, 2, 3)))\n    [-1, 1]\n    >>> smallest_range([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    [3, 7]\n    >>> smallest_range([[0, 0, 0], [0, 0, 0], [0, 0, 0]])\n    [0, 0]\n    >>> smallest_range([[], [], []])\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n\n    min_heap: list[tuple[int, int, int]] = []\n    current_max = -maxsize - 1\n\n    for i, items in enumerate(nums):\n        heappush(min_heap, (items[0], i, 0))\n        current_max = max(current_max, items[0])\n\n    # Initialize smallest_range with large integer values\n    smallest_range = [-maxsize - 1, maxsize]\n\n    while min_heap:\n        current_min, list_index, element_index = heappop(min_heap)\n\n        if current_max - current_min < smallest_range[1] - smallest_range[0]:\n            smallest_range = [current_min, current_max]\n\n        if element_index == len(nums[list_index]) - 1:\n            break\n\n        next_element = nums[list_index][element_index + 1]\n        heappush(min_heap, (next_element, list_index, element_index + 1))\n        current_max = max(current_max, next_element)\n\n    return smallest_range",
    "docstring": "Find the smallest range from each list in nums.\n\nUses min heap for efficiency. The range includes at least one number from each list.\n\nArgs:\n    `nums`: List of k sorted integer lists.\n\nReturns:\n    list: Smallest range as a two-element list.\n\nExamples:\n\n>>> smallest_range([[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]])\n[20, 24]\n>>> smallest_range([[1, 2, 3], [1, 2, 3], [1, 2, 3]])\n[1, 1]\n>>> smallest_range(((1, 2, 3), (1, 2, 3), (1, 2, 3)))\n[1, 1]\n>>> smallest_range(((-3, -2, -1), (0, 0, 0), (1, 2, 3)))\n[-1, 1]\n>>> smallest_range([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n[3, 7]\n>>> smallest_range([[0, 0, 0], [0, 0, 0], [0, 0, 0]])\n[0, 0]\n>>> smallest_range([[], [], []])\nTraceback (most recent call last):\n    ...\nIndexError: list index out of range"
  },
  {
    "function": "adler32",
    "code": "def adler32(plain_text: str) -> int:\n    \"\"\"\n    Function implements adler-32 hash.\n    Iterates and evaluates a new value for each character\n\n    >>> adler32('Algorithms')\n    363791387\n\n    >>> adler32('go adler em all')\n    708642122\n    \"\"\"\n    a = 1\n    b = 0\n    for plain_chr in plain_text:\n        a = (a + ord(plain_chr)) % MOD_ADLER\n        b = (b + a) % MOD_ADLER\n    return (b << 16) | a",
    "docstring": "Function implements adler-32 hash.\nIterates and evaluates a new value for each character\n\n>>> adler32('Algorithms')\n363791387\n\n>>> adler32('go adler em all')\n708642122"
  },
  {
    "function": "djb2",
    "code": "def djb2(s: str) -> int:\n    \"\"\"\n    Implementation of djb2 hash algorithm that\n    is popular because of it's magic constants.\n\n    >>> djb2('Algorithms')\n    3782405311\n\n    >>> djb2('scramble bits')\n    1609059040\n    \"\"\"\n    hash_value = 5381\n    for x in s:\n        hash_value = ((hash_value << 5) + hash_value) + ord(x)\n    return hash_value & 0xFFFFFFFF",
    "docstring": "Implementation of djb2 hash algorithm that\nis popular because of it's magic constants.\n\n>>> djb2('Algorithms')\n3782405311\n\n>>> djb2('scramble bits')\n1609059040"
  },
  {
    "function": "elf_hash",
    "code": "def elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_",
    "docstring": "Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n>>> elf_hash('lorem ipsum')\n253956621"
  },
  {
    "function": "fletcher16",
    "code": "def fletcher16(text: str) -> int:\n    \"\"\"\n    Loop through every character in the data and add to two sums.\n\n    >>> fletcher16('hello world')\n    6752\n    >>> fletcher16('onethousandfourhundredthirtyfour')\n    28347\n    >>> fletcher16('The quick brown fox jumps over the lazy dog.')\n    5655\n    \"\"\"\n    data = bytes(text, \"ascii\")\n    sum1 = 0\n    sum2 = 0\n    for character in data:\n        sum1 = (sum1 + character) % 255\n        sum2 = (sum1 + sum2) % 255\n    return (sum2 << 8) | sum1",
    "docstring": "Loop through every character in the data and add to two sums.\n\n>>> fletcher16('hello world')\n6752\n>>> fletcher16('onethousandfourhundredthirtyfour')\n28347\n>>> fletcher16('The quick brown fox jumps over the lazy dog.')\n5655"
  },
  {
    "function": "text_to_bits",
    "code": "def text_to_bits(text, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_to_bits(\"msg\")\n    '011011010111001101100111'\n    \"\"\"\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \"big\"))[2:]\n    return bits.zfill(8 * ((len(bits) + 7) // 8))",
    "docstring": ">>> text_to_bits(\"msg\")\n'011011010111001101100111'"
  },
  {
    "function": "text_from_bits",
    "code": "def text_from_bits(bits, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_from_bits('011011010111001101100111')\n    'msg'\n    \"\"\"\n    n = int(bits, 2)\n    return n.to_bytes((n.bit_length() + 7) // 8, \"big\").decode(encoding, errors) or \"\\0\"",
    "docstring": ">>> text_from_bits('011011010111001101100111')\n'msg'"
  },
  {
    "function": "emitter_converter",
    "code": "def emitter_converter(size_par, data):\n    \"\"\"\n    :param size_par: how many parity bits the message must have\n    :param data:  information bits\n    :return: message to be transmitted by unreliable medium\n            - bits of information merged with parity bits\n\n    >>> emitter_converter(4, \"101010111111\")\n    ['1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1']\n    >>> emitter_converter(5, \"101010111111\")\n    Traceback (most recent call last):\n        ...\n    ValueError: size of parity don't match with size of data\n    \"\"\"\n    if size_par + len(data) <= 2**size_par - (len(data) - 1):\n        raise ValueError(\"size of parity don't match with size of data\")\n\n    data_out = []\n    parity = []\n    bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]\n\n    # sorted information data for the size of the output data\n    data_ord = []\n    # data position template + parity\n    data_out_gab = []\n    # parity bit counter\n    qtd_bp = 0\n    # counter position of data bits\n    cont_data = 0\n\n    for x in range(1, size_par + len(data) + 1):\n        # Performs a template of bit positions - who should be given,\n        # and who should be parity\n        if qtd_bp < size_par:\n            if (np.log(x) / np.log(2)).is_integer():\n                data_out_gab.append(\"P\")\n                qtd_bp = qtd_bp + 1\n            else:\n                data_out_gab.append(\"D\")\n        else:\n            data_out_gab.append(\"D\")\n\n        # Sorts the data to the new output size\n        if data_out_gab[-1] == \"D\":\n            data_ord.append(data[cont_data])\n            cont_data += 1\n        else:\n            data_ord.append(None)\n\n    # Calculates parity\n    qtd_bp = 0  # parity bit counter\n    for bp in range(1, size_par + 1):\n        # Bit counter one for a given parity\n        cont_bo = 0\n        # counter to control the loop reading\n        for cont_loop, x in enumerate(data_ord):\n            if x is not None:\n                try:\n                    aux = (bin_pos[cont_loop])[-1 * (bp)]\n                except IndexError:\n                    aux = \"0\"\n                if aux == \"1\" and x == \"1\":\n                    cont_bo += 1\n        parity.append(cont_bo % 2)\n\n        qtd_bp += 1\n\n    # Mount the message\n    cont_bp = 0  # parity bit counter\n    for x in range(size_par + len(data)):\n        if data_ord[x] is None:\n            data_out.append(str(parity[cont_bp]))\n            cont_bp += 1\n        else:\n            data_out.append(data_ord[x])\n\n    return data_out",
    "docstring": ":param size_par: how many parity bits the message must have\n:param data:  information bits\n:return: message to be transmitted by unreliable medium\n        - bits of information merged with parity bits\n\n>>> emitter_converter(4, \"101010111111\")\n['1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1']\n>>> emitter_converter(5, \"101010111111\")\nTraceback (most recent call last):\n    ...\nValueError: size of parity don't match with size of data"
  },
  {
    "function": "receptor_converter",
    "code": "def receptor_converter(size_par, data):\n    \"\"\"\n    >>> receptor_converter(4, \"1111010010111111\")\n    (['1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1'], True)\n    \"\"\"\n    # data position template + parity\n    data_out_gab = []\n    # Parity bit counter\n    qtd_bp = 0\n    # Counter p data bit reading\n    cont_data = 0\n    # list of parity received\n    parity_received = []\n    data_output = []\n\n    for i, item in enumerate(data, 1):\n        # Performs a template of bit positions - who should be given,\n        #  and who should be parity\n        if qtd_bp < size_par and (np.log(i) / np.log(2)).is_integer():\n            data_out_gab.append(\"P\")\n            qtd_bp = qtd_bp + 1\n        else:\n            data_out_gab.append(\"D\")\n\n        # Sorts the data to the new output size\n        if data_out_gab[-1] == \"D\":\n            data_output.append(item)\n        else:\n            parity_received.append(item)\n\n    # -----------calculates the parity with the data\n    data_out = []\n    parity = []\n    bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data_output) + 1)]\n\n    #  sorted information data for the size of the output data\n    data_ord = []\n    # Data position feedback + parity\n    data_out_gab = []\n    # Parity bit counter\n    qtd_bp = 0\n    # Counter p data bit reading\n    cont_data = 0\n\n    for x in range(1, size_par + len(data_output) + 1):\n        # Performs a template position of bits - who should be given,\n        # and who should be parity\n        if qtd_bp < size_par and (np.log(x) / np.log(2)).is_integer():\n            data_out_gab.append(\"P\")\n            qtd_bp = qtd_bp + 1\n        else:\n            data_out_gab.append(\"D\")\n\n        # Sorts the data to the new output size\n        if data_out_gab[-1] == \"D\":\n            data_ord.append(data_output[cont_data])\n            cont_data += 1\n        else:\n            data_ord.append(None)\n\n    # Calculates parity\n    qtd_bp = 0  # parity bit counter\n    for bp in range(1, size_par + 1):\n        # Bit counter one for a certain parity\n        cont_bo = 0\n        for cont_loop, x in enumerate(data_ord):\n            if x is not None:\n                try:\n                    aux = (bin_pos[cont_loop])[-1 * (bp)]\n                except IndexError:\n                    aux = \"0\"\n                if aux == \"1\" and x == \"1\":\n                    cont_bo += 1\n        parity.append(str(cont_bo % 2))\n\n        qtd_bp += 1\n\n    # Mount the message\n    cont_bp = 0  # Parity bit counter\n    for x in range(size_par + len(data_output)):\n        if data_ord[x] is None:\n            data_out.append(str(parity[cont_bp]))\n            cont_bp += 1\n        else:\n            data_out.append(data_ord[x])\n\n    ack = parity_received == parity\n    return data_output, ack",
    "docstring": ">>> receptor_converter(4, \"1111010010111111\")\n(['1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1'], True)"
  },
  {
    "function": "is_luhn",
    "code": "def is_luhn(string: str) -> bool:\n    \"\"\"\n    Perform Luhn validation on an input string\n    Algorithm:\n    * Double every other digit starting from 2nd last digit.\n    * Subtract 9 if number is greater than 9.\n    * Sum the numbers\n    *\n    >>> test_cases = (79927398710, 79927398711, 79927398712, 79927398713,\n    ...     79927398714, 79927398715, 79927398716, 79927398717, 79927398718,\n    ...     79927398719)\n    >>> [is_luhn(str(test_case)) for test_case in test_cases]\n    [False, False, False, True, False, False, False, False, False, False]\n    \"\"\"\n    check_digit: int\n    _vector: list[str] = list(string)\n    __vector, check_digit = _vector[:-1], int(_vector[-1])\n    vector: list[int] = [int(digit) for digit in __vector]\n\n    vector.reverse()\n    for i, digit in enumerate(vector):\n        if i & 1 == 0:\n            doubled: int = digit * 2\n            if doubled > 9:\n                doubled -= 9\n            check_digit += doubled\n        else:\n            check_digit += digit\n\n    return check_digit % 10 == 0",
    "docstring": "Perform Luhn validation on an input string\nAlgorithm:\n* Double every other digit starting from 2nd last digit.\n* Subtract 9 if number is greater than 9.\n* Sum the numbers\n*\n>>> test_cases = (79927398710, 79927398711, 79927398712, 79927398713,\n...     79927398714, 79927398715, 79927398716, 79927398717, 79927398718,\n...     79927398719)\n>>> [is_luhn(str(test_case)) for test_case in test_cases]\n[False, False, False, True, False, False, False, False, False, False]"
  },
  {
    "function": "to_little_endian",
    "code": "def to_little_endian(string_32: bytes) -> bytes:\n    \"\"\"\n    Converts the given string to little-endian in groups of 8 chars.\n\n    Arguments:\n        string_32 {[string]} -- [32-char string]\n\n    Raises:\n        ValueError -- [input is not 32 char]\n\n    Returns:\n        32-char little-endian string\n    >>> to_little_endian(b'1234567890abcdfghijklmnopqrstuvw')\n    b'pqrstuvwhijklmno90abcdfg12345678'\n    >>> to_little_endian(b'1234567890')\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be of length 32\n    \"\"\"\n    if len(string_32) != 32:\n        raise ValueError(\"Input must be of length 32\")\n\n    little_endian = b\"\"\n    for i in [3, 2, 1, 0]:\n        little_endian += string_32[8 * i : 8 * i + 8]\n    return little_endian",
    "docstring": "Converts the given string to little-endian in groups of 8 chars.\n\nArguments:\n    string_32 {[string]} -- [32-char string]\n\nRaises:\n    ValueError -- [input is not 32 char]\n\nReturns:\n    32-char little-endian string\n>>> to_little_endian(b'1234567890abcdfghijklmnopqrstuvw')\nb'pqrstuvwhijklmno90abcdfg12345678'\n>>> to_little_endian(b'1234567890')\nTraceback (most recent call last):\n...\nValueError: Input must be of length 32"
  },
  {
    "function": "reformat_hex",
    "code": "def reformat_hex(i: int) -> bytes:\n    \"\"\"\n    Converts the given non-negative integer to hex string.\n\n    Example: Suppose the input is the following:\n        i = 1234\n\n        The input is 0x000004d2 in hex, so the little-endian hex string is\n        \"d2040000\".\n\n    Arguments:\n        i {[int]} -- [integer]\n\n    Raises:\n        ValueError -- [input is negative]\n\n    Returns:\n        8-char little-endian hex string\n\n    >>> reformat_hex(1234)\n    b'd2040000'\n    >>> reformat_hex(666)\n    b'9a020000'\n    >>> reformat_hex(0)\n    b'00000000'\n    >>> reformat_hex(1234567890)\n    b'd2029649'\n    >>> reformat_hex(1234567890987654321)\n    b'b11c6cb1'\n    >>> reformat_hex(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be non-negative\n    \"\"\"\n    if i < 0:\n        raise ValueError(\"Input must be non-negative\")\n\n    hex_rep = format(i, \"08x\")[-8:]\n    little_endian_hex = b\"\"\n    for j in [3, 2, 1, 0]:\n        little_endian_hex += hex_rep[2 * j : 2 * j + 2].encode(\"utf-8\")\n    return little_endian_hex",
    "docstring": "Converts the given non-negative integer to hex string.\n\nExample: Suppose the input is the following:\n    i = 1234\n\n    The input is 0x000004d2 in hex, so the little-endian hex string is\n    \"d2040000\".\n\nArguments:\n    i {[int]} -- [integer]\n\nRaises:\n    ValueError -- [input is negative]\n\nReturns:\n    8-char little-endian hex string\n\n>>> reformat_hex(1234)\nb'd2040000'\n>>> reformat_hex(666)\nb'9a020000'\n>>> reformat_hex(0)\nb'00000000'\n>>> reformat_hex(1234567890)\nb'd2029649'\n>>> reformat_hex(1234567890987654321)\nb'b11c6cb1'\n>>> reformat_hex(-1)\nTraceback (most recent call last):\n...\nValueError: Input must be non-negative"
  },
  {
    "function": "preprocess",
    "code": "def preprocess(message: bytes) -> bytes:\n    \"\"\"\n    Preprocesses the message string:\n    - Convert message to bit string\n    - Pad bit string to a multiple of 512 chars:\n        - Append a 1\n        - Append 0's until length = 448 (mod 512)\n        - Append length of original message (64 chars)\n\n    Example: Suppose the input is the following:\n        message = \"a\"\n\n        The message bit string is \"01100001\", which is 8 bits long. Thus, the\n        bit string needs 439 bits of padding so that\n        (bit_string + \"1\" + padding) = 448 (mod 512).\n        The message length is \"000010000...0\" in 64-bit little-endian binary.\n        The combined bit string is then 512 bits long.\n\n    Arguments:\n        message {[string]} -- [message string]\n\n    Returns:\n        processed bit string padded to a multiple of 512 chars\n\n    >>> preprocess(b\"a\") == (b\"01100001\" + b\"1\" +\n    ...                     (b\"0\" * 439) + b\"00001000\" + (b\"0\" * 56))\n    True\n    >>> preprocess(b\"\") == b\"1\" + (b\"0\" * 447) + (b\"0\" * 64)\n    True\n    \"\"\"\n    bit_string = b\"\"\n    for char in message:\n        bit_string += format(char, \"08b\").encode(\"utf-8\")\n    start_len = format(len(bit_string), \"064b\").encode(\"utf-8\")\n\n    # Pad bit_string to a multiple of 512 chars\n    bit_string += b\"1\"\n    while len(bit_string) % 512 != 448:\n        bit_string += b\"0\"\n    bit_string += to_little_endian(start_len[32:]) + to_little_endian(start_len[:32])\n\n    return bit_string",
    "docstring": "Preprocesses the message string:\n- Convert message to bit string\n- Pad bit string to a multiple of 512 chars:\n    - Append a 1\n    - Append 0's until length = 448 (mod 512)\n    - Append length of original message (64 chars)\n\nExample: Suppose the input is the following:\n    message = \"a\"\n\n    The message bit string is \"01100001\", which is 8 bits long. Thus, the\n    bit string needs 439 bits of padding so that\n    (bit_string + \"1\" + padding) = 448 (mod 512).\n    The message length is \"000010000...0\" in 64-bit little-endian binary.\n    The combined bit string is then 512 bits long.\n\nArguments:\n    message {[string]} -- [message string]\n\nReturns:\n    processed bit string padded to a multiple of 512 chars\n\n>>> preprocess(b\"a\") == (b\"01100001\" + b\"1\" +\n...                     (b\"0\" * 439) + b\"00001000\" + (b\"0\" * 56))\nTrue\n>>> preprocess(b\"\") == b\"1\" + (b\"0\" * 447) + (b\"0\" * 64)\nTrue"
  },
  {
    "function": "get_block_words",
    "code": "def get_block_words(bit_string: bytes) -> Generator[list[int]]:\n    \"\"\"\n    Splits bit string into blocks of 512 chars and yields each block as a list\n    of 32-bit words\n\n    Example: Suppose the input is the following:\n        bit_string =\n            \"000000000...0\" +  # 0x00 (32 bits, padded to the right)\n            \"000000010...0\" +  # 0x01 (32 bits, padded to the right)\n            \"000000100...0\" +  # 0x02 (32 bits, padded to the right)\n            \"000000110...0\" +  # 0x03 (32 bits, padded to the right)\n            ...\n            \"000011110...0\"    # 0x0a (32 bits, padded to the right)\n\n        Then len(bit_string) == 512, so there'll be 1 block. The block is split\n        into 32-bit words, and each word is converted to little endian. The\n        first word is interpreted as 0 in decimal, the second word is\n        interpreted as 1 in decimal, etc.\n\n        Thus, block_words == [[0, 1, 2, 3, ..., 15]].\n\n    Arguments:\n        bit_string {[string]} -- [bit string with multiple of 512 as length]\n\n    Raises:\n        ValueError -- [length of bit string isn't multiple of 512]\n\n    Yields:\n        a list of 16 32-bit words\n\n    >>> test_string = (\"\".join(format(n << 24, \"032b\") for n in range(16))\n    ...                  .encode(\"utf-8\"))\n    >>> list(get_block_words(test_string))\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]]\n    >>> list(get_block_words(test_string * 4)) == [list(range(16))] * 4\n    True\n    >>> list(get_block_words(b\"1\" * 512)) == [[4294967295] * 16]\n    True\n    >>> list(get_block_words(b\"\"))\n    []\n    >>> list(get_block_words(b\"1111\"))\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must have length that's a multiple of 512\n    \"\"\"\n    if len(bit_string) % 512 != 0:\n        raise ValueError(\"Input must have length that's a multiple of 512\")\n\n    for pos in range(0, len(bit_string), 512):\n        block = bit_string[pos : pos + 512]\n        block_words = []\n        for i in range(0, 512, 32):\n            block_words.append(int(to_little_endian(block[i : i + 32]), 2))\n        yield block_words",
    "docstring": "Splits bit string into blocks of 512 chars and yields each block as a list\nof 32-bit words\n\nExample: Suppose the input is the following:\n    bit_string =\n        \"000000000...0\" +  # 0x00 (32 bits, padded to the right)\n        \"000000010...0\" +  # 0x01 (32 bits, padded to the right)\n        \"000000100...0\" +  # 0x02 (32 bits, padded to the right)\n        \"000000110...0\" +  # 0x03 (32 bits, padded to the right)\n        ...\n        \"000011110...0\"    # 0x0a (32 bits, padded to the right)\n\n    Then len(bit_string) == 512, so there'll be 1 block. The block is split\n    into 32-bit words, and each word is converted to little endian. The\n    first word is interpreted as 0 in decimal, the second word is\n    interpreted as 1 in decimal, etc.\n\n    Thus, block_words == [[0, 1, 2, 3, ..., 15]].\n\nArguments:\n    bit_string {[string]} -- [bit string with multiple of 512 as length]\n\nRaises:\n    ValueError -- [length of bit string isn't multiple of 512]\n\nYields:\n    a list of 16 32-bit words\n\n>>> test_string = (\"\".join(format(n << 24, \"032b\") for n in range(16))\n...                  .encode(\"utf-8\"))\n>>> list(get_block_words(test_string))\n[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]]\n>>> list(get_block_words(test_string * 4)) == [list(range(16))] * 4\nTrue\n>>> list(get_block_words(b\"1\" * 512)) == [[4294967295] * 16]\nTrue\n>>> list(get_block_words(b\"\"))\n[]\n>>> list(get_block_words(b\"1111\"))\nTraceback (most recent call last):\n...\nValueError: Input must have length that's a multiple of 512"
  },
  {
    "function": "not_32",
    "code": "def not_32(i: int) -> int:\n    \"\"\"\n    Perform bitwise NOT on given int.\n\n    Arguments:\n        i {[int]} -- [given int]\n\n    Raises:\n        ValueError -- [input is negative]\n\n    Returns:\n        Result of bitwise NOT on i\n\n    >>> not_32(34)\n    4294967261\n    >>> not_32(1234)\n    4294966061\n    >>> not_32(4294966061)\n    1234\n    >>> not_32(0)\n    4294967295\n    >>> not_32(1)\n    4294967294\n    >>> not_32(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be non-negative\n    \"\"\"\n    if i < 0:\n        raise ValueError(\"Input must be non-negative\")\n\n    i_str = format(i, \"032b\")\n    new_str = \"\"\n    for c in i_str:\n        new_str += \"1\" if c == \"0\" else \"0\"\n    return int(new_str, 2)",
    "docstring": "Perform bitwise NOT on given int.\n\nArguments:\n    i {[int]} -- [given int]\n\nRaises:\n    ValueError -- [input is negative]\n\nReturns:\n    Result of bitwise NOT on i\n\n>>> not_32(34)\n4294967261\n>>> not_32(1234)\n4294966061\n>>> not_32(4294966061)\n1234\n>>> not_32(0)\n4294967295\n>>> not_32(1)\n4294967294\n>>> not_32(-1)\nTraceback (most recent call last):\n...\nValueError: Input must be non-negative"
  },
  {
    "function": "sum_32",
    "code": "def sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32",
    "docstring": "Add two numbers as 32-bit ints.\n\nArguments:\n    a {[int]} -- [first given int]\n    b {[int]} -- [second given int]\n\nReturns:\n    (a + b) as an unsigned 32-bit int\n\n>>> sum_32(1, 1)\n2\n>>> sum_32(2, 3)\n5\n>>> sum_32(0, 0)\n0\n>>> sum_32(-1, -1)\n4294967294\n>>> sum_32(4294967295, 1)\n0"
  },
  {
    "function": "left_rotate_32",
    "code": "def left_rotate_32(i: int, shift: int) -> int:\n    \"\"\"\n    Rotate the bits of a given int left by a given amount.\n\n    Arguments:\n        i {[int]} -- [given int]\n        shift {[int]} -- [shift amount]\n\n    Raises:\n        ValueError -- [either given int or shift is negative]\n\n    Returns:\n        `i` rotated to the left by `shift` bits\n\n    >>> left_rotate_32(1234, 1)\n    2468\n    >>> left_rotate_32(1111, 4)\n    17776\n    >>> left_rotate_32(2147483648, 1)\n    1\n    >>> left_rotate_32(2147483648, 3)\n    4\n    >>> left_rotate_32(4294967295, 4)\n    4294967295\n    >>> left_rotate_32(1234, 0)\n    1234\n    >>> left_rotate_32(0, 0)\n    0\n    >>> left_rotate_32(-1, 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be non-negative\n    >>> left_rotate_32(0, -1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Shift must be non-negative\n    \"\"\"\n    if i < 0:\n        raise ValueError(\"Input must be non-negative\")\n    if shift < 0:\n        raise ValueError(\"Shift must be non-negative\")\n    return ((i << shift) ^ (i >> (32 - shift))) % 2**32",
    "docstring": "Rotate the bits of a given int left by a given amount.\n\nArguments:\n    i {[int]} -- [given int]\n    shift {[int]} -- [shift amount]\n\nRaises:\n    ValueError -- [either given int or shift is negative]\n\nReturns:\n    `i` rotated to the left by `shift` bits\n\n>>> left_rotate_32(1234, 1)\n2468\n>>> left_rotate_32(1111, 4)\n17776\n>>> left_rotate_32(2147483648, 1)\n1\n>>> left_rotate_32(2147483648, 3)\n4\n>>> left_rotate_32(4294967295, 4)\n4294967295\n>>> left_rotate_32(1234, 0)\n1234\n>>> left_rotate_32(0, 0)\n0\n>>> left_rotate_32(-1, 0)\nTraceback (most recent call last):\n...\nValueError: Input must be non-negative\n>>> left_rotate_32(0, -1)\nTraceback (most recent call last):\n...\nValueError: Shift must be non-negative"
  },
  {
    "function": "md5_me",
    "code": "def md5_me(message: bytes) -> bytes:\n    \"\"\"\n    Returns the 32-char MD5 hash of a given message.\n\n    Reference: https://en.wikipedia.org/wiki/MD5#Algorithm\n\n    Arguments:\n        message {[string]} -- [message]\n\n    Returns:\n        32-char MD5 hash string\n\n    >>> md5_me(b\"\")\n    b'd41d8cd98f00b204e9800998ecf8427e'\n    >>> md5_me(b\"The quick brown fox jumps over the lazy dog\")\n    b'9e107d9d372bb6826bd81d3542a419d6'\n    >>> md5_me(b\"The quick brown fox jumps over the lazy dog.\")\n    b'e4d909c290d0fb1ca068ffaddf22cbd0'\n\n    >>> import hashlib\n    >>> from string import ascii_letters\n    >>> msgs = [b\"\", ascii_letters.encode(\"utf-8\"), \"\u00dc\u00f1\u00ee\u00e7\u00f8\u2202\u00e9\".encode(\"utf-8\"),\n    ...         b\"The quick brown fox jumps over the lazy dog.\"]\n    >>> all(md5_me(msg) == hashlib.md5(msg).hexdigest().encode(\"utf-8\") for msg in msgs)\n    True\n    \"\"\"\n\n    # Convert to bit string, add padding and append message length\n    bit_string = preprocess(message)\n\n    added_consts = [int(2**32 * abs(sin(i + 1))) for i in range(64)]\n\n    # Starting states\n    a0 = 0x67452301\n    b0 = 0xEFCDAB89\n    c0 = 0x98BADCFE\n    d0 = 0x10325476\n\n    shift_amounts = [\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21,\n    ]\n\n    # Process bit string in chunks, each with 16 32-char words\n    for block_words in get_block_words(bit_string):\n        a = a0\n        b = b0\n        c = c0\n        d = d0\n\n        # Hash current chunk\n        for i in range(64):\n            if i <= 15:\n                # f = (b & c) | (not_32(b) & d)     # Alternate definition for f\n                f = d ^ (b & (c ^ d))\n                g = i\n            elif i <= 31:\n                # f = (d & b) | (not_32(d) & c)     # Alternate definition for f\n                f = c ^ (d & (b ^ c))\n                g = (5 * i + 1) % 16\n            elif i <= 47:\n                f = b ^ c ^ d\n                g = (3 * i + 5) % 16\n            else:\n                f = c ^ (b | not_32(d))\n                g = (7 * i) % 16\n            f = (f + a + added_consts[i] + block_words[g]) % 2**32\n            a = d\n            d = c\n            c = b\n            b = sum_32(b, left_rotate_32(f, shift_amounts[i]))\n\n        # Add hashed chunk to running total\n        a0 = sum_32(a0, a)\n        b0 = sum_32(b0, b)\n        c0 = sum_32(c0, c)\n        d0 = sum_32(d0, d)\n\n    digest = reformat_hex(a0) + reformat_hex(b0) + reformat_hex(c0) + reformat_hex(d0)\n    return digest",
    "docstring": "Returns the 32-char MD5 hash of a given message.\n\nReference: https://en.wikipedia.org/wiki/MD5#Algorithm\n\nArguments:\n    message {[string]} -- [message]\n\nReturns:\n    32-char MD5 hash string\n\n>>> md5_me(b\"\")\nb'd41d8cd98f00b204e9800998ecf8427e'\n>>> md5_me(b\"The quick brown fox jumps over the lazy dog\")\nb'9e107d9d372bb6826bd81d3542a419d6'\n>>> md5_me(b\"The quick brown fox jumps over the lazy dog.\")\nb'e4d909c290d0fb1ca068ffaddf22cbd0'\n\n>>> import hashlib\n>>> from string import ascii_letters\n>>> msgs = [b\"\", ascii_letters.encode(\"utf-8\"), \"\u00dc\u00f1\u00ee\u00e7\u00f8\u2202\u00e9\".encode(\"utf-8\"),\n...         b\"The quick brown fox jumps over the lazy dog.\"]\n>>> all(md5_me(msg) == hashlib.md5(msg).hexdigest().encode(\"utf-8\") for msg in msgs)\nTrue"
  },
  {
    "function": "sdbm",
    "code": "def sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value",
    "docstring": "Function implements sdbm hash, easy to use, great for bits scrambling.\niterates over each character in the given string and applies function to each of\nthem.\n\n>>> sdbm('Algorithms')\n1462174910723540325254304520539387479031000036\n\n>>> sdbm('scramble bits')\n730247649148944819640658295400555317318720608290373040936089"
  },
  {
    "function": "main",
    "code": "def main():\n    \"\"\"\n    Provides option 'string' or 'file' to take input and prints the calculated SHA1\n    hash. unittest.main() has been commented out because we probably don't want to run\n    the test each time.\n    \"\"\"\n    # unittest.main()\n    parser = argparse.ArgumentParser(description=\"Process some strings or files\")\n    parser.add_argument(\n        \"--string\",\n        dest=\"input_string\",\n        default=\"Hello World!! Welcome to Cryptography\",\n        help=\"Hash the string\",\n    )\n    parser.add_argument(\"--file\", dest=\"input_file\", help=\"Hash contents of a file\")\n    args = parser.parse_args()\n    input_string = args.input_string\n    # In any case hash input should be a bytestring\n    if args.input_file:\n        with open(args.input_file, \"rb\") as f:\n            hash_input = f.read()\n    else:\n        hash_input = bytes(input_string, \"utf-8\")\n    print(SHA1Hash(hash_input).final_hash())",
    "docstring": "Provides option 'string' or 'file' to take input and prints the calculated SHA1\nhash. unittest.main() has been commented out because we probably don't want to run\nthe test each time."
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Provides option 'string' or 'file' to take input\n    and prints the calculated SHA-256 hash\n    \"\"\"\n\n    # unittest.main()\n\n    import doctest\n\n    doctest.testmod()\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-s\",\n        \"--string\",\n        dest=\"input_string\",\n        default=\"Hello World!! Welcome to Cryptography\",\n        help=\"Hash the string\",\n    )\n    parser.add_argument(\n        \"-f\", \"--file\", dest=\"input_file\", help=\"Hash contents of a file\"\n    )\n\n    args = parser.parse_args()\n\n    input_string = args.input_string\n\n    # hash input should be a bytestring\n    if args.input_file:\n        with open(args.input_file, \"rb\") as f:\n            hash_input = f.read()\n    else:\n        hash_input = bytes(input_string, \"utf-8\")\n\n    print(SHA256(hash_input).hash)",
    "docstring": "Provides option 'string' or 'file' to take input\nand prints the calculated SHA-256 hash"
  },
  {
    "function": "calc_profit",
    "code": "def calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain",
    "docstring": "Function description is as follows-\n:param profit: Take a list of profits\n:param weight: Take a list of weight if bags corresponding to the profits\n:param max_weight: Maximum weight that could be carried\n:return: Maximum expected gain\n\n>>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n6\n>>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n27"
  },
  {
    "function": "knapsack",
    "code": "def knapsack(\n    capacity: int,\n    weights: list[int],\n    values: list[int],\n    counter: int,\n    allow_repetition=False,\n) -> int:\n    \"\"\"\n    Returns the maximum value that can be put in a knapsack of a capacity cap,\n    whereby each weight w has a specific value val\n    with option to allow repetitive selection of items\n\n    >>> cap = 50\n    >>> val = [60, 100, 120]\n    >>> w = [10, 20, 30]\n    >>> c = len(val)\n    >>> knapsack(cap, w, val, c)\n    220\n\n    Given the repetition is NOT allowed,\n    the result is 220 cause the values of 100 and 120 got the weight of 50\n    which is the limit of the capacity.\n    >>> knapsack(cap, w, val, c, True)\n    300\n\n    Given the repetition is allowed,\n    the result is 300 cause the values of 60*5 (pick 5 times)\n    got the weight of 10*5 which is the limit of the capacity.\n    \"\"\"\n\n    @lru_cache\n    def knapsack_recur(capacity: int, counter: int) -> int:\n        # Base Case\n        if counter == 0 or capacity == 0:\n            return 0\n\n        # If weight of the nth item is more than Knapsack of capacity,\n        #   then this item cannot be included in the optimal solution,\n        # else return the maximum of two cases:\n        #   (1) nth item included only once (0-1), if allow_repetition is False\n        #       nth item included one or more times (0-N), if allow_repetition is True\n        #   (2) not included\n        if weights[counter - 1] > capacity:\n            return knapsack_recur(capacity, counter - 1)\n        else:\n            left_capacity = capacity - weights[counter - 1]\n            new_value_included = values[counter - 1] + knapsack_recur(\n                left_capacity, counter - 1 if not allow_repetition else counter\n            )\n            without_new_value = knapsack_recur(capacity, counter - 1)\n            return max(new_value_included, without_new_value)\n\n    return knapsack_recur(capacity, counter)",
    "docstring": "Returns the maximum value that can be put in a knapsack of a capacity cap,\nwhereby each weight w has a specific value val\nwith option to allow repetitive selection of items\n\n>>> cap = 50\n>>> val = [60, 100, 120]\n>>> w = [10, 20, 30]\n>>> c = len(val)\n>>> knapsack(cap, w, val, c)\n220\n\nGiven the repetition is NOT allowed,\nthe result is 220 cause the values of 100 and 120 got the weight of 50\nwhich is the limit of the capacity.\n>>> knapsack(cap, w, val, c, True)\n300\n\nGiven the repetition is allowed,\nthe result is 300 cause the values of 60*5 (pick 5 times)\ngot the weight of 10*5 which is the limit of the capacity."
  },
  {
    "function": "knapsack",
    "code": "def knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)",
    "docstring": "Function description is as follows-\n:param weights: Take a list of weights\n:param values: Take a list of profits corresponding to the weights\n:param number_of_items: number of items available to pick from\n:param max_weight: Maximum weight that could be carried\n:param index: the element we are looking at\n:return: Maximum expected gain\n>>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n13\n>>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n27"
  },
  {
    "function": "retroactive_resolution",
    "code": "def retroactive_resolution(\n    coefficients: NDArray[float64], vector: NDArray[float64]\n) -> NDArray[float64]:\n    \"\"\"\n    This function performs a retroactive linear system resolution\n    for triangular matrix\n\n    Examples:\n        1.\n            * 2x1 + 2x2 - 1x3 = 5\n            * 0x1 - 2x2 - 1x3 = -7\n            * 0x1 + 0x2 + 5x3 = 15\n        2.\n            * 2x1 + 2x2 = -1\n            * 0x1 - 2x2 = -1\n\n    >>> gaussian_elimination([[2, 2, -1], [0, -2, -1], [0, 0, 5]], [[5], [-7], [15]])\n    array([[2.],\n           [2.],\n           [3.]])\n    >>> gaussian_elimination([[2, 2], [0, -2]], [[-1], [-1]])\n    array([[-1. ],\n           [ 0.5]])\n    \"\"\"\n\n    rows, _columns = np.shape(coefficients)\n\n    x: NDArray[float64] = np.zeros((rows, 1), dtype=float)\n    for row in reversed(range(rows)):\n        total = np.dot(coefficients[row, row + 1 :], x[row + 1 :])\n        x[row, 0] = (vector[row][0] - total[0]) / coefficients[row, row]\n\n    return x",
    "docstring": "This function performs a retroactive linear system resolution\nfor triangular matrix\n\nExamples:\n    1.\n        * 2x1 + 2x2 - 1x3 = 5\n        * 0x1 - 2x2 - 1x3 = -7\n        * 0x1 + 0x2 + 5x3 = 15\n    2.\n        * 2x1 + 2x2 = -1\n        * 0x1 - 2x2 = -1\n\n>>> gaussian_elimination([[2, 2, -1], [0, -2, -1], [0, 0, 5]], [[5], [-7], [15]])\narray([[2.],\n       [2.],\n       [3.]])\n>>> gaussian_elimination([[2, 2], [0, -2]], [[-1], [-1]])\narray([[-1. ],\n       [ 0.5]])"
  },
  {
    "function": "gaussian_elimination",
    "code": "def gaussian_elimination(\n    coefficients: NDArray[float64], vector: NDArray[float64]\n) -> NDArray[float64]:\n    \"\"\"\n    This function performs Gaussian elimination method\n\n    Examples:\n        1.\n            * 1x1 - 4x2 - 2x3 = -2\n            * 5x1 + 2x2 - 2x3 = -3\n            * 1x1 - 1x2 + 0x3 = 4\n        2.\n            * 1x1 + 2x2 = 5\n            * 5x1 + 2x2 = 5\n\n    >>> gaussian_elimination([[1, -4, -2], [5, 2, -2], [1, -1, 0]], [[-2], [-3], [4]])\n    array([[ 2.3 ],\n           [-1.7 ],\n           [ 5.55]])\n    >>> gaussian_elimination([[1, 2], [5, 2]], [[5], [5]])\n    array([[0. ],\n           [2.5]])\n    \"\"\"\n    # coefficients must to be a square matrix so we need to check first\n    rows, columns = np.shape(coefficients)\n    if rows != columns:\n        return np.array((), dtype=float)\n\n    # augmented matrix\n    augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)\n    augmented_mat = augmented_mat.astype(\"float64\")\n\n    # scale the matrix leaving it triangular\n    for row in range(rows - 1):\n        pivot = augmented_mat[row, row]\n        for col in range(row + 1, columns):\n            factor = augmented_mat[col, row] / pivot\n            augmented_mat[col, :] -= factor * augmented_mat[row, :]\n\n    x = retroactive_resolution(\n        augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]\n    )\n\n    return x",
    "docstring": "This function performs Gaussian elimination method\n\nExamples:\n    1.\n        * 1x1 - 4x2 - 2x3 = -2\n        * 5x1 + 2x2 - 2x3 = -3\n        * 1x1 - 1x2 + 0x3 = 4\n    2.\n        * 1x1 + 2x2 = 5\n        * 5x1 + 2x2 = 5\n\n>>> gaussian_elimination([[1, -4, -2], [5, 2, -2], [1, -1, 0]], [[-2], [-3], [4]])\narray([[ 2.3 ],\n       [-1.7 ],\n       [ 5.55]])\n>>> gaussian_elimination([[1, 2], [5, 2]], [[5], [5]])\narray([[0. ],\n       [2.5]])"
  },
  {
    "function": "jacobi_iteration_method",
    "code": "def jacobi_iteration_method(\n    coefficient_matrix: NDArray[float64],\n    constant_matrix: NDArray[float64],\n    init_val: list[float],\n    iterations: int,\n) -> list[float]:\n    \"\"\"\n    Jacobi Iteration Method:\n    An iterative algorithm to determine the solutions of strictly diagonally dominant\n    system of linear equations\n\n    4x1 +  x2 +  x3 =  2\n     x1 + 5x2 + 2x3 = -6\n     x1 + 2x2 + 4x3 = -4\n\n    x_init = [0.5, -0.5 , -0.5]\n\n    Examples:\n\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n    >>> constant = np.array([[2], [-6], [-4]])\n    >>> init_val = [0.5, -0.5, -0.5]\n    >>> iterations = 3\n    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\n    [0.909375, -1.14375, -0.7484375]\n\n\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2]])\n    >>> constant = np.array([[2], [-6], [-4]])\n    >>> init_val = [0.5, -0.5, -0.5]\n    >>> iterations = 3\n    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\n    Traceback (most recent call last):\n        ...\n    ValueError: Coefficient matrix dimensions must be nxn but received 2x3\n\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n    >>> constant = np.array([[2], [-6]])\n    >>> init_val = [0.5, -0.5, -0.5]\n    >>> iterations = 3\n    >>> jacobi_iteration_method(\n    ...     coefficient, constant, init_val, iterations\n    ... )  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Coefficient and constant matrices dimensions must be nxn and nx1 but\n                received 3x3 and 2x1\n\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n    >>> constant = np.array([[2], [-6], [-4]])\n    >>> init_val = [0.5, -0.5]\n    >>> iterations = 3\n    >>> jacobi_iteration_method(\n    ...     coefficient, constant, init_val, iterations\n    ... )  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Number of initial values must be equal to number of rows in coefficient\n                matrix but received 2 and 3\n\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n    >>> constant = np.array([[2], [-6], [-4]])\n    >>> init_val = [0.5, -0.5, -0.5]\n    >>> iterations = 0\n    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\n    Traceback (most recent call last):\n        ...\n    ValueError: Iterations must be at least 1\n    \"\"\"\n\n    rows1, cols1 = coefficient_matrix.shape\n    rows2, cols2 = constant_matrix.shape\n\n    if rows1 != cols1:\n        msg = f\"Coefficient matrix dimensions must be nxn but received {rows1}x{cols1}\"\n        raise ValueError(msg)\n\n    if cols2 != 1:\n        msg = f\"Constant matrix must be nx1 but received {rows2}x{cols2}\"\n        raise ValueError(msg)\n\n    if rows1 != rows2:\n        msg = (\n            \"Coefficient and constant matrices dimensions must be nxn and nx1 but \"\n            f\"received {rows1}x{cols1} and {rows2}x{cols2}\"\n        )\n        raise ValueError(msg)\n\n    if len(init_val) != rows1:\n        msg = (\n            \"Number of initial values must be equal to number of rows in coefficient \"\n            f\"matrix but received {len(init_val)} and {rows1}\"\n        )\n        raise ValueError(msg)\n\n    if iterations <= 0:\n        raise ValueError(\"Iterations must be at least 1\")\n\n    table: NDArray[float64] = np.concatenate(\n        (coefficient_matrix, constant_matrix), axis=1\n    )\n\n    rows, _cols = table.shape\n\n    strictly_diagonally_dominant(table)\n\n    \"\"\"\n    # Iterates the whole matrix for given number of times\n    for _ in range(iterations):\n        new_val = []\n        for row in range(rows):\n            temp = 0\n            for col in range(cols):\n                if col == row:\n                    denom = table[row][col]\n                elif col == cols - 1:\n                    val = table[row][col]\n                else:\n                    temp += (-1) * table[row][col] * init_val[col]\n            temp = (temp + val) / denom\n            new_val.append(temp)\n        init_val = new_val\n    \"\"\"\n\n    # denominator - a list of values along the diagonal\n    denominator = np.diag(coefficient_matrix)\n\n    # val_last - values of the last column of the table array\n    val_last = table[:, -1]\n\n    # masks - boolean mask of all strings without diagonal\n    # elements array coefficient_matrix\n    masks = ~np.eye(coefficient_matrix.shape[0], dtype=bool)\n\n    # no_diagonals - coefficient_matrix array values without diagonal elements\n    no_diagonals = coefficient_matrix[masks].reshape(-1, rows - 1)\n\n    # Here we get 'i_col' - these are the column numbers, for each row\n    # without diagonal elements, except for the last column.\n    _i_row, i_col = np.where(masks)\n    ind = i_col.reshape(-1, rows - 1)\n\n    #'i_col' is converted to a two-dimensional list 'ind', which will be\n    # used to make selections from 'init_val' ('arr' array see below).\n\n    # Iterates the whole matrix for given number of times\n    for _ in range(iterations):\n        arr = np.take(init_val, ind)\n        sum_product_rows = np.sum((-1) * no_diagonals * arr, axis=1)\n        new_val = (sum_product_rows + val_last) / denominator\n        init_val = new_val\n\n    return new_val.tolist()",
    "docstring": "Jacobi Iteration Method:\nAn iterative algorithm to determine the solutions of strictly diagonally dominant\nsystem of linear equations\n\n4x1 +  x2 +  x3 =  2\n x1 + 5x2 + 2x3 = -6\n x1 + 2x2 + 4x3 = -4\n\nx_init = [0.5, -0.5 , -0.5]\n\nExamples:\n\n>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n>>> constant = np.array([[2], [-6], [-4]])\n>>> init_val = [0.5, -0.5, -0.5]\n>>> iterations = 3\n>>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\n[0.909375, -1.14375, -0.7484375]\n\n\n>>> coefficient = np.array([[4, 1, 1], [1, 5, 2]])\n>>> constant = np.array([[2], [-6], [-4]])\n>>> init_val = [0.5, -0.5, -0.5]\n>>> iterations = 3\n>>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\nTraceback (most recent call last):\n    ...\nValueError: Coefficient matrix dimensions must be nxn but received 2x3\n\n>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n>>> constant = np.array([[2], [-6]])\n>>> init_val = [0.5, -0.5, -0.5]\n>>> iterations = 3\n>>> jacobi_iteration_method(\n...     coefficient, constant, init_val, iterations\n... )  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: Coefficient and constant matrices dimensions must be nxn and nx1 but\n            received 3x3 and 2x1\n\n>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n>>> constant = np.array([[2], [-6], [-4]])\n>>> init_val = [0.5, -0.5]\n>>> iterations = 3\n>>> jacobi_iteration_method(\n...     coefficient, constant, init_val, iterations\n... )  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: Number of initial values must be equal to number of rows in coefficient\n            matrix but received 2 and 3\n\n>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n>>> constant = np.array([[2], [-6], [-4]])\n>>> init_val = [0.5, -0.5, -0.5]\n>>> iterations = 0\n>>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\nTraceback (most recent call last):\n    ...\nValueError: Iterations must be at least 1"
  },
  {
    "function": "strictly_diagonally_dominant",
    "code": "def strictly_diagonally_dominant(table: NDArray[float64]) -> bool:\n    \"\"\"\n    >>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 4, -4]])\n    >>> strictly_diagonally_dominant(table)\n    True\n\n    >>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 3, -4]])\n    >>> strictly_diagonally_dominant(table)\n    Traceback (most recent call last):\n        ...\n    ValueError: Coefficient matrix is not strictly diagonally dominant\n    \"\"\"\n\n    rows, cols = table.shape\n\n    is_diagonally_dominant = True\n\n    for i in range(rows):\n        total = 0\n        for j in range(cols - 1):\n            if i == j:\n                continue\n            else:\n                total += table[i][j]\n\n        if table[i][i] <= total:\n            raise ValueError(\"Coefficient matrix is not strictly diagonally dominant\")\n\n    return is_diagonally_dominant",
    "docstring": ">>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 4, -4]])\n>>> strictly_diagonally_dominant(table)\nTrue\n\n>>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 3, -4]])\n>>> strictly_diagonally_dominant(table)\nTraceback (most recent call last):\n    ...\nValueError: Coefficient matrix is not strictly diagonally dominant"
  },
  {
    "function": "lower_upper_decomposition",
    "code": "def lower_upper_decomposition(table: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Perform LU decomposition on a given matrix and raises an error if the matrix\n    isn't square or if no such decomposition exists\n\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. , 0. ],\n           [0. , 1. , 0. ],\n           [2.5, 8. , 1. ]])\n    >>> upper_mat\n    array([[  2. ,  -2. ,   1. ],\n           [  0. ,   1. ,   2. ],\n           [  0. ,   0. , -17.5]])\n\n    >>> matrix = np.array([[4, 3], [6, 3]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. ],\n           [1.5, 1. ]])\n    >>> upper_mat\n    array([[ 4. ,  3. ],\n           [ 0. , -1.5]])\n\n    >>> # Matrix is not square\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'table' has to be of square shaped array but got a 2x3 array:\n    [[ 2 -2  1]\n     [ 0  1  2]]\n\n    >>> # Matrix is invertible, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n\n    >>> # Matrix is singular, but its first leading principal minor is 1\n    >>> matrix = np.array([[1, 0], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1., 0.],\n           [1., 1.]])\n    >>> upper_mat\n    array([[1., 0.],\n           [0., 0.]])\n\n    >>> # Matrix is singular, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [0, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n    \"\"\"\n    # Ensure that table is a square array\n    rows, columns = np.shape(table)\n    if rows != columns:\n        msg = (\n            \"'table' has to be of square shaped array but got a \"\n            f\"{rows}x{columns} array:\\n{table}\"\n        )\n        raise ValueError(msg)\n\n    lower = np.zeros((rows, columns))\n    upper = np.zeros((rows, columns))\n\n    # in 'total', the necessary data is extracted through slices\n    # and the sum of the products is obtained.\n\n    for i in range(columns):\n        for j in range(i):\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            if upper[j][j] == 0:\n                raise ArithmeticError(\"No LU decomposition exists\")\n            lower[i][j] = (table[i][j] - total) / upper[j][j]\n        lower[i][i] = 1\n        for j in range(i, columns):\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            upper[i][j] = table[i][j] - total\n    return lower, upper",
    "docstring": "Perform LU decomposition on a given matrix and raises an error if the matrix\nisn't square or if no such decomposition exists\n\n>>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])\n>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n>>> lower_mat\narray([[1. , 0. , 0. ],\n       [0. , 1. , 0. ],\n       [2.5, 8. , 1. ]])\n>>> upper_mat\narray([[  2. ,  -2. ,   1. ],\n       [  0. ,   1. ,   2. ],\n       [  0. ,   0. , -17.5]])\n\n>>> matrix = np.array([[4, 3], [6, 3]])\n>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n>>> lower_mat\narray([[1. , 0. ],\n       [1.5, 1. ]])\n>>> upper_mat\narray([[ 4. ,  3. ],\n       [ 0. , -1.5]])\n\n>>> # Matrix is not square\n>>> matrix = np.array([[2, -2, 1], [0, 1, 2]])\n>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\nTraceback (most recent call last):\n    ...\nValueError: 'table' has to be of square shaped array but got a 2x3 array:\n[[ 2 -2  1]\n [ 0  1  2]]\n\n>>> # Matrix is invertible, but its first leading principal minor is 0\n>>> matrix = np.array([[0, 1], [1, 0]])\n>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\nTraceback (most recent call last):\n...\nArithmeticError: No LU decomposition exists\n\n>>> # Matrix is singular, but its first leading principal minor is 1\n>>> matrix = np.array([[1, 0], [1, 0]])\n>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n>>> lower_mat\narray([[1., 0.],\n       [1., 1.]])\n>>> upper_mat\narray([[1., 0.],\n       [0., 0.]])\n\n>>> # Matrix is singular, but its first leading principal minor is 0\n>>> matrix = np.array([[0, 1], [0, 1]])\n>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\nTraceback (most recent call last):\n...\nArithmeticError: No LU decomposition exists"
  },
  {
    "function": "invert_matrix",
    "code": "def invert_matrix(matrix: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    Returns the inverse of a square matrix using NumPy.\n\n    Parameters:\n    matrix (list[list[float]]): A square matrix.\n\n    Returns:\n    list[list[float]]: Inverted matrix if invertible, else raises error.\n\n    >>> invert_matrix([[4.0, 7.0], [2.0, 6.0]])\n    [[0.6000000000000001, -0.7000000000000001], [-0.2, 0.4]]\n    >>> invert_matrix([[1.0, 2.0], [0.0, 0.0]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Matrix is not invertible\n    \"\"\"\n    np_matrix = np.array(matrix)\n\n    try:\n        inv_matrix = np.linalg.inv(np_matrix)\n    except np.linalg.LinAlgError:\n        raise ValueError(\"Matrix is not invertible\")\n\n    return inv_matrix.tolist()",
    "docstring": "Returns the inverse of a square matrix using NumPy.\n\nParameters:\nmatrix (list[list[float]]): A square matrix.\n\nReturns:\nlist[list[float]]: Inverted matrix if invertible, else raises error.\n\n>>> invert_matrix([[4.0, 7.0], [2.0, 6.0]])\n[[0.6000000000000001, -0.7000000000000001], [-0.2, 0.4]]\n>>> invert_matrix([[1.0, 2.0], [0.0, 0.0]])\nTraceback (most recent call last):\n    ...\nValueError: Matrix is not invertible"
  },
  {
    "function": "_is_matrix_spd",
    "code": "def _is_matrix_spd(matrix: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if input matrix is symmetric positive definite.\n    Returns False otherwise.\n\n    For a matrix to be SPD, all eigenvalues must be positive.\n\n    >>> import numpy as np\n    >>> matrix = np.array([\n    ... [4.12401784, -5.01453636, -0.63865857],\n    ... [-5.01453636, 12.33347422, -3.40493586],\n    ... [-0.63865857, -3.40493586,  5.78591885]])\n    >>> _is_matrix_spd(matrix)\n    True\n    >>> matrix = np.array([\n    ... [0.34634879,  1.96165514,  2.18277744],\n    ... [0.74074469, -1.19648894, -1.34223498],\n    ... [-0.7687067 ,  0.06018373, -1.16315631]])\n    >>> _is_matrix_spd(matrix)\n    False\n    \"\"\"\n    # Ensure matrix is square.\n    assert np.shape(matrix)[0] == np.shape(matrix)[1]\n\n    # If matrix not symmetric, exit right away.\n    if np.allclose(matrix, matrix.T) is False:\n        return False\n\n    # Get eigenvalues and eignevectors for a symmetric matrix.\n    eigen_values, _ = np.linalg.eigh(matrix)\n\n    # Check sign of all eigenvalues.\n    # np.all returns a value of type np.bool_\n    return bool(np.all(eigen_values > 0))",
    "docstring": "Returns True if input matrix is symmetric positive definite.\nReturns False otherwise.\n\nFor a matrix to be SPD, all eigenvalues must be positive.\n\n>>> import numpy as np\n>>> matrix = np.array([\n... [4.12401784, -5.01453636, -0.63865857],\n... [-5.01453636, 12.33347422, -3.40493586],\n... [-0.63865857, -3.40493586,  5.78591885]])\n>>> _is_matrix_spd(matrix)\nTrue\n>>> matrix = np.array([\n... [0.34634879,  1.96165514,  2.18277744],\n... [0.74074469, -1.19648894, -1.34223498],\n... [-0.7687067 ,  0.06018373, -1.16315631]])\n>>> _is_matrix_spd(matrix)\nFalse"
  },
  {
    "function": "_create_spd_matrix",
    "code": "def _create_spd_matrix(dimension: int) -> Any:\n    \"\"\"\n    Returns a symmetric positive definite matrix given a dimension.\n\n    Input:\n    dimension gives the square matrix dimension.\n\n    Output:\n    spd_matrix is an diminesion x dimensions symmetric positive definite (SPD) matrix.\n\n    >>> import numpy as np\n    >>> dimension = 3\n    >>> spd_matrix = _create_spd_matrix(dimension)\n    >>> _is_matrix_spd(spd_matrix)\n    True\n    \"\"\"\n    rng = np.random.default_rng()\n    random_matrix = rng.normal(size=(dimension, dimension))\n    spd_matrix = np.dot(random_matrix, random_matrix.T)\n    assert _is_matrix_spd(spd_matrix)\n    return spd_matrix",
    "docstring": "Returns a symmetric positive definite matrix given a dimension.\n\nInput:\ndimension gives the square matrix dimension.\n\nOutput:\nspd_matrix is an diminesion x dimensions symmetric positive definite (SPD) matrix.\n\n>>> import numpy as np\n>>> dimension = 3\n>>> spd_matrix = _create_spd_matrix(dimension)\n>>> _is_matrix_spd(spd_matrix)\nTrue"
  },
  {
    "function": "conjugate_gradient",
    "code": "def conjugate_gradient(\n    spd_matrix: np.ndarray,\n    load_vector: np.ndarray,\n    max_iterations: int = 1000,\n    tol: float = 1e-8,\n) -> Any:\n    \"\"\"\n    Returns solution to the linear system np.dot(spd_matrix, x) = b.\n\n    Input:\n    spd_matrix is an NxN Symmetric Positive Definite (SPD) matrix.\n    load_vector is an Nx1 vector.\n\n    Output:\n    x is an Nx1 vector that is the solution vector.\n\n    >>> import numpy as np\n    >>> spd_matrix = np.array([\n    ... [8.73256573, -5.02034289, -2.68709226],\n    ... [-5.02034289,  3.78188322,  0.91980451],\n    ... [-2.68709226,  0.91980451,  1.94746467]])\n    >>> b = np.array([\n    ... [-5.80872761],\n    ... [ 3.23807431],\n    ... [ 1.95381422]])\n    >>> conjugate_gradient(spd_matrix, b)\n    array([[-0.63114139],\n           [-0.01561498],\n           [ 0.13979294]])\n    \"\"\"\n    # Ensure proper dimensionality.\n    assert np.shape(spd_matrix)[0] == np.shape(spd_matrix)[1]\n    assert np.shape(load_vector)[0] == np.shape(spd_matrix)[0]\n    assert _is_matrix_spd(spd_matrix)\n\n    # Initialize solution guess, residual, search direction.\n    x0 = np.zeros((np.shape(load_vector)[0], 1))\n    r0 = np.copy(load_vector)\n    p0 = np.copy(r0)\n\n    # Set initial errors in solution guess and residual.\n    error_residual = 1e9\n    error_x_solution = 1e9\n    error = 1e9\n\n    # Set iteration counter to threshold number of iterations.\n    iterations = 0\n\n    while error > tol:\n        # Save this value so we only calculate the matrix-vector product once.\n        w = np.dot(spd_matrix, p0)\n\n        # The main algorithm.\n\n        # Update search direction magnitude.\n        alpha = np.dot(r0.T, r0) / np.dot(p0.T, w)\n        # Update solution guess.\n        x = x0 + alpha * p0\n        # Calculate new residual.\n        r = r0 - alpha * w\n        # Calculate new Krylov subspace scale.\n        beta = np.dot(r.T, r) / np.dot(r0.T, r0)\n        # Calculate new A conjuage search direction.\n        p = r + beta * p0\n\n        # Calculate errors.\n        error_residual = np.linalg.norm(r - r0)\n        error_x_solution = np.linalg.norm(x - x0)\n        error = np.maximum(error_residual, error_x_solution)\n\n        # Update variables.\n        x0 = np.copy(x)\n        r0 = np.copy(r)\n        p0 = np.copy(p)\n\n        # Update number of iterations.\n        iterations += 1\n        if iterations > max_iterations:\n            break\n\n    return x",
    "docstring": "Returns solution to the linear system np.dot(spd_matrix, x) = b.\n\nInput:\nspd_matrix is an NxN Symmetric Positive Definite (SPD) matrix.\nload_vector is an Nx1 vector.\n\nOutput:\nx is an Nx1 vector that is the solution vector.\n\n>>> import numpy as np\n>>> spd_matrix = np.array([\n... [8.73256573, -5.02034289, -2.68709226],\n... [-5.02034289,  3.78188322,  0.91980451],\n... [-2.68709226,  0.91980451,  1.94746467]])\n>>> b = np.array([\n... [-5.80872761],\n... [ 3.23807431],\n... [ 1.95381422]])\n>>> conjugate_gradient(spd_matrix, b)\narray([[-0.63114139],\n       [-0.01561498],\n       [ 0.13979294]])"
  },
  {
    "function": "test_conjugate_gradient",
    "code": "def test_conjugate_gradient() -> None:\n    \"\"\"\n    >>> test_conjugate_gradient()  # self running tests\n    \"\"\"\n    # Create linear system with SPD matrix and known solution x_true.\n    dimension = 3\n    spd_matrix = _create_spd_matrix(dimension)\n    rng = np.random.default_rng()\n    x_true = rng.normal(size=(dimension, 1))\n    b = np.dot(spd_matrix, x_true)\n\n    # Numpy solution.\n    x_numpy = np.linalg.solve(spd_matrix, b)\n\n    # Our implementation.\n    x_conjugate_gradient = conjugate_gradient(spd_matrix, b)\n\n    # Ensure both solutions are close to x_true (and therefore one another).\n    assert np.linalg.norm(x_numpy - x_true) <= 1e-6\n    assert np.linalg.norm(x_conjugate_gradient - x_true) <= 1e-6",
    "docstring": ">>> test_conjugate_gradient()  # self running tests"
  },
  {
    "function": "solve_linear_system",
    "code": "def solve_linear_system(matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Solve a linear system of equations using Gaussian elimination with partial pivoting\n\n    Args:\n      - `matrix`: Coefficient matrix with the last column representing the constants.\n\n    Returns:\n      - Solution vector.\n\n    Raises:\n      - ``ValueError``: If the matrix is not correct (i.e., singular).\n\n    https://courses.engr.illinois.edu/cs357/su2013/lect.htm Lecture 7\n\n    Example:\n\n    >>> A = np.array([[2, 1, -1], [-3, -1, 2], [-2, 1, 2]], dtype=float)\n    >>> B = np.array([8, -11, -3], dtype=float)\n    >>> solution = solve_linear_system(np.column_stack((A, B)))\n    >>> np.allclose(solution, np.array([2., 3., -1.]))\n    True\n    >>> solve_linear_system(np.array([[0, 0, 0]], dtype=float))\n    Traceback (most recent call last):\n        ...\n    ValueError: Matrix is not square\n    >>> solve_linear_system(np.array([[0, 0, 0], [0, 0, 0]], dtype=float))\n    Traceback (most recent call last):\n        ...\n    ValueError: Matrix is singular\n    \"\"\"\n    ab = np.copy(matrix)\n    num_of_rows = ab.shape[0]\n    num_of_columns = ab.shape[1] - 1\n    x_lst: list[float] = []\n\n    if num_of_rows != num_of_columns:\n        raise ValueError(\"Matrix is not square\")\n\n    for column_num in range(num_of_rows):\n        # Lead element search\n        for i in range(column_num, num_of_columns):\n            if abs(ab[i][column_num]) > abs(ab[column_num][column_num]):\n                ab[[column_num, i]] = ab[[i, column_num]]\n\n        # Upper triangular matrix\n        if abs(ab[column_num, column_num]) < 1e-8:\n            raise ValueError(\"Matrix is singular\")\n\n        if column_num != 0:\n            for i in range(column_num, num_of_rows):\n                ab[i, :] -= (\n                    ab[i, column_num - 1]\n                    / ab[column_num - 1, column_num - 1]\n                    * ab[column_num - 1, :]\n                )\n\n    # Find x vector (Back Substitution)\n    for column_num in range(num_of_rows - 1, -1, -1):\n        x = ab[column_num, -1] / ab[column_num, column_num]\n        x_lst.insert(0, x)\n        for i in range(column_num - 1, -1, -1):\n            ab[i, -1] -= ab[i, column_num] * x\n\n    # Return the solution vector\n    return np.asarray(x_lst)",
    "docstring": "Solve a linear system of equations using Gaussian elimination with partial pivoting\n\nArgs:\n  - `matrix`: Coefficient matrix with the last column representing the constants.\n\nReturns:\n  - Solution vector.\n\nRaises:\n  - ``ValueError``: If the matrix is not correct (i.e., singular).\n\nhttps://courses.engr.illinois.edu/cs357/su2013/lect.htm Lecture 7\n\nExample:\n\n>>> A = np.array([[2, 1, -1], [-3, -1, 2], [-2, 1, 2]], dtype=float)\n>>> B = np.array([8, -11, -3], dtype=float)\n>>> solution = solve_linear_system(np.column_stack((A, B)))\n>>> np.allclose(solution, np.array([2., 3., -1.]))\nTrue\n>>> solve_linear_system(np.array([[0, 0, 0]], dtype=float))\nTraceback (most recent call last):\n    ...\nValueError: Matrix is not square\n>>> solve_linear_system(np.array([[0, 0, 0], [0, 0, 0]], dtype=float))\nTraceback (most recent call last):\n    ...\nValueError: Matrix is singular"
  },
  {
    "function": "zero_vector",
    "code": "def zero_vector(dimension: int) -> Vector:\n    \"\"\"\n    returns a zero-vector of size 'dimension'\n    \"\"\"\n    # precondition\n    assert isinstance(dimension, int)\n    return Vector([0] * dimension)",
    "docstring": "returns a zero-vector of size 'dimension'"
  },
  {
    "function": "unit_basis_vector",
    "code": "def unit_basis_vector(dimension: int, pos: int) -> Vector:\n    \"\"\"\n    returns a unit basis vector with a One\n    at index 'pos' (indexing at 0)\n    \"\"\"\n    # precondition\n    assert isinstance(dimension, int)\n    assert isinstance(pos, int)\n    ans = [0] * dimension\n    ans[pos] = 1\n    return Vector(ans)",
    "docstring": "returns a unit basis vector with a One\nat index 'pos' (indexing at 0)"
  },
  {
    "function": "axpy",
    "code": "def axpy(scalar: float, x: Vector, y: Vector) -> Vector:\n    \"\"\"\n    input: a 'scalar' and two vectors 'x' and 'y'\n    output: a vector\n    computes the axpy operation\n    \"\"\"\n    # precondition\n    assert isinstance(x, Vector)\n    assert isinstance(y, Vector)\n    assert isinstance(scalar, (int, float))\n    return x * scalar + y",
    "docstring": "input: a 'scalar' and two vectors 'x' and 'y'\noutput: a vector\ncomputes the axpy operation"
  },
  {
    "function": "random_vector",
    "code": "def random_vector(n: int, a: int, b: int) -> Vector:\n    \"\"\"\n    input: size (N) of the vector.\n           random range (a,b)\n    output: returns a random vector of size N, with\n            random integer components between 'a' and 'b'.\n    \"\"\"\n    random.seed(None)\n    ans = [random.randint(a, b) for _ in range(n)]\n    return Vector(ans)",
    "docstring": "input: size (N) of the vector.\n       random range (a,b)\noutput: returns a random vector of size N, with\n        random integer components between 'a' and 'b'."
  },
  {
    "function": "square_zero_matrix",
    "code": "def square_zero_matrix(n: int) -> Matrix:\n    \"\"\"\n    returns a square zero-matrix of dimension NxN\n    \"\"\"\n    ans: list[list[float]] = [[0] * n for _ in range(n)]\n    return Matrix(ans, n, n)",
    "docstring": "returns a square zero-matrix of dimension NxN"
  },
  {
    "function": "random_matrix",
    "code": "def random_matrix(width: int, height: int, a: int, b: int) -> Matrix:\n    \"\"\"\n    returns a random matrix WxH with integer components\n    between 'a' and 'b'\n    \"\"\"\n    random.seed(None)\n    matrix: list[list[float]] = [\n        [random.randint(a, b) for _ in range(width)] for _ in range(height)\n    ]\n    return Matrix(matrix, width, height)",
    "docstring": "returns a random matrix WxH with integer components\nbetween 'a' and 'b'"
  },
  {
    "function": "points_to_polynomial",
    "code": "def points_to_polynomial(coordinates: list[list[int]]) -> str:\n    \"\"\"\n    coordinates is a two dimensional matrix: [[x, y], [x, y], ...]\n    number of points you want to use\n\n    >>> points_to_polynomial([])\n    Traceback (most recent call last):\n        ...\n    ValueError: The program cannot work out a fitting polynomial.\n    >>> points_to_polynomial([[]])\n    Traceback (most recent call last):\n        ...\n    ValueError: The program cannot work out a fitting polynomial.\n    >>> points_to_polynomial([[1, 0], [2, 0], [3, 0]])\n    'f(x)=x^2*0.0+x^1*-0.0+x^0*0.0'\n    >>> points_to_polynomial([[1, 1], [2, 1], [3, 1]])\n    'f(x)=x^2*0.0+x^1*-0.0+x^0*1.0'\n    >>> points_to_polynomial([[1, 3], [2, 3], [3, 3]])\n    'f(x)=x^2*0.0+x^1*-0.0+x^0*3.0'\n    >>> points_to_polynomial([[1, 1], [2, 2], [3, 3]])\n    'f(x)=x^2*0.0+x^1*1.0+x^0*0.0'\n    >>> points_to_polynomial([[1, 1], [2, 4], [3, 9]])\n    'f(x)=x^2*1.0+x^1*-0.0+x^0*0.0'\n    >>> points_to_polynomial([[1, 3], [2, 6], [3, 11]])\n    'f(x)=x^2*1.0+x^1*-0.0+x^0*2.0'\n    >>> points_to_polynomial([[1, -3], [2, -6], [3, -11]])\n    'f(x)=x^2*-1.0+x^1*-0.0+x^0*-2.0'\n    >>> points_to_polynomial([[1, 5], [2, 2], [3, 9]])\n    'f(x)=x^2*5.0+x^1*-18.0+x^0*18.0'\n    >>> points_to_polynomial([[1, 1], [1, 2], [1, 3]])\n    'x=1'\n    >>> points_to_polynomial([[1, 1], [2, 2], [2, 2]])\n    Traceback (most recent call last):\n        ...\n    ValueError: The program cannot work out a fitting polynomial.\n    \"\"\"\n    if len(coordinates) == 0 or not all(len(pair) == 2 for pair in coordinates):\n        raise ValueError(\"The program cannot work out a fitting polynomial.\")\n\n    if len({tuple(pair) for pair in coordinates}) != len(coordinates):\n        raise ValueError(\"The program cannot work out a fitting polynomial.\")\n\n    set_x = {x for x, _ in coordinates}\n    if len(set_x) == 1:\n        return f\"x={coordinates[0][0]}\"\n\n    if len(set_x) != len(coordinates):\n        raise ValueError(\"The program cannot work out a fitting polynomial.\")\n\n    x = len(coordinates)\n\n    # put the x and x to the power values in a matrix\n    matrix: list[list[float]] = [\n        [\n            coordinates[count_of_line][0] ** (x - (count_in_line + 1))\n            for count_in_line in range(x)\n        ]\n        for count_of_line in range(x)\n    ]\n\n    # put the y values into a vector\n    vector: list[float] = [coordinates[count_of_line][1] for count_of_line in range(x)]\n\n    for count in range(x):\n        for number in range(x):\n            if count == number:\n                continue\n            fraction = matrix[number][count] / matrix[count][count]\n            for counting_columns, item in enumerate(matrix[count]):\n                # manipulating all the values in the matrix\n                matrix[number][counting_columns] -= item * fraction\n            # manipulating the values in the vector\n            vector[number] -= vector[count] * fraction\n\n    # make solutions\n    solution: list[str] = [\n        str(vector[count] / matrix[count][count]) for count in range(x)\n    ]\n\n    solved = \"f(x)=\"\n\n    for count in range(x):\n        remove_e: list[str] = solution[count].split(\"E\")\n        if len(remove_e) > 1:\n            solution[count] = f\"{remove_e[0]}*10^{remove_e[1]}\"\n        solved += f\"x^{x - (count + 1)}*{solution[count]}\"\n        if count + 1 != x:\n            solved += \"+\"\n\n    return solved",
    "docstring": "coordinates is a two dimensional matrix: [[x, y], [x, y], ...]\nnumber of points you want to use\n\n>>> points_to_polynomial([])\nTraceback (most recent call last):\n    ...\nValueError: The program cannot work out a fitting polynomial.\n>>> points_to_polynomial([[]])\nTraceback (most recent call last):\n    ...\nValueError: The program cannot work out a fitting polynomial.\n>>> points_to_polynomial([[1, 0], [2, 0], [3, 0]])\n'f(x)=x^2*0.0+x^1*-0.0+x^0*0.0'\n>>> points_to_polynomial([[1, 1], [2, 1], [3, 1]])\n'f(x)=x^2*0.0+x^1*-0.0+x^0*1.0'\n>>> points_to_polynomial([[1, 3], [2, 3], [3, 3]])\n'f(x)=x^2*0.0+x^1*-0.0+x^0*3.0'\n>>> points_to_polynomial([[1, 1], [2, 2], [3, 3]])\n'f(x)=x^2*0.0+x^1*1.0+x^0*0.0'\n>>> points_to_polynomial([[1, 1], [2, 4], [3, 9]])\n'f(x)=x^2*1.0+x^1*-0.0+x^0*0.0'\n>>> points_to_polynomial([[1, 3], [2, 6], [3, 11]])\n'f(x)=x^2*1.0+x^1*-0.0+x^0*2.0'\n>>> points_to_polynomial([[1, -3], [2, -6], [3, -11]])\n'f(x)=x^2*-1.0+x^1*-0.0+x^0*-2.0'\n>>> points_to_polynomial([[1, 5], [2, 2], [3, 9]])\n'f(x)=x^2*5.0+x^1*-18.0+x^0*18.0'\n>>> points_to_polynomial([[1, 1], [1, 2], [1, 3]])\n'x=1'\n>>> points_to_polynomial([[1, 1], [2, 2], [2, 2]])\nTraceback (most recent call last):\n    ...\nValueError: The program cannot work out a fitting polynomial."
  },
  {
    "function": "power_iteration",
    "code": "def power_iteration(\n    input_matrix: np.ndarray,\n    vector: np.ndarray,\n    error_tol: float = 1e-12,\n    max_iterations: int = 100,\n) -> tuple[float, np.ndarray]:\n    \"\"\"\n    Power Iteration.\n    Find the largest eigenvalue and corresponding eigenvector\n    of matrix input_matrix given a random vector in the same space.\n    Will work so long as vector has component of largest eigenvector.\n    input_matrix must be either real or Hermitian.\n\n    Input\n    input_matrix: input matrix whose largest eigenvalue we will find.\n    Numpy array. np.shape(input_matrix) == (N,N).\n    vector: random initial vector in same space as matrix.\n    Numpy array. np.shape(vector) == (N,) or (N,1)\n\n    Output\n    largest_eigenvalue: largest eigenvalue of the matrix input_matrix.\n    Float. Scalar.\n    largest_eigenvector: eigenvector corresponding to largest_eigenvalue.\n    Numpy array. np.shape(largest_eigenvector) == (N,) or (N,1).\n\n    >>> import numpy as np\n    >>> input_matrix = np.array([\n    ... [41,  4, 20],\n    ... [ 4, 26, 30],\n    ... [20, 30, 50]\n    ... ])\n    >>> vector = np.array([41,4,20])\n    >>> power_iteration(input_matrix,vector)\n    (79.66086378788381, array([0.44472726, 0.46209842, 0.76725662]))\n    \"\"\"\n\n    # Ensure matrix is square.\n    assert np.shape(input_matrix)[0] == np.shape(input_matrix)[1]\n    # Ensure proper dimensionality.\n    assert np.shape(input_matrix)[0] == np.shape(vector)[0]\n    # Ensure inputs are either both complex or both real\n    assert np.iscomplexobj(input_matrix) == np.iscomplexobj(vector)\n    is_complex = np.iscomplexobj(input_matrix)\n    if is_complex:\n        # Ensure complex input_matrix is Hermitian\n        assert np.array_equal(input_matrix, input_matrix.conj().T)\n\n    # Set convergence to False. Will define convergence when we exceed max_iterations\n    # or when we have small changes from one iteration to next.\n\n    convergence = False\n    lambda_previous = 0\n    iterations = 0\n    error = 1e12\n\n    while not convergence:\n        # Multiple matrix by the vector.\n        w = np.dot(input_matrix, vector)\n        # Normalize the resulting output vector.\n        vector = w / np.linalg.norm(w)\n        # Find rayleigh quotient\n        # (faster than usual b/c we know vector is normalized already)\n        vector_h = vector.conj().T if is_complex else vector.T\n        lambda_ = np.dot(vector_h, np.dot(input_matrix, vector))\n\n        # Check convergence.\n        error = np.abs(lambda_ - lambda_previous) / lambda_\n        iterations += 1\n\n        if error <= error_tol or iterations >= max_iterations:\n            convergence = True\n\n        lambda_previous = lambda_\n\n    if is_complex:\n        lambda_ = np.real(lambda_)\n\n    return float(lambda_), vector",
    "docstring": "Power Iteration.\nFind the largest eigenvalue and corresponding eigenvector\nof matrix input_matrix given a random vector in the same space.\nWill work so long as vector has component of largest eigenvector.\ninput_matrix must be either real or Hermitian.\n\nInput\ninput_matrix: input matrix whose largest eigenvalue we will find.\nNumpy array. np.shape(input_matrix) == (N,N).\nvector: random initial vector in same space as matrix.\nNumpy array. np.shape(vector) == (N,) or (N,1)\n\nOutput\nlargest_eigenvalue: largest eigenvalue of the matrix input_matrix.\nFloat. Scalar.\nlargest_eigenvector: eigenvector corresponding to largest_eigenvalue.\nNumpy array. np.shape(largest_eigenvector) == (N,) or (N,1).\n\n>>> import numpy as np\n>>> input_matrix = np.array([\n... [41,  4, 20],\n... [ 4, 26, 30],\n... [20, 30, 50]\n... ])\n>>> vector = np.array([41,4,20])\n>>> power_iteration(input_matrix,vector)\n(79.66086378788381, array([0.44472726, 0.46209842, 0.76725662]))"
  },
  {
    "function": "test_power_iteration",
    "code": "def test_power_iteration() -> None:\n    \"\"\"\n    >>> test_power_iteration()  # self running tests\n    \"\"\"\n    real_input_matrix = np.array([[41, 4, 20], [4, 26, 30], [20, 30, 50]])\n    real_vector = np.array([41, 4, 20])\n    complex_input_matrix = real_input_matrix.astype(np.complex128)\n    imag_matrix = np.triu(1j * complex_input_matrix, 1)\n    complex_input_matrix += imag_matrix\n    complex_input_matrix += -1 * imag_matrix.T\n    complex_vector = np.array([41, 4, 20]).astype(np.complex128)\n\n    for problem_type in [\"real\", \"complex\"]:\n        if problem_type == \"real\":\n            input_matrix = real_input_matrix\n            vector = real_vector\n        elif problem_type == \"complex\":\n            input_matrix = complex_input_matrix\n            vector = complex_vector\n\n        # Our implementation.\n        eigen_value, eigen_vector = power_iteration(input_matrix, vector)\n\n        # Numpy implementation.\n\n        # Get eigenvalues and eigenvectors using built-in numpy\n        # eigh (eigh used for symmetric or hermetian matrices).\n        eigen_values, eigen_vectors = np.linalg.eigh(input_matrix)\n        # Last eigenvalue is the maximum one.\n        eigen_value_max = eigen_values[-1]\n        # Last column in this matrix is eigenvector corresponding to largest eigenvalue.\n        eigen_vector_max = eigen_vectors[:, -1]\n\n        # Check our implementation and numpy gives close answers.\n        assert np.abs(eigen_value - eigen_value_max) <= 1e-6\n        # Take absolute values element wise of each eigenvector.\n        # as they are only unique to a minus sign.\n        assert np.linalg.norm(np.abs(eigen_vector) - np.abs(eigen_vector_max)) <= 1e-6",
    "docstring": ">>> test_power_iteration()  # self running tests"
  },
  {
    "function": "rank_of_matrix",
    "code": "def rank_of_matrix(matrix: list[list[int | float]]) -> int:\n    \"\"\"\n    Finds the rank of a matrix.\n\n    Args:\n        `matrix`: The matrix as a list of lists.\n\n    Returns:\n        The rank of the matrix.\n\n    Example:\n\n    >>> matrix1 = [[1, 2, 3],\n    ...            [4, 5, 6],\n    ...            [7, 8, 9]]\n    >>> rank_of_matrix(matrix1)\n    2\n    >>> matrix2 = [[1, 0, 0],\n    ...            [0, 1, 0],\n    ...            [0, 0, 0]]\n    >>> rank_of_matrix(matrix2)\n    2\n    >>> matrix3 = [[1, 2, 3, 4],\n    ...            [5, 6, 7, 8],\n    ...            [9, 10, 11, 12]]\n    >>> rank_of_matrix(matrix3)\n    2\n    >>> rank_of_matrix([[2,3,-1,-1],\n    ...                [1,-1,-2,4],\n    ...                [3,1,3,-2],\n    ...                [6,3,0,-7]])\n    4\n    >>> rank_of_matrix([[2,1,-3,-6],\n    ...                [3,-3,1,2],\n    ...                [1,1,1,2]])\n    3\n    >>> rank_of_matrix([[2,-1,0],\n    ...                [1,3,4],\n    ...                [4,1,-3]])\n    3\n    >>> rank_of_matrix([[3,2,1],\n    ...                [-6,-4,-2]])\n    1\n    >>> rank_of_matrix([[],[]])\n    0\n    >>> rank_of_matrix([[1]])\n    1\n    >>> rank_of_matrix([[]])\n    0\n    \"\"\"\n\n    rows = len(matrix)\n    columns = len(matrix[0])\n    rank = min(rows, columns)\n\n    for row in range(rank):\n        # Check if diagonal element is not zero\n        if matrix[row][row] != 0:\n            # Eliminate all the elements below the diagonal\n            for col in range(row + 1, rows):\n                multiplier = matrix[col][row] / matrix[row][row]\n                for i in range(row, columns):\n                    matrix[col][i] -= multiplier * matrix[row][i]\n        else:\n            # Find a non-zero diagonal element to swap rows\n            reduce = True\n            for i in range(row + 1, rows):\n                if matrix[i][row] != 0:\n                    matrix[row], matrix[i] = matrix[i], matrix[row]\n                    reduce = False\n                    break\n            if reduce:\n                rank -= 1\n                for i in range(rows):\n                    matrix[i][row] = matrix[i][rank]\n\n            # Reduce the row pointer by one to stay on the same row\n            row -= 1\n\n    return rank",
    "docstring": "Finds the rank of a matrix.\n\nArgs:\n    `matrix`: The matrix as a list of lists.\n\nReturns:\n    The rank of the matrix.\n\nExample:\n\n>>> matrix1 = [[1, 2, 3],\n...            [4, 5, 6],\n...            [7, 8, 9]]\n>>> rank_of_matrix(matrix1)\n2\n>>> matrix2 = [[1, 0, 0],\n...            [0, 1, 0],\n...            [0, 0, 0]]\n>>> rank_of_matrix(matrix2)\n2\n>>> matrix3 = [[1, 2, 3, 4],\n...            [5, 6, 7, 8],\n...            [9, 10, 11, 12]]\n>>> rank_of_matrix(matrix3)\n2\n>>> rank_of_matrix([[2,3,-1,-1],\n...                [1,-1,-2,4],\n...                [3,1,3,-2],\n...                [6,3,0,-7]])\n4\n>>> rank_of_matrix([[2,1,-3,-6],\n...                [3,-3,1,2],\n...                [1,1,1,2]])\n3\n>>> rank_of_matrix([[2,-1,0],\n...                [1,3,4],\n...                [4,1,-3]])\n3\n>>> rank_of_matrix([[3,2,1],\n...                [-6,-4,-2]])\n1\n>>> rank_of_matrix([[],[]])\n0\n>>> rank_of_matrix([[1]])\n1\n>>> rank_of_matrix([[]])\n0"
  },
  {
    "function": "is_hermitian",
    "code": "def is_hermitian(matrix: np.ndarray) -> bool:\n    \"\"\"\n    Checks if a matrix is Hermitian.\n    >>> import numpy as np\n    >>> A = np.array([\n    ... [2,    2+1j, 4],\n    ... [2-1j,  3,  1j],\n    ... [4,    -1j,  1]])\n    >>> is_hermitian(A)\n    True\n    >>> A = np.array([\n    ... [2,    2+1j, 4+1j],\n    ... [2-1j,  3,  1j],\n    ... [4,    -1j,  1]])\n    >>> is_hermitian(A)\n    False\n    \"\"\"\n    return np.array_equal(matrix, matrix.conjugate().T)",
    "docstring": "Checks if a matrix is Hermitian.\n>>> import numpy as np\n>>> A = np.array([\n... [2,    2+1j, 4],\n... [2-1j,  3,  1j],\n... [4,    -1j,  1]])\n>>> is_hermitian(A)\nTrue\n>>> A = np.array([\n... [2,    2+1j, 4+1j],\n... [2-1j,  3,  1j],\n... [4,    -1j,  1]])\n>>> is_hermitian(A)\nFalse"
  },
  {
    "function": "rayleigh_quotient",
    "code": "def rayleigh_quotient(a: np.ndarray, v: np.ndarray) -> Any:\n    \"\"\"\n    Returns the Rayleigh quotient of a Hermitian matrix A and\n    vector v.\n    >>> import numpy as np\n    >>> A = np.array([\n    ... [1,  2, 4],\n    ... [2,  3,  -1],\n    ... [4, -1,  1]\n    ... ])\n    >>> v = np.array([\n    ... [1],\n    ... [2],\n    ... [3]\n    ... ])\n    >>> rayleigh_quotient(A, v)\n    array([[3.]])\n    \"\"\"\n    v_star = v.conjugate().T\n    v_star_dot = v_star.dot(a)\n    assert isinstance(v_star_dot, np.ndarray)\n    return (v_star_dot.dot(v)) / (v_star.dot(v))",
    "docstring": "Returns the Rayleigh quotient of a Hermitian matrix A and\nvector v.\n>>> import numpy as np\n>>> A = np.array([\n... [1,  2, 4],\n... [2,  3,  -1],\n... [4, -1,  1]\n... ])\n>>> v = np.array([\n... [1],\n... [2],\n... [3]\n... ])\n>>> rayleigh_quotient(A, v)\narray([[3.]])"
  },
  {
    "function": "schur_complement",
    "code": "def schur_complement(\n    mat_a: np.ndarray,\n    mat_b: np.ndarray,\n    mat_c: np.ndarray,\n    pseudo_inv: np.ndarray | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Schur complement of a symmetric matrix X given as a 2x2 block matrix\n    consisting of matrices `A`, `B` and `C`.\n    Matrix `A` must be quadratic and non-singular.\n    In case `A` is singular, a pseudo-inverse may be provided using\n    the `pseudo_inv` argument.\n\n    | Link to Wiki: https://en.wikipedia.org/wiki/Schur_complement\n    | See also Convex Optimization - Boyd and Vandenberghe, A.5.5\n\n    >>> import numpy as np\n    >>> a = np.array([[1, 2], [2, 1]])\n    >>> b = np.array([[0, 3], [3, 0]])\n    >>> c = np.array([[2, 1], [6, 3]])\n    >>> schur_complement(a, b, c)\n    array([[ 5., -5.],\n           [ 0.,  6.]])\n    \"\"\"\n    shape_a = np.shape(mat_a)\n    shape_b = np.shape(mat_b)\n    shape_c = np.shape(mat_c)\n\n    if shape_a[0] != shape_b[0]:\n        msg = (\n            \"Expected the same number of rows for A and B. \"\n            f\"Instead found A of size {shape_a} and B of size {shape_b}\"\n        )\n        raise ValueError(msg)\n\n    if shape_b[1] != shape_c[1]:\n        msg = (\n            \"Expected the same number of columns for B and C. \"\n            f\"Instead found B of size {shape_b} and C of size {shape_c}\"\n        )\n        raise ValueError(msg)\n\n    a_inv = pseudo_inv\n    if a_inv is None:\n        try:\n            a_inv = np.linalg.inv(mat_a)\n        except np.linalg.LinAlgError:\n            raise ValueError(\n                \"Input matrix A is not invertible. Cannot compute Schur complement.\"\n            )\n\n    return mat_c - mat_b.T @ a_inv @ mat_b",
    "docstring": "Schur complement of a symmetric matrix X given as a 2x2 block matrix\nconsisting of matrices `A`, `B` and `C`.\nMatrix `A` must be quadratic and non-singular.\nIn case `A` is singular, a pseudo-inverse may be provided using\nthe `pseudo_inv` argument.\n\n| Link to Wiki: https://en.wikipedia.org/wiki/Schur_complement\n| See also Convex Optimization - Boyd and Vandenberghe, A.5.5\n\n>>> import numpy as np\n>>> a = np.array([[1, 2], [2, 1]])\n>>> b = np.array([[0, 3], [3, 0]])\n>>> c = np.array([[2, 1], [6, 3]])\n>>> schur_complement(a, b, c)\narray([[ 5., -5.],\n       [ 0.,  6.]])"
  },
  {
    "function": "scaling",
    "code": "def scaling(scaling_factor: float) -> list[list[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]",
    "docstring": ">>> scaling(5)\n[[5.0, 0.0], [0.0, 5.0]]"
  },
  {
    "function": "rotation",
    "code": "def rotation(angle: float) -> list[list[float]]:\n    \"\"\"\n    >>> rotation(45)  # doctest: +NORMALIZE_WHITESPACE\n    [[0.5253219888177297, -0.8509035245341184],\n     [0.8509035245341184, 0.5253219888177297]]\n    \"\"\"\n    c, s = cos(angle), sin(angle)\n    return [[c, -s], [s, c]]",
    "docstring": ">>> rotation(45)  # doctest: +NORMALIZE_WHITESPACE\n[[0.5253219888177297, -0.8509035245341184],\n [0.8509035245341184, 0.5253219888177297]]"
  },
  {
    "function": "projection",
    "code": "def projection(angle: float) -> list[list[float]]:\n    \"\"\"\n    >>> projection(45)  # doctest: +NORMALIZE_WHITESPACE\n    [[0.27596319193541496, 0.446998331800279],\n     [0.446998331800279, 0.7240368080645851]]\n    \"\"\"\n    c, s = cos(angle), sin(angle)\n    cs = c * s\n    return [[c * c, cs], [cs, s * s]]",
    "docstring": ">>> projection(45)  # doctest: +NORMALIZE_WHITESPACE\n[[0.27596319193541496, 0.446998331800279],\n [0.446998331800279, 0.7240368080645851]]"
  },
  {
    "function": "reflection",
    "code": "def reflection(angle: float) -> list[list[float]]:\n    \"\"\"\n    >>> reflection(45)  # doctest: +NORMALIZE_WHITESPACE\n    [[0.05064397763545947, 0.893996663600558],\n     [0.893996663600558, 0.7018070490682369]]\n    \"\"\"\n    c, s = cos(angle), sin(angle)\n    cs = c * s\n    return [[2 * c - 1, 2 * cs], [2 * cs, 2 * s - 1]]",
    "docstring": ">>> reflection(45)  # doctest: +NORMALIZE_WHITESPACE\n[[0.05064397763545947, 0.893996663600558],\n [0.893996663600558, 0.7018070490682369]]"
  },
  {
    "function": "load_data",
    "code": "def load_data() -> list[list[str]]:\n    \"\"\"\n    Returns a sample transaction dataset.\n\n    >>> load_data()\n    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]\n    \"\"\"\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]",
    "docstring": "Returns a sample transaction dataset.\n\n>>> load_data()\n[['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]"
  },
  {
    "function": "prune",
    "code": "def prune(itemset: list, candidates: list, length: int) -> list:\n    \"\"\"\n    Prune candidate itemsets that are not frequent.\n    The goal of pruning is to filter out candidate itemsets that are not frequent.  This\n    is done by checking if all the (k-1) subsets of a candidate itemset are present in\n    the frequent itemsets of the previous iteration (valid subsequences of the frequent\n    itemsets from the previous iteration).\n\n    Prunes candidate itemsets that are not frequent.\n\n    >>> itemset = ['X', 'Y', 'Z']\n    >>> candidates = [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]\n    >>> prune(itemset, candidates, 2)\n    [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]\n\n    >>> itemset = ['1', '2', '3', '4']\n    >>> candidates = ['1', '2', '4']\n    >>> prune(itemset, candidates, 3)\n    []\n    \"\"\"\n    itemset_counter = Counter(tuple(item) for item in itemset)\n    pruned = []\n    for candidate in candidates:\n        is_subsequence = True\n        for item in candidate:\n            item_tuple = tuple(item)\n            if (\n                item_tuple not in itemset_counter\n                or itemset_counter[item_tuple] < length - 1\n            ):\n                is_subsequence = False\n                break\n        if is_subsequence:\n            pruned.append(candidate)\n    return pruned",
    "docstring": "Prune candidate itemsets that are not frequent.\nThe goal of pruning is to filter out candidate itemsets that are not frequent.  This\nis done by checking if all the (k-1) subsets of a candidate itemset are present in\nthe frequent itemsets of the previous iteration (valid subsequences of the frequent\nitemsets from the previous iteration).\n\nPrunes candidate itemsets that are not frequent.\n\n>>> itemset = ['X', 'Y', 'Z']\n>>> candidates = [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]\n>>> prune(itemset, candidates, 2)\n[['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]\n\n>>> itemset = ['1', '2', '3', '4']\n>>> candidates = ['1', '2', '4']\n>>> prune(itemset, candidates, 3)\n[]"
  },
  {
    "function": "apriori",
    "code": "def apriori(data: list[list[str]], min_support: int) -> list[tuple[list[str], int]]:\n    \"\"\"\n    Returns a list of frequent itemsets and their support counts.\n\n    >>> data = [['A', 'B', 'C'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C']]\n    >>> apriori(data, 2)\n    [(['A', 'B'], 1), (['A', 'C'], 2), (['B', 'C'], 2)]\n\n    >>> data = [['1', '2', '3'], ['1', '2'], ['1', '3'], ['1', '4'], ['2', '3']]\n    >>> apriori(data, 3)\n    []\n    \"\"\"\n    itemset = [list(transaction) for transaction in data]\n    frequent_itemsets = []\n    length = 1\n\n    while itemset:\n        # Count itemset support\n        counts = [0] * len(itemset)\n        for transaction in data:\n            for j, candidate in enumerate(itemset):\n                if all(item in transaction for item in candidate):\n                    counts[j] += 1\n\n        # Prune infrequent itemsets\n        itemset = [item for i, item in enumerate(itemset) if counts[i] >= min_support]\n\n        # Append frequent itemsets (as a list to maintain order)\n        for i, item in enumerate(itemset):\n            frequent_itemsets.append((sorted(item), counts[i]))\n\n        length += 1\n        itemset = prune(itemset, list(combinations(itemset, length)), length)\n\n    return frequent_itemsets",
    "docstring": "Returns a list of frequent itemsets and their support counts.\n\n>>> data = [['A', 'B', 'C'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C']]\n>>> apriori(data, 2)\n[(['A', 'B'], 1), (['A', 'C'], 2), (['B', 'C'], 2)]\n\n>>> data = [['1', '2', '3'], ['1', '2'], ['1', '3'], ['1', '4'], ['2', '3']]\n>>> apriori(data, 3)\n[]"
  },
  {
    "function": "astar",
    "code": "def astar(world, start, goal):\n    \"\"\"\n    Implementation of a start algorithm.\n    world : Object of the world object.\n    start : Object of the cell as  start position.\n    stop  : Object of the cell as goal position.\n\n    >>> p = Gridworld()\n    >>> start = Cell()\n    >>> start.position = (0,0)\n    >>> goal = Cell()\n    >>> goal.position = (4,4)\n    >>> astar(p, start, goal)\n    [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\n    \"\"\"\n    _open = []\n    _closed = []\n    _open.append(start)\n\n    while _open:\n        min_f = np.argmin([n.f for n in _open])\n        current = _open[min_f]\n        _closed.append(_open.pop(min_f))\n        if current == goal:\n            break\n        for n in world.get_neighbours(current):\n            for c in _closed:\n                if c == n:\n                    continue\n            n.g = current.g + 1\n            x1, y1 = n.position\n            x2, y2 = goal.position\n            n.h = (y2 - y1) ** 2 + (x2 - x1) ** 2\n            n.f = n.h + n.g\n\n            for c in _open:\n                if c == n and c.f < n.f:\n                    continue\n            _open.append(n)\n    path = []\n    while current.parent is not None:\n        path.append(current.position)\n        current = current.parent\n    path.append(current.position)\n    return path[::-1]",
    "docstring": "Implementation of a start algorithm.\nworld : Object of the world object.\nstart : Object of the cell as  start position.\nstop  : Object of the cell as goal position.\n\n>>> p = Gridworld()\n>>> start = Cell()\n>>> start.position = (0,0)\n>>> goal = Cell()\n>>> goal.position = (4,4)\n>>> astar(p, start, goal)\n[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]"
  },
  {
    "function": "normalization",
    "code": "def normalization(data: list, ndigits: int = 3) -> list:\n    \"\"\"\n    Return a normalized list of values.\n\n    @params: data, a list of values to normalize\n    @returns: a list of normalized values (rounded to ndigits decimal places)\n    @examples:\n    >>> normalization([2, 7, 10, 20, 30, 50])\n    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\n    >>> normalization([5, 10, 15, 20, 25])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # variables for calculation\n    x_min = min(data)\n    x_max = max(data)\n    # normalize data\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]",
    "docstring": "Return a normalized list of values.\n\n@params: data, a list of values to normalize\n@returns: a list of normalized values (rounded to ndigits decimal places)\n@examples:\n>>> normalization([2, 7, 10, 20, 30, 50])\n[0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\n>>> normalization([5, 10, 15, 20, 25])\n[0.0, 0.25, 0.5, 0.75, 1.0]"
  },
  {
    "function": "standardization",
    "code": "def standardization(data: list, ndigits: int = 3) -> list:\n    \"\"\"\n    Return a standardized list of values.\n\n    @params: data, a list of values to standardize\n    @returns: a list of standardized values (rounded to ndigits decimal places)\n    @examples:\n    >>> standardization([2, 7, 10, 20, 30, 50])\n    [-0.999, -0.719, -0.551, 0.009, 0.57, 1.69]\n    >>> standardization([5, 10, 15, 20, 25])\n    [-1.265, -0.632, 0.0, 0.632, 1.265]\n    \"\"\"\n    # variables for calculation\n    mu = mean(data)\n    sigma = stdev(data)\n    # standardize data\n    return [round((x - mu) / (sigma), ndigits) for x in data]",
    "docstring": "Return a standardized list of values.\n\n@params: data, a list of values to standardize\n@returns: a list of standardized values (rounded to ndigits decimal places)\n@examples:\n>>> standardization([2, 7, 10, 20, 30, 50])\n[-0.999, -0.719, -0.551, 0.009, 0.57, 1.69]\n>>> standardization([5, 10, 15, 20, 25])\n[-1.265, -0.632, 0.0, 0.632, 1.265]"
  },
  {
    "function": "main",
    "code": "def main():\n    \"\"\"\n    In this demonstration we're generating a sample data set from the sin function in\n    numpy.  We then train a decision tree on the data set and use the decision tree to\n    predict the label of 10 different test values. Then the mean squared error over\n    this test is displayed.\n    \"\"\"\n    x = np.arange(-1.0, 1.0, 0.005)\n    y = np.sin(x)\n\n    tree = DecisionTree(depth=10, min_leaf_size=10)\n    tree.train(x, y)\n\n    rng = np.random.default_rng()\n    test_cases = (rng.random(10) * 2) - 1\n    predictions = np.array([tree.predict(x) for x in test_cases])\n    avg_error = np.mean((predictions - test_cases) ** 2)\n\n    print(\"Test values: \" + str(test_cases))\n    print(\"Predictions: \" + str(predictions))\n    print(\"Average error: \" + str(avg_error))",
    "docstring": "In this demonstration we're generating a sample data set from the sin function in\nnumpy.  We then train a decision tree on the data set and use the decision tree to\npredict the label of 10 different test values. Then the mean squared error over\nthis test is displayed."
  },
  {
    "function": "column_reshape",
    "code": "def column_reshape(input_array: np.ndarray) -> np.ndarray:\n    \"\"\"Function to reshape a row Numpy array into a column Numpy array\n    >>> input_array = np.array([1, 2, 3])\n    >>> column_reshape(input_array)\n    array([[1],\n           [2],\n           [3]])\n    \"\"\"\n\n    return input_array.reshape((input_array.size, 1))",
    "docstring": "Function to reshape a row Numpy array into a column Numpy array\n>>> input_array = np.array([1, 2, 3])\n>>> column_reshape(input_array)\narray([[1],\n       [2],\n       [3]])"
  },
  {
    "function": "covariance_within_classes",
    "code": "def covariance_within_classes(\n    features: np.ndarray, labels: np.ndarray, classes: int\n) -> np.ndarray:\n    \"\"\"Function to compute the covariance matrix inside each class.\n    >>> features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> labels = np.array([0, 1, 0])\n    >>> covariance_within_classes(features, labels, 2)\n    array([[0.66666667, 0.66666667, 0.66666667],\n           [0.66666667, 0.66666667, 0.66666667],\n           [0.66666667, 0.66666667, 0.66666667]])\n    \"\"\"\n\n    covariance_sum = np.nan\n    for i in range(classes):\n        data = features[:, labels == i]\n        data_mean = data.mean(1)\n        # Centralize the data of class i\n        centered_data = data - column_reshape(data_mean)\n        if i > 0:\n            # If covariance_sum is not None\n            covariance_sum += np.dot(centered_data, centered_data.T)\n        else:\n            # If covariance_sum is np.nan (i.e. first loop)\n            covariance_sum = np.dot(centered_data, centered_data.T)\n\n    return covariance_sum / features.shape[1]",
    "docstring": "Function to compute the covariance matrix inside each class.\n>>> features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n>>> labels = np.array([0, 1, 0])\n>>> covariance_within_classes(features, labels, 2)\narray([[0.66666667, 0.66666667, 0.66666667],\n       [0.66666667, 0.66666667, 0.66666667],\n       [0.66666667, 0.66666667, 0.66666667]])"
  },
  {
    "function": "covariance_between_classes",
    "code": "def covariance_between_classes(\n    features: np.ndarray, labels: np.ndarray, classes: int\n) -> np.ndarray:\n    \"\"\"Function to compute the covariance matrix between multiple classes\n    >>> features = np.array([[9, 2, 3], [4, 3, 6], [1, 8, 9]])\n    >>> labels = np.array([0, 1, 0])\n    >>> covariance_between_classes(features, labels, 2)\n    array([[ 3.55555556,  1.77777778, -2.66666667],\n           [ 1.77777778,  0.88888889, -1.33333333],\n           [-2.66666667, -1.33333333,  2.        ]])\n    \"\"\"\n\n    general_data_mean = features.mean(1)\n    covariance_sum = np.nan\n    for i in range(classes):\n        data = features[:, labels == i]\n        device_data = data.shape[1]\n        data_mean = data.mean(1)\n        if i > 0:\n            # If covariance_sum is not None\n            covariance_sum += device_data * np.dot(\n                column_reshape(data_mean) - column_reshape(general_data_mean),\n                (column_reshape(data_mean) - column_reshape(general_data_mean)).T,\n            )\n        else:\n            # If covariance_sum is np.nan (i.e. first loop)\n            covariance_sum = device_data * np.dot(\n                column_reshape(data_mean) - column_reshape(general_data_mean),\n                (column_reshape(data_mean) - column_reshape(general_data_mean)).T,\n            )\n\n    return covariance_sum / features.shape[1]",
    "docstring": "Function to compute the covariance matrix between multiple classes\n>>> features = np.array([[9, 2, 3], [4, 3, 6], [1, 8, 9]])\n>>> labels = np.array([0, 1, 0])\n>>> covariance_between_classes(features, labels, 2)\narray([[ 3.55555556,  1.77777778, -2.66666667],\n       [ 1.77777778,  0.88888889, -1.33333333],\n       [-2.66666667, -1.33333333,  2.        ]])"
  },
  {
    "function": "principal_component_analysis",
    "code": "def principal_component_analysis(features: np.ndarray, dimensions: int) -> np.ndarray:\n    \"\"\"\n    Principal Component Analysis.\n\n    For more details, see: https://en.wikipedia.org/wiki/Principal_component_analysis.\n    Parameters:\n        * features: the features extracted from the dataset\n        * dimensions: to filter the projected data for the desired dimension\n\n    >>> test_principal_component_analysis()\n    \"\"\"\n\n    # Check if the features have been loaded\n    if features.any():\n        data_mean = features.mean(1)\n        # Center the dataset\n        centered_data = features - np.reshape(data_mean, (data_mean.size, 1))\n        covariance_matrix = np.dot(centered_data, centered_data.T) / features.shape[1]\n        _, eigenvectors = np.linalg.eigh(covariance_matrix)\n        # Take all the columns in the reverse order (-1), and then takes only the first\n        filtered_eigenvectors = eigenvectors[:, ::-1][:, 0:dimensions]\n        # Project the database on the new space\n        projected_data = np.dot(filtered_eigenvectors.T, features)\n        logging.info(\"Principal Component Analysis computed\")\n\n        return projected_data\n    else:\n        logging.basicConfig(level=logging.ERROR, format=\"%(message)s\", force=True)\n        logging.error(\"Dataset empty\")\n        raise AssertionError",
    "docstring": "Principal Component Analysis.\n\nFor more details, see: https://en.wikipedia.org/wiki/Principal_component_analysis.\nParameters:\n    * features: the features extracted from the dataset\n    * dimensions: to filter the projected data for the desired dimension\n\n>>> test_principal_component_analysis()"
  },
  {
    "function": "linear_discriminant_analysis",
    "code": "def linear_discriminant_analysis(\n    features: np.ndarray, labels: np.ndarray, classes: int, dimensions: int\n) -> np.ndarray:\n    \"\"\"\n    Linear Discriminant Analysis.\n\n    For more details, see: https://en.wikipedia.org/wiki/Linear_discriminant_analysis.\n    Parameters:\n        * features: the features extracted from the dataset\n        * labels: the class labels of the features\n        * classes: the number of classes present in the dataset\n        * dimensions: to filter the projected data for the desired dimension\n\n    >>> test_linear_discriminant_analysis()\n    \"\"\"\n\n    # Check if the dimension desired is less than the number of classes\n    assert classes > dimensions\n\n    # Check if features have been already loaded\n    if features.any:\n        _, eigenvectors = eigh(\n            covariance_between_classes(features, labels, classes),\n            covariance_within_classes(features, labels, classes),\n        )\n        filtered_eigenvectors = eigenvectors[:, ::-1][:, :dimensions]\n        svd_matrix, _, _ = np.linalg.svd(filtered_eigenvectors)\n        filtered_svd_matrix = svd_matrix[:, 0:dimensions]\n        projected_data = np.dot(filtered_svd_matrix.T, features)\n        logging.info(\"Linear Discriminant Analysis computed\")\n\n        return projected_data\n    else:\n        logging.basicConfig(level=logging.ERROR, format=\"%(message)s\", force=True)\n        logging.error(\"Dataset empty\")\n        raise AssertionError",
    "docstring": "Linear Discriminant Analysis.\n\nFor more details, see: https://en.wikipedia.org/wiki/Linear_discriminant_analysis.\nParameters:\n    * features: the features extracted from the dataset\n    * labels: the class labels of the features\n    * classes: the number of classes present in the dataset\n    * dimensions: to filter the projected data for the desired dimension\n\n>>> test_linear_discriminant_analysis()"
  },
  {
    "function": "create_tree",
    "code": "def create_tree(data_set: list, min_sup: int = 1) -> tuple[TreeNode, dict]:\n    \"\"\"\n    Create Frequent Pattern tree\n\n    Args:\n        data_set: A list of transactions, where each transaction is a list of items.\n        min_sup: The minimum support threshold.\n        Items with support less than this will be pruned. Default is 1.\n\n    Returns:\n        The root of the FP-Tree.\n        header_table: The header table dictionary with item information.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> len(header_table)\n    4\n    >>> header_table[\"A\"]\n    [[4, None], TreeNode('A', 4, TreeNode('Null Set', 1, None))]\n    >>> header_table[\"E\"][1]  # doctest: +NORMALIZE_WHITESPACE\n    TreeNode('E', 1, TreeNode('B', 3, TreeNode('A', 4, TreeNode('Null Set', 1, None))))\n    >>> sorted(header_table)\n    ['A', 'B', 'C', 'E']\n    >>> fp_tree.name\n    'Null Set'\n    >>> sorted(fp_tree.children)\n    ['A', 'B']\n    >>> fp_tree.children['A'].name\n    'A'\n    >>> sorted(fp_tree.children['A'].children)\n    ['B', 'C']\n    \"\"\"\n    header_table: dict = {}\n    for trans in data_set:\n        for item in trans:\n            header_table[item] = header_table.get(item, [0, None])\n            header_table[item][0] += 1\n\n    for k in list(header_table):\n        if header_table[k][0] < min_sup:\n            del header_table[k]\n\n    if not (freq_item_set := set(header_table)):\n        return TreeNode(\"Null Set\", 1, None), {}\n\n    for key, value in header_table.items():\n        header_table[key] = [value, None]\n\n    fp_tree = TreeNode(\"Null Set\", 1, None)  # Parent is None for the root node\n    for tran_set in data_set:\n        local_d = {\n            item: header_table[item][0] for item in tran_set if item in freq_item_set\n        }\n        if local_d:\n            sorted_items = sorted(\n                local_d.items(), key=lambda item_info: item_info[1], reverse=True\n            )\n            ordered_items = [item[0] for item in sorted_items]\n            update_tree(ordered_items, fp_tree, header_table, 1)\n\n    return fp_tree, header_table",
    "docstring": "Create Frequent Pattern tree\n\nArgs:\n    data_set: A list of transactions, where each transaction is a list of items.\n    min_sup: The minimum support threshold.\n    Items with support less than this will be pruned. Default is 1.\n\nReturns:\n    The root of the FP-Tree.\n    header_table: The header table dictionary with item information.\n\nExample:\n>>> data_set = [\n...    ['A', 'B', 'C'],\n...    ['A', 'C'],\n...    ['A', 'B', 'E'],\n...    ['A', 'B', 'C', 'E'],\n...    ['B', 'E']\n... ]\n>>> min_sup = 2\n>>> fp_tree, header_table = create_tree(data_set, min_sup)\n>>> fp_tree\nTreeNode('Null Set', 1, None)\n>>> len(header_table)\n4\n>>> header_table[\"A\"]\n[[4, None], TreeNode('A', 4, TreeNode('Null Set', 1, None))]\n>>> header_table[\"E\"][1]  # doctest: +NORMALIZE_WHITESPACE\nTreeNode('E', 1, TreeNode('B', 3, TreeNode('A', 4, TreeNode('Null Set', 1, None))))\n>>> sorted(header_table)\n['A', 'B', 'C', 'E']\n>>> fp_tree.name\n'Null Set'\n>>> sorted(fp_tree.children)\n['A', 'B']\n>>> fp_tree.children['A'].name\n'A'\n>>> sorted(fp_tree.children['A'].children)\n['B', 'C']"
  },
  {
    "function": "update_tree",
    "code": "def update_tree(items: list, in_tree: TreeNode, header_table: dict, count: int) -> None:\n    \"\"\"\n    Update the FP-Tree with a transaction.\n\n    Args:\n        items: List of items in the transaction.\n        in_tree: The current node in the FP-Tree.\n        header_table: The header table dictionary with item information.\n        count: The count of the transaction.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> transaction = ['A', 'B', 'E']\n    >>> update_tree(transaction, fp_tree, header_table, 1)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> fp_tree.children['A'].children['B'].children['E'].children\n    {}\n    >>> fp_tree.children['A'].children['B'].children['E'].count\n    2\n    >>> header_table['E'][1].name\n    'E'\n    \"\"\"\n    if items[0] in in_tree.children:\n        in_tree.children[items[0]].inc(count)\n    else:\n        in_tree.children[items[0]] = TreeNode(items[0], count, in_tree)\n        if header_table[items[0]][1] is None:\n            header_table[items[0]][1] = in_tree.children[items[0]]\n        else:\n            update_header(header_table[items[0]][1], in_tree.children[items[0]])\n    if len(items) > 1:\n        update_tree(items[1:], in_tree.children[items[0]], header_table, count)",
    "docstring": "Update the FP-Tree with a transaction.\n\nArgs:\n    items: List of items in the transaction.\n    in_tree: The current node in the FP-Tree.\n    header_table: The header table dictionary with item information.\n    count: The count of the transaction.\n\nExample:\n>>> data_set = [\n...    ['A', 'B', 'C'],\n...    ['A', 'C'],\n...    ['A', 'B', 'E'],\n...    ['A', 'B', 'C', 'E'],\n...    ['B', 'E']\n... ]\n>>> min_sup = 2\n>>> fp_tree, header_table = create_tree(data_set, min_sup)\n>>> fp_tree\nTreeNode('Null Set', 1, None)\n>>> transaction = ['A', 'B', 'E']\n>>> update_tree(transaction, fp_tree, header_table, 1)\n>>> fp_tree\nTreeNode('Null Set', 1, None)\n>>> fp_tree.children['A'].children['B'].children['E'].children\n{}\n>>> fp_tree.children['A'].children['B'].children['E'].count\n2\n>>> header_table['E'][1].name\n'E'"
  },
  {
    "function": "update_header",
    "code": "def update_header(node_to_test: TreeNode, target_node: TreeNode) -> TreeNode:\n    \"\"\"\n    Update the header table with a node link.\n\n    Args:\n        node_to_test: The node to be updated in the header table.\n        target_node: The node to link to.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> node1 = TreeNode(\"A\", 3, None)\n    >>> node2 = TreeNode(\"B\", 4, None)\n    >>> node1\n    TreeNode('A', 3, None)\n    >>> node1 = update_header(node1, node2)\n    >>> node1\n    TreeNode('A', 3, None)\n    >>> node1.node_link\n    TreeNode('B', 4, None)\n    >>> node2.node_link is None\n    True\n    \"\"\"\n    while node_to_test.node_link is not None:\n        node_to_test = node_to_test.node_link\n    if node_to_test.node_link is None:\n        node_to_test.node_link = target_node\n    # Return the updated node\n    return node_to_test",
    "docstring": "Update the header table with a node link.\n\nArgs:\n    node_to_test: The node to be updated in the header table.\n    target_node: The node to link to.\n\nExample:\n>>> data_set = [\n...    ['A', 'B', 'C'],\n...    ['A', 'C'],\n...    ['A', 'B', 'E'],\n...    ['A', 'B', 'C', 'E'],\n...    ['B', 'E']\n... ]\n>>> min_sup = 2\n>>> fp_tree, header_table = create_tree(data_set, min_sup)\n>>> fp_tree\nTreeNode('Null Set', 1, None)\n>>> node1 = TreeNode(\"A\", 3, None)\n>>> node2 = TreeNode(\"B\", 4, None)\n>>> node1\nTreeNode('A', 3, None)\n>>> node1 = update_header(node1, node2)\n>>> node1\nTreeNode('A', 3, None)\n>>> node1.node_link\nTreeNode('B', 4, None)\n>>> node2.node_link is None\nTrue"
  },
  {
    "function": "ascend_tree",
    "code": "def ascend_tree(leaf_node: TreeNode, prefix_path: list[str]) -> None:\n    \"\"\"\n    Ascend the FP-Tree from a leaf node to its root, adding item names to the prefix\n    path.\n\n    Args:\n        leaf_node: The leaf node to start ascending from.\n        prefix_path: A list to store the item as they are ascended.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n\n    >>> path = []\n    >>> ascend_tree(fp_tree.children['A'], path)\n    >>> path # ascending from a leaf node 'A'\n    ['A']\n    \"\"\"\n    if leaf_node.parent is not None:\n        prefix_path.append(leaf_node.name)\n        ascend_tree(leaf_node.parent, prefix_path)",
    "docstring": "Ascend the FP-Tree from a leaf node to its root, adding item names to the prefix\npath.\n\nArgs:\n    leaf_node: The leaf node to start ascending from.\n    prefix_path: A list to store the item as they are ascended.\n\nExample:\n>>> data_set = [\n...    ['A', 'B', 'C'],\n...    ['A', 'C'],\n...    ['A', 'B', 'E'],\n...    ['A', 'B', 'C', 'E'],\n...    ['B', 'E']\n... ]\n>>> min_sup = 2\n>>> fp_tree, header_table = create_tree(data_set, min_sup)\n\n>>> path = []\n>>> ascend_tree(fp_tree.children['A'], path)\n>>> path # ascending from a leaf node 'A'\n['A']"
  },
  {
    "function": "find_prefix_path",
    "code": "def find_prefix_path(base_pat: frozenset, tree_node: TreeNode | None) -> dict:  # noqa: ARG001\n    \"\"\"\n    Find the conditional pattern base for a given base pattern.\n\n    Args:\n        base_pat: The base pattern for which to find the conditional pattern base.\n        tree_node: The node in the FP-Tree.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> len(header_table)\n    4\n    >>> base_pattern = frozenset(['A'])\n    >>> sorted(find_prefix_path(base_pattern, fp_tree.children['A']))\n    []\n    \"\"\"\n    cond_pats: dict = {}\n    while tree_node is not None:\n        prefix_path: list = []\n        ascend_tree(tree_node, prefix_path)\n        if len(prefix_path) > 1:\n            cond_pats[frozenset(prefix_path[1:])] = tree_node.count\n        tree_node = tree_node.node_link\n    return cond_pats",
    "docstring": "Find the conditional pattern base for a given base pattern.\n\nArgs:\n    base_pat: The base pattern for which to find the conditional pattern base.\n    tree_node: The node in the FP-Tree.\n\nExample:\n>>> data_set = [\n...    ['A', 'B', 'C'],\n...    ['A', 'C'],\n...    ['A', 'B', 'E'],\n...    ['A', 'B', 'C', 'E'],\n...    ['B', 'E']\n... ]\n>>> min_sup = 2\n>>> fp_tree, header_table = create_tree(data_set, min_sup)\n>>> fp_tree\nTreeNode('Null Set', 1, None)\n>>> len(header_table)\n4\n>>> base_pattern = frozenset(['A'])\n>>> sorted(find_prefix_path(base_pattern, fp_tree.children['A']))\n[]"
  },
  {
    "function": "mine_tree",
    "code": "def mine_tree(\n    in_tree: TreeNode,  # noqa: ARG001\n    header_table: dict,\n    min_sup: int,\n    pre_fix: set,\n    freq_item_list: list,\n) -> None:\n    \"\"\"\n    Mine the FP-Tree recursively to discover frequent itemsets.\n\n    Args:\n        in_tree: The FP-Tree to mine.\n        header_table: The header table dictionary with item information.\n        min_sup: The minimum support threshold.\n        pre_fix: A set of items as a prefix for the itemsets being mined.\n        freq_item_list: A list to store the frequent itemsets.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> frequent_itemsets = []\n    >>> mine_tree(fp_tree, header_table, min_sup, set([]), frequent_itemsets)\n    >>> expe_itm = [{'C'}, {'C', 'A'}, {'E'}, {'A', 'E'}, {'E', 'B'}, {'A'}, {'B'}]\n    >>> all(expected in frequent_itemsets for expected in expe_itm)\n    True\n    \"\"\"\n    sorted_items = sorted(header_table.items(), key=lambda item_info: item_info[1][0])\n    big_l = [item[0] for item in sorted_items]\n    for base_pat in big_l:\n        new_freq_set = pre_fix.copy()\n        new_freq_set.add(base_pat)\n        freq_item_list.append(new_freq_set)\n        cond_patt_bases = find_prefix_path(base_pat, header_table[base_pat][1])\n        my_cond_tree, my_head = create_tree(list(cond_patt_bases), min_sup)\n        if my_head is not None:\n            # Pass header_table[base_pat][1] as node_to_test to update_header\n            header_table[base_pat][1] = update_header(\n                header_table[base_pat][1], my_cond_tree\n            )\n            mine_tree(my_cond_tree, my_head, min_sup, new_freq_set, freq_item_list)",
    "docstring": "Mine the FP-Tree recursively to discover frequent itemsets.\n\nArgs:\n    in_tree: The FP-Tree to mine.\n    header_table: The header table dictionary with item information.\n    min_sup: The minimum support threshold.\n    pre_fix: A set of items as a prefix for the itemsets being mined.\n    freq_item_list: A list to store the frequent itemsets.\n\nExample:\n>>> data_set = [\n...    ['A', 'B', 'C'],\n...    ['A', 'C'],\n...    ['A', 'B', 'E'],\n...    ['A', 'B', 'C', 'E'],\n...    ['B', 'E']\n... ]\n>>> min_sup = 2\n>>> fp_tree, header_table = create_tree(data_set, min_sup)\n>>> fp_tree\nTreeNode('Null Set', 1, None)\n>>> frequent_itemsets = []\n>>> mine_tree(fp_tree, header_table, min_sup, set([]), frequent_itemsets)\n>>> expe_itm = [{'C'}, {'C', 'A'}, {'E'}, {'A', 'E'}, {'E', 'B'}, {'A'}, {'B'}]\n>>> all(expected in frequent_itemsets for expected in expe_itm)\nTrue"
  },
  {
    "function": "_error",
    "code": "def _error(example_no, data_set=\"train\"):\n    \"\"\"\n    :param data_set: train data or test data\n    :param example_no: example number whose error has to be checked\n    :return: error in example pointed by example number.\n    \"\"\"\n    return calculate_hypothesis_value(example_no, data_set) - output(\n        example_no, data_set\n    )",
    "docstring": ":param data_set: train data or test data\n:param example_no: example number whose error has to be checked\n:return: error in example pointed by example number."
  },
  {
    "function": "_hypothesis_value",
    "code": "def _hypothesis_value(data_input_tuple):\n    \"\"\"\n    Calculates hypothesis function value for a given input\n    :param data_input_tuple: Input tuple of a particular example\n    :return: Value of hypothesis function at that point.\n    Note that there is an 'biased input' whose value is fixed as 1.\n    It is not explicitly mentioned in input data.. But, ML hypothesis functions use it.\n    So, we have to take care of it separately. Line 36 takes care of it.\n    \"\"\"\n    hyp_val = 0\n    for i in range(len(parameter_vector) - 1):\n        hyp_val += data_input_tuple[i] * parameter_vector[i + 1]\n    hyp_val += parameter_vector[0]\n    return hyp_val",
    "docstring": "Calculates hypothesis function value for a given input\n:param data_input_tuple: Input tuple of a particular example\n:return: Value of hypothesis function at that point.\nNote that there is an 'biased input' whose value is fixed as 1.\nIt is not explicitly mentioned in input data.. But, ML hypothesis functions use it.\nSo, we have to take care of it separately. Line 36 takes care of it."
  },
  {
    "function": "output",
    "code": "def output(example_no, data_set):\n    \"\"\"\n    :param data_set: test data or train data\n    :param example_no: example whose output is to be fetched\n    :return: output for that example\n    \"\"\"\n    if data_set == \"train\":\n        return train_data[example_no][1]\n    elif data_set == \"test\":\n        return test_data[example_no][1]\n    return None",
    "docstring": ":param data_set: test data or train data\n:param example_no: example whose output is to be fetched\n:return: output for that example"
  },
  {
    "function": "calculate_hypothesis_value",
    "code": "def calculate_hypothesis_value(example_no, data_set):\n    \"\"\"\n    Calculates hypothesis value for a given example\n    :param data_set: test data or train_data\n    :param example_no: example whose hypothesis value is to be calculated\n    :return: hypothesis value for that example\n    \"\"\"\n    if data_set == \"train\":\n        return _hypothesis_value(train_data[example_no][0])\n    elif data_set == \"test\":\n        return _hypothesis_value(test_data[example_no][0])\n    return None",
    "docstring": "Calculates hypothesis value for a given example\n:param data_set: test data or train_data\n:param example_no: example whose hypothesis value is to be calculated\n:return: hypothesis value for that example"
  },
  {
    "function": "summation_of_cost_derivative",
    "code": "def summation_of_cost_derivative(index, end=m):\n    \"\"\"\n    Calculates the sum of cost function derivative\n    :param index: index wrt derivative is being calculated\n    :param end: value where summation ends, default is m, number of examples\n    :return: Returns the summation of cost derivative\n    Note: If index is -1, this means we are calculating summation wrt to biased\n        parameter.\n    \"\"\"\n    summation_value = 0\n    for i in range(end):\n        if index == -1:\n            summation_value += _error(i)\n        else:\n            summation_value += _error(i) * train_data[i][0][index]\n    return summation_value",
    "docstring": "Calculates the sum of cost function derivative\n:param index: index wrt derivative is being calculated\n:param end: value where summation ends, default is m, number of examples\n:return: Returns the summation of cost derivative\nNote: If index is -1, this means we are calculating summation wrt to biased\n    parameter."
  },
  {
    "function": "get_cost_derivative",
    "code": "def get_cost_derivative(index):\n    \"\"\"\n    :param index: index of the parameter vector wrt to derivative is to be calculated\n    :return: derivative wrt to that index\n    Note: If index is -1, this means we are calculating summation wrt to biased\n        parameter.\n    \"\"\"\n    cost_derivative_value = summation_of_cost_derivative(index, m) / m\n    return cost_derivative_value",
    "docstring": ":param index: index of the parameter vector wrt to derivative is to be calculated\n:return: derivative wrt to that index\nNote: If index is -1, this means we are calculating summation wrt to biased\n    parameter."
  },
  {
    "function": "get_initial_centroids",
    "code": "def get_initial_centroids(data, k, seed=None):\n    \"\"\"Randomly choose k data points as initial centroids\"\"\"\n    # useful for obtaining consistent results\n    rng = np.random.default_rng(seed)\n    n = data.shape[0]  # number of data points\n\n    # Pick K indices from range [0, N).\n    rand_indices = rng.integers(0, n, k)\n\n    # Keep centroids as dense format, as many entries will be nonzero due to averaging.\n    # As long as at least one document in a cluster contains a word,\n    # it will carry a nonzero weight in the TF-IDF vector of the centroid.\n    centroids = data[rand_indices, :]\n\n    return centroids",
    "docstring": "Randomly choose k data points as initial centroids"
  },
  {
    "function": "kmeans",
    "code": "def kmeans(\n    data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False\n):\n    \"\"\"Runs k-means on given data and initial set of centroids.\n    maxiter: maximum number of iterations to run.(default=500)\n    record_heterogeneity: (optional) a list, to store the history of heterogeneity\n                          as function of iterations\n                          if None, do not store the history.\n    verbose: if True, print how many data points changed their cluster labels in\n                          each iteration\"\"\"\n    centroids = initial_centroids[:]\n    prev_cluster_assignment = None\n\n    for itr in range(maxiter):\n        if verbose:\n            print(itr, end=\"\")\n\n        # 1. Make cluster assignments using nearest centroids\n        cluster_assignment = assign_clusters(data, centroids)\n\n        # 2. Compute a new centroid for each of the k clusters, averaging all data\n        #    points assigned to that cluster.\n        centroids = revise_centroids(data, k, cluster_assignment)\n\n        # Check for convergence: if none of the assignments changed, stop\n        if (\n            prev_cluster_assignment is not None\n            and (prev_cluster_assignment == cluster_assignment).all()\n        ):\n            break\n\n        # Print number of new assignments\n        if prev_cluster_assignment is not None:\n            num_changed = np.sum(prev_cluster_assignment != cluster_assignment)\n            if verbose:\n                print(\n                    f\"    {num_changed:5d} elements changed their cluster assignment.\"\n                )\n\n        # Record heterogeneity convergence metric\n        if record_heterogeneity is not None:\n            # YOUR CODE HERE\n            score = compute_heterogeneity(data, k, centroids, cluster_assignment)\n            record_heterogeneity.append(score)\n\n        prev_cluster_assignment = cluster_assignment[:]\n\n    return centroids, cluster_assignment",
    "docstring": "Runs k-means on given data and initial set of centroids.\nmaxiter: maximum number of iterations to run.(default=500)\nrecord_heterogeneity: (optional) a list, to store the history of heterogeneity\n                      as function of iterations\n                      if None, do not store the history.\nverbose: if True, print how many data points changed their cluster labels in\n                      each iteration"
  },
  {
    "function": "report_generator",
    "code": "def report_generator(\n    predicted: pd.DataFrame, clustering_variables: np.ndarray, fill_missing_report=None\n) -> pd.DataFrame:\n    \"\"\"\n    Generate a clustering report given these two arguments:\n        predicted - dataframe with predicted cluster column\n        fill_missing_report - dictionary of rules on how we are going to fill in missing\n        values for final generated report (not included in modelling);\n    >>> predicted = pd.DataFrame()\n    >>> predicted['numbers'] = [1, 2, 3]\n    >>> predicted['col1'] = [0.5, 2.5, 4.5]\n    >>> predicted['col2'] = [100, 200, 300]\n    >>> predicted['col3'] = [10, 20, 30]\n    >>> predicted['Cluster'] = [1, 1, 2]\n    >>> report_generator(predicted, ['col1', 'col2'], 0)\n               Features               Type   Mark           1           2\n    0    # of Customers        ClusterSize  False    2.000000    1.000000\n    1    % of Customers  ClusterProportion  False    0.666667    0.333333\n    2              col1    mean_with_zeros   True    1.500000    4.500000\n    3              col2    mean_with_zeros   True  150.000000  300.000000\n    4           numbers    mean_with_zeros  False    1.500000    3.000000\n    ..              ...                ...    ...         ...         ...\n    99            dummy                 5%  False    1.000000    1.000000\n    100           dummy                95%  False    1.000000    1.000000\n    101           dummy              stdev  False    0.000000         NaN\n    102           dummy               mode  False    1.000000    1.000000\n    103           dummy             median  False    1.000000    1.000000\n    <BLANKLINE>\n    [104 rows x 5 columns]\n    \"\"\"\n    # Fill missing values with given rules\n    if fill_missing_report:\n        predicted = predicted.fillna(value=fill_missing_report)\n    predicted[\"dummy\"] = 1\n    numeric_cols = predicted.select_dtypes(np.number).columns\n    report = (\n        predicted.groupby([\"Cluster\"])[  # construct report dataframe\n            numeric_cols\n        ]  # group by cluster number\n        .agg(\n            [\n                (\"sum\", \"sum\"),\n                (\"mean_with_zeros\", lambda x: np.mean(np.nan_to_num(x))),\n                (\"mean_without_zeros\", lambda x: x.replace(0, np.nan).mean()),\n                (\n                    \"mean_25-75\",\n                    lambda x: np.mean(\n                        np.nan_to_num(\n                            sorted(x)[\n                                round(len(x) * 25 / 100) : round(len(x) * 75 / 100)\n                            ]\n                        )\n                    ),\n                ),\n                (\"mean_with_na\", \"mean\"),\n                (\"min\", lambda x: x.min()),\n                (\"5%\", lambda x: x.quantile(0.05)),\n                (\"25%\", lambda x: x.quantile(0.25)),\n                (\"50%\", lambda x: x.quantile(0.50)),\n                (\"75%\", lambda x: x.quantile(0.75)),\n                (\"95%\", lambda x: x.quantile(0.95)),\n                (\"max\", lambda x: x.max()),\n                (\"count\", lambda x: x.count()),\n                (\"stdev\", lambda x: x.std()),\n                (\"mode\", lambda x: x.mode()[0]),\n                (\"median\", lambda x: x.median()),\n                (\"# > 0\", lambda x: (x > 0).sum()),\n            ]\n        )\n        .T.reset_index()\n        .rename(index=str, columns={\"level_0\": \"Features\", \"level_1\": \"Type\"})\n    )  # rename columns\n    # calculate the size of cluster(count of clientID's)\n    # avoid SettingWithCopyWarning\n    clustersize = report[\n        (report[\"Features\"] == \"dummy\") & (report[\"Type\"] == \"count\")\n    ].copy()\n    # rename created predicted cluster to match report column names\n    clustersize.Type = \"ClusterSize\"\n    clustersize.Features = \"# of Customers\"\n    # calculating the proportion of cluster\n    clusterproportion = pd.DataFrame(\n        clustersize.iloc[:, 2:].to_numpy() / clustersize.iloc[:, 2:].to_numpy().sum()\n    )\n    # rename created predicted cluster to match report column names\n    clusterproportion[\"Type\"] = \"% of Customers\"\n    clusterproportion[\"Features\"] = \"ClusterProportion\"\n    cols = clusterproportion.columns.tolist()\n    cols = cols[-2:] + cols[:-2]\n    clusterproportion = clusterproportion[cols]  # rearrange columns to match report\n    clusterproportion.columns = report.columns\n    # generating dataframe with count of nan values\n    a = pd.DataFrame(\n        abs(\n            report[report[\"Type\"] == \"count\"].iloc[:, 2:].to_numpy()\n            - clustersize.iloc[:, 2:].to_numpy()\n        )\n    )\n    a[\"Features\"] = 0\n    a[\"Type\"] = \"# of nan\"\n    # filling values in order to match report\n    a.Features = report[report[\"Type\"] == \"count\"].Features.tolist()\n    cols = a.columns.tolist()\n    cols = cols[-2:] + cols[:-2]\n    a = a[cols]  # rearrange columns to match report\n    a.columns = report.columns  # rename columns to match report\n    # drop count values except for cluster size\n    report = report.drop(report[report.Type == \"count\"].index)\n    # concat report with cluster size and nan values\n    report = pd.concat([report, a, clustersize, clusterproportion], axis=0)\n    report[\"Mark\"] = report[\"Features\"].isin(clustering_variables)\n    cols = report.columns.tolist()\n    cols = cols[0:2] + cols[-1:] + cols[2:-1]\n    report = report[cols]\n    sorter1 = {\n        \"ClusterSize\": 9,\n        \"ClusterProportion\": 8,\n        \"mean_with_zeros\": 7,\n        \"mean_with_na\": 6,\n        \"max\": 5,\n        \"50%\": 4,\n        \"min\": 3,\n        \"25%\": 2,\n        \"75%\": 1,\n        \"# of nan\": 0,\n        \"# > 0\": -1,\n        \"sum_with_na\": -2,\n    }\n    report = (\n        report.assign(\n            Sorter1=lambda x: x.Type.map(sorter1),\n            Sorter2=lambda x: list(reversed(range(len(x)))),\n        )\n        .sort_values([\"Sorter1\", \"Mark\", \"Sorter2\"], ascending=False)\n        .drop([\"Sorter1\", \"Sorter2\"], axis=1)\n    )\n    report.columns.name = \"\"\n    report = report.reset_index()\n    report = report.drop(columns=[\"index\"])\n    return report",
    "docstring": "Generate a clustering report given these two arguments:\n    predicted - dataframe with predicted cluster column\n    fill_missing_report - dictionary of rules on how we are going to fill in missing\n    values for final generated report (not included in modelling);\n>>> predicted = pd.DataFrame()\n>>> predicted['numbers'] = [1, 2, 3]\n>>> predicted['col1'] = [0.5, 2.5, 4.5]\n>>> predicted['col2'] = [100, 200, 300]\n>>> predicted['col3'] = [10, 20, 30]\n>>> predicted['Cluster'] = [1, 1, 2]\n>>> report_generator(predicted, ['col1', 'col2'], 0)\n           Features               Type   Mark           1           2\n0    # of Customers        ClusterSize  False    2.000000    1.000000\n1    % of Customers  ClusterProportion  False    0.666667    0.333333\n2              col1    mean_with_zeros   True    1.500000    4.500000\n3              col2    mean_with_zeros   True  150.000000  300.000000\n4           numbers    mean_with_zeros  False    1.500000    3.000000\n..              ...                ...    ...         ...         ...\n99            dummy                 5%  False    1.000000    1.000000\n100           dummy                95%  False    1.000000    1.000000\n101           dummy              stdev  False    0.000000         NaN\n102           dummy               mode  False    1.000000    1.000000\n103           dummy             median  False    1.000000    1.000000\n<BLANKLINE>\n[104 rows x 5 columns]"
  },
  {
    "function": "gaussian_distribution",
    "code": "def gaussian_distribution(mean: float, std_dev: float, instance_count: int) -> list:\n    \"\"\"\n    Generate gaussian distribution instances based-on given mean and standard deviation\n    :param mean: mean value of class\n    :param std_dev: value of standard deviation entered by usr or default value of it\n    :param instance_count: instance number of class\n    :return: a list containing generated values based-on given mean, std_dev and\n        instance_count\n\n    >>> gaussian_distribution(5.0, 1.0, 20) # doctest: +NORMALIZE_WHITESPACE\n    [6.288184753155463, 6.4494456086997705, 5.066335808938262, 4.235456349028368,\n     3.9078267848958586, 5.031334516831717, 3.977896829989127, 3.56317055489747,\n      5.199311976483754, 5.133374604658605, 5.546468300338232, 4.086029056264687,\n       5.005005283626573, 4.935258239627312, 3.494170998739258, 5.537997178661033,\n        5.320711100998849, 7.3891120432406865, 5.202969177309964, 4.855297691835079]\n    \"\"\"\n    seed(1)\n    return [gauss(mean, std_dev) for _ in range(instance_count)]",
    "docstring": "Generate gaussian distribution instances based-on given mean and standard deviation\n:param mean: mean value of class\n:param std_dev: value of standard deviation entered by usr or default value of it\n:param instance_count: instance number of class\n:return: a list containing generated values based-on given mean, std_dev and\n    instance_count\n\n>>> gaussian_distribution(5.0, 1.0, 20) # doctest: +NORMALIZE_WHITESPACE\n[6.288184753155463, 6.4494456086997705, 5.066335808938262, 4.235456349028368,\n 3.9078267848958586, 5.031334516831717, 3.977896829989127, 3.56317055489747,\n  5.199311976483754, 5.133374604658605, 5.546468300338232, 4.086029056264687,\n   5.005005283626573, 4.935258239627312, 3.494170998739258, 5.537997178661033,\n    5.320711100998849, 7.3891120432406865, 5.202969177309964, 4.855297691835079]"
  },
  {
    "function": "y_generator",
    "code": "def y_generator(class_count: int, instance_count: list) -> list:\n    \"\"\"\n    Generate y values for corresponding classes\n    :param class_count: Number of classes(data groupings) in dataset\n    :param instance_count: number of instances in class\n    :return: corresponding values for data groupings in dataset\n\n    >>> y_generator(1, [10])\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    >>> y_generator(2, [5, 10])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    return [k for k in range(class_count) for _ in range(instance_count[k])]",
    "docstring": "Generate y values for corresponding classes\n:param class_count: Number of classes(data groupings) in dataset\n:param instance_count: number of instances in class\n:return: corresponding values for data groupings in dataset\n\n>>> y_generator(1, [10])\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n>>> y_generator(2, [5, 10])\n[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n>>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]"
  },
  {
    "function": "calculate_mean",
    "code": "def calculate_mean(instance_count: int, items: list) -> float:\n    \"\"\"\n    Calculate given class mean\n    :param instance_count: Number of instances in class\n    :param items: items that related to specific class(data grouping)\n    :return: calculated actual mean of considered class\n\n    >>> items = gaussian_distribution(5.0, 1.0, 20)\n    >>> calculate_mean(len(items), items)\n    5.011267842911003\n    \"\"\"\n    # the sum of all items divided by number of instances\n    return sum(items) / instance_count",
    "docstring": "Calculate given class mean\n:param instance_count: Number of instances in class\n:param items: items that related to specific class(data grouping)\n:return: calculated actual mean of considered class\n\n>>> items = gaussian_distribution(5.0, 1.0, 20)\n>>> calculate_mean(len(items), items)\n5.011267842911003"
  },
  {
    "function": "calculate_probabilities",
    "code": "def calculate_probabilities(instance_count: int, total_count: int) -> float:\n    \"\"\"\n    Calculate the probability that a given instance will belong to which class\n    :param instance_count: number of instances in class\n    :param total_count: the number of all instances\n    :return: value of probability for considered class\n\n    >>> calculate_probabilities(20, 60)\n    0.3333333333333333\n    >>> calculate_probabilities(30, 100)\n    0.3\n    \"\"\"\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count",
    "docstring": "Calculate the probability that a given instance will belong to which class\n:param instance_count: number of instances in class\n:param total_count: the number of all instances\n:return: value of probability for considered class\n\n>>> calculate_probabilities(20, 60)\n0.3333333333333333\n>>> calculate_probabilities(30, 100)\n0.3"
  },
  {
    "function": "calculate_variance",
    "code": "def calculate_variance(items: list, means: list, total_count: int) -> float:\n    \"\"\"\n    Calculate the variance\n    :param items: a list containing all items(gaussian distribution of all classes)\n    :param means: a list containing real mean values of each class\n    :param total_count: the number of all instances\n    :return: calculated variance for considered dataset\n\n    >>> items = gaussian_distribution(5.0, 1.0, 20)\n    >>> means = [5.011267842911003]\n    >>> total_count = 20\n    >>> calculate_variance([items], means, total_count)\n    0.9618530973487491\n    \"\"\"\n    squared_diff = []  # An empty list to store all squared differences\n    # iterate over number of elements in items\n    for i in range(len(items)):\n        # for loop iterates over number of elements in inner layer of items\n        for j in range(len(items[i])):\n            # appending squared differences to 'squared_diff' list\n            squared_diff.append((items[i][j] - means[i]) ** 2)\n\n    # one divided by (the number of all instances - number of classes) multiplied by\n    # sum of all squared differences\n    n_classes = len(means)  # Number of classes in dataset\n    return 1 / (total_count - n_classes) * sum(squared_diff)",
    "docstring": "Calculate the variance\n:param items: a list containing all items(gaussian distribution of all classes)\n:param means: a list containing real mean values of each class\n:param total_count: the number of all instances\n:return: calculated variance for considered dataset\n\n>>> items = gaussian_distribution(5.0, 1.0, 20)\n>>> means = [5.011267842911003]\n>>> total_count = 20\n>>> calculate_variance([items], means, total_count)\n0.9618530973487491"
  },
  {
    "function": "predict_y_values",
    "code": "def predict_y_values(\n    x_items: list, means: list, variance: float, probabilities: list\n) -> list:\n    \"\"\"This function predicts new indexes(groups for our data)\n    :param x_items: a list containing all items(gaussian distribution of all classes)\n    :param means: a list containing real mean values of each class\n    :param variance: calculated value of variance by calculate_variance function\n    :param probabilities: a list containing all probabilities of classes\n    :return: a list containing predicted Y values\n\n    >>> x_items = [[6.288184753155463, 6.4494456086997705, 5.066335808938262,\n    ...                4.235456349028368, 3.9078267848958586, 5.031334516831717,\n    ...                3.977896829989127, 3.56317055489747, 5.199311976483754,\n    ...                5.133374604658605, 5.546468300338232, 4.086029056264687,\n    ...                5.005005283626573, 4.935258239627312, 3.494170998739258,\n    ...                5.537997178661033, 5.320711100998849, 7.3891120432406865,\n    ...                5.202969177309964, 4.855297691835079], [11.288184753155463,\n    ...                11.44944560869977, 10.066335808938263, 9.235456349028368,\n    ...                8.907826784895859, 10.031334516831716, 8.977896829989128,\n    ...                8.56317055489747, 10.199311976483754, 10.133374604658606,\n    ...                10.546468300338232, 9.086029056264687, 10.005005283626572,\n    ...                9.935258239627313, 8.494170998739259, 10.537997178661033,\n    ...                10.320711100998848, 12.389112043240686, 10.202969177309964,\n    ...                9.85529769183508], [16.288184753155463, 16.449445608699772,\n    ...                15.066335808938263, 14.235456349028368, 13.907826784895859,\n    ...                15.031334516831716, 13.977896829989128, 13.56317055489747,\n    ...                15.199311976483754, 15.133374604658606, 15.546468300338232,\n    ...                14.086029056264687, 15.005005283626572, 14.935258239627313,\n    ...                13.494170998739259, 15.537997178661033, 15.320711100998848,\n    ...                17.389112043240686, 15.202969177309964, 14.85529769183508]]\n\n    >>> means = [5.011267842911003, 10.011267842911003, 15.011267842911002]\n    >>> variance = 0.9618530973487494\n    >>> probabilities = [0.3333333333333333, 0.3333333333333333, 0.3333333333333333]\n    >>> predict_y_values(x_items, means, variance,\n    ...                  probabilities)  # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2]\n\n    \"\"\"\n    # An empty list to store generated discriminant values of all items in dataset for\n    # each class\n    results = []\n    # for loop iterates over number of elements in list\n    for i in range(len(x_items)):\n        # for loop iterates over number of inner items of each element\n        for j in range(len(x_items[i])):\n            temp = []  # to store all discriminant values of each item as a list\n            # for loop iterates over number of classes we have in our dataset\n            for k in range(len(x_items)):\n                # appending values of discriminants for each class to 'temp' list\n                temp.append(\n                    x_items[i][j] * (means[k] / variance)\n                    - (means[k] ** 2 / (2 * variance))\n                    + log(probabilities[k])\n                )\n            # appending discriminant values of each item to 'results' list\n            results.append(temp)\n\n    return [result.index(max(result)) for result in results]",
    "docstring": "This function predicts new indexes(groups for our data)\n:param x_items: a list containing all items(gaussian distribution of all classes)\n:param means: a list containing real mean values of each class\n:param variance: calculated value of variance by calculate_variance function\n:param probabilities: a list containing all probabilities of classes\n:return: a list containing predicted Y values\n\n>>> x_items = [[6.288184753155463, 6.4494456086997705, 5.066335808938262,\n...                4.235456349028368, 3.9078267848958586, 5.031334516831717,\n...                3.977896829989127, 3.56317055489747, 5.199311976483754,\n...                5.133374604658605, 5.546468300338232, 4.086029056264687,\n...                5.005005283626573, 4.935258239627312, 3.494170998739258,\n...                5.537997178661033, 5.320711100998849, 7.3891120432406865,\n...                5.202969177309964, 4.855297691835079], [11.288184753155463,\n...                11.44944560869977, 10.066335808938263, 9.235456349028368,\n...                8.907826784895859, 10.031334516831716, 8.977896829989128,\n...                8.56317055489747, 10.199311976483754, 10.133374604658606,\n...                10.546468300338232, 9.086029056264687, 10.005005283626572,\n...                9.935258239627313, 8.494170998739259, 10.537997178661033,\n...                10.320711100998848, 12.389112043240686, 10.202969177309964,\n...                9.85529769183508], [16.288184753155463, 16.449445608699772,\n...                15.066335808938263, 14.235456349028368, 13.907826784895859,\n...                15.031334516831716, 13.977896829989128, 13.56317055489747,\n...                15.199311976483754, 15.133374604658606, 15.546468300338232,\n...                14.086029056264687, 15.005005283626572, 14.935258239627313,\n...                13.494170998739259, 15.537997178661033, 15.320711100998848,\n...                17.389112043240686, 15.202969177309964, 14.85529769183508]]\n\n>>> means = [5.011267842911003, 10.011267842911003, 15.011267842911002]\n>>> variance = 0.9618530973487494\n>>> probabilities = [0.3333333333333333, 0.3333333333333333, 0.3333333333333333]\n>>> predict_y_values(x_items, means, variance,\n...                  probabilities)  # doctest: +NORMALIZE_WHITESPACE\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n2, 2, 2, 2, 2, 2, 2, 2, 2]"
  },
  {
    "function": "accuracy",
    "code": "def accuracy(actual_y: list, predicted_y: list) -> float:\n    \"\"\"\n    Calculate the value of accuracy based-on predictions\n    :param actual_y:a list containing initial Y values generated by 'y_generator'\n        function\n    :param predicted_y: a list containing predicted Y values generated by\n        'predict_y_values' function\n    :return: percentage of accuracy\n\n    >>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\n    ... 1, 1 ,1 ,1 ,1 ,1 ,1]\n    >>> predicted_y = [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0,\n    ... 0, 0, 1, 1, 1, 0, 1, 1, 1]\n    >>> accuracy(actual_y, predicted_y)\n    50.0\n\n    >>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\n    ... 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n    >>> predicted_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,\n    ... 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n    >>> accuracy(actual_y, predicted_y)\n    100.0\n    \"\"\"\n    # iterate over one element of each list at a time (zip mode)\n    # prediction is correct if actual Y value equals to predicted Y value\n    correct = sum(1 for i, j in zip(actual_y, predicted_y) if i == j)\n    # percentage of accuracy equals to number of correct predictions divided by number\n    # of all data and multiplied by 100\n    return (correct / len(actual_y)) * 100",
    "docstring": "Calculate the value of accuracy based-on predictions\n:param actual_y:a list containing initial Y values generated by 'y_generator'\n    function\n:param predicted_y: a list containing predicted Y values generated by\n    'predict_y_values' function\n:return: percentage of accuracy\n\n>>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\n... 1, 1 ,1 ,1 ,1 ,1 ,1]\n>>> predicted_y = [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0,\n... 0, 0, 1, 1, 1, 0, 1, 1, 1]\n>>> accuracy(actual_y, predicted_y)\n50.0\n\n>>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\n... 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n>>> predicted_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,\n... 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n>>> accuracy(actual_y, predicted_y)\n100.0"
  },
  {
    "function": "valid_input",
    "code": "def valid_input(\n    input_type: Callable[[object], num],  # Usually float or int\n    input_msg: str,\n    err_msg: str,\n    condition: Callable[[num], bool] = lambda _: True,\n    default: str | None = None,\n) -> num:\n    \"\"\"\n    Ask for user value and validate that it fulfill a condition.\n\n    :input_type: user input expected type of value\n    :input_msg: message to show user in the screen\n    :err_msg: message to show in the screen in case of error\n    :condition: function that represents the condition that user input is valid.\n    :default: Default value in case the user does not type anything\n    :return: user's input\n    \"\"\"\n    while True:\n        try:\n            user_input = input_type(input(input_msg).strip() or default)\n            if condition(user_input):\n                return user_input\n            else:\n                print(f\"{user_input}: {err_msg}\")\n                continue\n        except ValueError:\n            print(\n                f\"{user_input}: Incorrect input type, expected {input_type.__name__!r}\"\n            )",
    "docstring": "Ask for user value and validate that it fulfill a condition.\n\n:input_type: user input expected type of value\n:input_msg: message to show user in the screen\n:err_msg: message to show in the screen in case of error\n:condition: function that represents the condition that user input is valid.\n:default: Default value in case the user does not type anything\n:return: user's input"
  },
  {
    "function": "main",
    "code": "def main():\n    \"\"\"This function starts execution phase\"\"\"\n    while True:\n        print(\" Linear Discriminant Analysis \".center(50, \"*\"))\n        print(\"*\" * 50, \"\\n\")\n        print(\"First of all we should specify the number of classes that\")\n        print(\"we want to generate as training dataset\")\n        # Trying to get number of classes\n        n_classes = valid_input(\n            input_type=int,\n            condition=lambda x: x > 0,\n            input_msg=\"Enter the number of classes (Data Groupings): \",\n            err_msg=\"Number of classes should be positive!\",\n        )\n\n        print(\"-\" * 100)\n\n        # Trying to get the value of standard deviation\n        std_dev = valid_input(\n            input_type=float,\n            condition=lambda x: x >= 0,\n            input_msg=(\n                \"Enter the value of standard deviation\"\n                \"(Default value is 1.0 for all classes): \"\n            ),\n            err_msg=\"Standard deviation should not be negative!\",\n            default=\"1.0\",\n        )\n\n        print(\"-\" * 100)\n\n        # Trying to get number of instances in classes and theirs means to generate\n        # dataset\n        counts = []  # An empty list to store instance counts of classes in dataset\n        for i in range(n_classes):\n            user_count = valid_input(\n                input_type=int,\n                condition=lambda x: x > 0,\n                input_msg=(f\"Enter The number of instances for class_{i + 1}: \"),\n                err_msg=\"Number of instances should be positive!\",\n            )\n            counts.append(user_count)\n        print(\"-\" * 100)\n\n        # An empty list to store values of user-entered means of classes\n        user_means = []\n        for a in range(n_classes):\n            user_mean = valid_input(\n                input_type=float,\n                input_msg=(f\"Enter the value of mean for class_{a + 1}: \"),\n                err_msg=\"This is an invalid value.\",\n            )\n            user_means.append(user_mean)\n        print(\"-\" * 100)\n\n        print(\"Standard deviation: \", std_dev)\n        # print out the number of instances in classes in separated line\n        for i, count in enumerate(counts, 1):\n            print(f\"Number of instances in class_{i} is: {count}\")\n        print(\"-\" * 100)\n\n        # print out mean values of classes separated line\n        for i, user_mean in enumerate(user_means, 1):\n            print(f\"Mean of class_{i} is: {user_mean}\")\n        print(\"-\" * 100)\n\n        # Generating training dataset drawn from gaussian distribution\n        x = [\n            gaussian_distribution(user_means[j], std_dev, counts[j])\n            for j in range(n_classes)\n        ]\n        print(\"Generated Normal Distribution: \\n\", x)\n        print(\"-\" * 100)\n\n        # Generating Ys to detecting corresponding classes\n        y = y_generator(n_classes, counts)\n        print(\"Generated Corresponding Ys: \\n\", y)\n        print(\"-\" * 100)\n\n        # Calculating the value of actual mean for each class\n        actual_means = [calculate_mean(counts[k], x[k]) for k in range(n_classes)]\n        # for loop iterates over number of elements in 'actual_means' list and print\n        # out them in separated line\n        for i, actual_mean in enumerate(actual_means, 1):\n            print(f\"Actual(Real) mean of class_{i} is: {actual_mean}\")\n        print(\"-\" * 100)\n\n        # Calculating the value of probabilities for each class\n        probabilities = [\n            calculate_probabilities(counts[i], sum(counts)) for i in range(n_classes)\n        ]\n\n        # for loop iterates over number of elements in 'probabilities' list and print\n        # out them in separated line\n        for i, probability in enumerate(probabilities, 1):\n            print(f\"Probability of class_{i} is: {probability}\")\n        print(\"-\" * 100)\n\n        # Calculating the values of variance for each class\n        variance = calculate_variance(x, actual_means, sum(counts))\n        print(\"Variance: \", variance)\n        print(\"-\" * 100)\n\n        # Predicting Y values\n        # storing predicted Y values in 'pre_indexes' variable\n        pre_indexes = predict_y_values(x, actual_means, variance, probabilities)\n        print(\"-\" * 100)\n\n        # Calculating Accuracy of the model\n        print(f\"Accuracy: {accuracy(y, pre_indexes)}\")\n        print(\"-\" * 100)\n        print(\" DONE \".center(100, \"+\"))\n\n        if input(\"Press any key to restart or 'q' for quit: \").strip().lower() == \"q\":\n            print(\"\\n\" + \"GoodBye!\".center(100, \"-\") + \"\\n\")\n            break\n        system(\"cls\" if name == \"nt\" else \"clear\")  # noqa: S605",
    "docstring": "This function starts execution phase"
  },
  {
    "function": "collect_dataset",
    "code": "def collect_dataset():\n    \"\"\"Collect dataset of CSGO\n    The dataset contains ADR vs Rating of a Player\n    :return : dataset obtained from the link, as matrix\n    \"\"\"\n    response = httpx.get(\n        \"https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/\"\n        \"master/Week1/ADRvsRating.csv\",\n        timeout=10,\n    )\n    lines = response.text.splitlines()\n    data = []\n    for item in lines:\n        item = item.split(\",\")\n        data.append(item)\n    data.pop(0)  # This is for removing the labels from the list\n    dataset = np.matrix(data)\n    return dataset",
    "docstring": "Collect dataset of CSGO\nThe dataset contains ADR vs Rating of a Player\n:return : dataset obtained from the link, as matrix"
  },
  {
    "function": "run_steep_gradient_descent",
    "code": "def run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta):\n    \"\"\"Run steep gradient descent and updates the Feature vector accordingly_\n    :param data_x   : contains the dataset\n    :param data_y   : contains the output associated with each data-entry\n    :param len_data : length of the data_\n    :param alpha    : Learning rate of the model\n    :param theta    : Feature vector (weight's for our model)\n    ;param return    : Updated Feature's, using\n                       curr_features - alpha_ * gradient(w.r.t. feature)\n    >>> import numpy as np\n    >>> data_x = np.array([[1, 2], [3, 4]])\n    >>> data_y = np.array([5, 6])\n    >>> len_data = len(data_x)\n    >>> alpha = 0.01\n    >>> theta = np.array([0.1, 0.2])\n    >>> run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)\n    array([0.196, 0.343])\n    \"\"\"\n    n = len_data\n\n    prod = np.dot(theta, data_x.transpose())\n    prod -= data_y.transpose()\n    sum_grad = np.dot(prod, data_x)\n    theta = theta - (alpha / n) * sum_grad\n    return theta",
    "docstring": "Run steep gradient descent and updates the Feature vector accordingly_\n:param data_x   : contains the dataset\n:param data_y   : contains the output associated with each data-entry\n:param len_data : length of the data_\n:param alpha    : Learning rate of the model\n:param theta    : Feature vector (weight's for our model)\n;param return    : Updated Feature's, using\n                   curr_features - alpha_ * gradient(w.r.t. feature)\n>>> import numpy as np\n>>> data_x = np.array([[1, 2], [3, 4]])\n>>> data_y = np.array([5, 6])\n>>> len_data = len(data_x)\n>>> alpha = 0.01\n>>> theta = np.array([0.1, 0.2])\n>>> run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)\narray([0.196, 0.343])"
  },
  {
    "function": "sum_of_square_error",
    "code": "def sum_of_square_error(data_x, data_y, len_data, theta):\n    \"\"\"Return sum of square error for error calculation\n    :param data_x    : contains our dataset\n    :param data_y    : contains the output (result vector)\n    :param len_data  : len of the dataset\n    :param theta     : contains the feature vector\n    :return          : sum of square error computed from given feature's\n\n    Example:\n    >>> vc_x = np.array([[1.1], [2.1], [3.1]])\n    >>> vc_y = np.array([1.2, 2.2, 3.2])\n    >>> round(sum_of_square_error(vc_x, vc_y, 3, np.array([1])),3)\n    np.float64(0.005)\n    \"\"\"\n    prod = np.dot(theta, data_x.transpose())\n    prod -= data_y.transpose()\n    sum_elem = np.sum(np.square(prod))\n    error = sum_elem / (2 * len_data)\n    return error",
    "docstring": "Return sum of square error for error calculation\n:param data_x    : contains our dataset\n:param data_y    : contains the output (result vector)\n:param len_data  : len of the dataset\n:param theta     : contains the feature vector\n:return          : sum of square error computed from given feature's\n\nExample:\n>>> vc_x = np.array([[1.1], [2.1], [3.1]])\n>>> vc_y = np.array([1.2, 2.2, 3.2])\n>>> round(sum_of_square_error(vc_x, vc_y, 3, np.array([1])),3)\nnp.float64(0.005)"
  },
  {
    "function": "run_linear_regression",
    "code": "def run_linear_regression(data_x, data_y):\n    \"\"\"Implement Linear regression over the dataset\n    :param data_x  : contains our dataset\n    :param data_y  : contains the output (result vector)\n    :return        : feature for line of best fit (Feature vector)\n    \"\"\"\n    iterations = 100000\n    alpha = 0.0001550\n\n    no_features = data_x.shape[1]\n    len_data = data_x.shape[0] - 1\n\n    theta = np.zeros((1, no_features))\n\n    for i in range(iterations):\n        theta = run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)\n        error = sum_of_square_error(data_x, data_y, len_data, theta)\n        print(f\"At Iteration {i + 1} - Error is {error:.5f}\")\n\n    return theta",
    "docstring": "Implement Linear regression over the dataset\n:param data_x  : contains our dataset\n:param data_y  : contains the output (result vector)\n:return        : feature for line of best fit (Feature vector)"
  },
  {
    "function": "mean_absolute_error",
    "code": "def mean_absolute_error(predicted_y, original_y):\n    \"\"\"Return sum of square error for error calculation\n    :param predicted_y   : contains the output of prediction (result vector)\n    :param original_y    : contains values of expected outcome\n    :return          : mean absolute error computed from given feature's\n\n    >>> predicted_y = [3, -0.5, 2, 7]\n    >>> original_y = [2.5, 0.0, 2, 8]\n    >>> mean_absolute_error(predicted_y, original_y)\n    0.5\n    \"\"\"\n    total = sum(abs(y - predicted_y[i]) for i, y in enumerate(original_y))\n    return total / len(original_y)",
    "docstring": "Return sum of square error for error calculation\n:param predicted_y   : contains the output of prediction (result vector)\n:param original_y    : contains values of expected outcome\n:return          : mean absolute error computed from given feature's\n\n>>> predicted_y = [3, -0.5, 2, 7]\n>>> original_y = [2.5, 0.0, 2, 8]\n>>> mean_absolute_error(predicted_y, original_y)\n0.5"
  },
  {
    "function": "sigmoid_function",
    "code": "def sigmoid_function(z: float | np.ndarray) -> float | np.ndarray:\n    \"\"\"\n    Also known as Logistic Function.\n\n                1\n    f(x) =   -------\n              1 + e\u207b\u02e3\n\n    The sigmoid function approaches a value of 1 as its input 'x' becomes\n    increasing positive. Opposite for negative values.\n\n    Reference: https://en.wikipedia.org/wiki/Sigmoid_function\n\n    @param z:  input to the function\n    @returns: returns value in the range 0 to 1\n\n    Examples:\n    >>> float(sigmoid_function(4))\n    0.9820137900379085\n    >>> sigmoid_function(np.array([-3, 3]))\n    array([0.04742587, 0.95257413])\n    >>> sigmoid_function(np.array([-3, 3, 1]))\n    array([0.04742587, 0.95257413, 0.73105858])\n    >>> sigmoid_function(np.array([-0.01, -2, -1.9]))\n    array([0.49750002, 0.11920292, 0.13010847])\n    >>> sigmoid_function(np.array([-1.3, 5.3, 12]))\n    array([0.21416502, 0.9950332 , 0.99999386])\n    >>> sigmoid_function(np.array([0.01, 0.02, 4.1]))\n    array([0.50249998, 0.50499983, 0.9836975 ])\n    >>> sigmoid_function(np.array([0.8]))\n    array([0.68997448])\n    \"\"\"\n    return 1 / (1 + np.exp(-z))",
    "docstring": "Also known as Logistic Function.\n\n            1\nf(x) =   -------\n          1 + e\u207b\u02e3\n\nThe sigmoid function approaches a value of 1 as its input 'x' becomes\nincreasing positive. Opposite for negative values.\n\nReference: https://en.wikipedia.org/wiki/Sigmoid_function\n\n@param z:  input to the function\n@returns: returns value in the range 0 to 1\n\nExamples:\n>>> float(sigmoid_function(4))\n0.9820137900379085\n>>> sigmoid_function(np.array([-3, 3]))\narray([0.04742587, 0.95257413])\n>>> sigmoid_function(np.array([-3, 3, 1]))\narray([0.04742587, 0.95257413, 0.73105858])\n>>> sigmoid_function(np.array([-0.01, -2, -1.9]))\narray([0.49750002, 0.11920292, 0.13010847])\n>>> sigmoid_function(np.array([-1.3, 5.3, 12]))\narray([0.21416502, 0.9950332 , 0.99999386])\n>>> sigmoid_function(np.array([0.01, 0.02, 4.1]))\narray([0.50249998, 0.50499983, 0.9836975 ])\n>>> sigmoid_function(np.array([0.8]))\narray([0.68997448])"
  },
  {
    "function": "cost_function",
    "code": "def cost_function(h: np.ndarray, y: np.ndarray) -> float:\n    \"\"\"\n    Cost function quantifies the error between predicted and expected values.\n    The cost function used in Logistic Regression is called Log Loss\n    or Cross Entropy Function.\n\n    J(\u03b8) = (1/m) * \u03a3 [ -y * log(h\u03b8(x)) - (1 - y) * log(1 - h\u03b8(x)) ]\n\n    Where:\n       - J(\u03b8) is the cost that we want to minimize during training\n       - m is the number of training examples\n       - \u03a3 represents the summation over all training examples\n       - y is the actual binary label (0 or 1) for a given example\n       - h\u03b8(x) is the predicted probability that x belongs to the positive class\n\n    @param h: the output of sigmoid function. It is the estimated probability\n    that the input example 'x' belongs to the positive class\n\n    @param y: the actual binary label associated with input example 'x'\n\n    Examples:\n    >>> estimations = sigmoid_function(np.array([0.3, -4.3, 8.1]))\n    >>> cost_function(h=estimations,y=np.array([1, 0, 1]))\n    0.18937868932131605\n    >>> estimations = sigmoid_function(np.array([4, 3, 1]))\n    >>> cost_function(h=estimations,y=np.array([1, 0, 0]))\n    1.459999655669926\n    >>> estimations = sigmoid_function(np.array([4, -3, -1]))\n    >>> cost_function(h=estimations,y=np.array([1,0,0]))\n    0.1266663223365915\n    >>> estimations = sigmoid_function(0)\n    >>> cost_function(h=estimations,y=np.array([1]))\n    0.6931471805599453\n\n    References:\n       - https://en.wikipedia.org/wiki/Logistic_regression\n    \"\"\"\n    return float((-y * np.log(h) - (1 - y) * np.log(1 - h)).mean())",
    "docstring": "Cost function quantifies the error between predicted and expected values.\nThe cost function used in Logistic Regression is called Log Loss\nor Cross Entropy Function.\n\nJ(\u03b8) = (1/m) * \u03a3 [ -y * log(h\u03b8(x)) - (1 - y) * log(1 - h\u03b8(x)) ]\n\nWhere:\n   - J(\u03b8) is the cost that we want to minimize during training\n   - m is the number of training examples\n   - \u03a3 represents the summation over all training examples\n   - y is the actual binary label (0 or 1) for a given example\n   - h\u03b8(x) is the predicted probability that x belongs to the positive class\n\n@param h: the output of sigmoid function. It is the estimated probability\nthat the input example 'x' belongs to the positive class\n\n@param y: the actual binary label associated with input example 'x'\n\nExamples:\n>>> estimations = sigmoid_function(np.array([0.3, -4.3, 8.1]))\n>>> cost_function(h=estimations,y=np.array([1, 0, 1]))\n0.18937868932131605\n>>> estimations = sigmoid_function(np.array([4, 3, 1]))\n>>> cost_function(h=estimations,y=np.array([1, 0, 0]))\n1.459999655669926\n>>> estimations = sigmoid_function(np.array([4, -3, -1]))\n>>> cost_function(h=estimations,y=np.array([1,0,0]))\n0.1266663223365915\n>>> estimations = sigmoid_function(0)\n>>> cost_function(h=estimations,y=np.array([1]))\n0.6931471805599453\n\nReferences:\n   - https://en.wikipedia.org/wiki/Logistic_regression"
  },
  {
    "function": "binary_cross_entropy",
    "code": "def binary_cross_entropy(\n    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15\n) -> float:\n    \"\"\"\n    Calculate the mean binary cross-entropy (BCE) loss between true labels and predicted\n    probabilities.\n\n    BCE loss quantifies dissimilarity between true labels (0 or 1) and predicted\n    probabilities. It's widely used in binary classification tasks.\n\n    BCE = -\u03a3(y_true * ln(y_pred) + (1 - y_true) * ln(1 - y_pred))\n\n    Reference: https://en.wikipedia.org/wiki/Cross_entropy\n\n    Parameters:\n    - y_true: True binary labels (0 or 1)\n    - y_pred: Predicted probabilities for class 1\n    - epsilon: Small constant to avoid numerical instability\n\n    >>> true_labels = np.array([0, 1, 1, 0, 1])\n    >>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8])\n    >>> float(binary_cross_entropy(true_labels, predicted_probs))\n    0.2529995012327421\n    >>> true_labels = np.array([0, 1, 1, 0, 1])\n    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n    >>> binary_cross_entropy(true_labels, predicted_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    y_pred = np.clip(y_pred, epsilon, 1 - epsilon)  # Clip predictions to avoid log(0)\n    bce_loss = -(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred))\n    return np.mean(bce_loss)",
    "docstring": "Calculate the mean binary cross-entropy (BCE) loss between true labels and predicted\nprobabilities.\n\nBCE loss quantifies dissimilarity between true labels (0 or 1) and predicted\nprobabilities. It's widely used in binary classification tasks.\n\nBCE = -\u03a3(y_true * ln(y_pred) + (1 - y_true) * ln(1 - y_pred))\n\nReference: https://en.wikipedia.org/wiki/Cross_entropy\n\nParameters:\n- y_true: True binary labels (0 or 1)\n- y_pred: Predicted probabilities for class 1\n- epsilon: Small constant to avoid numerical instability\n\n>>> true_labels = np.array([0, 1, 1, 0, 1])\n>>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8])\n>>> float(binary_cross_entropy(true_labels, predicted_probs))\n0.2529995012327421\n>>> true_labels = np.array([0, 1, 1, 0, 1])\n>>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n>>> binary_cross_entropy(true_labels, predicted_probs)\nTraceback (most recent call last):\n    ...\nValueError: Input arrays must have the same length."
  },
  {
    "function": "binary_focal_cross_entropy",
    "code": "def binary_focal_cross_entropy(\n    y_true: np.ndarray,\n    y_pred: np.ndarray,\n    gamma: float = 2.0,\n    alpha: float = 0.25,\n    epsilon: float = 1e-15,\n) -> float:\n    \"\"\"\n    Calculate the mean binary focal cross-entropy (BFCE) loss between true labels\n    and predicted probabilities.\n\n    BFCE loss quantifies dissimilarity between true labels (0 or 1) and predicted\n    probabilities. It's a variation of binary cross-entropy that addresses class\n    imbalance by focusing on hard examples.\n\n    BCFE = -\u03a3(alpha * (1 - y_pred)**gamma * y_true * log(y_pred)\n                + (1 - alpha) * y_pred**gamma * (1 - y_true) * log(1 - y_pred))\n\n    Reference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)\n\n    Parameters:\n    - y_true: True binary labels (0 or 1).\n    - y_pred: Predicted probabilities for class 1.\n    - gamma: Focusing parameter for modulating the loss (default: 2.0).\n    - alpha: Weighting factor for class 1 (default: 0.25).\n    - epsilon: Small constant to avoid numerical instability.\n\n    >>> true_labels = np.array([0, 1, 1, 0, 1])\n    >>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8])\n    >>> float(binary_focal_cross_entropy(true_labels, predicted_probs))\n    0.008257977659239775\n    >>> true_labels = np.array([0, 1, 1, 0, 1])\n    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n    >>> binary_focal_cross_entropy(true_labels, predicted_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n    # Clip predicted probabilities to avoid log(0)\n    y_pred = np.clip(y_pred, epsilon, 1 - epsilon)\n\n    bcfe_loss = -(\n        alpha * (1 - y_pred) ** gamma * y_true * np.log(y_pred)\n        + (1 - alpha) * y_pred**gamma * (1 - y_true) * np.log(1 - y_pred)\n    )\n\n    return np.mean(bcfe_loss)",
    "docstring": "Calculate the mean binary focal cross-entropy (BFCE) loss between true labels\nand predicted probabilities.\n\nBFCE loss quantifies dissimilarity between true labels (0 or 1) and predicted\nprobabilities. It's a variation of binary cross-entropy that addresses class\nimbalance by focusing on hard examples.\n\nBCFE = -\u03a3(alpha * (1 - y_pred)**gamma * y_true * log(y_pred)\n            + (1 - alpha) * y_pred**gamma * (1 - y_true) * log(1 - y_pred))\n\nReference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)\n\nParameters:\n- y_true: True binary labels (0 or 1).\n- y_pred: Predicted probabilities for class 1.\n- gamma: Focusing parameter for modulating the loss (default: 2.0).\n- alpha: Weighting factor for class 1 (default: 0.25).\n- epsilon: Small constant to avoid numerical instability.\n\n>>> true_labels = np.array([0, 1, 1, 0, 1])\n>>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8])\n>>> float(binary_focal_cross_entropy(true_labels, predicted_probs))\n0.008257977659239775\n>>> true_labels = np.array([0, 1, 1, 0, 1])\n>>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n>>> binary_focal_cross_entropy(true_labels, predicted_probs)\nTraceback (most recent call last):\n    ...\nValueError: Input arrays must have the same length."
  },
  {
    "function": "categorical_cross_entropy",
    "code": "def categorical_cross_entropy(\n    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15\n) -> float:\n    \"\"\"\n    Calculate categorical cross-entropy (CCE) loss between true class labels and\n    predicted class probabilities.\n\n    CCE = -\u03a3(y_true * ln(y_pred))\n\n    Reference: https://en.wikipedia.org/wiki/Cross_entropy\n\n    Parameters:\n    - y_true: True class labels (one-hot encoded)\n    - y_pred: Predicted class probabilities\n    - epsilon: Small constant to avoid numerical instability\n\n    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])\n    >>> float(categorical_cross_entropy(true_labels, pred_probs))\n    0.567395975254385\n    >>> true_labels = np.array([[1, 0], [0, 1]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input arrays must have the same shape.\n    >>> true_labels = np.array([[2, 0, 1], [1, 0, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: y_true must be one-hot encoded.\n    >>> true_labels = np.array([[1, 0, 1], [1, 0, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: y_true must be one-hot encoded.\n    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]])\n    >>> categorical_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Predicted probabilities must sum to approximately 1.\n    \"\"\"\n    if y_true.shape != y_pred.shape:\n        raise ValueError(\"Input arrays must have the same shape.\")\n\n    if np.any((y_true != 0) & (y_true != 1)) or np.any(y_true.sum(axis=1) != 1):\n        raise ValueError(\"y_true must be one-hot encoded.\")\n\n    if not np.all(np.isclose(np.sum(y_pred, axis=1), 1, rtol=epsilon, atol=epsilon)):\n        raise ValueError(\"Predicted probabilities must sum to approximately 1.\")\n\n    y_pred = np.clip(y_pred, epsilon, 1)  # Clip predictions to avoid log(0)\n    return -np.sum(y_true * np.log(y_pred))",
    "docstring": "Calculate categorical cross-entropy (CCE) loss between true class labels and\npredicted class probabilities.\n\nCCE = -\u03a3(y_true * ln(y_pred))\n\nReference: https://en.wikipedia.org/wiki/Cross_entropy\n\nParameters:\n- y_true: True class labels (one-hot encoded)\n- y_pred: Predicted class probabilities\n- epsilon: Small constant to avoid numerical instability\n\n>>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])\n>>> float(categorical_cross_entropy(true_labels, pred_probs))\n0.567395975254385\n>>> true_labels = np.array([[1, 0], [0, 1]])\n>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n>>> categorical_cross_entropy(true_labels, pred_probs)\nTraceback (most recent call last):\n    ...\nValueError: Input arrays must have the same shape.\n>>> true_labels = np.array([[2, 0, 1], [1, 0, 0]])\n>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n>>> categorical_cross_entropy(true_labels, pred_probs)\nTraceback (most recent call last):\n    ...\nValueError: y_true must be one-hot encoded.\n>>> true_labels = np.array([[1, 0, 1], [1, 0, 0]])\n>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n>>> categorical_cross_entropy(true_labels, pred_probs)\nTraceback (most recent call last):\n    ...\nValueError: y_true must be one-hot encoded.\n>>> true_labels = np.array([[1, 0, 0], [0, 1, 0]])\n>>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]])\n>>> categorical_cross_entropy(true_labels, pred_probs)\nTraceback (most recent call last):\n    ...\nValueError: Predicted probabilities must sum to approximately 1."
  },
  {
    "function": "categorical_focal_cross_entropy",
    "code": "def categorical_focal_cross_entropy(\n    y_true: np.ndarray,\n    y_pred: np.ndarray,\n    alpha: np.ndarray = None,\n    gamma: float = 2.0,\n    epsilon: float = 1e-15,\n) -> float:\n    \"\"\"\n    Calculate the mean categorical focal cross-entropy (CFCE) loss between true\n    labels and predicted probabilities for multi-class classification.\n\n    CFCE loss is a generalization of binary focal cross-entropy for multi-class\n    classification. It addresses class imbalance by focusing on hard examples.\n\n    CFCE = -\u03a3 alpha * (1 - y_pred)**gamma * y_true * log(y_pred)\n\n    Reference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)\n\n    Parameters:\n    - y_true: True labels in one-hot encoded form.\n    - y_pred: Predicted probabilities for each class.\n    - alpha: Array of weighting factors for each class.\n    - gamma: Focusing parameter for modulating the loss (default: 2.0).\n    - epsilon: Small constant to avoid numerical instability.\n\n    Returns:\n    - The mean categorical focal cross-entropy loss.\n\n    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])\n    >>> alpha = np.array([0.6, 0.2, 0.7])\n    >>> float(categorical_focal_cross_entropy(true_labels, pred_probs, alpha))\n    0.0025966118981496423\n\n    >>> true_labels = np.array([[0, 1, 0], [0, 0, 1]])\n    >>> pred_probs = np.array([[0.05, 0.95, 0], [0.1, 0.8, 0.1]])\n    >>> alpha = np.array([0.25, 0.25, 0.25])\n    >>> float(categorical_focal_cross_entropy(true_labels, pred_probs, alpha))\n    0.23315276982014324\n\n    >>> true_labels = np.array([[1, 0], [0, 1]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input arrays must have the same shape.\n\n    >>> true_labels = np.array([[2, 0, 1], [1, 0, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_focal_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: y_true must be one-hot encoded.\n\n    >>> true_labels = np.array([[1, 0, 1], [1, 0, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_focal_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: y_true must be one-hot encoded.\n\n    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]])\n    >>> categorical_focal_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Predicted probabilities must sum to approximately 1.\n\n    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])\n    >>> alpha = np.array([0.6, 0.2])\n    >>> categorical_focal_cross_entropy(true_labels, pred_probs, alpha)\n    Traceback (most recent call last):\n        ...\n    ValueError: Length of alpha must match the number of classes.\n    \"\"\"\n    if y_true.shape != y_pred.shape:\n        raise ValueError(\"Shape of y_true and y_pred must be the same.\")\n\n    if alpha is None:\n        alpha = np.ones(y_true.shape[1])\n\n    if np.any((y_true != 0) & (y_true != 1)) or np.any(y_true.sum(axis=1) != 1):\n        raise ValueError(\"y_true must be one-hot encoded.\")\n\n    if len(alpha) != y_true.shape[1]:\n        raise ValueError(\"Length of alpha must match the number of classes.\")\n\n    if not np.all(np.isclose(np.sum(y_pred, axis=1), 1, rtol=epsilon, atol=epsilon)):\n        raise ValueError(\"Predicted probabilities must sum to approximately 1.\")\n\n    # Clip predicted probabilities to avoid log(0)\n    y_pred = np.clip(y_pred, epsilon, 1 - epsilon)\n\n    # Calculate loss for each class and sum across classes\n    cfce_loss = -np.sum(\n        alpha * np.power(1 - y_pred, gamma) * y_true * np.log(y_pred), axis=1\n    )\n\n    return np.mean(cfce_loss)",
    "docstring": "Calculate the mean categorical focal cross-entropy (CFCE) loss between true\nlabels and predicted probabilities for multi-class classification.\n\nCFCE loss is a generalization of binary focal cross-entropy for multi-class\nclassification. It addresses class imbalance by focusing on hard examples.\n\nCFCE = -\u03a3 alpha * (1 - y_pred)**gamma * y_true * log(y_pred)\n\nReference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)\n\nParameters:\n- y_true: True labels in one-hot encoded form.\n- y_pred: Predicted probabilities for each class.\n- alpha: Array of weighting factors for each class.\n- gamma: Focusing parameter for modulating the loss (default: 2.0).\n- epsilon: Small constant to avoid numerical instability.\n\nReturns:\n- The mean categorical focal cross-entropy loss.\n\n>>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])\n>>> alpha = np.array([0.6, 0.2, 0.7])\n>>> float(categorical_focal_cross_entropy(true_labels, pred_probs, alpha))\n0.0025966118981496423\n\n>>> true_labels = np.array([[0, 1, 0], [0, 0, 1]])\n>>> pred_probs = np.array([[0.05, 0.95, 0], [0.1, 0.8, 0.1]])\n>>> alpha = np.array([0.25, 0.25, 0.25])\n>>> float(categorical_focal_cross_entropy(true_labels, pred_probs, alpha))\n0.23315276982014324\n\n>>> true_labels = np.array([[1, 0], [0, 1]])\n>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n>>> categorical_cross_entropy(true_labels, pred_probs)\nTraceback (most recent call last):\n    ...\nValueError: Input arrays must have the same shape.\n\n>>> true_labels = np.array([[2, 0, 1], [1, 0, 0]])\n>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n>>> categorical_focal_cross_entropy(true_labels, pred_probs)\nTraceback (most recent call last):\n    ...\nValueError: y_true must be one-hot encoded.\n\n>>> true_labels = np.array([[1, 0, 1], [1, 0, 0]])\n>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n>>> categorical_focal_cross_entropy(true_labels, pred_probs)\nTraceback (most recent call last):\n    ...\nValueError: y_true must be one-hot encoded.\n\n>>> true_labels = np.array([[1, 0, 0], [0, 1, 0]])\n>>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]])\n>>> categorical_focal_cross_entropy(true_labels, pred_probs)\nTraceback (most recent call last):\n    ...\nValueError: Predicted probabilities must sum to approximately 1.\n\n>>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])\n>>> alpha = np.array([0.6, 0.2])\n>>> categorical_focal_cross_entropy(true_labels, pred_probs, alpha)\nTraceback (most recent call last):\n    ...\nValueError: Length of alpha must match the number of classes."
  },
  {
    "function": "hinge_loss",
    "code": "def hinge_loss(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"\n    Calculate the mean hinge loss for between true labels and predicted probabilities\n    for training support vector machines (SVMs).\n\n    Hinge loss = max(0, 1 - true * pred)\n\n    Reference: https://en.wikipedia.org/wiki/Hinge_loss\n\n    Args:\n    - y_true: actual values (ground truth) encoded as -1 or 1\n    - y_pred: predicted values\n\n    >>> true_labels = np.array([-1, 1, 1, -1, 1])\n    >>> pred = np.array([-4, -0.3, 0.7, 5, 10])\n    >>> float(hinge_loss(true_labels, pred))\n    1.52\n    >>> true_labels = np.array([-1, 1, 1, -1, 1, 1])\n    >>> pred = np.array([-4, -0.3, 0.7, 5, 10])\n    >>> hinge_loss(true_labels, pred)\n    Traceback (most recent call last):\n    ...\n    ValueError: Length of predicted and actual array must be same.\n    >>> true_labels = np.array([-1, 1, 10, -1, 1])\n    >>> pred = np.array([-4, -0.3, 0.7, 5, 10])\n    >>> hinge_loss(true_labels, pred)\n    Traceback (most recent call last):\n    ...\n    ValueError: y_true can have values -1 or 1 only.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Length of predicted and actual array must be same.\")\n\n    if np.any((y_true != -1) & (y_true != 1)):\n        raise ValueError(\"y_true can have values -1 or 1 only.\")\n\n    hinge_losses = np.maximum(0, 1.0 - (y_true * y_pred))\n    return np.mean(hinge_losses)",
    "docstring": "Calculate the mean hinge loss for between true labels and predicted probabilities\nfor training support vector machines (SVMs).\n\nHinge loss = max(0, 1 - true * pred)\n\nReference: https://en.wikipedia.org/wiki/Hinge_loss\n\nArgs:\n- y_true: actual values (ground truth) encoded as -1 or 1\n- y_pred: predicted values\n\n>>> true_labels = np.array([-1, 1, 1, -1, 1])\n>>> pred = np.array([-4, -0.3, 0.7, 5, 10])\n>>> float(hinge_loss(true_labels, pred))\n1.52\n>>> true_labels = np.array([-1, 1, 1, -1, 1, 1])\n>>> pred = np.array([-4, -0.3, 0.7, 5, 10])\n>>> hinge_loss(true_labels, pred)\nTraceback (most recent call last):\n...\nValueError: Length of predicted and actual array must be same.\n>>> true_labels = np.array([-1, 1, 10, -1, 1])\n>>> pred = np.array([-4, -0.3, 0.7, 5, 10])\n>>> hinge_loss(true_labels, pred)\nTraceback (most recent call last):\n...\nValueError: y_true can have values -1 or 1 only."
  },
  {
    "function": "huber_loss",
    "code": "def huber_loss(y_true: np.ndarray, y_pred: np.ndarray, delta: float) -> float:\n    \"\"\"\n    Calculate the mean Huber loss between the given ground truth and predicted values.\n\n    The Huber loss describes the penalty incurred by an estimation procedure, and it\n    serves as a measure of accuracy for regression models.\n\n    Huber loss =\n        0.5 * (y_true - y_pred)^2                   if |y_true - y_pred| <= delta\n        delta * |y_true - y_pred| - 0.5 * delta^2   otherwise\n\n    Reference: https://en.wikipedia.org/wiki/Huber_loss\n\n    Parameters:\n    - y_true: The true values (ground truth)\n    - y_pred: The predicted values\n\n    >>> true_values = np.array([0.9, 10.0, 2.0, 1.0, 5.2])\n    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n    >>> bool(np.isclose(huber_loss(true_values, predicted_values, 1.0), 2.102))\n    True\n    >>> true_labels = np.array([11.0, 21.0, 3.32, 4.0, 5.0])\n    >>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0])\n    >>> bool(np.isclose(huber_loss(true_labels, predicted_probs, 1.0), 1.80164))\n    True\n    >>> true_labels = np.array([11.0, 21.0, 3.32, 4.0])\n    >>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0])\n    >>> huber_loss(true_labels, predicted_probs, 1.0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    huber_mse = 0.5 * (y_true - y_pred) ** 2\n    huber_mae = delta * (np.abs(y_true - y_pred) - 0.5 * delta)\n    return np.where(np.abs(y_true - y_pred) <= delta, huber_mse, huber_mae).mean()",
    "docstring": "Calculate the mean Huber loss between the given ground truth and predicted values.\n\nThe Huber loss describes the penalty incurred by an estimation procedure, and it\nserves as a measure of accuracy for regression models.\n\nHuber loss =\n    0.5 * (y_true - y_pred)^2                   if |y_true - y_pred| <= delta\n    delta * |y_true - y_pred| - 0.5 * delta^2   otherwise\n\nReference: https://en.wikipedia.org/wiki/Huber_loss\n\nParameters:\n- y_true: The true values (ground truth)\n- y_pred: The predicted values\n\n>>> true_values = np.array([0.9, 10.0, 2.0, 1.0, 5.2])\n>>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n>>> bool(np.isclose(huber_loss(true_values, predicted_values, 1.0), 2.102))\nTrue\n>>> true_labels = np.array([11.0, 21.0, 3.32, 4.0, 5.0])\n>>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0])\n>>> bool(np.isclose(huber_loss(true_labels, predicted_probs, 1.0), 1.80164))\nTrue\n>>> true_labels = np.array([11.0, 21.0, 3.32, 4.0])\n>>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0])\n>>> huber_loss(true_labels, predicted_probs, 1.0)\nTraceback (most recent call last):\n...\nValueError: Input arrays must have the same length."
  },
  {
    "function": "mean_squared_error",
    "code": "def mean_squared_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"\n    Calculate the mean squared error (MSE) between ground truth and predicted values.\n\n    MSE measures the squared difference between true values and predicted values, and it\n    serves as a measure of accuracy for regression models.\n\n    MSE = (1/n) * \u03a3(y_true - y_pred)^2\n\n    Reference: https://en.wikipedia.org/wiki/Mean_squared_error\n\n    Parameters:\n    - y_true: The true values (ground truth)\n    - y_pred: The predicted values\n\n    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n    >>> bool(np.isclose(mean_squared_error(true_values, predicted_values), 0.028))\n    True\n    >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n    >>> mean_squared_error(true_labels, predicted_probs)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    squared_errors = (y_true - y_pred) ** 2\n    return np.mean(squared_errors)",
    "docstring": "Calculate the mean squared error (MSE) between ground truth and predicted values.\n\nMSE measures the squared difference between true values and predicted values, and it\nserves as a measure of accuracy for regression models.\n\nMSE = (1/n) * \u03a3(y_true - y_pred)^2\n\nReference: https://en.wikipedia.org/wiki/Mean_squared_error\n\nParameters:\n- y_true: The true values (ground truth)\n- y_pred: The predicted values\n\n>>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n>>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n>>> bool(np.isclose(mean_squared_error(true_values, predicted_values), 0.028))\nTrue\n>>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n>>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n>>> mean_squared_error(true_labels, predicted_probs)\nTraceback (most recent call last):\n...\nValueError: Input arrays must have the same length."
  },
  {
    "function": "mean_absolute_error",
    "code": "def mean_absolute_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"\n    Calculates the Mean Absolute Error (MAE) between ground truth (observed)\n        and predicted values.\n\n    MAE measures the absolute difference between true values and predicted values.\n\n    Equation:\n    MAE = (1/n) * \u03a3(abs(y_true - y_pred))\n\n    Reference: https://en.wikipedia.org/wiki/Mean_absolute_error\n\n    Parameters:\n    - y_true: The true values (ground truth)\n    - y_pred: The predicted values\n\n    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n    >>> bool(np.isclose(mean_absolute_error(true_values, predicted_values), 0.16))\n    True\n    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n    >>> bool(np.isclose(mean_absolute_error(true_values, predicted_values), 2.16))\n    False\n    >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 5.2])\n    >>> mean_absolute_error(true_labels, predicted_probs)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    return np.mean(abs(y_true - y_pred))",
    "docstring": "Calculates the Mean Absolute Error (MAE) between ground truth (observed)\n    and predicted values.\n\nMAE measures the absolute difference between true values and predicted values.\n\nEquation:\nMAE = (1/n) * \u03a3(abs(y_true - y_pred))\n\nReference: https://en.wikipedia.org/wiki/Mean_absolute_error\n\nParameters:\n- y_true: The true values (ground truth)\n- y_pred: The predicted values\n\n>>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n>>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n>>> bool(np.isclose(mean_absolute_error(true_values, predicted_values), 0.16))\nTrue\n>>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n>>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n>>> bool(np.isclose(mean_absolute_error(true_values, predicted_values), 2.16))\nFalse\n>>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n>>> predicted_probs = np.array([0.3, 0.8, 0.9, 5.2])\n>>> mean_absolute_error(true_labels, predicted_probs)\nTraceback (most recent call last):\n...\nValueError: Input arrays must have the same length."
  },
  {
    "function": "mean_squared_logarithmic_error",
    "code": "def mean_squared_logarithmic_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"\n    Calculate the mean squared logarithmic error (MSLE) between ground truth and\n    predicted values.\n\n    MSLE measures the squared logarithmic difference between true values and predicted\n    values for regression models. It's particularly useful for dealing with skewed or\n    large-value data, and it's often used when the relative differences between\n    predicted and true values are more important than absolute differences.\n\n    MSLE = (1/n) * \u03a3(log(1 + y_true) - log(1 + y_pred))^2\n\n    Reference: https://insideaiml.com/blog/MeanSquared-Logarithmic-Error-Loss-1035\n\n    Parameters:\n    - y_true: The true values (ground truth)\n    - y_pred: The predicted values\n\n    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n    >>> float(mean_squared_logarithmic_error(true_values, predicted_values))\n    0.0030860877925181344\n    >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n    >>> mean_squared_logarithmic_error(true_labels, predicted_probs)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    squared_logarithmic_errors = (np.log1p(y_true) - np.log1p(y_pred)) ** 2\n    return np.mean(squared_logarithmic_errors)",
    "docstring": "Calculate the mean squared logarithmic error (MSLE) between ground truth and\npredicted values.\n\nMSLE measures the squared logarithmic difference between true values and predicted\nvalues for regression models. It's particularly useful for dealing with skewed or\nlarge-value data, and it's often used when the relative differences between\npredicted and true values are more important than absolute differences.\n\nMSLE = (1/n) * \u03a3(log(1 + y_true) - log(1 + y_pred))^2\n\nReference: https://insideaiml.com/blog/MeanSquared-Logarithmic-Error-Loss-1035\n\nParameters:\n- y_true: The true values (ground truth)\n- y_pred: The predicted values\n\n>>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n>>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n>>> float(mean_squared_logarithmic_error(true_values, predicted_values))\n0.0030860877925181344\n>>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n>>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n>>> mean_squared_logarithmic_error(true_labels, predicted_probs)\nTraceback (most recent call last):\n...\nValueError: Input arrays must have the same length."
  },
  {
    "function": "mean_absolute_percentage_error",
    "code": "def mean_absolute_percentage_error(\n    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15\n) -> float:\n    \"\"\"\n    Calculate the Mean Absolute Percentage Error between y_true and y_pred.\n\n    Mean Absolute Percentage Error calculates the average of the absolute\n    percentage differences between the predicted and true values.\n\n    Formula = (\u03a3|y_true[i]-Y_pred[i]/y_true[i]|)/n\n\n    Source: https://stephenallwright.com/good-mape-score/\n\n    Parameters:\n    y_true (np.ndarray): Numpy array containing true/target values.\n    y_pred (np.ndarray): Numpy array containing predicted values.\n\n    Returns:\n    float: The Mean Absolute Percentage error between y_true and y_pred.\n\n    Examples:\n    >>> y_true = np.array([10, 20, 30, 40])\n    >>> y_pred = np.array([12, 18, 33, 45])\n    >>> float(mean_absolute_percentage_error(y_true, y_pred))\n    0.13125\n\n    >>> y_true = np.array([1, 2, 3, 4])\n    >>> y_pred = np.array([2, 3, 4, 5])\n    >>> float(mean_absolute_percentage_error(y_true, y_pred))\n    0.5208333333333333\n\n    >>> y_true = np.array([34, 37, 44, 47, 48, 48, 46, 43, 32, 27, 26, 24])\n    >>> y_pred = np.array([37, 40, 46, 44, 46, 50, 45, 44, 34, 30, 22, 23])\n    >>> float(mean_absolute_percentage_error(y_true, y_pred))\n    0.064671076436071\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"The length of the two arrays should be the same.\")\n\n    y_true = np.where(y_true == 0, epsilon, y_true)\n    absolute_percentage_diff = np.abs((y_true - y_pred) / y_true)\n\n    return np.mean(absolute_percentage_diff)",
    "docstring": "Calculate the Mean Absolute Percentage Error between y_true and y_pred.\n\nMean Absolute Percentage Error calculates the average of the absolute\npercentage differences between the predicted and true values.\n\nFormula = (\u03a3|y_true[i]-Y_pred[i]/y_true[i]|)/n\n\nSource: https://stephenallwright.com/good-mape-score/\n\nParameters:\ny_true (np.ndarray): Numpy array containing true/target values.\ny_pred (np.ndarray): Numpy array containing predicted values.\n\nReturns:\nfloat: The Mean Absolute Percentage error between y_true and y_pred.\n\nExamples:\n>>> y_true = np.array([10, 20, 30, 40])\n>>> y_pred = np.array([12, 18, 33, 45])\n>>> float(mean_absolute_percentage_error(y_true, y_pred))\n0.13125\n\n>>> y_true = np.array([1, 2, 3, 4])\n>>> y_pred = np.array([2, 3, 4, 5])\n>>> float(mean_absolute_percentage_error(y_true, y_pred))\n0.5208333333333333\n\n>>> y_true = np.array([34, 37, 44, 47, 48, 48, 46, 43, 32, 27, 26, 24])\n>>> y_pred = np.array([37, 40, 46, 44, 46, 50, 45, 44, 34, 30, 22, 23])\n>>> float(mean_absolute_percentage_error(y_true, y_pred))\n0.064671076436071"
  },
  {
    "function": "perplexity_loss",
    "code": "def perplexity_loss(\n    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-7\n) -> float:\n    \"\"\"\n    Calculate the perplexity for the y_true and y_pred.\n\n    Compute the Perplexity which useful in predicting language model\n    accuracy in Natural Language Processing (NLP.)\n    Perplexity is measure of how certain the model in its predictions.\n\n    Perplexity Loss = exp(-1/N (\u03a3 ln(p(x)))\n\n    Reference:\n    https://en.wikipedia.org/wiki/Perplexity\n\n    Args:\n        y_true: Actual label encoded sentences of shape (batch_size, sentence_length)\n        y_pred: Predicted sentences of shape (batch_size, sentence_length, vocab_size)\n        epsilon: Small floating point number to avoid getting inf for log(0)\n\n    Returns:\n        Perplexity loss between y_true and y_pred.\n\n    >>> y_true = np.array([[1, 4], [2, 3]])\n    >>> y_pred = np.array(\n    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n    ...      [0.24, 0.19, 0.09, 0.18, 0.27]],\n    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n    ...       [0.28, 0.10, 0.33, 0.15, 0.12]]]\n    ... )\n    >>> float(perplexity_loss(y_true, y_pred))\n    5.0247347775367945\n    >>> y_true = np.array([[1, 4], [2, 3]])\n    >>> y_pred = np.array(\n    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n    ...      [0.24, 0.19, 0.09, 0.18, 0.27],\n    ...      [0.30, 0.10, 0.20, 0.15, 0.25]],\n    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n    ...       [0.28, 0.10, 0.33, 0.15, 0.12],\n    ...       [0.30, 0.10, 0.20, 0.15, 0.25]],]\n    ... )\n    >>> perplexity_loss(y_true, y_pred)\n    Traceback (most recent call last):\n    ...\n    ValueError: Sentence length of y_true and y_pred must be equal.\n    >>> y_true = np.array([[1, 4], [2, 11]])\n    >>> y_pred = np.array(\n    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n    ...      [0.24, 0.19, 0.09, 0.18, 0.27]],\n    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n    ...       [0.28, 0.10, 0.33, 0.15, 0.12]]]\n    ... )\n    >>> perplexity_loss(y_true, y_pred)\n    Traceback (most recent call last):\n    ...\n    ValueError: Label value must not be greater than vocabulary size.\n    >>> y_true = np.array([[1, 4]])\n    >>> y_pred = np.array(\n    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n    ...      [0.24, 0.19, 0.09, 0.18, 0.27]],\n    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n    ...       [0.28, 0.10, 0.33, 0.15, 0.12]]]\n    ... )\n    >>> perplexity_loss(y_true, y_pred)\n    Traceback (most recent call last):\n    ...\n    ValueError: Batch size of y_true and y_pred must be equal.\n    \"\"\"\n\n    vocab_size = y_pred.shape[2]\n\n    if y_true.shape[0] != y_pred.shape[0]:\n        raise ValueError(\"Batch size of y_true and y_pred must be equal.\")\n    if y_true.shape[1] != y_pred.shape[1]:\n        raise ValueError(\"Sentence length of y_true and y_pred must be equal.\")\n    if np.max(y_true) > vocab_size:\n        raise ValueError(\"Label value must not be greater than vocabulary size.\")\n\n    # Matrix to select prediction value only for true class\n    filter_matrix = np.array(\n        [[list(np.eye(vocab_size)[word]) for word in sentence] for sentence in y_true]\n    )\n\n    # Getting the matrix containing prediction for only true class\n    true_class_pred = np.sum(y_pred * filter_matrix, axis=2).clip(epsilon, 1)\n\n    # Calculating perplexity for each sentence\n    perp_losses = np.exp(np.negative(np.mean(np.log(true_class_pred), axis=1)))\n\n    return np.mean(perp_losses)",
    "docstring": "Calculate the perplexity for the y_true and y_pred.\n\nCompute the Perplexity which useful in predicting language model\naccuracy in Natural Language Processing (NLP.)\nPerplexity is measure of how certain the model in its predictions.\n\nPerplexity Loss = exp(-1/N (\u03a3 ln(p(x)))\n\nReference:\nhttps://en.wikipedia.org/wiki/Perplexity\n\nArgs:\n    y_true: Actual label encoded sentences of shape (batch_size, sentence_length)\n    y_pred: Predicted sentences of shape (batch_size, sentence_length, vocab_size)\n    epsilon: Small floating point number to avoid getting inf for log(0)\n\nReturns:\n    Perplexity loss between y_true and y_pred.\n\n>>> y_true = np.array([[1, 4], [2, 3]])\n>>> y_pred = np.array(\n...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n...      [0.24, 0.19, 0.09, 0.18, 0.27]],\n...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n...       [0.28, 0.10, 0.33, 0.15, 0.12]]]\n... )\n>>> float(perplexity_loss(y_true, y_pred))\n5.0247347775367945\n>>> y_true = np.array([[1, 4], [2, 3]])\n>>> y_pred = np.array(\n...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n...      [0.24, 0.19, 0.09, 0.18, 0.27],\n...      [0.30, 0.10, 0.20, 0.15, 0.25]],\n...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n...       [0.28, 0.10, 0.33, 0.15, 0.12],\n...       [0.30, 0.10, 0.20, 0.15, 0.25]],]\n... )\n>>> perplexity_loss(y_true, y_pred)\nTraceback (most recent call last):\n...\nValueError: Sentence length of y_true and y_pred must be equal.\n>>> y_true = np.array([[1, 4], [2, 11]])\n>>> y_pred = np.array(\n...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n...      [0.24, 0.19, 0.09, 0.18, 0.27]],\n...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n...       [0.28, 0.10, 0.33, 0.15, 0.12]]]\n... )\n>>> perplexity_loss(y_true, y_pred)\nTraceback (most recent call last):\n...\nValueError: Label value must not be greater than vocabulary size.\n>>> y_true = np.array([[1, 4]])\n>>> y_pred = np.array(\n...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n...      [0.24, 0.19, 0.09, 0.18, 0.27]],\n...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n...       [0.28, 0.10, 0.33, 0.15, 0.12]]]\n... )\n>>> perplexity_loss(y_true, y_pred)\nTraceback (most recent call last):\n...\nValueError: Batch size of y_true and y_pred must be equal."
  },
  {
    "function": "smooth_l1_loss",
    "code": "def smooth_l1_loss(y_true: np.ndarray, y_pred: np.ndarray, beta: float = 1.0) -> float:\n    \"\"\"\n    Calculate the Smooth L1 Loss between y_true and y_pred.\n\n    The Smooth L1 Loss is less sensitive to outliers than the L2 Loss and is often used\n    in regression problems, such as object detection.\n\n    Smooth L1 Loss =\n        0.5 * (x - y)^2 / beta, if |x - y| < beta\n        |x - y| - 0.5 * beta, otherwise\n\n    Reference:\n    https://pytorch.org/docs/stable/generated/torch.nn.SmoothL1Loss.html\n\n    Args:\n        y_true: Array of true values.\n        y_pred: Array of predicted values.\n        beta: Specifies the threshold at which to change between L1 and L2 loss.\n\n    Returns:\n        The calculated Smooth L1 Loss between y_true and y_pred.\n\n    Raises:\n        ValueError: If the length of the two arrays is not the same.\n\n    >>> y_true = np.array([3, 5, 2, 7])\n    >>> y_pred = np.array([2.9, 4.8, 2.1, 7.2])\n    >>> float(smooth_l1_loss(y_true, y_pred, 1.0))\n    0.012500000000000022\n\n    >>> y_true = np.array([2, 4, 6])\n    >>> y_pred = np.array([1, 5, 7])\n    >>> float(smooth_l1_loss(y_true, y_pred, 1.0))\n    0.5\n\n    >>> y_true = np.array([1, 3, 5, 7])\n    >>> y_pred = np.array([1, 3, 5, 7])\n    >>> float(smooth_l1_loss(y_true, y_pred, 1.0))\n    0.0\n\n    >>> y_true = np.array([1, 3, 5])\n    >>> y_pred = np.array([1, 3, 5, 7])\n    >>> smooth_l1_loss(y_true, y_pred, 1.0)\n    Traceback (most recent call last):\n    ...\n    ValueError: The length of the two arrays should be the same.\n    \"\"\"\n\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"The length of the two arrays should be the same.\")\n\n    diff = np.abs(y_true - y_pred)\n    loss = np.where(diff < beta, 0.5 * diff**2 / beta, diff - 0.5 * beta)\n    return np.mean(loss)",
    "docstring": "Calculate the Smooth L1 Loss between y_true and y_pred.\n\nThe Smooth L1 Loss is less sensitive to outliers than the L2 Loss and is often used\nin regression problems, such as object detection.\n\nSmooth L1 Loss =\n    0.5 * (x - y)^2 / beta, if |x - y| < beta\n    |x - y| - 0.5 * beta, otherwise\n\nReference:\nhttps://pytorch.org/docs/stable/generated/torch.nn.SmoothL1Loss.html\n\nArgs:\n    y_true: Array of true values.\n    y_pred: Array of predicted values.\n    beta: Specifies the threshold at which to change between L1 and L2 loss.\n\nReturns:\n    The calculated Smooth L1 Loss between y_true and y_pred.\n\nRaises:\n    ValueError: If the length of the two arrays is not the same.\n\n>>> y_true = np.array([3, 5, 2, 7])\n>>> y_pred = np.array([2.9, 4.8, 2.1, 7.2])\n>>> float(smooth_l1_loss(y_true, y_pred, 1.0))\n0.012500000000000022\n\n>>> y_true = np.array([2, 4, 6])\n>>> y_pred = np.array([1, 5, 7])\n>>> float(smooth_l1_loss(y_true, y_pred, 1.0))\n0.5\n\n>>> y_true = np.array([1, 3, 5, 7])\n>>> y_pred = np.array([1, 3, 5, 7])\n>>> float(smooth_l1_loss(y_true, y_pred, 1.0))\n0.0\n\n>>> y_true = np.array([1, 3, 5])\n>>> y_pred = np.array([1, 3, 5, 7])\n>>> smooth_l1_loss(y_true, y_pred, 1.0)\nTraceback (most recent call last):\n...\nValueError: The length of the two arrays should be the same."
  },
  {
    "function": "kullback_leibler_divergence",
    "code": "def kullback_leibler_divergence(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"\n    Calculate the Kullback-Leibler divergence (KL divergence) loss between true labels\n    and predicted probabilities.\n\n    KL divergence loss quantifies dissimilarity between true labels and predicted\n    probabilities. It's often used in training generative models.\n\n    KL = \u03a3(y_true * ln(y_true / y_pred))\n\n    Reference: https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence\n\n    Parameters:\n    - y_true: True class probabilities\n    - y_pred: Predicted class probabilities\n\n    >>> true_labels = np.array([0.2, 0.3, 0.5])\n    >>> predicted_probs = np.array([0.3, 0.3, 0.4])\n    >>> float(kullback_leibler_divergence(true_labels, predicted_probs))\n    0.030478754035472025\n    >>> true_labels = np.array([0.2, 0.3, 0.5])\n    >>> predicted_probs = np.array([0.3, 0.3, 0.4, 0.5])\n    >>> kullback_leibler_divergence(true_labels, predicted_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    kl_loss = y_true * np.log(y_true / y_pred)\n    return np.sum(kl_loss)",
    "docstring": "Calculate the Kullback-Leibler divergence (KL divergence) loss between true labels\nand predicted probabilities.\n\nKL divergence loss quantifies dissimilarity between true labels and predicted\nprobabilities. It's often used in training generative models.\n\nKL = \u03a3(y_true * ln(y_true / y_pred))\n\nReference: https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence\n\nParameters:\n- y_true: True class probabilities\n- y_pred: Predicted class probabilities\n\n>>> true_labels = np.array([0.2, 0.3, 0.5])\n>>> predicted_probs = np.array([0.3, 0.3, 0.4])\n>>> float(kullback_leibler_divergence(true_labels, predicted_probs))\n0.030478754035472025\n>>> true_labels = np.array([0.2, 0.3, 0.5])\n>>> predicted_probs = np.array([0.3, 0.3, 0.4, 0.5])\n>>> kullback_leibler_divergence(true_labels, predicted_probs)\nTraceback (most recent call last):\n    ...\nValueError: Input arrays must have the same length."
  },
  {
    "function": "mfcc",
    "code": "def mfcc(\n    audio: np.ndarray,\n    sample_rate: int,\n    ftt_size: int = 1024,\n    hop_length: int = 20,\n    mel_filter_num: int = 10,\n    dct_filter_num: int = 40,\n) -> np.ndarray:\n    \"\"\"\n    Calculate Mel Frequency Cepstral Coefficients (MFCCs) from an audio signal.\n\n    Args:\n        audio: The input audio signal.\n        sample_rate: The sample rate of the audio signal (in Hz).\n        ftt_size: The size of the FFT window (default is 1024).\n        hop_length: The hop length for frame creation (default is 20ms).\n        mel_filter_num: The number of Mel filters (default is 10).\n        dct_filter_num: The number of DCT filters (default is 40).\n\n    Returns:\n        A matrix of MFCCs for the input audio.\n\n    Raises:\n        ValueError: If the input audio is empty.\n\n    Example:\n    >>> sample_rate = 44100  # Sample rate of 44.1 kHz\n    >>> duration = 2.0  # Duration of 1 second\n    >>> t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False)\n    >>> audio = 0.5 * np.sin(2 * np.pi * 440.0 * t)  # Generate a 440 Hz sine wave\n    >>> mfccs = mfcc(audio, sample_rate)\n    >>> mfccs.shape\n    (40, 101)\n    \"\"\"\n    logging.info(f\"Sample rate: {sample_rate}Hz\")\n    logging.info(f\"Audio duration: {len(audio) / sample_rate}s\")\n    logging.info(f\"Audio min: {np.min(audio)}\")\n    logging.info(f\"Audio max: {np.max(audio)}\")\n\n    # normalize audio\n    audio_normalized = normalize(audio)\n\n    logging.info(f\"Normalized audio min: {np.min(audio_normalized)}\")\n    logging.info(f\"Normalized audio max: {np.max(audio_normalized)}\")\n\n    # frame audio into\n    audio_framed = audio_frames(\n        audio_normalized, sample_rate, ftt_size=ftt_size, hop_length=hop_length\n    )\n\n    logging.info(f\"Framed audio shape: {audio_framed.shape}\")\n    logging.info(f\"First frame: {audio_framed[0]}\")\n\n    # convert to frequency domain\n    # For simplicity we will choose the Hanning window.\n    window = get_window(\"hann\", ftt_size, fftbins=True)\n    audio_windowed = audio_framed * window\n\n    logging.info(f\"Windowed audio shape: {audio_windowed.shape}\")\n    logging.info(f\"First frame: {audio_windowed[0]}\")\n\n    audio_fft = calculate_fft(audio_windowed, ftt_size)\n    logging.info(f\"fft audio shape: {audio_fft.shape}\")\n    logging.info(f\"First frame: {audio_fft[0]}\")\n\n    audio_power = calculate_signal_power(audio_fft)\n    logging.info(f\"power audio shape: {audio_power.shape}\")\n    logging.info(f\"First frame: {audio_power[0]}\")\n\n    filters = mel_spaced_filterbank(sample_rate, mel_filter_num, ftt_size)\n    logging.info(f\"filters shape: {filters.shape}\")\n\n    audio_filtered = np.dot(filters, np.transpose(audio_power))\n    audio_log = 10.0 * np.log10(audio_filtered)\n    logging.info(f\"audio_log shape: {audio_log.shape}\")\n\n    dct_filters = discrete_cosine_transform(dct_filter_num, mel_filter_num)\n    cepstral_coefficents = np.dot(dct_filters, audio_log)\n\n    logging.info(f\"cepstral_coefficents shape: {cepstral_coefficents.shape}\")\n    return cepstral_coefficents",
    "docstring": "Calculate Mel Frequency Cepstral Coefficients (MFCCs) from an audio signal.\n\nArgs:\n    audio: The input audio signal.\n    sample_rate: The sample rate of the audio signal (in Hz).\n    ftt_size: The size of the FFT window (default is 1024).\n    hop_length: The hop length for frame creation (default is 20ms).\n    mel_filter_num: The number of Mel filters (default is 10).\n    dct_filter_num: The number of DCT filters (default is 40).\n\nReturns:\n    A matrix of MFCCs for the input audio.\n\nRaises:\n    ValueError: If the input audio is empty.\n\nExample:\n>>> sample_rate = 44100  # Sample rate of 44.1 kHz\n>>> duration = 2.0  # Duration of 1 second\n>>> t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False)\n>>> audio = 0.5 * np.sin(2 * np.pi * 440.0 * t)  # Generate a 440 Hz sine wave\n>>> mfccs = mfcc(audio, sample_rate)\n>>> mfccs.shape\n(40, 101)"
  },
  {
    "function": "normalize",
    "code": "def normalize(audio: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Normalize an audio signal by scaling it to have values between -1 and 1.\n\n    Args:\n        audio: The input audio signal.\n\n    Returns:\n        The normalized audio signal.\n\n    Examples:\n    >>> audio = np.array([1, 2, 3, 4, 5])\n    >>> normalized_audio = normalize(audio)\n    >>> float(np.max(normalized_audio))\n    1.0\n    >>> float(np.min(normalized_audio))\n    0.2\n    \"\"\"\n    # Divide the entire audio signal by the maximum absolute value\n    return audio / np.max(np.abs(audio))",
    "docstring": "Normalize an audio signal by scaling it to have values between -1 and 1.\n\nArgs:\n    audio: The input audio signal.\n\nReturns:\n    The normalized audio signal.\n\nExamples:\n>>> audio = np.array([1, 2, 3, 4, 5])\n>>> normalized_audio = normalize(audio)\n>>> float(np.max(normalized_audio))\n1.0\n>>> float(np.min(normalized_audio))\n0.2"
  },
  {
    "function": "audio_frames",
    "code": "def audio_frames(\n    audio: np.ndarray,\n    sample_rate: int,\n    hop_length: int = 20,\n    ftt_size: int = 1024,\n) -> np.ndarray:\n    \"\"\"\n    Split an audio signal into overlapping frames.\n\n    Args:\n        audio: The input audio signal.\n        sample_rate: The sample rate of the audio signal.\n        hop_length: The length of the hopping (default is 20ms).\n        ftt_size: The size of the FFT window (default is 1024).\n\n    Returns:\n        An array of overlapping frames.\n\n    Examples:\n    >>> audio = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]*1000)\n    >>> sample_rate = 8000\n    >>> frames = audio_frames(audio, sample_rate, hop_length=10, ftt_size=512)\n    >>> frames.shape\n    (126, 512)\n    \"\"\"\n\n    hop_size = np.round(sample_rate * hop_length / 1000).astype(int)\n\n    # Pad the audio signal to handle edge cases\n    audio = np.pad(audio, int(ftt_size / 2), mode=\"reflect\")\n\n    # Calculate the number of frames\n    frame_count = int((len(audio) - ftt_size) / hop_size) + 1\n\n    # Initialize an array to store the frames\n    frames = np.zeros((frame_count, ftt_size))\n\n    # Split the audio signal into frames\n    for n in range(frame_count):\n        frames[n] = audio[n * hop_size : n * hop_size + ftt_size]\n\n    return frames",
    "docstring": "Split an audio signal into overlapping frames.\n\nArgs:\n    audio: The input audio signal.\n    sample_rate: The sample rate of the audio signal.\n    hop_length: The length of the hopping (default is 20ms).\n    ftt_size: The size of the FFT window (default is 1024).\n\nReturns:\n    An array of overlapping frames.\n\nExamples:\n>>> audio = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]*1000)\n>>> sample_rate = 8000\n>>> frames = audio_frames(audio, sample_rate, hop_length=10, ftt_size=512)\n>>> frames.shape\n(126, 512)"
  },
  {
    "function": "calculate_fft",
    "code": "def calculate_fft(audio_windowed: np.ndarray, ftt_size: int = 1024) -> np.ndarray:\n    \"\"\"\n    Calculate the Fast Fourier Transform (FFT) of windowed audio data.\n\n    Args:\n        audio_windowed: The windowed audio signal.\n        ftt_size: The size of the FFT (default is 1024).\n\n    Returns:\n        The FFT of the audio data.\n\n    Examples:\n    >>> audio_windowed = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n    >>> audio_fft = calculate_fft(audio_windowed, ftt_size=4)\n    >>> bool(np.allclose(audio_fft[0], np.array([6.0+0.j, -1.5+0.8660254j,\n    ...     -1.5-0.8660254j])))\n    True\n    \"\"\"\n    # Transpose the audio data to have time in rows and channels in columns\n    audio_transposed = np.transpose(audio_windowed)\n\n    # Initialize an array to store the FFT results\n    audio_fft = np.empty(\n        (int(1 + ftt_size // 2), audio_transposed.shape[1]),\n        dtype=np.complex64,\n        order=\"F\",\n    )\n\n    # Compute FFT for each channel\n    for n in range(audio_fft.shape[1]):\n        audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]\n\n    # Transpose the FFT results back to the original shape\n    return np.transpose(audio_fft)",
    "docstring": "Calculate the Fast Fourier Transform (FFT) of windowed audio data.\n\nArgs:\n    audio_windowed: The windowed audio signal.\n    ftt_size: The size of the FFT (default is 1024).\n\nReturns:\n    The FFT of the audio data.\n\nExamples:\n>>> audio_windowed = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n>>> audio_fft = calculate_fft(audio_windowed, ftt_size=4)\n>>> bool(np.allclose(audio_fft[0], np.array([6.0+0.j, -1.5+0.8660254j,\n...     -1.5-0.8660254j])))\nTrue"
  },
  {
    "function": "calculate_signal_power",
    "code": "def calculate_signal_power(audio_fft: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculate the power of the audio signal from its FFT.\n\n    Args:\n        audio_fft: The FFT of the audio signal.\n\n    Returns:\n        The power of the audio signal.\n\n    Examples:\n    >>> audio_fft = np.array([1+2j, 2+3j, 3+4j, 4+5j])\n    >>> power = calculate_signal_power(audio_fft)\n    >>> np.allclose(power, np.array([5, 13, 25, 41]))\n    True\n    \"\"\"\n    # Calculate the power by squaring the absolute values of the FFT coefficients\n    return np.square(np.abs(audio_fft))",
    "docstring": "Calculate the power of the audio signal from its FFT.\n\nArgs:\n    audio_fft: The FFT of the audio signal.\n\nReturns:\n    The power of the audio signal.\n\nExamples:\n>>> audio_fft = np.array([1+2j, 2+3j, 3+4j, 4+5j])\n>>> power = calculate_signal_power(audio_fft)\n>>> np.allclose(power, np.array([5, 13, 25, 41]))\nTrue"
  },
  {
    "function": "freq_to_mel",
    "code": "def freq_to_mel(freq: float) -> float:\n    \"\"\"\n    Convert a frequency in Hertz to the mel scale.\n\n    Args:\n        freq: The frequency in Hertz.\n\n    Returns:\n        The frequency in mel scale.\n\n    Examples:\n    >>> float(round(freq_to_mel(1000), 2))\n    999.99\n    \"\"\"\n    # Use the formula to convert frequency to the mel scale\n    return 2595.0 * np.log10(1.0 + freq / 700.0)",
    "docstring": "Convert a frequency in Hertz to the mel scale.\n\nArgs:\n    freq: The frequency in Hertz.\n\nReturns:\n    The frequency in mel scale.\n\nExamples:\n>>> float(round(freq_to_mel(1000), 2))\n999.99"
  },
  {
    "function": "mel_to_freq",
    "code": "def mel_to_freq(mels: float) -> float:\n    \"\"\"\n    Convert a frequency in the mel scale to Hertz.\n\n    Args:\n        mels: The frequency in mel scale.\n\n    Returns:\n        The frequency in Hertz.\n\n    Examples:\n    >>> round(mel_to_freq(999.99), 2)\n    1000.01\n    \"\"\"\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)",
    "docstring": "Convert a frequency in the mel scale to Hertz.\n\nArgs:\n    mels: The frequency in mel scale.\n\nReturns:\n    The frequency in Hertz.\n\nExamples:\n>>> round(mel_to_freq(999.99), 2)\n1000.01"
  },
  {
    "function": "mel_spaced_filterbank",
    "code": "def mel_spaced_filterbank(\n    sample_rate: int, mel_filter_num: int = 10, ftt_size: int = 1024\n) -> np.ndarray:\n    \"\"\"\n    Create a Mel-spaced filter bank for audio processing.\n\n    Args:\n        sample_rate: The sample rate of the audio.\n        mel_filter_num: The number of mel filters (default is 10).\n        ftt_size: The size of the FFT (default is 1024).\n\n    Returns:\n        Mel-spaced filter bank.\n\n    Examples:\n    >>> float(round(mel_spaced_filterbank(8000, 10, 1024)[0][1], 10))\n    0.0004603981\n    \"\"\"\n    freq_min = 0\n    freq_high = sample_rate // 2\n\n    logging.info(f\"Minimum frequency: {freq_min}\")\n    logging.info(f\"Maximum frequency: {freq_high}\")\n\n    # Calculate filter points and mel frequencies\n    filter_points, mel_freqs = get_filter_points(\n        sample_rate,\n        freq_min,\n        freq_high,\n        mel_filter_num,\n        ftt_size,\n    )\n\n    filters = get_filters(filter_points, ftt_size)\n\n    # normalize filters\n    # taken from the librosa library\n    enorm = 2.0 / (mel_freqs[2 : mel_filter_num + 2] - mel_freqs[:mel_filter_num])\n    return filters * enorm[:, np.newaxis]",
    "docstring": "Create a Mel-spaced filter bank for audio processing.\n\nArgs:\n    sample_rate: The sample rate of the audio.\n    mel_filter_num: The number of mel filters (default is 10).\n    ftt_size: The size of the FFT (default is 1024).\n\nReturns:\n    Mel-spaced filter bank.\n\nExamples:\n>>> float(round(mel_spaced_filterbank(8000, 10, 1024)[0][1], 10))\n0.0004603981"
  },
  {
    "function": "get_filters",
    "code": "def get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:\n    \"\"\"\n    Generate filters for audio processing.\n\n    Args:\n        filter_points: A list of filter points.\n        ftt_size: The size of the FFT.\n\n    Returns:\n        A matrix of filters.\n\n    Examples:\n    >>> get_filters(np.array([0, 20, 51, 95, 161, 256], dtype=int), 512).shape\n    (4, 257)\n    \"\"\"\n    num_filters = len(filter_points) - 2\n    filters = np.zeros((num_filters, int(ftt_size / 2) + 1))\n\n    for n in range(num_filters):\n        start = filter_points[n]\n        mid = filter_points[n + 1]\n        end = filter_points[n + 2]\n\n        # Linearly increase values from 0 to 1\n        filters[n, start:mid] = np.linspace(0, 1, mid - start)\n\n        # Linearly decrease values from 1 to 0\n        filters[n, mid:end] = np.linspace(1, 0, end - mid)\n\n    return filters",
    "docstring": "Generate filters for audio processing.\n\nArgs:\n    filter_points: A list of filter points.\n    ftt_size: The size of the FFT.\n\nReturns:\n    A matrix of filters.\n\nExamples:\n>>> get_filters(np.array([0, 20, 51, 95, 161, 256], dtype=int), 512).shape\n(4, 257)"
  },
  {
    "function": "get_filter_points",
    "code": "def get_filter_points(\n    sample_rate: int,\n    freq_min: int,\n    freq_high: int,\n    mel_filter_num: int = 10,\n    ftt_size: int = 1024,\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Calculate the filter points and frequencies for mel frequency filters.\n\n    Args:\n        sample_rate: The sample rate of the audio.\n        freq_min: The minimum frequency in Hertz.\n        freq_high: The maximum frequency in Hertz.\n        mel_filter_num: The number of mel filters (default is 10).\n        ftt_size: The size of the FFT (default is 1024).\n\n    Returns:\n        Filter points and corresponding frequencies.\n\n    Examples:\n    >>> filter_points = get_filter_points(8000, 0, 4000, mel_filter_num=4, ftt_size=512)\n    >>> filter_points[0]\n    array([  0,  20,  51,  95, 161, 256])\n    >>> filter_points[1]\n    array([   0.        ,  324.46707094,  799.33254207, 1494.30973963,\n           2511.42581671, 4000.        ])\n    \"\"\"\n    # Convert minimum and maximum frequencies to mel scale\n    fmin_mel = freq_to_mel(freq_min)\n    fmax_mel = freq_to_mel(freq_high)\n\n    logging.info(f\"MEL min: {fmin_mel}\")\n    logging.info(f\"MEL max: {fmax_mel}\")\n\n    # Generate equally spaced mel frequencies\n    mels = np.linspace(fmin_mel, fmax_mel, num=mel_filter_num + 2)\n\n    # Convert mel frequencies back to Hertz\n    freqs = mel_to_freq(mels)\n\n    # Calculate filter points as integer values\n    filter_points = np.floor((ftt_size + 1) / sample_rate * freqs).astype(int)\n\n    return filter_points, freqs",
    "docstring": "Calculate the filter points and frequencies for mel frequency filters.\n\nArgs:\n    sample_rate: The sample rate of the audio.\n    freq_min: The minimum frequency in Hertz.\n    freq_high: The maximum frequency in Hertz.\n    mel_filter_num: The number of mel filters (default is 10).\n    ftt_size: The size of the FFT (default is 1024).\n\nReturns:\n    Filter points and corresponding frequencies.\n\nExamples:\n>>> filter_points = get_filter_points(8000, 0, 4000, mel_filter_num=4, ftt_size=512)\n>>> filter_points[0]\narray([  0,  20,  51,  95, 161, 256])\n>>> filter_points[1]\narray([   0.        ,  324.46707094,  799.33254207, 1494.30973963,\n       2511.42581671, 4000.        ])"
  },
  {
    "function": "discrete_cosine_transform",
    "code": "def discrete_cosine_transform(dct_filter_num: int, filter_num: int) -> np.ndarray:\n    \"\"\"\n    Compute the Discrete Cosine Transform (DCT) basis matrix.\n\n    Args:\n        dct_filter_num: The number of DCT filters to generate.\n        filter_num: The number of the fbank filters.\n\n    Returns:\n        The DCT basis matrix.\n\n    Examples:\n    >>> float(round(discrete_cosine_transform(3, 5)[0][0], 5))\n    0.44721\n    \"\"\"\n    basis = np.empty((dct_filter_num, filter_num))\n    basis[0, :] = 1.0 / np.sqrt(filter_num)\n\n    samples = np.arange(1, 2 * filter_num, 2) * np.pi / (2.0 * filter_num)\n\n    for i in range(1, dct_filter_num):\n        basis[i, :] = np.cos(i * samples) * np.sqrt(2.0 / filter_num)\n\n    return basis",
    "docstring": "Compute the Discrete Cosine Transform (DCT) basis matrix.\n\nArgs:\n    dct_filter_num: The number of DCT filters to generate.\n    filter_num: The number of the fbank filters.\n\nReturns:\n    The DCT basis matrix.\n\nExamples:\n>>> float(round(discrete_cosine_transform(3, 5)[0][0], 5))\n0.44721"
  },
  {
    "function": "example",
    "code": "def example(wav_file_path: str = \"./path-to-file/sample.wav\") -> np.ndarray:\n    \"\"\"\n    Example function to calculate Mel Frequency Cepstral Coefficients\n    (MFCCs) from an audio file.\n\n    Args:\n        wav_file_path: The path to the WAV audio file.\n\n    Returns:\n        np.ndarray: The computed MFCCs for the audio.\n    \"\"\"\n    from scipy.io import wavfile\n\n    # Load the audio from the WAV file\n    sample_rate, audio = wavfile.read(wav_file_path)\n\n    # Calculate MFCCs\n    return mfcc(audio, sample_rate)",
    "docstring": "Example function to calculate Mel Frequency Cepstral Coefficients\n(MFCCs) from an audio file.\n\nArgs:\n    wav_file_path: The path to the WAV audio file.\n\nReturns:\n    np.ndarray: The computed MFCCs for the audio."
  },
  {
    "function": "wrapper",
    "code": "def wrapper(y):\n    \"\"\"\n    >>> [int(x) for x in wrapper(Y)]\n    [0, 0, 1]\n    \"\"\"\n    return list(y)",
    "docstring": ">>> [int(x) for x in wrapper(Y)]\n[0, 0, 1]"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Fit a polynomial regression model to predict fuel efficiency using seaborn's mpg\n    dataset\n\n    >>> pass    # Placeholder, function is only for demo purposes\n    \"\"\"\n    import seaborn as sns\n\n    mpg_data = sns.load_dataset(\"mpg\")\n\n    poly_reg = PolynomialRegression(degree=2)\n    poly_reg.fit(mpg_data.weight, mpg_data.mpg)\n\n    weight_sorted = np.sort(mpg_data.weight)\n    predictions = poly_reg.predict(weight_sorted)\n\n    plt.scatter(mpg_data.weight, mpg_data.mpg, color=\"gray\", alpha=0.5)\n    plt.plot(weight_sorted, predictions, color=\"red\", linewidth=3)\n    plt.title(\"Predicting Fuel Efficiency Using Polynomial Regression\")\n    plt.xlabel(\"Weight (lbs)\")\n    plt.ylabel(\"Fuel Efficiency (mpg)\")\n    plt.show()",
    "docstring": "Fit a polynomial regression model to predict fuel efficiency using seaborn's mpg\ndataset\n\n>>> pass    # Placeholder, function is only for demo purposes"
  },
  {
    "function": "collect_dataset",
    "code": "def collect_dataset() -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Collects the dataset (Iris dataset) and returns feature matrix and target values.\n\n    :return: Tuple containing feature matrix (X) and target labels (y)\n\n    Example:\n    >>> X, y = collect_dataset()\n    >>> X.shape\n    (150, 4)\n    >>> y.shape\n    (150,)\n    \"\"\"\n    data = load_iris()\n    return np.array(data.data), np.array(data.target)",
    "docstring": "Collects the dataset (Iris dataset) and returns feature matrix and target values.\n\n:return: Tuple containing feature matrix (X) and target labels (y)\n\nExample:\n>>> X, y = collect_dataset()\n>>> X.shape\n(150, 4)\n>>> y.shape\n(150,)"
  },
  {
    "function": "apply_pca",
    "code": "def apply_pca(data_x: np.ndarray, n_components: int) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Applies Principal Component Analysis (PCA) to reduce dimensionality.\n\n    :param data_x: Original dataset (features)\n    :param n_components: Number of principal components to retain\n    :return: Tuple containing transformed dataset and explained variance ratio\n\n    Example:\n    >>> X, _ = collect_dataset()\n    >>> transformed_X, variance = apply_pca(X, 2)\n    >>> transformed_X.shape\n    (150, 2)\n    >>> len(variance) == 2\n    True\n    \"\"\"\n    # Standardizing the dataset\n    scaler = StandardScaler()\n    data_x_scaled = scaler.fit_transform(data_x)\n\n    # Applying PCA\n    pca = PCA(n_components=n_components)\n    principal_components = pca.fit_transform(data_x_scaled)\n\n    return principal_components, pca.explained_variance_ratio_",
    "docstring": "Applies Principal Component Analysis (PCA) to reduce dimensionality.\n\n:param data_x: Original dataset (features)\n:param n_components: Number of principal components to retain\n:return: Tuple containing transformed dataset and explained variance ratio\n\nExample:\n>>> X, _ = collect_dataset()\n>>> transformed_X, variance = apply_pca(X, 2)\n>>> transformed_X.shape\n(150, 2)\n>>> len(variance) == 2\nTrue"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Driver function to execute PCA and display results.\n    \"\"\"\n    data_x, _data_y = collect_dataset()\n\n    # Number of principal components to retain\n    n_components = 2\n\n    # Apply PCA\n    transformed_data, variance_ratio = apply_pca(data_x, n_components)\n\n    print(\"Transformed Dataset (First 5 rows):\")\n    print(transformed_data[:5])\n\n    print(\"\\nExplained Variance Ratio:\")\n    print(variance_ratio)",
    "docstring": "Driver function to execute PCA and display results."
  },
  {
    "function": "mae",
    "code": "def mae(predict, actual):\n    \"\"\"\n    Examples(rounded for precision):\n    >>> actual = [1,2,3];predict = [1,4,3]\n    >>> float(np.around(mae(predict,actual),decimals = 2))\n    0.67\n\n    >>> actual = [1,1,1];predict = [1,1,1]\n    >>> float(mae(predict,actual))\n    0.0\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = abs(predict - actual)\n    score = difference.mean()\n\n    return score",
    "docstring": "Examples(rounded for precision):\n>>> actual = [1,2,3];predict = [1,4,3]\n>>> float(np.around(mae(predict,actual),decimals = 2))\n0.67\n\n>>> actual = [1,1,1];predict = [1,1,1]\n>>> float(mae(predict,actual))\n0.0"
  },
  {
    "function": "mse",
    "code": "def mse(predict, actual):\n    \"\"\"\n    Examples(rounded for precision):\n    >>> actual = [1,2,3];predict = [1,4,3]\n    >>> float(np.around(mse(predict,actual),decimals = 2))\n    1.33\n\n    >>> actual = [1,1,1];predict = [1,1,1]\n    >>> float(mse(predict,actual))\n    0.0\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    square_diff = np.square(difference)\n\n    score = square_diff.mean()\n    return score",
    "docstring": "Examples(rounded for precision):\n>>> actual = [1,2,3];predict = [1,4,3]\n>>> float(np.around(mse(predict,actual),decimals = 2))\n1.33\n\n>>> actual = [1,1,1];predict = [1,1,1]\n>>> float(mse(predict,actual))\n0.0"
  },
  {
    "function": "rmse",
    "code": "def rmse(predict, actual):\n    \"\"\"\n    Examples(rounded for precision):\n    >>> actual = [1,2,3];predict = [1,4,3]\n    >>> float(np.around(rmse(predict,actual),decimals = 2))\n    1.15\n\n    >>> actual = [1,1,1];predict = [1,1,1]\n    >>> float(rmse(predict,actual))\n    0.0\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    square_diff = np.square(difference)\n    mean_square_diff = square_diff.mean()\n    score = np.sqrt(mean_square_diff)\n    return score",
    "docstring": "Examples(rounded for precision):\n>>> actual = [1,2,3];predict = [1,4,3]\n>>> float(np.around(rmse(predict,actual),decimals = 2))\n1.15\n\n>>> actual = [1,1,1];predict = [1,1,1]\n>>> float(rmse(predict,actual))\n0.0"
  },
  {
    "function": "rmsle",
    "code": "def rmsle(predict, actual):\n    \"\"\"\n    Examples(rounded for precision):\n    >>> float(np.around(rmsle(predict=[10, 2, 30], actual=[10, 10, 30]), decimals=2))\n    0.75\n\n    >>> float(rmsle(predict=[1, 1, 1], actual=[1, 1, 1]))\n    0.0\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    log_predict = np.log(predict + 1)\n    log_actual = np.log(actual + 1)\n\n    difference = log_predict - log_actual\n    square_diff = np.square(difference)\n    mean_square_diff = square_diff.mean()\n\n    score = np.sqrt(mean_square_diff)\n\n    return score",
    "docstring": "Examples(rounded for precision):\n>>> float(np.around(rmsle(predict=[10, 2, 30], actual=[10, 10, 30]), decimals=2))\n0.75\n\n>>> float(rmsle(predict=[1, 1, 1], actual=[1, 1, 1]))\n0.0"
  },
  {
    "function": "mbd",
    "code": "def mbd(predict, actual):\n    \"\"\"\n    This value is Negative, if the model underpredicts,\n    positive, if it overpredicts.\n\n    Example(rounded for precision):\n\n    Here the model overpredicts\n    >>> actual = [1,2,3];predict = [2,3,4]\n    >>> float(np.around(mbd(predict,actual),decimals = 2))\n    50.0\n\n    Here the model underpredicts\n    >>> actual = [1,2,3];predict = [0,1,1]\n    >>> float(np.around(mbd(predict,actual),decimals = 2))\n    -66.67\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    numerator = np.sum(difference) / len(predict)\n    denumerator = np.sum(actual) / len(predict)\n    # print(numerator, denumerator)\n    score = float(numerator) / denumerator * 100\n\n    return score",
    "docstring": "This value is Negative, if the model underpredicts,\npositive, if it overpredicts.\n\nExample(rounded for precision):\n\nHere the model overpredicts\n>>> actual = [1,2,3];predict = [2,3,4]\n>>> float(np.around(mbd(predict,actual),decimals = 2))\n50.0\n\nHere the model underpredicts\n>>> actual = [1,2,3];predict = [0,1,1]\n>>> float(np.around(mbd(predict,actual),decimals = 2))\n-66.67"
  },
  {
    "function": "plot_partition_boundary",
    "code": "def plot_partition_boundary(\n    model, train_data, ax, resolution=100, colors=(\"b\", \"k\", \"r\")\n):\n    \"\"\"\n    We cannot get the optimal w of our kernel SVM model, which is different from a\n    linear SVM.  For this reason, we generate randomly distributed points with high\n    density, and predicted values of these points are calculated using our trained\n    model. Then we could use this predicted values to draw contour map, and this contour\n    map represents the SVM's partition boundary.\n    \"\"\"\n    train_data_x = train_data[:, 1]\n    train_data_y = train_data[:, 2]\n    train_data_tags = train_data[:, 0]\n    xrange = np.linspace(train_data_x.min(), train_data_x.max(), resolution)\n    yrange = np.linspace(train_data_y.min(), train_data_y.max(), resolution)\n    test_samples = np.array([(x, y) for x in xrange for y in yrange]).reshape(\n        resolution * resolution, 2\n    )\n\n    test_tags = model.predict(test_samples, classify=False)\n    grid = test_tags.reshape((len(xrange), len(yrange)))\n\n    # Plot contour map which represents the partition boundary\n    ax.contour(\n        xrange,\n        yrange,\n        np.asmatrix(grid).T,\n        levels=(-1, 0, 1),\n        linestyles=(\"--\", \"-\", \"--\"),\n        linewidths=(1, 1, 1),\n        colors=colors,\n    )\n    # Plot all train samples\n    ax.scatter(\n        train_data_x,\n        train_data_y,\n        c=train_data_tags,\n        cmap=plt.cm.Dark2,\n        lw=0,\n        alpha=0.5,\n    )\n\n    # Plot support vectors\n    support = model.support\n    ax.scatter(\n        train_data_x[support],\n        train_data_y[support],\n        c=train_data_tags[support],\n        cmap=plt.cm.Dark2,\n    )",
    "docstring": "We cannot get the optimal w of our kernel SVM model, which is different from a\nlinear SVM.  For this reason, we generate randomly distributed points with high\ndensity, and predicted values of these points are calculated using our trained\nmodel. Then we could use this predicted values to draw contour map, and this contour\nmap represents the SVM's partition boundary."
  },
  {
    "function": "euclidean",
    "code": "def euclidean(input_a: np.ndarray, input_b: np.ndarray) -> float:\n    \"\"\"\n    Calculates euclidean distance between two data.\n    :param input_a: ndarray of first vector.\n    :param input_b: ndarray of second vector.\n    :return: Euclidean distance of input_a and input_b. By using math.sqrt(),\n             result will be float.\n\n    >>> euclidean(np.array([0]), np.array([1]))\n    1.0\n    >>> euclidean(np.array([0, 1]), np.array([1, 1]))\n    1.0\n    >>> euclidean(np.array([0, 0, 0]), np.array([0, 0, 1]))\n    1.0\n    \"\"\"\n    return math.sqrt(sum(pow(a - b, 2) for a, b in zip(input_a, input_b)))",
    "docstring": "Calculates euclidean distance between two data.\n:param input_a: ndarray of first vector.\n:param input_b: ndarray of second vector.\n:return: Euclidean distance of input_a and input_b. By using math.sqrt(),\n         result will be float.\n\n>>> euclidean(np.array([0]), np.array([1]))\n1.0\n>>> euclidean(np.array([0, 1]), np.array([1, 1]))\n1.0\n>>> euclidean(np.array([0, 0, 0]), np.array([0, 0, 1]))\n1.0"
  },
  {
    "function": "similarity_search",
    "code": "def similarity_search(\n    dataset: np.ndarray, value_array: np.ndarray\n) -> list[list[list[float] | float]]:\n    \"\"\"\n    :param dataset: Set containing the vectors. Should be ndarray.\n    :param value_array: vector/vectors we want to know the nearest vector from dataset.\n    :return: Result will be a list containing\n            1. the nearest vector\n            2. distance from the vector\n\n    >>> dataset = np.array([[0], [1], [2]])\n    >>> value_array = np.array([[0]])\n    >>> similarity_search(dataset, value_array)\n    [[[0], 0.0]]\n\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 0.0], [[0, 0, 0], 1.0]]\n\n    These are the errors that might occur:\n\n    1. If dimensions are different.\n    For example, dataset has 2d array and value_array has 1d array:\n    >>> dataset = np.array([[1]])\n    >>> value_array = np.array([1])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's dimensions... dataset : 2, value_array : 1\n\n    2. If data's shapes are different.\n    For example, dataset has shape of (3, 2) and value_array has (2, 3).\n    We are expecting same shapes of two arrays, so it is wrong.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's shape... dataset : 2, value_array : 3\n\n    3. If data types are different.\n    When trying to compare, we are expecting same types so they should be same.\n    If not, it'll come up with errors.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]], dtype=np.float32)\n    >>> value_array = np.array([[0, 0], [0, 1]], dtype=np.int32)\n    >>> similarity_search(dataset, value_array)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    TypeError: Input data have different datatype...\n    dataset : float32, value_array : int32\n    \"\"\"\n\n    if dataset.ndim != value_array.ndim:\n        msg = (\n            \"Wrong input data's dimensions... \"\n            f\"dataset : {dataset.ndim}, value_array : {value_array.ndim}\"\n        )\n        raise ValueError(msg)\n\n    try:\n        if dataset.shape[1] != value_array.shape[1]:\n            msg = (\n                \"Wrong input data's shape... \"\n                f\"dataset : {dataset.shape[1]}, value_array : {value_array.shape[1]}\"\n            )\n            raise ValueError(msg)\n    except IndexError:\n        if dataset.ndim != value_array.ndim:\n            raise TypeError(\"Wrong shape\")\n\n    if dataset.dtype != value_array.dtype:\n        msg = (\n            \"Input data have different datatype... \"\n            f\"dataset : {dataset.dtype}, value_array : {value_array.dtype}\"\n        )\n        raise TypeError(msg)\n\n    answer = []\n\n    for value in value_array:\n        dist = euclidean(value, dataset[0])\n        vector = dataset[0].tolist()\n\n        for dataset_value in dataset[1:]:\n            temp_dist = euclidean(value, dataset_value)\n\n            if dist > temp_dist:\n                dist = temp_dist\n                vector = dataset_value.tolist()\n\n        answer.append([vector, dist])\n\n    return answer",
    "docstring": ":param dataset: Set containing the vectors. Should be ndarray.\n:param value_array: vector/vectors we want to know the nearest vector from dataset.\n:return: Result will be a list containing\n        1. the nearest vector\n        2. distance from the vector\n\n>>> dataset = np.array([[0], [1], [2]])\n>>> value_array = np.array([[0]])\n>>> similarity_search(dataset, value_array)\n[[[0], 0.0]]\n\n>>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n>>> value_array = np.array([[0, 1]])\n>>> similarity_search(dataset, value_array)\n[[[0, 0], 1.0]]\n\n>>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n>>> value_array = np.array([[0, 0, 1]])\n>>> similarity_search(dataset, value_array)\n[[[0, 0, 0], 1.0]]\n\n>>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n>>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n>>> similarity_search(dataset, value_array)\n[[[0, 0, 0], 0.0], [[0, 0, 0], 1.0]]\n\nThese are the errors that might occur:\n\n1. If dimensions are different.\nFor example, dataset has 2d array and value_array has 1d array:\n>>> dataset = np.array([[1]])\n>>> value_array = np.array([1])\n>>> similarity_search(dataset, value_array)\nTraceback (most recent call last):\n    ...\nValueError: Wrong input data's dimensions... dataset : 2, value_array : 1\n\n2. If data's shapes are different.\nFor example, dataset has shape of (3, 2) and value_array has (2, 3).\nWe are expecting same shapes of two arrays, so it is wrong.\n>>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n>>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n>>> similarity_search(dataset, value_array)\nTraceback (most recent call last):\n    ...\nValueError: Wrong input data's shape... dataset : 2, value_array : 3\n\n3. If data types are different.\nWhen trying to compare, we are expecting same types so they should be same.\nIf not, it'll come up with errors.\n>>> dataset = np.array([[0, 0], [1, 1], [2, 2]], dtype=np.float32)\n>>> value_array = np.array([[0, 0], [0, 1]], dtype=np.int32)\n>>> similarity_search(dataset, value_array)  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nTypeError: Input data have different datatype...\ndataset : float32, value_array : int32"
  },
  {
    "function": "cosine_similarity",
    "code": "def cosine_similarity(input_a: np.ndarray, input_b: np.ndarray) -> float:\n    \"\"\"\n    Calculates cosine similarity between two data.\n    :param input_a: ndarray of first vector.\n    :param input_b: ndarray of second vector.\n    :return: Cosine similarity of input_a and input_b. By using math.sqrt(),\n             result will be float.\n\n    >>> cosine_similarity(np.array([1]), np.array([1]))\n    1.0\n    >>> cosine_similarity(np.array([1, 2]), np.array([6, 32]))\n    0.9615239476408232\n    \"\"\"\n    return float(np.dot(input_a, input_b) / (norm(input_a) * norm(input_b)))",
    "docstring": "Calculates cosine similarity between two data.\n:param input_a: ndarray of first vector.\n:param input_b: ndarray of second vector.\n:return: Cosine similarity of input_a and input_b. By using math.sqrt(),\n         result will be float.\n\n>>> cosine_similarity(np.array([1]), np.array([1]))\n1.0\n>>> cosine_similarity(np.array([1, 2]), np.array([6, 32]))\n0.9615239476408232"
  },
  {
    "function": "norm_squared",
    "code": "def norm_squared(vector: ndarray) -> float:\n    \"\"\"\n    Return the squared second norm of vector\n    norm_squared(v) = sum(x * x for x in v)\n\n    Args:\n        vector (ndarray): input vector\n\n    Returns:\n        float: squared second norm of vector\n\n    >>> int(norm_squared([1, 2]))\n    5\n    >>> int(norm_squared(np.asarray([1, 2])))\n    5\n    >>> int(norm_squared([0, 0]))\n    0\n    \"\"\"\n    return np.dot(vector, vector)",
    "docstring": "Return the squared second norm of vector\nnorm_squared(v) = sum(x * x for x in v)\n\nArgs:\n    vector (ndarray): input vector\n\nReturns:\n    float: squared second norm of vector\n\n>>> int(norm_squared([1, 2]))\n5\n>>> int(norm_squared(np.asarray([1, 2])))\n5\n>>> int(norm_squared([0, 0]))\n0"
  },
  {
    "function": "collect_dataset",
    "code": "def collect_dataset() -> tuple[ndarray, ndarray]:\n    \"\"\"\n    Load the Iris dataset and return features and labels.\n\n    Returns:\n        tuple[ndarray, ndarray]: Feature matrix and target labels.\n\n    >>> features, targets = collect_dataset()\n    >>> features.shape\n    (150, 4)\n    >>> targets.shape\n    (150,)\n    \"\"\"\n    iris_dataset = load_iris()\n    return np.array(iris_dataset.data), np.array(iris_dataset.target)",
    "docstring": "Load the Iris dataset and return features and labels.\n\nReturns:\n    tuple[ndarray, ndarray]: Feature matrix and target labels.\n\n>>> features, targets = collect_dataset()\n>>> features.shape\n(150, 4)\n>>> targets.shape\n(150,)"
  },
  {
    "function": "compute_pairwise_affinities",
    "code": "def compute_pairwise_affinities(data_matrix: ndarray, sigma: float = 1.0) -> ndarray:\n    \"\"\"\n    Compute high-dimensional affinities (P matrix) using a Gaussian kernel.\n\n    Args:\n        data_matrix: Input data of shape (n_samples, n_features).\n        sigma: Gaussian kernel bandwidth.\n\n    Returns:\n        ndarray: Symmetrized probability matrix.\n\n    >>> x = np.array([[0.0, 0.0], [1.0, 0.0]])\n    >>> probabilities = compute_pairwise_affinities(x)\n    >>> float(round(probabilities[0, 1], 3))\n    0.25\n    \"\"\"\n    n_samples = data_matrix.shape[0]\n    squared_sum = np.sum(np.square(data_matrix), axis=1)\n    squared_distance = np.add(\n        np.add(-2 * np.dot(data_matrix, data_matrix.T), squared_sum).T, squared_sum\n    )\n\n    affinity_matrix = np.exp(-squared_distance / (2 * sigma**2))\n    np.fill_diagonal(affinity_matrix, 0)\n\n    affinity_matrix /= np.sum(affinity_matrix)\n    return (affinity_matrix + affinity_matrix.T) / (2 * n_samples)",
    "docstring": "Compute high-dimensional affinities (P matrix) using a Gaussian kernel.\n\nArgs:\n    data_matrix: Input data of shape (n_samples, n_features).\n    sigma: Gaussian kernel bandwidth.\n\nReturns:\n    ndarray: Symmetrized probability matrix.\n\n>>> x = np.array([[0.0, 0.0], [1.0, 0.0]])\n>>> probabilities = compute_pairwise_affinities(x)\n>>> float(round(probabilities[0, 1], 3))\n0.25"
  },
  {
    "function": "compute_low_dim_affinities",
    "code": "def compute_low_dim_affinities(embedding_matrix: ndarray) -> tuple[ndarray, ndarray]:\n    \"\"\"\n    Compute low-dimensional affinities (Q matrix) using a Student-t distribution.\n\n    Args:\n        embedding_matrix: Low-dimensional embedding of shape (n_samples, n_components).\n\n    Returns:\n        tuple[ndarray, ndarray]: (Q probability matrix, numerator matrix).\n\n    >>> y = np.array([[0.0, 0.0], [1.0, 0.0]])\n    >>> q_matrix, numerators = compute_low_dim_affinities(y)\n    >>> q_matrix.shape\n    (2, 2)\n    \"\"\"\n    squared_sum = np.sum(np.square(embedding_matrix), axis=1)\n    numerator_matrix = 1 / (\n        1\n        + np.add(\n            np.add(-2 * np.dot(embedding_matrix, embedding_matrix.T), squared_sum).T,\n            squared_sum,\n        )\n    )\n    np.fill_diagonal(numerator_matrix, 0)\n\n    q_matrix = numerator_matrix / np.sum(numerator_matrix)\n    return q_matrix, numerator_matrix",
    "docstring": "Compute low-dimensional affinities (Q matrix) using a Student-t distribution.\n\nArgs:\n    embedding_matrix: Low-dimensional embedding of shape (n_samples, n_components).\n\nReturns:\n    tuple[ndarray, ndarray]: (Q probability matrix, numerator matrix).\n\n>>> y = np.array([[0.0, 0.0], [1.0, 0.0]])\n>>> q_matrix, numerators = compute_low_dim_affinities(y)\n>>> q_matrix.shape\n(2, 2)"
  },
  {
    "function": "apply_tsne",
    "code": "def apply_tsne(\n    data_matrix: ndarray,\n    n_components: int = 2,\n    learning_rate: float = 200.0,\n    n_iter: int = 500,\n) -> ndarray:\n    \"\"\"\n    Apply t-SNE for dimensionality reduction.\n\n    Args:\n        data_matrix: Original dataset (features).\n        n_components: Target dimension (2D or 3D).\n        learning_rate: Step size for gradient descent.\n        n_iter: Number of iterations.\n\n    Returns:\n        ndarray: Low-dimensional embedding of the data.\n\n    >>> features, _ = collect_dataset()\n    >>> embedding = apply_tsne(features, n_components=2, n_iter=50)\n    >>> embedding.shape\n    (150, 2)\n    \"\"\"\n    if n_components < 1 or n_iter < 1:\n        raise ValueError(\"n_components and n_iter must be >= 1\")\n\n    n_samples = data_matrix.shape[0]\n    rng = np.random.default_rng()\n    embedding = rng.standard_normal((n_samples, n_components)) * 1e-4\n\n    high_dim_affinities = compute_pairwise_affinities(data_matrix)\n    high_dim_affinities = np.maximum(high_dim_affinities, 1e-12)\n\n    embedding_increment = np.zeros_like(embedding)\n    momentum = 0.5\n\n    for iteration in range(n_iter):\n        low_dim_affinities, numerator_matrix = compute_low_dim_affinities(embedding)\n        low_dim_affinities = np.maximum(low_dim_affinities, 1e-12)\n\n        affinity_diff = high_dim_affinities - low_dim_affinities\n\n        gradient = 4 * (\n            np.dot((affinity_diff * numerator_matrix), embedding)\n            - np.multiply(\n                np.sum(affinity_diff * numerator_matrix, axis=1)[:, np.newaxis],\n                embedding,\n            )\n        )\n\n        embedding_increment = momentum * embedding_increment - learning_rate * gradient\n        embedding += embedding_increment\n\n        if iteration == int(n_iter / 4):\n            momentum = 0.8\n\n    return embedding",
    "docstring": "Apply t-SNE for dimensionality reduction.\n\nArgs:\n    data_matrix: Original dataset (features).\n    n_components: Target dimension (2D or 3D).\n    learning_rate: Step size for gradient descent.\n    n_iter: Number of iterations.\n\nReturns:\n    ndarray: Low-dimensional embedding of the data.\n\n>>> features, _ = collect_dataset()\n>>> embedding = apply_tsne(features, n_components=2, n_iter=50)\n>>> embedding.shape\n(150, 2)"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Run t-SNE on the Iris dataset and display the first 5 embeddings.\n\n    >>> main()  # doctest: +ELLIPSIS\n    t-SNE embedding (first 5 points):\n    [[...\n    \"\"\"\n    features, _labels = collect_dataset()\n    embedding = apply_tsne(features, n_components=2, n_iter=300)\n\n    if not isinstance(embedding, np.ndarray):\n        raise TypeError(\"t-SNE embedding must be an ndarray\")\n\n    print(\"t-SNE embedding (first 5 points):\")\n    print(embedding[:5])",
    "docstring": "Run t-SNE on the Iris dataset and display the first 5 embeddings.\n\n>>> main()  # doctest: +ELLIPSIS\nt-SNE embedding (first 5 points):\n[[..."
  },
  {
    "function": "term_frequency",
    "code": "def term_frequency(term: str, document: str) -> int:\n    \"\"\"\n    Return the number of times a term occurs within\n    a given document.\n    @params: term, the term to search a document for, and document,\n            the document to search within\n    @returns: an integer representing the number of times a term is\n            found within the document\n\n    @examples:\n    >>> term_frequency(\"to\", \"To be, or not to be\")\n    2\n    \"\"\"\n    # strip all punctuation and newlines and replace it with ''\n    document_without_punctuation = document.translate(\n        str.maketrans(\"\", \"\", string.punctuation)\n    ).replace(\"\\n\", \"\")\n    tokenize_document = document_without_punctuation.split(\" \")  # word tokenization\n    return len([word for word in tokenize_document if word.lower() == term.lower()])",
    "docstring": "Return the number of times a term occurs within\na given document.\n@params: term, the term to search a document for, and document,\n        the document to search within\n@returns: an integer representing the number of times a term is\n        found within the document\n\n@examples:\n>>> term_frequency(\"to\", \"To be, or not to be\")\n2"
  },
  {
    "function": "document_frequency",
    "code": "def document_frequency(term: str, corpus: str) -> tuple[int, int]:\n    \"\"\"\n    Calculate the number of documents in a corpus that contain a\n    given term\n    @params : term, the term to search each document for, and corpus, a collection of\n             documents. Each document should be separated by a newline.\n    @returns : the number of documents in the corpus that contain the term you are\n               searching for and the number of documents in the corpus\n    @examples :\n    >>> document_frequency(\"first\", \"This is the first document in the corpus.\\\\nThIs\\\nis the second document in the corpus.\\\\nTHIS is \\\nthe third document in the corpus.\")\n    (1, 3)\n    \"\"\"\n    corpus_without_punctuation = corpus.lower().translate(\n        str.maketrans(\"\", \"\", string.punctuation)\n    )  # strip all punctuation and replace it with ''\n    docs = corpus_without_punctuation.split(\"\\n\")\n    term = term.lower()\n    return (len([doc for doc in docs if term in doc]), len(docs))",
    "docstring": "Calculate the number of documents in a corpus that contain a\ngiven term\n@params : term, the term to search each document for, and corpus, a collection of\n         documents. Each document should be separated by a newline.\n@returns : the number of documents in the corpus that contain the term you are\n           searching for and the number of documents in the corpus\n@examples :\n>>> document_frequency(\"first\", \"This is the first document in the corpus.\\nThIsis the second document in the corpus.\\nTHIS is the third document in the corpus.\")\n(1, 3)"
  },
  {
    "function": "inverse_document_frequency",
    "code": "def inverse_document_frequency(df: int, n: int, smoothing=False) -> float:\n    \"\"\"\n    Return an integer denoting the importance\n    of a word. This measure of importance is\n    calculated by log10(N/df), where N is the\n    number of documents and df is\n    the Document Frequency.\n    @params : df, the Document Frequency, N,\n    the number of documents in the corpus and\n    smoothing, if True return the idf-smooth\n    @returns : log10(N/df) or 1+log10(N/1+df)\n    @examples :\n    >>> inverse_document_frequency(3, 0)\n    Traceback (most recent call last):\n     ...\n    ValueError: log10(0) is undefined.\n    >>> inverse_document_frequency(1, 3)\n    0.477\n    >>> inverse_document_frequency(0, 3)\n    Traceback (most recent call last):\n     ...\n    ZeroDivisionError: df must be > 0\n    >>> inverse_document_frequency(0, 3,True)\n    1.477\n    \"\"\"\n    if smoothing:\n        if n == 0:\n            raise ValueError(\"log10(0) is undefined.\")\n        return round(1 + log10(n / (1 + df)), 3)\n\n    if df == 0:\n        raise ZeroDivisionError(\"df must be > 0\")\n    elif n == 0:\n        raise ValueError(\"log10(0) is undefined.\")\n    return round(log10(n / df), 3)",
    "docstring": "Return an integer denoting the importance\nof a word. This measure of importance is\ncalculated by log10(N/df), where N is the\nnumber of documents and df is\nthe Document Frequency.\n@params : df, the Document Frequency, N,\nthe number of documents in the corpus and\nsmoothing, if True return the idf-smooth\n@returns : log10(N/df) or 1+log10(N/1+df)\n@examples :\n>>> inverse_document_frequency(3, 0)\nTraceback (most recent call last):\n ...\nValueError: log10(0) is undefined.\n>>> inverse_document_frequency(1, 3)\n0.477\n>>> inverse_document_frequency(0, 3)\nTraceback (most recent call last):\n ...\nZeroDivisionError: df must be > 0\n>>> inverse_document_frequency(0, 3,True)\n1.477"
  },
  {
    "function": "tf_idf",
    "code": "def tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)",
    "docstring": "Combine the term frequency\nand inverse document frequency functions to\ncalculate the originality of a term. This\n'originality' is calculated by multiplying\nthe term frequency and the inverse document\nfrequency : tf-idf = TF * IDF\n@params : tf, the term frequency, and idf, the inverse document\nfrequency\n@examples :\n>>> tf_idf(2, 0.477)\n0.954"
  },
  {
    "function": "data_handling",
    "code": "def data_handling(data: dict) -> tuple:\n    # Split dataset into features and target\n    # data is features\n    \"\"\"\n    >>> data_handling(({'data':'[5.1, 3.5, 1.4, 0.2]','target':([0])}))\n    ('[5.1, 3.5, 1.4, 0.2]', [0])\n    >>> data_handling(\n    ...     {'data': '[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', 'target': ([0, 0])}\n    ... )\n    ('[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', [0, 0])\n    \"\"\"\n    return (data[\"data\"], data[\"target\"])",
    "docstring": ">>> data_handling(({'data':'[5.1, 3.5, 1.4, 0.2]','target':([0])}))\n('[5.1, 3.5, 1.4, 0.2]', [0])\n>>> data_handling(\n...     {'data': '[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', 'target': ([0, 0])}\n... )\n('[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', [0, 0])"
  },
  {
    "function": "xgboost",
    "code": "def xgboost(features: np.ndarray, target: np.ndarray) -> XGBClassifier:\n    \"\"\"\n    # THIS TEST IS BROKEN!! >>> xgboost(np.array([[5.1, 3.6, 1.4, 0.2]]), np.array([0]))\n    XGBClassifier(base_score=0.5, booster='gbtree', callbacks=None,\n                  colsample_bylevel=1, colsample_bynode=1, colsample_bytree=1,\n                  early_stopping_rounds=None, enable_categorical=False,\n                  eval_metric=None, gamma=0, gpu_id=-1, grow_policy='depthwise',\n                  importance_type=None, interaction_constraints='',\n                  learning_rate=0.300000012, max_bin=256, max_cat_to_onehot=4,\n                  max_delta_step=0, max_depth=6, max_leaves=0, min_child_weight=1,\n                  missing=nan, monotone_constraints='()', n_estimators=100,\n                  n_jobs=0, num_parallel_tree=1, predictor='auto', random_state=0,\n                  reg_alpha=0, reg_lambda=1, ...)\n    \"\"\"\n    classifier = XGBClassifier()\n    classifier.fit(features, target)\n    return classifier",
    "docstring": "# THIS TEST IS BROKEN!! >>> xgboost(np.array([[5.1, 3.6, 1.4, 0.2]]), np.array([0]))\nXGBClassifier(base_score=0.5, booster='gbtree', callbacks=None,\n              colsample_bylevel=1, colsample_bynode=1, colsample_bytree=1,\n              early_stopping_rounds=None, enable_categorical=False,\n              eval_metric=None, gamma=0, gpu_id=-1, grow_policy='depthwise',\n              importance_type=None, interaction_constraints='',\n              learning_rate=0.300000012, max_bin=256, max_cat_to_onehot=4,\n              max_delta_step=0, max_depth=6, max_leaves=0, min_child_weight=1,\n              missing=nan, monotone_constraints='()', n_estimators=100,\n              n_jobs=0, num_parallel_tree=1, predictor='auto', random_state=0,\n              reg_alpha=0, reg_lambda=1, ...)"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    Url for the algorithm:\n    https://xgboost.readthedocs.io/en/stable/\n    Iris type dataset is used to demonstrate algorithm.\n    \"\"\"\n\n    # Load Iris dataset\n    iris = load_iris()\n    features, targets = data_handling(iris)\n    x_train, x_test, y_train, y_test = train_test_split(\n        features, targets, test_size=0.25\n    )\n\n    names = iris[\"target_names\"]\n\n    # Create an XGBoost Classifier from the training data\n    xgboost_classifier = xgboost(x_train, y_train)\n\n    # Display the confusion matrix of the classifier with both training and test sets\n    ConfusionMatrixDisplay.from_estimator(\n        xgboost_classifier,\n        x_test,\n        y_test,\n        display_labels=names,\n        cmap=\"Blues\",\n        normalize=\"true\",\n    )\n    plt.title(\"Normalized Confusion Matrix - IRIS Dataset\")\n    plt.show()",
    "docstring": "Url for the algorithm:\nhttps://xgboost.readthedocs.io/en/stable/\nIris type dataset is used to demonstrate algorithm."
  },
  {
    "function": "data_handling",
    "code": "def data_handling(data: dict) -> tuple:\n    # Split dataset into features and target.  Data is features.\n    \"\"\"\n    >>> data_handling((\n    ...  {'data':'[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]'\n    ...  ,'target':([4.526])}))\n    ('[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]', [4.526])\n    \"\"\"\n    return (data[\"data\"], data[\"target\"])",
    "docstring": ">>> data_handling((\n...  {'data':'[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]'\n...  ,'target':([4.526])}))\n('[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]', [4.526])"
  },
  {
    "function": "xgboost",
    "code": "def xgboost(\n    features: np.ndarray, target: np.ndarray, test_features: np.ndarray\n) -> np.ndarray:\n    \"\"\"\n    >>> xgboost(np.array([[ 2.3571 ,   52. , 6.00813008, 1.06775068,\n    ...    907. , 2.45799458,   40.58 , -124.26]]),np.array([1.114]),\n    ... np.array([[1.97840000e+00,  3.70000000e+01,  4.98858447e+00,  1.03881279e+00,\n    ...    1.14300000e+03,  2.60958904e+00,  3.67800000e+01, -1.19780000e+02]]))\n    array([[1.1139996]], dtype=float32)\n    \"\"\"\n    xgb = XGBRegressor(\n        verbosity=0, random_state=42, tree_method=\"exact\", base_score=0.5\n    )\n    xgb.fit(features, target)\n    # Predict target for test data\n    predictions = xgb.predict(test_features)\n    predictions = predictions.reshape(len(predictions), 1)\n    return predictions",
    "docstring": ">>> xgboost(np.array([[ 2.3571 ,   52. , 6.00813008, 1.06775068,\n...    907. , 2.45799458,   40.58 , -124.26]]),np.array([1.114]),\n... np.array([[1.97840000e+00,  3.70000000e+01,  4.98858447e+00,  1.03881279e+00,\n...    1.14300000e+03,  2.60958904e+00,  3.67800000e+01, -1.19780000e+02]]))\narray([[1.1139996]], dtype=float32)"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    The URL for this algorithm\n    https://xgboost.readthedocs.io/en/stable/\n    California house price dataset is used to demonstrate the algorithm.\n\n    Expected error values:\n    Mean Absolute Error: 0.30957163379906033\n    Mean Square Error: 0.22611560196662744\n    \"\"\"\n    # Load California house price dataset\n    california = fetch_california_housing()\n    data, target = data_handling(california)\n    x_train, x_test, y_train, y_test = train_test_split(\n        data, target, test_size=0.25, random_state=1\n    )\n    predictions = xgboost(x_train, y_train, x_test)\n    # Error printing\n    print(f\"Mean Absolute Error: {mean_absolute_error(y_test, predictions)}\")\n    print(f\"Mean Square Error: {mean_squared_error(y_test, predictions)}\")",
    "docstring": "The URL for this algorithm\nhttps://xgboost.readthedocs.io/en/stable/\nCalifornia house price dataset is used to demonstrate the algorithm.\n\nExpected error values:\nMean Absolute Error: 0.30957163379906033\nMean Square Error: 0.22611560196662744"
  },
  {
    "function": "linear_regression_prediction",
    "code": "def linear_regression_prediction(\n    train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list\n) -> float:\n    \"\"\"\n    First method: linear regression\n    input : training data (date, total_user, total_event) in list of float\n    output : list of total user prediction in float\n    >>> n = linear_regression_prediction([2,3,4,5], [5,3,4,6], [3,1,2,4], [2,1], [2,2])\n    >>> bool(abs(n - 5.0) < 1e-6)  # Checking precision because of floating point errors\n    True\n    \"\"\"\n    x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])\n    y = np.array(train_usr)\n    beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)\n    return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])",
    "docstring": "First method: linear regression\ninput : training data (date, total_user, total_event) in list of float\noutput : list of total user prediction in float\n>>> n = linear_regression_prediction([2,3,4,5], [5,3,4,6], [3,1,2,4], [2,1], [2,2])\n>>> bool(abs(n - 5.0) < 1e-6)  # Checking precision because of floating point errors\nTrue"
  },
  {
    "function": "sarimax_predictor",
    "code": "def sarimax_predictor(train_user: list, train_match: list, test_match: list) -> float:\n    \"\"\"\n    second method: Sarimax\n    sarimax is a statistic method which using previous input\n    and learn its pattern to predict future data\n    input : training data (total_user, with exog data = total_event) in list of float\n    output : list of total user prediction in float\n    >>> sarimax_predictor([4,2,6,8], [3,1,2,4], [2])\n    6.6666671111109626\n    \"\"\"\n    # Suppress the User Warning raised by SARIMAX due to insufficient observations\n    simplefilter(\"ignore\", UserWarning)\n    order = (1, 2, 1)\n    seasonal_order = (1, 1, 1, 7)\n    model = SARIMAX(\n        train_user, exog=train_match, order=order, seasonal_order=seasonal_order\n    )\n    model_fit = model.fit(disp=False, maxiter=600, method=\"nm\")\n    result = model_fit.predict(1, len(test_match), exog=[test_match])\n    return float(result[0])",
    "docstring": "second method: Sarimax\nsarimax is a statistic method which using previous input\nand learn its pattern to predict future data\ninput : training data (total_user, with exog data = total_event) in list of float\noutput : list of total user prediction in float\n>>> sarimax_predictor([4,2,6,8], [3,1,2,4], [2])\n6.6666671111109626"
  },
  {
    "function": "support_vector_regressor",
    "code": "def support_vector_regressor(x_train: list, x_test: list, train_user: list) -> float:\n    \"\"\"\n    Third method: Support vector regressor\n    svr is quite the same with svm(support vector machine)\n    it uses the same principles as the SVM for classification,\n    with only a few minor differences and the only different is that\n    it suits better for regression purpose\n    input : training data (date, total_user, total_event) in list of float\n    where x = list of set (date and total event)\n    output : list of total user prediction in float\n    >>> support_vector_regressor([[5,2],[1,5],[6,2]], [[3,2]], [2,1,4])\n    1.634932078116079\n    \"\"\"\n    regressor = SVR(kernel=\"rbf\", C=1, gamma=0.1, epsilon=0.1)\n    regressor.fit(x_train, train_user)\n    y_pred = regressor.predict(x_test)\n    return float(y_pred[0])",
    "docstring": "Third method: Support vector regressor\nsvr is quite the same with svm(support vector machine)\nit uses the same principles as the SVM for classification,\nwith only a few minor differences and the only different is that\nit suits better for regression purpose\ninput : training data (date, total_user, total_event) in list of float\nwhere x = list of set (date and total event)\noutput : list of total user prediction in float\n>>> support_vector_regressor([[5,2],[1,5],[6,2]], [[3,2]], [2,1,4])\n1.634932078116079"
  },
  {
    "function": "interquartile_range_checker",
    "code": "def interquartile_range_checker(train_user: list) -> float:\n    \"\"\"\n    Optional method: interquatile range\n    input : list of total user in float\n    output : low limit of input in float\n    this method can be used to check whether some data is outlier or not\n    >>> interquartile_range_checker([1,2,3,4,5,6,7,8,9,10])\n    2.8\n    \"\"\"\n    train_user.sort()\n    q1 = np.percentile(train_user, 25)\n    q3 = np.percentile(train_user, 75)\n    iqr = q3 - q1\n    low_lim = q1 - (iqr * 0.1)\n    return float(low_lim)",
    "docstring": "Optional method: interquatile range\ninput : list of total user in float\noutput : low limit of input in float\nthis method can be used to check whether some data is outlier or not\n>>> interquartile_range_checker([1,2,3,4,5,6,7,8,9,10])\n2.8"
  },
  {
    "function": "data_safety_checker",
    "code": "def data_safety_checker(list_vote: list, actual_result: float) -> bool:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2, 3, 4], 5.0)\n    False\n    \"\"\"\n    safe = 0\n    not_safe = 0\n\n    if not isinstance(actual_result, float):\n        raise TypeError(\"Actual result should be float. Value passed is a list\")\n\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        elif abs(abs(i) - abs(actual_result)) <= 0.1:\n            safe += 1\n        else:\n            not_safe += 1\n    return safe > not_safe",
    "docstring": "Used to review all the votes (list result prediction)\nand compare it to the actual result.\ninput : list of predictions\noutput : print whether it's safe or not\n>>> data_safety_checker([2, 3, 4], 5.0)\nFalse"
  },
  {
    "function": "weight_matrix",
    "code": "def weight_matrix(point: np.ndarray, x_train: np.ndarray, tau: float) -> np.ndarray:\n    \"\"\"\n    Calculate the weight of every point in the training data around a given\n    prediction point\n\n    Args:\n        point: x-value at which the prediction is being made\n        x_train: ndarray of x-values for training\n        tau: bandwidth value, controls how quickly the weight of training values\n            decreases as the distance from the prediction point increases\n\n    Returns:\n        m x m weight matrix around the prediction point, where m is the size of\n        the training set\n    >>> weight_matrix(\n    ...     np.array([1., 1.]),\n    ...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),\n    ...     0.6\n    ... )\n    array([[1.43807972e-207, 0.00000000e+000, 0.00000000e+000],\n           [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],\n           [0.00000000e+000, 0.00000000e+000, 0.00000000e+000]])\n    \"\"\"\n    m = len(x_train)  # Number of training samples\n    weights = np.eye(m)  # Initialize weights as identity matrix\n    for j in range(m):\n        diff = point - x_train[j]\n        weights[j, j] = np.exp(diff @ diff.T / (-2.0 * tau**2))\n\n    return weights",
    "docstring": "Calculate the weight of every point in the training data around a given\nprediction point\n\nArgs:\n    point: x-value at which the prediction is being made\n    x_train: ndarray of x-values for training\n    tau: bandwidth value, controls how quickly the weight of training values\n        decreases as the distance from the prediction point increases\n\nReturns:\n    m x m weight matrix around the prediction point, where m is the size of\n    the training set\n>>> weight_matrix(\n...     np.array([1., 1.]),\n...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),\n...     0.6\n... )\narray([[1.43807972e-207, 0.00000000e+000, 0.00000000e+000],\n       [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],\n       [0.00000000e+000, 0.00000000e+000, 0.00000000e+000]])"
  },
  {
    "function": "local_weight",
    "code": "def local_weight(\n    point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float\n) -> np.ndarray:\n    \"\"\"\n    Calculate the local weights at a given prediction point using the weight\n    matrix for that point\n\n    Args:\n        point: x-value at which the prediction is being made\n        x_train: ndarray of x-values for training\n        y_train: ndarray of y-values for training\n        tau: bandwidth value, controls how quickly the weight of training values\n            decreases as the distance from the prediction point increases\n    Returns:\n        ndarray of local weights\n    >>> local_weight(\n    ...     np.array([1., 1.]),\n    ...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),\n    ...     np.array([[1.01, 1.66, 3.5]]),\n    ...     0.6\n    ... )\n    array([[0.00873174],\n           [0.08272556]])\n    \"\"\"\n    weight_mat = weight_matrix(point, x_train, tau)\n    weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (\n        x_train.T @ weight_mat @ y_train.T\n    )\n\n    return weight",
    "docstring": "Calculate the local weights at a given prediction point using the weight\nmatrix for that point\n\nArgs:\n    point: x-value at which the prediction is being made\n    x_train: ndarray of x-values for training\n    y_train: ndarray of y-values for training\n    tau: bandwidth value, controls how quickly the weight of training values\n        decreases as the distance from the prediction point increases\nReturns:\n    ndarray of local weights\n>>> local_weight(\n...     np.array([1., 1.]),\n...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),\n...     np.array([[1.01, 1.66, 3.5]]),\n...     0.6\n... )\narray([[0.00873174],\n       [0.08272556]])"
  },
  {
    "function": "local_weight_regression",
    "code": "def local_weight_regression(\n    x_train: np.ndarray, y_train: np.ndarray, tau: float\n) -> np.ndarray:\n    \"\"\"\n    Calculate predictions for each point in the training data\n\n    Args:\n        x_train: ndarray of x-values for training\n        y_train: ndarray of y-values for training\n        tau: bandwidth value, controls how quickly the weight of training values\n            decreases as the distance from the prediction point increases\n\n    Returns:\n        ndarray of predictions\n    >>> local_weight_regression(\n    ...     np.array([[16.99, 10.34], [21.01, 23.68], [24.59, 25.69]]),\n    ...     np.array([[1.01, 1.66, 3.5]]),\n    ...     0.6\n    ... )\n    array([1.07173261, 1.65970737, 3.50160179])\n    \"\"\"\n    y_pred = np.zeros(len(x_train))  # Initialize array of predictions\n    for i, item in enumerate(x_train):\n        y_pred[i] = np.dot(item, local_weight(item, x_train, y_train, tau)).item()\n\n    return y_pred",
    "docstring": "Calculate predictions for each point in the training data\n\nArgs:\n    x_train: ndarray of x-values for training\n    y_train: ndarray of y-values for training\n    tau: bandwidth value, controls how quickly the weight of training values\n        decreases as the distance from the prediction point increases\n\nReturns:\n    ndarray of predictions\n>>> local_weight_regression(\n...     np.array([[16.99, 10.34], [21.01, 23.68], [24.59, 25.69]]),\n...     np.array([[1.01, 1.66, 3.5]]),\n...     0.6\n... )\narray([1.07173261, 1.65970737, 3.50160179])"
  },
  {
    "function": "load_data",
    "code": "def load_data(\n    dataset_name: str, x_name: str, y_name: str\n) -> tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Load data from seaborn and split it into x and y points\n    >>> pass    # No doctests, function is for demo purposes only\n    \"\"\"\n    import seaborn as sns\n\n    data = sns.load_dataset(dataset_name)\n    x_data = np.array(data[x_name])\n    y_data = np.array(data[y_name])\n\n    one = np.ones(len(y_data))\n\n    # pairing elements of one and x_data\n    x_train = np.column_stack((one, x_data))\n\n    return x_train, x_data, y_data",
    "docstring": "Load data from seaborn and split it into x and y points\n>>> pass    # No doctests, function is for demo purposes only"
  },
  {
    "function": "plot_preds",
    "code": "def plot_preds(\n    x_train: np.ndarray,\n    preds: np.ndarray,\n    x_data: np.ndarray,\n    y_data: np.ndarray,\n    x_name: str,\n    y_name: str,\n) -> None:\n    \"\"\"\n    Plot predictions and display the graph\n    >>> pass    # No doctests, function is for demo purposes only\n    \"\"\"\n    x_train_sorted = np.sort(x_train, axis=0)\n    plt.scatter(x_data, y_data, color=\"blue\")\n    plt.plot(\n        x_train_sorted[:, 1],\n        preds[x_train[:, 1].argsort(0)],\n        color=\"yellow\",\n        linewidth=5,\n    )\n    plt.title(\"Local Weighted Regression\")\n    plt.xlabel(x_name)\n    plt.ylabel(y_name)\n    plt.show()",
    "docstring": "Plot predictions and display the graph\n>>> pass    # No doctests, function is for demo purposes only"
  },
  {
    "function": "abs_val",
    "code": "def abs_val(num: float) -> float:\n    \"\"\"\n    Find the absolute value of a number.\n\n    >>> abs_val(-5.1)\n    5.1\n    >>> abs_val(-5) == abs_val(5)\n    True\n    >>> abs_val(0)\n    0\n    \"\"\"\n    return -num if num < 0 else num",
    "docstring": "Find the absolute value of a number.\n\n>>> abs_val(-5.1)\n5.1\n>>> abs_val(-5) == abs_val(5)\nTrue\n>>> abs_val(0)\n0"
  },
  {
    "function": "abs_min",
    "code": "def abs_min(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_min([0,5,1,11])\n    0\n    >>> abs_min([3,-10,-2])\n    -2\n    >>> abs_min([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_min() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError(\"abs_min() arg is an empty sequence\")\n    j = x[0]\n    for i in x:\n        if abs_val(i) < abs_val(j):\n            j = i\n    return j",
    "docstring": ">>> abs_min([0,5,1,11])\n0\n>>> abs_min([3,-10,-2])\n-2\n>>> abs_min([])\nTraceback (most recent call last):\n    ...\nValueError: abs_min() arg is an empty sequence"
  },
  {
    "function": "abs_max",
    "code": "def abs_max(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    >>> abs_max([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_max() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError(\"abs_max() arg is an empty sequence\")\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j",
    "docstring": ">>> abs_max([0,5,1,11])\n11\n>>> abs_max([3,-10,-2])\n-10\n>>> abs_max([])\nTraceback (most recent call last):\n    ...\nValueError: abs_max() arg is an empty sequence"
  },
  {
    "function": "abs_max_sort",
    "code": "def abs_max_sort(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max_sort([0,5,1,11])\n    11\n    >>> abs_max_sort([3,-10,-2])\n    -10\n    >>> abs_max_sort([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_max_sort() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError(\"abs_max_sort() arg is an empty sequence\")\n    return sorted(x, key=abs)[-1]",
    "docstring": ">>> abs_max_sort([0,5,1,11])\n11\n>>> abs_max_sort([3,-10,-2])\n-10\n>>> abs_max_sort([])\nTraceback (most recent call last):\n    ...\nValueError: abs_max_sort() arg is an empty sequence"
  },
  {
    "function": "add",
    "code": "def add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first",
    "docstring": "Implementation of addition of integer\n\nExamples:\n>>> add(3, 5)\n8\n>>> add(13, 5)\n18\n>>> add(-7, 2)\n-5\n>>> add(0, -7)\n-7\n>>> add(-321, 0)\n-321"
  },
  {
    "function": "aliquot_sum",
    "code": "def aliquot_sum(input_num: int) -> int:\n    \"\"\"\n    Finds the aliquot sum of an input integer, where the\n    aliquot sum of a number n is defined as the sum of all\n    natural numbers less than n that divide n evenly. For\n    example, the aliquot sum of 15 is 1 + 3 + 5 = 9. This is\n    a simple O(n) implementation.\n    @param input_num: a positive integer whose aliquot sum is to be found\n    @return: the aliquot sum of input_num, if input_num is positive.\n    Otherwise, raise a ValueError\n    Wikipedia Explanation: https://en.wikipedia.org/wiki/Aliquot_sum\n\n    >>> aliquot_sum(15)\n    9\n    >>> aliquot_sum(6)\n    6\n    >>> aliquot_sum(-1)\n    Traceback (most recent call last):\n      ...\n    ValueError: Input must be positive\n    >>> aliquot_sum(0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Input must be positive\n    >>> aliquot_sum(1.6)\n    Traceback (most recent call last):\n      ...\n    ValueError: Input must be an integer\n    >>> aliquot_sum(12)\n    16\n    >>> aliquot_sum(1)\n    0\n    >>> aliquot_sum(19)\n    1\n    \"\"\"\n    if not isinstance(input_num, int):\n        raise ValueError(\"Input must be an integer\")\n    if input_num <= 0:\n        raise ValueError(\"Input must be positive\")\n    return sum(\n        divisor for divisor in range(1, input_num // 2 + 1) if input_num % divisor == 0\n    )",
    "docstring": "Finds the aliquot sum of an input integer, where the\naliquot sum of a number n is defined as the sum of all\nnatural numbers less than n that divide n evenly. For\nexample, the aliquot sum of 15 is 1 + 3 + 5 = 9. This is\na simple O(n) implementation.\n@param input_num: a positive integer whose aliquot sum is to be found\n@return: the aliquot sum of input_num, if input_num is positive.\nOtherwise, raise a ValueError\nWikipedia Explanation: https://en.wikipedia.org/wiki/Aliquot_sum\n\n>>> aliquot_sum(15)\n9\n>>> aliquot_sum(6)\n6\n>>> aliquot_sum(-1)\nTraceback (most recent call last):\n  ...\nValueError: Input must be positive\n>>> aliquot_sum(0)\nTraceback (most recent call last):\n  ...\nValueError: Input must be positive\n>>> aliquot_sum(1.6)\nTraceback (most recent call last):\n  ...\nValueError: Input must be an integer\n>>> aliquot_sum(12)\n16\n>>> aliquot_sum(1)\n0\n>>> aliquot_sum(19)\n1"
  },
  {
    "function": "allocation_num",
    "code": "def allocation_num(number_of_bytes: int, partitions: int) -> list[str]:\n    \"\"\"\n    Divide a number of bytes into x partitions.\n    :param number_of_bytes: the total of bytes.\n    :param partitions: the number of partition need to be allocated.\n    :return: list of bytes to be assigned to each worker thread\n\n    >>> allocation_num(16647, 4)\n    ['1-4161', '4162-8322', '8323-12483', '12484-16647']\n    >>> allocation_num(50000, 5)\n    ['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']\n    >>> allocation_num(888, 999)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions can not > number_of_bytes!\n    >>> allocation_num(888, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions must be a positive number!\n    \"\"\"\n    if partitions <= 0:\n        raise ValueError(\"partitions must be a positive number!\")\n    if partitions > number_of_bytes:\n        raise ValueError(\"partitions can not > number_of_bytes!\")\n    bytes_per_partition = number_of_bytes // partitions\n    allocation_list = []\n    for i in range(partitions):\n        start_bytes = i * bytes_per_partition + 1\n        end_bytes = (\n            number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition\n        )\n        allocation_list.append(f\"{start_bytes}-{end_bytes}\")\n    return allocation_list",
    "docstring": "Divide a number of bytes into x partitions.\n:param number_of_bytes: the total of bytes.\n:param partitions: the number of partition need to be allocated.\n:return: list of bytes to be assigned to each worker thread\n\n>>> allocation_num(16647, 4)\n['1-4161', '4162-8322', '8323-12483', '12484-16647']\n>>> allocation_num(50000, 5)\n['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']\n>>> allocation_num(888, 999)\nTraceback (most recent call last):\n    ...\nValueError: partitions can not > number_of_bytes!\n>>> allocation_num(888, -4)\nTraceback (most recent call last):\n    ...\nValueError: partitions must be a positive number!"
  },
  {
    "function": "arc_length",
    "code": "def arc_length(angle: int, radius: int) -> float:\n    \"\"\"\n    >>> arc_length(45, 5)\n    3.9269908169872414\n    >>> arc_length(120, 15)\n    31.415926535897928\n    >>> arc_length(90, 10)\n    15.707963267948966\n    \"\"\"\n    return 2 * pi * radius * (angle / 360)",
    "docstring": ">>> arc_length(45, 5)\n3.9269908169872414\n>>> arc_length(120, 15)\n31.415926535897928\n>>> arc_length(90, 10)\n15.707963267948966"
  },
  {
    "function": "surface_area_cube",
    "code": "def surface_area_cube(side_length: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Cube.\n\n    >>> surface_area_cube(1)\n    6\n    >>> surface_area_cube(1.6)\n    15.360000000000003\n    >>> surface_area_cube(0)\n    0\n    >>> surface_area_cube(3)\n    54\n    >>> surface_area_cube(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cube() only accepts non-negative values\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"surface_area_cube() only accepts non-negative values\")\n    return 6 * side_length**2",
    "docstring": "Calculate the Surface Area of a Cube.\n\n>>> surface_area_cube(1)\n6\n>>> surface_area_cube(1.6)\n15.360000000000003\n>>> surface_area_cube(0)\n0\n>>> surface_area_cube(3)\n54\n>>> surface_area_cube(-1)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_cube() only accepts non-negative values"
  },
  {
    "function": "surface_area_cuboid",
    "code": "def surface_area_cuboid(length: float, breadth: float, height: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Cuboid.\n\n    >>> surface_area_cuboid(1, 2, 3)\n    22\n    >>> surface_area_cuboid(0, 0, 0)\n    0\n    >>> surface_area_cuboid(1.6, 2.6, 3.6)\n    38.56\n    >>> surface_area_cuboid(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cuboid() only accepts non-negative values\n    >>> surface_area_cuboid(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cuboid() only accepts non-negative values\n    >>> surface_area_cuboid(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cuboid() only accepts non-negative values\n    \"\"\"\n    if length < 0 or breadth < 0 or height < 0:\n        raise ValueError(\"surface_area_cuboid() only accepts non-negative values\")\n    return 2 * ((length * breadth) + (breadth * height) + (length * height))",
    "docstring": "Calculate the Surface Area of a Cuboid.\n\n>>> surface_area_cuboid(1, 2, 3)\n22\n>>> surface_area_cuboid(0, 0, 0)\n0\n>>> surface_area_cuboid(1.6, 2.6, 3.6)\n38.56\n>>> surface_area_cuboid(-1, 2, 3)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_cuboid() only accepts non-negative values\n>>> surface_area_cuboid(1, -2, 3)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_cuboid() only accepts non-negative values\n>>> surface_area_cuboid(1, 2, -3)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_cuboid() only accepts non-negative values"
  },
  {
    "function": "surface_area_sphere",
    "code": "def surface_area_sphere(radius: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Sphere.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Sphere\n    Formula: 4 * pi * r^2\n\n    >>> surface_area_sphere(5)\n    314.1592653589793\n    >>> surface_area_sphere(1)\n    12.566370614359172\n    >>> surface_area_sphere(1.6)\n    32.169908772759484\n    >>> surface_area_sphere(0)\n    0.0\n    >>> surface_area_sphere(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_sphere() only accepts non-negative values\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"surface_area_sphere() only accepts non-negative values\")\n    return 4 * pi * radius**2",
    "docstring": "Calculate the Surface Area of a Sphere.\nWikipedia reference: https://en.wikipedia.org/wiki/Sphere\nFormula: 4 * pi * r^2\n\n>>> surface_area_sphere(5)\n314.1592653589793\n>>> surface_area_sphere(1)\n12.566370614359172\n>>> surface_area_sphere(1.6)\n32.169908772759484\n>>> surface_area_sphere(0)\n0.0\n>>> surface_area_sphere(-1)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_sphere() only accepts non-negative values"
  },
  {
    "function": "surface_area_hemisphere",
    "code": "def surface_area_hemisphere(radius: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Hemisphere.\n    Formula: 3 * pi * r^2\n\n    >>> surface_area_hemisphere(5)\n    235.61944901923448\n    >>> surface_area_hemisphere(1)\n    9.42477796076938\n    >>> surface_area_hemisphere(0)\n    0.0\n    >>> surface_area_hemisphere(1.1)\n    11.40398133253095\n    >>> surface_area_hemisphere(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_hemisphere() only accepts non-negative values\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"surface_area_hemisphere() only accepts non-negative values\")\n    return 3 * pi * radius**2",
    "docstring": "Calculate the Surface Area of a Hemisphere.\nFormula: 3 * pi * r^2\n\n>>> surface_area_hemisphere(5)\n235.61944901923448\n>>> surface_area_hemisphere(1)\n9.42477796076938\n>>> surface_area_hemisphere(0)\n0.0\n>>> surface_area_hemisphere(1.1)\n11.40398133253095\n>>> surface_area_hemisphere(-1)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_hemisphere() only accepts non-negative values"
  },
  {
    "function": "surface_area_cone",
    "code": "def surface_area_cone(radius: float, height: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Cone.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cone\n    Formula: pi * r * (r + (h ** 2 + r ** 2) ** 0.5)\n\n    >>> surface_area_cone(10, 24)\n    1130.9733552923256\n    >>> surface_area_cone(6, 8)\n    301.59289474462014\n    >>> surface_area_cone(1.6, 2.6)\n    23.387862992395807\n    >>> surface_area_cone(0, 0)\n    0.0\n    >>> surface_area_cone(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cone() only accepts non-negative values\n    >>> surface_area_cone(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cone() only accepts non-negative values\n    >>> surface_area_cone(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cone() only accepts non-negative values\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"surface_area_cone() only accepts non-negative values\")\n    return pi * radius * (radius + (height**2 + radius**2) ** 0.5)",
    "docstring": "Calculate the Surface Area of a Cone.\nWikipedia reference: https://en.wikipedia.org/wiki/Cone\nFormula: pi * r * (r + (h ** 2 + r ** 2) ** 0.5)\n\n>>> surface_area_cone(10, 24)\n1130.9733552923256\n>>> surface_area_cone(6, 8)\n301.59289474462014\n>>> surface_area_cone(1.6, 2.6)\n23.387862992395807\n>>> surface_area_cone(0, 0)\n0.0\n>>> surface_area_cone(-1, -2)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_cone() only accepts non-negative values\n>>> surface_area_cone(1, -2)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_cone() only accepts non-negative values\n>>> surface_area_cone(-1, 2)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_cone() only accepts non-negative values"
  },
  {
    "function": "surface_area_conical_frustum",
    "code": "def surface_area_conical_frustum(\n    radius_1: float, radius_2: float, height: float\n) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Conical Frustum.\n\n    >>> surface_area_conical_frustum(1, 2, 3)\n    45.511728065337266\n    >>> surface_area_conical_frustum(4, 5, 6)\n    300.7913575056268\n    >>> surface_area_conical_frustum(0, 0, 0)\n    0.0\n    >>> surface_area_conical_frustum(1.6, 2.6, 3.6)\n    78.57907060751548\n    >>> surface_area_conical_frustum(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_conical_frustum() only accepts non-negative values\n    >>> surface_area_conical_frustum(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_conical_frustum() only accepts non-negative values\n    >>> surface_area_conical_frustum(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_conical_frustum() only accepts non-negative values\n    \"\"\"\n    if radius_1 < 0 or radius_2 < 0 or height < 0:\n        raise ValueError(\n            \"surface_area_conical_frustum() only accepts non-negative values\"\n        )\n    slant_height = (height**2 + (radius_1 - radius_2) ** 2) ** 0.5\n    return pi * ((slant_height * (radius_1 + radius_2)) + radius_1**2 + radius_2**2)",
    "docstring": "Calculate the Surface Area of a Conical Frustum.\n\n>>> surface_area_conical_frustum(1, 2, 3)\n45.511728065337266\n>>> surface_area_conical_frustum(4, 5, 6)\n300.7913575056268\n>>> surface_area_conical_frustum(0, 0, 0)\n0.0\n>>> surface_area_conical_frustum(1.6, 2.6, 3.6)\n78.57907060751548\n>>> surface_area_conical_frustum(-1, 2, 3)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_conical_frustum() only accepts non-negative values\n>>> surface_area_conical_frustum(1, -2, 3)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_conical_frustum() only accepts non-negative values\n>>> surface_area_conical_frustum(1, 2, -3)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_conical_frustum() only accepts non-negative values"
  },
  {
    "function": "surface_area_cylinder",
    "code": "def surface_area_cylinder(radius: float, height: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Cylinder.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder\n    Formula: 2 * pi * r * (h + r)\n\n    >>> surface_area_cylinder(7, 10)\n    747.6990515543707\n    >>> surface_area_cylinder(1.6, 2.6)\n    42.22300526424682\n    >>> surface_area_cylinder(0, 0)\n    0.0\n    >>> surface_area_cylinder(6, 8)\n    527.7875658030853\n    >>> surface_area_cylinder(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cylinder() only accepts non-negative values\n    >>> surface_area_cylinder(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cylinder() only accepts non-negative values\n    >>> surface_area_cylinder(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cylinder() only accepts non-negative values\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"surface_area_cylinder() only accepts non-negative values\")\n    return 2 * pi * radius * (height + radius)",
    "docstring": "Calculate the Surface Area of a Cylinder.\nWikipedia reference: https://en.wikipedia.org/wiki/Cylinder\nFormula: 2 * pi * r * (h + r)\n\n>>> surface_area_cylinder(7, 10)\n747.6990515543707\n>>> surface_area_cylinder(1.6, 2.6)\n42.22300526424682\n>>> surface_area_cylinder(0, 0)\n0.0\n>>> surface_area_cylinder(6, 8)\n527.7875658030853\n>>> surface_area_cylinder(-1, -2)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_cylinder() only accepts non-negative values\n>>> surface_area_cylinder(1, -2)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_cylinder() only accepts non-negative values\n>>> surface_area_cylinder(-1, 2)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_cylinder() only accepts non-negative values"
  },
  {
    "function": "surface_area_torus",
    "code": "def surface_area_torus(torus_radius: float, tube_radius: float) -> float:\n    \"\"\"Calculate the Area of a Torus.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Torus\n    :return 4pi^2 * torus_radius * tube_radius\n    >>> surface_area_torus(1, 1)\n    39.47841760435743\n    >>> surface_area_torus(4, 3)\n    473.7410112522892\n    >>> surface_area_torus(3, 4)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_torus() does not support spindle or self intersecting tori\n    >>> surface_area_torus(1.6, 1.6)\n    101.06474906715503\n    >>> surface_area_torus(0, 0)\n    0.0\n    >>> surface_area_torus(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_torus() only accepts non-negative values\n    >>> surface_area_torus(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_torus() only accepts non-negative values\n    \"\"\"\n    if torus_radius < 0 or tube_radius < 0:\n        raise ValueError(\"surface_area_torus() only accepts non-negative values\")\n    if torus_radius < tube_radius:\n        raise ValueError(\n            \"surface_area_torus() does not support spindle or self intersecting tori\"\n        )\n    return 4 * pow(pi, 2) * torus_radius * tube_radius",
    "docstring": "Calculate the Area of a Torus.\nWikipedia reference: https://en.wikipedia.org/wiki/Torus\n:return 4pi^2 * torus_radius * tube_radius\n>>> surface_area_torus(1, 1)\n39.47841760435743\n>>> surface_area_torus(4, 3)\n473.7410112522892\n>>> surface_area_torus(3, 4)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_torus() does not support spindle or self intersecting tori\n>>> surface_area_torus(1.6, 1.6)\n101.06474906715503\n>>> surface_area_torus(0, 0)\n0.0\n>>> surface_area_torus(-1, 1)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_torus() only accepts non-negative values\n>>> surface_area_torus(1, -1)\nTraceback (most recent call last):\n    ...\nValueError: surface_area_torus() only accepts non-negative values"
  },
  {
    "function": "area_rectangle",
    "code": "def area_rectangle(length: float, width: float) -> float:\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    >>> area_rectangle(10, 20)\n    200\n    >>> area_rectangle(1.6, 2.6)\n    4.16\n    >>> area_rectangle(0, 0)\n    0\n    >>> area_rectangle(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rectangle() only accepts non-negative values\n    >>> area_rectangle(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rectangle() only accepts non-negative values\n    >>> area_rectangle(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rectangle() only accepts non-negative values\n    \"\"\"\n    if length < 0 or width < 0:\n        raise ValueError(\"area_rectangle() only accepts non-negative values\")\n    return length * width",
    "docstring": "Calculate the area of a rectangle.\n\n>>> area_rectangle(10, 20)\n200\n>>> area_rectangle(1.6, 2.6)\n4.16\n>>> area_rectangle(0, 0)\n0\n>>> area_rectangle(-1, -2)\nTraceback (most recent call last):\n    ...\nValueError: area_rectangle() only accepts non-negative values\n>>> area_rectangle(1, -2)\nTraceback (most recent call last):\n    ...\nValueError: area_rectangle() only accepts non-negative values\n>>> area_rectangle(-1, 2)\nTraceback (most recent call last):\n    ...\nValueError: area_rectangle() only accepts non-negative values"
  },
  {
    "function": "area_square",
    "code": "def area_square(side_length: float) -> float:\n    \"\"\"\n    Calculate the area of a square.\n\n    >>> area_square(10)\n    100\n    >>> area_square(0)\n    0\n    >>> area_square(1.6)\n    2.5600000000000005\n    >>> area_square(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_square() only accepts non-negative values\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"area_square() only accepts non-negative values\")\n    return side_length**2",
    "docstring": "Calculate the area of a square.\n\n>>> area_square(10)\n100\n>>> area_square(0)\n0\n>>> area_square(1.6)\n2.5600000000000005\n>>> area_square(-1)\nTraceback (most recent call last):\n    ...\nValueError: area_square() only accepts non-negative values"
  },
  {
    "function": "area_triangle",
    "code": "def area_triangle(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle given the base and height.\n\n    >>> area_triangle(10, 10)\n    50.0\n    >>> area_triangle(1.6, 2.6)\n    2.08\n    >>> area_triangle(0, 0)\n    0.0\n    >>> area_triangle(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    >>> area_triangle(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    >>> area_triangle(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    \"\"\"\n    if base < 0 or height < 0:\n        raise ValueError(\"area_triangle() only accepts non-negative values\")\n    return (base * height) / 2",
    "docstring": "Calculate the area of a triangle given the base and height.\n\n>>> area_triangle(10, 10)\n50.0\n>>> area_triangle(1.6, 2.6)\n2.08\n>>> area_triangle(0, 0)\n0.0\n>>> area_triangle(-1, -2)\nTraceback (most recent call last):\n    ...\nValueError: area_triangle() only accepts non-negative values\n>>> area_triangle(1, -2)\nTraceback (most recent call last):\n    ...\nValueError: area_triangle() only accepts non-negative values\n>>> area_triangle(-1, 2)\nTraceback (most recent call last):\n    ...\nValueError: area_triangle() only accepts non-negative values"
  },
  {
    "function": "area_triangle_three_sides",
    "code": "def area_triangle_three_sides(side1: float, side2: float, side3: float) -> float:\n    \"\"\"\n    Calculate area of triangle when the length of 3 sides are known.\n    This function uses Heron's formula: https://en.wikipedia.org/wiki/Heron%27s_formula\n\n    >>> area_triangle_three_sides(5, 12, 13)\n    30.0\n    >>> area_triangle_three_sides(10, 11, 12)\n    51.521233486786784\n    >>> area_triangle_three_sides(0, 0, 0)\n    0.0\n    >>> area_triangle_three_sides(1.6, 2.6, 3.6)\n    1.8703742940919619\n    >>> area_triangle_three_sides(-1, -2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle_three_sides() only accepts non-negative values\n    >>> area_triangle_three_sides(1, -2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle_three_sides() only accepts non-negative values\n    >>> area_triangle_three_sides(2, 4, 7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Given three sides do not form a triangle\n    >>> area_triangle_three_sides(2, 7, 4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Given three sides do not form a triangle\n    >>> area_triangle_three_sides(7, 2, 4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Given three sides do not form a triangle\n    \"\"\"\n    if side1 < 0 or side2 < 0 or side3 < 0:\n        raise ValueError(\"area_triangle_three_sides() only accepts non-negative values\")\n    elif side1 + side2 < side3 or side1 + side3 < side2 or side2 + side3 < side1:\n        raise ValueError(\"Given three sides do not form a triangle\")\n    semi_perimeter = (side1 + side2 + side3) / 2\n    area = sqrt(\n        semi_perimeter\n        * (semi_perimeter - side1)\n        * (semi_perimeter - side2)\n        * (semi_perimeter - side3)\n    )\n    return area",
    "docstring": "Calculate area of triangle when the length of 3 sides are known.\nThis function uses Heron's formula: https://en.wikipedia.org/wiki/Heron%27s_formula\n\n>>> area_triangle_three_sides(5, 12, 13)\n30.0\n>>> area_triangle_three_sides(10, 11, 12)\n51.521233486786784\n>>> area_triangle_three_sides(0, 0, 0)\n0.0\n>>> area_triangle_three_sides(1.6, 2.6, 3.6)\n1.8703742940919619\n>>> area_triangle_three_sides(-1, -2, -1)\nTraceback (most recent call last):\n    ...\nValueError: area_triangle_three_sides() only accepts non-negative values\n>>> area_triangle_three_sides(1, -2, 1)\nTraceback (most recent call last):\n    ...\nValueError: area_triangle_three_sides() only accepts non-negative values\n>>> area_triangle_three_sides(2, 4, 7)\nTraceback (most recent call last):\n    ...\nValueError: Given three sides do not form a triangle\n>>> area_triangle_three_sides(2, 7, 4)\nTraceback (most recent call last):\n    ...\nValueError: Given three sides do not form a triangle\n>>> area_triangle_three_sides(7, 2, 4)\nTraceback (most recent call last):\n    ...\nValueError: Given three sides do not form a triangle"
  },
  {
    "function": "area_parallelogram",
    "code": "def area_parallelogram(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    >>> area_parallelogram(10, 20)\n    200\n    >>> area_parallelogram(1.6, 2.6)\n    4.16\n    >>> area_parallelogram(0, 0)\n    0\n    >>> area_parallelogram(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_parallelogram() only accepts non-negative values\n    >>> area_parallelogram(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_parallelogram() only accepts non-negative values\n    >>> area_parallelogram(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_parallelogram() only accepts non-negative values\n    \"\"\"\n    if base < 0 or height < 0:\n        raise ValueError(\"area_parallelogram() only accepts non-negative values\")\n    return base * height",
    "docstring": "Calculate the area of a parallelogram.\n\n>>> area_parallelogram(10, 20)\n200\n>>> area_parallelogram(1.6, 2.6)\n4.16\n>>> area_parallelogram(0, 0)\n0\n>>> area_parallelogram(-1, -2)\nTraceback (most recent call last):\n    ...\nValueError: area_parallelogram() only accepts non-negative values\n>>> area_parallelogram(1, -2)\nTraceback (most recent call last):\n    ...\nValueError: area_parallelogram() only accepts non-negative values\n>>> area_parallelogram(-1, 2)\nTraceback (most recent call last):\n    ...\nValueError: area_parallelogram() only accepts non-negative values"
  },
  {
    "function": "area_trapezium",
    "code": "def area_trapezium(base1: float, base2: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a trapezium.\n\n    >>> area_trapezium(10, 20, 30)\n    450.0\n    >>> area_trapezium(1.6, 2.6, 3.6)\n    7.5600000000000005\n    >>> area_trapezium(0, 0, 0)\n    0.0\n    >>> area_trapezium(-1, -2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(-1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(1, -2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(-1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    \"\"\"\n    if base1 < 0 or base2 < 0 or height < 0:\n        raise ValueError(\"area_trapezium() only accepts non-negative values\")\n    return 1 / 2 * (base1 + base2) * height",
    "docstring": "Calculate the area of a trapezium.\n\n>>> area_trapezium(10, 20, 30)\n450.0\n>>> area_trapezium(1.6, 2.6, 3.6)\n7.5600000000000005\n>>> area_trapezium(0, 0, 0)\n0.0\n>>> area_trapezium(-1, -2, -3)\nTraceback (most recent call last):\n    ...\nValueError: area_trapezium() only accepts non-negative values\n>>> area_trapezium(-1, 2, 3)\nTraceback (most recent call last):\n    ...\nValueError: area_trapezium() only accepts non-negative values\n>>> area_trapezium(1, -2, 3)\nTraceback (most recent call last):\n    ...\nValueError: area_trapezium() only accepts non-negative values\n>>> area_trapezium(1, 2, -3)\nTraceback (most recent call last):\n    ...\nValueError: area_trapezium() only accepts non-negative values\n>>> area_trapezium(-1, -2, 3)\nTraceback (most recent call last):\n    ...\nValueError: area_trapezium() only accepts non-negative values\n>>> area_trapezium(1, -2, -3)\nTraceback (most recent call last):\n    ...\nValueError: area_trapezium() only accepts non-negative values\n>>> area_trapezium(-1, 2, -3)\nTraceback (most recent call last):\n    ...\nValueError: area_trapezium() only accepts non-negative values"
  },
  {
    "function": "area_circle",
    "code": "def area_circle(radius: float) -> float:\n    \"\"\"\n    Calculate the area of a circle.\n\n    >>> area_circle(20)\n    1256.6370614359173\n    >>> area_circle(1.6)\n    8.042477193189871\n    >>> area_circle(0)\n    0.0\n    >>> area_circle(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_circle() only accepts non-negative values\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"area_circle() only accepts non-negative values\")\n    return pi * radius**2",
    "docstring": "Calculate the area of a circle.\n\n>>> area_circle(20)\n1256.6370614359173\n>>> area_circle(1.6)\n8.042477193189871\n>>> area_circle(0)\n0.0\n>>> area_circle(-1)\nTraceback (most recent call last):\n    ...\nValueError: area_circle() only accepts non-negative values"
  },
  {
    "function": "area_ellipse",
    "code": "def area_ellipse(radius_x: float, radius_y: float) -> float:\n    \"\"\"\n    Calculate the area of a ellipse.\n\n    >>> area_ellipse(10, 10)\n    314.1592653589793\n    >>> area_ellipse(10, 20)\n    628.3185307179587\n    >>> area_ellipse(0, 0)\n    0.0\n    >>> area_ellipse(1.6, 2.6)\n    13.06902543893354\n    >>> area_ellipse(-10, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_ellipse() only accepts non-negative values\n    >>> area_ellipse(10, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_ellipse() only accepts non-negative values\n    >>> area_ellipse(-10, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_ellipse() only accepts non-negative values\n    \"\"\"\n    if radius_x < 0 or radius_y < 0:\n        raise ValueError(\"area_ellipse() only accepts non-negative values\")\n    return pi * radius_x * radius_y",
    "docstring": "Calculate the area of a ellipse.\n\n>>> area_ellipse(10, 10)\n314.1592653589793\n>>> area_ellipse(10, 20)\n628.3185307179587\n>>> area_ellipse(0, 0)\n0.0\n>>> area_ellipse(1.6, 2.6)\n13.06902543893354\n>>> area_ellipse(-10, 20)\nTraceback (most recent call last):\n    ...\nValueError: area_ellipse() only accepts non-negative values\n>>> area_ellipse(10, -20)\nTraceback (most recent call last):\n    ...\nValueError: area_ellipse() only accepts non-negative values\n>>> area_ellipse(-10, -20)\nTraceback (most recent call last):\n    ...\nValueError: area_ellipse() only accepts non-negative values"
  },
  {
    "function": "area_rhombus",
    "code": "def area_rhombus(diagonal_1: float, diagonal_2: float) -> float:\n    \"\"\"\n    Calculate the area of a rhombus.\n\n    >>> area_rhombus(10, 20)\n    100.0\n    >>> area_rhombus(1.6, 2.6)\n    2.08\n    >>> area_rhombus(0, 0)\n    0.0\n    >>> area_rhombus(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rhombus() only accepts non-negative values\n    >>> area_rhombus(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rhombus() only accepts non-negative values\n    >>> area_rhombus(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rhombus() only accepts non-negative values\n    \"\"\"\n    if diagonal_1 < 0 or diagonal_2 < 0:\n        raise ValueError(\"area_rhombus() only accepts non-negative values\")\n    return 1 / 2 * diagonal_1 * diagonal_2",
    "docstring": "Calculate the area of a rhombus.\n\n>>> area_rhombus(10, 20)\n100.0\n>>> area_rhombus(1.6, 2.6)\n2.08\n>>> area_rhombus(0, 0)\n0.0\n>>> area_rhombus(-1, -2)\nTraceback (most recent call last):\n    ...\nValueError: area_rhombus() only accepts non-negative values\n>>> area_rhombus(1, -2)\nTraceback (most recent call last):\n    ...\nValueError: area_rhombus() only accepts non-negative values\n>>> area_rhombus(-1, 2)\nTraceback (most recent call last):\n    ...\nValueError: area_rhombus() only accepts non-negative values"
  },
  {
    "function": "area_reg_polygon",
    "code": "def area_reg_polygon(sides: int, length: float) -> float:\n    \"\"\"\n    Calculate the area of a regular polygon.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Polygon#Regular_polygons\n    Formula: (n*s^2*cot(pi/n))/4\n\n    >>> area_reg_polygon(3, 10)\n    43.301270189221945\n    >>> area_reg_polygon(4, 10)\n    100.00000000000001\n    >>> area_reg_polygon(0, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_reg_polygon() only accepts integers greater than or equal to \\\nthree as number of sides\n    >>> area_reg_polygon(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_reg_polygon() only accepts integers greater than or equal to \\\nthree as number of sides\n    >>> area_reg_polygon(5, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_reg_polygon() only accepts non-negative values as \\\nlength of a side\n    >>> area_reg_polygon(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_reg_polygon() only accepts integers greater than or equal to \\\nthree as number of sides\n    \"\"\"\n    if not isinstance(sides, int) or sides < 3:\n        raise ValueError(\n            \"area_reg_polygon() only accepts integers greater than or \\\nequal to three as number of sides\"\n        )\n    elif length < 0:\n        raise ValueError(\n            \"area_reg_polygon() only accepts non-negative values as \\\nlength of a side\"\n        )\n    return (sides * length**2) / (4 * tan(pi / sides))\n    return (sides * length**2) / (4 * tan(pi / sides))",
    "docstring": "Calculate the area of a regular polygon.\nWikipedia reference: https://en.wikipedia.org/wiki/Polygon#Regular_polygons\nFormula: (n*s^2*cot(pi/n))/4\n\n>>> area_reg_polygon(3, 10)\n43.301270189221945\n>>> area_reg_polygon(4, 10)\n100.00000000000001\n>>> area_reg_polygon(0, 0)\nTraceback (most recent call last):\n    ...\nValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides\n>>> area_reg_polygon(-1, -2)\nTraceback (most recent call last):\n    ...\nValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides\n>>> area_reg_polygon(5, -2)\nTraceback (most recent call last):\n    ...\nValueError: area_reg_polygon() only accepts non-negative values as length of a side\n>>> area_reg_polygon(-1, 2)\nTraceback (most recent call last):\n    ...\nValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides"
  },
  {
    "function": "trapezoidal_area",
    "code": "def trapezoidal_area(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    \"\"\"\n    Treats curve as a collection of linear lines and sums the area of the\n    trapezium shape they form\n    :param fnc: a function which defines a curve\n    :param x_start: left end point to indicate the start of line segment\n    :param x_end: right end point to indicate end of line segment\n    :param steps: an accuracy gauge; more steps increases the accuracy\n    :return: a float representing the length of the curve\n\n    >>> def f(x):\n    ...    return 5\n    >>> f\"{trapezoidal_area(f, 12.0, 14.0, 1000):.3f}\"\n    '10.000'\n    >>> def f(x):\n    ...    return 9*x**2\n    >>> f\"{trapezoidal_area(f, -4.0, 0, 10000):.4f}\"\n    '192.0000'\n    >>> f\"{trapezoidal_area(f, -4.0, 4.0, 10000):.4f}\"\n    '384.0000'\n    \"\"\"\n    x1 = x_start\n    fx1 = fnc(x_start)\n    area = 0.0\n    for _ in range(steps):\n        # Approximates small segments of curve as linear and solve\n        # for trapezoidal area\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n    return area",
    "docstring": "Treats curve as a collection of linear lines and sums the area of the\ntrapezium shape they form\n:param fnc: a function which defines a curve\n:param x_start: left end point to indicate the start of line segment\n:param x_end: right end point to indicate end of line segment\n:param steps: an accuracy gauge; more steps increases the accuracy\n:return: a float representing the length of the curve\n\n>>> def f(x):\n...    return 5\n>>> f\"{trapezoidal_area(f, 12.0, 14.0, 1000):.3f}\"\n'10.000'\n>>> def f(x):\n...    return 9*x**2\n>>> f\"{trapezoidal_area(f, -4.0, 0, 10000):.4f}\"\n'192.0000'\n>>> f\"{trapezoidal_area(f, -4.0, 4.0, 10000):.4f}\"\n'384.0000'"
  },
  {
    "function": "average_absolute_deviation",
    "code": "def average_absolute_deviation(nums: list[int]) -> float:\n    \"\"\"\n    Return the average absolute deviation of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Average_absolute_deviation\n\n    >>> average_absolute_deviation([0])\n    0.0\n    >>> average_absolute_deviation([4, 1, 3, 2])\n    1.0\n    >>> average_absolute_deviation([2, 70, 6, 50, 20, 8, 4, 0])\n    20.0\n    >>> average_absolute_deviation([-20, 0, 30, 15])\n    16.25\n    >>> average_absolute_deviation([])\n    Traceback (most recent call last):\n        ...\n    ValueError: List is empty\n    \"\"\"\n    if not nums:  # Makes sure that the list is not empty\n        raise ValueError(\"List is empty\")\n\n    average = sum(nums) / len(nums)  # Calculate the average\n    return sum(abs(x - average) for x in nums) / len(nums)",
    "docstring": "Return the average absolute deviation of a list of numbers.\nWiki: https://en.wikipedia.org/wiki/Average_absolute_deviation\n\n>>> average_absolute_deviation([0])\n0.0\n>>> average_absolute_deviation([4, 1, 3, 2])\n1.0\n>>> average_absolute_deviation([2, 70, 6, 50, 20, 8, 4, 0])\n20.0\n>>> average_absolute_deviation([-20, 0, 30, 15])\n16.25\n>>> average_absolute_deviation([])\nTraceback (most recent call last):\n    ...\nValueError: List is empty"
  },
  {
    "function": "mean",
    "code": "def mean(nums: list) -> float:\n    \"\"\"\n    Find mean of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Mean\n\n    >>> mean([3, 6, 9, 12, 15, 18, 21])\n    12.0\n    >>> mean([5, 10, 15, 20, 25, 30, 35])\n    20.0\n    >>> mean([1, 2, 3, 4, 5, 6, 7, 8])\n    4.5\n    >>> mean([])\n    Traceback (most recent call last):\n        ...\n    ValueError: List is empty\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List is empty\")\n    return sum(nums) / len(nums)",
    "docstring": "Find mean of a list of numbers.\nWiki: https://en.wikipedia.org/wiki/Mean\n\n>>> mean([3, 6, 9, 12, 15, 18, 21])\n12.0\n>>> mean([5, 10, 15, 20, 25, 30, 35])\n20.0\n>>> mean([1, 2, 3, 4, 5, 6, 7, 8])\n4.5\n>>> mean([])\nTraceback (most recent call last):\n    ...\nValueError: List is empty"
  },
  {
    "function": "median",
    "code": "def median(nums: list) -> int | float:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    # The sorted function returns list[SupportsRichComparisonT@sorted]\n    # which does not support `+`\n    sorted_list: list[int] = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )",
    "docstring": "Find median of a list of numbers.\nWiki: https://en.wikipedia.org/wiki/Median\n\n>>> median([0])\n0\n>>> median([4, 1, 3, 2])\n2.5\n>>> median([2, 70, 6, 50, 20, 8, 4])\n8\n\nArgs:\n    nums: List of nums\n\nReturns:\n    Median."
  },
  {
    "function": "mode",
    "code": "def mode(input_list: list) -> list[Any]:\n    \"\"\"This function returns the mode(Mode as in the measures of\n    central tendency) of the input data.\n\n    The input list may contain any Datastructure or any Datatype.\n\n    >>> mode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])\n    [2]\n    >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])\n    [2]\n    >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])\n    [2, 4]\n    >>> mode([\"x\", \"y\", \"y\", \"z\"])\n    ['y']\n    >>> mode([\"x\", \"x\" , \"y\", \"y\", \"z\"])\n    ['x', 'y']\n    \"\"\"\n    if not input_list:\n        return []\n    result = [input_list.count(value) for value in input_list]\n    y = max(result)  # Gets the maximum count in the input list.\n    # Gets values of modes\n    return sorted({input_list[i] for i, value in enumerate(result) if value == y})",
    "docstring": "This function returns the mode(Mode as in the measures of\ncentral tendency) of the input data.\n\nThe input list may contain any Datastructure or any Datatype.\n\n>>> mode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])\n[2]\n>>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])\n[2]\n>>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])\n[2, 4]\n>>> mode([\"x\", \"y\", \"y\", \"z\"])\n['y']\n>>> mode([\"x\", \"x\" , \"y\", \"y\", \"z\"])\n['x', 'y']"
  },
  {
    "function": "bailey_borwein_plouffe",
    "code": "def bailey_borwein_plouffe(digit_position: int, precision: int = 1000) -> str:\n    \"\"\"\n    Implement a popular pi-digit-extraction algorithm known as the\n    Bailey-Borwein-Plouffe (BBP) formula to calculate the nth hex digit of pi.\n    Wikipedia page:\n    https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula\n    @param digit_position: a positive integer representing the position of the digit to\n    extract.\n    The digit immediately after the decimal point is located at position 1.\n    @param precision: number of terms in the second summation to calculate.\n    A higher number reduces the chance of an error but increases the runtime.\n    @return: a hexadecimal digit representing the digit at the nth position\n    in pi's decimal expansion.\n\n    >>> \"\".join(bailey_borwein_plouffe(i) for i in range(1, 11))\n    '243f6a8885'\n    >>> bailey_borwein_plouffe(5, 10000)\n    '6'\n    >>> bailey_borwein_plouffe(-10)\n    Traceback (most recent call last):\n      ...\n    ValueError: Digit position must be a positive integer\n    >>> bailey_borwein_plouffe(0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Digit position must be a positive integer\n    >>> bailey_borwein_plouffe(1.7)\n    Traceback (most recent call last):\n      ...\n    ValueError: Digit position must be a positive integer\n    >>> bailey_borwein_plouffe(2, -10)\n    Traceback (most recent call last):\n      ...\n    ValueError: Precision must be a nonnegative integer\n    >>> bailey_borwein_plouffe(2, 1.6)\n    Traceback (most recent call last):\n      ...\n    ValueError: Precision must be a nonnegative integer\n    \"\"\"\n    if (not isinstance(digit_position, int)) or (digit_position <= 0):\n        raise ValueError(\"Digit position must be a positive integer\")\n    elif (not isinstance(precision, int)) or (precision < 0):\n        raise ValueError(\"Precision must be a nonnegative integer\")\n\n    # compute an approximation of (16 ** (n - 1)) * pi whose fractional part is mostly\n    # accurate\n    sum_result = (\n        4 * _subsum(digit_position, 1, precision)\n        - 2 * _subsum(digit_position, 4, precision)\n        - _subsum(digit_position, 5, precision)\n        - _subsum(digit_position, 6, precision)\n    )\n\n    # return the first hex digit of the fractional part of the result\n    return hex(int((sum_result % 1) * 16))[2:]",
    "docstring": "Implement a popular pi-digit-extraction algorithm known as the\nBailey-Borwein-Plouffe (BBP) formula to calculate the nth hex digit of pi.\nWikipedia page:\nhttps://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula\n@param digit_position: a positive integer representing the position of the digit to\nextract.\nThe digit immediately after the decimal point is located at position 1.\n@param precision: number of terms in the second summation to calculate.\nA higher number reduces the chance of an error but increases the runtime.\n@return: a hexadecimal digit representing the digit at the nth position\nin pi's decimal expansion.\n\n>>> \"\".join(bailey_borwein_plouffe(i) for i in range(1, 11))\n'243f6a8885'\n>>> bailey_borwein_plouffe(5, 10000)\n'6'\n>>> bailey_borwein_plouffe(-10)\nTraceback (most recent call last):\n  ...\nValueError: Digit position must be a positive integer\n>>> bailey_borwein_plouffe(0)\nTraceback (most recent call last):\n  ...\nValueError: Digit position must be a positive integer\n>>> bailey_borwein_plouffe(1.7)\nTraceback (most recent call last):\n  ...\nValueError: Digit position must be a positive integer\n>>> bailey_borwein_plouffe(2, -10)\nTraceback (most recent call last):\n  ...\nValueError: Precision must be a nonnegative integer\n>>> bailey_borwein_plouffe(2, 1.6)\nTraceback (most recent call last):\n  ...\nValueError: Precision must be a nonnegative integer"
  },
  {
    "function": "_subsum",
    "code": "def _subsum(\n    digit_pos_to_extract: int, denominator_addend: int, precision: int\n) -> float:\n    # only care about first digit of fractional part; don't need decimal\n    \"\"\"\n    Private helper function to implement the summation\n    functionality.\n    @param digit_pos_to_extract: digit position to extract\n    @param denominator_addend: added to denominator of fractions in the formula\n    @param precision: same as precision in main function\n    @return: floating-point number whose integer part is not important\n    \"\"\"\n    total = 0.0\n    for sum_index in range(digit_pos_to_extract + precision):\n        denominator = 8 * sum_index + denominator_addend\n        if sum_index < digit_pos_to_extract:\n            # if the exponential term is an integer and we mod it by the denominator\n            # before dividing, only the integer part of the sum will change;\n            # the fractional part will not\n            exponential_term = pow(\n                16, digit_pos_to_extract - 1 - sum_index, denominator\n            )\n        else:\n            exponential_term = pow(16, digit_pos_to_extract - 1 - sum_index)\n        total += exponential_term / denominator\n    return total",
    "docstring": "Private helper function to implement the summation\nfunctionality.\n@param digit_pos_to_extract: digit position to extract\n@param denominator_addend: added to denominator of fractions in the formula\n@param precision: same as precision in main function\n@return: floating-point number whose integer part is not important"
  },
  {
    "function": "decimal_to_negative_base_2",
    "code": "def decimal_to_negative_base_2(num: int) -> int:\n    \"\"\"\n    This function returns the number negative base 2\n        of the decimal number of the input data.\n\n    Args:\n        int: The decimal number to convert.\n\n    Returns:\n        int: The negative base 2 number.\n\n    Examples:\n        >>> decimal_to_negative_base_2(0)\n        0\n        >>> decimal_to_negative_base_2(-19)\n        111101\n        >>> decimal_to_negative_base_2(4)\n        100\n        >>> decimal_to_negative_base_2(7)\n        11011\n    \"\"\"\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)",
    "docstring": "This function returns the number negative base 2\n    of the decimal number of the input data.\n\nArgs:\n    int: The decimal number to convert.\n\nReturns:\n    int: The negative base 2 number.\n\nExamples:\n    >>> decimal_to_negative_base_2(0)\n    0\n    >>> decimal_to_negative_base_2(-19)\n    111101\n    >>> decimal_to_negative_base_2(4)\n    100\n    >>> decimal_to_negative_base_2(7)\n    11011"
  },
  {
    "function": "prime_factors",
    "code": "def prime_factors(n: int) -> list:\n    \"\"\"Find Prime Factors.\n    >>> prime_factors(100)\n    [2, 2, 5, 5]\n    >>> prime_factors(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive integers have prime factors\n    >>> prime_factors(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive integers have prime factors\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Only positive integers have prime factors\")\n    pf = []\n    while n % 2 == 0:\n        pf.append(2)\n        n = int(n / 2)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            pf.append(i)\n            n = int(n / i)\n    if n > 2:\n        pf.append(n)\n    return pf",
    "docstring": "Find Prime Factors.\n>>> prime_factors(100)\n[2, 2, 5, 5]\n>>> prime_factors(0)\nTraceback (most recent call last):\n    ...\nValueError: Only positive integers have prime factors\n>>> prime_factors(-10)\nTraceback (most recent call last):\n    ...\nValueError: Only positive integers have prime factors"
  },
  {
    "function": "number_of_divisors",
    "code": "def number_of_divisors(n: int) -> int:\n    \"\"\"Calculate Number of Divisors of an Integer.\n    >>> number_of_divisors(100)\n    9\n    >>> number_of_divisors(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    >>> number_of_divisors(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    div = 1\n    temp = 1\n    while n % 2 == 0:\n        temp += 1\n        n = int(n / 2)\n    div *= temp\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        temp = 1\n        while n % i == 0:\n            temp += 1\n            n = int(n / i)\n        div *= temp\n    if n > 1:\n        div *= 2\n    return div",
    "docstring": "Calculate Number of Divisors of an Integer.\n>>> number_of_divisors(100)\n9\n>>> number_of_divisors(0)\nTraceback (most recent call last):\n    ...\nValueError: Only positive numbers are accepted\n>>> number_of_divisors(-10)\nTraceback (most recent call last):\n    ...\nValueError: Only positive numbers are accepted"
  },
  {
    "function": "sum_of_divisors",
    "code": "def sum_of_divisors(n: int) -> int:\n    \"\"\"Calculate Sum of Divisors.\n    >>> sum_of_divisors(100)\n    217\n    >>> sum_of_divisors(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    >>> sum_of_divisors(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    s = 1\n    temp = 1\n    while n % 2 == 0:\n        temp += 1\n        n = int(n / 2)\n    if temp > 1:\n        s *= (2**temp - 1) / (2 - 1)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        temp = 1\n        while n % i == 0:\n            temp += 1\n            n = int(n / i)\n        if temp > 1:\n            s *= (i**temp - 1) / (i - 1)\n    return int(s)",
    "docstring": "Calculate Sum of Divisors.\n>>> sum_of_divisors(100)\n217\n>>> sum_of_divisors(0)\nTraceback (most recent call last):\n    ...\nValueError: Only positive numbers are accepted\n>>> sum_of_divisors(-10)\nTraceback (most recent call last):\n    ...\nValueError: Only positive numbers are accepted"
  },
  {
    "function": "euler_phi",
    "code": "def euler_phi(n: int) -> int:\n    \"\"\"Calculate Euler's Phi Function.\n    >>> euler_phi(100)\n    40\n    >>> euler_phi(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    >>> euler_phi(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    s = n\n    for x in set(prime_factors(n)):\n        s *= (x - 1) / x\n    return int(s)",
    "docstring": "Calculate Euler's Phi Function.\n>>> euler_phi(100)\n40\n>>> euler_phi(0)\nTraceback (most recent call last):\n    ...\nValueError: Only positive numbers are accepted\n>>> euler_phi(-10)\nTraceback (most recent call last):\n    ...\nValueError: Only positive numbers are accepted"
  },
  {
    "function": "binary_exp_recursive",
    "code": "def binary_exp_recursive(base: float, exponent: int) -> float:\n    \"\"\"\n    Computes a^b recursively, where a is the base and b is the exponent\n\n    >>> binary_exp_recursive(3, 5)\n    243\n    >>> binary_exp_recursive(11, 13)\n    34522712143931\n    >>> binary_exp_recursive(-1, 3)\n    -1\n    >>> binary_exp_recursive(0, 5)\n    0\n    >>> binary_exp_recursive(3, 1)\n    3\n    >>> binary_exp_recursive(3, 0)\n    1\n    >>> binary_exp_recursive(1.5, 4)\n    5.0625\n    >>> binary_exp_recursive(3, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exponent must be a non-negative integer\n    \"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n\n    if exponent == 0:\n        return 1\n\n    if exponent % 2 == 1:\n        return binary_exp_recursive(base, exponent - 1) * base\n\n    b = binary_exp_recursive(base, exponent // 2)\n    return b * b",
    "docstring": "Computes a^b recursively, where a is the base and b is the exponent\n\n>>> binary_exp_recursive(3, 5)\n243\n>>> binary_exp_recursive(11, 13)\n34522712143931\n>>> binary_exp_recursive(-1, 3)\n-1\n>>> binary_exp_recursive(0, 5)\n0\n>>> binary_exp_recursive(3, 1)\n3\n>>> binary_exp_recursive(3, 0)\n1\n>>> binary_exp_recursive(1.5, 4)\n5.0625\n>>> binary_exp_recursive(3, -1)\nTraceback (most recent call last):\n    ...\nValueError: Exponent must be a non-negative integer"
  },
  {
    "function": "binary_exp_iterative",
    "code": "def binary_exp_iterative(base: float, exponent: int) -> float:\n    \"\"\"\n    Computes a^b iteratively, where a is the base and b is the exponent\n\n    >>> binary_exp_iterative(3, 5)\n    243\n    >>> binary_exp_iterative(11, 13)\n    34522712143931\n    >>> binary_exp_iterative(-1, 3)\n    -1\n    >>> binary_exp_iterative(0, 5)\n    0\n    >>> binary_exp_iterative(3, 1)\n    3\n    >>> binary_exp_iterative(3, 0)\n    1\n    >>> binary_exp_iterative(1.5, 4)\n    5.0625\n    >>> binary_exp_iterative(3, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exponent must be a non-negative integer\n    \"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n\n    res: int | float = 1\n    while exponent > 0:\n        if exponent & 1:\n            res *= base\n\n        base *= base\n        exponent >>= 1\n\n    return res",
    "docstring": "Computes a^b iteratively, where a is the base and b is the exponent\n\n>>> binary_exp_iterative(3, 5)\n243\n>>> binary_exp_iterative(11, 13)\n34522712143931\n>>> binary_exp_iterative(-1, 3)\n-1\n>>> binary_exp_iterative(0, 5)\n0\n>>> binary_exp_iterative(3, 1)\n3\n>>> binary_exp_iterative(3, 0)\n1\n>>> binary_exp_iterative(1.5, 4)\n5.0625\n>>> binary_exp_iterative(3, -1)\nTraceback (most recent call last):\n    ...\nValueError: Exponent must be a non-negative integer"
  },
  {
    "function": "binary_exp_mod_recursive",
    "code": "def binary_exp_mod_recursive(base: float, exponent: int, modulus: int) -> float:\n    \"\"\"\n    Computes a^b % c recursively, where a is the base, b is the exponent, and c is the\n    modulus\n\n    >>> binary_exp_mod_recursive(3, 4, 5)\n    1\n    >>> binary_exp_mod_recursive(11, 13, 7)\n    4\n    >>> binary_exp_mod_recursive(1.5, 4, 3)\n    2.0625\n    >>> binary_exp_mod_recursive(7, -1, 10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exponent must be a non-negative integer\n    >>> binary_exp_mod_recursive(7, 13, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Modulus must be a positive integer\n    \"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer\")\n\n    if exponent == 0:\n        return 1\n\n    if exponent % 2 == 1:\n        return (binary_exp_mod_recursive(base, exponent - 1, modulus) * base) % modulus\n\n    r = binary_exp_mod_recursive(base, exponent // 2, modulus)\n    return (r * r) % modulus",
    "docstring": "Computes a^b % c recursively, where a is the base, b is the exponent, and c is the\nmodulus\n\n>>> binary_exp_mod_recursive(3, 4, 5)\n1\n>>> binary_exp_mod_recursive(11, 13, 7)\n4\n>>> binary_exp_mod_recursive(1.5, 4, 3)\n2.0625\n>>> binary_exp_mod_recursive(7, -1, 10)\nTraceback (most recent call last):\n    ...\nValueError: Exponent must be a non-negative integer\n>>> binary_exp_mod_recursive(7, 13, 0)\nTraceback (most recent call last):\n    ...\nValueError: Modulus must be a positive integer"
  },
  {
    "function": "binary_exp_mod_iterative",
    "code": "def binary_exp_mod_iterative(base: float, exponent: int, modulus: int) -> float:\n    \"\"\"\n    Computes a^b % c iteratively, where a is the base, b is the exponent, and c is the\n    modulus\n\n    >>> binary_exp_mod_iterative(3, 4, 5)\n    1\n    >>> binary_exp_mod_iterative(11, 13, 7)\n    4\n    >>> binary_exp_mod_iterative(1.5, 4, 3)\n    2.0625\n    >>> binary_exp_mod_iterative(7, -1, 10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exponent must be a non-negative integer\n    >>> binary_exp_mod_iterative(7, 13, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Modulus must be a positive integer\n    \"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer\")\n\n    res: int | float = 1\n    while exponent > 0:\n        if exponent & 1:\n            res = ((res % modulus) * (base % modulus)) % modulus\n\n        base *= base\n        exponent >>= 1\n\n    return res",
    "docstring": "Computes a^b % c iteratively, where a is the base, b is the exponent, and c is the\nmodulus\n\n>>> binary_exp_mod_iterative(3, 4, 5)\n1\n>>> binary_exp_mod_iterative(11, 13, 7)\n4\n>>> binary_exp_mod_iterative(1.5, 4, 3)\n2.0625\n>>> binary_exp_mod_iterative(7, -1, 10)\nTraceback (most recent call last):\n    ...\nValueError: Exponent must be a non-negative integer\n>>> binary_exp_mod_iterative(7, 13, 0)\nTraceback (most recent call last):\n    ...\nValueError: Modulus must be a positive integer"
  },
  {
    "function": "binary_multiply",
    "code": "def binary_multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply 'a' and 'b' using bitwise multiplication.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: a * b\n\n    Examples:\n    >>> binary_multiply(2, 3)\n    6\n    >>> binary_multiply(5, 0)\n    0\n    >>> binary_multiply(3, 4)\n    12\n    >>> binary_multiply(10, 5)\n    50\n    >>> binary_multiply(0, 5)\n    0\n    >>> binary_multiply(2, 1)\n    2\n    >>> binary_multiply(1, 10)\n    10\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res",
    "docstring": "Multiply 'a' and 'b' using bitwise multiplication.\n\nParameters:\na (int): The first number.\nb (int): The second number.\n\nReturns:\nint: a * b\n\nExamples:\n>>> binary_multiply(2, 3)\n6\n>>> binary_multiply(5, 0)\n0\n>>> binary_multiply(3, 4)\n12\n>>> binary_multiply(10, 5)\n50\n>>> binary_multiply(0, 5)\n0\n>>> binary_multiply(2, 1)\n2\n>>> binary_multiply(1, 10)\n10"
  },
  {
    "function": "binary_mod_multiply",
    "code": "def binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res",
    "docstring": "Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\nParameters:\na (int): The first number.\nb (int): The second number.\nmodulus (int): The modulus.\n\nReturns:\nint: (a * b) % modulus.\n\nExamples:\n>>> binary_mod_multiply(2, 3, 5)\n1\n>>> binary_mod_multiply(5, 0, 7)\n0\n>>> binary_mod_multiply(3, 4, 6)\n0\n>>> binary_mod_multiply(10, 5, 13)\n11\n>>> binary_mod_multiply(2, 1, 5)\n2\n>>> binary_mod_multiply(1, 10, 3)\n1"
  },
  {
    "function": "binomial_coefficient",
    "code": "def binomial_coefficient(n: int, r: int) -> int:\n    \"\"\"\n    Find binomial coefficient using Pascal's triangle.\n\n    Calculate C(n, r) using Pascal's triangle.\n\n    :param n: The total number of items.\n    :param r: The number of items to choose.\n    :return: The binomial coefficient C(n, r).\n\n    >>> binomial_coefficient(10, 5)\n    252\n    >>> binomial_coefficient(10, 0)\n    1\n    >>> binomial_coefficient(0, 10)\n    1\n    >>> binomial_coefficient(10, 10)\n    1\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(5, 6)\n    0\n    >>> binomial_coefficient(3, 5)\n    0\n    >>> binomial_coefficient(-2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: n and r must be non-negative integers\n    >>> binomial_coefficient(5, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n and r must be non-negative integers\n    >>> binomial_coefficient(10.1, 5)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> binomial_coefficient(10, 5.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    \"\"\"\n    if n < 0 or r < 0:\n        raise ValueError(\"n and r must be non-negative integers\")\n    if 0 in (n, r):\n        return 1\n    c = [0 for i in range(r + 1)]\n    # nc0 = 1\n    c[0] = 1\n    for i in range(1, n + 1):\n        # to compute current row from previous row.\n        j = min(i, r)\n        while j > 0:\n            c[j] += c[j - 1]\n            j -= 1\n    return c[r]",
    "docstring": "Find binomial coefficient using Pascal's triangle.\n\nCalculate C(n, r) using Pascal's triangle.\n\n:param n: The total number of items.\n:param r: The number of items to choose.\n:return: The binomial coefficient C(n, r).\n\n>>> binomial_coefficient(10, 5)\n252\n>>> binomial_coefficient(10, 0)\n1\n>>> binomial_coefficient(0, 10)\n1\n>>> binomial_coefficient(10, 10)\n1\n>>> binomial_coefficient(5, 2)\n10\n>>> binomial_coefficient(5, 6)\n0\n>>> binomial_coefficient(3, 5)\n0\n>>> binomial_coefficient(-2, 3)\nTraceback (most recent call last):\n    ...\nValueError: n and r must be non-negative integers\n>>> binomial_coefficient(5, -1)\nTraceback (most recent call last):\n    ...\nValueError: n and r must be non-negative integers\n>>> binomial_coefficient(10.1, 5)\nTraceback (most recent call last):\n    ...\nTypeError: 'float' object cannot be interpreted as an integer\n>>> binomial_coefficient(10, 5.1)\nTraceback (most recent call last):\n    ...\nTypeError: 'float' object cannot be interpreted as an integer"
  },
  {
    "function": "binomial_distribution",
    "code": "def binomial_distribution(successes: int, trials: int, prob: float) -> float:\n    \"\"\"\n    Return probability of k successes out of n tries, with p probability for one\n    success\n\n    The function uses the factorial function in order to calculate the binomial\n    coefficient\n\n    >>> binomial_distribution(3, 5, 0.7)\n    0.30870000000000003\n    >>> binomial_distribution (2, 4, 0.5)\n    0.375\n    \"\"\"\n    if successes > trials:\n        raise ValueError(\"\"\"successes must be lower or equal to trials\"\"\")\n    if trials < 0 or successes < 0:\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not isinstance(successes, int) or not isinstance(trials, int):\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not 0 < prob < 1:\n        raise ValueError(\"prob has to be in range of 1 - 0\")\n    probability = (prob**successes) * ((1 - prob) ** (trials - successes))\n    # Calculate the binomial coefficient: n! / k!(n-k)!\n    coefficient = float(factorial(trials))\n    coefficient /= factorial(successes) * factorial(trials - successes)\n    return probability * coefficient",
    "docstring": "Return probability of k successes out of n tries, with p probability for one\nsuccess\n\nThe function uses the factorial function in order to calculate the binomial\ncoefficient\n\n>>> binomial_distribution(3, 5, 0.7)\n0.30870000000000003\n>>> binomial_distribution (2, 4, 0.5)\n0.375"
  },
  {
    "function": "ceil",
    "code": "def ceil(x: float) -> int:\n    \"\"\"\n    Return the ceiling of x as an Integral.\n\n    :param x: the number\n    :return: the smallest integer >= x.\n\n    >>> import math\n    >>> all(ceil(n) == math.ceil(n) for n\n    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))\n    True\n    \"\"\"\n    return int(x) if x - int(x) <= 0 else int(x) + 1",
    "docstring": "Return the ceiling of x as an Integral.\n\n:param x: the number\n:return: the smallest integer >= x.\n\n>>> import math\n>>> all(ceil(n) == math.ceil(n) for n\n...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))\nTrue"
  },
  {
    "function": "chebyshev_distance",
    "code": "def chebyshev_distance(point_a: list[float], point_b: list[float]) -> float:\n    \"\"\"\n    This function calculates the Chebyshev distance (also known as the\n    Chessboard distance) between two n-dimensional points represented as lists.\n\n    https://en.wikipedia.org/wiki/Chebyshev_distance\n\n    >>> chebyshev_distance([1.0, 1.0], [2.0, 2.0])\n    1.0\n    >>> chebyshev_distance([1.0, 1.0, 9.0], [2.0, 2.0, -5.2])\n    14.2\n    >>> chebyshev_distance([1.0], [2.0, 2.0])\n    Traceback (most recent call last):\n        ...\n    ValueError: Both points must have the same dimension.\n    \"\"\"\n    if len(point_a) != len(point_b):\n        raise ValueError(\"Both points must have the same dimension.\")\n\n    return max(abs(a - b) for a, b in zip(point_a, point_b))",
    "docstring": "This function calculates the Chebyshev distance (also known as the\nChessboard distance) between two n-dimensional points represented as lists.\n\nhttps://en.wikipedia.org/wiki/Chebyshev_distance\n\n>>> chebyshev_distance([1.0, 1.0], [2.0, 2.0])\n1.0\n>>> chebyshev_distance([1.0, 1.0, 9.0], [2.0, 2.0, -5.2])\n14.2\n>>> chebyshev_distance([1.0], [2.0, 2.0])\nTraceback (most recent call last):\n    ...\nValueError: Both points must have the same dimension."
  },
  {
    "function": "check_polygon",
    "code": "def check_polygon(nums: list[float]) -> bool:\n    \"\"\"\n    Takes list of possible side lengths and determines whether a\n    two-dimensional polygon with such side lengths can exist.\n\n    Returns a boolean value for the < comparison\n    of the largest side length with sum of the rest.\n    Wiki: https://en.wikipedia.org/wiki/Triangle_inequality\n\n    >>> check_polygon([6, 10, 5])\n    True\n    >>> check_polygon([3, 7, 13, 2])\n    False\n    >>> check_polygon([1, 4.3, 5.2, 12.2])\n    False\n    >>> nums = [3, 7, 13, 2]\n    >>> _ = check_polygon(nums) #   Run function, do not show answer in output\n    >>> nums #  Check numbers are not reordered\n    [3, 7, 13, 2]\n    >>> check_polygon([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Monogons and Digons are not polygons in the Euclidean space\n    >>> check_polygon([-2, 5, 6])\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be greater than 0\n    \"\"\"\n    if len(nums) < 2:\n        raise ValueError(\"Monogons and Digons are not polygons in the Euclidean space\")\n    if any(i <= 0 for i in nums):\n        raise ValueError(\"All values must be greater than 0\")\n    copy_nums = nums.copy()\n    copy_nums.sort()\n    return copy_nums[-1] < sum(copy_nums[:-1])",
    "docstring": "Takes list of possible side lengths and determines whether a\ntwo-dimensional polygon with such side lengths can exist.\n\nReturns a boolean value for the < comparison\nof the largest side length with sum of the rest.\nWiki: https://en.wikipedia.org/wiki/Triangle_inequality\n\n>>> check_polygon([6, 10, 5])\nTrue\n>>> check_polygon([3, 7, 13, 2])\nFalse\n>>> check_polygon([1, 4.3, 5.2, 12.2])\nFalse\n>>> nums = [3, 7, 13, 2]\n>>> _ = check_polygon(nums) #   Run function, do not show answer in output\n>>> nums #  Check numbers are not reordered\n[3, 7, 13, 2]\n>>> check_polygon([])\nTraceback (most recent call last):\n    ...\nValueError: Monogons and Digons are not polygons in the Euclidean space\n>>> check_polygon([-2, 5, 6])\nTraceback (most recent call last):\n    ...\nValueError: All values must be greater than 0"
  },
  {
    "function": "extended_euclid",
    "code": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)",
    "docstring": ">>> extended_euclid(10, 6)\n(-1, 2)\n\n>>> extended_euclid(7, 5)\n(-2, 3)"
  },
  {
    "function": "chinese_remainder_theorem",
    "code": "def chinese_remainder_theorem(n1: int, r1: int, n2: int, r2: int) -> int:\n    \"\"\"\n    >>> chinese_remainder_theorem(5,1,7,3)\n    31\n\n    Explanation : 31 is the smallest number such that\n                (i)  When we divide it by 5, we get remainder 1\n                (ii) When we divide it by 7, we get remainder 3\n\n    >>> chinese_remainder_theorem(6,1,4,3)\n    14\n\n    \"\"\"\n    (x, y) = extended_euclid(n1, n2)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m",
    "docstring": ">>> chinese_remainder_theorem(5,1,7,3)\n31\n\nExplanation : 31 is the smallest number such that\n            (i)  When we divide it by 5, we get remainder 1\n            (ii) When we divide it by 7, we get remainder 3\n\n>>> chinese_remainder_theorem(6,1,4,3)\n14"
  },
  {
    "function": "invert_modulo",
    "code": "def invert_modulo(a: int, n: int) -> int:\n    \"\"\"\n    >>> invert_modulo(2, 5)\n    3\n\n    >>> invert_modulo(8,7)\n    1\n\n    \"\"\"\n    (b, _x) = extended_euclid(a, n)\n    if b < 0:\n        b = (b % n + n) % n\n    return b",
    "docstring": ">>> invert_modulo(2, 5)\n3\n\n>>> invert_modulo(8,7)\n1"
  },
  {
    "function": "chinese_remainder_theorem2",
    "code": "def chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:\n    \"\"\"\n    >>> chinese_remainder_theorem2(5,1,7,3)\n    31\n\n    >>> chinese_remainder_theorem2(6,1,4,3)\n    14\n\n    \"\"\"\n    x, y = invert_modulo(n1, n2), invert_modulo(n2, n1)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m",
    "docstring": ">>> chinese_remainder_theorem2(5,1,7,3)\n31\n\n>>> chinese_remainder_theorem2(6,1,4,3)\n14"
  },
  {
    "function": "pi",
    "code": "def pi(precision: int) -> str:\n    \"\"\"\n    The Chudnovsky algorithm is a fast method for calculating the digits of PI,\n    based on Ramanujan's PI formulae.\n\n    https://en.wikipedia.org/wiki/Chudnovsky_algorithm\n\n    PI = constant_term / ((multinomial_term * linear_term) / exponential_term)\n        where constant_term = 426880 * sqrt(10005)\n\n    The linear_term and the exponential_term can be defined iteratively as follows:\n        L_k+1 = L_k + 545140134            where L_0 = 13591409\n        X_k+1 = X_k * -262537412640768000  where X_0 = 1\n\n    The multinomial_term is defined as follows:\n        6k! / ((3k)! * (k!) ^ 3)\n            where k is the k_th iteration.\n\n    This algorithm correctly calculates around 14 digits of PI per iteration\n\n    >>> pi(10)\n    '3.14159265'\n    >>> pi(100)\n    '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706'\n    >>> pi('hello')\n    Traceback (most recent call last):\n        ...\n    TypeError: Undefined for non-integers\n    >>> pi(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Undefined for non-natural numbers\n    \"\"\"\n\n    if not isinstance(precision, int):\n        raise TypeError(\"Undefined for non-integers\")\n    elif precision < 1:\n        raise ValueError(\"Undefined for non-natural numbers\")\n\n    getcontext().prec = precision\n    num_iterations = ceil(precision / 14)\n    constant_term = 426880 * Decimal(10005).sqrt()\n    exponential_term = 1\n    linear_term = 13591409\n    partial_sum = Decimal(linear_term)\n    for k in range(1, num_iterations):\n        multinomial_term = factorial(6 * k) // (factorial(3 * k) * factorial(k) ** 3)\n        linear_term += 545140134\n        exponential_term *= -262537412640768000\n        partial_sum += Decimal(multinomial_term * linear_term) / exponential_term\n    return str(constant_term / partial_sum)[:-1]",
    "docstring": "The Chudnovsky algorithm is a fast method for calculating the digits of PI,\nbased on Ramanujan's PI formulae.\n\nhttps://en.wikipedia.org/wiki/Chudnovsky_algorithm\n\nPI = constant_term / ((multinomial_term * linear_term) / exponential_term)\n    where constant_term = 426880 * sqrt(10005)\n\nThe linear_term and the exponential_term can be defined iteratively as follows:\n    L_k+1 = L_k + 545140134            where L_0 = 13591409\n    X_k+1 = X_k * -262537412640768000  where X_0 = 1\n\nThe multinomial_term is defined as follows:\n    6k! / ((3k)! * (k!) ^ 3)\n        where k is the k_th iteration.\n\nThis algorithm correctly calculates around 14 digits of PI per iteration\n\n>>> pi(10)\n'3.14159265'\n>>> pi(100)\n'3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706'\n>>> pi('hello')\nTraceback (most recent call last):\n    ...\nTypeError: Undefined for non-integers\n>>> pi(-1)\nTraceback (most recent call last):\n    ...\nValueError: Undefined for non-natural numbers"
  },
  {
    "function": "collatz_sequence",
    "code": "def collatz_sequence(n: int) -> Generator[int]:\n    \"\"\"\n    Generate the Collatz sequence starting at n.\n    >>> tuple(collatz_sequence(2.1))\n    Traceback (most recent call last):\n        ...\n    Exception: Sequence only defined for positive integers\n    >>> tuple(collatz_sequence(0))\n    Traceback (most recent call last):\n        ...\n    Exception: Sequence only defined for positive integers\n    >>> tuple(collatz_sequence(4))\n    (4, 2, 1)\n    >>> tuple(collatz_sequence(11))\n    (11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1)\n    >>> tuple(collatz_sequence(31))     # doctest: +NORMALIZE_WHITESPACE\n    (31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137,\n    412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593,\n    1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425,\n    1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644,\n    1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732,\n    866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53,\n    160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1)\n    >>> tuple(collatz_sequence(43))     # doctest: +NORMALIZE_WHITESPACE\n    (43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26,\n    13, 40, 20, 10, 5, 16, 8, 4, 2, 1)\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise Exception(\"Sequence only defined for positive integers\")\n\n    yield n\n    while n != 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = 3 * n + 1\n        yield n",
    "docstring": "Generate the Collatz sequence starting at n.\n>>> tuple(collatz_sequence(2.1))\nTraceback (most recent call last):\n    ...\nException: Sequence only defined for positive integers\n>>> tuple(collatz_sequence(0))\nTraceback (most recent call last):\n    ...\nException: Sequence only defined for positive integers\n>>> tuple(collatz_sequence(4))\n(4, 2, 1)\n>>> tuple(collatz_sequence(11))\n(11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1)\n>>> tuple(collatz_sequence(31))     # doctest: +NORMALIZE_WHITESPACE\n(31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137,\n412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593,\n1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425,\n1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644,\n1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732,\n866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53,\n160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1)\n>>> tuple(collatz_sequence(43))     # doctest: +NORMALIZE_WHITESPACE\n(43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26,\n13, 40, 20, 10, 5, 16, 8, 4, 2, 1)"
  },
  {
    "function": "combinations",
    "code": "def combinations(n: int, k: int) -> int:\n    \"\"\"\n    Returns the number of different combinations of k length which can\n    be made from n values, where n >= k.\n\n    Examples:\n    >>> combinations(10,5)\n    252\n\n    >>> combinations(6,3)\n    20\n\n    >>> combinations(20,5)\n    15504\n\n    >>> combinations(52, 5)\n    2598960\n\n    >>> combinations(0, 0)\n    1\n\n    >>> combinations(-4, -5)\n    ...\n    Traceback (most recent call last):\n    ValueError: Please enter positive integers for n and k where n >= k\n    \"\"\"\n\n    # If either of the conditions are true, the function is being asked\n    # to calculate a factorial of a negative number, which is not possible\n    if n < k or k < 0:\n        raise ValueError(\"Please enter positive integers for n and k where n >= k\")\n    res = 1\n    for i in range(k):\n        res *= n - i\n        res //= i + 1\n    return res",
    "docstring": "Returns the number of different combinations of k length which can\nbe made from n values, where n >= k.\n\nExamples:\n>>> combinations(10,5)\n252\n\n>>> combinations(6,3)\n20\n\n>>> combinations(20,5)\n15504\n\n>>> combinations(52, 5)\n2598960\n\n>>> combinations(0, 0)\n1\n\n>>> combinations(-4, -5)\n...\nTraceback (most recent call last):\nValueError: Please enter positive integers for n and k where n >= k"
  },
  {
    "function": "continued_fraction",
    "code": "def continued_fraction(num: Fraction) -> list[int]:\n    \"\"\"\n    :param num:\n    Fraction of the number whose continued fractions to be found.\n    Use Fraction(str(number)) for more accurate results due to\n    float inaccuracies.\n\n    :return:\n    The continued fraction of rational number.\n    It is the all commas in the (n + 1)-tuple notation.\n\n    >>> continued_fraction(Fraction(2))\n    [2]\n    >>> continued_fraction(Fraction(\"3.245\"))\n    [3, 4, 12, 4]\n    >>> continued_fraction(Fraction(\"2.25\"))\n    [2, 4]\n    >>> continued_fraction(1/Fraction(\"2.25\"))\n    [0, 2, 4]\n    >>> continued_fraction(Fraction(\"415/93\"))\n    [4, 2, 6, 7]\n    >>> continued_fraction(Fraction(0))\n    [0]\n    >>> continued_fraction(Fraction(0.75))\n    [0, 1, 3]\n    >>> continued_fraction(Fraction(\"-2.25\"))    # -2.25 = -3 + 0.75\n    [-3, 1, 3]\n    \"\"\"\n    numerator, denominator = num.as_integer_ratio()\n    continued_fraction_list: list[int] = []\n    while True:\n        integer_part = floor(numerator / denominator)\n        continued_fraction_list.append(integer_part)\n        numerator -= integer_part * denominator\n        if numerator == 0:\n            break\n        numerator, denominator = denominator, numerator\n\n    return continued_fraction_list",
    "docstring": ":param num:\nFraction of the number whose continued fractions to be found.\nUse Fraction(str(number)) for more accurate results due to\nfloat inaccuracies.\n\n:return:\nThe continued fraction of rational number.\nIt is the all commas in the (n + 1)-tuple notation.\n\n>>> continued_fraction(Fraction(2))\n[2]\n>>> continued_fraction(Fraction(\"3.245\"))\n[3, 4, 12, 4]\n>>> continued_fraction(Fraction(\"2.25\"))\n[2, 4]\n>>> continued_fraction(1/Fraction(\"2.25\"))\n[0, 2, 4]\n>>> continued_fraction(Fraction(\"415/93\"))\n[4, 2, 6, 7]\n>>> continued_fraction(Fraction(0))\n[0]\n>>> continued_fraction(Fraction(0.75))\n[0, 1, 3]\n>>> continued_fraction(Fraction(\"-2.25\"))    # -2.25 = -3 + 0.75\n[-3, 1, 3]"
  },
  {
    "function": "decimal_isolate",
    "code": "def decimal_isolate(number: float, digit_amount: int) -> float:\n    \"\"\"\n    Isolates the decimal part of a number.\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\n    >>> decimal_isolate(1.53, 0)\n    0.53\n    >>> decimal_isolate(35.345, 1)\n    0.3\n    >>> decimal_isolate(35.345, 2)\n    0.34\n    >>> decimal_isolate(35.345, 3)\n    0.345\n    >>> decimal_isolate(-14.789, 3)\n    -0.789\n    >>> decimal_isolate(0, 2)\n    0\n    >>> decimal_isolate(-14.123, 1)\n    -0.1\n    >>> decimal_isolate(-14.123, 2)\n    -0.12\n    >>> decimal_isolate(-14.123, 3)\n    -0.123\n    \"\"\"\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)",
    "docstring": "Isolates the decimal part of a number.\nIf digitAmount > 0 round to that decimal place, else print the entire decimal.\n>>> decimal_isolate(1.53, 0)\n0.53\n>>> decimal_isolate(35.345, 1)\n0.3\n>>> decimal_isolate(35.345, 2)\n0.34\n>>> decimal_isolate(35.345, 3)\n0.345\n>>> decimal_isolate(-14.789, 3)\n-0.789\n>>> decimal_isolate(0, 2)\n0\n>>> decimal_isolate(-14.123, 1)\n-0.1\n>>> decimal_isolate(-14.123, 2)\n-0.12\n>>> decimal_isolate(-14.123, 3)\n-0.123"
  },
  {
    "function": "decimal_to_fraction",
    "code": "def decimal_to_fraction(decimal: float | str) -> tuple[int, int]:\n    \"\"\"\n    Return a decimal number in its simplest fraction form\n    >>> decimal_to_fraction(2)\n    (2, 1)\n    >>> decimal_to_fraction(89.)\n    (89, 1)\n    >>> decimal_to_fraction(\"67\")\n    (67, 1)\n    >>> decimal_to_fraction(\"45.0\")\n    (45, 1)\n    >>> decimal_to_fraction(1.5)\n    (3, 2)\n    >>> decimal_to_fraction(\"6.25\")\n    (25, 4)\n    >>> decimal_to_fraction(\"78td\")\n    Traceback (most recent call last):\n    ValueError: Please enter a valid number\n    >>> decimal_to_fraction(0)\n    (0, 1)\n    >>> decimal_to_fraction(-2.5)\n    (-5, 2)\n    >>> decimal_to_fraction(0.125)\n    (1, 8)\n    >>> decimal_to_fraction(1000000.25)\n    (4000001, 4)\n    >>> decimal_to_fraction(1.3333)\n    (13333, 10000)\n    >>> decimal_to_fraction(\"1.23e2\")\n    (123, 1)\n    >>> decimal_to_fraction(\"0.500\")\n    (1, 2)\n    \"\"\"\n    try:\n        decimal = float(decimal)\n    except ValueError:\n        raise ValueError(\"Please enter a valid number\")\n    fractional_part = decimal - int(decimal)\n    if fractional_part == 0:\n        return int(decimal), 1\n    else:\n        number_of_frac_digits = len(str(decimal).split(\".\")[1])\n        numerator = int(decimal * (10**number_of_frac_digits))\n        denominator = 10**number_of_frac_digits\n        divisor, dividend = denominator, numerator\n        while True:\n            remainder = dividend % divisor\n            if remainder == 0:\n                break\n            dividend, divisor = divisor, remainder\n        numerator, denominator = numerator // divisor, denominator // divisor\n        return numerator, denominator",
    "docstring": "Return a decimal number in its simplest fraction form\n>>> decimal_to_fraction(2)\n(2, 1)\n>>> decimal_to_fraction(89.)\n(89, 1)\n>>> decimal_to_fraction(\"67\")\n(67, 1)\n>>> decimal_to_fraction(\"45.0\")\n(45, 1)\n>>> decimal_to_fraction(1.5)\n(3, 2)\n>>> decimal_to_fraction(\"6.25\")\n(25, 4)\n>>> decimal_to_fraction(\"78td\")\nTraceback (most recent call last):\nValueError: Please enter a valid number\n>>> decimal_to_fraction(0)\n(0, 1)\n>>> decimal_to_fraction(-2.5)\n(-5, 2)\n>>> decimal_to_fraction(0.125)\n(1, 8)\n>>> decimal_to_fraction(1000000.25)\n(4000001, 4)\n>>> decimal_to_fraction(1.3333)\n(13333, 10000)\n>>> decimal_to_fraction(\"1.23e2\")\n(123, 1)\n>>> decimal_to_fraction(\"0.500\")\n(1, 2)"
  },
  {
    "function": "dodecahedron_surface_area",
    "code": "def dodecahedron_surface_area(edge: float) -> float:\n    \"\"\"\n    Calculates the surface area of a regular dodecahedron\n    a = 3 * ((25 + 10 * (5** (1 / 2))) ** (1 / 2 )) * (e**2)\n    where:\n    a --> is the area of the dodecahedron\n    e --> is the length of the edge\n    reference-->\"Dodecahedron\" Study.com\n    <https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>\n\n    :param edge: length of the edge of the dodecahedron\n    :type edge: float\n    :return: the surface area of the dodecahedron as a float\n\n\n    Tests:\n    >>> dodecahedron_surface_area(5)\n    516.1432201766901\n    >>> dodecahedron_surface_area(10)\n    2064.5728807067603\n    >>> dodecahedron_surface_area(-1)\n    Traceback (most recent call last):\n      ...\n    ValueError: Length must be a positive.\n    \"\"\"\n\n    if edge <= 0 or not isinstance(edge, int):\n        raise ValueError(\"Length must be a positive.\")\n    return 3 * ((25 + 10 * (5 ** (1 / 2))) ** (1 / 2)) * (edge**2)",
    "docstring": "Calculates the surface area of a regular dodecahedron\na = 3 * ((25 + 10 * (5** (1 / 2))) ** (1 / 2 )) * (e**2)\nwhere:\na --> is the area of the dodecahedron\ne --> is the length of the edge\nreference-->\"Dodecahedron\" Study.com\n<https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>\n\n:param edge: length of the edge of the dodecahedron\n:type edge: float\n:return: the surface area of the dodecahedron as a float\n\n\nTests:\n>>> dodecahedron_surface_area(5)\n516.1432201766901\n>>> dodecahedron_surface_area(10)\n2064.5728807067603\n>>> dodecahedron_surface_area(-1)\nTraceback (most recent call last):\n  ...\nValueError: Length must be a positive."
  },
  {
    "function": "dodecahedron_volume",
    "code": "def dodecahedron_volume(edge: float) -> float:\n    \"\"\"\n    Calculates the volume of a regular dodecahedron\n    v = ((15 + (7 * (5** (1 / 2)))) / 4) * (e**3)\n    where:\n    v --> is the volume of the dodecahedron\n    e --> is the length of the edge\n    reference-->\"Dodecahedron\" Study.com\n    <https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>\n\n    :param edge: length of the edge of the dodecahedron\n    :type edge: float\n    :return: the volume of the dodecahedron as a float\n\n    Tests:\n    >>> dodecahedron_volume(5)\n    957.8898700780791\n    >>> dodecahedron_volume(10)\n    7663.118960624633\n    >>> dodecahedron_volume(-1)\n    Traceback (most recent call last):\n      ...\n    ValueError: Length must be a positive.\n    \"\"\"\n\n    if edge <= 0 or not isinstance(edge, int):\n        raise ValueError(\"Length must be a positive.\")\n    return ((15 + (7 * (5 ** (1 / 2)))) / 4) * (edge**3)",
    "docstring": "Calculates the volume of a regular dodecahedron\nv = ((15 + (7 * (5** (1 / 2)))) / 4) * (e**3)\nwhere:\nv --> is the volume of the dodecahedron\ne --> is the length of the edge\nreference-->\"Dodecahedron\" Study.com\n<https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>\n\n:param edge: length of the edge of the dodecahedron\n:type edge: float\n:return: the volume of the dodecahedron as a float\n\nTests:\n>>> dodecahedron_volume(5)\n957.8898700780791\n>>> dodecahedron_volume(10)\n7663.118960624633\n>>> dodecahedron_volume(-1)\nTraceback (most recent call last):\n  ...\nValueError: Length must be a positive."
  },
  {
    "function": "double_factorial_recursive",
    "code": "def double_factorial_recursive(n: int) -> int:\n    \"\"\"\n    Compute double factorial using recursive method.\n    Recursion can be costly for large numbers.\n\n    To learn about the theory behind this algorithm:\n    https://en.wikipedia.org/wiki/Double_factorial\n\n    >>> from math import prod\n    >>> all(double_factorial_recursive(i) == prod(range(i, 0, -2)) for i in range(20))\n    True\n    >>> double_factorial_recursive(0.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: double_factorial_recursive() only accepts integral values\n    >>> double_factorial_recursive(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: double_factorial_recursive() not defined for negative values\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"double_factorial_recursive() only accepts integral values\")\n    if n < 0:\n        raise ValueError(\"double_factorial_recursive() not defined for negative values\")\n    return 1 if n <= 1 else n * double_factorial_recursive(n - 2)",
    "docstring": "Compute double factorial using recursive method.\nRecursion can be costly for large numbers.\n\nTo learn about the theory behind this algorithm:\nhttps://en.wikipedia.org/wiki/Double_factorial\n\n>>> from math import prod\n>>> all(double_factorial_recursive(i) == prod(range(i, 0, -2)) for i in range(20))\nTrue\n>>> double_factorial_recursive(0.1)\nTraceback (most recent call last):\n    ...\nValueError: double_factorial_recursive() only accepts integral values\n>>> double_factorial_recursive(-1)\nTraceback (most recent call last):\n    ...\nValueError: double_factorial_recursive() not defined for negative values"
  },
  {
    "function": "double_factorial_iterative",
    "code": "def double_factorial_iterative(num: int) -> int:\n    \"\"\"\n    Compute double factorial using iterative method.\n\n    To learn about the theory behind this algorithm:\n    https://en.wikipedia.org/wiki/Double_factorial\n\n    >>> from math import prod\n    >>> all(double_factorial_iterative(i) == prod(range(i, 0, -2)) for i in range(20))\n    True\n    >>> double_factorial_iterative(0.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: double_factorial_iterative() only accepts integral values\n    >>> double_factorial_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: double_factorial_iterative() not defined for negative values\n    \"\"\"\n    if not isinstance(num, int):\n        raise ValueError(\"double_factorial_iterative() only accepts integral values\")\n    if num < 0:\n        raise ValueError(\"double_factorial_iterative() not defined for negative values\")\n    value = 1\n    for i in range(num, 0, -2):\n        value *= i\n    return value",
    "docstring": "Compute double factorial using iterative method.\n\nTo learn about the theory behind this algorithm:\nhttps://en.wikipedia.org/wiki/Double_factorial\n\n>>> from math import prod\n>>> all(double_factorial_iterative(i) == prod(range(i, 0, -2)) for i in range(20))\nTrue\n>>> double_factorial_iterative(0.1)\nTraceback (most recent call last):\n    ...\nValueError: double_factorial_iterative() only accepts integral values\n>>> double_factorial_iterative(-1)\nTraceback (most recent call last):\n    ...\nValueError: double_factorial_iterative() not defined for negative values"
  },
  {
    "function": "differentiate",
    "code": "def differentiate(func, position, order):\n    \"\"\"\n    >>> differentiate(lambda x: x**2, 2, 2)\n    2\n    >>> differentiate(lambda x: x**2 * x**4, 9, 2)\n    196830\n    >>> differentiate(lambda y: 0.5 * (y + 3) ** 6, 3.5, 4)\n    7605.0\n    >>> differentiate(lambda y: y ** 2, 4, 3)\n    0\n    >>> differentiate(8, 8, 8)\n    Traceback (most recent call last):\n        ...\n    ValueError: differentiate() requires a function as input for func\n    >>> differentiate(lambda x: x **2, \"\", 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: differentiate() requires a float as input for position\n    >>> differentiate(lambda x: x**2, 3, \"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: differentiate() requires an int as input for order\n    \"\"\"\n    if not callable(func):\n        raise ValueError(\"differentiate() requires a function as input for func\")\n    if not isinstance(position, (float, int)):\n        raise ValueError(\"differentiate() requires a float as input for position\")\n    if not isinstance(order, int):\n        raise ValueError(\"differentiate() requires an int as input for order\")\n    d = Dual(position, 1)\n    result = func(d)\n    if order == 0:\n        return result.real\n    return result.duals[order - 1] * factorial(order)",
    "docstring": ">>> differentiate(lambda x: x**2, 2, 2)\n2\n>>> differentiate(lambda x: x**2 * x**4, 9, 2)\n196830\n>>> differentiate(lambda y: 0.5 * (y + 3) ** 6, 3.5, 4)\n7605.0\n>>> differentiate(lambda y: y ** 2, 4, 3)\n0\n>>> differentiate(8, 8, 8)\nTraceback (most recent call last):\n    ...\nValueError: differentiate() requires a function as input for func\n>>> differentiate(lambda x: x **2, \"\", 1)\nTraceback (most recent call last):\n    ...\nValueError: differentiate() requires a float as input for position\n>>> differentiate(lambda x: x**2, 3, \"\")\nTraceback (most recent call last):\n    ...\nValueError: differentiate() requires an int as input for order"
  },
  {
    "function": "calculate_prob",
    "code": "def calculate_prob(text: str) -> None:\n    \"\"\"\n    This method takes path and two dict as argument\n    and than calculates entropy of them.\n    :param dict:\n    :param dict:\n    :return: Prints\n    1) Entropy of information based on 1 alphabet\n    2) Entropy of information based on couples of 2 alphabet\n    3) print Entropy of H(X n|Xn-1)\n\n    Text from random books. Also, random quotes.\n    >>> text = (\"Behind Winston's back the voice \"\n    ...         \"from the telescreen was still \"\n    ...         \"babbling and the overfulfilment\")\n    >>> calculate_prob(text)\n    4.0\n    6.0\n    2.0\n\n    >>> text = (\"The Ministry of Truth\u2014Minitrue, in Newspeak [Newspeak was the official\"\n    ...         \"face in elegant lettering, the three\")\n    >>> calculate_prob(text)\n    4.0\n    5.0\n    1.0\n    >>> text = (\"Had repulsive dashwoods suspicion sincerity but advantage now him. \"\n    ...         \"Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. \"\n    ...         \"You greatest jointure saw horrible. He private he on be imagine \"\n    ...         \"suppose. Fertile beloved evident through no service elderly is. Blind \"\n    ...         \"there if every no so at. Own neglected you preferred way sincerity \"\n    ...         \"delivered his attempted. To of message cottage windows do besides \"\n    ...         \"against uncivil.  Delightful unreserved impossible few estimating \"\n    ...         \"men favourable see entreaties. She propriety immediate was improving. \"\n    ...         \"He or entrance humoured likewise moderate. Much nor game son say \"\n    ...         \"feel. Fat make met can must form into gate. Me we offending prevailed \"\n    ...         \"discovery.\")\n    >>> calculate_prob(text)\n    4.0\n    7.0\n    3.0\n    \"\"\"\n    single_char_strings, two_char_strings = analyze_text(text)\n    my_alphas = list(\" \" + ascii_lowercase)\n    # what is our total sum of probabilities.\n    all_sum = sum(single_char_strings.values())\n\n    # one length string\n    my_fir_sum = 0\n    # for each alpha we go in our dict and if it is in it we calculate entropy\n    for ch in my_alphas:\n        if ch in single_char_strings:\n            my_str = single_char_strings[ch]\n            prob = my_str / all_sum\n            my_fir_sum += prob * math.log2(prob)  # entropy formula.\n\n    # print entropy\n    print(f\"{round(-1 * my_fir_sum):.1f}\")\n\n    # two len string\n    all_sum = sum(two_char_strings.values())\n    my_sec_sum = 0\n    # for each alpha (two in size) calculate entropy.\n    for ch0 in my_alphas:\n        for ch1 in my_alphas:\n            sequence = ch0 + ch1\n            if sequence in two_char_strings:\n                my_str = two_char_strings[sequence]\n                prob = int(my_str) / all_sum\n                my_sec_sum += prob * math.log2(prob)\n\n    # print second entropy\n    print(f\"{round(-1 * my_sec_sum):.1f}\")\n\n    # print the difference between them\n    print(f\"{round((-1 * my_sec_sum) - (-1 * my_fir_sum)):.1f}\")",
    "docstring": "This method takes path and two dict as argument\nand than calculates entropy of them.\n:param dict:\n:param dict:\n:return: Prints\n1) Entropy of information based on 1 alphabet\n2) Entropy of information based on couples of 2 alphabet\n3) print Entropy of H(X n|Xn-1)\n\nText from random books. Also, random quotes.\n>>> text = (\"Behind Winston's back the voice \"\n...         \"from the telescreen was still \"\n...         \"babbling and the overfulfilment\")\n>>> calculate_prob(text)\n4.0\n6.0\n2.0\n\n>>> text = (\"The Ministry of Truth\u2014Minitrue, in Newspeak [Newspeak was the official\"\n...         \"face in elegant lettering, the three\")\n>>> calculate_prob(text)\n4.0\n5.0\n1.0\n>>> text = (\"Had repulsive dashwoods suspicion sincerity but advantage now him. \"\n...         \"Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. \"\n...         \"You greatest jointure saw horrible. He private he on be imagine \"\n...         \"suppose. Fertile beloved evident through no service elderly is. Blind \"\n...         \"there if every no so at. Own neglected you preferred way sincerity \"\n...         \"delivered his attempted. To of message cottage windows do besides \"\n...         \"against uncivil.  Delightful unreserved impossible few estimating \"\n...         \"men favourable see entreaties. She propriety immediate was improving. \"\n...         \"He or entrance humoured likewise moderate. Much nor game son say \"\n...         \"feel. Fat make met can must form into gate. Me we offending prevailed \"\n...         \"discovery.\")\n>>> calculate_prob(text)\n4.0\n7.0\n3.0"
  },
  {
    "function": "analyze_text",
    "code": "def analyze_text(text: str) -> tuple[dict, dict]:\n    \"\"\"\n    Convert text input into two dicts of counts.\n    The first dictionary stores the frequency of single character strings.\n    The second dictionary stores the frequency of two character strings.\n    \"\"\"\n    single_char_strings = Counter()  # type: ignore[var-annotated]\n    two_char_strings = Counter()  # type: ignore[var-annotated]\n    single_char_strings[text[-1]] += 1\n\n    # first case when we have space at start.\n    two_char_strings[\" \" + text[0]] += 1\n    for i in range(len(text) - 1):\n        single_char_strings[text[i]] += 1\n        two_char_strings[text[i : i + 2]] += 1\n    return single_char_strings, two_char_strings",
    "docstring": "Convert text input into two dicts of counts.\nThe first dictionary stores the frequency of single character strings.\nThe second dictionary stores the frequency of two character strings."
  },
  {
    "function": "euclidean_distance",
    "code": "def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:\n    \"\"\"\n    Calculate the distance between the two endpoints of two vectors.\n    A vector is defined as a list, tuple, or numpy 1D array.\n    >>> float(euclidean_distance((0, 0), (2, 2)))\n    2.8284271247461903\n    >>> float(euclidean_distance(np.array([0, 0, 0]), np.array([2, 2, 2])))\n    3.4641016151377544\n    >>> float(euclidean_distance(np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8])))\n    8.0\n    >>> float(euclidean_distance([1, 2, 3, 4], [5, 6, 7, 8]))\n    8.0\n    \"\"\"\n    return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))",
    "docstring": "Calculate the distance between the two endpoints of two vectors.\nA vector is defined as a list, tuple, or numpy 1D array.\n>>> float(euclidean_distance((0, 0), (2, 2)))\n2.8284271247461903\n>>> float(euclidean_distance(np.array([0, 0, 0]), np.array([2, 2, 2])))\n3.4641016151377544\n>>> float(euclidean_distance(np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8])))\n8.0\n>>> float(euclidean_distance([1, 2, 3, 4], [5, 6, 7, 8]))\n8.0"
  },
  {
    "function": "euclidean_distance_no_np",
    "code": "def euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:\n    \"\"\"\n    Calculate the distance between the two endpoints of two vectors without numpy.\n    A vector is defined as a list, tuple, or numpy 1D array.\n    >>> euclidean_distance_no_np((0, 0), (2, 2))\n    2.8284271247461903\n    >>> euclidean_distance_no_np([1, 2, 3, 4], [5, 6, 7, 8])\n    8.0\n    \"\"\"\n    return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)",
    "docstring": "Calculate the distance between the two endpoints of two vectors without numpy.\nA vector is defined as a list, tuple, or numpy 1D array.\n>>> euclidean_distance_no_np((0, 0), (2, 2))\n2.8284271247461903\n>>> euclidean_distance_no_np([1, 2, 3, 4], [5, 6, 7, 8])\n8.0"
  },
  {
    "function": "totient",
    "code": "def totient(n: int) -> list:\n    \"\"\"\n    >>> n = 10\n    >>> totient_calculation = totient(n)\n    >>> for i in range(1, n):\n    ...     print(f\"{i} has {totient_calculation[i]} relative primes.\")\n    1 has 0 relative primes.\n    2 has 1 relative primes.\n    3 has 2 relative primes.\n    4 has 2 relative primes.\n    5 has 4 relative primes.\n    6 has 2 relative primes.\n    7 has 6 relative primes.\n    8 has 4 relative primes.\n    9 has 6 relative primes.\n    \"\"\"\n    is_prime = [True for i in range(n + 1)]\n    totients = [i - 1 for i in range(n + 1)]\n    primes = []\n    for i in range(2, n + 1):\n        if is_prime[i]:\n            primes.append(i)\n        for j in range(len(primes)):\n            if i * primes[j] >= n:\n                break\n            is_prime[i * primes[j]] = False\n\n            if i % primes[j] == 0:\n                totients[i * primes[j]] = totients[i] * primes[j]\n                break\n\n            totients[i * primes[j]] = totients[i] * (primes[j] - 1)\n\n    return totients",
    "docstring": ">>> n = 10\n>>> totient_calculation = totient(n)\n>>> for i in range(1, n):\n...     print(f\"{i} has {totient_calculation[i]} relative primes.\")\n1 has 0 relative primes.\n2 has 1 relative primes.\n3 has 2 relative primes.\n4 has 2 relative primes.\n5 has 4 relative primes.\n6 has 2 relative primes.\n7 has 6 relative primes.\n8 has 4 relative primes.\n9 has 6 relative primes."
  },
  {
    "function": "explicit_euler",
    "code": "def explicit_euler(\n    ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float\n) -> np.ndarray:\n    \"\"\"Calculate numeric solution at each step to an ODE using Euler's Method\n\n    For reference to Euler's method refer to https://en.wikipedia.org/wiki/Euler_method.\n\n    Args:\n        ode_func (Callable):  The ordinary differential equation\n            as a function of x and y.\n        y0 (float): The initial value for y.\n        x0 (float): The initial value for x.\n        step_size (float): The increment value for x.\n        x_end (float): The final value of x to be calculated.\n\n    Returns:\n        np.ndarray: Solution of y for every step in x.\n\n    >>> # the exact solution is math.exp(x)\n    >>> def f(x, y):\n    ...     return y\n    >>> y0 = 1\n    >>> y = explicit_euler(f, y0, 0.0, 0.01, 5)\n    >>> float(y[-1])\n    144.77277243257308\n    \"\"\"\n    n = int(np.ceil((x_end - x0) / step_size))\n    y = np.zeros((n + 1,))\n    y[0] = y0\n    x = x0\n\n    for k in range(n):\n        y[k + 1] = y[k] + step_size * ode_func(x, y[k])\n        x += step_size\n\n    return y",
    "docstring": "Calculate numeric solution at each step to an ODE using Euler's Method\n\nFor reference to Euler's method refer to https://en.wikipedia.org/wiki/Euler_method.\n\nArgs:\n    ode_func (Callable):  The ordinary differential equation\n        as a function of x and y.\n    y0 (float): The initial value for y.\n    x0 (float): The initial value for x.\n    step_size (float): The increment value for x.\n    x_end (float): The final value of x to be calculated.\n\nReturns:\n    np.ndarray: Solution of y for every step in x.\n\n>>> # the exact solution is math.exp(x)\n>>> def f(x, y):\n...     return y\n>>> y0 = 1\n>>> y = explicit_euler(f, y0, 0.0, 0.01, 5)\n>>> float(y[-1])\n144.77277243257308"
  },
  {
    "function": "euler_modified",
    "code": "def euler_modified(\n    ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float\n) -> np.ndarray:\n    \"\"\"\n    Calculate solution at each step to an ODE using Euler's Modified Method\n    The Euler Method is straightforward to implement, but can't give accurate solutions.\n    So, some changes were proposed to improve accuracy.\n\n    https://en.wikipedia.org/wiki/Euler_method\n\n    Arguments:\n    ode_func -- The ode as a function of x and y\n    y0 -- the initial value for y\n    x0 -- the initial value for x\n    stepsize -- the increment value for x\n    x_end -- the end value for x\n\n    >>> # the exact solution is math.exp(x)\n    >>> def f1(x, y):\n    ...     return -2*x*(y**2)\n    >>> y = euler_modified(f1, 1.0, 0.0, 0.2, 1.0)\n    >>> float(y[-1])\n    0.503338255442106\n    >>> import math\n    >>> def f2(x, y):\n    ...     return -2*y + (x**3)*math.exp(-2*x)\n    >>> y = euler_modified(f2, 1.0, 0.0, 0.1, 0.3)\n    >>> float(y[-1])\n    0.5525976431951775\n    \"\"\"\n    n = int(np.ceil((x_end - x0) / step_size))\n    y = np.zeros((n + 1,))\n    y[0] = y0\n    x = x0\n\n    for k in range(n):\n        y_get = y[k] + step_size * ode_func(x, y[k])\n        y[k + 1] = y[k] + (\n            (step_size / 2) * (ode_func(x, y[k]) + ode_func(x + step_size, y_get))\n        )\n        x += step_size\n\n    return y",
    "docstring": "Calculate solution at each step to an ODE using Euler's Modified Method\nThe Euler Method is straightforward to implement, but can't give accurate solutions.\nSo, some changes were proposed to improve accuracy.\n\nhttps://en.wikipedia.org/wiki/Euler_method\n\nArguments:\node_func -- The ode as a function of x and y\ny0 -- the initial value for y\nx0 -- the initial value for x\nstepsize -- the increment value for x\nx_end -- the end value for x\n\n>>> # the exact solution is math.exp(x)\n>>> def f1(x, y):\n...     return -2*x*(y**2)\n>>> y = euler_modified(f1, 1.0, 0.0, 0.2, 1.0)\n>>> float(y[-1])\n0.503338255442106\n>>> import math\n>>> def f2(x, y):\n...     return -2*y + (x**3)*math.exp(-2*x)\n>>> y = euler_modified(f2, 1.0, 0.0, 0.1, 0.3)\n>>> float(y[-1])\n0.5525976431951775"
  },
  {
    "function": "extended_euclidean_algorithm",
    "code": "def extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b",
    "docstring": "Extended Euclidean Algorithm.\n\nFinds 2 numbers a and b such that it satisfies\nthe equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n>>> extended_euclidean_algorithm(1, 24)\n(1, 0)\n\n>>> extended_euclidean_algorithm(8, 14)\n(2, -1)\n\n>>> extended_euclidean_algorithm(240, 46)\n(-9, 47)\n\n>>> extended_euclidean_algorithm(1, -4)\n(1, 0)\n\n>>> extended_euclidean_algorithm(-2, -4)\n(-1, 0)\n\n>>> extended_euclidean_algorithm(0, -4)\n(0, -1)\n\n>>> extended_euclidean_algorithm(2, 0)\n(1, 0)"
  },
  {
    "function": "main",
    "code": "def main():\n    \"\"\"Call Extended Euclidean Algorithm.\"\"\"\n    if len(sys.argv) < 3:\n        print(\"2 integer arguments required\")\n        return 1\n    a = int(sys.argv[1])\n    b = int(sys.argv[2])\n    print(extended_euclidean_algorithm(a, b))\n    return 0",
    "docstring": "Call Extended Euclidean Algorithm."
  },
  {
    "function": "factorial",
    "code": "def factorial(number: int) -> int:\n    \"\"\"\n    Calculate the factorial of specified number (n!).\n\n    >>> import math\n    >>> all(factorial(i) == math.factorial(i) for i in range(20))\n    True\n    >>> factorial(0.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() only accepts integral values\n    >>> factorial(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() not defined for negative values\n    >>> factorial(1)\n    1\n    >>> factorial(6)\n    720\n    >>> factorial(0)\n    1\n    \"\"\"\n    if number != int(number):\n        raise ValueError(\"factorial() only accepts integral values\")\n    if number < 0:\n        raise ValueError(\"factorial() not defined for negative values\")\n    value = 1\n    for i in range(1, number + 1):\n        value *= i\n    return value",
    "docstring": "Calculate the factorial of specified number (n!).\n\n>>> import math\n>>> all(factorial(i) == math.factorial(i) for i in range(20))\nTrue\n>>> factorial(0.1)\nTraceback (most recent call last):\n    ...\nValueError: factorial() only accepts integral values\n>>> factorial(-1)\nTraceback (most recent call last):\n    ...\nValueError: factorial() not defined for negative values\n>>> factorial(1)\n1\n>>> factorial(6)\n720\n>>> factorial(0)\n1"
  },
  {
    "function": "factorial_recursive",
    "code": "def factorial_recursive(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a positive integer\n    https://en.wikipedia.org/wiki/Factorial\n\n    >>> import math\n    >>> all(factorial(i) == math.factorial(i) for i in range(20))\n    True\n    >>> factorial(0.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() only accepts integral values\n    >>> factorial(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() not defined for negative values\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"factorial() only accepts integral values\")\n    if n < 0:\n        raise ValueError(\"factorial() not defined for negative values\")\n    return 1 if n in {0, 1} else n * factorial_recursive(n - 1)",
    "docstring": "Calculate the factorial of a positive integer\nhttps://en.wikipedia.org/wiki/Factorial\n\n>>> import math\n>>> all(factorial(i) == math.factorial(i) for i in range(20))\nTrue\n>>> factorial(0.1)\nTraceback (most recent call last):\n    ...\nValueError: factorial() only accepts integral values\n>>> factorial(-1)\nTraceback (most recent call last):\n    ...\nValueError: factorial() not defined for negative values"
  },
  {
    "function": "factors_of_a_number",
    "code": "def factors_of_a_number(num: int) -> list:\n    \"\"\"\n    >>> factors_of_a_number(1)\n    [1]\n    >>> factors_of_a_number(5)\n    [1, 5]\n    >>> factors_of_a_number(24)\n    [1, 2, 3, 4, 6, 8, 12, 24]\n    >>> factors_of_a_number(-24)\n    []\n    \"\"\"\n    facs: list[int] = []\n    if num < 1:\n        return facs\n    facs.append(1)\n    if num == 1:\n        return facs\n    facs.append(num)\n    for i in range(2, int(sqrt(num)) + 1):\n        if num % i == 0:  # If i is a factor of num\n            facs.append(i)\n            d = num // i  # num//i is the other factor of num\n            if d != i:  # If d and i are distinct\n                facs.append(d)  # we have found another factor\n    facs.sort()\n    return facs",
    "docstring": ">>> factors_of_a_number(1)\n[1]\n>>> factors_of_a_number(5)\n[1, 5]\n>>> factors_of_a_number(24)\n[1, 2, 3, 4, 6, 8, 12, 24]\n>>> factors_of_a_number(-24)\n[]"
  },
  {
    "function": "fast_inverse_sqrt",
    "code": "def fast_inverse_sqrt(number: float) -> float:\n    \"\"\"\n    Compute the fast inverse square root of a floating-point number using the famous\n    Quake III algorithm.\n\n    :param float number: Input number for which to calculate the inverse square root.\n    :return float: The fast inverse square root of the input number.\n\n    Example:\n    >>> fast_inverse_sqrt(10)\n    0.3156857923527257\n    >>> fast_inverse_sqrt(4)\n    0.49915357479239103\n    >>> fast_inverse_sqrt(4.1)\n    0.4932849504615651\n    >>> fast_inverse_sqrt(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive number.\n    >>> fast_inverse_sqrt(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive number.\n    >>> from math import isclose, sqrt\n    >>> all(isclose(fast_inverse_sqrt(i), 1 / sqrt(i), rel_tol=0.00132)\n    ...     for i in range(50, 60))\n    True\n    \"\"\"\n    if number <= 0:\n        raise ValueError(\"Input must be a positive number.\")\n    i = struct.unpack(\">i\", struct.pack(\">f\", number))[0]\n    i = 0x5F3759DF - (i >> 1)\n    y = struct.unpack(\">f\", struct.pack(\">i\", i))[0]\n    return y * (1.5 - 0.5 * number * y * y)",
    "docstring": "Compute the fast inverse square root of a floating-point number using the famous\nQuake III algorithm.\n\n:param float number: Input number for which to calculate the inverse square root.\n:return float: The fast inverse square root of the input number.\n\nExample:\n>>> fast_inverse_sqrt(10)\n0.3156857923527257\n>>> fast_inverse_sqrt(4)\n0.49915357479239103\n>>> fast_inverse_sqrt(4.1)\n0.4932849504615651\n>>> fast_inverse_sqrt(0)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a positive number.\n>>> fast_inverse_sqrt(-1)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a positive number.\n>>> from math import isclose, sqrt\n>>> all(isclose(fast_inverse_sqrt(i), 1 / sqrt(i), rel_tol=0.00132)\n...     for i in range(50, 60))\nTrue"
  },
  {
    "function": "time_func",
    "code": "def time_func(func, *args, **kwargs):\n    \"\"\"\n    Times the execution of a function with parameters\n    \"\"\"\n    start = time()\n    output = func(*args, **kwargs)\n    end = time()\n    if int(end - start) > 0:\n        print(f\"{func.__name__} runtime: {(end - start):0.4f} s\")\n    else:\n        print(f\"{func.__name__} runtime: {(end - start) * 1000:0.4f} ms\")\n    return output",
    "docstring": "Times the execution of a function with parameters"
  },
  {
    "function": "fib_iterative_yield",
    "code": "def fib_iterative_yield(n: int) -> Iterator[int]:\n    \"\"\"\n    Calculates the first n (1-indexed) Fibonacci numbers using iteration with yield\n    >>> list(fib_iterative_yield(0))\n    [0]\n    >>> tuple(fib_iterative_yield(1))\n    (0, 1)\n    >>> tuple(fib_iterative_yield(5))\n    (0, 1, 1, 2, 3, 5)\n    >>> tuple(fib_iterative_yield(10))\n    (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)\n    >>> tuple(fib_iterative_yield(-1))\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    a, b = 0, 1\n    yield a\n    for _ in range(n):\n        yield b\n        a, b = b, a + b",
    "docstring": "Calculates the first n (1-indexed) Fibonacci numbers using iteration with yield\n>>> list(fib_iterative_yield(0))\n[0]\n>>> tuple(fib_iterative_yield(1))\n(0, 1)\n>>> tuple(fib_iterative_yield(5))\n(0, 1, 1, 2, 3, 5)\n>>> tuple(fib_iterative_yield(10))\n(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)\n>>> tuple(fib_iterative_yield(-1))\nTraceback (most recent call last):\n    ...\nValueError: n is negative"
  },
  {
    "function": "fib_iterative",
    "code": "def fib_iterative(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using iteration\n    >>> fib_iterative(0)\n    [0]\n    >>> fib_iterative(1)\n    [0, 1]\n    >>> fib_iterative(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_iterative(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    if n == 0:\n        return [0]\n    fib = [0, 1]\n    for _ in range(n - 1):\n        fib.append(fib[-1] + fib[-2])\n    return fib",
    "docstring": "Calculates the first n (0-indexed) Fibonacci numbers using iteration\n>>> fib_iterative(0)\n[0]\n>>> fib_iterative(1)\n[0, 1]\n>>> fib_iterative(5)\n[0, 1, 1, 2, 3, 5]\n>>> fib_iterative(10)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> fib_iterative(-1)\nTraceback (most recent call last):\n    ...\nValueError: n is negative"
  },
  {
    "function": "fib_recursive",
    "code": "def fib_recursive(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using recursion\n    >>> fib_iterative(0)\n    [0]\n    >>> fib_iterative(1)\n    [0, 1]\n    >>> fib_iterative(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_iterative(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n\n    def fib_recursive_term(i: int) -> int:\n        \"\"\"\n        Calculates the i-th (0-indexed) Fibonacci number using recursion\n        >>> fib_recursive_term(0)\n        0\n        >>> fib_recursive_term(1)\n        1\n        >>> fib_recursive_term(5)\n        5\n        >>> fib_recursive_term(10)\n        55\n        >>> fib_recursive_term(-1)\n        Traceback (most recent call last):\n            ...\n        Exception: n is negative\n        \"\"\"\n        if i < 0:\n            raise ValueError(\"n is negative\")\n        if i < 2:\n            return i\n        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)\n\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    return [fib_recursive_term(i) for i in range(n + 1)]",
    "docstring": "Calculates the first n (0-indexed) Fibonacci numbers using recursion\n>>> fib_iterative(0)\n[0]\n>>> fib_iterative(1)\n[0, 1]\n>>> fib_iterative(5)\n[0, 1, 1, 2, 3, 5]\n>>> fib_iterative(10)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> fib_iterative(-1)\nTraceback (most recent call last):\n    ...\nValueError: n is negative"
  },
  {
    "function": "fib_recursive_cached",
    "code": "def fib_recursive_cached(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using recursion\n    >>> fib_iterative(0)\n    [0]\n    >>> fib_iterative(1)\n    [0, 1]\n    >>> fib_iterative(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_iterative(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n\n    @functools.cache\n    def fib_recursive_term(i: int) -> int:\n        \"\"\"\n        Calculates the i-th (0-indexed) Fibonacci number using recursion\n        \"\"\"\n        if i < 0:\n            raise ValueError(\"n is negative\")\n        if i < 2:\n            return i\n        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)\n\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    return [fib_recursive_term(i) for i in range(n + 1)]",
    "docstring": "Calculates the first n (0-indexed) Fibonacci numbers using recursion\n>>> fib_iterative(0)\n[0]\n>>> fib_iterative(1)\n[0, 1]\n>>> fib_iterative(5)\n[0, 1, 1, 2, 3, 5]\n>>> fib_iterative(10)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> fib_iterative(-1)\nTraceback (most recent call last):\n    ...\nValueError: n is negative"
  },
  {
    "function": "fib_memoization",
    "code": "def fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]",
    "docstring": "Calculates the first n (0-indexed) Fibonacci numbers using memoization\n>>> fib_memoization(0)\n[0]\n>>> fib_memoization(1)\n[0, 1]\n>>> fib_memoization(5)\n[0, 1, 1, 2, 3, 5]\n>>> fib_memoization(10)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> fib_iterative(-1)\nTraceback (most recent call last):\n    ...\nValueError: n is negative"
  },
  {
    "function": "fib_binet",
    "code": "def fib_binet(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using a simplified form\n    of Binet's formula:\n    https://en.m.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding\n\n    NOTE 1: this function diverges from fib_iterative at around n = 71, likely\n    due to compounding floating-point arithmetic errors\n\n    NOTE 2: this function doesn't accept n >= 1475 because it overflows\n    thereafter due to the size limitations of Python floats\n    >>> fib_binet(0)\n    [0]\n    >>> fib_binet(1)\n    [0, 1]\n    >>> fib_binet(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_binet(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_binet(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    >>> fib_binet(1475)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is too large\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    if n >= 1475:\n        raise ValueError(\"n is too large\")\n    sqrt_5 = sqrt(5)\n    phi = (1 + sqrt_5) / 2\n    return [round(phi**i / sqrt_5) for i in range(n + 1)]",
    "docstring": "Calculates the first n (0-indexed) Fibonacci numbers using a simplified form\nof Binet's formula:\nhttps://en.m.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding\n\nNOTE 1: this function diverges from fib_iterative at around n = 71, likely\ndue to compounding floating-point arithmetic errors\n\nNOTE 2: this function doesn't accept n >= 1475 because it overflows\nthereafter due to the size limitations of Python floats\n>>> fib_binet(0)\n[0]\n>>> fib_binet(1)\n[0, 1]\n>>> fib_binet(5)\n[0, 1, 1, 2, 3, 5]\n>>> fib_binet(10)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> fib_binet(-1)\nTraceback (most recent call last):\n    ...\nValueError: n is negative\n>>> fib_binet(1475)\nTraceback (most recent call last):\n    ...\nValueError: n is too large"
  },
  {
    "function": "matrix_pow_np",
    "code": "def matrix_pow_np(m: ndarray, power: int) -> ndarray:\n    \"\"\"\n    Raises a matrix to the power of 'power' using binary exponentiation.\n\n    Args:\n        m: Matrix as a numpy array.\n        power: The power to which the matrix is to be raised.\n\n    Returns:\n        The matrix raised to the power.\n\n    Raises:\n        ValueError: If power is negative.\n\n    >>> m = np.array([[1, 1], [1, 0]], dtype=int)\n    >>> matrix_pow_np(m, 0)  # Identity matrix when raised to the power of 0\n    array([[1, 0],\n           [0, 1]])\n\n    >>> matrix_pow_np(m, 1)  # Same matrix when raised to the power of 1\n    array([[1, 1],\n           [1, 0]])\n\n    >>> matrix_pow_np(m, 5)\n    array([[8, 5],\n           [5, 3]])\n\n    >>> matrix_pow_np(m, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: power is negative\n    \"\"\"\n    result = np.array([[1, 0], [0, 1]], dtype=int)  # Identity Matrix\n    base = m\n    if power < 0:  # Negative power is not allowed\n        raise ValueError(\"power is negative\")\n    while power:\n        if power % 2 == 1:\n            result = np.dot(result, base)\n        base = np.dot(base, base)\n        power //= 2\n    return result",
    "docstring": "Raises a matrix to the power of 'power' using binary exponentiation.\n\nArgs:\n    m: Matrix as a numpy array.\n    power: The power to which the matrix is to be raised.\n\nReturns:\n    The matrix raised to the power.\n\nRaises:\n    ValueError: If power is negative.\n\n>>> m = np.array([[1, 1], [1, 0]], dtype=int)\n>>> matrix_pow_np(m, 0)  # Identity matrix when raised to the power of 0\narray([[1, 0],\n       [0, 1]])\n\n>>> matrix_pow_np(m, 1)  # Same matrix when raised to the power of 1\narray([[1, 1],\n       [1, 0]])\n\n>>> matrix_pow_np(m, 5)\narray([[8, 5],\n       [5, 3]])\n\n>>> matrix_pow_np(m, -1)\nTraceback (most recent call last):\n    ...\nValueError: power is negative"
  },
  {
    "function": "fib_matrix_np",
    "code": "def fib_matrix_np(n: int) -> int:\n    \"\"\"\n    Calculates the n-th Fibonacci number using matrix exponentiation.\n    https://www.nayuki.io/page/fast-fibonacci-algorithms#:~:text=\n    Summary:%20The%20two%20fast%20Fibonacci%20algorithms%20are%20matrix\n\n    Args:\n        n: Fibonacci sequence index\n\n    Returns:\n        The n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is negative.\n\n    >>> fib_matrix_np(0)\n    0\n    >>> fib_matrix_np(1)\n    1\n    >>> fib_matrix_np(5)\n    5\n    >>> fib_matrix_np(10)\n    55\n    >>> fib_matrix_np(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    if n == 0:\n        return 0\n\n    m = np.array([[1, 1], [1, 0]], dtype=int)\n    result = matrix_pow_np(m, n - 1)\n    return int(result[0, 0])",
    "docstring": "Calculates the n-th Fibonacci number using matrix exponentiation.\nhttps://www.nayuki.io/page/fast-fibonacci-algorithms#:~:text=\nSummary:%20The%20two%20fast%20Fibonacci%20algorithms%20are%20matrix\n\nArgs:\n    n: Fibonacci sequence index\n\nReturns:\n    The n-th Fibonacci number.\n\nRaises:\n    ValueError: If n is negative.\n\n>>> fib_matrix_np(0)\n0\n>>> fib_matrix_np(1)\n1\n>>> fib_matrix_np(5)\n5\n>>> fib_matrix_np(10)\n55\n>>> fib_matrix_np(-1)\nTraceback (most recent call last):\n    ...\nValueError: n is negative"
  },
  {
    "function": "find_max_iterative",
    "code": "def find_max_iterative(nums: list[int | float]) -> int | float:\n    \"\"\"\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n    ...     find_max_iterative(nums) == max(nums)\n    True\n    True\n    True\n    True\n    >>> find_max_iterative([2, 4, 9, 7, 19, 94, 5])\n    94\n    >>> find_max_iterative([])\n    Traceback (most recent call last):\n        ...\n    ValueError: find_max_iterative() arg is an empty sequence\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"find_max_iterative() arg is an empty sequence\")\n    max_num = nums[0]\n    for x in nums:\n        if x > max_num:  # noqa: PLR1730\n            max_num = x\n    return max_num",
    "docstring": ">>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n...     find_max_iterative(nums) == max(nums)\nTrue\nTrue\nTrue\nTrue\n>>> find_max_iterative([2, 4, 9, 7, 19, 94, 5])\n94\n>>> find_max_iterative([])\nTraceback (most recent call last):\n    ...\nValueError: find_max_iterative() arg is an empty sequence"
  },
  {
    "function": "find_max_recursive",
    "code": "def find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:\n    \"\"\"\n    find max value in list\n    :param nums: contains elements\n    :param left: index of first element\n    :param right: index of last element\n    :return: max in nums\n\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n    ...     find_max_recursive(nums, 0, len(nums) - 1) == max(nums)\n    True\n    True\n    True\n    True\n    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n    >>> find_max_recursive(nums, 0, len(nums) - 1) == max(nums)\n    True\n    >>> find_max_recursive([], 0, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: find_max_recursive() arg is an empty sequence\n    >>> find_max_recursive(nums, 0, len(nums)) == max(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    >>> find_max_recursive(nums, -len(nums), -1) == max(nums)\n    True\n    >>> find_max_recursive(nums, -len(nums) - 1, -1) == max(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"find_max_recursive() arg is an empty sequence\")\n    if (\n        left >= len(nums)\n        or left < -len(nums)\n        or right >= len(nums)\n        or right < -len(nums)\n    ):\n        raise IndexError(\"list index out of range\")\n    if left == right:\n        return nums[left]\n    mid = (left + right) >> 1  # the middle\n    left_max = find_max_recursive(nums, left, mid)  # find max in range[left, mid]\n    right_max = find_max_recursive(\n        nums, mid + 1, right\n    )  # find max in range[mid + 1, right]\n\n    return left_max if left_max >= right_max else right_max",
    "docstring": "find max value in list\n:param nums: contains elements\n:param left: index of first element\n:param right: index of last element\n:return: max in nums\n\n>>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n...     find_max_recursive(nums, 0, len(nums) - 1) == max(nums)\nTrue\nTrue\nTrue\nTrue\n>>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n>>> find_max_recursive(nums, 0, len(nums) - 1) == max(nums)\nTrue\n>>> find_max_recursive([], 0, 0)\nTraceback (most recent call last):\n    ...\nValueError: find_max_recursive() arg is an empty sequence\n>>> find_max_recursive(nums, 0, len(nums)) == max(nums)\nTraceback (most recent call last):\n    ...\nIndexError: list index out of range\n>>> find_max_recursive(nums, -len(nums), -1) == max(nums)\nTrue\n>>> find_max_recursive(nums, -len(nums) - 1, -1) == max(nums)\nTraceback (most recent call last):\n    ...\nIndexError: list index out of range"
  },
  {
    "function": "find_min_iterative",
    "code": "def find_min_iterative(nums: list[int | float]) -> int | float:\n    \"\"\"\n    Find Minimum Number in a List\n    :param nums: contains elements\n    :return: min number in list\n\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n    ...     find_min_iterative(nums) == min(nums)\n    True\n    True\n    True\n    True\n    >>> find_min_iterative([0, 1, 2, 3, 4, 5, -3, 24, -56])\n    -56\n    >>> find_min_iterative([])\n    Traceback (most recent call last):\n        ...\n    ValueError: find_min_iterative() arg is an empty sequence\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"find_min_iterative() arg is an empty sequence\")\n    min_num = nums[0]\n    for num in nums:\n        min_num = min(min_num, num)\n    return min_num",
    "docstring": "Find Minimum Number in a List\n:param nums: contains elements\n:return: min number in list\n\n>>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n...     find_min_iterative(nums) == min(nums)\nTrue\nTrue\nTrue\nTrue\n>>> find_min_iterative([0, 1, 2, 3, 4, 5, -3, 24, -56])\n-56\n>>> find_min_iterative([])\nTraceback (most recent call last):\n    ...\nValueError: find_min_iterative() arg is an empty sequence"
  },
  {
    "function": "find_min_recursive",
    "code": "def find_min_recursive(nums: list[int | float], left: int, right: int) -> int | float:\n    \"\"\"\n    find min value in list\n    :param nums: contains elements\n    :param left: index of first element\n    :param right: index of last element\n    :return: min in nums\n\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n    ...     find_min_recursive(nums, 0, len(nums) - 1) == min(nums)\n    True\n    True\n    True\n    True\n    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n    >>> find_min_recursive(nums, 0, len(nums) - 1) == min(nums)\n    True\n    >>> find_min_recursive([], 0, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: find_min_recursive() arg is an empty sequence\n    >>> find_min_recursive(nums, 0, len(nums)) == min(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    >>> find_min_recursive(nums, -len(nums), -1) == min(nums)\n    True\n    >>> find_min_recursive(nums, -len(nums) - 1, -1) == min(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"find_min_recursive() arg is an empty sequence\")\n    if (\n        left >= len(nums)\n        or left < -len(nums)\n        or right >= len(nums)\n        or right < -len(nums)\n    ):\n        raise IndexError(\"list index out of range\")\n    if left == right:\n        return nums[left]\n    mid = (left + right) >> 1  # the middle\n    left_min = find_min_recursive(nums, left, mid)  # find min in range[left, mid]\n    right_min = find_min_recursive(\n        nums, mid + 1, right\n    )  # find min in range[mid + 1, right]\n\n    return left_min if left_min <= right_min else right_min",
    "docstring": "find min value in list\n:param nums: contains elements\n:param left: index of first element\n:param right: index of last element\n:return: min in nums\n\n>>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n...     find_min_recursive(nums, 0, len(nums) - 1) == min(nums)\nTrue\nTrue\nTrue\nTrue\n>>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n>>> find_min_recursive(nums, 0, len(nums) - 1) == min(nums)\nTrue\n>>> find_min_recursive([], 0, 0)\nTraceback (most recent call last):\n    ...\nValueError: find_min_recursive() arg is an empty sequence\n>>> find_min_recursive(nums, 0, len(nums)) == min(nums)\nTraceback (most recent call last):\n    ...\nIndexError: list index out of range\n>>> find_min_recursive(nums, -len(nums), -1) == min(nums)\nTrue\n>>> find_min_recursive(nums, -len(nums) - 1, -1) == min(nums)\nTraceback (most recent call last):\n    ...\nIndexError: list index out of range"
  },
  {
    "function": "floor",
    "code": "def floor(x: float) -> int:\n    \"\"\"\n    Return the floor of x as an Integral.\n    :param x: the number\n    :return: the largest integer <= x.\n    >>> import math\n    >>> all(floor(n) == math.floor(n) for n\n    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))\n    True\n    \"\"\"\n    return int(x) if x - int(x) >= 0 else int(x) - 1",
    "docstring": "Return the floor of x as an Integral.\n:param x: the number\n:return: the largest integer <= x.\n>>> import math\n>>> all(floor(n) == math.floor(n) for n\n...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))\nTrue"
  },
  {
    "function": "gamma_iterative",
    "code": "def gamma_iterative(num: float) -> float:\n    \"\"\"\n    Calculates the value of Gamma function of num\n    where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).\n\n    >>> gamma_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_iterative(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_iterative(9)\n    40320.0\n    >>> from math import gamma as math_gamma\n    >>> all(.99999999 < gamma_iterative(i) / math_gamma(i) <= 1.000000001\n    ...     for i in range(1, 50))\n    True\n    >>> gamma_iterative(-1)/math_gamma(-1) <= 1.000000001\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_iterative(3.3) - math_gamma(3.3) <= 0.00000001\n    True\n    \"\"\"\n    if num <= 0:\n        raise ValueError(\"math domain error\")\n\n    return quad(integrand, 0, inf, args=(num))[0]",
    "docstring": "Calculates the value of Gamma function of num\nwhere num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).\n\n>>> gamma_iterative(-1)\nTraceback (most recent call last):\n    ...\nValueError: math domain error\n>>> gamma_iterative(0)\nTraceback (most recent call last):\n    ...\nValueError: math domain error\n>>> gamma_iterative(9)\n40320.0\n>>> from math import gamma as math_gamma\n>>> all(.99999999 < gamma_iterative(i) / math_gamma(i) <= 1.000000001\n...     for i in range(1, 50))\nTrue\n>>> gamma_iterative(-1)/math_gamma(-1) <= 1.000000001\nTraceback (most recent call last):\n    ...\nValueError: math domain error\n>>> gamma_iterative(3.3) - math_gamma(3.3) <= 0.00000001\nTrue"
  },
  {
    "function": "gamma_recursive",
    "code": "def gamma_recursive(num: float) -> float:\n    \"\"\"\n    Calculates the value of Gamma function of num\n    where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).\n    Implemented using recursion\n    Examples:\n    >>> from math import isclose, gamma as math_gamma\n    >>> gamma_recursive(0.5)\n    1.7724538509055159\n    >>> gamma_recursive(1)\n    1.0\n    >>> gamma_recursive(2)\n    1.0\n    >>> gamma_recursive(3.5)\n    3.3233509704478426\n    >>> gamma_recursive(171.5)\n    9.483367566824795e+307\n    >>> all(isclose(gamma_recursive(num), math_gamma(num))\n    ...     for num in (0.5, 2, 3.5, 171.5))\n    True\n    >>> gamma_recursive(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_recursive(-1.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_recursive(-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_recursive(172)\n    Traceback (most recent call last):\n        ...\n    OverflowError: math range error\n    >>> gamma_recursive(1.1)\n    Traceback (most recent call last):\n        ...\n    NotImplementedError: num must be an integer or a half-integer\n    \"\"\"\n    if num <= 0:\n        raise ValueError(\"math domain error\")\n    if num > 171.5:\n        raise OverflowError(\"math range error\")\n    elif num - int(num) not in (0, 0.5):\n        raise NotImplementedError(\"num must be an integer or a half-integer\")\n    elif num == 0.5:\n        return math.sqrt(math.pi)\n    else:\n        return 1.0 if num == 1 else (num - 1) * gamma_recursive(num - 1)",
    "docstring": "Calculates the value of Gamma function of num\nwhere num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).\nImplemented using recursion\nExamples:\n>>> from math import isclose, gamma as math_gamma\n>>> gamma_recursive(0.5)\n1.7724538509055159\n>>> gamma_recursive(1)\n1.0\n>>> gamma_recursive(2)\n1.0\n>>> gamma_recursive(3.5)\n3.3233509704478426\n>>> gamma_recursive(171.5)\n9.483367566824795e+307\n>>> all(isclose(gamma_recursive(num), math_gamma(num))\n...     for num in (0.5, 2, 3.5, 171.5))\nTrue\n>>> gamma_recursive(0)\nTraceback (most recent call last):\n    ...\nValueError: math domain error\n>>> gamma_recursive(-1.1)\nTraceback (most recent call last):\n    ...\nValueError: math domain error\n>>> gamma_recursive(-4)\nTraceback (most recent call last):\n    ...\nValueError: math domain error\n>>> gamma_recursive(172)\nTraceback (most recent call last):\n    ...\nOverflowError: math range error\n>>> gamma_recursive(1.1)\nTraceback (most recent call last):\n    ...\nNotImplementedError: num must be an integer or a half-integer"
  },
  {
    "function": "gaussian",
    "code": "def gaussian(x, mu: float = 0.0, sigma: float = 1.0) -> float:\n    \"\"\"\n    >>> float(gaussian(1))\n    0.24197072451914337\n\n    >>> float(gaussian(24))\n    3.342714441794458e-126\n\n    >>> float(gaussian(1, 4, 2))\n    0.06475879783294587\n\n    >>> float(gaussian(1, 5, 3))\n    0.05467002489199788\n\n    Supports NumPy Arrays\n    Use numpy.meshgrid with this to generate gaussian blur on images.\n    >>> import numpy as np\n    >>> x = np.arange(15)\n    >>> gaussian(x)\n    array([3.98942280e-01, 2.41970725e-01, 5.39909665e-02, 4.43184841e-03,\n           1.33830226e-04, 1.48671951e-06, 6.07588285e-09, 9.13472041e-12,\n           5.05227108e-15, 1.02797736e-18, 7.69459863e-23, 2.11881925e-27,\n           2.14638374e-32, 7.99882776e-38, 1.09660656e-43])\n\n    >>> float(gaussian(15))\n    5.530709549844416e-50\n\n    >>> gaussian([1,2, 'string'])\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'list' and 'float'\n\n    >>> gaussian('hello world')\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'str' and 'float'\n\n    >>> gaussian(10**234) # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n        ...\n    OverflowError: (34, 'Result too large')\n\n    >>> float(gaussian(10**-326))\n    0.3989422804014327\n\n    >>> float(gaussian(2523, mu=234234, sigma=3425))\n    0.0\n    \"\"\"\n    return 1 / sqrt(2 * pi * sigma**2) * exp(-((x - mu) ** 2) / (2 * sigma**2))",
    "docstring": ">>> float(gaussian(1))\n0.24197072451914337\n\n>>> float(gaussian(24))\n3.342714441794458e-126\n\n>>> float(gaussian(1, 4, 2))\n0.06475879783294587\n\n>>> float(gaussian(1, 5, 3))\n0.05467002489199788\n\nSupports NumPy Arrays\nUse numpy.meshgrid with this to generate gaussian blur on images.\n>>> import numpy as np\n>>> x = np.arange(15)\n>>> gaussian(x)\narray([3.98942280e-01, 2.41970725e-01, 5.39909665e-02, 4.43184841e-03,\n       1.33830226e-04, 1.48671951e-06, 6.07588285e-09, 9.13472041e-12,\n       5.05227108e-15, 1.02797736e-18, 7.69459863e-23, 2.11881925e-27,\n       2.14638374e-32, 7.99882776e-38, 1.09660656e-43])\n\n>>> float(gaussian(15))\n5.530709549844416e-50\n\n>>> gaussian([1,2, 'string'])\nTraceback (most recent call last):\n    ...\nTypeError: unsupported operand type(s) for -: 'list' and 'float'\n\n>>> gaussian('hello world')\nTraceback (most recent call last):\n    ...\nTypeError: unsupported operand type(s) for -: 'str' and 'float'\n\n>>> gaussian(10**234) # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n    ...\nOverflowError: (34, 'Result too large')\n\n>>> float(gaussian(10**-326))\n0.3989422804014327\n\n>>> float(gaussian(2523, mu=234234, sigma=3425))\n0.0"
  },
  {
    "function": "get_factors",
    "code": "def get_factors(\n    number: int, factors: Counter | None = None, factor: int = 2\n) -> Counter:\n    \"\"\"\n    this is a recursive function for get all factors of number\n    >>> get_factors(45)\n    Counter({3: 2, 5: 1})\n    >>> get_factors(2520)\n    Counter({2: 3, 3: 2, 5: 1, 7: 1})\n    >>> get_factors(23)\n    Counter({23: 1})\n    >>> get_factors(0)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be integer and greater than zero\n    >>> get_factors(-1)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be integer and greater than zero\n    >>> get_factors(1.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be integer and greater than zero\n\n    factor can be all numbers from 2 to number that we check if number % factor == 0\n    if it is equal to zero, we check again with number // factor\n    else we increase factor by one\n    \"\"\"\n\n    match number:\n        case int(number) if number == 1:\n            return Counter({1: 1})\n        case int(num) if number > 0:\n            number = num\n        case _:\n            raise TypeError(\"number must be integer and greater than zero\")\n\n    factors = factors or Counter()\n\n    if number == factor:  # break condition\n        # all numbers are factors of itself\n        factors[factor] += 1\n        return factors\n\n    if number % factor > 0:\n        # if it is greater than zero\n        # so it is not a factor of number and we check next number\n        return get_factors(number, factors, factor + 1)\n\n    factors[factor] += 1\n    # else we update factors (that is Counter(dict-like) type) and check again\n    return get_factors(number // factor, factors, factor)",
    "docstring": "this is a recursive function for get all factors of number\n>>> get_factors(45)\nCounter({3: 2, 5: 1})\n>>> get_factors(2520)\nCounter({2: 3, 3: 2, 5: 1, 7: 1})\n>>> get_factors(23)\nCounter({23: 1})\n>>> get_factors(0)\nTraceback (most recent call last):\n    ...\nTypeError: number must be integer and greater than zero\n>>> get_factors(-1)\nTraceback (most recent call last):\n    ...\nTypeError: number must be integer and greater than zero\n>>> get_factors(1.5)\nTraceback (most recent call last):\n    ...\nTypeError: number must be integer and greater than zero\n\nfactor can be all numbers from 2 to number that we check if number % factor == 0\nif it is equal to zero, we check again with number // factor\nelse we increase factor by one"
  },
  {
    "function": "get_greatest_common_divisor",
    "code": "def get_greatest_common_divisor(*numbers: int) -> int:\n    \"\"\"\n    get gcd of n numbers:\n    >>> get_greatest_common_divisor(18, 45)\n    9\n    >>> get_greatest_common_divisor(23, 37)\n    1\n    >>> get_greatest_common_divisor(2520, 8350)\n    10\n    >>> get_greatest_common_divisor(-10, 20)\n    Traceback (most recent call last):\n        ...\n    Exception: numbers must be integer and greater than zero\n    >>> get_greatest_common_divisor(1.5, 2)\n    Traceback (most recent call last):\n        ...\n    Exception: numbers must be integer and greater than zero\n    >>> get_greatest_common_divisor(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    1\n    >>> get_greatest_common_divisor(\"1\", 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    Traceback (most recent call last):\n        ...\n    Exception: numbers must be integer and greater than zero\n    \"\"\"\n\n    # we just need factors, not numbers itself\n    try:\n        same_factors, *factors = map(get_factors, numbers)\n    except TypeError as e:\n        raise Exception(\"numbers must be integer and greater than zero\") from e\n\n    for factor in factors:\n        same_factors &= factor\n        # get common factor between all\n        # `&` return common elements with smaller value (for Counter type)\n\n    # now, same_factors is something like {2: 2, 3: 4} that means 2 * 2 * 3 * 3 * 3 * 3\n    mult = 1\n    # power each factor and multiply\n    # for {2: 2, 3: 4}, it is [4, 81] and then 324\n    for m in [factor**power for factor, power in same_factors.items()]:\n        mult *= m\n    return mult",
    "docstring": "get gcd of n numbers:\n>>> get_greatest_common_divisor(18, 45)\n9\n>>> get_greatest_common_divisor(23, 37)\n1\n>>> get_greatest_common_divisor(2520, 8350)\n10\n>>> get_greatest_common_divisor(-10, 20)\nTraceback (most recent call last):\n    ...\nException: numbers must be integer and greater than zero\n>>> get_greatest_common_divisor(1.5, 2)\nTraceback (most recent call last):\n    ...\nException: numbers must be integer and greater than zero\n>>> get_greatest_common_divisor(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n1\n>>> get_greatest_common_divisor(\"1\", 2, 3, 4, 5, 6, 7, 8, 9, 10)\nTraceback (most recent call last):\n    ...\nException: numbers must be integer and greater than zero"
  },
  {
    "function": "compute_geometric_mean",
    "code": "def compute_geometric_mean(*args: int) -> float:\n    \"\"\"\n    Return the geometric mean of the argument numbers.\n    >>> compute_geometric_mean(2,8)\n    4.0\n    >>> compute_geometric_mean('a', 4)\n    Traceback (most recent call last):\n        ...\n    TypeError: Not a Number\n    >>> compute_geometric_mean(5, 125)\n    25.0\n    >>> compute_geometric_mean(1, 0)\n    0.0\n    >>> compute_geometric_mean(1, 5, 25, 5)\n    5.0\n    >>> compute_geometric_mean(2, -2)\n    Traceback (most recent call last):\n        ...\n    ArithmeticError: Cannot Compute Geometric Mean for these numbers.\n    >>> compute_geometric_mean(-5, 25, 1)\n    -5.0\n    \"\"\"\n    product = 1\n    for number in args:\n        if not isinstance(number, int) and not isinstance(number, float):\n            raise TypeError(\"Not a Number\")\n        product *= number\n    # Cannot calculate the even root for negative product.\n    # Frequently they are restricted to being positive.\n    if product < 0 and len(args) % 2 == 0:\n        raise ArithmeticError(\"Cannot Compute Geometric Mean for these numbers.\")\n    mean = abs(product) ** (1 / len(args))\n    # Since python calculates complex roots for negative products with odd roots.\n    if product < 0:\n        mean = -mean\n    # Since it does floating point arithmetic, it gives 64**(1/3) as 3.99999996\n    possible_mean = float(round(mean))\n    # To check if the rounded number is actually the mean.\n    if possible_mean ** len(args) == product:\n        mean = possible_mean\n    return mean",
    "docstring": "Return the geometric mean of the argument numbers.\n>>> compute_geometric_mean(2,8)\n4.0\n>>> compute_geometric_mean('a', 4)\nTraceback (most recent call last):\n    ...\nTypeError: Not a Number\n>>> compute_geometric_mean(5, 125)\n25.0\n>>> compute_geometric_mean(1, 0)\n0.0\n>>> compute_geometric_mean(1, 5, 25, 5)\n5.0\n>>> compute_geometric_mean(2, -2)\nTraceback (most recent call last):\n    ...\nArithmeticError: Cannot Compute Geometric Mean for these numbers.\n>>> compute_geometric_mean(-5, 25, 1)\n-5.0"
  },
  {
    "function": "is_germain_prime",
    "code": "def is_germain_prime(number: int) -> bool:\n    \"\"\"Checks if input number and 2*number + 1 are prime.\n\n    >>> is_germain_prime(3)\n    True\n    >>> is_germain_prime(11)\n    True\n    >>> is_germain_prime(4)\n    False\n    >>> is_germain_prime(23)\n    True\n    >>> is_germain_prime(13)\n    False\n    >>> is_germain_prime(20)\n    False\n    >>> is_germain_prime('abc')\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a positive integer. Input value: abc\n    \"\"\"\n    if not isinstance(number, int) or number < 1:\n        msg = f\"Input value must be a positive integer. Input value: {number}\"\n        raise TypeError(msg)\n\n    return is_prime(number) and is_prime(2 * number + 1)",
    "docstring": "Checks if input number and 2*number + 1 are prime.\n\n>>> is_germain_prime(3)\nTrue\n>>> is_germain_prime(11)\nTrue\n>>> is_germain_prime(4)\nFalse\n>>> is_germain_prime(23)\nTrue\n>>> is_germain_prime(13)\nFalse\n>>> is_germain_prime(20)\nFalse\n>>> is_germain_prime('abc')\nTraceback (most recent call last):\n    ...\nTypeError: Input value must be a positive integer. Input value: abc"
  },
  {
    "function": "is_safe_prime",
    "code": "def is_safe_prime(number: int) -> bool:\n    \"\"\"Checks if input number and (number - 1)/2 are prime.\n    The smallest safe prime is 5, with the Germain prime is 2.\n\n    >>> is_safe_prime(5)\n    True\n    >>> is_safe_prime(11)\n    True\n    >>> is_safe_prime(1)\n    False\n    >>> is_safe_prime(2)\n    False\n    >>> is_safe_prime(3)\n    False\n    >>> is_safe_prime(47)\n    True\n    >>> is_safe_prime('abc')\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a positive integer. Input value: abc\n    \"\"\"\n    if not isinstance(number, int) or number < 1:\n        msg = f\"Input value must be a positive integer. Input value: {number}\"\n        raise TypeError(msg)\n\n    return (number - 1) % 2 == 0 and is_prime(number) and is_prime((number - 1) // 2)",
    "docstring": "Checks if input number and (number - 1)/2 are prime.\nThe smallest safe prime is 5, with the Germain prime is 2.\n\n>>> is_safe_prime(5)\nTrue\n>>> is_safe_prime(11)\nTrue\n>>> is_safe_prime(1)\nFalse\n>>> is_safe_prime(2)\nFalse\n>>> is_safe_prime(3)\nFalse\n>>> is_safe_prime(47)\nTrue\n>>> is_safe_prime('abc')\nTraceback (most recent call last):\n    ...\nTypeError: Input value must be a positive integer. Input value: abc"
  },
  {
    "function": "greatest_common_divisor",
    "code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Calculate Greatest Common Divisor (GCD).\n    >>> greatest_common_divisor(24, 40)\n    8\n    >>> greatest_common_divisor(1, 1)\n    1\n    >>> greatest_common_divisor(1, 800)\n    1\n    >>> greatest_common_divisor(11, 37)\n    1\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(16, 4)\n    4\n    >>> greatest_common_divisor(-3, 9)\n    3\n    >>> greatest_common_divisor(9, -3)\n    3\n    >>> greatest_common_divisor(3, -9)\n    3\n    >>> greatest_common_divisor(-3, -9)\n    3\n    \"\"\"\n    return abs(b) if a == 0 else greatest_common_divisor(b % a, a)",
    "docstring": "Calculate Greatest Common Divisor (GCD).\n>>> greatest_common_divisor(24, 40)\n8\n>>> greatest_common_divisor(1, 1)\n1\n>>> greatest_common_divisor(1, 800)\n1\n>>> greatest_common_divisor(11, 37)\n1\n>>> greatest_common_divisor(3, 5)\n1\n>>> greatest_common_divisor(16, 4)\n4\n>>> greatest_common_divisor(-3, 9)\n3\n>>> greatest_common_divisor(9, -3)\n3\n>>> greatest_common_divisor(3, -9)\n3\n>>> greatest_common_divisor(-3, -9)\n3"
  },
  {
    "function": "gcd_by_iterative",
    "code": "def gcd_by_iterative(x: int, y: int) -> int:\n    \"\"\"\n    Below method is more memory efficient because it does not create additional\n    stack frames for recursive functions calls (as done in the above method).\n    >>> gcd_by_iterative(24, 40)\n    8\n    >>> greatest_common_divisor(24, 40) == gcd_by_iterative(24, 40)\n    True\n    >>> gcd_by_iterative(-3, -9)\n    3\n    >>> gcd_by_iterative(3, -9)\n    3\n    >>> gcd_by_iterative(1, -800)\n    1\n    >>> gcd_by_iterative(11, 37)\n    1\n    \"\"\"\n    while y:  # --> when y=0 then loop will terminate and return x as final GCD.\n        x, y = y, x % y\n    return abs(x)",
    "docstring": "Below method is more memory efficient because it does not create additional\nstack frames for recursive functions calls (as done in the above method).\n>>> gcd_by_iterative(24, 40)\n8\n>>> greatest_common_divisor(24, 40) == gcd_by_iterative(24, 40)\nTrue\n>>> gcd_by_iterative(-3, -9)\n3\n>>> gcd_by_iterative(3, -9)\n3\n>>> gcd_by_iterative(1, -800)\n1\n>>> gcd_by_iterative(11, 37)\n1"
  },
  {
    "function": "main",
    "code": "def main():\n    \"\"\"\n    Call Greatest Common Divisor function.\n    \"\"\"\n    try:\n        nums = input(\"Enter two integers separated by comma (,): \").split(\",\")\n        num_1 = int(nums[0])\n        num_2 = int(nums[1])\n        print(\n            f\"greatest_common_divisor({num_1}, {num_2}) = \"\n            f\"{greatest_common_divisor(num_1, num_2)}\"\n        )\n        print(f\"By iterative gcd({num_1}, {num_2}) = {gcd_by_iterative(num_1, num_2)}\")\n    except (IndexError, UnboundLocalError, ValueError):\n        print(\"Wrong input\")",
    "docstring": "Call Greatest Common Divisor function."
  },
  {
    "function": "exact_prime_factor_count",
    "code": "def exact_prime_factor_count(n: int) -> int:\n    \"\"\"\n    >>> exact_prime_factor_count(51242183)\n    3\n    \"\"\"\n    count = 0\n    if n % 2 == 0:\n        count += 1\n        while n % 2 == 0:\n            n = int(n / 2)\n    # the n input value must be odd so that\n    # we can skip one element (ie i += 2)\n\n    i = 3\n\n    while i <= int(math.sqrt(n)):\n        if n % i == 0:\n            count += 1\n            while n % i == 0:\n                n = int(n / i)\n        i = i + 2\n\n    # this condition checks the prime\n    # number n is greater than 2\n\n    if n > 2:\n        count += 1\n    return count",
    "docstring": ">>> exact_prime_factor_count(51242183)\n3"
  },
  {
    "function": "integer_square_root",
    "code": "def integer_square_root(num: int) -> int:\n    \"\"\"\n    Returns the integer square root of a non-negative integer num.\n    Args:\n        num: A non-negative integer.\n    Returns:\n        The integer square root of num.\n    Raises:\n        ValueError: If num is not an integer or is negative.\n    >>> [integer_square_root(i) for i in range(18)]\n    [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4]\n    >>> integer_square_root(625)\n    25\n    >>> integer_square_root(2_147_483_647)\n    46340\n    >>> from math import isqrt\n    >>> all(integer_square_root(i) == isqrt(i) for i in range(20))\n    True\n    >>> integer_square_root(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: num must be non-negative integer\n    >>> integer_square_root(1.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: num must be non-negative integer\n    >>> integer_square_root(\"0\")\n    Traceback (most recent call last):\n        ...\n    ValueError: num must be non-negative integer\n    \"\"\"\n    if not isinstance(num, int) or num < 0:\n        raise ValueError(\"num must be non-negative integer\")\n\n    if num < 2:\n        return num\n\n    left_bound = 0\n    right_bound = num // 2\n\n    while left_bound <= right_bound:\n        mid = left_bound + (right_bound - left_bound) // 2\n        mid_squared = mid * mid\n        if mid_squared == num:\n            return mid\n\n        if mid_squared < num:\n            left_bound = mid + 1\n        else:\n            right_bound = mid - 1\n\n    return right_bound",
    "docstring": "Returns the integer square root of a non-negative integer num.\nArgs:\n    num: A non-negative integer.\nReturns:\n    The integer square root of num.\nRaises:\n    ValueError: If num is not an integer or is negative.\n>>> [integer_square_root(i) for i in range(18)]\n[0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4]\n>>> integer_square_root(625)\n25\n>>> integer_square_root(2_147_483_647)\n46340\n>>> from math import isqrt\n>>> all(integer_square_root(i) == isqrt(i) for i in range(20))\nTrue\n>>> integer_square_root(-1)\nTraceback (most recent call last):\n    ...\nValueError: num must be non-negative integer\n>>> integer_square_root(1.5)\nTraceback (most recent call last):\n    ...\nValueError: num must be non-negative integer\n>>> integer_square_root(\"0\")\nTraceback (most recent call last):\n    ...\nValueError: num must be non-negative integer"
  },
  {
    "function": "find_median",
    "code": "def find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2",
    "docstring": "This is the implementation of the median.\n:param nums: The list of numeric nums\n:return: Median of the list\n>>> find_median(nums=([1, 2, 2, 3, 4]))\n2\n>>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n2.5\n>>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n1.5\n>>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n2.65"
  },
  {
    "function": "interquartile_range",
    "code": "def interquartile_range(nums: list[int | float]) -> float:\n    \"\"\"\n    Return the interquartile range for a list of numeric values.\n    :param nums: The list of numeric values.\n    :return: interquartile range\n\n    >>> interquartile_range(nums=[4, 1, 2, 3, 2])\n    2.0\n    >>> interquartile_range(nums = [-2, -7, -10, 9, 8, 4, -67, 45])\n    17.0\n    >>> interquartile_range(nums = [-2.1, -7.1, -10.1, 9.1, 8.1, 4.1, -67.1, 45.1])\n    17.2\n    >>> interquartile_range(nums = [0, 0, 0, 0, 0])\n    0.0\n    >>> interquartile_range(nums=[])\n    Traceback (most recent call last):\n    ...\n    ValueError: The list is empty. Provide a non-empty list.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list is empty. Provide a non-empty list.\")\n    nums.sort()\n    length = len(nums)\n    div, mod = divmod(length, 2)\n    q1 = find_median(nums[:div])\n    half_length = sum((div, mod))\n    q3 = find_median(nums[half_length:length])\n    return q3 - q1",
    "docstring": "Return the interquartile range for a list of numeric values.\n:param nums: The list of numeric values.\n:return: interquartile range\n\n>>> interquartile_range(nums=[4, 1, 2, 3, 2])\n2.0\n>>> interquartile_range(nums = [-2, -7, -10, 9, 8, 4, -67, 45])\n17.0\n>>> interquartile_range(nums = [-2.1, -7.1, -10.1, 9.1, 8.1, 4.1, -67.1, 45.1])\n17.2\n>>> interquartile_range(nums = [0, 0, 0, 0, 0])\n0.0\n>>> interquartile_range(nums=[])\nTraceback (most recent call last):\n...\nValueError: The list is empty. Provide a non-empty list."
  },
  {
    "function": "is_int_palindrome",
    "code": "def is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num",
    "docstring": "Returns whether `num` is a palindrome or not\n(see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n>>> is_int_palindrome(-121)\nFalse\n>>> is_int_palindrome(0)\nTrue\n>>> is_int_palindrome(10)\nFalse\n>>> is_int_palindrome(11)\nTrue\n>>> is_int_palindrome(101)\nTrue\n>>> is_int_palindrome(120)\nFalse"
  },
  {
    "function": "is_ip_v4_address_valid",
    "code": "def is_ip_v4_address_valid(ip: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.256.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"255.256.0.256\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.05\")\n    False\n    \"\"\"\n    octets = ip.split(\".\")\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        if not octet.isdigit():\n            return False\n\n        number = int(octet)\n        if len(str(number)) != len(octet):\n            return False\n\n        if not 0 <= number <= 255:\n            return False\n\n    return True",
    "docstring": "print \"Valid IP address\" If IP is valid.\nor\nprint \"Invalid IP address\" If IP is invalid.\n\n>>> is_ip_v4_address_valid(\"192.168.0.23\")\nTrue\n\n>>> is_ip_v4_address_valid(\"192.256.15.8\")\nFalse\n\n>>> is_ip_v4_address_valid(\"172.100.0.8\")\nTrue\n\n>>> is_ip_v4_address_valid(\"255.256.0.256\")\nFalse\n\n>>> is_ip_v4_address_valid(\"1.2.33333333.4\")\nFalse\n\n>>> is_ip_v4_address_valid(\"1.2.-3.4\")\nFalse\n\n>>> is_ip_v4_address_valid(\"1.2.3\")\nFalse\n\n>>> is_ip_v4_address_valid(\"1.2.3.4.5\")\nFalse\n\n>>> is_ip_v4_address_valid(\"1.2.A.4\")\nFalse\n\n>>> is_ip_v4_address_valid(\"0.0.0.0\")\nTrue\n\n>>> is_ip_v4_address_valid(\"1.2.3.\")\nFalse\n\n>>> is_ip_v4_address_valid(\"1.2.3.05\")\nFalse"
  },
  {
    "function": "is_square_free",
    "code": "def is_square_free(factors: list[int]) -> bool:\n    \"\"\"\n    # doctest: +NORMALIZE_WHITESPACE\n    This functions takes a list of prime factors as input.\n    returns True if the factors are square free.\n    >>> is_square_free([1, 1, 2, 3, 4])\n    False\n\n    These are wrong but should return some value\n    it simply checks for repetition in the numbers.\n    >>> is_square_free([1, 3, 4, 'sd', 0.0])\n    True\n\n    >>> is_square_free([1, 0.5, 2, 0.0])\n    True\n    >>> is_square_free([1, 2, 2, 5])\n    False\n    >>> is_square_free('asd')\n    True\n    >>> is_square_free(24)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'int' object is not iterable\n    \"\"\"\n    return len(set(factors)) == len(factors)",
    "docstring": "# doctest: +NORMALIZE_WHITESPACE\nThis functions takes a list of prime factors as input.\nreturns True if the factors are square free.\n>>> is_square_free([1, 1, 2, 3, 4])\nFalse\n\nThese are wrong but should return some value\nit simply checks for repetition in the numbers.\n>>> is_square_free([1, 3, 4, 'sd', 0.0])\nTrue\n\n>>> is_square_free([1, 0.5, 2, 0.0])\nTrue\n>>> is_square_free([1, 2, 2, 5])\nFalse\n>>> is_square_free('asd')\nTrue\n>>> is_square_free(24)\nTraceback (most recent call last):\n    ...\nTypeError: 'int' object is not iterable"
  },
  {
    "function": "jaccard_similarity",
    "code": "def jaccard_similarity(\n    set_a: set[str] | list[str] | tuple[str],\n    set_b: set[str] | list[str] | tuple[str],\n    alternative_union=False,\n):\n    \"\"\"\n    Finds the jaccard similarity between two sets.\n    Essentially, its intersection over union.\n\n    The alternative way to calculate this is to take union as sum of the\n    number of items in the two sets. This will lead to jaccard similarity\n    of a set with itself be 1/2 instead of 1. [MMDS 2nd Edition, Page 77]\n\n    Parameters:\n        :set_a (set,list,tuple): A non-empty set/list\n        :set_b (set,list,tuple): A non-empty set/list\n        :alternativeUnion (boolean): If True, use sum of number of\n        items as union\n\n    Output:\n        (float) The jaccard similarity between the two sets.\n\n    Examples:\n    >>> set_a = {'a', 'b', 'c', 'd', 'e'}\n    >>> set_b = {'c', 'd', 'e', 'f', 'h', 'i'}\n    >>> jaccard_similarity(set_a, set_b)\n    0.375\n    >>> jaccard_similarity(set_a, set_a)\n    1.0\n    >>> jaccard_similarity(set_a, set_a, True)\n    0.5\n    >>> set_a = ['a', 'b', 'c', 'd', 'e']\n    >>> set_b = ('c', 'd', 'e', 'f', 'h', 'i')\n    >>> jaccard_similarity(set_a, set_b)\n    0.375\n    >>> set_a = ('c', 'd', 'e', 'f', 'h', 'i')\n    >>> set_b = ['a', 'b', 'c', 'd', 'e']\n    >>> jaccard_similarity(set_a, set_b)\n    0.375\n    >>> set_a = ('c', 'd', 'e', 'f', 'h', 'i')\n    >>> set_b = ['a', 'b', 'c', 'd']\n    >>> jaccard_similarity(set_a, set_b, True)\n    0.2\n    >>> set_a = {'a', 'b'}\n    >>> set_b = ['c', 'd']\n    >>> jaccard_similarity(set_a, set_b)\n    Traceback (most recent call last):\n        ...\n    ValueError: Set a and b must either both be sets or be either a list or a tuple.\n    \"\"\"\n\n    if isinstance(set_a, set) and isinstance(set_b, set):\n        intersection_length = len(set_a.intersection(set_b))\n\n        if alternative_union:\n            union_length = len(set_a) + len(set_b)\n        else:\n            union_length = len(set_a.union(set_b))\n\n        return intersection_length / union_length\n\n    elif isinstance(set_a, (list, tuple)) and isinstance(set_b, (list, tuple)):\n        intersection = [element for element in set_a if element in set_b]\n\n        if alternative_union:\n            return len(intersection) / (len(set_a) + len(set_b))\n        else:\n            # Cast set_a to list because tuples cannot be mutated\n            union = list(set_a) + [element for element in set_b if element not in set_a]\n            return len(intersection) / len(union)\n    raise ValueError(\n        \"Set a and b must either both be sets or be either a list or a tuple.\"\n    )",
    "docstring": "Finds the jaccard similarity between two sets.\nEssentially, its intersection over union.\n\nThe alternative way to calculate this is to take union as sum of the\nnumber of items in the two sets. This will lead to jaccard similarity\nof a set with itself be 1/2 instead of 1. [MMDS 2nd Edition, Page 77]\n\nParameters:\n    :set_a (set,list,tuple): A non-empty set/list\n    :set_b (set,list,tuple): A non-empty set/list\n    :alternativeUnion (boolean): If True, use sum of number of\n    items as union\n\nOutput:\n    (float) The jaccard similarity between the two sets.\n\nExamples:\n>>> set_a = {'a', 'b', 'c', 'd', 'e'}\n>>> set_b = {'c', 'd', 'e', 'f', 'h', 'i'}\n>>> jaccard_similarity(set_a, set_b)\n0.375\n>>> jaccard_similarity(set_a, set_a)\n1.0\n>>> jaccard_similarity(set_a, set_a, True)\n0.5\n>>> set_a = ['a', 'b', 'c', 'd', 'e']\n>>> set_b = ('c', 'd', 'e', 'f', 'h', 'i')\n>>> jaccard_similarity(set_a, set_b)\n0.375\n>>> set_a = ('c', 'd', 'e', 'f', 'h', 'i')\n>>> set_b = ['a', 'b', 'c', 'd', 'e']\n>>> jaccard_similarity(set_a, set_b)\n0.375\n>>> set_a = ('c', 'd', 'e', 'f', 'h', 'i')\n>>> set_b = ['a', 'b', 'c', 'd']\n>>> jaccard_similarity(set_a, set_b, True)\n0.2\n>>> set_a = {'a', 'b'}\n>>> set_b = ['c', 'd']\n>>> jaccard_similarity(set_a, set_b)\nTraceback (most recent call last):\n    ...\nValueError: Set a and b must either both be sets or be either a list or a tuple."
  },
  {
    "function": "joint_probability_distribution",
    "code": "def joint_probability_distribution(\n    x_values: list[int],\n    y_values: list[int],\n    x_probabilities: list[float],\n    y_probabilities: list[float],\n) -> dict:\n    \"\"\"\n    >>> joint_distribution =  joint_probability_distribution(\n    ...     [1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2]\n    ... )\n    >>> from math import isclose\n    >>> isclose(joint_distribution.pop((1, 8)), 0.14)\n    True\n    >>> joint_distribution\n    {(1, -2): 0.21, (1, 5): 0.35, (2, -2): 0.09, (2, 5): 0.15, (2, 8): 0.06}\n    \"\"\"\n    return {\n        (x, y): x_prob * y_prob\n        for x, x_prob in zip(x_values, x_probabilities)\n        for y, y_prob in zip(y_values, y_probabilities)\n    }",
    "docstring": ">>> joint_distribution =  joint_probability_distribution(\n...     [1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2]\n... )\n>>> from math import isclose\n>>> isclose(joint_distribution.pop((1, 8)), 0.14)\nTrue\n>>> joint_distribution\n{(1, -2): 0.21, (1, 5): 0.35, (2, -2): 0.09, (2, 5): 0.15, (2, 8): 0.06}"
  },
  {
    "function": "expectation",
    "code": "def expectation(values: list, probabilities: list) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(expectation([1, 2], [0.7, 0.3]), 1.3)\n    True\n    \"\"\"\n    return sum(x * p for x, p in zip(values, probabilities))",
    "docstring": ">>> from math import isclose\n>>> isclose(expectation([1, 2], [0.7, 0.3]), 1.3)\nTrue"
  },
  {
    "function": "variance",
    "code": "def variance(values: list[int], probabilities: list[float]) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(variance([1,2],[0.7,0.3]), 0.21)\n    True\n    \"\"\"\n    mean = expectation(values, probabilities)\n    return sum((x - mean) ** 2 * p for x, p in zip(values, probabilities))",
    "docstring": ">>> from math import isclose\n>>> isclose(variance([1,2],[0.7,0.3]), 0.21)\nTrue"
  },
  {
    "function": "covariance",
    "code": "def covariance(\n    x_values: list[int],\n    y_values: list[int],\n    x_probabilities: list[float],\n    y_probabilities: list[float],\n) -> float:\n    \"\"\"\n    >>> covariance([1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2])\n    -2.7755575615628914e-17\n    \"\"\"\n    mean_x = expectation(x_values, x_probabilities)\n    mean_y = expectation(y_values, y_probabilities)\n    return sum(\n        (x - mean_x) * (y - mean_y) * px * py\n        for x, px in zip(x_values, x_probabilities)\n        for y, py in zip(y_values, y_probabilities)\n    )",
    "docstring": ">>> covariance([1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2])\n-2.7755575615628914e-17"
  },
  {
    "function": "standard_deviation",
    "code": "def standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5",
    "docstring": ">>> standard_deviation(0.21)\n0.458257569495584"
  },
  {
    "function": "josephus_recursive",
    "code": "def josephus_recursive(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size recursively.\n\n    Args:\n        num_people: A positive integer representing the number of people.\n        step_size: A positive integer representing the step size for elimination.\n\n    Returns:\n        The position of the last person remaining.\n\n    Raises:\n        ValueError: If num_people or step_size is not a positive integer.\n\n    Examples:\n        >>> josephus_recursive(7, 3)\n        3\n        >>> josephus_recursive(10, 2)\n        4\n        >>> josephus_recursive(0, 2)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(1.9, 2)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(-2, 2)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(7, 0)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(7, -2)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(1_000, 0.01)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(\"cat\", \"dog\")\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n    \"\"\"\n    if (\n        not isinstance(num_people, int)\n        or not isinstance(step_size, int)\n        or num_people <= 0\n        or step_size <= 0\n    ):\n        raise ValueError(\"num_people or step_size is not a positive integer.\")\n\n    if num_people == 1:\n        return 0\n\n    return (josephus_recursive(num_people - 1, step_size) + step_size) % num_people",
    "docstring": "Solve the Josephus problem for num_people and a step_size recursively.\n\nArgs:\n    num_people: A positive integer representing the number of people.\n    step_size: A positive integer representing the step size for elimination.\n\nReturns:\n    The position of the last person remaining.\n\nRaises:\n    ValueError: If num_people or step_size is not a positive integer.\n\nExamples:\n    >>> josephus_recursive(7, 3)\n    3\n    >>> josephus_recursive(10, 2)\n    4\n    >>> josephus_recursive(0, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: num_people or step_size is not a positive integer.\n    >>> josephus_recursive(1.9, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: num_people or step_size is not a positive integer.\n    >>> josephus_recursive(-2, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: num_people or step_size is not a positive integer.\n    >>> josephus_recursive(7, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: num_people or step_size is not a positive integer.\n    >>> josephus_recursive(7, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: num_people or step_size is not a positive integer.\n    >>> josephus_recursive(1_000, 0.01)\n    Traceback (most recent call last):\n        ...\n    ValueError: num_people or step_size is not a positive integer.\n    >>> josephus_recursive(\"cat\", \"dog\")\n    Traceback (most recent call last):\n        ...\n    ValueError: num_people or step_size is not a positive integer."
  },
  {
    "function": "find_winner",
    "code": "def find_winner(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Find the winner of the Josephus problem for num_people and a step_size.\n\n    Args:\n        num_people (int): Number of people.\n        step_size (int): Step size for elimination.\n\n    Returns:\n        int: The position of the last person remaining (1-based index).\n\n    Examples:\n        >>> find_winner(7, 3)\n        4\n        >>> find_winner(10, 2)\n        5\n    \"\"\"\n    return josephus_recursive(num_people, step_size) + 1",
    "docstring": "Find the winner of the Josephus problem for num_people and a step_size.\n\nArgs:\n    num_people (int): Number of people.\n    step_size (int): Step size for elimination.\n\nReturns:\n    int: The position of the last person remaining (1-based index).\n\nExamples:\n    >>> find_winner(7, 3)\n    4\n    >>> find_winner(10, 2)\n    5"
  },
  {
    "function": "josephus_iterative",
    "code": "def josephus_iterative(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size iteratively.\n\n    Args:\n        num_people (int): The number of people in the circle.\n        step_size (int): The number of steps to take before eliminating someone.\n\n    Returns:\n        int: The position of the last person standing.\n\n    Examples:\n        >>> josephus_iterative(5, 2)\n        3\n        >>> josephus_iterative(7, 3)\n        4\n    \"\"\"\n    circle = list(range(1, num_people + 1))\n    current = 0\n\n    while len(circle) > 1:\n        current = (current + step_size - 1) % len(circle)\n        circle.pop(current)\n\n    return circle[0]",
    "docstring": "Solve the Josephus problem for num_people and a step_size iteratively.\n\nArgs:\n    num_people (int): The number of people in the circle.\n    step_size (int): The number of steps to take before eliminating someone.\n\nReturns:\n    int: The position of the last person standing.\n\nExamples:\n    >>> josephus_iterative(5, 2)\n    3\n    >>> josephus_iterative(7, 3)\n    4"
  },
  {
    "function": "juggler_sequence",
    "code": "def juggler_sequence(number: int) -> list[int]:\n    \"\"\"\n    >>> juggler_sequence(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=0] must be a positive integer\n    >>> juggler_sequence(1)\n    [1]\n    >>> juggler_sequence(2)\n    [2, 1]\n    >>> juggler_sequence(3)\n    [3, 5, 11, 36, 6, 2, 1]\n    >>> juggler_sequence(5)\n    [5, 11, 36, 6, 2, 1]\n    >>> juggler_sequence(10)\n    [10, 3, 5, 11, 36, 6, 2, 1]\n    >>> juggler_sequence(25)\n    [25, 125, 1397, 52214, 228, 15, 58, 7, 18, 4, 2, 1]\n    >>> juggler_sequence(6.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=6.0] must be an integer\n    >>> juggler_sequence(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=-1] must be a positive integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 1:\n        msg = f\"Input value of [number={number}] must be a positive integer\"\n        raise ValueError(msg)\n    sequence = [number]\n    while number != 1:\n        if number % 2 == 0:\n            number = math.floor(math.sqrt(number))\n        else:\n            number = math.floor(\n                math.sqrt(number) * math.sqrt(number) * math.sqrt(number)\n            )\n        sequence.append(number)\n    return sequence",
    "docstring": ">>> juggler_sequence(0)\nTraceback (most recent call last):\n    ...\nValueError: Input value of [number=0] must be a positive integer\n>>> juggler_sequence(1)\n[1]\n>>> juggler_sequence(2)\n[2, 1]\n>>> juggler_sequence(3)\n[3, 5, 11, 36, 6, 2, 1]\n>>> juggler_sequence(5)\n[5, 11, 36, 6, 2, 1]\n>>> juggler_sequence(10)\n[10, 3, 5, 11, 36, 6, 2, 1]\n>>> juggler_sequence(25)\n[25, 125, 1397, 52214, 228, 15, 58, 7, 18, 4, 2, 1]\n>>> juggler_sequence(6.0)\nTraceback (most recent call last):\n    ...\nTypeError: Input value of [number=6.0] must be an integer\n>>> juggler_sequence(-1)\nTraceback (most recent call last):\n    ...\nValueError: Input value of [number=-1] must be a positive integer"
  },
  {
    "function": "karatsuba",
    "code": "def karatsuba(a: int, b: int) -> int:\n    \"\"\"\n    >>> karatsuba(15463, 23489) == 15463 * 23489\n    True\n    >>> karatsuba(3, 9) == 3 * 9\n    True\n    \"\"\"\n    if len(str(a)) == 1 or len(str(b)) == 1:\n        return a * b\n\n    m1 = max(len(str(a)), len(str(b)))\n    m2 = m1 // 2\n\n    a1, a2 = divmod(a, 10**m2)\n    b1, b2 = divmod(b, 10**m2)\n\n    x = karatsuba(a2, b2)\n    y = karatsuba((a1 + a2), (b1 + b2))\n    z = karatsuba(a1, b1)\n\n    return (z * 10 ** (2 * m2)) + ((y - z - x) * 10 ** (m2)) + (x)",
    "docstring": ">>> karatsuba(15463, 23489) == 15463 * 23489\nTrue\n>>> karatsuba(3, 9) == 3 * 9\nTrue"
  },
  {
    "function": "kth_permutation",
    "code": "def kth_permutation(k, n):\n    \"\"\"\n    Finds k'th lexicographic permutation (in increasing order) of\n    0,1,2,...n-1 in O(n^2) time.\n\n    Examples:\n    First permutation is always 0,1,2,...n\n    >>> kth_permutation(0,5)\n    [0, 1, 2, 3, 4]\n\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n    [1,2,3,0], [1,3,0,2]\n    >>> kth_permutation(10,4)\n    [1, 3, 0, 2]\n    \"\"\"\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation",
    "docstring": "Finds k'th lexicographic permutation (in increasing order) of\n0,1,2,...n-1 in O(n^2) time.\n\nExamples:\nFirst permutation is always 0,1,2,...n\n>>> kth_permutation(0,5)\n[0, 1, 2, 3, 4]\n\nThe order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n[0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n[1,2,3,0], [1,3,0,2]\n>>> kth_permutation(10,4)\n[1, 3, 0, 2]"
  },
  {
    "function": "res",
    "code": "def res(x, y):\n    \"\"\"\n    Reduces large number to a more manageable number\n    >>> res(5, 7)\n    4.892790030352132\n    >>> res(0, 5)\n    0\n    >>> res(3, 0)\n    1\n    >>> res(-1, 5)\n    Traceback (most recent call last):\n    ...\n    ValueError: expected a positive input\n    \"\"\"\n    if 0 not in (x, y):\n        # We use the relation x^y = y*log10(x), where 10 is the base.\n        return y * math.log10(x)\n    elif x == 0:  # 0 raised to any number is 0\n        return 0\n    elif y == 0:\n        return 1  # any number raised to 0 is 1\n    raise AssertionError(\"This should never happen\")",
    "docstring": "Reduces large number to a more manageable number\n>>> res(5, 7)\n4.892790030352132\n>>> res(0, 5)\n0\n>>> res(3, 0)\n1\n>>> res(-1, 5)\nTraceback (most recent call last):\n...\nValueError: expected a positive input"
  },
  {
    "function": "least_common_multiple_slow",
    "code": "def least_common_multiple_slow(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n\n    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple\n\n    >>> least_common_multiple_slow(5, 2)\n    10\n    >>> least_common_multiple_slow(12, 76)\n    228\n    \"\"\"\n    max_num = first_num if first_num >= second_num else second_num\n    common_mult = max_num\n    while (common_mult % first_num > 0) or (common_mult % second_num > 0):\n        common_mult += max_num\n    return common_mult",
    "docstring": "Find the least common multiple of two numbers.\n\nLearn more: https://en.wikipedia.org/wiki/Least_common_multiple\n\n>>> least_common_multiple_slow(5, 2)\n10\n>>> least_common_multiple_slow(12, 76)\n228"
  },
  {
    "function": "least_common_multiple_fast",
    "code": "def least_common_multiple_fast(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n    https://en.wikipedia.org/wiki/Least_common_multiple#Using_the_greatest_common_divisor\n    >>> least_common_multiple_fast(5,2)\n    10\n    >>> least_common_multiple_fast(12,76)\n    228\n    \"\"\"\n    return first_num // greatest_common_divisor(first_num, second_num) * second_num",
    "docstring": "Find the least common multiple of two numbers.\nhttps://en.wikipedia.org/wiki/Least_common_multiple#Using_the_greatest_common_divisor\n>>> least_common_multiple_fast(5,2)\n10\n>>> least_common_multiple_fast(12,76)\n228"
  },
  {
    "function": "line_length",
    "code": "def line_length(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    \"\"\"\n    Approximates the arc length of a line segment by treating the curve as a\n    sequence of linear lines and summing their lengths\n    :param fnc: a function which defines a curve\n    :param x_start: left end point to indicate the start of line segment\n    :param x_end: right end point to indicate end of line segment\n    :param steps: an accuracy gauge; more steps increases accuracy\n    :return: a float representing the length of the curve\n\n    >>> def f(x):\n    ...    return x\n    >>> f\"{line_length(f, 0, 1, 10):.6f}\"\n    '1.414214'\n\n    >>> def f(x):\n    ...    return 1\n    >>> f\"{line_length(f, -5.5, 4.5):.6f}\"\n    '10.000000'\n\n    >>> def f(x):\n    ...    return math.sin(5 * x) + math.cos(10 * x) + x * x/10\n    >>> f\"{line_length(f, 0.0, 10.0, 10000):.6f}\"\n    '69.534930'\n    \"\"\"\n\n    x1 = x_start\n    fx1 = fnc(x_start)\n    length = 0.0\n\n    for _ in range(steps):\n        # Approximates curve as a sequence of linear lines and sums their length\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        length += math.hypot(x2 - x1, fx2 - fx1)\n\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n\n    return length",
    "docstring": "Approximates the arc length of a line segment by treating the curve as a\nsequence of linear lines and summing their lengths\n:param fnc: a function which defines a curve\n:param x_start: left end point to indicate the start of line segment\n:param x_end: right end point to indicate end of line segment\n:param steps: an accuracy gauge; more steps increases accuracy\n:return: a float representing the length of the curve\n\n>>> def f(x):\n...    return x\n>>> f\"{line_length(f, 0, 1, 10):.6f}\"\n'1.414214'\n\n>>> def f(x):\n...    return 1\n>>> f\"{line_length(f, -5.5, 4.5):.6f}\"\n'10.000000'\n\n>>> def f(x):\n...    return math.sin(5 * x) + math.cos(10 * x) + x * x/10\n>>> f\"{line_length(f, 0.0, 10.0, 10000):.6f}\"\n'69.534930'"
  },
  {
    "function": "liouville_lambda",
    "code": "def liouville_lambda(number: int) -> int:\n    \"\"\"\n    This functions takes an integer number as input.\n    returns 1 if n has even number of prime factors and -1 otherwise.\n    >>> liouville_lambda(10)\n    1\n    >>> liouville_lambda(11)\n    -1\n    >>> liouville_lambda(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer\n    >>> liouville_lambda(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer\n    >>> liouville_lambda(11.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=11.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    return -1 if len(prime_factors(number)) % 2 else 1",
    "docstring": "This functions takes an integer number as input.\nreturns 1 if n has even number of prime factors and -1 otherwise.\n>>> liouville_lambda(10)\n1\n>>> liouville_lambda(11)\n-1\n>>> liouville_lambda(0)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a positive integer\n>>> liouville_lambda(-1)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a positive integer\n>>> liouville_lambda(11.0)\nTraceback (most recent call last):\n    ...\nTypeError: Input value of [number=11.0] must be an integer"
  },
  {
    "function": "lucas_lehmer_test",
    "code": "def lucas_lehmer_test(p: int) -> bool:\n    \"\"\"\n    >>> lucas_lehmer_test(p=7)\n    True\n\n    >>> lucas_lehmer_test(p=11)\n    False\n\n    # M_11 = 2^11 - 1 = 2047 = 23 * 89\n    \"\"\"\n\n    if p < 2:\n        raise ValueError(\"p should not be less than 2!\")\n    elif p == 2:\n        return True\n\n    s = 4\n    m = (1 << p) - 1\n    for _ in range(p - 2):\n        s = ((s * s) - 2) % m\n    return s == 0",
    "docstring": ">>> lucas_lehmer_test(p=7)\nTrue\n\n>>> lucas_lehmer_test(p=11)\nFalse\n\n# M_11 = 2^11 - 1 = 2047 = 23 * 89"
  },
  {
    "function": "recursive_lucas_number",
    "code": "def recursive_lucas_number(n_th_number: int) -> int:\n    \"\"\"\n    Returns the nth lucas number\n    >>> recursive_lucas_number(1)\n    1\n    >>> recursive_lucas_number(20)\n    15127\n    >>> recursive_lucas_number(0)\n    2\n    >>> recursive_lucas_number(25)\n    167761\n    >>> recursive_lucas_number(-1.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: recursive_lucas_number accepts only integer arguments.\n    \"\"\"\n    if not isinstance(n_th_number, int):\n        raise TypeError(\"recursive_lucas_number accepts only integer arguments.\")\n    if n_th_number == 0:\n        return 2\n    if n_th_number == 1:\n        return 1\n\n    return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(\n        n_th_number - 2\n    )",
    "docstring": "Returns the nth lucas number\n>>> recursive_lucas_number(1)\n1\n>>> recursive_lucas_number(20)\n15127\n>>> recursive_lucas_number(0)\n2\n>>> recursive_lucas_number(25)\n167761\n>>> recursive_lucas_number(-1.5)\nTraceback (most recent call last):\n    ...\nTypeError: recursive_lucas_number accepts only integer arguments."
  },
  {
    "function": "dynamic_lucas_number",
    "code": "def dynamic_lucas_number(n_th_number: int) -> int:\n    \"\"\"\n    Returns the nth lucas number\n    >>> dynamic_lucas_number(1)\n    1\n    >>> dynamic_lucas_number(20)\n    15127\n    >>> dynamic_lucas_number(0)\n    2\n    >>> dynamic_lucas_number(25)\n    167761\n    >>> dynamic_lucas_number(-1.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: dynamic_lucas_number accepts only integer arguments.\n    \"\"\"\n    if not isinstance(n_th_number, int):\n        raise TypeError(\"dynamic_lucas_number accepts only integer arguments.\")\n    a, b = 2, 1\n    for _ in range(n_th_number):\n        a, b = b, a + b\n    return a",
    "docstring": "Returns the nth lucas number\n>>> dynamic_lucas_number(1)\n1\n>>> dynamic_lucas_number(20)\n15127\n>>> dynamic_lucas_number(0)\n2\n>>> dynamic_lucas_number(25)\n167761\n>>> dynamic_lucas_number(-1.5)\nTraceback (most recent call last):\n    ...\nTypeError: dynamic_lucas_number accepts only integer arguments."
  },
  {
    "function": "maclaurin_sin",
    "code": "def maclaurin_sin(theta: float, accuracy: int = 30) -> float:\n    \"\"\"\n    Finds the maclaurin approximation of sin\n\n    :param theta: the angle to which sin is found\n    :param accuracy: the degree of accuracy wanted minimum\n    :return: the value of sine in radians\n\n\n    >>> from math import isclose, sin\n    >>> all(isclose(maclaurin_sin(x, 50), sin(x)) for x in range(-25, 25))\n    True\n    >>> maclaurin_sin(10)\n    -0.5440211108893691\n    >>> maclaurin_sin(-10)\n    0.5440211108893704\n    >>> maclaurin_sin(10, 15)\n    -0.544021110889369\n    >>> maclaurin_sin(-10, 15)\n    0.5440211108893704\n    >>> maclaurin_sin(\"10\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires either an int or float for theta\n    >>> maclaurin_sin(10, -30)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires a positive int for accuracy\n    >>> maclaurin_sin(10, 30.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires a positive int for accuracy\n    >>> maclaurin_sin(10, \"30\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires a positive int for accuracy\n    \"\"\"\n\n    if not isinstance(theta, (int, float)):\n        raise ValueError(\"maclaurin_sin() requires either an int or float for theta\")\n\n    if not isinstance(accuracy, int) or accuracy <= 0:\n        raise ValueError(\"maclaurin_sin() requires a positive int for accuracy\")\n\n    theta = float(theta)\n    div = theta // (2 * pi)\n    theta -= 2 * div * pi\n    return sum(\n        (-1) ** r * theta ** (2 * r + 1) / factorial(2 * r + 1) for r in range(accuracy)\n    )",
    "docstring": "Finds the maclaurin approximation of sin\n\n:param theta: the angle to which sin is found\n:param accuracy: the degree of accuracy wanted minimum\n:return: the value of sine in radians\n\n\n>>> from math import isclose, sin\n>>> all(isclose(maclaurin_sin(x, 50), sin(x)) for x in range(-25, 25))\nTrue\n>>> maclaurin_sin(10)\n-0.5440211108893691\n>>> maclaurin_sin(-10)\n0.5440211108893704\n>>> maclaurin_sin(10, 15)\n-0.544021110889369\n>>> maclaurin_sin(-10, 15)\n0.5440211108893704\n>>> maclaurin_sin(\"10\")\nTraceback (most recent call last):\n    ...\nValueError: maclaurin_sin() requires either an int or float for theta\n>>> maclaurin_sin(10, -30)\nTraceback (most recent call last):\n    ...\nValueError: maclaurin_sin() requires a positive int for accuracy\n>>> maclaurin_sin(10, 30.5)\nTraceback (most recent call last):\n    ...\nValueError: maclaurin_sin() requires a positive int for accuracy\n>>> maclaurin_sin(10, \"30\")\nTraceback (most recent call last):\n    ...\nValueError: maclaurin_sin() requires a positive int for accuracy"
  },
  {
    "function": "maclaurin_cos",
    "code": "def maclaurin_cos(theta: float, accuracy: int = 30) -> float:\n    \"\"\"\n    Finds the maclaurin approximation of cos\n\n    :param theta: the angle to which cos is found\n    :param accuracy: the degree of accuracy wanted\n    :return: the value of cosine in radians\n\n\n    >>> from math import isclose, cos\n    >>> all(isclose(maclaurin_cos(x, 50), cos(x)) for x in range(-25, 25))\n    True\n    >>> maclaurin_cos(5)\n    0.2836621854632268\n    >>> maclaurin_cos(-5)\n    0.2836621854632265\n    >>> maclaurin_cos(10, 15)\n    -0.8390715290764524\n    >>> maclaurin_cos(-10, 15)\n    -0.8390715290764521\n    >>> maclaurin_cos(\"10\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires either an int or float for theta\n    >>> maclaurin_cos(10, -30)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    >>> maclaurin_cos(10, 30.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    >>> maclaurin_cos(10, \"30\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    \"\"\"\n\n    if not isinstance(theta, (int, float)):\n        raise ValueError(\"maclaurin_cos() requires either an int or float for theta\")\n\n    if not isinstance(accuracy, int) or accuracy <= 0:\n        raise ValueError(\"maclaurin_cos() requires a positive int for accuracy\")\n\n    theta = float(theta)\n    div = theta // (2 * pi)\n    theta -= 2 * div * pi\n    return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))",
    "docstring": "Finds the maclaurin approximation of cos\n\n:param theta: the angle to which cos is found\n:param accuracy: the degree of accuracy wanted\n:return: the value of cosine in radians\n\n\n>>> from math import isclose, cos\n>>> all(isclose(maclaurin_cos(x, 50), cos(x)) for x in range(-25, 25))\nTrue\n>>> maclaurin_cos(5)\n0.2836621854632268\n>>> maclaurin_cos(-5)\n0.2836621854632265\n>>> maclaurin_cos(10, 15)\n-0.8390715290764524\n>>> maclaurin_cos(-10, 15)\n-0.8390715290764521\n>>> maclaurin_cos(\"10\")\nTraceback (most recent call last):\n    ...\nValueError: maclaurin_cos() requires either an int or float for theta\n>>> maclaurin_cos(10, -30)\nTraceback (most recent call last):\n    ...\nValueError: maclaurin_cos() requires a positive int for accuracy\n>>> maclaurin_cos(10, 30.5)\nTraceback (most recent call last):\n    ...\nValueError: maclaurin_cos() requires a positive int for accuracy\n>>> maclaurin_cos(10, \"30\")\nTraceback (most recent call last):\n    ...\nValueError: maclaurin_cos() requires a positive int for accuracy"
  },
  {
    "function": "manhattan_distance",
    "code": "def manhattan_distance(point_a: list, point_b: list) -> float:\n    \"\"\"\n    Expectts two list of numbers representing two points in the same\n    n-dimensional space\n\n    https://en.wikipedia.org/wiki/Taxicab_geometry\n\n    >>> manhattan_distance([1,1], [2,2])\n    2.0\n    >>> manhattan_distance([1.5,1.5], [2,2])\n    1.0\n    >>> manhattan_distance([1.5,1.5], [2.5,2])\n    1.5\n    >>> manhattan_distance([-3, -3, -3], [0, 0, 0])\n    9.0\n    >>> manhattan_distance([1,1], None)\n    Traceback (most recent call last):\n        ...\n    ValueError: Missing an input\n    >>> manhattan_distance([1,1], [2, 2, 2])\n    Traceback (most recent call last):\n        ...\n    ValueError: Both points must be in the same n-dimensional space\n    >>> manhattan_distance([1,\"one\"], [2, 2, 2])\n    Traceback (most recent call last):\n        ...\n    TypeError: Expected a list of numbers as input, found str\n    >>> manhattan_distance(1, [2, 2, 2])\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found int\n    >>> manhattan_distance([1,1], \"not_a_list\")\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    \"\"\"\n\n    _validate_point(point_a)\n    _validate_point(point_b)\n    if len(point_a) != len(point_b):\n        raise ValueError(\"Both points must be in the same n-dimensional space\")\n\n    return float(sum(abs(a - b) for a, b in zip(point_a, point_b)))",
    "docstring": "Expectts two list of numbers representing two points in the same\nn-dimensional space\n\nhttps://en.wikipedia.org/wiki/Taxicab_geometry\n\n>>> manhattan_distance([1,1], [2,2])\n2.0\n>>> manhattan_distance([1.5,1.5], [2,2])\n1.0\n>>> manhattan_distance([1.5,1.5], [2.5,2])\n1.5\n>>> manhattan_distance([-3, -3, -3], [0, 0, 0])\n9.0\n>>> manhattan_distance([1,1], None)\nTraceback (most recent call last):\n    ...\nValueError: Missing an input\n>>> manhattan_distance([1,1], [2, 2, 2])\nTraceback (most recent call last):\n    ...\nValueError: Both points must be in the same n-dimensional space\n>>> manhattan_distance([1,\"one\"], [2, 2, 2])\nTraceback (most recent call last):\n    ...\nTypeError: Expected a list of numbers as input, found str\n>>> manhattan_distance(1, [2, 2, 2])\nTraceback (most recent call last):\n     ...\nTypeError: Expected a list of numbers as input, found int\n>>> manhattan_distance([1,1], \"not_a_list\")\nTraceback (most recent call last):\n     ...\nTypeError: Expected a list of numbers as input, found str"
  },
  {
    "function": "_validate_point",
    "code": "def _validate_point(point: list[float]) -> None:\n    \"\"\"\n    >>> _validate_point(None)\n    Traceback (most recent call last):\n         ...\n    ValueError: Missing an input\n    >>> _validate_point([1,\"one\"])\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    >>> _validate_point(1)\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found int\n    >>> _validate_point(\"not_a_list\")\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    \"\"\"\n    if point:\n        if isinstance(point, list):\n            for item in point:\n                if not isinstance(item, (int, float)):\n                    msg = (\n                        \"Expected a list of numbers as input, found \"\n                        f\"{type(item).__name__}\"\n                    )\n                    raise TypeError(msg)\n        else:\n            msg = f\"Expected a list of numbers as input, found {type(point).__name__}\"\n            raise TypeError(msg)\n    else:\n        raise ValueError(\"Missing an input\")",
    "docstring": ">>> _validate_point(None)\nTraceback (most recent call last):\n     ...\nValueError: Missing an input\n>>> _validate_point([1,\"one\"])\nTraceback (most recent call last):\n     ...\nTypeError: Expected a list of numbers as input, found str\n>>> _validate_point(1)\nTraceback (most recent call last):\n     ...\nTypeError: Expected a list of numbers as input, found int\n>>> _validate_point(\"not_a_list\")\nTraceback (most recent call last):\n     ...\nTypeError: Expected a list of numbers as input, found str"
  },
  {
    "function": "manhattan_distance_one_liner",
    "code": "def manhattan_distance_one_liner(point_a: list, point_b: list) -> float:\n    \"\"\"\n    Version with one liner\n\n    >>> manhattan_distance_one_liner([1,1], [2,2])\n    2.0\n    >>> manhattan_distance_one_liner([1.5,1.5], [2,2])\n    1.0\n    >>> manhattan_distance_one_liner([1.5,1.5], [2.5,2])\n    1.5\n    >>> manhattan_distance_one_liner([-3, -3, -3], [0, 0, 0])\n    9.0\n    >>> manhattan_distance_one_liner([1,1], None)\n    Traceback (most recent call last):\n         ...\n    ValueError: Missing an input\n    >>> manhattan_distance_one_liner([1,1], [2, 2, 2])\n    Traceback (most recent call last):\n         ...\n    ValueError: Both points must be in the same n-dimensional space\n    >>> manhattan_distance_one_liner([1,\"one\"], [2, 2, 2])\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    >>> manhattan_distance_one_liner(1, [2, 2, 2])\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found int\n    >>> manhattan_distance_one_liner([1,1], \"not_a_list\")\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    \"\"\"\n\n    _validate_point(point_a)\n    _validate_point(point_b)\n    if len(point_a) != len(point_b):\n        raise ValueError(\"Both points must be in the same n-dimensional space\")\n\n    return float(sum(abs(x - y) for x, y in zip(point_a, point_b)))",
    "docstring": "Version with one liner\n\n>>> manhattan_distance_one_liner([1,1], [2,2])\n2.0\n>>> manhattan_distance_one_liner([1.5,1.5], [2,2])\n1.0\n>>> manhattan_distance_one_liner([1.5,1.5], [2.5,2])\n1.5\n>>> manhattan_distance_one_liner([-3, -3, -3], [0, 0, 0])\n9.0\n>>> manhattan_distance_one_liner([1,1], None)\nTraceback (most recent call last):\n     ...\nValueError: Missing an input\n>>> manhattan_distance_one_liner([1,1], [2, 2, 2])\nTraceback (most recent call last):\n     ...\nValueError: Both points must be in the same n-dimensional space\n>>> manhattan_distance_one_liner([1,\"one\"], [2, 2, 2])\nTraceback (most recent call last):\n     ...\nTypeError: Expected a list of numbers as input, found str\n>>> manhattan_distance_one_liner(1, [2, 2, 2])\nTraceback (most recent call last):\n     ...\nTypeError: Expected a list of numbers as input, found int\n>>> manhattan_distance_one_liner([1,1], \"not_a_list\")\nTraceback (most recent call last):\n     ...\nTypeError: Expected a list of numbers as input, found str"
  },
  {
    "function": "fibonacci_with_matrix_exponentiation",
    "code": "def fibonacci_with_matrix_exponentiation(n, f1, f2):\n    \"\"\"\n    Returns the nth number of the Fibonacci sequence that\n    starts with f1 and f2\n    Uses the matrix exponentiation\n    >>> fibonacci_with_matrix_exponentiation(1, 5, 6)\n    5\n    >>> fibonacci_with_matrix_exponentiation(2, 10, 11)\n    11\n    >>> fibonacci_with_matrix_exponentiation(13, 0, 1)\n    144\n    >>> fibonacci_with_matrix_exponentiation(10, 5, 9)\n    411\n    >>> fibonacci_with_matrix_exponentiation(9, 2, 3)\n    89\n    \"\"\"\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n    matrix = Matrix([[1, 1], [1, 0]])\n    matrix = modular_exponentiation(matrix, n - 2)\n    return f2 * matrix.t[0][0] + f1 * matrix.t[0][1]",
    "docstring": "Returns the nth number of the Fibonacci sequence that\nstarts with f1 and f2\nUses the matrix exponentiation\n>>> fibonacci_with_matrix_exponentiation(1, 5, 6)\n5\n>>> fibonacci_with_matrix_exponentiation(2, 10, 11)\n11\n>>> fibonacci_with_matrix_exponentiation(13, 0, 1)\n144\n>>> fibonacci_with_matrix_exponentiation(10, 5, 9)\n411\n>>> fibonacci_with_matrix_exponentiation(9, 2, 3)\n89"
  },
  {
    "function": "simple_fibonacci",
    "code": "def simple_fibonacci(n, f1, f2):\n    \"\"\"\n    Returns the nth number of the Fibonacci sequence that\n    starts with f1 and f2\n    Uses the definition\n    >>> simple_fibonacci(1, 5, 6)\n    5\n    >>> simple_fibonacci(2, 10, 11)\n    11\n    >>> simple_fibonacci(13, 0, 1)\n    144\n    >>> simple_fibonacci(10, 5, 9)\n    411\n    >>> simple_fibonacci(9, 2, 3)\n    89\n    \"\"\"\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    n -= 2\n\n    while n > 0:\n        f2, f1 = f1 + f2, f2\n        n -= 1\n\n    return f2",
    "docstring": "Returns the nth number of the Fibonacci sequence that\nstarts with f1 and f2\nUses the definition\n>>> simple_fibonacci(1, 5, 6)\n5\n>>> simple_fibonacci(2, 10, 11)\n11\n>>> simple_fibonacci(13, 0, 1)\n144\n>>> simple_fibonacci(10, 5, 9)\n411\n>>> simple_fibonacci(9, 2, 3)\n89"
  },
  {
    "function": "max_sum_in_array",
    "code": "def max_sum_in_array(array: list[int], k: int) -> int:\n    \"\"\"\n    Returns the maximum sum of k consecutive elements\n    >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]\n    >>> k = 4\n    >>> max_sum_in_array(arr, k)\n    24\n    >>> k = 10\n    >>> max_sum_in_array(arr,k)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid Input\n    >>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2]\n    >>> k = 4\n    >>> max_sum_in_array(arr, k)\n    27\n    \"\"\"\n    if len(array) < k or k < 0:\n        raise ValueError(\"Invalid Input\")\n    max_sum = current_sum = sum(array[:k])\n    for i in range(len(array) - k):\n        current_sum = current_sum - array[i] + array[i + k]\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
    "docstring": "Returns the maximum sum of k consecutive elements\n>>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]\n>>> k = 4\n>>> max_sum_in_array(arr, k)\n24\n>>> k = 10\n>>> max_sum_in_array(arr,k)\nTraceback (most recent call last):\n    ...\nValueError: Invalid Input\n>>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2]\n>>> k = 4\n>>> max_sum_in_array(arr, k)\n27"
  },
  {
    "function": "minkowski_distance",
    "code": "def minkowski_distance(\n    point_a: list[float],\n    point_b: list[float],\n    order: int,\n) -> float:\n    \"\"\"\n    This function calculates the Minkowski distance for a given order between\n    two n-dimensional points represented as lists. For the case of order = 1,\n    the Minkowski distance degenerates to the Manhattan distance. For\n    order = 2, the usual Euclidean distance is obtained.\n\n    https://en.wikipedia.org/wiki/Minkowski_distance\n\n    Note: due to floating point calculation errors the output of this\n    function may be inaccurate.\n\n    >>> minkowski_distance([1.0, 1.0], [2.0, 2.0], 1)\n    2.0\n    >>> minkowski_distance([1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], 2)\n    8.0\n    >>> import numpy as np\n    >>> bool(np.isclose(5.0, minkowski_distance([5.0], [0.0], 3)))\n    True\n    >>> minkowski_distance([1.0], [2.0], -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The order must be greater than or equal to 1.\n    >>> minkowski_distance([1.0], [1.0, 2.0], 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Both points must have the same dimension.\n    \"\"\"\n    if order < 1:\n        raise ValueError(\"The order must be greater than or equal to 1.\")\n\n    if len(point_a) != len(point_b):\n        raise ValueError(\"Both points must have the same dimension.\")\n\n    return sum(abs(a - b) ** order for a, b in zip(point_a, point_b)) ** (1 / order)",
    "docstring": "This function calculates the Minkowski distance for a given order between\ntwo n-dimensional points represented as lists. For the case of order = 1,\nthe Minkowski distance degenerates to the Manhattan distance. For\norder = 2, the usual Euclidean distance is obtained.\n\nhttps://en.wikipedia.org/wiki/Minkowski_distance\n\nNote: due to floating point calculation errors the output of this\nfunction may be inaccurate.\n\n>>> minkowski_distance([1.0, 1.0], [2.0, 2.0], 1)\n2.0\n>>> minkowski_distance([1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], 2)\n8.0\n>>> import numpy as np\n>>> bool(np.isclose(5.0, minkowski_distance([5.0], [0.0], 3)))\nTrue\n>>> minkowski_distance([1.0], [2.0], -1)\nTraceback (most recent call last):\n    ...\nValueError: The order must be greater than or equal to 1.\n>>> minkowski_distance([1.0], [1.0, 2.0], 1)\nTraceback (most recent call last):\n    ...\nValueError: Both points must have the same dimension."
  },
  {
    "function": "mobius",
    "code": "def mobius(n: int) -> int:\n    \"\"\"\n    Mobius function\n    >>> mobius(24)\n    0\n    >>> mobius(-1)\n    1\n    >>> mobius('asd')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> mobius(10**400)\n    0\n    >>> mobius(10**-400)\n    1\n    >>> mobius(-1424)\n    1\n    >>> mobius([1, '2', 2.0])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n    \"\"\"\n    factors = prime_factors(n)\n    if is_square_free(factors):\n        return -1 if len(factors) % 2 else 1\n    return 0",
    "docstring": "Mobius function\n>>> mobius(24)\n0\n>>> mobius(-1)\n1\n>>> mobius('asd')\nTraceback (most recent call last):\n    ...\nTypeError: '<=' not supported between instances of 'int' and 'str'\n>>> mobius(10**400)\n0\n>>> mobius(10**-400)\n1\n>>> mobius(-1424)\n1\n>>> mobius([1, '2', 2.0])\nTraceback (most recent call last):\n    ...\nTypeError: '<=' not supported between instances of 'int' and 'list'"
  },
  {
    "function": "modular_division",
    "code": "def modular_division(a: int, b: int, n: int) -> int:\n    \"\"\"\n    Modular Division :\n    An efficient algorithm for dividing b by a modulo n.\n\n    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n    Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should\n    return an integer x such that 0\u2264x\u2264n-1, and  b/a=x(modn) (that is, b=ax(modn)).\n\n    Theorem:\n    a has a multiplicative inverse modulo n iff gcd(a,n) = 1\n\n\n    This find x = b*a^(-1) mod n\n    Uses ExtendedEuclid to find the inverse of a\n\n    >>> modular_division(4,8,5)\n    2\n\n    >>> modular_division(3,8,5)\n    1\n\n    >>> modular_division(4, 11, 5)\n    4\n\n    \"\"\"\n    assert n > 1\n    assert a > 0\n    assert greatest_common_divisor(a, n) == 1\n    (_d, _t, s) = extended_gcd(n, a)  # Implemented below\n    x = (b * s) % n\n    return x",
    "docstring": "Modular Division :\nAn efficient algorithm for dividing b by a modulo n.\n\nGCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\nGiven three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should\nreturn an integer x such that 0\u2264x\u2264n-1, and  b/a=x(modn) (that is, b=ax(modn)).\n\nTheorem:\na has a multiplicative inverse modulo n iff gcd(a,n) = 1\n\n\nThis find x = b*a^(-1) mod n\nUses ExtendedEuclid to find the inverse of a\n\n>>> modular_division(4,8,5)\n2\n\n>>> modular_division(3,8,5)\n1\n\n>>> modular_division(4, 11, 5)\n4"
  },
  {
    "function": "invert_modulo",
    "code": "def invert_modulo(a: int, n: int) -> int:\n    \"\"\"\n    This function find the inverses of a i.e., a^(-1)\n\n    >>> invert_modulo(2, 5)\n    3\n\n    >>> invert_modulo(8,7)\n    1\n\n    \"\"\"\n    (b, _x) = extended_euclid(a, n)  # Implemented below\n    if b < 0:\n        b = (b % n + n) % n\n    return b",
    "docstring": "This function find the inverses of a i.e., a^(-1)\n\n>>> invert_modulo(2, 5)\n3\n\n>>> invert_modulo(8,7)\n1"
  },
  {
    "function": "modular_division2",
    "code": "def modular_division2(a: int, b: int, n: int) -> int:\n    \"\"\"\n    This function used the above inversion of a to find x = (b*a^(-1))mod n\n\n    >>> modular_division2(4,8,5)\n    2\n\n    >>> modular_division2(3,8,5)\n    1\n\n    >>> modular_division2(4, 11, 5)\n    4\n\n    \"\"\"\n    s = invert_modulo(a, n)\n    x = (b * s) % n\n    return x",
    "docstring": "This function used the above inversion of a to find x = (b*a^(-1))mod n\n\n>>> modular_division2(4,8,5)\n2\n\n>>> modular_division2(3,8,5)\n1\n\n>>> modular_division2(4, 11, 5)\n4"
  },
  {
    "function": "extended_gcd",
    "code": "def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0\n    assert b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0\n    assert b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)",
    "docstring": "Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\nand y, then d = gcd(a,b)\n>>> extended_gcd(10, 6)\n(2, -1, 2)\n\n>>> extended_gcd(7, 5)\n(1, -2, 3)\n\n** extended_gcd function is used when d = gcd(a,b) is required in output"
  },
  {
    "function": "extended_euclid",
    "code": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)",
    "docstring": "Extended Euclid\n>>> extended_euclid(10, 6)\n(-1, 2)\n\n>>> extended_euclid(7, 5)\n(-2, 3)"
  },
  {
    "function": "greatest_common_divisor",
    "code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid's Algorithm\n\n    >>> greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    >>> greatest_common_divisor(121, 11)\n    11\n\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while a % b != 0:\n        a, b = b, a % b\n\n    return b",
    "docstring": "Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\nEuclid's Algorithm\n\n>>> greatest_common_divisor(7,5)\n1\n\nNote : In number theory, two integers a and b are said to be relatively prime,\n    mutually prime, or co-prime if the only positive integer (factor) that divides\n    both of them is 1  i.e., gcd(a,b) = 1.\n\n>>> greatest_common_divisor(121, 11)\n11"
  },
  {
    "function": "modular_exponential",
    "code": "def modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result",
    "docstring": ">>> modular_exponential(5, 0, 10)\n1\n>>> modular_exponential(2, 8, 7)\n4\n>>> modular_exponential(3, -2, 9)\n-1"
  },
  {
    "function": "main",
    "code": "def main():\n    \"\"\"Call Modular Exponential Function.\"\"\"\n    print(modular_exponential(3, 200, 13))",
    "docstring": "Call Modular Exponential Function."
  },
  {
    "function": "pi_estimator",
    "code": "def pi_estimator(iterations: int) -> None:\n    \"\"\"\n    An implementation of the Monte Carlo method used to find pi.\n    1. Draw a 2x2 square centred at (0,0).\n    2. Inscribe a circle within the square.\n    3. For each iteration, place a dot anywhere in the square.\n       a. Record the number of dots within the circle.\n    4. After all the dots are placed, divide the dots in the circle by the total.\n    5. Multiply this value by 4 to get your estimate of pi.\n    6. Print the estimated and numpy value of pi\n    \"\"\"\n\n    # A local function to see if a dot lands in the circle.\n    def is_in_circle(x: float, y: float) -> bool:\n        distance_from_centre = sqrt((x**2) + (y**2))\n        # Our circle has a radius of 1, so a distance\n        # greater than 1 would land outside the circle.\n        return distance_from_centre <= 1\n\n    # The proportion of guesses that landed in the circle\n    proportion = mean(\n        int(is_in_circle(uniform(-1.0, 1.0), uniform(-1.0, 1.0)))\n        for _ in range(iterations)\n    )\n    # The ratio of the area for circle to square is pi/4.\n    pi_estimate = proportion * 4\n    print(f\"The estimated value of pi is {pi_estimate}\")\n    print(f\"The numpy value of pi is {pi}\")\n    print(f\"The total error is {abs(pi - pi_estimate)}\")",
    "docstring": "An implementation of the Monte Carlo method used to find pi.\n1. Draw a 2x2 square centred at (0,0).\n2. Inscribe a circle within the square.\n3. For each iteration, place a dot anywhere in the square.\n   a. Record the number of dots within the circle.\n4. After all the dots are placed, divide the dots in the circle by the total.\n5. Multiply this value by 4 to get your estimate of pi.\n6. Print the estimated and numpy value of pi"
  },
  {
    "function": "area_under_curve_estimator",
    "code": "def area_under_curve_estimator(\n    iterations: int,\n    function_to_integrate: Callable[[float], float],\n    min_value: float = 0.0,\n    max_value: float = 1.0,\n) -> float:\n    \"\"\"\n    An implementation of the Monte Carlo method to find area under\n       a single variable non-negative real-valued continuous function,\n       say f(x), where x lies within a continuous bounded interval,\n       say [min_value, max_value], where min_value and max_value are\n       finite numbers\n    1. Let x be a uniformly distributed random variable between min_value to\n       max_value\n    2. Expected value of f(x) =\n       (integrate f(x) from min_value to max_value)/(max_value - min_value)\n    3. Finding expected value of f(x):\n        a. Repeatedly draw x from uniform distribution\n        b. Evaluate f(x) at each of the drawn x values\n        c. Expected value = average of the function evaluations\n    4. Estimated value of integral = Expected value * (max_value - min_value)\n    5. Returns estimated value\n    \"\"\"\n\n    return mean(\n        function_to_integrate(uniform(min_value, max_value)) for _ in range(iterations)\n    ) * (max_value - min_value)",
    "docstring": "An implementation of the Monte Carlo method to find area under\n   a single variable non-negative real-valued continuous function,\n   say f(x), where x lies within a continuous bounded interval,\n   say [min_value, max_value], where min_value and max_value are\n   finite numbers\n1. Let x be a uniformly distributed random variable between min_value to\n   max_value\n2. Expected value of f(x) =\n   (integrate f(x) from min_value to max_value)/(max_value - min_value)\n3. Finding expected value of f(x):\n    a. Repeatedly draw x from uniform distribution\n    b. Evaluate f(x) at each of the drawn x values\n    c. Expected value = average of the function evaluations\n4. Estimated value of integral = Expected value * (max_value - min_value)\n5. Returns estimated value"
  },
  {
    "function": "area_under_line_estimator_check",
    "code": "def area_under_line_estimator_check(\n    iterations: int, min_value: float = 0.0, max_value: float = 1.0\n) -> None:\n    \"\"\"\n    Checks estimation error for area_under_curve_estimator function\n    for f(x) = x where x lies within min_value to max_value\n    1. Calls \"area_under_curve_estimator\" function\n    2. Compares with the expected value\n    3. Prints estimated, expected and error value\n    \"\"\"\n\n    def identity_function(x: float) -> float:\n        \"\"\"\n        Represents identity function\n        >>> [function_to_integrate(x) for x in [-2.0, -1.0, 0.0, 1.0, 2.0]]\n        [-2.0, -1.0, 0.0, 1.0, 2.0]\n        \"\"\"\n        return x\n\n    estimated_value = area_under_curve_estimator(\n        iterations, identity_function, min_value, max_value\n    )\n    expected_value = (max_value * max_value - min_value * min_value) / 2\n\n    print(\"******************\")\n    print(f\"Estimating area under y=x where x varies from {min_value} to {max_value}\")\n    print(f\"Estimated value is {estimated_value}\")\n    print(f\"Expected value is {expected_value}\")\n    print(f\"Total error is {abs(estimated_value - expected_value)}\")\n    print(\"******************\")",
    "docstring": "Checks estimation error for area_under_curve_estimator function\nfor f(x) = x where x lies within min_value to max_value\n1. Calls \"area_under_curve_estimator\" function\n2. Compares with the expected value\n3. Prints estimated, expected and error value"
  },
  {
    "function": "pi_estimator_using_area_under_curve",
    "code": "def pi_estimator_using_area_under_curve(iterations: int) -> None:\n    \"\"\"\n    Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi\n    \"\"\"\n\n    def function_to_integrate(x: float) -> float:\n        \"\"\"\n        Represents semi-circle with radius 2\n        >>> [function_to_integrate(x) for x in [-2.0, 0.0, 2.0]]\n        [0.0, 2.0, 0.0]\n        \"\"\"\n        return sqrt(4.0 - x * x)\n\n    estimated_value = area_under_curve_estimator(\n        iterations, function_to_integrate, 0.0, 2.0\n    )\n\n    print(\"******************\")\n    print(\"Estimating pi using area_under_curve_estimator\")\n    print(f\"Estimated value is {estimated_value}\")\n    print(f\"Expected value is {pi}\")\n    print(f\"Total error is {abs(estimated_value - pi)}\")\n    print(\"******************\")",
    "docstring": "Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi"
  },
  {
    "function": "throw_dice",
    "code": "def throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:\n    \"\"\"\n    Return probability list of all possible sums when throwing dice.\n\n    >>> random.seed(0)\n    >>> throw_dice(10, 1)\n    [10.0, 0.0, 30.0, 50.0, 10.0, 0.0]\n    >>> throw_dice(100, 1)\n    [19.0, 17.0, 17.0, 11.0, 23.0, 13.0]\n    >>> throw_dice(1000, 1)\n    [18.8, 15.5, 16.3, 17.6, 14.2, 17.6]\n    >>> throw_dice(10000, 1)\n    [16.35, 16.89, 16.93, 16.6, 16.52, 16.71]\n    >>> throw_dice(10000, 2)\n    [2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]\n    \"\"\"\n    dices = [Dice() for i in range(num_dice)]\n    count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)\n    for _ in range(num_throws):\n        count_of_sum[sum(dice.roll() for dice in dices)] += 1\n    probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]\n    return probability[num_dice:]  # remove probability of sums that never appear",
    "docstring": "Return probability list of all possible sums when throwing dice.\n\n>>> random.seed(0)\n>>> throw_dice(10, 1)\n[10.0, 0.0, 30.0, 50.0, 10.0, 0.0]\n>>> throw_dice(100, 1)\n[19.0, 17.0, 17.0, 11.0, 23.0, 13.0]\n>>> throw_dice(1000, 1)\n[18.8, 15.5, 16.3, 17.6, 14.2, 17.6]\n>>> throw_dice(10000, 1)\n[16.35, 16.89, 16.93, 16.6, 16.52, 16.71]\n>>> throw_dice(10000, 2)\n[2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]"
  },
  {
    "function": "num_digits",
    "code": "def num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    >>> num_digits(0)\n    1\n    >>> num_digits(-1)\n    1\n    >>> num_digits(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    digits = 0\n    n = abs(n)\n    while True:\n        n = n // 10\n        digits += 1\n        if n == 0:\n            break\n    return digits",
    "docstring": "Find the number of digits in a number.\n\n>>> num_digits(12345)\n5\n>>> num_digits(123)\n3\n>>> num_digits(0)\n1\n>>> num_digits(-1)\n1\n>>> num_digits(-123456)\n6\n>>> num_digits('123')  # Raises a TypeError for non-integer input\nTraceback (most recent call last):\n    ...\nTypeError: Input must be an integer"
  },
  {
    "function": "num_digits_fast",
    "code": "def num_digits_fast(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used as logarithm for negative numbers is not defined.\n\n    >>> num_digits_fast(12345)\n    5\n    >>> num_digits_fast(123)\n    3\n    >>> num_digits_fast(0)\n    1\n    >>> num_digits_fast(-1)\n    1\n    >>> num_digits_fast(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return 1 if n == 0 else math.floor(math.log(abs(n), 10) + 1)",
    "docstring": "Find the number of digits in a number.\nabs() is used as logarithm for negative numbers is not defined.\n\n>>> num_digits_fast(12345)\n5\n>>> num_digits_fast(123)\n3\n>>> num_digits_fast(0)\n1\n>>> num_digits_fast(-1)\n1\n>>> num_digits_fast(-123456)\n6\n>>> num_digits('123')  # Raises a TypeError for non-integer input\nTraceback (most recent call last):\n    ...\nTypeError: Input must be an integer"
  },
  {
    "function": "num_digits_faster",
    "code": "def num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))",
    "docstring": "Find the number of digits in a number.\nabs() is used for negative numbers\n\n>>> num_digits_faster(12345)\n5\n>>> num_digits_faster(123)\n3\n>>> num_digits_faster(0)\n1\n>>> num_digits_faster(-1)\n1\n>>> num_digits_faster(-123456)\n6\n>>> num_digits('123')  # Raises a TypeError for non-integer input\nTraceback (most recent call last):\n    ...\nTypeError: Input must be an integer"
  },
  {
    "function": "benchmark",
    "code": "def benchmark() -> None:\n    \"\"\"\n    Benchmark multiple functions, with three different length int values.\n    \"\"\"\n    from collections.abc import Callable\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        print(f\"{call}: {func(value)} -- {timing} seconds\")\n\n    for value in (262144, 1125899906842624, 1267650600228229401496703205376):\n        for func in (num_digits, num_digits_fast, num_digits_faster):\n            benchmark_a_function(func, value)\n        print()",
    "docstring": "Benchmark multiple functions, with three different length int values."
  },
  {
    "function": "odd_sieve",
    "code": "def odd_sieve(num: int) -> list[int]:\n    \"\"\"\n    Returns the prime numbers < `num`. The prime numbers are calculated using an\n    odd sieve implementation of the Sieve of Eratosthenes algorithm\n    (see for reference https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).\n\n    >>> odd_sieve(2)\n    []\n    >>> odd_sieve(3)\n    [2]\n    >>> odd_sieve(10)\n    [2, 3, 5, 7]\n    >>> odd_sieve(20)\n    [2, 3, 5, 7, 11, 13, 17, 19]\n    \"\"\"\n\n    if num <= 2:\n        return []\n    if num == 3:\n        return [2]\n\n    # Odd sieve for numbers in range [3, num - 1]\n    sieve = bytearray(b\"\\x01\") * ((num >> 1) - 1)\n\n    for i in range(3, int(sqrt(num)) + 1, 2):\n        if sieve[(i >> 1) - 1]:\n            i_squared = i**2\n            sieve[(i_squared >> 1) - 1 :: i] = repeat(\n                0, ceil((num - i_squared) / (i << 1))\n            )\n\n    return [2, *list(compress(range(3, num, 2), sieve))]",
    "docstring": "Returns the prime numbers < `num`. The prime numbers are calculated using an\nodd sieve implementation of the Sieve of Eratosthenes algorithm\n(see for reference https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).\n\n>>> odd_sieve(2)\n[]\n>>> odd_sieve(3)\n[2]\n>>> odd_sieve(10)\n[2, 3, 5, 7]\n>>> odd_sieve(20)\n[2, 3, 5, 7, 11, 13, 17, 19]"
  },
  {
    "function": "perfect_cube",
    "code": "def perfect_cube(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not.\n\n    >>> perfect_cube(27)\n    True\n    >>> perfect_cube(4)\n    False\n    \"\"\"\n    val = n ** (1 / 3)\n    return (val * val * val) == n",
    "docstring": "Check if a number is a perfect cube or not.\n\n>>> perfect_cube(27)\nTrue\n>>> perfect_cube(4)\nFalse"
  },
  {
    "function": "perfect_cube_binary_search",
    "code": "def perfect_cube_binary_search(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not using binary search.\n    Time complexity : O(Log(n))\n    Space complexity: O(1)\n\n    >>> perfect_cube_binary_search(27)\n    True\n    >>> perfect_cube_binary_search(64)\n    True\n    >>> perfect_cube_binary_search(4)\n    False\n    >>> perfect_cube_binary_search(\"a\")\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    >>> perfect_cube_binary_search(0.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"perfect_cube_binary_search() only accepts integers\")\n    if n < 0:\n        n = -n\n    left = 0\n    right = n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid * mid == n:\n            return True\n        elif mid * mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False",
    "docstring": "Check if a number is a perfect cube or not using binary search.\nTime complexity : O(Log(n))\nSpace complexity: O(1)\n\n>>> perfect_cube_binary_search(27)\nTrue\n>>> perfect_cube_binary_search(64)\nTrue\n>>> perfect_cube_binary_search(4)\nFalse\n>>> perfect_cube_binary_search(\"a\")\nTraceback (most recent call last):\n    ...\nTypeError: perfect_cube_binary_search() only accepts integers\n>>> perfect_cube_binary_search(0.1)\nTraceback (most recent call last):\n    ...\nTypeError: perfect_cube_binary_search() only accepts integers"
  },
  {
    "function": "perfect",
    "code": "def perfect(number: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect number.\n\n    A perfect number is a positive integer that is equal to the sum of its proper\n    divisors (excluding itself).\n\n    Args:\n        number: The number to be checked.\n\n    Returns:\n        True if the number is a perfect number otherwise, False.\n    Start from 1 because dividing by 0 will raise ZeroDivisionError.\n    A number at most can be divisible by the half of the number except the number\n    itself. For example, 6 is at most can be divisible by 3 except by 6 itself.\n    Examples:\n    >>> perfect(27)\n    False\n    >>> perfect(28)\n    True\n    >>> perfect(29)\n    False\n    >>> perfect(6)\n    True\n    >>> perfect(12)\n    False\n    >>> perfect(496)\n    True\n    >>> perfect(8128)\n    True\n    >>> perfect(0)\n    False\n    >>> perfect(-1)\n    False\n    >>> perfect(33550336)  # Large perfect number\n    True\n    >>> perfect(33550337)  # Just above a large perfect number\n    False\n    >>> perfect(1)  # Edge case: 1 is not a perfect number\n    False\n    >>> perfect(\"123\")  # String representation of a number\n    Traceback (most recent call last):\n    ...\n    ValueError: number must be an integer\n    >>> perfect(12.34)\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    >>> perfect(\"Hello\")\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        raise ValueError(\"number must be an integer\")\n    if number <= 0:\n        return False\n    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number",
    "docstring": "Check if a number is a perfect number.\n\nA perfect number is a positive integer that is equal to the sum of its proper\ndivisors (excluding itself).\n\nArgs:\n    number: The number to be checked.\n\nReturns:\n    True if the number is a perfect number otherwise, False.\nStart from 1 because dividing by 0 will raise ZeroDivisionError.\nA number at most can be divisible by the half of the number except the number\nitself. For example, 6 is at most can be divisible by 3 except by 6 itself.\nExamples:\n>>> perfect(27)\nFalse\n>>> perfect(28)\nTrue\n>>> perfect(29)\nFalse\n>>> perfect(6)\nTrue\n>>> perfect(12)\nFalse\n>>> perfect(496)\nTrue\n>>> perfect(8128)\nTrue\n>>> perfect(0)\nFalse\n>>> perfect(-1)\nFalse\n>>> perfect(33550336)  # Large perfect number\nTrue\n>>> perfect(33550337)  # Just above a large perfect number\nFalse\n>>> perfect(1)  # Edge case: 1 is not a perfect number\nFalse\n>>> perfect(\"123\")  # String representation of a number\nTraceback (most recent call last):\n...\nValueError: number must be an integer\n>>> perfect(12.34)\nTraceback (most recent call last):\n  ...\nValueError: number must be an integer\n>>> perfect(\"Hello\")\nTraceback (most recent call last):\n  ...\nValueError: number must be an integer"
  },
  {
    "function": "perfect_square",
    "code": "def perfect_square(num: int) -> bool:\n    \"\"\"\n    Check if a number is perfect square number or not\n    :param num: the number to be checked\n    :return: True if number is square number, otherwise False\n\n    >>> perfect_square(9)\n    True\n    >>> perfect_square(16)\n    True\n    >>> perfect_square(1)\n    True\n    >>> perfect_square(0)\n    True\n    >>> perfect_square(10)\n    False\n    \"\"\"\n    return math.sqrt(num) * math.sqrt(num) == num",
    "docstring": "Check if a number is perfect square number or not\n:param num: the number to be checked\n:return: True if number is square number, otherwise False\n\n>>> perfect_square(9)\nTrue\n>>> perfect_square(16)\nTrue\n>>> perfect_square(1)\nTrue\n>>> perfect_square(0)\nTrue\n>>> perfect_square(10)\nFalse"
  },
  {
    "function": "perfect_square_binary_search",
    "code": "def perfect_square_binary_search(n: int) -> bool:\n    \"\"\"\n    Check if a number is perfect square using binary search.\n    Time complexity : O(Log(n))\n    Space complexity: O(1)\n\n    >>> perfect_square_binary_search(9)\n    True\n    >>> perfect_square_binary_search(16)\n    True\n    >>> perfect_square_binary_search(1)\n    True\n    >>> perfect_square_binary_search(0)\n    True\n    >>> perfect_square_binary_search(10)\n    False\n    >>> perfect_square_binary_search(-1)\n    False\n    >>> perfect_square_binary_search(1.1)\n    False\n    >>> perfect_square_binary_search(\"a\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> perfect_square_binary_search(None)\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'NoneType'\n    >>> perfect_square_binary_search([])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n    \"\"\"\n    left = 0\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        if mid**2 == n:\n            return True\n        elif mid**2 > n:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False",
    "docstring": "Check if a number is perfect square using binary search.\nTime complexity : O(Log(n))\nSpace complexity: O(1)\n\n>>> perfect_square_binary_search(9)\nTrue\n>>> perfect_square_binary_search(16)\nTrue\n>>> perfect_square_binary_search(1)\nTrue\n>>> perfect_square_binary_search(0)\nTrue\n>>> perfect_square_binary_search(10)\nFalse\n>>> perfect_square_binary_search(-1)\nFalse\n>>> perfect_square_binary_search(1.1)\nFalse\n>>> perfect_square_binary_search(\"a\")\nTraceback (most recent call last):\n    ...\nTypeError: '<=' not supported between instances of 'int' and 'str'\n>>> perfect_square_binary_search(None)\nTraceback (most recent call last):\n    ...\nTypeError: '<=' not supported between instances of 'int' and 'NoneType'\n>>> perfect_square_binary_search([])\nTraceback (most recent call last):\n    ...\nTypeError: '<=' not supported between instances of 'int' and 'list'"
  },
  {
    "function": "multiplicative_persistence",
    "code": "def multiplicative_persistence(num: int) -> int:\n    \"\"\"\n    Return the persistence of a given number.\n\n    https://en.wikipedia.org/wiki/Persistence_of_a_number\n\n    >>> multiplicative_persistence(217)\n    2\n    >>> multiplicative_persistence(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: multiplicative_persistence() does not accept negative values\n    >>> multiplicative_persistence(\"long number\")\n    Traceback (most recent call last):\n        ...\n    ValueError: multiplicative_persistence() only accepts integral values\n    \"\"\"\n\n    if not isinstance(num, int):\n        raise ValueError(\"multiplicative_persistence() only accepts integral values\")\n    if num < 0:\n        raise ValueError(\"multiplicative_persistence() does not accept negative values\")\n\n    steps = 0\n    num_string = str(num)\n\n    while len(num_string) != 1:\n        numbers = [int(i) for i in num_string]\n\n        total = 1\n        for i in range(len(numbers)):\n            total *= numbers[i]\n\n        num_string = str(total)\n\n        steps += 1\n    return steps",
    "docstring": "Return the persistence of a given number.\n\nhttps://en.wikipedia.org/wiki/Persistence_of_a_number\n\n>>> multiplicative_persistence(217)\n2\n>>> multiplicative_persistence(-1)\nTraceback (most recent call last):\n    ...\nValueError: multiplicative_persistence() does not accept negative values\n>>> multiplicative_persistence(\"long number\")\nTraceback (most recent call last):\n    ...\nValueError: multiplicative_persistence() only accepts integral values"
  },
  {
    "function": "additive_persistence",
    "code": "def additive_persistence(num: int) -> int:\n    \"\"\"\n    Return the persistence of a given number.\n\n    https://en.wikipedia.org/wiki/Persistence_of_a_number\n\n    >>> additive_persistence(199)\n    3\n    >>> additive_persistence(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: additive_persistence() does not accept negative values\n    >>> additive_persistence(\"long number\")\n    Traceback (most recent call last):\n        ...\n    ValueError: additive_persistence() only accepts integral values\n    \"\"\"\n\n    if not isinstance(num, int):\n        raise ValueError(\"additive_persistence() only accepts integral values\")\n    if num < 0:\n        raise ValueError(\"additive_persistence() does not accept negative values\")\n\n    steps = 0\n    num_string = str(num)\n\n    while len(num_string) != 1:\n        numbers = [int(i) for i in num_string]\n\n        total = 0\n        for i in range(len(numbers)):\n            total += numbers[i]\n\n        num_string = str(total)\n\n        steps += 1\n    return steps",
    "docstring": "Return the persistence of a given number.\n\nhttps://en.wikipedia.org/wiki/Persistence_of_a_number\n\n>>> additive_persistence(199)\n3\n>>> additive_persistence(-1)\nTraceback (most recent call last):\n    ...\nValueError: additive_persistence() does not accept negative values\n>>> additive_persistence(\"long number\")\nTraceback (most recent call last):\n    ...\nValueError: additive_persistence() only accepts integral values"
  },
  {
    "function": "calculate_pi",
    "code": "def calculate_pi(limit: int) -> str:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80\n    Leibniz Formula for Pi\n\n    The Leibniz formula is the special case arctan(1) = pi / 4.\n    Leibniz's formula converges extremely slowly: it exhibits sublinear convergence.\n\n    Convergence (https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Convergence)\n\n    We cannot try to prove against an interrupted, uncompleted generation.\n    https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Unusual_behaviour\n    The errors can in fact be predicted, but those calculations also approach infinity\n    for accuracy.\n\n    Our output will be a string so that we can definitely store all digits.\n\n    >>> import math\n    >>> float(calculate_pi(15)) == math.pi\n    True\n\n    Since we cannot predict errors or interrupt any infinite alternating series\n    generation since they approach infinity, or interrupt any alternating series, we'll\n    need math.isclose()\n\n    >>> math.isclose(float(calculate_pi(50)), math.pi)\n    True\n    >>> math.isclose(float(calculate_pi(100)), math.pi)\n    True\n\n    Since math.pi contains only 16 digits, here are some tests with known values:\n\n    >>> calculate_pi(50)\n    '3.14159265358979323846264338327950288419716939937510'\n    >>> calculate_pi(80)\n    '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899'\n    \"\"\"\n    # Variables used for the iteration process\n    q = 1\n    r = 0\n    t = 1\n    k = 1\n    n = 3\n    m = 3\n\n    decimal = limit\n    counter = 0\n\n    result = \"\"\n\n    # We can't compare against anything if we make a generator,\n    # so we'll stick with plain return logic\n    while counter != decimal + 1:\n        if 4 * q + r - t < n * t:\n            result += str(n)\n            if counter == 0:\n                result += \".\"\n\n            if decimal == counter:\n                break\n\n            counter += 1\n            nr = 10 * (r - n * t)\n            n = ((10 * (3 * q + r)) // t) - 10 * n\n            q *= 10\n            r = nr\n        else:\n            nr = (2 * q + r) * m\n            nn = (q * (7 * k) + 2 + (r * m)) // (t * m)\n            q *= k\n            t *= m\n            m += 2\n            k += 1\n            n = nn\n            r = nr\n    return result",
    "docstring": "https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80\nLeibniz Formula for Pi\n\nThe Leibniz formula is the special case arctan(1) = pi / 4.\nLeibniz's formula converges extremely slowly: it exhibits sublinear convergence.\n\nConvergence (https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Convergence)\n\nWe cannot try to prove against an interrupted, uncompleted generation.\nhttps://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Unusual_behaviour\nThe errors can in fact be predicted, but those calculations also approach infinity\nfor accuracy.\n\nOur output will be a string so that we can definitely store all digits.\n\n>>> import math\n>>> float(calculate_pi(15)) == math.pi\nTrue\n\nSince we cannot predict errors or interrupt any infinite alternating series\ngeneration since they approach infinity, or interrupt any alternating series, we'll\nneed math.isclose()\n\n>>> math.isclose(float(calculate_pi(50)), math.pi)\nTrue\n>>> math.isclose(float(calculate_pi(100)), math.pi)\nTrue\n\nSince math.pi contains only 16 digits, here are some tests with known values:\n\n>>> calculate_pi(50)\n'3.14159265358979323846264338327950288419716939937510'\n>>> calculate_pi(80)\n'3.14159265358979323846264338327950288419716939937510582097494459230781640628620899'"
  },
  {
    "function": "estimate_pi",
    "code": "def estimate_pi(number_of_simulations: int) -> float:\n    \"\"\"\n    Generates an estimate of the mathematical constant PI.\n    See https://en.wikipedia.org/wiki/Monte_Carlo_method#Overview\n\n    The estimate is generated by Monte Carlo simulations. Let U be uniformly drawn from\n    the unit square [0, 1) x [0, 1). The probability that U lies in the unit circle is:\n\n        P[U in unit circle] = 1/4 PI\n\n    and therefore\n\n        PI = 4 * P[U in unit circle]\n\n    We can get an estimate of the probability P[U in unit circle].\n    See https://en.wikipedia.org/wiki/Empirical_probability by:\n\n        1. Draw a point uniformly from the unit square.\n        2. Repeat the first step n times and count the number of points in the unit\n            circle, which is called m.\n        3. An estimate of P[U in unit circle] is m/n\n    \"\"\"\n    if number_of_simulations < 1:\n        raise ValueError(\"At least one simulation is necessary to estimate PI.\")\n\n    number_in_unit_circle = 0\n    for _ in range(number_of_simulations):\n        random_point = Point.random_unit_square()\n\n        if random_point.is_in_unit_circle():\n            number_in_unit_circle += 1\n\n    return 4 * number_in_unit_circle / number_of_simulations",
    "docstring": "Generates an estimate of the mathematical constant PI.\nSee https://en.wikipedia.org/wiki/Monte_Carlo_method#Overview\n\nThe estimate is generated by Monte Carlo simulations. Let U be uniformly drawn from\nthe unit square [0, 1) x [0, 1). The probability that U lies in the unit circle is:\n\n    P[U in unit circle] = 1/4 PI\n\nand therefore\n\n    PI = 4 * P[U in unit circle]\n\nWe can get an estimate of the probability P[U in unit circle].\nSee https://en.wikipedia.org/wiki/Empirical_probability by:\n\n    1. Draw a point uniformly from the unit square.\n    2. Repeat the first step n times and count the number of points in the unit\n        circle, which is called m.\n    3. An estimate of P[U in unit circle] is m/n"
  },
  {
    "function": "create_vector",
    "code": "def create_vector(end_point1: Point3d, end_point2: Point3d) -> Vector3d:\n    \"\"\"\n    Pass two points to get the vector from them in the form (x, y, z).\n\n    >>> create_vector((0, 0, 0), (1, 1, 1))\n    (1, 1, 1)\n    >>> create_vector((45, 70, 24), (47, 32, 1))\n    (2, -38, -23)\n    >>> create_vector((-14, -1, -8), (-7, 6, 4))\n    (7, 7, 12)\n    \"\"\"\n    x = end_point2[0] - end_point1[0]\n    y = end_point2[1] - end_point1[1]\n    z = end_point2[2] - end_point1[2]\n    return (x, y, z)",
    "docstring": "Pass two points to get the vector from them in the form (x, y, z).\n\n>>> create_vector((0, 0, 0), (1, 1, 1))\n(1, 1, 1)\n>>> create_vector((45, 70, 24), (47, 32, 1))\n(2, -38, -23)\n>>> create_vector((-14, -1, -8), (-7, 6, 4))\n(7, 7, 12)"
  },
  {
    "function": "get_3d_vectors_cross",
    "code": "def get_3d_vectors_cross(ab: Vector3d, ac: Vector3d) -> Vector3d:\n    \"\"\"\n    Get the cross of the two vectors AB and AC.\n\n    I used determinant of 2x2 to get the determinant of the 3x3 matrix in the process.\n\n    Read More:\n        https://en.wikipedia.org/wiki/Cross_product\n        https://en.wikipedia.org/wiki/Determinant\n\n    >>> get_3d_vectors_cross((3, 4, 7), (4, 9, 2))\n    (-55, 22, 11)\n    >>> get_3d_vectors_cross((1, 1, 1), (1, 1, 1))\n    (0, 0, 0)\n    >>> get_3d_vectors_cross((-4, 3, 0), (3, -9, -12))\n    (-36, -48, 27)\n    >>> get_3d_vectors_cross((17.67, 4.7, 6.78), (-9.5, 4.78, -19.33))\n    (-123.2594, 277.15110000000004, 129.11260000000001)\n    \"\"\"\n    x = ab[1] * ac[2] - ab[2] * ac[1]  # *i\n    y = (ab[0] * ac[2] - ab[2] * ac[0]) * -1  # *j\n    z = ab[0] * ac[1] - ab[1] * ac[0]  # *k\n    return (x, y, z)",
    "docstring": "Get the cross of the two vectors AB and AC.\n\nI used determinant of 2x2 to get the determinant of the 3x3 matrix in the process.\n\nRead More:\n    https://en.wikipedia.org/wiki/Cross_product\n    https://en.wikipedia.org/wiki/Determinant\n\n>>> get_3d_vectors_cross((3, 4, 7), (4, 9, 2))\n(-55, 22, 11)\n>>> get_3d_vectors_cross((1, 1, 1), (1, 1, 1))\n(0, 0, 0)\n>>> get_3d_vectors_cross((-4, 3, 0), (3, -9, -12))\n(-36, -48, 27)\n>>> get_3d_vectors_cross((17.67, 4.7, 6.78), (-9.5, 4.78, -19.33))\n(-123.2594, 277.15110000000004, 129.11260000000001)"
  },
  {
    "function": "is_zero_vector",
    "code": "def is_zero_vector(vector: Vector3d, accuracy: int) -> bool:\n    \"\"\"\n    Check if vector is equal to (0, 0, 0) or not.\n\n    Since the algorithm is very accurate, we will never get a zero vector,\n    so we need to round the vector axis,\n    because we want a result that is either True or False.\n    In other applications, we can return a float that represents the collinearity ratio.\n\n    >>> is_zero_vector((0, 0, 0), accuracy=10)\n    True\n    >>> is_zero_vector((15, 74, 32), accuracy=10)\n    False\n    >>> is_zero_vector((-15, -74, -32), accuracy=10)\n    False\n    \"\"\"\n    return tuple(round(x, accuracy) for x in vector) == (0, 0, 0)",
    "docstring": "Check if vector is equal to (0, 0, 0) or not.\n\nSince the algorithm is very accurate, we will never get a zero vector,\nso we need to round the vector axis,\nbecause we want a result that is either True or False.\nIn other applications, we can return a float that represents the collinearity ratio.\n\n>>> is_zero_vector((0, 0, 0), accuracy=10)\nTrue\n>>> is_zero_vector((15, 74, 32), accuracy=10)\nFalse\n>>> is_zero_vector((-15, -74, -32), accuracy=10)\nFalse"
  },
  {
    "function": "are_collinear",
    "code": "def are_collinear(a: Point3d, b: Point3d, c: Point3d, accuracy: int = 10) -> bool:\n    \"\"\"\n    Check if three points are collinear or not.\n\n    1- Create two vectors AB and AC.\n    2- Get the cross vector of the two vectors.\n    3- Calculate the length of the cross vector.\n    4- If the length is zero then the points are collinear, else they are not.\n\n    The use of the accuracy parameter is explained in is_zero_vector docstring.\n\n    >>> are_collinear((4.802293498137402, 3.536233125455244, 0),\n    ...               (-2.186788107953106, -9.24561398001649, 7.141509524846482),\n    ...               (1.530169574640268, -2.447927606600034, 3.343487096469054))\n    True\n    >>> are_collinear((-6, -2, 6),\n    ...               (6.200213806439997, -4.930157614926678, -4.482371908289856),\n    ...               (-4.085171149525941, -2.459889509029438, 4.354787180795383))\n    True\n    >>> are_collinear((2.399001826862445, -2.452009976680793, 4.464656666157666),\n    ...               (-3.682816335934376, 5.753788986533145, 9.490993909044244),\n    ...               (1.962903518985307, 3.741415730125627, 7))\n    False\n    >>> are_collinear((1.875375340689544, -7.268426006071538, 7.358196269835993),\n    ...               (-3.546599383667157, -4.630005261513976, 3.208784032924246),\n    ...               (-2.564606140206386, 3.937845170672183, 7))\n    False\n    \"\"\"\n    ab = create_vector(a, b)\n    ac = create_vector(a, c)\n    return is_zero_vector(get_3d_vectors_cross(ab, ac), accuracy)",
    "docstring": "Check if three points are collinear or not.\n\n1- Create two vectors AB and AC.\n2- Get the cross vector of the two vectors.\n3- Calculate the length of the cross vector.\n4- If the length is zero then the points are collinear, else they are not.\n\nThe use of the accuracy parameter is explained in is_zero_vector docstring.\n\n>>> are_collinear((4.802293498137402, 3.536233125455244, 0),\n...               (-2.186788107953106, -9.24561398001649, 7.141509524846482),\n...               (1.530169574640268, -2.447927606600034, 3.343487096469054))\nTrue\n>>> are_collinear((-6, -2, 6),\n...               (6.200213806439997, -4.930157614926678, -4.482371908289856),\n...               (-4.085171149525941, -2.459889509029438, 4.354787180795383))\nTrue\n>>> are_collinear((2.399001826862445, -2.452009976680793, 4.464656666157666),\n...               (-3.682816335934376, 5.753788986533145, 9.490993909044244),\n...               (1.962903518985307, 3.741415730125627, 7))\nFalse\n>>> are_collinear((1.875375340689544, -7.268426006071538, 7.358196269835993),\n...               (-3.546599383667157, -4.630005261513976, 3.208784032924246),\n...               (-2.564606140206386, 3.937845170672183, 7))\nFalse"
  },
  {
    "function": "pollard_rho",
    "code": "def pollard_rho(\n    num: int,\n    seed: int = 2,\n    step: int = 1,\n    attempts: int = 3,\n) -> int | None:\n    \"\"\"\n    Use Pollard's Rho algorithm to return a nontrivial factor of ``num``.\n    The returned factor may be composite and require further factorization.\n    If the algorithm will return None if it fails to find a factor within\n    the specified number of attempts or within the specified number of steps.\n    If ``num`` is prime, this algorithm is guaranteed to return None.\n    https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\n\n    >>> pollard_rho(18446744073709551617)\n    274177\n    >>> pollard_rho(97546105601219326301)\n    9876543191\n    >>> pollard_rho(100)\n    2\n    >>> pollard_rho(17)\n    >>> pollard_rho(17**3)\n    17\n    >>> pollard_rho(17**3, attempts=1)\n    >>> pollard_rho(3*5*7)\n    21\n    >>> pollard_rho(1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value cannot be less than 2\n    \"\"\"\n    # A value less than 2 can cause an infinite loop in the algorithm.\n    if num < 2:\n        raise ValueError(\"The input value cannot be less than 2\")\n\n    # Because of the relationship between ``f(f(x))`` and ``f(x)``, this\n    # algorithm struggles to find factors that are divisible by two.\n    # As a workaround, we specifically check for two and even inputs.\n    #   See: https://math.stackexchange.com/a/2856214/165820\n    if num > 2 and num % 2 == 0:\n        return 2\n\n    # Pollard's Rho algorithm requires a function that returns pseudorandom\n    # values between 0 <= X < ``num``.  It doesn't need to be random in the\n    # sense that the output value is cryptographically secure or difficult\n    # to calculate, it only needs to be random in the sense that all output\n    # values should be equally likely to appear.\n    # For this reason, Pollard suggested using ``f(x) = (x**2 - 1) % num``\n    # However, the success of Pollard's algorithm isn't guaranteed and is\n    # determined in part by the initial seed and the chosen random function.\n    # To make retries easier, we will instead use ``f(x) = (x**2 + C) % num``\n    # where ``C`` is a value that we can modify between each attempt.\n    def rand_fn(value: int, step: int, modulus: int) -> int:\n        \"\"\"\n        Returns a pseudorandom value modulo ``modulus`` based on the\n        input ``value`` and attempt-specific ``step`` size.\n\n        >>> rand_fn(0, 0, 0)\n        Traceback (most recent call last):\n            ...\n        ZeroDivisionError: integer division or modulo by zero\n        >>> rand_fn(1, 2, 3)\n        0\n        >>> rand_fn(0, 10, 7)\n        3\n        >>> rand_fn(1234, 1, 17)\n        16\n        \"\"\"\n        return (pow(value, 2) + step) % modulus\n\n    for _ in range(attempts):\n        # These track the position within the cycle detection logic.\n        tortoise = seed\n        hare = seed\n\n        while True:\n            # At each iteration, the tortoise moves one step and the hare moves two.\n            tortoise = rand_fn(tortoise, step, num)\n            hare = rand_fn(hare, step, num)\n            hare = rand_fn(hare, step, num)\n\n            # At some point both the tortoise and the hare will enter a cycle whose\n            # length ``p`` is a divisor of ``num``.  Once in that cycle, at some point\n            # the tortoise and hare will end up on the same value modulo ``p``.\n            # We can detect when this happens because the position difference between\n            # the tortoise and the hare will share a common divisor with ``num``.\n            divisor = gcd(hare - tortoise, num)\n\n            if divisor == 1:\n                # No common divisor yet, just keep searching.\n                continue\n            # We found a common divisor!\n            elif divisor == num:\n                # Unfortunately, the divisor is ``num`` itself and is useless.\n                break\n            else:\n                # The divisor is a nontrivial factor of ``num``!\n                return divisor\n\n        # If we made it here, then this attempt failed.\n        # We need to pick a new starting seed for the tortoise and hare\n        # in addition to a new step value for the random function.\n        # To keep this example implementation deterministic, the\n        # new values will be generated based on currently available\n        # values instead of using something like ``random.randint``.\n\n        # We can use the hare's position as the new seed.\n        # This is actually what Richard Brent's the \"optimized\" variant does.\n        seed = hare\n\n        # The new step value for the random function can just be incremented.\n        # At first the results will be similar to what the old function would\n        # have produced, but the value will quickly diverge after a bit.\n        step += 1\n\n    # We haven't found a divisor within the requested number of attempts.\n    # We were unlucky or ``num`` itself is actually prime.\n    return None",
    "docstring": "Use Pollard's Rho algorithm to return a nontrivial factor of ``num``.\nThe returned factor may be composite and require further factorization.\nIf the algorithm will return None if it fails to find a factor within\nthe specified number of attempts or within the specified number of steps.\nIf ``num`` is prime, this algorithm is guaranteed to return None.\nhttps://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\n\n>>> pollard_rho(18446744073709551617)\n274177\n>>> pollard_rho(97546105601219326301)\n9876543191\n>>> pollard_rho(100)\n2\n>>> pollard_rho(17)\n>>> pollard_rho(17**3)\n17\n>>> pollard_rho(17**3, attempts=1)\n>>> pollard_rho(3*5*7)\n21\n>>> pollard_rho(1)\nTraceback (most recent call last):\n    ...\nValueError: The input value cannot be less than 2"
  },
  {
    "function": "evaluate_poly",
    "code": "def evaluate_poly(poly: Sequence[float], x: float) -> float:\n    \"\"\"Evaluate a polynomial f(x) at specified point x and return the value.\n\n    Arguments:\n    poly -- the coefficients of a polynomial as an iterable in order of\n            ascending degree\n    x -- the point at which to evaluate the polynomial\n\n    >>> evaluate_poly((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)\n    79800.0\n    \"\"\"\n    return sum(c * (x**i) for i, c in enumerate(poly))",
    "docstring": "Evaluate a polynomial f(x) at specified point x and return the value.\n\nArguments:\npoly -- the coefficients of a polynomial as an iterable in order of\n        ascending degree\nx -- the point at which to evaluate the polynomial\n\n>>> evaluate_poly((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)\n79800.0"
  },
  {
    "function": "horner",
    "code": "def horner(poly: Sequence[float], x: float) -> float:\n    \"\"\"Evaluate a polynomial at specified point using Horner's method.\n\n    In terms of computational complexity, Horner's method is an efficient method\n    of evaluating a polynomial. It avoids the use of expensive exponentiation,\n    and instead uses only multiplication and addition to evaluate the polynomial\n    in O(n), where n is the degree of the polynomial.\n\n    https://en.wikipedia.org/wiki/Horner's_method\n\n    Arguments:\n    poly -- the coefficients of a polynomial as an iterable in order of\n            ascending degree\n    x -- the point at which to evaluate the polynomial\n\n    >>> horner((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)\n    79800.0\n    \"\"\"\n    result = 0.0\n    for coeff in reversed(poly):\n        result = result * x + coeff\n    return result",
    "docstring": "Evaluate a polynomial at specified point using Horner's method.\n\nIn terms of computational complexity, Horner's method is an efficient method\nof evaluating a polynomial. It avoids the use of expensive exponentiation,\nand instead uses only multiplication and addition to evaluate the polynomial\nin O(n), where n is the degree of the polynomial.\n\nhttps://en.wikipedia.org/wiki/Horner's_method\n\nArguments:\npoly -- the coefficients of a polynomial as an iterable in order of\n        ascending degree\nx -- the point at which to evaluate the polynomial\n\n>>> horner((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)\n79800.0"
  },
  {
    "function": "power",
    "code": "def power(base: int, exponent: int) -> float:\n    \"\"\"\n    Calculate the power of a base raised to an exponent.\n\n    >>> power(3, 4)\n    81\n    >>> power(2, 0)\n    1\n    >>> all(power(base, exponent) == pow(base, exponent)\n    ...     for base in range(-10, 10) for exponent in range(10))\n    True\n    >>> power('a', 1)\n    'a'\n    >>> power('a', 2)\n    Traceback (most recent call last):\n        ...\n    TypeError: can't multiply sequence by non-int of type 'str'\n    >>> power('a', 'b')\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'str' and 'int'\n    >>> power(2, -1)\n    Traceback (most recent call last):\n        ...\n    RecursionError: maximum recursion depth exceeded\n    >>> power(0, 0)\n    1\n    >>> power(0, 1)\n    0\n    >>> power(5,6)\n    15625\n    >>> power(23, 12)\n    21914624432020321\n    \"\"\"\n    return base * power(base, (exponent - 1)) if exponent else 1",
    "docstring": "Calculate the power of a base raised to an exponent.\n\n>>> power(3, 4)\n81\n>>> power(2, 0)\n1\n>>> all(power(base, exponent) == pow(base, exponent)\n...     for base in range(-10, 10) for exponent in range(10))\nTrue\n>>> power('a', 1)\n'a'\n>>> power('a', 2)\nTraceback (most recent call last):\n    ...\nTypeError: can't multiply sequence by non-int of type 'str'\n>>> power('a', 'b')\nTraceback (most recent call last):\n    ...\nTypeError: unsupported operand type(s) for -: 'str' and 'int'\n>>> power(2, -1)\nTraceback (most recent call last):\n    ...\nRecursionError: maximum recursion depth exceeded\n>>> power(0, 0)\n1\n>>> power(0, 1)\n0\n>>> power(5,6)\n15625\n>>> power(23, 12)\n21914624432020321"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"\n    input: positive integer 'number'\n    returns true if 'number' is prime otherwise false.\n\n    >>> is_prime(3)\n    True\n    >>> is_prime(10)\n    False\n    >>> is_prime(97)\n    True\n    >>> is_prime(9991)\n    False\n    >>> is_prime(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and positive\n    >>> is_prime(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and positive\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and (number >= 0), (\n        \"'number' must been an int and positive\"\n    )\n\n    status = True\n\n    # 0 and 1 are none primes.\n    if number <= 1:\n        status = False\n\n    for divisor in range(2, round(sqrt(number)) + 1):\n        # if 'number' divisible by 'divisor' then sets 'status'\n        # of false and break up the loop.\n        if number % divisor == 0:\n            status = False\n            break\n\n    # precondition\n    assert isinstance(status, bool), \"'status' must been from type bool\"\n\n    return status",
    "docstring": "input: positive integer 'number'\nreturns true if 'number' is prime otherwise false.\n\n>>> is_prime(3)\nTrue\n>>> is_prime(10)\nFalse\n>>> is_prime(97)\nTrue\n>>> is_prime(9991)\nFalse\n>>> is_prime(-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and positive\n>>> is_prime(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and positive"
  },
  {
    "function": "sieve_er",
    "code": "def sieve_er(n):\n    \"\"\"\n    input: positive integer 'N' > 2\n    returns a list of prime numbers from 2 up to N.\n\n    This function implements the algorithm called\n    sieve of erathostenes.\n\n    >>> sieve_er(8)\n    [2, 3, 5, 7]\n    >>> sieve_er(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'N' must been an int and > 2\n    >>> sieve_er(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'N' must been an int and > 2\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n > 2), \"'N' must been an int and > 2\"\n\n    # beginList: contains all natural numbers from 2 up to N\n    begin_list = list(range(2, n + 1))\n\n    ans = []  # this list will be returns.\n\n    # actual sieve of erathostenes\n    for i in range(len(begin_list)):\n        for j in range(i + 1, len(begin_list)):\n            if (begin_list[i] != 0) and (begin_list[j] % begin_list[i] == 0):\n                begin_list[j] = 0\n\n    # filters actual prime numbers.\n    ans = [x for x in begin_list if x != 0]\n\n    # precondition\n    assert isinstance(ans, list), \"'ans' must been from type list\"\n\n    return ans",
    "docstring": "input: positive integer 'N' > 2\nreturns a list of prime numbers from 2 up to N.\n\nThis function implements the algorithm called\nsieve of erathostenes.\n\n>>> sieve_er(8)\n[2, 3, 5, 7]\n>>> sieve_er(-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'N' must been an int and > 2\n>>> sieve_er(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'N' must been an int and > 2"
  },
  {
    "function": "get_prime_numbers",
    "code": "def get_prime_numbers(n):\n    \"\"\"\n    input: positive integer 'N' > 2\n    returns a list of prime numbers from 2 up to N (inclusive)\n    This function is more efficient as function 'sieveEr(...)'\n\n    >>> get_prime_numbers(8)\n    [2, 3, 5, 7]\n    >>> get_prime_numbers(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'N' must been an int and > 2\n    >>> get_prime_numbers(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'N' must been an int and > 2\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n > 2), \"'N' must been an int and > 2\"\n\n    ans = []\n\n    # iterates over all numbers between 2 up to N+1\n    # if a number is prime then appends to list 'ans'\n    for number in range(2, n + 1):\n        if is_prime(number):\n            ans.append(number)\n\n    # precondition\n    assert isinstance(ans, list), \"'ans' must been from type list\"\n\n    return ans",
    "docstring": "input: positive integer 'N' > 2\nreturns a list of prime numbers from 2 up to N (inclusive)\nThis function is more efficient as function 'sieveEr(...)'\n\n>>> get_prime_numbers(8)\n[2, 3, 5, 7]\n>>> get_prime_numbers(-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'N' must been an int and > 2\n>>> get_prime_numbers(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'N' must been an int and > 2"
  },
  {
    "function": "prime_factorization",
    "code": "def prime_factorization(number):\n    \"\"\"\n    input: positive integer 'number'\n    returns a list of the prime number factors of 'number'\n\n    >>> prime_factorization(0)\n    [0]\n    >>> prime_factorization(8)\n    [2, 2, 2]\n    >>> prime_factorization(287)\n    [7, 41]\n    >>> prime_factorization(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    >>> prime_factorization(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and number >= 0, \"'number' must been an int and >= 0\"\n\n    ans = []  # this list will be returns of the function.\n\n    # potential prime number factors.\n\n    factor = 2\n\n    quotient = number\n\n    if number in {0, 1}:\n        ans.append(number)\n\n    # if 'number' not prime then builds the prime factorization of 'number'\n    elif not is_prime(number):\n        while quotient != 1:\n            if is_prime(factor) and (quotient % factor == 0):\n                ans.append(factor)\n                quotient /= factor\n            else:\n                factor += 1\n\n    else:\n        ans.append(number)\n\n    # precondition\n    assert isinstance(ans, list), \"'ans' must been from type list\"\n\n    return ans",
    "docstring": "input: positive integer 'number'\nreturns a list of the prime number factors of 'number'\n\n>>> prime_factorization(0)\n[0]\n>>> prime_factorization(8)\n[2, 2, 2]\n>>> prime_factorization(287)\n[7, 41]\n>>> prime_factorization(-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and >= 0\n>>> prime_factorization(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and >= 0"
  },
  {
    "function": "greatest_prime_factor",
    "code": "def greatest_prime_factor(number):\n    \"\"\"\n    input: positive integer 'number' >= 0\n    returns the greatest prime number factor of 'number'\n\n    >>> greatest_prime_factor(0)\n    0\n    >>> greatest_prime_factor(8)\n    2\n    >>> greatest_prime_factor(287)\n    41\n    >>> greatest_prime_factor(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    >>> greatest_prime_factor(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and (number >= 0), (\n        \"'number' must been an int and >= 0\"\n    )\n\n    ans = 0\n\n    # prime factorization of 'number'\n    prime_factors = prime_factorization(number)\n\n    ans = max(prime_factors)\n\n    # precondition\n    assert isinstance(ans, int), \"'ans' must been from type int\"\n\n    return ans",
    "docstring": "input: positive integer 'number' >= 0\nreturns the greatest prime number factor of 'number'\n\n>>> greatest_prime_factor(0)\n0\n>>> greatest_prime_factor(8)\n2\n>>> greatest_prime_factor(287)\n41\n>>> greatest_prime_factor(-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and >= 0\n>>> greatest_prime_factor(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and >= 0"
  },
  {
    "function": "smallest_prime_factor",
    "code": "def smallest_prime_factor(number):\n    \"\"\"\n    input: integer 'number' >= 0\n    returns the smallest prime number factor of 'number'\n\n    >>> smallest_prime_factor(0)\n    0\n    >>> smallest_prime_factor(8)\n    2\n    >>> smallest_prime_factor(287)\n    7\n    >>> smallest_prime_factor(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    >>> smallest_prime_factor(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and (number >= 0), (\n        \"'number' must been an int and >= 0\"\n    )\n\n    ans = 0\n\n    # prime factorization of 'number'\n    prime_factors = prime_factorization(number)\n\n    ans = min(prime_factors)\n\n    # precondition\n    assert isinstance(ans, int), \"'ans' must been from type int\"\n\n    return ans",
    "docstring": "input: integer 'number' >= 0\nreturns the smallest prime number factor of 'number'\n\n>>> smallest_prime_factor(0)\n0\n>>> smallest_prime_factor(8)\n2\n>>> smallest_prime_factor(287)\n7\n>>> smallest_prime_factor(-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and >= 0\n>>> smallest_prime_factor(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and >= 0"
  },
  {
    "function": "is_even",
    "code": "def is_even(number):\n    \"\"\"\n    input: integer 'number'\n    returns true if 'number' is even, otherwise false.\n\n    >>> is_even(0)\n    True\n    >>> is_even(8)\n    True\n    >>> is_even(287)\n    False\n    >>> is_even(-1)\n    False\n    >>> is_even(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int), \"'number' must been an int\"\n    assert isinstance(number % 2 == 0, bool), \"compare must been from type bool\"\n\n    return number % 2 == 0",
    "docstring": "input: integer 'number'\nreturns true if 'number' is even, otherwise false.\n\n>>> is_even(0)\nTrue\n>>> is_even(8)\nTrue\n>>> is_even(287)\nFalse\n>>> is_even(-1)\nFalse\n>>> is_even(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int"
  },
  {
    "function": "is_odd",
    "code": "def is_odd(number):\n    \"\"\"\n    input: integer 'number'\n    returns true if 'number' is odd, otherwise false.\n\n    >>> is_odd(0)\n    False\n    >>> is_odd(8)\n    False\n    >>> is_odd(287)\n    True\n    >>> is_odd(-1)\n    True\n    >>> is_odd(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int), \"'number' must been an int\"\n    assert isinstance(number % 2 != 0, bool), \"compare must been from type bool\"\n\n    return number % 2 != 0",
    "docstring": "input: integer 'number'\nreturns true if 'number' is odd, otherwise false.\n\n>>> is_odd(0)\nFalse\n>>> is_odd(8)\nFalse\n>>> is_odd(287)\nTrue\n>>> is_odd(-1)\nTrue\n>>> is_odd(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int"
  },
  {
    "function": "goldbach",
    "code": "def goldbach(number):\n    \"\"\"\n    Goldbach's assumption\n    input: a even positive integer 'number' > 2\n    returns a list of two prime numbers whose sum is equal to 'number'\n\n    >>> goldbach(8)\n    [3, 5]\n    >>> goldbach(824)\n    [3, 821]\n    >>> goldbach(0)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int, even and > 2\n    >>> goldbach(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int, even and > 2\n    >>> goldbach(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int, even and > 2\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and (number > 2) and is_even(number), (\n        \"'number' must been an int, even and > 2\"\n    )\n\n    ans = []  # this list will returned\n\n    # creates a list of prime numbers between 2 up to 'number'\n    prime_numbers = get_prime_numbers(number)\n    len_pn = len(prime_numbers)\n\n    # run variable for while-loops.\n    i = 0\n    j = None\n\n    # exit variable. for break up the loops\n    loop = True\n\n    while i < len_pn and loop:\n        j = i + 1\n\n        while j < len_pn and loop:\n            if prime_numbers[i] + prime_numbers[j] == number:\n                loop = False\n                ans.append(prime_numbers[i])\n                ans.append(prime_numbers[j])\n\n            j += 1\n\n        i += 1\n\n    # precondition\n    assert (\n        isinstance(ans, list)\n        and (len(ans) == 2)\n        and (ans[0] + ans[1] == number)\n        and is_prime(ans[0])\n        and is_prime(ans[1])\n    ), \"'ans' must contains two primes. And sum of elements must been eq 'number'\"\n\n    return ans",
    "docstring": "Goldbach's assumption\ninput: a even positive integer 'number' > 2\nreturns a list of two prime numbers whose sum is equal to 'number'\n\n>>> goldbach(8)\n[3, 5]\n>>> goldbach(824)\n[3, 821]\n>>> goldbach(0)\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int, even and > 2\n>>> goldbach(-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int, even and > 2\n>>> goldbach(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int, even and > 2"
  },
  {
    "function": "kg_v",
    "code": "def kg_v(number1, number2):\n    \"\"\"\n    Least common multiple\n    input: two positive integer 'number1' and 'number2'\n    returns the least common multiple of 'number1' and 'number2'\n\n    >>> kg_v(8,10)\n    40\n    >>> kg_v(824,67)\n    55208\n    >>> kg_v(1, 10)\n    10\n    >>> kg_v(0)\n    Traceback (most recent call last):\n        ...\n    TypeError: kg_v() missing 1 required positional argument: 'number2'\n    >>> kg_v(10,-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number1' and 'number2' must been positive integer.\n    >>> kg_v(\"test\",\"test2\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number1' and 'number2' must been positive integer.\n    \"\"\"\n\n    # precondition\n    assert (\n        isinstance(number1, int)\n        and isinstance(number2, int)\n        and (number1 >= 1)\n        and (number2 >= 1)\n    ), \"'number1' and 'number2' must been positive integer.\"\n\n    ans = 1  # actual answer that will be return.\n\n    # for kgV (x,1)\n    if number1 > 1 and number2 > 1:\n        # builds the prime factorization of 'number1' and 'number2'\n        prime_fac_1 = prime_factorization(number1)\n        prime_fac_2 = prime_factorization(number2)\n\n    elif number1 == 1 or number2 == 1:\n        prime_fac_1 = []\n        prime_fac_2 = []\n        ans = max(number1, number2)\n\n    count1 = 0\n    count2 = 0\n\n    done = []  # captured numbers int both 'primeFac1' and 'primeFac2'\n\n    # iterates through primeFac1\n    for n in prime_fac_1:\n        if n not in done:\n            if n in prime_fac_2:\n                count1 = prime_fac_1.count(n)\n                count2 = prime_fac_2.count(n)\n\n                for _ in range(max(count1, count2)):\n                    ans *= n\n\n            else:\n                count1 = prime_fac_1.count(n)\n\n                for _ in range(count1):\n                    ans *= n\n\n            done.append(n)\n\n    # iterates through primeFac2\n    for n in prime_fac_2:\n        if n not in done:\n            count2 = prime_fac_2.count(n)\n\n            for _ in range(count2):\n                ans *= n\n\n            done.append(n)\n\n    # precondition\n    assert isinstance(ans, int) and (ans >= 0), (\n        \"'ans' must been from type int and positive\"\n    )\n\n    return ans",
    "docstring": "Least common multiple\ninput: two positive integer 'number1' and 'number2'\nreturns the least common multiple of 'number1' and 'number2'\n\n>>> kg_v(8,10)\n40\n>>> kg_v(824,67)\n55208\n>>> kg_v(1, 10)\n10\n>>> kg_v(0)\nTraceback (most recent call last):\n    ...\nTypeError: kg_v() missing 1 required positional argument: 'number2'\n>>> kg_v(10,-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'number1' and 'number2' must been positive integer.\n>>> kg_v(\"test\",\"test2\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'number1' and 'number2' must been positive integer."
  },
  {
    "function": "get_prime",
    "code": "def get_prime(n):\n    \"\"\"\n    Gets the n-th prime number.\n    input: positive integer 'n' >= 0\n    returns the n-th prime number, beginning at index 0\n\n    >>> get_prime(0)\n    2\n    >>> get_prime(8)\n    23\n    >>> get_prime(824)\n    6337\n    >>> get_prime(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been a positive int\n    >>> get_prime(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been a positive int\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n >= 0), \"'number' must been a positive int\"\n\n    index = 0\n    ans = 2  # this variable holds the answer\n\n    while index < n:\n        index += 1\n\n        ans += 1  # counts to the next number\n\n        # if ans not prime then\n        # runs to the next prime number.\n        while not is_prime(ans):\n            ans += 1\n\n    # precondition\n    assert isinstance(ans, int) and is_prime(ans), (\n        \"'ans' must been a prime number and from type int\"\n    )\n\n    return ans",
    "docstring": "Gets the n-th prime number.\ninput: positive integer 'n' >= 0\nreturns the n-th prime number, beginning at index 0\n\n>>> get_prime(0)\n2\n>>> get_prime(8)\n23\n>>> get_prime(824)\n6337\n>>> get_prime(-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been a positive int\n>>> get_prime(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been a positive int"
  },
  {
    "function": "get_primes_between",
    "code": "def get_primes_between(p_number_1, p_number_2):\n    \"\"\"\n    input: prime numbers 'pNumber1' and 'pNumber2'\n            pNumber1 < pNumber2\n    returns a list of all prime numbers between 'pNumber1' (exclusive)\n            and 'pNumber2' (exclusive)\n\n    >>> get_primes_between(3, 67)\n    [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n    >>> get_primes_between(0)\n    Traceback (most recent call last):\n        ...\n    TypeError: get_primes_between() missing 1 required positional argument: 'p_number_2'\n    >>> get_primes_between(0, 1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: The arguments must been prime numbers and 'pNumber1' < 'pNumber2'\n    >>> get_primes_between(-1, 3)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and positive\n    >>> get_primes_between(\"test\",\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and positive\n    \"\"\"\n\n    # precondition\n    assert (\n        is_prime(p_number_1) and is_prime(p_number_2) and (p_number_1 < p_number_2)\n    ), \"The arguments must been prime numbers and 'pNumber1' < 'pNumber2'\"\n\n    number = p_number_1 + 1  # jump to the next number\n\n    ans = []  # this list will be returns.\n\n    # if number is not prime then\n    # fetch the next prime number.\n    while not is_prime(number):\n        number += 1\n\n    while number < p_number_2:\n        ans.append(number)\n\n        number += 1\n\n        # fetch the next prime number.\n        while not is_prime(number):\n            number += 1\n\n    # precondition\n    assert (\n        isinstance(ans, list)\n        and ans[0] != p_number_1\n        and ans[len(ans) - 1] != p_number_2\n    ), \"'ans' must been a list without the arguments\"\n\n    # 'ans' contains not 'pNumber1' and 'pNumber2' !\n    return ans",
    "docstring": "input: prime numbers 'pNumber1' and 'pNumber2'\n        pNumber1 < pNumber2\nreturns a list of all prime numbers between 'pNumber1' (exclusive)\n        and 'pNumber2' (exclusive)\n\n>>> get_primes_between(3, 67)\n[5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n>>> get_primes_between(0)\nTraceback (most recent call last):\n    ...\nTypeError: get_primes_between() missing 1 required positional argument: 'p_number_2'\n>>> get_primes_between(0, 1)\nTraceback (most recent call last):\n    ...\nAssertionError: The arguments must been prime numbers and 'pNumber1' < 'pNumber2'\n>>> get_primes_between(-1, 3)\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and positive\n>>> get_primes_between(\"test\",\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and positive"
  },
  {
    "function": "get_divisors",
    "code": "def get_divisors(n):\n    \"\"\"\n    input: positive integer 'n' >= 1\n    returns all divisors of n (inclusive 1 and 'n')\n\n    >>> get_divisors(8)\n    [1, 2, 4, 8]\n    >>> get_divisors(824)\n    [1, 2, 4, 8, 103, 206, 412, 824]\n    >>> get_divisors(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'n' must been int and >= 1\n    >>> get_divisors(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'n' must been int and >= 1\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n >= 1), \"'n' must been int and >= 1\"\n\n    ans = []  # will be returned.\n\n    for divisor in range(1, n + 1):\n        if n % divisor == 0:\n            ans.append(divisor)\n\n    # precondition\n    assert ans[0] == 1 and ans[len(ans) - 1] == n, \"Error in function getDivisiors(...)\"\n\n    return ans",
    "docstring": "input: positive integer 'n' >= 1\nreturns all divisors of n (inclusive 1 and 'n')\n\n>>> get_divisors(8)\n[1, 2, 4, 8]\n>>> get_divisors(824)\n[1, 2, 4, 8, 103, 206, 412, 824]\n>>> get_divisors(-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'n' must been int and >= 1\n>>> get_divisors(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'n' must been int and >= 1"
  },
  {
    "function": "is_perfect_number",
    "code": "def is_perfect_number(number):\n    \"\"\"\n    input: positive integer 'number' > 1\n    returns true if 'number' is a perfect number otherwise false.\n\n    >>> is_perfect_number(28)\n    True\n    >>> is_perfect_number(824)\n    False\n    >>> is_perfect_number(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 1\n    >>> is_perfect_number(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 1\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and (number > 1), (\n        \"'number' must been an int and >= 1\"\n    )\n\n    divisors = get_divisors(number)\n\n    # precondition\n    assert (\n        isinstance(divisors, list)\n        and (divisors[0] == 1)\n        and (divisors[len(divisors) - 1] == number)\n    ), \"Error in help-function getDivisiors(...)\"\n\n    # summed all divisors up to 'number' (exclusive), hence [:-1]\n    return sum(divisors[:-1]) == number",
    "docstring": "input: positive integer 'number' > 1\nreturns true if 'number' is a perfect number otherwise false.\n\n>>> is_perfect_number(28)\nTrue\n>>> is_perfect_number(824)\nFalse\n>>> is_perfect_number(-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and >= 1\n>>> is_perfect_number(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'number' must been an int and >= 1"
  },
  {
    "function": "simplify_fraction",
    "code": "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    input: two integer 'numerator' and 'denominator'\n    assumes: 'denominator' != 0\n    returns: a tuple with simplify numerator and denominator.\n\n    >>> simplify_fraction(10, 20)\n    (1, 2)\n    >>> simplify_fraction(10, -1)\n    (10, -1)\n    >>> simplify_fraction(\"test\",\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: The arguments must been from type int and 'denominator' != 0\n    \"\"\"\n\n    # precondition\n    assert (\n        isinstance(numerator, int)\n        and isinstance(denominator, int)\n        and (denominator != 0)\n    ), \"The arguments must been from type int and 'denominator' != 0\"\n\n    # build the greatest common divisor of numerator and denominator.\n    gcd_of_fraction = gcd_by_iterative(abs(numerator), abs(denominator))\n\n    # precondition\n    assert (\n        isinstance(gcd_of_fraction, int)\n        and (numerator % gcd_of_fraction == 0)\n        and (denominator % gcd_of_fraction == 0)\n    ), \"Error in function gcd_by_iterative(...,...)\"\n\n    return (numerator // gcd_of_fraction, denominator // gcd_of_fraction)",
    "docstring": "input: two integer 'numerator' and 'denominator'\nassumes: 'denominator' != 0\nreturns: a tuple with simplify numerator and denominator.\n\n>>> simplify_fraction(10, 20)\n(1, 2)\n>>> simplify_fraction(10, -1)\n(10, -1)\n>>> simplify_fraction(\"test\",\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: The arguments must been from type int and 'denominator' != 0"
  },
  {
    "function": "factorial",
    "code": "def factorial(n):\n    \"\"\"\n    input: positive integer 'n'\n    returns the factorial of 'n' (n!)\n\n    >>> factorial(0)\n    1\n    >>> factorial(20)\n    2432902008176640000\n    >>> factorial(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'n' must been a int and >= 0\n    >>> factorial(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'n' must been a int and >= 0\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n >= 0), \"'n' must been a int and >= 0\"\n\n    ans = 1  # this will be return.\n\n    for factor in range(1, n + 1):\n        ans *= factor\n\n    return ans",
    "docstring": "input: positive integer 'n'\nreturns the factorial of 'n' (n!)\n\n>>> factorial(0)\n1\n>>> factorial(20)\n2432902008176640000\n>>> factorial(-1)\nTraceback (most recent call last):\n    ...\nAssertionError: 'n' must been a int and >= 0\n>>> factorial(\"test\")\nTraceback (most recent call last):\n    ...\nAssertionError: 'n' must been a int and >= 0"
  },
  {
    "function": "fib",
    "code": "def fib(n: int) -> int:\n    \"\"\"\n    input: positive integer 'n'\n    returns the n-th fibonacci term , indexing by 0\n\n    >>> fib(0)\n    1\n    >>> fib(5)\n    8\n    >>> fib(20)\n    10946\n    >>> fib(99)\n    354224848179261915075\n    >>> fib(-1)\n    Traceback (most recent call last):\n    ...\n    AssertionError: 'n' must been an int and >= 0\n    >>> fib(\"test\")\n    Traceback (most recent call last):\n    ...\n    AssertionError: 'n' must been an int and >= 0\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n >= 0), \"'n' must been an int and >= 0\"\n\n    tmp = 0\n    fib1 = 1\n    ans = 1  # this will be return\n\n    for _ in range(n - 1):\n        tmp = ans\n        ans += fib1\n        fib1 = tmp\n\n    return ans",
    "docstring": "input: positive integer 'n'\nreturns the n-th fibonacci term , indexing by 0\n\n>>> fib(0)\n1\n>>> fib(5)\n8\n>>> fib(20)\n10946\n>>> fib(99)\n354224848179261915075\n>>> fib(-1)\nTraceback (most recent call last):\n...\nAssertionError: 'n' must been an int and >= 0\n>>> fib(\"test\")\nTraceback (most recent call last):\n...\nAssertionError: 'n' must been an int and >= 0"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    >>> is_prime(16.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: is_prime() only accepts positive integers\n    >>> is_prime(-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: is_prime() only accepts positive integers\n    \"\"\"\n\n    # precondition\n    if not isinstance(number, int) or not number >= 0:\n        raise ValueError(\"is_prime() only accepts positive integers\")\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\n\nA number is prime if it has exactly two factors: 1 and itself.\n\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(87)\nFalse\n>>> is_prime(563)\nTrue\n>>> is_prime(2999)\nTrue\n>>> is_prime(67483)\nFalse\n>>> is_prime(16.1)\nTraceback (most recent call last):\n    ...\nValueError: is_prime() only accepts positive integers\n>>> is_prime(-4)\nTraceback (most recent call last):\n    ...\nValueError: is_prime() only accepts positive integers"
  },
  {
    "function": "prime_factors",
    "code": "def prime_factors(n: int) -> list[int]:\n    \"\"\"\n    Returns prime factors of n as a list.\n\n    >>> prime_factors(0)\n    []\n    >>> prime_factors(100)\n    [2, 2, 5, 5]\n    >>> prime_factors(2560)\n    [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]\n    >>> prime_factors(10**-2)\n    []\n    >>> prime_factors(0.02)\n    []\n    >>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE\n    >>> x == [2]*241 + [5]*241\n    True\n    >>> prime_factors(10**-354)\n    []\n    >>> prime_factors('hello')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> prime_factors([1,2,'hello'])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors",
    "docstring": "Returns prime factors of n as a list.\n\n>>> prime_factors(0)\n[]\n>>> prime_factors(100)\n[2, 2, 5, 5]\n>>> prime_factors(2560)\n[2, 2, 2, 2, 2, 2, 2, 2, 2, 5]\n>>> prime_factors(10**-2)\n[]\n>>> prime_factors(0.02)\n[]\n>>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE\n>>> x == [2]*241 + [5]*241\nTrue\n>>> prime_factors(10**-354)\n[]\n>>> prime_factors('hello')\nTraceback (most recent call last):\n    ...\nTypeError: '<=' not supported between instances of 'int' and 'str'\n>>> prime_factors([1,2,'hello'])\nTraceback (most recent call last):\n    ...\nTypeError: '<=' not supported between instances of 'int' and 'list'"
  },
  {
    "function": "unique_prime_factors",
    "code": "def unique_prime_factors(n: int) -> list[int]:\n    \"\"\"\n    Returns unique prime factors of n as a list.\n\n    >>> unique_prime_factors(0)\n    []\n    >>> unique_prime_factors(100)\n    [2, 5]\n    >>> unique_prime_factors(2560)\n    [2, 5]\n    >>> unique_prime_factors(10**-2)\n    []\n    >>> unique_prime_factors(0.02)\n    []\n    >>> unique_prime_factors(10**241)\n    [2, 5]\n    >>> unique_prime_factors(10**-354)\n    []\n    >>> unique_prime_factors('hello')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> unique_prime_factors([1,2,'hello'])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if not n % i:\n            while not n % i:\n                n //= i\n            factors.append(i)\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors",
    "docstring": "Returns unique prime factors of n as a list.\n\n>>> unique_prime_factors(0)\n[]\n>>> unique_prime_factors(100)\n[2, 5]\n>>> unique_prime_factors(2560)\n[2, 5]\n>>> unique_prime_factors(10**-2)\n[]\n>>> unique_prime_factors(0.02)\n[]\n>>> unique_prime_factors(10**241)\n[2, 5]\n>>> unique_prime_factors(10**-354)\n[]\n>>> unique_prime_factors('hello')\nTraceback (most recent call last):\n    ...\nTypeError: '<=' not supported between instances of 'int' and 'str'\n>>> unique_prime_factors([1,2,'hello'])\nTraceback (most recent call last):\n    ...\nTypeError: '<=' not supported between instances of 'int' and 'list'"
  },
  {
    "function": "slow_primes",
    "code": "def slow_primes(max_n: int) -> Generator[int]:\n    \"\"\"\n    Return a list of all primes numbers up to max.\n    >>> list(slow_primes(0))\n    []\n    >>> list(slow_primes(-1))\n    []\n    >>> list(slow_primes(-10))\n    []\n    >>> list(slow_primes(25))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    >>> list(slow_primes(11))\n    [2, 3, 5, 7, 11]\n    >>> list(slow_primes(33))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    >>> list(slow_primes(1000))[-1]\n    997\n    \"\"\"\n    numbers: Generator = (i for i in range(1, (max_n + 1)))\n    for i in (n for n in numbers if n > 1):\n        for j in range(2, i):\n            if (i % j) == 0:\n                break\n        else:\n            yield i",
    "docstring": "Return a list of all primes numbers up to max.\n>>> list(slow_primes(0))\n[]\n>>> list(slow_primes(-1))\n[]\n>>> list(slow_primes(-10))\n[]\n>>> list(slow_primes(25))\n[2, 3, 5, 7, 11, 13, 17, 19, 23]\n>>> list(slow_primes(11))\n[2, 3, 5, 7, 11]\n>>> list(slow_primes(33))\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n>>> list(slow_primes(1000))[-1]\n997"
  },
  {
    "function": "primes",
    "code": "def primes(max_n: int) -> Generator[int]:\n    \"\"\"\n    Return a list of all primes numbers up to max.\n    >>> list(primes(0))\n    []\n    >>> list(primes(-1))\n    []\n    >>> list(primes(-10))\n    []\n    >>> list(primes(25))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    >>> list(primes(11))\n    [2, 3, 5, 7, 11]\n    >>> list(primes(33))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    >>> list(primes(1000))[-1]\n    997\n    \"\"\"\n    numbers: Generator = (i for i in range(1, (max_n + 1)))\n    for i in (n for n in numbers if n > 1):\n        # only need to check for factors up to sqrt(i)\n        bound = int(math.sqrt(i)) + 1\n        for j in range(2, bound):\n            if (i % j) == 0:\n                break\n        else:\n            yield i",
    "docstring": "Return a list of all primes numbers up to max.\n>>> list(primes(0))\n[]\n>>> list(primes(-1))\n[]\n>>> list(primes(-10))\n[]\n>>> list(primes(25))\n[2, 3, 5, 7, 11, 13, 17, 19, 23]\n>>> list(primes(11))\n[2, 3, 5, 7, 11]\n>>> list(primes(33))\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n>>> list(primes(1000))[-1]\n997"
  },
  {
    "function": "fast_primes",
    "code": "def fast_primes(max_n: int) -> Generator[int]:\n    \"\"\"\n    Return a list of all primes numbers up to max.\n    >>> list(fast_primes(0))\n    []\n    >>> list(fast_primes(-1))\n    []\n    >>> list(fast_primes(-10))\n    []\n    >>> list(fast_primes(25))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    >>> list(fast_primes(11))\n    [2, 3, 5, 7, 11]\n    >>> list(fast_primes(33))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    >>> list(fast_primes(1000))[-1]\n    997\n    \"\"\"\n    numbers: Generator = (i for i in range(1, (max_n + 1), 2))\n    # It's useless to test even numbers as they will not be prime\n    if max_n > 2:\n        yield 2  # Because 2 will not be tested, it's necessary to yield it now\n    for i in (n for n in numbers if n > 1):\n        bound = int(math.sqrt(i)) + 1\n        for j in range(3, bound, 2):\n            # As we removed the even numbers, we don't need them now\n            if (i % j) == 0:\n                break\n        else:\n            yield i",
    "docstring": "Return a list of all primes numbers up to max.\n>>> list(fast_primes(0))\n[]\n>>> list(fast_primes(-1))\n[]\n>>> list(fast_primes(-10))\n[]\n>>> list(fast_primes(25))\n[2, 3, 5, 7, 11, 13, 17, 19, 23]\n>>> list(fast_primes(11))\n[2, 3, 5, 7, 11]\n>>> list(fast_primes(33))\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n>>> list(fast_primes(1000))[-1]\n997"
  },
  {
    "function": "benchmark",
    "code": "def benchmark():\n    \"\"\"\n    Let's benchmark our functions side-by-side...\n    \"\"\"\n    from timeit import timeit\n\n    setup = \"from __main__ import slow_primes, primes, fast_primes\"\n    print(timeit(\"slow_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n    print(timeit(\"primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n    print(timeit(\"fast_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))",
    "docstring": "Let's benchmark our functions side-by-side..."
  },
  {
    "function": "prime_sieve_eratosthenes",
    "code": "def prime_sieve_eratosthenes(num: int) -> list[int]:\n    \"\"\"\n    Print the prime numbers up to n\n\n    >>> prime_sieve_eratosthenes(10)\n    [2, 3, 5, 7]\n    >>> prime_sieve_eratosthenes(20)\n    [2, 3, 5, 7, 11, 13, 17, 19]\n    >>> prime_sieve_eratosthenes(2)\n    [2]\n    >>> prime_sieve_eratosthenes(1)\n    []\n    >>> prime_sieve_eratosthenes(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be a positive integer\n    \"\"\"\n\n    if num <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    primes = [True] * (num + 1)\n\n    p = 2\n    while p * p <= num:\n        if primes[p]:\n            for i in range(p * p, num + 1, p):\n                primes[i] = False\n        p += 1\n\n    return [prime for prime in range(2, num + 1) if primes[prime]]",
    "docstring": "Print the prime numbers up to n\n\n>>> prime_sieve_eratosthenes(10)\n[2, 3, 5, 7]\n>>> prime_sieve_eratosthenes(20)\n[2, 3, 5, 7, 11, 13, 17, 19]\n>>> prime_sieve_eratosthenes(2)\n[2]\n>>> prime_sieve_eratosthenes(1)\n[]\n>>> prime_sieve_eratosthenes(-1)\nTraceback (most recent call last):\n...\nValueError: Input must be a positive integer"
  },
  {
    "function": "multiplication_table",
    "code": "def multiplication_table(number: int, number_of_terms: int) -> str:\n    \"\"\"\n    Prints the multiplication table of a given number till the given number of terms\n\n    >>> print(multiplication_table(3, 5))\n    3 * 1 = 3\n    3 * 2 = 6\n    3 * 3 = 9\n    3 * 4 = 12\n    3 * 5 = 15\n\n    >>> print(multiplication_table(-4, 6))\n    -4 * 1 = -4\n    -4 * 2 = -8\n    -4 * 3 = -12\n    -4 * 4 = -16\n    -4 * 5 = -20\n    -4 * 6 = -24\n    \"\"\"\n    return \"\\n\".join(\n        f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)\n    )",
    "docstring": "Prints the multiplication table of a given number till the given number of terms\n\n>>> print(multiplication_table(3, 5))\n3 * 1 = 3\n3 * 2 = 6\n3 * 3 = 9\n3 * 4 = 12\n3 * 5 = 15\n\n>>> print(multiplication_table(-4, 6))\n-4 * 1 = -4\n-4 * 2 = -8\n-4 * 3 = -12\n-4 * 4 = -16\n-4 * 5 = -20\n-4 * 6 = -24"
  },
  {
    "function": "distance",
    "code": "def distance(a: Point, b: Point) -> float:\n    \"\"\"\n    >>> point1 = Point(2, -1, 7)\n    >>> point2 = Point(1, -3, 5)\n    >>> print(f\"Distance from {point1} to {point2} is {distance(point1, point2)}\")\n    Distance from Point(2, -1, 7) to Point(1, -3, 5) is 3.0\n    \"\"\"\n    return math.sqrt(abs((b.x - a.x) ** 2 + (b.y - a.y) ** 2 + (b.z - a.z) ** 2))",
    "docstring": ">>> point1 = Point(2, -1, 7)\n>>> point2 = Point(1, -3, 5)\n>>> print(f\"Distance from {point1} to {point2} is {distance(point1, point2)}\")\nDistance from Point(2, -1, 7) to Point(1, -3, 5) is 3.0"
  },
  {
    "function": "qr_householder",
    "code": "def qr_householder(a: np.ndarray):\n    \"\"\"Return a QR-decomposition of the matrix A using Householder reflection.\n\n    The QR-decomposition decomposes the matrix A of shape (m, n) into an\n    orthogonal matrix Q of shape (m, m) and an upper triangular matrix R of\n    shape (m, n).  Note that the matrix A does not have to be square.  This\n    method of decomposing A uses the Householder reflection, which is\n    numerically stable and of complexity O(n^3).\n\n    https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections\n\n    Arguments:\n    A -- a numpy.ndarray of shape (m, n)\n\n    Note: several optimizations can be made for numeric efficiency, but this is\n    intended to demonstrate how it would be represented in a mathematics\n    textbook.  In cases where efficiency is particularly important, an optimized\n    version from BLAS should be used.\n\n    >>> A = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]], dtype=float)\n    >>> Q, R = qr_householder(A)\n\n    >>> # check that the decomposition is correct\n    >>> np.allclose(Q@R, A)\n    True\n\n    >>> # check that Q is orthogonal\n    >>> np.allclose(Q@Q.T, np.eye(A.shape[0]))\n    True\n    >>> np.allclose(Q.T@Q, np.eye(A.shape[0]))\n    True\n\n    >>> # check that R is upper triangular\n    >>> np.allclose(np.triu(R), R)\n    True\n    \"\"\"\n    m, n = a.shape\n    t = min(m, n)\n    q = np.eye(m)\n    r = a.copy()\n\n    for k in range(t - 1):\n        # select a column of modified matrix A':\n        x = r[k:, [k]]\n        # construct first basis vector\n        e1 = np.zeros_like(x)\n        e1[0] = 1.0\n        # determine scaling factor\n        alpha = np.linalg.norm(x)\n        # construct vector v for Householder reflection\n        v = x + np.sign(x[0]) * alpha * e1\n        v /= np.linalg.norm(v)\n\n        # construct the Householder matrix\n        q_k = np.eye(m - k) - 2.0 * v @ v.T\n        # pad with ones and zeros as necessary\n        q_k = np.block([[np.eye(k), np.zeros((k, m - k))], [np.zeros((m - k, k)), q_k]])\n\n        q = q @ q_k.T\n        r = q_k @ r\n\n    return q, r",
    "docstring": "Return a QR-decomposition of the matrix A using Householder reflection.\n\nThe QR-decomposition decomposes the matrix A of shape (m, n) into an\northogonal matrix Q of shape (m, m) and an upper triangular matrix R of\nshape (m, n).  Note that the matrix A does not have to be square.  This\nmethod of decomposing A uses the Householder reflection, which is\nnumerically stable and of complexity O(n^3).\n\nhttps://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections\n\nArguments:\nA -- a numpy.ndarray of shape (m, n)\n\nNote: several optimizations can be made for numeric efficiency, but this is\nintended to demonstrate how it would be represented in a mathematics\ntextbook.  In cases where efficiency is particularly important, an optimized\nversion from BLAS should be used.\n\n>>> A = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]], dtype=float)\n>>> Q, R = qr_householder(A)\n\n>>> # check that the decomposition is correct\n>>> np.allclose(Q@R, A)\nTrue\n\n>>> # check that Q is orthogonal\n>>> np.allclose(Q@Q.T, np.eye(A.shape[0]))\nTrue\n>>> np.allclose(Q.T@Q, np.eye(A.shape[0]))\nTrue\n\n>>> # check that R is upper triangular\n>>> np.allclose(np.triu(R), R)\nTrue"
  },
  {
    "function": "quadratic_roots",
    "code": "def quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:\n    \"\"\"\n    Given the numerical coefficients a, b and c,\n    calculates the roots for any quadratic equation of the form ax^2 + bx + c\n\n    >>> quadratic_roots(a=1, b=3, c=-4)\n    (1.0, -4.0)\n    >>> quadratic_roots(5, 6, 1)\n    (-0.2, -1.0)\n    >>> quadratic_roots(1, -6, 25)\n    ((3+4j), (3-4j))\n    \"\"\"\n\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must not be zero.\")\n    delta = b * b - 4 * a * c\n\n    root_1 = (-b + sqrt(delta)) / (2 * a)\n    root_2 = (-b - sqrt(delta)) / (2 * a)\n\n    return (\n        root_1.real if not root_1.imag else root_1,\n        root_2.real if not root_2.imag else root_2,\n    )",
    "docstring": "Given the numerical coefficients a, b and c,\ncalculates the roots for any quadratic equation of the form ax^2 + bx + c\n\n>>> quadratic_roots(a=1, b=3, c=-4)\n(1.0, -4.0)\n>>> quadratic_roots(5, 6, 1)\n(-0.2, -1.0)\n>>> quadratic_roots(1, -6, 25)\n((3+4j), (3-4j))"
  },
  {
    "function": "radians",
    "code": "def radians(degree: float) -> float:\n    \"\"\"\n    Converts the given angle from degrees to radians\n    https://en.wikipedia.org/wiki/Radian\n\n    >>> radians(180)\n    3.141592653589793\n    >>> radians(92)\n    1.6057029118347832\n    >>> radians(274)\n    4.782202150464463\n    >>> radians(109.82)\n    1.9167205845401725\n\n    >>> from math import radians as math_radians\n    >>> all(abs(radians(i) - math_radians(i)) <= 1e-8 for i in range(-2, 361))\n    True\n    \"\"\"\n\n    return degree / (180 / pi)",
    "docstring": "Converts the given angle from degrees to radians\nhttps://en.wikipedia.org/wiki/Radian\n\n>>> radians(180)\n3.141592653589793\n>>> radians(92)\n1.6057029118347832\n>>> radians(274)\n4.782202150464463\n>>> radians(109.82)\n1.9167205845401725\n\n>>> from math import radians as math_radians\n>>> all(abs(radians(i) - math_radians(i)) <= 1e-8 for i in range(-2, 361))\nTrue"
  },
  {
    "function": "remove_digit",
    "code": "def remove_digit(num: int) -> int:\n    \"\"\"\n\n    returns the biggest possible result\n    that can be achieved by removing\n    one digit from the given number\n\n    >>> remove_digit(152)\n    52\n    >>> remove_digit(6385)\n    685\n    >>> remove_digit(-11)\n    1\n    >>> remove_digit(2222222)\n    222222\n    >>> remove_digit(\"2222222\")\n    Traceback (most recent call last):\n    TypeError: only integers accepted as input\n    >>> remove_digit(\"string input\")\n    Traceback (most recent call last):\n    TypeError: only integers accepted as input\n    \"\"\"\n\n    if not isinstance(num, int):\n        raise TypeError(\"only integers accepted as input\")\n    else:\n        num_str = str(abs(num))\n        num_transpositions = [list(num_str) for char in range(len(num_str))]\n        for index in range(len(num_str)):\n            num_transpositions[index].pop(index)\n        return max(\n            int(\"\".join(list(transposition))) for transposition in num_transpositions\n        )",
    "docstring": "returns the biggest possible result\nthat can be achieved by removing\none digit from the given number\n\n>>> remove_digit(152)\n52\n>>> remove_digit(6385)\n685\n>>> remove_digit(-11)\n1\n>>> remove_digit(2222222)\n222222\n>>> remove_digit(\"2222222\")\nTraceback (most recent call last):\nTypeError: only integers accepted as input\n>>> remove_digit(\"string input\")\nTraceback (most recent call last):\nTypeError: only integers accepted as input"
  },
  {
    "function": "sieve",
    "code": "def sieve(n: int) -> list[int]:\n    \"\"\"\n    Segmented Sieve.\n\n    Examples:\n    >>> sieve(8)\n    [2, 3, 5, 7]\n\n    >>> sieve(27)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n\n    >>> sieve(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Number 0 must instead be a positive integer\n\n    >>> sieve(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Number -1 must instead be a positive integer\n\n    >>> sieve(22.2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Number 22.2 must instead be a positive integer\n    \"\"\"\n\n    if n <= 0 or isinstance(n, float):\n        msg = f\"Number {n} must instead be a positive integer\"\n        raise ValueError(msg)\n\n    in_prime = []\n    start = 2\n    end = int(math.sqrt(n))  # Size of every segment\n    temp = [True] * (end + 1)\n    prime = []\n\n    while start <= end:\n        if temp[start] is True:\n            in_prime.append(start)\n            for i in range(start * start, end + 1, start):\n                temp[i] = False\n        start += 1\n    prime += in_prime\n\n    low = end + 1\n    high = min(2 * end, n)\n\n    while low <= n:\n        temp = [True] * (high - low + 1)\n        for each in in_prime:\n            t = math.floor(low / each) * each\n            if t < low:\n                t += each\n\n            for j in range(t, high + 1, each):\n                temp[j - low] = False\n\n        for j in range(len(temp)):\n            if temp[j] is True:\n                prime.append(j + low)\n\n        low = high + 1\n        high = min(high + end, n)\n\n    return prime",
    "docstring": "Segmented Sieve.\n\nExamples:\n>>> sieve(8)\n[2, 3, 5, 7]\n\n>>> sieve(27)\n[2, 3, 5, 7, 11, 13, 17, 19, 23]\n\n>>> sieve(0)\nTraceback (most recent call last):\n    ...\nValueError: Number 0 must instead be a positive integer\n\n>>> sieve(-1)\nTraceback (most recent call last):\n    ...\nValueError: Number -1 must instead be a positive integer\n\n>>> sieve(22.2)\nTraceback (most recent call last):\n    ...\nValueError: Number 22.2 must instead be a positive integer"
  },
  {
    "function": "prime_sieve",
    "code": "def prime_sieve(num: int) -> list[int]:\n    \"\"\"\n    Returns a list with all prime numbers up to n.\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    >>> prime_sieve(25)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    >>> prime_sieve(10)\n    [2, 3, 5, 7]\n    >>> prime_sieve(9)\n    [2, 3, 5, 7]\n    >>> prime_sieve(2)\n    [2]\n    >>> prime_sieve(1)\n    []\n    \"\"\"\n\n    if num <= 0:\n        msg = f\"{num}: Invalid input, please enter a positive integer.\"\n        raise ValueError(msg)\n\n    sieve = [True] * (num + 1)\n    prime = []\n    start = 2\n    end = int(math.sqrt(num))\n\n    while start <= end:\n        # If start is a prime\n        if sieve[start] is True:\n            prime.append(start)\n\n            # Set multiples of start be False\n            for i in range(start * start, num + 1, start):\n                if sieve[i] is True:\n                    sieve[i] = False\n\n        start += 1\n\n    for j in range(end + 1, num + 1):\n        if sieve[j] is True:\n            prime.append(j)\n\n    return prime",
    "docstring": "Returns a list with all prime numbers up to n.\n\n>>> prime_sieve(50)\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n>>> prime_sieve(25)\n[2, 3, 5, 7, 11, 13, 17, 19, 23]\n>>> prime_sieve(10)\n[2, 3, 5, 7]\n>>> prime_sieve(9)\n[2, 3, 5, 7]\n>>> prime_sieve(2)\n[2]\n>>> prime_sieve(1)\n[]"
  },
  {
    "function": "sigmoid",
    "code": "def sigmoid(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the sigmoid function\n\n    Parameters:\n        vector (np.array): A  numpy array of shape (1,n)\n        consisting of real values\n\n    Returns:\n        sigmoid_vec (np.array): The input numpy array, after applying\n        sigmoid.\n\n    Examples:\n    >>> sigmoid(np.array([-1.0, 1.0, 2.0]))\n    array([0.26894142, 0.73105858, 0.88079708])\n\n    >>> sigmoid(np.array([0.0]))\n    array([0.5])\n    \"\"\"\n    return 1 / (1 + np.exp(-vector))",
    "docstring": "Implements the sigmoid function\n\nParameters:\n    vector (np.array): A  numpy array of shape (1,n)\n    consisting of real values\n\nReturns:\n    sigmoid_vec (np.array): The input numpy array, after applying\n    sigmoid.\n\nExamples:\n>>> sigmoid(np.array([-1.0, 1.0, 2.0]))\narray([0.26894142, 0.73105858, 0.88079708])\n\n>>> sigmoid(np.array([0.0]))\narray([0.5])"
  },
  {
    "function": "signum",
    "code": "def signum(num: float) -> int:\n    \"\"\"\n    Applies signum function on the number\n\n    Custom test cases:\n    >>> signum(-10)\n    -1\n    >>> signum(10)\n    1\n    >>> signum(0)\n    0\n    >>> signum(-20.5)\n    -1\n    >>> signum(20.5)\n    1\n    >>> signum(-1e-6)\n    -1\n    >>> signum(1e-6)\n    1\n    >>> signum(\"Hello\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    >>> signum([])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'list' and 'int'\n    \"\"\"\n    if num < 0:\n        return -1\n    return 1 if num else 0",
    "docstring": "Applies signum function on the number\n\nCustom test cases:\n>>> signum(-10)\n-1\n>>> signum(10)\n1\n>>> signum(0)\n0\n>>> signum(-20.5)\n-1\n>>> signum(20.5)\n1\n>>> signum(-1e-6)\n-1\n>>> signum(1e-6)\n1\n>>> signum(\"Hello\")\nTraceback (most recent call last):\n    ...\nTypeError: '<' not supported between instances of 'str' and 'int'\n>>> signum([])\nTraceback (most recent call last):\n    ...\nTypeError: '<' not supported between instances of 'list' and 'int'"
  },
  {
    "function": "test_signum",
    "code": "def test_signum() -> None:\n    \"\"\"\n    Tests the signum function\n    >>> test_signum()\n    \"\"\"\n    assert signum(5) == 1\n    assert signum(-5) == -1\n    assert signum(0) == 0\n    assert signum(10.5) == 1\n    assert signum(-10.5) == -1\n    assert signum(1e-6) == 1\n    assert signum(-1e-6) == -1\n    assert signum(123456789) == 1\n    assert signum(-123456789) == -1",
    "docstring": "Tests the signum function\n>>> test_signum()"
  },
  {
    "function": "simplify",
    "code": "def simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set",
    "docstring": ">>> simplify([[1, 2, 3], [4, 5, 6]])\n[[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n>>> simplify([[5, 2, 5], [5, 1, 10]])\n[[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]"
  },
  {
    "function": "solve_simultaneous",
    "code": "def solve_simultaneous(equations: list[list]) -> list:\n    \"\"\"\n    >>> solve_simultaneous([[1, 2, 3],[4, 5, 6]])\n    [-1.0, 2.0]\n    >>> solve_simultaneous([[0, -3, 1, 7],[3, 2, -1, 11],[5, 1, -2, 12]])\n    [6.4, 1.2, 10.6]\n    >>> solve_simultaneous([])\n    Traceback (most recent call last):\n        ...\n    IndexError: solve_simultaneous() requires n lists of length n+1\n    >>> solve_simultaneous([[1, 2, 3],[1, 2]])\n    Traceback (most recent call last):\n        ...\n    IndexError: solve_simultaneous() requires n lists of length n+1\n    >>> solve_simultaneous([[1, 2, 3],[\"a\", 7, 8]])\n    Traceback (most recent call last):\n        ...\n    ValueError: solve_simultaneous() requires lists of integers\n    >>> solve_simultaneous([[0, 2, 3],[4, 0, 6]])\n    Traceback (most recent call last):\n        ...\n    ValueError: solve_simultaneous() requires at least 1 full equation\n    \"\"\"\n    if len(equations) == 0:\n        raise IndexError(\"solve_simultaneous() requires n lists of length n+1\")\n    _length = len(equations) + 1\n    if any(len(item) != _length for item in equations):\n        raise IndexError(\"solve_simultaneous() requires n lists of length n+1\")\n    for row in equations:\n        if any(not isinstance(column, (int, float)) for column in row):\n            raise ValueError(\"solve_simultaneous() requires lists of integers\")\n    if len(equations) == 1:\n        return [equations[0][-1] / equations[0][0]]\n    data_set = equations.copy()\n    if any(0 in row for row in data_set):\n        temp_data = data_set.copy()\n        full_row = []\n        for row_index, row in enumerate(temp_data):\n            if 0 not in row:\n                full_row = data_set.pop(row_index)\n                break\n        if not full_row:\n            raise ValueError(\"solve_simultaneous() requires at least 1 full equation\")\n        data_set.insert(0, full_row)\n    useable_form = data_set.copy()\n    simplified = simplify(useable_form)\n    simplified = simplified[::-1]\n    solutions: list = []\n    for row in simplified:\n        current_solution = row[-1]\n        if not solutions:\n            if row[-2] == 0:\n                solutions.append(0)\n                continue\n            solutions.append(current_solution / row[-2])\n            continue\n        temp_row = row.copy()[: len(row) - 1 :]\n        while temp_row[0] == 0:\n            temp_row.pop(0)\n        if len(temp_row) == 0:\n            solutions.append(0)\n            continue\n        temp_row = temp_row[1::]\n        temp_row = temp_row[::-1]\n        for column_index, column in enumerate(temp_row):\n            current_solution -= column * solutions[column_index]\n        solutions.append(current_solution)\n    final = []\n    for item in solutions:\n        final.append(float(round(item, 5)))\n    return final[::-1]",
    "docstring": ">>> solve_simultaneous([[1, 2, 3],[4, 5, 6]])\n[-1.0, 2.0]\n>>> solve_simultaneous([[0, -3, 1, 7],[3, 2, -1, 11],[5, 1, -2, 12]])\n[6.4, 1.2, 10.6]\n>>> solve_simultaneous([])\nTraceback (most recent call last):\n    ...\nIndexError: solve_simultaneous() requires n lists of length n+1\n>>> solve_simultaneous([[1, 2, 3],[1, 2]])\nTraceback (most recent call last):\n    ...\nIndexError: solve_simultaneous() requires n lists of length n+1\n>>> solve_simultaneous([[1, 2, 3],[\"a\", 7, 8]])\nTraceback (most recent call last):\n    ...\nValueError: solve_simultaneous() requires lists of integers\n>>> solve_simultaneous([[0, 2, 3],[4, 0, 6]])\nTraceback (most recent call last):\n    ...\nValueError: solve_simultaneous() requires at least 1 full equation"
  },
  {
    "function": "sin",
    "code": "def sin(\n    angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10\n) -> float:\n    \"\"\"\n    Implement sin function.\n\n    >>> sin(0.0)\n    0.0\n    >>> sin(90.0)\n    1.0\n    >>> sin(180.0)\n    0.0\n    >>> sin(270.0)\n    -1.0\n    >>> sin(0.68)\n    0.0118679603\n    >>> sin(1.97)\n    0.0343762121\n    >>> sin(64.0)\n    0.8987940463\n    >>> sin(9999.0)\n    -0.9876883406\n    >>> sin(-689.0)\n    0.5150380749\n    >>> sin(89.7)\n    0.9999862922\n    \"\"\"\n    # Simplify the angle to be between 360 and -360 degrees.\n    angle_in_degrees = angle_in_degrees - ((angle_in_degrees // 360.0) * 360.0)\n\n    # Converting from degrees to radians\n    angle_in_radians = radians(angle_in_degrees)\n\n    result = angle_in_radians\n    a = 3\n    b = -1\n\n    for _ in range(accuracy):\n        result += (b * (angle_in_radians**a)) / factorial(a)\n\n        b = -b  # One positive term and the next will be negative and so on...\n        a += 2  # Increased by 2 for every term.\n\n    return round(result, rounded_values_count)",
    "docstring": "Implement sin function.\n\n>>> sin(0.0)\n0.0\n>>> sin(90.0)\n1.0\n>>> sin(180.0)\n0.0\n>>> sin(270.0)\n-1.0\n>>> sin(0.68)\n0.0118679603\n>>> sin(1.97)\n0.0343762121\n>>> sin(64.0)\n0.8987940463\n>>> sin(9999.0)\n-0.9876883406\n>>> sin(-689.0)\n0.5150380749\n>>> sin(89.7)\n0.9999862922"
  },
  {
    "function": "sock_merchant",
    "code": "def sock_merchant(colors: list[int]) -> int:\n    \"\"\"\n    >>> sock_merchant([10, 20, 20, 10, 10, 30, 50, 10, 20])\n    3\n    >>> sock_merchant([1, 1, 3, 3])\n    2\n    \"\"\"\n    return sum(socks_by_color // 2 for socks_by_color in Counter(colors).values())",
    "docstring": ">>> sock_merchant([10, 20, 20, 10, 10, 30, 50, 10, 20])\n3\n>>> sock_merchant([1, 1, 3, 3])\n2"
  },
  {
    "function": "softmax",
    "code": "def softmax(vector):\n    \"\"\"\n    Implements the softmax function\n\n    Parameters:\n        vector (np.array,list,tuple): A  numpy array of shape (1,n)\n        consisting of real values or a similar list,tuple\n\n\n    Returns:\n        softmax_vec (np.array): The input numpy array  after applying\n        softmax.\n\n    The softmax vector adds up to one. We need to ceil to mitigate for\n    precision\n    >>> float(np.ceil(np.sum(softmax([1,2,3,4]))))\n    1.0\n\n    >>> vec = np.array([5,5])\n    >>> softmax(vec)\n    array([0.5, 0.5])\n\n    >>> softmax([0])\n    array([1.])\n    \"\"\"\n\n    # Calculate e^x for each x in your vector where e is Euler's\n    # number (approximately 2.718)\n    exponent_vector = np.exp(vector)\n\n    # Add up the all the exponentials\n    sum_of_exponents = np.sum(exponent_vector)\n\n    # Divide every exponent by the sum of all exponents\n    softmax_vector = exponent_vector / sum_of_exponents\n\n    return softmax_vector",
    "docstring": "Implements the softmax function\n\nParameters:\n    vector (np.array,list,tuple): A  numpy array of shape (1,n)\n    consisting of real values or a similar list,tuple\n\n\nReturns:\n    softmax_vec (np.array): The input numpy array  after applying\n    softmax.\n\nThe softmax vector adds up to one. We need to ceil to mitigate for\nprecision\n>>> float(np.ceil(np.sum(softmax([1,2,3,4]))))\n1.0\n\n>>> vec = np.array([5,5])\n>>> softmax(vec)\narray([0.5, 0.5])\n\n>>> softmax([0])\narray([1.])"
  },
  {
    "function": "jacobi_symbol",
    "code": "def jacobi_symbol(random_a: int, number: int) -> int:\n    \"\"\"\n    Calculate the Jacobi symbol. The Jacobi symbol is a generalization\n    of the Legendre symbol, which can be used to simplify computations involving\n    quadratic residues. The Jacobi symbol is used in primality tests, like the\n    Solovay-Strassen test, because it helps determine if an integer is a\n    quadratic residue modulo a given modulus, providing valuable information\n    about the number's potential primality or compositeness.\n\n    Parameters:\n        random_a: A randomly chosen integer from 2 to n-2 (inclusive)\n        number: The number that is tested for primality\n\n    Returns:\n        jacobi_symbol: The Jacobi symbol is a mathematical function\n        used to determine whether an integer is a quadratic residue modulo\n        another integer (usually prime) or not.\n\n    >>> jacobi_symbol(2, 13)\n    -1\n    >>> jacobi_symbol(5, 19)\n    1\n    >>> jacobi_symbol(7, 14)\n    0\n    \"\"\"\n\n    if random_a in (0, 1):\n        return random_a\n\n    random_a %= number\n    t = 1\n\n    while random_a != 0:\n        while random_a % 2 == 0:\n            random_a //= 2\n            r = number % 8\n            if r in (3, 5):\n                t = -t\n\n        random_a, number = number, random_a\n\n        if random_a % 4 == number % 4 == 3:\n            t = -t\n\n        random_a %= number\n\n    return t if number == 1 else 0",
    "docstring": "Calculate the Jacobi symbol. The Jacobi symbol is a generalization\nof the Legendre symbol, which can be used to simplify computations involving\nquadratic residues. The Jacobi symbol is used in primality tests, like the\nSolovay-Strassen test, because it helps determine if an integer is a\nquadratic residue modulo a given modulus, providing valuable information\nabout the number's potential primality or compositeness.\n\nParameters:\n    random_a: A randomly chosen integer from 2 to n-2 (inclusive)\n    number: The number that is tested for primality\n\nReturns:\n    jacobi_symbol: The Jacobi symbol is a mathematical function\n    used to determine whether an integer is a quadratic residue modulo\n    another integer (usually prime) or not.\n\n>>> jacobi_symbol(2, 13)\n-1\n>>> jacobi_symbol(5, 19)\n1\n>>> jacobi_symbol(7, 14)\n0"
  },
  {
    "function": "solovay_strassen",
    "code": "def solovay_strassen(number: int, iterations: int) -> bool:\n    \"\"\"\n    Check whether the input number is prime or not using\n    the Solovay-Strassen Primality test\n\n    Parameters:\n        number: The number that is tested for primality\n        iterations: The number of times that the test is run\n        which effects the accuracy\n\n    Returns:\n        result: True if number is probably prime and false\n        if not\n\n    >>> random.seed(10)\n    >>> solovay_strassen(13, 5)\n    True\n    >>> solovay_strassen(9, 10)\n    False\n    >>> solovay_strassen(17, 15)\n    True\n    \"\"\"\n\n    if number <= 1:\n        return False\n    if number <= 3:\n        return True\n\n    for _ in range(iterations):\n        a = random.randint(2, number - 2)\n        x = jacobi_symbol(a, number)\n        y = pow(a, (number - 1) // 2, number)\n\n        if x == 0 or y != x % number:\n            return False\n\n    return True",
    "docstring": "Check whether the input number is prime or not using\nthe Solovay-Strassen Primality test\n\nParameters:\n    number: The number that is tested for primality\n    iterations: The number of times that the test is run\n    which effects the accuracy\n\nReturns:\n    result: True if number is probably prime and false\n    if not\n\n>>> random.seed(10)\n>>> solovay_strassen(13, 5)\nTrue\n>>> solovay_strassen(9, 10)\nFalse\n>>> solovay_strassen(17, 15)\nTrue"
  },
  {
    "function": "assign_ranks",
    "code": "def assign_ranks(data: Sequence[float]) -> list[int]:\n    \"\"\"\n    Assigns ranks to elements in the array.\n\n    :param data: List of floats.\n    :return: List of ints representing the ranks.\n\n    Example:\n    >>> assign_ranks([3.2, 1.5, 4.0, 2.7, 5.1])\n    [3, 1, 4, 2, 5]\n\n    >>> assign_ranks([10.5, 8.1, 12.4, 9.3, 11.0])\n    [3, 1, 5, 2, 4]\n    \"\"\"\n    ranked_data = sorted((value, index) for index, value in enumerate(data))\n    ranks = [0] * len(data)\n\n    for position, (_, index) in enumerate(ranked_data):\n        ranks[index] = position + 1\n\n    return ranks",
    "docstring": "Assigns ranks to elements in the array.\n\n:param data: List of floats.\n:return: List of ints representing the ranks.\n\nExample:\n>>> assign_ranks([3.2, 1.5, 4.0, 2.7, 5.1])\n[3, 1, 4, 2, 5]\n\n>>> assign_ranks([10.5, 8.1, 12.4, 9.3, 11.0])\n[3, 1, 5, 2, 4]"
  },
  {
    "function": "calculate_spearman_rank_correlation",
    "code": "def calculate_spearman_rank_correlation(\n    variable_1: Sequence[float], variable_2: Sequence[float]\n) -> float:\n    \"\"\"\n    Calculates Spearman's rank correlation coefficient.\n\n    :param variable_1: List of floats representing the first variable.\n    :param variable_2: List of floats representing the second variable.\n    :return: Spearman's rank correlation coefficient.\n\n    Example Usage:\n\n    >>> x = [1, 2, 3, 4, 5]\n    >>> y = [5, 4, 3, 2, 1]\n    >>> calculate_spearman_rank_correlation(x, y)\n    -1.0\n\n    >>> x = [1, 2, 3, 4, 5]\n    >>> y = [2, 4, 6, 8, 10]\n    >>> calculate_spearman_rank_correlation(x, y)\n    1.0\n\n    >>> x = [1, 2, 3, 4, 5]\n    >>> y = [5, 1, 2, 9, 5]\n    >>> calculate_spearman_rank_correlation(x, y)\n    0.6\n    \"\"\"\n    n = len(variable_1)\n    rank_var1 = assign_ranks(variable_1)\n    rank_var2 = assign_ranks(variable_2)\n\n    # Calculate differences of ranks\n    d = [rx - ry for rx, ry in zip(rank_var1, rank_var2)]\n\n    # Calculate the sum of squared differences\n    d_squared = sum(di**2 for di in d)\n\n    # Calculate the Spearman's rank correlation coefficient\n    rho = 1 - (6 * d_squared) / (n * (n**2 - 1))\n\n    return rho",
    "docstring": "Calculates Spearman's rank correlation coefficient.\n\n:param variable_1: List of floats representing the first variable.\n:param variable_2: List of floats representing the second variable.\n:return: Spearman's rank correlation coefficient.\n\nExample Usage:\n\n>>> x = [1, 2, 3, 4, 5]\n>>> y = [5, 4, 3, 2, 1]\n>>> calculate_spearman_rank_correlation(x, y)\n-1.0\n\n>>> x = [1, 2, 3, 4, 5]\n>>> y = [2, 4, 6, 8, 10]\n>>> calculate_spearman_rank_correlation(x, y)\n1.0\n\n>>> x = [1, 2, 3, 4, 5]\n>>> y = [5, 1, 2, 9, 5]\n>>> calculate_spearman_rank_correlation(x, y)\n0.6"
  },
  {
    "function": "sumset",
    "code": "def sumset(set_a: set, set_b: set) -> set:\n    \"\"\"\n    :param first set: a set of numbers\n    :param second set: a set of numbers\n    :return: the nth number in Sylvester's sequence\n\n    >>> sumset({1, 2, 3}, {4, 5, 6})\n    {5, 6, 7, 8, 9}\n\n    >>> sumset({1, 2, 3}, {4, 5, 6, 7})\n    {5, 6, 7, 8, 9, 10}\n\n    >>> sumset({1, 2, 3, 4}, 3)\n    Traceback (most recent call last):\n    ...\n    AssertionError: The input value of [set_b=3] is not a set\n    \"\"\"\n    assert isinstance(set_a, set), f\"The input value of [set_a={set_a}] is not a set\"\n    assert isinstance(set_b, set), f\"The input value of [set_b={set_b}] is not a set\"\n\n    return {a + b for a in set_a for b in set_b}",
    "docstring": ":param first set: a set of numbers\n:param second set: a set of numbers\n:return: the nth number in Sylvester's sequence\n\n>>> sumset({1, 2, 3}, {4, 5, 6})\n{5, 6, 7, 8, 9}\n\n>>> sumset({1, 2, 3}, {4, 5, 6, 7})\n{5, 6, 7, 8, 9, 10}\n\n>>> sumset({1, 2, 3, 4}, 3)\nTraceback (most recent call last):\n...\nAssertionError: The input value of [set_b=3] is not a set"
  },
  {
    "function": "sum_of_series",
    "code": "def sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:\n    \"\"\"\n    Find the sum of n terms in an arithmetic progression.\n\n    >>> sum_of_series(1, 1, 10)\n    55.0\n    >>> sum_of_series(1, 10, 100)\n    49600.0\n    \"\"\"\n    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\n    # formula for sum of series\n    return total",
    "docstring": "Find the sum of n terms in an arithmetic progression.\n\n>>> sum_of_series(1, 1, 10)\n55.0\n>>> sum_of_series(1, 10, 100)\n49600.0"
  },
  {
    "function": "sum_of_digits",
    "code": "def sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(-123)\n    6\n    >>> sum_of_digits(0)\n    0\n    \"\"\"\n    n = abs(n)\n    res = 0\n    while n > 0:\n        res += n % 10\n        n //= 10\n    return res",
    "docstring": "Find the sum of digits of a number.\n>>> sum_of_digits(12345)\n15\n>>> sum_of_digits(123)\n6\n>>> sum_of_digits(-123)\n6\n>>> sum_of_digits(0)\n0"
  },
  {
    "function": "sum_of_digits_recursion",
    "code": "def sum_of_digits_recursion(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number using recursion\n    >>> sum_of_digits_recursion(12345)\n    15\n    >>> sum_of_digits_recursion(123)\n    6\n    >>> sum_of_digits_recursion(-123)\n    6\n    >>> sum_of_digits_recursion(0)\n    0\n    \"\"\"\n    n = abs(n)\n    return n if n < 10 else n % 10 + sum_of_digits(n // 10)",
    "docstring": "Find the sum of digits of a number using recursion\n>>> sum_of_digits_recursion(12345)\n15\n>>> sum_of_digits_recursion(123)\n6\n>>> sum_of_digits_recursion(-123)\n6\n>>> sum_of_digits_recursion(0)\n0"
  },
  {
    "function": "sum_of_digits_compact",
    "code": "def sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))",
    "docstring": "Find the sum of digits of a number\n>>> sum_of_digits_compact(12345)\n15\n>>> sum_of_digits_compact(123)\n6\n>>> sum_of_digits_compact(-123)\n6\n>>> sum_of_digits_compact(0)\n0"
  },
  {
    "function": "benchmark",
    "code": "def benchmark() -> None:\n    \"\"\"\n    Benchmark multiple functions, with three different length int values.\n    \"\"\"\n    from collections.abc import Callable\n    from timeit import timeit\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")\n\n    for value in (262144, 1125899906842624, 1267650600228229401496703205376):\n        for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):\n            benchmark_a_function(func, value)\n        print()",
    "docstring": "Benchmark multiple functions, with three different length int values."
  },
  {
    "function": "sum_of_geometric_progression",
    "code": "def sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)",
    "docstring": "\"\nReturn the sum of n terms in a geometric progression.\n>>> sum_of_geometric_progression(1, 2, 10)\n1023.0\n>>> sum_of_geometric_progression(1, 10, 5)\n11111.0\n>>> sum_of_geometric_progression(0, 2, 10)\n0.0\n>>> sum_of_geometric_progression(1, 0, 10)\n1.0\n>>> sum_of_geometric_progression(1, 2, 0)\n-0.0\n>>> sum_of_geometric_progression(-1, 2, 10)\n-1023.0\n>>> sum_of_geometric_progression(1, -2, 10)\n-341.0\n>>> sum_of_geometric_progression(1, 2, -10)\n-0.9990234375"
  },
  {
    "function": "sum_of_harmonic_progression",
    "code": "def sum_of_harmonic_progression(\n    first_term: float, common_difference: float, number_of_terms: int\n) -> float:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)\n\n    Find the sum of n terms in an harmonic progression.  The calculation starts with the\n    first_term and loops adding the common difference of Arithmetic Progression by which\n    the given Harmonic Progression is linked.\n\n    >>> sum_of_harmonic_progression(1 / 2, 2, 2)\n    0.75\n    >>> sum_of_harmonic_progression(1 / 5, 5, 5)\n    0.45666666666666667\n    \"\"\"\n    arithmetic_progression = [1 / first_term]\n    first_term = 1 / first_term\n    for _ in range(number_of_terms - 1):\n        first_term += common_difference\n        arithmetic_progression.append(first_term)\n    harmonic_series = [1 / step for step in arithmetic_progression]\n    return sum(harmonic_series)",
    "docstring": "https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)\n\nFind the sum of n terms in an harmonic progression.  The calculation starts with the\nfirst_term and loops adding the common difference of Arithmetic Progression by which\nthe given Harmonic Progression is linked.\n\n>>> sum_of_harmonic_progression(1 / 2, 2, 2)\n0.75\n>>> sum_of_harmonic_progression(1 / 5, 5, 5)\n0.45666666666666667"
  },
  {
    "function": "sylvester",
    "code": "def sylvester(number: int) -> int:\n    \"\"\"\n    :param number: nth number to calculate in the sequence\n    :return: the nth number in Sylvester's sequence\n\n    >>> sylvester(8)\n    113423713055421844361000443\n\n    >>> sylvester(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value of [n=-1] has to be > 0\n\n    >>> sylvester(8.0)\n    Traceback (most recent call last):\n        ...\n    AssertionError: The input value of [n=8.0] is not an integer\n    \"\"\"\n    assert isinstance(number, int), f\"The input value of [n={number}] is not an integer\"\n\n    if number == 1:\n        return 2\n    elif number < 1:\n        msg = f\"The input value of [n={number}] has to be > 0\"\n        raise ValueError(msg)\n    else:\n        num = sylvester(number - 1)\n        lower = num - 1\n        upper = num\n        return lower * upper + 1",
    "docstring": ":param number: nth number to calculate in the sequence\n:return: the nth number in Sylvester's sequence\n\n>>> sylvester(8)\n113423713055421844361000443\n\n>>> sylvester(-1)\nTraceback (most recent call last):\n    ...\nValueError: The input value of [n=-1] has to be > 0\n\n>>> sylvester(8.0)\nTraceback (most recent call last):\n    ...\nAssertionError: The input value of [n=8.0] is not an integer"
  },
  {
    "function": "tangent_hyperbolic",
    "code": "def tangent_hyperbolic(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n        Implements the tanh function\n\n        Parameters:\n            vector: np.ndarray\n\n        Returns:\n            tanh (np.array): The input numpy array after applying tanh.\n\n        mathematically (e^x - e^(-x))/(e^x + e^(-x)) can be written as (2/(1+e^(-2x))-1\n\n    Examples:\n        >>> tangent_hyperbolic(np.array([1,5,6,-0.67]))\n        array([ 0.76159416,  0.9999092 ,  0.99998771, -0.58497988])\n\n        >>> tangent_hyperbolic(np.array([8,10,2,-0.98,13]))\n        array([ 0.99999977,  1.        ,  0.96402758, -0.7530659 ,  1.        ])\n\n    \"\"\"\n\n    return (2 / (1 + np.exp(-2 * vector))) - 1",
    "docstring": "Implements the tanh function\n\n    Parameters:\n        vector: np.ndarray\n\n    Returns:\n        tanh (np.array): The input numpy array after applying tanh.\n\n    mathematically (e^x - e^(-x))/(e^x + e^(-x)) can be written as (2/(1+e^(-2x))-1\n\nExamples:\n    >>> tangent_hyperbolic(np.array([1,5,6,-0.67]))\n    array([ 0.76159416,  0.9999092 ,  0.99998771, -0.58497988])\n\n    >>> tangent_hyperbolic(np.array([8,10,2,-0.98,13]))\n    array([ 0.99999977,  1.        ,  0.96402758, -0.7530659 ,  1.        ])"
  },
  {
    "function": "three_sum",
    "code": "def three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans",
    "docstring": "Find all unique triplets in a sorted array of integers that sum up to zero.\n\nArgs:\n    nums: A sorted list of integers.\n\nReturns:\n    A list of lists containing unique triplets that sum up to zero.\n\n>>> three_sum([-1, 0, 1, 2, -1, -4])\n[[-1, -1, 2], [-1, 0, 1]]\n>>> three_sum([1, 2, 3, 4])\n[]"
  },
  {
    "function": "trapezoidal_rule",
    "code": "def trapezoidal_rule(boundary, steps):\n    \"\"\"\n    Implements the extended trapezoidal rule for numerical integration.\n    The function f(x) is provided below.\n\n    :param boundary: List containing the lower and upper bounds of integration [a, b]\n    :param steps: The number of steps (intervals) used in the approximation\n    :return: The numerical approximation of the integral\n\n    >>> abs(trapezoidal_rule([0, 1], 10) - 0.33333) < 0.01\n    True\n    >>> abs(trapezoidal_rule([0, 1], 100) - 0.33333) < 0.01\n    True\n    >>> abs(trapezoidal_rule([0, 2], 1000) - 2.66667) < 0.01\n    True\n    >>> abs(trapezoidal_rule([1, 2], 1000) - 2.33333) < 0.01\n    True\n    \"\"\"\n    h = (boundary[1] - boundary[0]) / steps\n    a = boundary[0]\n    b = boundary[1]\n    x_i = make_points(a, b, h)\n    y = 0.0\n    y += (h / 2.0) * f(a)\n    for i in x_i:\n        y += h * f(i)\n    y += (h / 2.0) * f(b)\n    return y",
    "docstring": "Implements the extended trapezoidal rule for numerical integration.\nThe function f(x) is provided below.\n\n:param boundary: List containing the lower and upper bounds of integration [a, b]\n:param steps: The number of steps (intervals) used in the approximation\n:return: The numerical approximation of the integral\n\n>>> abs(trapezoidal_rule([0, 1], 10) - 0.33333) < 0.01\nTrue\n>>> abs(trapezoidal_rule([0, 1], 100) - 0.33333) < 0.01\nTrue\n>>> abs(trapezoidal_rule([0, 2], 1000) - 2.66667) < 0.01\nTrue\n>>> abs(trapezoidal_rule([1, 2], 1000) - 2.33333) < 0.01\nTrue"
  },
  {
    "function": "make_points",
    "code": "def make_points(a, b, h):\n    \"\"\"\n    Generates points between a and b with step size h for trapezoidal integration.\n\n    :param a: The lower bound of integration\n    :param b: The upper bound of integration\n    :param h: The step size\n    :yield: The next x-value in the range (a, b)\n\n    >>> list(make_points(0, 1, 0.1))    # doctest: +NORMALIZE_WHITESPACE\n    [0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6, 0.7, 0.7999999999999999, \\\n    0.8999999999999999]\n    >>> list(make_points(0, 10, 2.5))\n    [2.5, 5.0, 7.5]\n    >>> list(make_points(0, 10, 2))\n    [2, 4, 6, 8]\n    >>> list(make_points(1, 21, 5))\n    [6, 11, 16]\n    >>> list(make_points(1, 5, 2))\n    [3]\n    >>> list(make_points(1, 4, 3))\n    []\n    \"\"\"\n    x = a + h\n    while x <= (b - h):\n        yield x\n        x += h",
    "docstring": "Generates points between a and b with step size h for trapezoidal integration.\n\n:param a: The lower bound of integration\n:param b: The upper bound of integration\n:param h: The step size\n:yield: The next x-value in the range (a, b)\n\n>>> list(make_points(0, 1, 0.1))    # doctest: +NORMALIZE_WHITESPACE\n[0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6, 0.7, 0.7999999999999999,     0.8999999999999999]\n>>> list(make_points(0, 10, 2.5))\n[2.5, 5.0, 7.5]\n>>> list(make_points(0, 10, 2))\n[2, 4, 6, 8]\n>>> list(make_points(1, 21, 5))\n[6, 11, 16]\n>>> list(make_points(1, 5, 2))\n[3]\n>>> list(make_points(1, 4, 3))\n[]"
  },
  {
    "function": "f",
    "code": "def f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2",
    "docstring": "This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n:param x: The input value\n:return: The value of f(x)\n\n>>> f(0)\n0\n>>> f(1)\n1\n>>> f(0.5)\n0.25"
  },
  {
    "function": "main",
    "code": "def main():\n    \"\"\"\n    Main function to test the trapezoidal rule.\n    :a: Lower bound of integration\n    :b: Upper bound of integration\n    :steps: define number of steps or resolution\n    :boundary: define boundary of integration\n\n    >>> main()\n    y = 0.3349999999999999\n    \"\"\"\n    a = 0.0\n    b = 1.0\n    steps = 10.0\n    boundary = [a, b]\n    y = trapezoidal_rule(boundary, steps)\n    print(f\"y = {y}\")",
    "docstring": "Main function to test the trapezoidal rule.\n:a: Lower bound of integration\n:b: Upper bound of integration\n:steps: define number of steps or resolution\n:boundary: define boundary of integration\n\n>>> main()\ny = 0.3349999999999999"
  },
  {
    "function": "triplet_sum1",
    "code": "def triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:\n    \"\"\"\n    Returns a triplet in the array with sum equal to target,\n    else (0, 0, 0).\n    >>> triplet_sum1([13, 29, 7, 23, 5], 35)\n    (5, 7, 23)\n    >>> triplet_sum1([37, 9, 19, 50, 44], 65)\n    (9, 19, 37)\n    >>> arr = [6, 47, 27, 1, 15]\n    >>> target = 11\n    >>> triplet_sum1(arr, target)\n    (0, 0, 0)\n    \"\"\"\n    for triplet in permutations(arr, 3):\n        if sum(triplet) == target:\n            return tuple(sorted(triplet))\n    return (0, 0, 0)",
    "docstring": "Returns a triplet in the array with sum equal to target,\nelse (0, 0, 0).\n>>> triplet_sum1([13, 29, 7, 23, 5], 35)\n(5, 7, 23)\n>>> triplet_sum1([37, 9, 19, 50, 44], 65)\n(9, 19, 37)\n>>> arr = [6, 47, 27, 1, 15]\n>>> target = 11\n>>> triplet_sum1(arr, target)\n(0, 0, 0)"
  },
  {
    "function": "triplet_sum2",
    "code": "def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:\n    \"\"\"\n    Returns a triplet in the array with sum equal to target,\n    else (0, 0, 0).\n    >>> triplet_sum2([13, 29, 7, 23, 5], 35)\n    (5, 7, 23)\n    >>> triplet_sum2([37, 9, 19, 50, 44], 65)\n    (9, 19, 37)\n    >>> arr = [6, 47, 27, 1, 15]\n    >>> target = 11\n    >>> triplet_sum2(arr, target)\n    (0, 0, 0)\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n - 1):\n        left, right = i + 1, n - 1\n        while left < right:\n            if arr[i] + arr[left] + arr[right] == target:\n                return (arr[i], arr[left], arr[right])\n            elif arr[i] + arr[left] + arr[right] < target:\n                left += 1\n            elif arr[i] + arr[left] + arr[right] > target:\n                right -= 1\n    return (0, 0, 0)",
    "docstring": "Returns a triplet in the array with sum equal to target,\nelse (0, 0, 0).\n>>> triplet_sum2([13, 29, 7, 23, 5], 35)\n(5, 7, 23)\n>>> triplet_sum2([37, 9, 19, 50, 44], 65)\n(9, 19, 37)\n>>> arr = [6, 47, 27, 1, 15]\n>>> target = 11\n>>> triplet_sum2(arr, target)\n(0, 0, 0)"
  },
  {
    "function": "twin_prime",
    "code": "def twin_prime(number: int) -> int:\n    \"\"\"\n    # doctest: +NORMALIZE_WHITESPACE\n    This functions takes an integer number as input.\n    returns n+2 if n and n+2 are prime numbers and -1 otherwise.\n    >>> twin_prime(3)\n    5\n    >>> twin_prime(4)\n    -1\n    >>> twin_prime(5)\n    7\n    >>> twin_prime(17)\n    19\n    >>> twin_prime(0)\n    -1\n    >>> twin_prime(6.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=6.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if is_prime(number) and is_prime(number + 2):\n        return number + 2\n    else:\n        return -1",
    "docstring": "# doctest: +NORMALIZE_WHITESPACE\nThis functions takes an integer number as input.\nreturns n+2 if n and n+2 are prime numbers and -1 otherwise.\n>>> twin_prime(3)\n5\n>>> twin_prime(4)\n-1\n>>> twin_prime(5)\n7\n>>> twin_prime(17)\n19\n>>> twin_prime(0)\n-1\n>>> twin_prime(6.0)\nTraceback (most recent call last):\n    ...\nTypeError: Input value of [number=6.0] must be an integer"
  },
  {
    "function": "two_pointer",
    "code": "def two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []",
    "docstring": ">>> two_pointer([2, 7, 11, 15], 9)\n[0, 1]\n>>> two_pointer([2, 7, 11, 15], 17)\n[0, 3]\n>>> two_pointer([2, 7, 11, 15], 18)\n[1, 2]\n>>> two_pointer([2, 7, 11, 15], 26)\n[2, 3]\n>>> two_pointer([1, 3, 3], 6)\n[1, 2]\n>>> two_pointer([2, 7, 11, 15], 8)\n[]\n>>> two_pointer([3 * i for i in range(10)], 19)\n[]\n>>> two_pointer([1, 2, 3], 6)\n[]"
  },
  {
    "function": "two_sum",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum([15, 2, 11, 7], 13)\n    [1, 2]\n    >>> two_sum([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum([7, 15, 11, 2], 18)\n    [0, 2]\n    >>> two_sum([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum([2, 7, 11, 15], 8)\n    []\n    >>> two_sum([3 * i for i in range(10)], 19)\n    []\n    \"\"\"\n    chk_map: dict[int, int] = {}\n    for index, val in enumerate(nums):\n        compl = target - val\n        if compl in chk_map:\n            return [chk_map[compl], index]\n        chk_map[val] = index\n    return []",
    "docstring": ">>> two_sum([2, 7, 11, 15], 9)\n[0, 1]\n>>> two_sum([15, 2, 11, 7], 13)\n[1, 2]\n>>> two_sum([2, 7, 11, 15], 17)\n[0, 3]\n>>> two_sum([7, 15, 11, 2], 18)\n[0, 2]\n>>> two_sum([2, 7, 11, 15], 26)\n[2, 3]\n>>> two_sum([2, 7, 11, 15], 8)\n[]\n>>> two_sum([3 * i for i in range(10)], 19)\n[]"
  },
  {
    "function": "vol_cube",
    "code": "def vol_cube(side_length: float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    >>> vol_cube(0)\n    0.0\n    >>> vol_cube(1.6)\n    4.096000000000001\n    >>> vol_cube(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cube() only accepts non-negative values\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"vol_cube() only accepts non-negative values\")\n    return pow(side_length, 3)",
    "docstring": "Calculate the Volume of a Cube.\n\n>>> vol_cube(1)\n1.0\n>>> vol_cube(3)\n27.0\n>>> vol_cube(0)\n0.0\n>>> vol_cube(1.6)\n4.096000000000001\n>>> vol_cube(-1)\nTraceback (most recent call last):\n    ...\nValueError: vol_cube() only accepts non-negative values"
  },
  {
    "function": "vol_spherical_cap",
    "code": "def vol_spherical_cap(height: float, radius: float) -> float:\n    \"\"\"\n    Calculate the volume of the spherical cap.\n\n    >>> vol_spherical_cap(1, 2)\n    5.235987755982988\n    >>> vol_spherical_cap(1.6, 2.6)\n    16.621119532592402\n    >>> vol_spherical_cap(0, 0)\n    0.0\n    >>> vol_spherical_cap(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spherical_cap() only accepts non-negative values\n    >>> vol_spherical_cap(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spherical_cap() only accepts non-negative values\n    \"\"\"\n    if height < 0 or radius < 0:\n        raise ValueError(\"vol_spherical_cap() only accepts non-negative values\")\n    # Volume is 1/3 pi * height squared * (3 * radius - height)\n    return 1 / 3 * pi * pow(height, 2) * (3 * radius - height)",
    "docstring": "Calculate the volume of the spherical cap.\n\n>>> vol_spherical_cap(1, 2)\n5.235987755982988\n>>> vol_spherical_cap(1.6, 2.6)\n16.621119532592402\n>>> vol_spherical_cap(0, 0)\n0.0\n>>> vol_spherical_cap(-1, 2)\nTraceback (most recent call last):\n    ...\nValueError: vol_spherical_cap() only accepts non-negative values\n>>> vol_spherical_cap(1, -2)\nTraceback (most recent call last):\n    ...\nValueError: vol_spherical_cap() only accepts non-negative values"
  },
  {
    "function": "vol_spheres_intersect",
    "code": "def vol_spheres_intersect(\n    radius_1: float, radius_2: float, centers_distance: float\n) -> float:\n    r\"\"\"\n    Calculate the volume of the intersection of two spheres.\n\n    The intersection is composed by two spherical caps and therefore its volume is the\n    sum of the volumes of the spherical caps.\n    First, it calculates the heights :math:`(h_1, h_2)` of the spherical caps,\n    then the two volumes and it returns the sum.\n    The height formulas are\n\n    .. math::\n        h_1 = \\frac{(radius_1 - radius_2 + centers\\_distance)\n                    \\cdot (radius_1 + radius_2 - centers\\_distance)}\n                   {2 \\cdot centers\\_distance}\n\n        h_2 = \\frac{(radius_2 - radius_1 + centers\\_distance)\n                    \\cdot (radius_2 + radius_1 - centers\\_distance)}\n                   {2 \\cdot centers\\_distance}\n\n    if `centers_distance` is 0 then it returns the volume of the smallers sphere\n\n    :return: ``vol_spherical_cap`` (:math:`h_1`, :math:`radius_2`)\n             + ``vol_spherical_cap`` (:math:`h_2`, :math:`radius_1`)\n\n    >>> vol_spheres_intersect(2, 2, 1)\n    21.205750411731103\n    >>> vol_spheres_intersect(2.6, 2.6, 1.6)\n    40.71504079052372\n    >>> vol_spheres_intersect(0, 0, 0)\n    0.0\n    >>> vol_spheres_intersect(-2, 2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spheres_intersect() only accepts non-negative values\n    >>> vol_spheres_intersect(2, -2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spheres_intersect() only accepts non-negative values\n    >>> vol_spheres_intersect(2, 2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spheres_intersect() only accepts non-negative values\n    \"\"\"\n    if radius_1 < 0 or radius_2 < 0 or centers_distance < 0:\n        raise ValueError(\"vol_spheres_intersect() only accepts non-negative values\")\n    if centers_distance == 0:\n        return vol_sphere(min(radius_1, radius_2))\n\n    h1 = (\n        (radius_1 - radius_2 + centers_distance)\n        * (radius_1 + radius_2 - centers_distance)\n        / (2 * centers_distance)\n    )\n    h2 = (\n        (radius_2 - radius_1 + centers_distance)\n        * (radius_2 + radius_1 - centers_distance)\n        / (2 * centers_distance)\n    )\n\n    return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)",
    "docstring": "Calculate the volume of the intersection of two spheres.\n\nThe intersection is composed by two spherical caps and therefore its volume is the\nsum of the volumes of the spherical caps.\nFirst, it calculates the heights :math:`(h_1, h_2)` of the spherical caps,\nthen the two volumes and it returns the sum.\nThe height formulas are\n\n.. math::\n    h_1 = \\frac{(radius_1 - radius_2 + centers\\_distance)\n                \\cdot (radius_1 + radius_2 - centers\\_distance)}\n               {2 \\cdot centers\\_distance}\n\n    h_2 = \\frac{(radius_2 - radius_1 + centers\\_distance)\n                \\cdot (radius_2 + radius_1 - centers\\_distance)}\n               {2 \\cdot centers\\_distance}\n\nif `centers_distance` is 0 then it returns the volume of the smallers sphere\n\n:return: ``vol_spherical_cap`` (:math:`h_1`, :math:`radius_2`)\n         + ``vol_spherical_cap`` (:math:`h_2`, :math:`radius_1`)\n\n>>> vol_spheres_intersect(2, 2, 1)\n21.205750411731103\n>>> vol_spheres_intersect(2.6, 2.6, 1.6)\n40.71504079052372\n>>> vol_spheres_intersect(0, 0, 0)\n0.0\n>>> vol_spheres_intersect(-2, 2, 1)\nTraceback (most recent call last):\n    ...\nValueError: vol_spheres_intersect() only accepts non-negative values\n>>> vol_spheres_intersect(2, -2, 1)\nTraceback (most recent call last):\n    ...\nValueError: vol_spheres_intersect() only accepts non-negative values\n>>> vol_spheres_intersect(2, 2, -1)\nTraceback (most recent call last):\n    ...\nValueError: vol_spheres_intersect() only accepts non-negative values"
  },
  {
    "function": "vol_spheres_union",
    "code": "def vol_spheres_union(\n    radius_1: float, radius_2: float, centers_distance: float\n) -> float:\n    r\"\"\"\n    Calculate the volume of the union of two spheres that possibly intersect.\n\n    It is the sum of sphere :math:`A` and sphere :math:`B` minus their intersection.\n    First, it calculates the volumes :math:`(v_1, v_2)` of the spheres,\n    then the volume of the intersection :math:`i` and\n    it returns the sum :math:`v_1 + v_2 - i`.\n    If `centers_distance` is 0 then it returns the volume of the larger sphere\n\n    :return: ``vol_sphere`` (:math:`radius_1`) + ``vol_sphere`` (:math:`radius_2`)\n             - ``vol_spheres_intersect``\n             (:math:`radius_1`, :math:`radius_2`, :math:`centers\\_distance`)\n\n    >>> vol_spheres_union(2, 2, 1)\n    45.814892864851146\n    >>> vol_spheres_union(1.56, 2.2, 1.4)\n    48.77802773671288\n    >>> vol_spheres_union(0, 2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spheres_union() only accepts non-negative values, non-zero radius\n    >>> vol_spheres_union('1.56', '2.2', '1.4')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'str' and 'int'\n    >>> vol_spheres_union(1, None, 1)\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'NoneType' and 'int'\n    \"\"\"\n\n    if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:\n        raise ValueError(\n            \"vol_spheres_union() only accepts non-negative values, non-zero radius\"\n        )\n\n    if centers_distance == 0:\n        return vol_sphere(max(radius_1, radius_2))\n\n    return (\n        vol_sphere(radius_1)\n        + vol_sphere(radius_2)\n        - vol_spheres_intersect(radius_1, radius_2, centers_distance)\n    )",
    "docstring": "Calculate the volume of the union of two spheres that possibly intersect.\n\nIt is the sum of sphere :math:`A` and sphere :math:`B` minus their intersection.\nFirst, it calculates the volumes :math:`(v_1, v_2)` of the spheres,\nthen the volume of the intersection :math:`i` and\nit returns the sum :math:`v_1 + v_2 - i`.\nIf `centers_distance` is 0 then it returns the volume of the larger sphere\n\n:return: ``vol_sphere`` (:math:`radius_1`) + ``vol_sphere`` (:math:`radius_2`)\n         - ``vol_spheres_intersect``\n         (:math:`radius_1`, :math:`radius_2`, :math:`centers\\_distance`)\n\n>>> vol_spheres_union(2, 2, 1)\n45.814892864851146\n>>> vol_spheres_union(1.56, 2.2, 1.4)\n48.77802773671288\n>>> vol_spheres_union(0, 2, 1)\nTraceback (most recent call last):\n    ...\nValueError: vol_spheres_union() only accepts non-negative values, non-zero radius\n>>> vol_spheres_union('1.56', '2.2', '1.4')\nTraceback (most recent call last):\n    ...\nTypeError: '<=' not supported between instances of 'str' and 'int'\n>>> vol_spheres_union(1, None, 1)\nTraceback (most recent call last):\n    ...\nTypeError: '<=' not supported between instances of 'NoneType' and 'int'"
  },
  {
    "function": "vol_cuboid",
    "code": "def vol_cuboid(width: float, height: float, length: float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cuboid.\n\n    :return: multiple of `width`, `length` and `height`\n\n    >>> vol_cuboid(1, 1, 1)\n    1.0\n    >>> vol_cuboid(1, 2, 3)\n    6.0\n    >>> vol_cuboid(1.6, 2.6, 3.6)\n    14.976\n    >>> vol_cuboid(0, 0, 0)\n    0.0\n    >>> vol_cuboid(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    >>> vol_cuboid(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    >>> vol_cuboid(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    \"\"\"\n    if width < 0 or height < 0 or length < 0:\n        raise ValueError(\"vol_cuboid() only accepts non-negative values\")\n    return float(width * height * length)",
    "docstring": "Calculate the Volume of a Cuboid.\n\n:return: multiple of `width`, `length` and `height`\n\n>>> vol_cuboid(1, 1, 1)\n1.0\n>>> vol_cuboid(1, 2, 3)\n6.0\n>>> vol_cuboid(1.6, 2.6, 3.6)\n14.976\n>>> vol_cuboid(0, 0, 0)\n0.0\n>>> vol_cuboid(-1, 2, 3)\nTraceback (most recent call last):\n    ...\nValueError: vol_cuboid() only accepts non-negative values\n>>> vol_cuboid(1, -2, 3)\nTraceback (most recent call last):\n    ...\nValueError: vol_cuboid() only accepts non-negative values\n>>> vol_cuboid(1, 2, -3)\nTraceback (most recent call last):\n    ...\nValueError: vol_cuboid() only accepts non-negative values"
  },
  {
    "function": "vol_cone",
    "code": "def vol_cone(area_of_base: float, height: float) -> float:\n    r\"\"\"\n    | Calculate the Volume of a Cone.\n    | Wikipedia reference: https://en.wikipedia.org/wiki/Cone\n\n    :return: :math:`\\frac{1}{3} \\cdot area\\_of\\_base \\cdot height`\n\n    >>> vol_cone(10, 3)\n    10.0\n    >>> vol_cone(1, 1)\n    0.3333333333333333\n    >>> vol_cone(1.6, 1.6)\n    0.8533333333333335\n    >>> vol_cone(0, 0)\n    0.0\n    >>> vol_cone(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cone() only accepts non-negative values\n    >>> vol_cone(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cone() only accepts non-negative values\n    \"\"\"\n    if height < 0 or area_of_base < 0:\n        raise ValueError(\"vol_cone() only accepts non-negative values\")\n    return area_of_base * height / 3.0",
    "docstring": "| Calculate the Volume of a Cone.\n| Wikipedia reference: https://en.wikipedia.org/wiki/Cone\n\n:return: :math:`\\frac{1}{3} \\cdot area\\_of\\_base \\cdot height`\n\n>>> vol_cone(10, 3)\n10.0\n>>> vol_cone(1, 1)\n0.3333333333333333\n>>> vol_cone(1.6, 1.6)\n0.8533333333333335\n>>> vol_cone(0, 0)\n0.0\n>>> vol_cone(-1, 1)\nTraceback (most recent call last):\n    ...\nValueError: vol_cone() only accepts non-negative values\n>>> vol_cone(1, -1)\nTraceback (most recent call last):\n    ...\nValueError: vol_cone() only accepts non-negative values"
  },
  {
    "function": "vol_right_circ_cone",
    "code": "def vol_right_circ_cone(radius: float, height: float) -> float:\n    r\"\"\"\n    | Calculate the Volume of a Right Circular Cone.\n    | Wikipedia reference: https://en.wikipedia.org/wiki/Cone\n\n    :return: :math:`\\frac{1}{3} \\cdot \\pi \\cdot radius^2 \\cdot height`\n\n    >>> vol_right_circ_cone(2, 3)\n    12.566370614359172\n    >>> vol_right_circ_cone(0, 0)\n    0.0\n    >>> vol_right_circ_cone(1.6, 1.6)\n    4.289321169701265\n    >>> vol_right_circ_cone(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_right_circ_cone() only accepts non-negative values\n    >>> vol_right_circ_cone(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_right_circ_cone() only accepts non-negative values\n    \"\"\"\n    if height < 0 or radius < 0:\n        raise ValueError(\"vol_right_circ_cone() only accepts non-negative values\")\n    return pi * pow(radius, 2) * height / 3.0",
    "docstring": "| Calculate the Volume of a Right Circular Cone.\n| Wikipedia reference: https://en.wikipedia.org/wiki/Cone\n\n:return: :math:`\\frac{1}{3} \\cdot \\pi \\cdot radius^2 \\cdot height`\n\n>>> vol_right_circ_cone(2, 3)\n12.566370614359172\n>>> vol_right_circ_cone(0, 0)\n0.0\n>>> vol_right_circ_cone(1.6, 1.6)\n4.289321169701265\n>>> vol_right_circ_cone(-1, 1)\nTraceback (most recent call last):\n    ...\nValueError: vol_right_circ_cone() only accepts non-negative values\n>>> vol_right_circ_cone(1, -1)\nTraceback (most recent call last):\n    ...\nValueError: vol_right_circ_cone() only accepts non-negative values"
  },
  {
    "function": "vol_prism",
    "code": "def vol_prism(area_of_base: float, height: float) -> float:\n    r\"\"\"\n    | Calculate the Volume of a Prism.\n    | Wikipedia reference: https://en.wikipedia.org/wiki/Prism_(geometry)\n\n    :return: :math:`V = B \\cdot h`\n\n    >>> vol_prism(10, 2)\n    20.0\n    >>> vol_prism(11, 1)\n    11.0\n    >>> vol_prism(1.6, 1.6)\n    2.5600000000000005\n    >>> vol_prism(0, 0)\n    0.0\n    >>> vol_prism(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_prism() only accepts non-negative values\n    >>> vol_prism(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_prism() only accepts non-negative values\n    \"\"\"\n    if height < 0 or area_of_base < 0:\n        raise ValueError(\"vol_prism() only accepts non-negative values\")\n    return float(area_of_base * height)",
    "docstring": "| Calculate the Volume of a Prism.\n| Wikipedia reference: https://en.wikipedia.org/wiki/Prism_(geometry)\n\n:return: :math:`V = B \\cdot h`\n\n>>> vol_prism(10, 2)\n20.0\n>>> vol_prism(11, 1)\n11.0\n>>> vol_prism(1.6, 1.6)\n2.5600000000000005\n>>> vol_prism(0, 0)\n0.0\n>>> vol_prism(-1, 1)\nTraceback (most recent call last):\n    ...\nValueError: vol_prism() only accepts non-negative values\n>>> vol_prism(1, -1)\nTraceback (most recent call last):\n    ...\nValueError: vol_prism() only accepts non-negative values"
  },
  {
    "function": "vol_pyramid",
    "code": "def vol_pyramid(area_of_base: float, height: float) -> float:\n    r\"\"\"\n    | Calculate the Volume of a Pyramid.\n    | Wikipedia reference: https://en.wikipedia.org/wiki/Pyramid_(geometry)\n\n    :return: :math:`\\frac{1}{3} \\cdot B \\cdot h`\n\n    >>> vol_pyramid(10, 3)\n    10.0\n    >>> vol_pyramid(1.5, 3)\n    1.5\n    >>> vol_pyramid(1.6, 1.6)\n    0.8533333333333335\n    >>> vol_pyramid(0, 0)\n    0.0\n    >>> vol_pyramid(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_pyramid() only accepts non-negative values\n    >>> vol_pyramid(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_pyramid() only accepts non-negative values\n    \"\"\"\n    if height < 0 or area_of_base < 0:\n        raise ValueError(\"vol_pyramid() only accepts non-negative values\")\n    return area_of_base * height / 3.0",
    "docstring": "| Calculate the Volume of a Pyramid.\n| Wikipedia reference: https://en.wikipedia.org/wiki/Pyramid_(geometry)\n\n:return: :math:`\\frac{1}{3} \\cdot B \\cdot h`\n\n>>> vol_pyramid(10, 3)\n10.0\n>>> vol_pyramid(1.5, 3)\n1.5\n>>> vol_pyramid(1.6, 1.6)\n0.8533333333333335\n>>> vol_pyramid(0, 0)\n0.0\n>>> vol_pyramid(-1, 1)\nTraceback (most recent call last):\n    ...\nValueError: vol_pyramid() only accepts non-negative values\n>>> vol_pyramid(1, -1)\nTraceback (most recent call last):\n    ...\nValueError: vol_pyramid() only accepts non-negative values"
  },
  {
    "function": "vol_sphere",
    "code": "def vol_sphere(radius: float) -> float:\n    r\"\"\"\n    | Calculate the Volume of a Sphere.\n    | Wikipedia reference: https://en.wikipedia.org/wiki/Sphere\n\n    :return: :math:`\\frac{4}{3} \\cdot \\pi \\cdot r^3`\n\n    >>> vol_sphere(5)\n    523.5987755982989\n    >>> vol_sphere(1)\n    4.1887902047863905\n    >>> vol_sphere(1.6)\n    17.15728467880506\n    >>> vol_sphere(0)\n    0.0\n    >>> vol_sphere(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_sphere() only accepts non-negative values\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"vol_sphere() only accepts non-negative values\")\n    # Volume is 4/3 * pi * radius cubed\n    return 4 / 3 * pi * pow(radius, 3)",
    "docstring": "| Calculate the Volume of a Sphere.\n| Wikipedia reference: https://en.wikipedia.org/wiki/Sphere\n\n:return: :math:`\\frac{4}{3} \\cdot \\pi \\cdot r^3`\n\n>>> vol_sphere(5)\n523.5987755982989\n>>> vol_sphere(1)\n4.1887902047863905\n>>> vol_sphere(1.6)\n17.15728467880506\n>>> vol_sphere(0)\n0.0\n>>> vol_sphere(-1)\nTraceback (most recent call last):\n    ...\nValueError: vol_sphere() only accepts non-negative values"
  },
  {
    "function": "vol_hemisphere",
    "code": "def vol_hemisphere(radius: float) -> float:\n    r\"\"\"\n    | Calculate the volume of a hemisphere\n    | Wikipedia reference: https://en.wikipedia.org/wiki/Hemisphere\n    | Other references: https://www.cuemath.com/geometry/hemisphere\n\n    :return: :math:`\\frac{2}{3} \\cdot \\pi \\cdot radius^3`\n\n    >>> vol_hemisphere(1)\n    2.0943951023931953\n    >>> vol_hemisphere(7)\n    718.377520120866\n    >>> vol_hemisphere(1.6)\n    8.57864233940253\n    >>> vol_hemisphere(0)\n    0.0\n    >>> vol_hemisphere(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_hemisphere() only accepts non-negative values\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"vol_hemisphere() only accepts non-negative values\")\n    # Volume is radius cubed * pi * 2/3\n    return pow(radius, 3) * pi * 2 / 3",
    "docstring": "| Calculate the volume of a hemisphere\n| Wikipedia reference: https://en.wikipedia.org/wiki/Hemisphere\n| Other references: https://www.cuemath.com/geometry/hemisphere\n\n:return: :math:`\\frac{2}{3} \\cdot \\pi \\cdot radius^3`\n\n>>> vol_hemisphere(1)\n2.0943951023931953\n>>> vol_hemisphere(7)\n718.377520120866\n>>> vol_hemisphere(1.6)\n8.57864233940253\n>>> vol_hemisphere(0)\n0.0\n>>> vol_hemisphere(-1)\nTraceback (most recent call last):\n    ...\nValueError: vol_hemisphere() only accepts non-negative values"
  },
  {
    "function": "vol_circular_cylinder",
    "code": "def vol_circular_cylinder(radius: float, height: float) -> float:\n    r\"\"\"\n    | Calculate the Volume of a Circular Cylinder.\n    | Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder\n\n    :return: :math:`\\pi \\cdot radius^2 \\cdot height`\n\n    >>> vol_circular_cylinder(1, 1)\n    3.141592653589793\n    >>> vol_circular_cylinder(4, 3)\n    150.79644737231007\n    >>> vol_circular_cylinder(1.6, 1.6)\n    12.867963509103795\n    >>> vol_circular_cylinder(0, 0)\n    0.0\n    >>> vol_circular_cylinder(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_circular_cylinder() only accepts non-negative values\n    >>> vol_circular_cylinder(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_circular_cylinder() only accepts non-negative values\n    \"\"\"\n    if height < 0 or radius < 0:\n        raise ValueError(\"vol_circular_cylinder() only accepts non-negative values\")\n    # Volume is radius squared * height * pi\n    return pow(radius, 2) * height * pi",
    "docstring": "| Calculate the Volume of a Circular Cylinder.\n| Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder\n\n:return: :math:`\\pi \\cdot radius^2 \\cdot height`\n\n>>> vol_circular_cylinder(1, 1)\n3.141592653589793\n>>> vol_circular_cylinder(4, 3)\n150.79644737231007\n>>> vol_circular_cylinder(1.6, 1.6)\n12.867963509103795\n>>> vol_circular_cylinder(0, 0)\n0.0\n>>> vol_circular_cylinder(-1, 1)\nTraceback (most recent call last):\n    ...\nValueError: vol_circular_cylinder() only accepts non-negative values\n>>> vol_circular_cylinder(1, -1)\nTraceback (most recent call last):\n    ...\nValueError: vol_circular_cylinder() only accepts non-negative values"
  },
  {
    "function": "vol_hollow_circular_cylinder",
    "code": "def vol_hollow_circular_cylinder(\n    inner_radius: float, outer_radius: float, height: float\n) -> float:\n    \"\"\"\n    Calculate the Volume of a Hollow Circular Cylinder.\n\n    >>> vol_hollow_circular_cylinder(1, 2, 3)\n    28.274333882308138\n    >>> vol_hollow_circular_cylinder(1.6, 2.6, 3.6)\n    47.50088092227767\n    >>> vol_hollow_circular_cylinder(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_hollow_circular_cylinder() only accepts non-negative values\n    >>> vol_hollow_circular_cylinder(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_hollow_circular_cylinder() only accepts non-negative values\n    >>> vol_hollow_circular_cylinder(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_hollow_circular_cylinder() only accepts non-negative values\n    >>> vol_hollow_circular_cylinder(2, 1, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: outer_radius must be greater than inner_radius\n    >>> vol_hollow_circular_cylinder(0, 0, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: outer_radius must be greater than inner_radius\n    \"\"\"\n    # Volume - (outer_radius squared - inner_radius squared) * pi * height\n    if inner_radius < 0 or outer_radius < 0 or height < 0:\n        raise ValueError(\n            \"vol_hollow_circular_cylinder() only accepts non-negative values\"\n        )\n    if outer_radius <= inner_radius:\n        raise ValueError(\"outer_radius must be greater than inner_radius\")\n    return pi * (pow(outer_radius, 2) - pow(inner_radius, 2)) * height",
    "docstring": "Calculate the Volume of a Hollow Circular Cylinder.\n\n>>> vol_hollow_circular_cylinder(1, 2, 3)\n28.274333882308138\n>>> vol_hollow_circular_cylinder(1.6, 2.6, 3.6)\n47.50088092227767\n>>> vol_hollow_circular_cylinder(-1, 2, 3)\nTraceback (most recent call last):\n    ...\nValueError: vol_hollow_circular_cylinder() only accepts non-negative values\n>>> vol_hollow_circular_cylinder(1, -2, 3)\nTraceback (most recent call last):\n    ...\nValueError: vol_hollow_circular_cylinder() only accepts non-negative values\n>>> vol_hollow_circular_cylinder(1, 2, -3)\nTraceback (most recent call last):\n    ...\nValueError: vol_hollow_circular_cylinder() only accepts non-negative values\n>>> vol_hollow_circular_cylinder(2, 1, 3)\nTraceback (most recent call last):\n    ...\nValueError: outer_radius must be greater than inner_radius\n>>> vol_hollow_circular_cylinder(0, 0, 0)\nTraceback (most recent call last):\n    ...\nValueError: outer_radius must be greater than inner_radius"
  },
  {
    "function": "vol_conical_frustum",
    "code": "def vol_conical_frustum(height: float, radius_1: float, radius_2: float) -> float:\n    \"\"\"\n    | Calculate the Volume of a Conical Frustum.\n    | Wikipedia reference: https://en.wikipedia.org/wiki/Frustum\n\n    >>> vol_conical_frustum(45, 7, 28)\n    48490.482608158454\n    >>> vol_conical_frustum(1, 1, 2)\n    7.330382858376184\n    >>> vol_conical_frustum(1.6, 2.6, 3.6)\n    48.7240076620753\n    >>> vol_conical_frustum(0, 0, 0)\n    0.0\n    >>> vol_conical_frustum(-2, 2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_conical_frustum() only accepts non-negative values\n    >>> vol_conical_frustum(2, -2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_conical_frustum() only accepts non-negative values\n    >>> vol_conical_frustum(2, 2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_conical_frustum() only accepts non-negative values\n    \"\"\"\n    # Volume is 1/3 * pi * height *\n    #           (radius_1 squared + radius_2 squared + radius_1 * radius_2)\n    if radius_1 < 0 or radius_2 < 0 or height < 0:\n        raise ValueError(\"vol_conical_frustum() only accepts non-negative values\")\n    return (\n        1\n        / 3\n        * pi\n        * height\n        * (pow(radius_1, 2) + pow(radius_2, 2) + radius_1 * radius_2)\n    )",
    "docstring": "| Calculate the Volume of a Conical Frustum.\n| Wikipedia reference: https://en.wikipedia.org/wiki/Frustum\n\n>>> vol_conical_frustum(45, 7, 28)\n48490.482608158454\n>>> vol_conical_frustum(1, 1, 2)\n7.330382858376184\n>>> vol_conical_frustum(1.6, 2.6, 3.6)\n48.7240076620753\n>>> vol_conical_frustum(0, 0, 0)\n0.0\n>>> vol_conical_frustum(-2, 2, 1)\nTraceback (most recent call last):\n    ...\nValueError: vol_conical_frustum() only accepts non-negative values\n>>> vol_conical_frustum(2, -2, 1)\nTraceback (most recent call last):\n    ...\nValueError: vol_conical_frustum() only accepts non-negative values\n>>> vol_conical_frustum(2, 2, -1)\nTraceback (most recent call last):\n    ...\nValueError: vol_conical_frustum() only accepts non-negative values"
  },
  {
    "function": "vol_torus",
    "code": "def vol_torus(torus_radius: float, tube_radius: float) -> float:\n    r\"\"\"\n    | Calculate the Volume of a Torus.\n    | Wikipedia reference: https://en.wikipedia.org/wiki/Torus\n\n    :return: :math:`2 \\pi^2 \\cdot torus\\_radius \\cdot tube\\_radius^2`\n\n    >>> vol_torus(1, 1)\n    19.739208802178716\n    >>> vol_torus(4, 3)\n    710.6115168784338\n    >>> vol_torus(3, 4)\n    947.4820225045784\n    >>> vol_torus(1.6, 1.6)\n    80.85179925372404\n    >>> vol_torus(0, 0)\n    0.0\n    >>> vol_torus(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_torus() only accepts non-negative values\n    >>> vol_torus(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_torus() only accepts non-negative values\n    \"\"\"\n    if torus_radius < 0 or tube_radius < 0:\n        raise ValueError(\"vol_torus() only accepts non-negative values\")\n    return 2 * pow(pi, 2) * torus_radius * pow(tube_radius, 2)",
    "docstring": "| Calculate the Volume of a Torus.\n| Wikipedia reference: https://en.wikipedia.org/wiki/Torus\n\n:return: :math:`2 \\pi^2 \\cdot torus\\_radius \\cdot tube\\_radius^2`\n\n>>> vol_torus(1, 1)\n19.739208802178716\n>>> vol_torus(4, 3)\n710.6115168784338\n>>> vol_torus(3, 4)\n947.4820225045784\n>>> vol_torus(1.6, 1.6)\n80.85179925372404\n>>> vol_torus(0, 0)\n0.0\n>>> vol_torus(-1, 1)\nTraceback (most recent call last):\n    ...\nValueError: vol_torus() only accepts non-negative values\n>>> vol_torus(1, -1)\nTraceback (most recent call last):\n    ...\nValueError: vol_torus() only accepts non-negative values"
  },
  {
    "function": "vol_icosahedron",
    "code": "def vol_icosahedron(tri_side: float) -> float:\n    \"\"\"\n    | Calculate the Volume of an Icosahedron.\n    | Wikipedia reference: https://en.wikipedia.org/wiki/Regular_icosahedron\n\n    >>> from math import isclose\n    >>> isclose(vol_icosahedron(2.5), 34.088984228514256)\n    True\n    >>> isclose(vol_icosahedron(10), 2181.694990624912374)\n    True\n    >>> isclose(vol_icosahedron(5), 272.711873828114047)\n    True\n    >>> isclose(vol_icosahedron(3.49), 92.740688412033628)\n    True\n    >>> vol_icosahedron(0)\n    0.0\n    >>> vol_icosahedron(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_icosahedron() only accepts non-negative values\n    >>> vol_icosahedron(-0.2)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_icosahedron() only accepts non-negative values\n    \"\"\"\n    if tri_side < 0:\n        raise ValueError(\"vol_icosahedron() only accepts non-negative values\")\n    return tri_side**3 * (3 + 5**0.5) * 5 / 12",
    "docstring": "| Calculate the Volume of an Icosahedron.\n| Wikipedia reference: https://en.wikipedia.org/wiki/Regular_icosahedron\n\n>>> from math import isclose\n>>> isclose(vol_icosahedron(2.5), 34.088984228514256)\nTrue\n>>> isclose(vol_icosahedron(10), 2181.694990624912374)\nTrue\n>>> isclose(vol_icosahedron(5), 272.711873828114047)\nTrue\n>>> isclose(vol_icosahedron(3.49), 92.740688412033628)\nTrue\n>>> vol_icosahedron(0)\n0.0\n>>> vol_icosahedron(-1)\nTraceback (most recent call last):\n    ...\nValueError: vol_icosahedron() only accepts non-negative values\n>>> vol_icosahedron(-0.2)\nTraceback (most recent call last):\n    ...\nValueError: vol_icosahedron() only accepts non-negative values"
  },
  {
    "function": "main",
    "code": "def main():\n    \"\"\"Print the Results of Various Volume Calculations.\"\"\"\n    print(\"Volumes:\")\n    print(f\"Cube: {vol_cube(2) = }\")  # = 8\n    print(f\"Cuboid: {vol_cuboid(2, 2, 2) = }\")  # = 8\n    print(f\"Cone: {vol_cone(2, 2) = }\")  # ~= 1.33\n    print(f\"Right Circular Cone: {vol_right_circ_cone(2, 2) = }\")  # ~= 8.38\n    print(f\"Prism: {vol_prism(2, 2) = }\")  # = 4\n    print(f\"Pyramid: {vol_pyramid(2, 2) = }\")  # ~= 1.33\n    print(f\"Sphere: {vol_sphere(2) = }\")  # ~= 33.5\n    print(f\"Hemisphere: {vol_hemisphere(2) = }\")  # ~= 16.75\n    print(f\"Circular Cylinder: {vol_circular_cylinder(2, 2) = }\")  # ~= 25.1\n    print(f\"Torus: {vol_torus(2, 2) = }\")  # ~= 157.9\n    print(f\"Conical Frustum: {vol_conical_frustum(2, 2, 4) = }\")  # ~= 58.6\n    print(f\"Spherical cap: {vol_spherical_cap(1, 2) = }\")  # ~= 5.24\n    print(f\"Spheres intersection: {vol_spheres_intersect(2, 2, 1) = }\")  # ~= 21.21\n    print(f\"Spheres union: {vol_spheres_union(2, 2, 1) = }\")  # ~= 45.81\n    print(\n        f\"Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }\"\n    )  # ~= 28.3\n    print(f\"Icosahedron: {vol_icosahedron(2.5) = }\")  # ~=34.09",
    "docstring": "Print the Results of Various Volume Calculations."
  },
  {
    "function": "zeller",
    "code": "def zeller(date_input: str) -> str:\n    \"\"\"\n    | Zellers Congruence Algorithm\n    | Find the day of the week for nearly any Gregorian or Julian calendar date\n\n    >>> zeller('01-31-2010')\n    'Your date 01-31-2010, is a Sunday!'\n\n    Validate out of range month:\n\n    >>> zeller('13-31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Month must be between 1 - 12\n    >>> zeller('.2-31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: '.2'\n\n    Validate out of range date:\n\n    >>> zeller('01-33-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date must be between 1 - 31\n    >>> zeller('01-.4-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: '.4'\n\n    Validate second separator:\n\n    >>> zeller('01-31*2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date separator must be '-' or '/'\n\n    Validate first separator:\n\n    >>> zeller('01^31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date separator must be '-' or '/'\n\n    Validate out of range year:\n\n    >>> zeller('01-31-8999')\n    Traceback (most recent call last):\n        ...\n    ValueError: Year out of range. There has to be some sort of limit...right?\n\n    Test null input:\n\n    >>> zeller()\n    Traceback (most recent call last):\n        ...\n    TypeError: zeller() missing 1 required positional argument: 'date_input'\n\n    Test length of `date_input`:\n\n    >>> zeller('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Must be 10 characters long\n    >>> zeller('01-31-19082939')\n    Traceback (most recent call last):\n        ...\n    ValueError: Must be 10 characters long\"\"\"\n\n    # Days of the week for response\n    days = {\n        \"0\": \"Sunday\",\n        \"1\": \"Monday\",\n        \"2\": \"Tuesday\",\n        \"3\": \"Wednesday\",\n        \"4\": \"Thursday\",\n        \"5\": \"Friday\",\n        \"6\": \"Saturday\",\n    }\n\n    convert_datetime_days = {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 0}\n\n    # Validate\n    if not 0 < len(date_input) < 11:\n        raise ValueError(\"Must be 10 characters long\")\n\n    # Get month\n    m: int = int(date_input[0] + date_input[1])\n    # Validate\n    if not 0 < m < 13:\n        raise ValueError(\"Month must be between 1 - 12\")\n\n    sep_1: str = date_input[2]\n    # Validate\n    if sep_1 not in [\"-\", \"/\"]:\n        raise ValueError(\"Date separator must be '-' or '/'\")\n\n    # Get day\n    d: int = int(date_input[3] + date_input[4])\n    # Validate\n    if not 0 < d < 32:\n        raise ValueError(\"Date must be between 1 - 31\")\n\n    # Get second separator\n    sep_2: str = date_input[5]\n    # Validate\n    if sep_2 not in [\"-\", \"/\"]:\n        raise ValueError(\"Date separator must be '-' or '/'\")\n\n    # Get year\n    y: int = int(date_input[6] + date_input[7] + date_input[8] + date_input[9])\n    # Arbitrary year range\n    if not 45 < y < 8500:\n        raise ValueError(\n            \"Year out of range. There has to be some sort of limit...right?\"\n        )\n\n    # Get datetime obj for validation\n    dt_ck = datetime.date(int(y), int(m), int(d))\n\n    # Start math\n    if m <= 2:\n        y = y - 1\n        m = m + 12\n    # maths var\n    c: int = int(str(y)[:2])\n    k: int = int(str(y)[2:])\n    t: int = int(2.6 * m - 5.39)\n    u: int = int(c / 4)\n    v: int = int(k / 4)\n    x: int = int(d + k)\n    z: int = int(t + u + v + x)\n    w: int = int(z - (2 * c))\n    f: int = round(w % 7)\n    # End math\n\n    # Validate math\n    if f != convert_datetime_days[dt_ck.weekday()]:\n        raise AssertionError(\"The date was evaluated incorrectly. Contact developer.\")\n\n    # Response\n    response: str = f\"Your date {date_input}, is a {days[str(f)]}!\"\n    return response",
    "docstring": "| Zellers Congruence Algorithm\n| Find the day of the week for nearly any Gregorian or Julian calendar date\n\n>>> zeller('01-31-2010')\n'Your date 01-31-2010, is a Sunday!'\n\nValidate out of range month:\n\n>>> zeller('13-31-2010')\nTraceback (most recent call last):\n    ...\nValueError: Month must be between 1 - 12\n>>> zeller('.2-31-2010')\nTraceback (most recent call last):\n    ...\nValueError: invalid literal for int() with base 10: '.2'\n\nValidate out of range date:\n\n>>> zeller('01-33-2010')\nTraceback (most recent call last):\n    ...\nValueError: Date must be between 1 - 31\n>>> zeller('01-.4-2010')\nTraceback (most recent call last):\n    ...\nValueError: invalid literal for int() with base 10: '.4'\n\nValidate second separator:\n\n>>> zeller('01-31*2010')\nTraceback (most recent call last):\n    ...\nValueError: Date separator must be '-' or '/'\n\nValidate first separator:\n\n>>> zeller('01^31-2010')\nTraceback (most recent call last):\n    ...\nValueError: Date separator must be '-' or '/'\n\nValidate out of range year:\n\n>>> zeller('01-31-8999')\nTraceback (most recent call last):\n    ...\nValueError: Year out of range. There has to be some sort of limit...right?\n\nTest null input:\n\n>>> zeller()\nTraceback (most recent call last):\n    ...\nTypeError: zeller() missing 1 required positional argument: 'date_input'\n\nTest length of `date_input`:\n\n>>> zeller('')\nTraceback (most recent call last):\n    ...\nValueError: Must be 10 characters long\n>>> zeller('01-31-19082939')\nTraceback (most recent call last):\n    ...\nValueError: Must be 10 characters long"
  },
  {
    "function": "bisection",
    "code": "def bisection(function: Callable[[float], float], a: float, b: float) -> float:\n    \"\"\"\n    finds where function becomes 0 in [a,b] using bolzano\n    >>> bisection(lambda x: x ** 3 - 1, -5, 5)\n    1.0000000149011612\n    >>> bisection(lambda x: x ** 3 - 1, 2, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 0, 2)\n    1.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 2, 4)\n    3.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    \"\"\"\n    start: float = a\n    end: float = b\n    if function(a) == 0:  # one of the a or b is a root for the function\n        return a\n    elif function(b) == 0:\n        return b\n    elif (\n        function(a) * function(b) > 0\n    ):  # if none of these are root and they are both positive or negative,\n        # then this algorithm can't find the root\n        raise ValueError(\"could not find root in given interval.\")\n    else:\n        mid: float = start + (end - start) / 2.0\n        while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7\n            if function(mid) == 0:\n                return mid\n            elif function(mid) * function(start) < 0:\n                end = mid\n            else:\n                start = mid\n            mid = start + (end - start) / 2.0\n        return mid",
    "docstring": "finds where function becomes 0 in [a,b] using bolzano\n>>> bisection(lambda x: x ** 3 - 1, -5, 5)\n1.0000000149011612\n>>> bisection(lambda x: x ** 3 - 1, 2, 1000)\nTraceback (most recent call last):\n    ...\nValueError: could not find root in given interval.\n>>> bisection(lambda x: x ** 2 - 4 * x + 3, 0, 2)\n1.0\n>>> bisection(lambda x: x ** 2 - 4 * x + 3, 2, 4)\n3.0\n>>> bisection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)\nTraceback (most recent call last):\n    ...\nValueError: could not find root in given interval."
  },
  {
    "function": "equation",
    "code": "def equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x",
    "docstring": ">>> equation(5)\n-15\n>>> equation(0)\n10\n>>> equation(-5)\n-15\n>>> equation(0.1)\n9.99\n>>> equation(-0.1)\n9.99"
  },
  {
    "function": "bisection",
    "code": "def bisection(a: float, b: float) -> float:\n    \"\"\"\n    >>> bisection(-2, 5)\n    3.1611328125\n    >>> bisection(0, 6)\n    3.158203125\n    >>> bisection(2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong space!\n    \"\"\"\n    # Bolzano theory in order to find if there is a root between a and b\n    if equation(a) * equation(b) >= 0:\n        raise ValueError(\"Wrong space!\")\n\n    c = a\n    while (b - a) >= 0.01:\n        # Find middle point\n        c = (a + b) / 2\n        # Check if middle point is root\n        if equation(c) == 0.0:\n            break\n        # Decide the side to repeat the steps\n        if equation(c) * equation(a) < 0:\n            b = c\n        else:\n            a = c\n    return c",
    "docstring": ">>> bisection(-2, 5)\n3.1611328125\n>>> bisection(0, 6)\n3.158203125\n>>> bisection(2, 3)\nTraceback (most recent call last):\n    ...\nValueError: Wrong space!"
  },
  {
    "function": "simpson_integration",
    "code": "def simpson_integration(function, a: float, b: float, precision: int = 4) -> float:\n    \"\"\"\n    Args:\n        function : the function which's integration is desired\n        a : the lower limit of integration\n        b : upper limit of integration\n        precision : precision of the result,error required default is 4\n\n    Returns:\n        result : the value of the approximated integration of function in range a to b\n\n    Raises:\n        AssertionError: function is not callable\n        AssertionError: a is not float or integer\n        AssertionError: function should return float or integer\n        AssertionError: b is not float or integer\n        AssertionError: precision is not positive integer\n\n    >>> simpson_integration(lambda x : x*x,1,2,3)\n    2.333\n\n    >>> simpson_integration(lambda x : x*x,'wrong_input',2,3)\n    Traceback (most recent call last):\n        ...\n    AssertionError: a should be float or integer your input : wrong_input\n\n    >>> simpson_integration(lambda x : x*x,1,'wrong_input',3)\n    Traceback (most recent call last):\n        ...\n    AssertionError: b should be float or integer your input : wrong_input\n\n    >>> simpson_integration(lambda x : x*x,1,2,'wrong_input')\n    Traceback (most recent call last):\n        ...\n    AssertionError: precision should be positive integer your input : wrong_input\n    >>> simpson_integration('wrong_input',2,3,4)\n    Traceback (most recent call last):\n        ...\n    AssertionError: the function(object) passed should be callable your input : ...\n\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,1)\n    -2.8\n\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,0)\n    Traceback (most recent call last):\n        ...\n    AssertionError: precision should be positive integer your input : 0\n\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: precision should be positive integer your input : -1\n\n    \"\"\"\n    assert callable(function), (\n        f\"the function(object) passed should be callable your input : {function}\"\n    )\n    assert isinstance(a, (float, int)), f\"a should be float or integer your input : {a}\"\n    assert isinstance(function(a), (float, int)), (\n        \"the function should return integer or float return type of your function, \"\n        f\"{type(a)}\"\n    )\n    assert isinstance(b, (float, int)), f\"b should be float or integer your input : {b}\"\n    assert isinstance(precision, int) and precision > 0, (\n        f\"precision should be positive integer your input : {precision}\"\n    )\n\n    # just applying the formula of simpson for approximate integration written in\n    # mentioned article in first comment of this file and above this function\n\n    h = (b - a) / N_STEPS\n    result = function(a) + function(b)\n\n    for i in range(1, N_STEPS):\n        a1 = a + h * i\n        result += function(a1) * (4 if i % 2 else 2)\n\n    result *= h / 3\n    return round(result, precision)",
    "docstring": "Args:\n    function : the function which's integration is desired\n    a : the lower limit of integration\n    b : upper limit of integration\n    precision : precision of the result,error required default is 4\n\nReturns:\n    result : the value of the approximated integration of function in range a to b\n\nRaises:\n    AssertionError: function is not callable\n    AssertionError: a is not float or integer\n    AssertionError: function should return float or integer\n    AssertionError: b is not float or integer\n    AssertionError: precision is not positive integer\n\n>>> simpson_integration(lambda x : x*x,1,2,3)\n2.333\n\n>>> simpson_integration(lambda x : x*x,'wrong_input',2,3)\nTraceback (most recent call last):\n    ...\nAssertionError: a should be float or integer your input : wrong_input\n\n>>> simpson_integration(lambda x : x*x,1,'wrong_input',3)\nTraceback (most recent call last):\n    ...\nAssertionError: b should be float or integer your input : wrong_input\n\n>>> simpson_integration(lambda x : x*x,1,2,'wrong_input')\nTraceback (most recent call last):\n    ...\nAssertionError: precision should be positive integer your input : wrong_input\n>>> simpson_integration('wrong_input',2,3,4)\nTraceback (most recent call last):\n    ...\nAssertionError: the function(object) passed should be callable your input : ...\n\n>>> simpson_integration(lambda x : x*x,3.45,3.2,1)\n-2.8\n\n>>> simpson_integration(lambda x : x*x,3.45,3.2,0)\nTraceback (most recent call last):\n    ...\nAssertionError: precision should be positive integer your input : 0\n\n>>> simpson_integration(lambda x : x*x,3.45,3.2,-1)\nTraceback (most recent call last):\n    ...\nAssertionError: precision should be positive integer your input : -1"
  },
  {
    "function": "intersection",
    "code": "def intersection(function: Callable[[float], float], x0: float, x1: float) -> float:\n    \"\"\"\n    function is the f we want to find its root\n    x0 and x1 are two random starting points\n    >>> intersection(lambda x: x ** 3 - 1, -5, 5)\n    0.9999999999954654\n    >>> intersection(lambda x: x ** 3 - 1, 5, 5)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: float division by zero, could not find root\n    >>> intersection(lambda x: x ** 3 - 1, 100, 200)\n    1.0000000000003888\n    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 0, 2)\n    0.9999999998088019\n    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 2, 4)\n    2.9999999998088023\n    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)\n    3.0000000001786042\n    >>> intersection(math.sin, -math.pi, math.pi)\n    0.0\n    >>> intersection(math.cos, -math.pi, math.pi)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: float division by zero, could not find root\n    \"\"\"\n    x_n: float = x0\n    x_n1: float = x1\n    while True:\n        if x_n == x_n1 or function(x_n1) == function(x_n):\n            raise ZeroDivisionError(\"float division by zero, could not find root\")\n        x_n2: float = x_n1 - (\n            function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))\n        )\n        if abs(x_n2 - x_n1) < 10**-5:\n            return x_n2\n        x_n = x_n1\n        x_n1 = x_n2",
    "docstring": "function is the f we want to find its root\nx0 and x1 are two random starting points\n>>> intersection(lambda x: x ** 3 - 1, -5, 5)\n0.9999999999954654\n>>> intersection(lambda x: x ** 3 - 1, 5, 5)\nTraceback (most recent call last):\n    ...\nZeroDivisionError: float division by zero, could not find root\n>>> intersection(lambda x: x ** 3 - 1, 100, 200)\n1.0000000000003888\n>>> intersection(lambda x: x ** 2 - 4 * x + 3, 0, 2)\n0.9999999998088019\n>>> intersection(lambda x: x ** 2 - 4 * x + 3, 2, 4)\n2.9999999998088023\n>>> intersection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)\n3.0000000001786042\n>>> intersection(math.sin, -math.pi, math.pi)\n0.0\n>>> intersection(math.cos, -math.pi, math.pi)\nTraceback (most recent call last):\n    ...\nZeroDivisionError: float division by zero, could not find root"
  },
  {
    "function": "f",
    "code": "def f(x: float) -> float:\n    \"\"\"\n    function is f(x) = x^3 - 2x - 5\n    >>> f(2)\n    -1.0\n    \"\"\"\n    return math.pow(x, 3) - (2 * x) - 5",
    "docstring": "function is f(x) = x^3 - 2x - 5\n>>> f(2)\n-1.0"
  },
  {
    "function": "neville_interpolate",
    "code": "def neville_interpolate(x_points: list, y_points: list, x0: int) -> list:\n    \"\"\"\n       Interpolate and evaluate a polynomial using Neville's method.\n       Arguments:\n           x_points, y_points: Iterables of x and corresponding y points through\n            which the polynomial passes.\n           x0: The value of x to evaluate the polynomial for.\n       Return Value: A list of the approximated value and the Neville iterations\n           table respectively.\n    >>> import pprint\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 5)[0]\n    10.0\n    >>> pprint.pprint(neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[1])\n    [[0, 6, 0, 0, 0],\n     [0, 7, 0, 0, 0],\n     [0, 8, 104.0, 0, 0],\n     [0, 9, 104.0, 104.0, 0],\n     [0, 11, 104.0, 104.0, 104.0]]\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[0]\n    104.0\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), '')\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'str' and 'int'\n    \"\"\"\n    n = len(x_points)\n    q = [[0] * n for i in range(n)]\n    for i in range(n):\n        q[i][1] = y_points[i]\n\n    for i in range(2, n):\n        for j in range(i, n):\n            q[j][i] = (\n                (x0 - x_points[j - i + 1]) * q[j][i - 1]\n                - (x0 - x_points[j]) * q[j - 1][i - 1]\n            ) / (x_points[j] - x_points[j - i + 1])\n\n    return [q[n - 1][n - 1], q]",
    "docstring": "Interpolate and evaluate a polynomial using Neville's method.\n   Arguments:\n       x_points, y_points: Iterables of x and corresponding y points through\n        which the polynomial passes.\n       x0: The value of x to evaluate the polynomial for.\n   Return Value: A list of the approximated value and the Neville iterations\n       table respectively.\n>>> import pprint\n>>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 5)[0]\n10.0\n>>> pprint.pprint(neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[1])\n[[0, 6, 0, 0, 0],\n [0, 7, 0, 0, 0],\n [0, 8, 104.0, 0, 0],\n [0, 9, 104.0, 104.0, 0],\n [0, 11, 104.0, 104.0, 104.0]]\n>>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[0]\n104.0\n>>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), '')\nTraceback (most recent call last):\n    ...\nTypeError: unsupported operand type(s) for -: 'str' and 'int'"
  },
  {
    "function": "ucal",
    "code": "def ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp",
    "docstring": ">>> ucal(1, 2)\n0\n>>> ucal(1.1, 2)\n0.11000000000000011\n>>> ucal(1.2, 2)\n0.23999999999999994"
  },
  {
    "function": "calc_derivative",
    "code": "def calc_derivative(f: RealFunc, x: float, delta_x: float = 1e-3) -> float:\n    \"\"\"\n    Approximate the derivative of a function f(x) at a point x using the finite\n    difference method\n\n    >>> import math\n    >>> tolerance = 1e-5\n    >>> derivative = calc_derivative(lambda x: x**2, 2)\n    >>> math.isclose(derivative, 4, abs_tol=tolerance)\n    True\n    >>> derivative = calc_derivative(math.sin, 0)\n    >>> math.isclose(derivative, 1, abs_tol=tolerance)\n    True\n    \"\"\"\n    return (f(x + delta_x / 2) - f(x - delta_x / 2)) / delta_x",
    "docstring": "Approximate the derivative of a function f(x) at a point x using the finite\ndifference method\n\n>>> import math\n>>> tolerance = 1e-5\n>>> derivative = calc_derivative(lambda x: x**2, 2)\n>>> math.isclose(derivative, 4, abs_tol=tolerance)\nTrue\n>>> derivative = calc_derivative(math.sin, 0)\n>>> math.isclose(derivative, 1, abs_tol=tolerance)\nTrue"
  },
  {
    "function": "newton_raphson",
    "code": "def newton_raphson(\n    f: RealFunc,\n    x0: float = 0,\n    max_iter: int = 100,\n    step: float = 1e-6,\n    max_error: float = 1e-6,\n    log_steps: bool = False,\n) -> tuple[float, float, list[float]]:\n    \"\"\"\n    Find a root of the given function f using the Newton-Raphson method.\n\n    :param f: A real-valued single-variable function\n    :param x0: Initial guess\n    :param max_iter: Maximum number of iterations\n    :param step: Step size of x, used to approximate f'(x)\n    :param max_error: Maximum approximation error\n    :param log_steps: bool denoting whether to log intermediate steps\n\n    :return: A tuple containing the approximation, the error, and the intermediate\n        steps. If log_steps is False, then an empty list is returned for the third\n        element of the tuple.\n\n    :raises ZeroDivisionError: The derivative approaches 0.\n    :raises ArithmeticError: No solution exists, or the solution isn't found before the\n        iteration limit is reached.\n\n    >>> import math\n    >>> tolerance = 1e-15\n    >>> root, *_ = newton_raphson(lambda x: x**2 - 5*x + 2, 0.4, max_error=tolerance)\n    >>> math.isclose(root, (5 - math.sqrt(17)) / 2, abs_tol=tolerance)\n    True\n    >>> root, *_ = newton_raphson(lambda x: math.log(x) - 1, 2, max_error=tolerance)\n    >>> math.isclose(root, math.e, abs_tol=tolerance)\n    True\n    >>> root, *_ = newton_raphson(math.sin, 1, max_error=tolerance)\n    >>> math.isclose(root, 0, abs_tol=tolerance)\n    True\n    >>> newton_raphson(math.cos, 0)\n    Traceback (most recent call last):\n    ...\n    ZeroDivisionError: No converging solution found, zero derivative\n    >>> newton_raphson(lambda x: x**2 + 1, 2)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No converging solution found, iteration limit reached\n    \"\"\"\n\n    def f_derivative(x: float) -> float:\n        return calc_derivative(f, x, step)\n\n    a = x0  # Set initial guess\n    steps = []\n    for _ in range(max_iter):\n        if log_steps:  # Log intermediate steps\n            steps.append(a)\n\n        error = abs(f(a))\n        if error < max_error:\n            return a, error, steps\n\n        if f_derivative(a) == 0:\n            raise ZeroDivisionError(\"No converging solution found, zero derivative\")\n        a -= f(a) / f_derivative(a)  # Calculate next estimate\n    raise ArithmeticError(\"No converging solution found, iteration limit reached\")",
    "docstring": "Find a root of the given function f using the Newton-Raphson method.\n\n:param f: A real-valued single-variable function\n:param x0: Initial guess\n:param max_iter: Maximum number of iterations\n:param step: Step size of x, used to approximate f'(x)\n:param max_error: Maximum approximation error\n:param log_steps: bool denoting whether to log intermediate steps\n\n:return: A tuple containing the approximation, the error, and the intermediate\n    steps. If log_steps is False, then an empty list is returned for the third\n    element of the tuple.\n\n:raises ZeroDivisionError: The derivative approaches 0.\n:raises ArithmeticError: No solution exists, or the solution isn't found before the\n    iteration limit is reached.\n\n>>> import math\n>>> tolerance = 1e-15\n>>> root, *_ = newton_raphson(lambda x: x**2 - 5*x + 2, 0.4, max_error=tolerance)\n>>> math.isclose(root, (5 - math.sqrt(17)) / 2, abs_tol=tolerance)\nTrue\n>>> root, *_ = newton_raphson(lambda x: math.log(x) - 1, 2, max_error=tolerance)\n>>> math.isclose(root, math.e, abs_tol=tolerance)\nTrue\n>>> root, *_ = newton_raphson(math.sin, 1, max_error=tolerance)\n>>> math.isclose(root, 0, abs_tol=tolerance)\nTrue\n>>> newton_raphson(math.cos, 0)\nTraceback (most recent call last):\n...\nZeroDivisionError: No converging solution found, zero derivative\n>>> newton_raphson(lambda x: x**2 + 1, 2)\nTraceback (most recent call last):\n...\nArithmeticError: No converging solution found, iteration limit reached"
  },
  {
    "function": "trapezoidal_area",
    "code": "def trapezoidal_area(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    \"\"\"\n    Treats curve as a collection of linear lines and sums the area of the\n    trapezium shape they form\n    :param fnc: a function which defines a curve\n    :param x_start: left end point to indicate the start of line segment\n    :param x_end: right end point to indicate end of line segment\n    :param steps: an accuracy gauge; more steps increases the accuracy\n    :return: a float representing the length of the curve\n\n    >>> def f(x):\n    ...    return 5\n    >>> '%.3f' % trapezoidal_area(f, 12.0, 14.0, 1000)\n    '10.000'\n\n    >>> def f(x):\n    ...    return 9*x**2\n    >>> '%.4f' % trapezoidal_area(f, -4.0, 0, 10000)\n    '192.0000'\n\n    >>> '%.4f' % trapezoidal_area(f, -4.0, 4.0, 10000)\n    '384.0000'\n    \"\"\"\n    x1 = x_start\n    fx1 = fnc(x_start)\n    area = 0.0\n\n    for _ in range(steps):\n        # Approximates small segments of curve as linear and solve\n        # for trapezoidal area\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\n\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n    return area",
    "docstring": "Treats curve as a collection of linear lines and sums the area of the\ntrapezium shape they form\n:param fnc: a function which defines a curve\n:param x_start: left end point to indicate the start of line segment\n:param x_end: right end point to indicate end of line segment\n:param steps: an accuracy gauge; more steps increases the accuracy\n:return: a float representing the length of the curve\n\n>>> def f(x):\n...    return 5\n>>> '%.3f' % trapezoidal_area(f, 12.0, 14.0, 1000)\n'10.000'\n\n>>> def f(x):\n...    return 9*x**2\n>>> '%.4f' % trapezoidal_area(f, -4.0, 0, 10000)\n'192.0000'\n\n>>> '%.4f' % trapezoidal_area(f, -4.0, 4.0, 10000)\n'384.0000'"
  },
  {
    "function": "proper_fractions",
    "code": "def proper_fractions(denominator: int) -> list[str]:\n    \"\"\"\n    this algorithm returns a list of proper fractions, in the\n    range between 0 and 1, which can be formed with the given denominator\n    https://en.wikipedia.org/wiki/Fraction#Proper_and_improper_fractions\n\n    >>> proper_fractions(10)\n    ['1/10', '3/10', '7/10', '9/10']\n    >>> proper_fractions(5)\n    ['1/5', '2/5', '3/5', '4/5']\n    >>> proper_fractions(-15)\n    Traceback (most recent call last):\n        ...\n    ValueError: The Denominator Cannot be less than 0\n    >>> proper_fractions(0)\n    []\n    >>> proper_fractions(1.2)\n    Traceback (most recent call last):\n        ...\n    ValueError: The Denominator must be an integer\n    \"\"\"\n\n    if denominator < 0:\n        raise ValueError(\"The Denominator Cannot be less than 0\")\n    elif isinstance(denominator, float):\n        raise ValueError(\"The Denominator must be an integer\")\n    return [\n        f\"{numerator}/{denominator}\"\n        for numerator in range(1, denominator)\n        if gcd(numerator, denominator) == 1\n    ]",
    "docstring": "this algorithm returns a list of proper fractions, in the\nrange between 0 and 1, which can be formed with the given denominator\nhttps://en.wikipedia.org/wiki/Fraction#Proper_and_improper_fractions\n\n>>> proper_fractions(10)\n['1/10', '3/10', '7/10', '9/10']\n>>> proper_fractions(5)\n['1/5', '2/5', '3/5', '4/5']\n>>> proper_fractions(-15)\nTraceback (most recent call last):\n    ...\nValueError: The Denominator Cannot be less than 0\n>>> proper_fractions(0)\n[]\n>>> proper_fractions(1.2)\nTraceback (most recent call last):\n    ...\nValueError: The Denominator must be an integer"
  },
  {
    "function": "runge_kutta",
    "code": "def runge_kutta(f, y0, x0, h, x_end):\n    \"\"\"\n    Calculate the numeric solution at each step to the ODE f(x, y) using RK4\n\n    https://en.wikipedia.org/wiki/Runge-Kutta_methods\n\n    Arguments:\n    f -- The ode as a function of x and y\n    y0 -- the initial value for y\n    x0 -- the initial value for x\n    h -- the stepsize\n    x_end -- the end value for x\n\n    >>> # the exact solution is math.exp(x)\n    >>> def f(x, y):\n    ...     return y\n    >>> y0 = 1\n    >>> y = runge_kutta(f, y0, 0.0, 0.01, 5)\n    >>> float(y[-1])\n    148.41315904125113\n    \"\"\"\n    n = int(np.ceil((x_end - x0) / h))\n    y = np.zeros((n + 1,))\n    y[0] = y0\n    x = x0\n\n    for k in range(n):\n        k1 = f(x, y[k])\n        k2 = f(x + 0.5 * h, y[k] + 0.5 * h * k1)\n        k3 = f(x + 0.5 * h, y[k] + 0.5 * h * k2)\n        k4 = f(x + h, y[k] + h * k3)\n        y[k + 1] = y[k] + (1 / 6) * h * (k1 + 2 * k2 + 2 * k3 + k4)\n        x += h\n\n    return y",
    "docstring": "Calculate the numeric solution at each step to the ODE f(x, y) using RK4\n\nhttps://en.wikipedia.org/wiki/Runge-Kutta_methods\n\nArguments:\nf -- The ode as a function of x and y\ny0 -- the initial value for y\nx0 -- the initial value for x\nh -- the stepsize\nx_end -- the end value for x\n\n>>> # the exact solution is math.exp(x)\n>>> def f(x, y):\n...     return y\n>>> y0 = 1\n>>> y = runge_kutta(f, y0, 0.0, 0.01, 5)\n>>> float(y[-1])\n148.41315904125113"
  },
  {
    "function": "runge_kutta_fehlberg_45",
    "code": "def runge_kutta_fehlberg_45(\n    func: Callable,\n    x_initial: float,\n    y_initial: float,\n    step_size: float,\n    x_final: float,\n) -> np.ndarray:\n    \"\"\"\n    Solve an Ordinary Differential Equations using Runge-Kutta-Fehlberg Method (rkf45)\n    of order 5.\n\n    https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method\n\n    args:\n    func: An ordinary differential equation (ODE) as function of x and y.\n    x_initial: The initial value of x.\n    y_initial: The initial value of y.\n    step_size: The increment value of x.\n    x_final: The final value of x.\n\n    Returns:\n        Solution of y at each nodal point\n\n    # exact value of y[1] is tan(0.2) = 0.2027100937470787\n    >>> def f(x, y):\n    ...     return 1 + y**2\n    >>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, 1)\n    >>> float(y[1])\n    0.2027100937470787\n    >>> def f(x,y):\n    ...     return x\n    >>> y = runge_kutta_fehlberg_45(f, -1, 0, 0.2, 0)\n    >>> float(y[1])\n    -0.18000000000000002\n    >>> y = runge_kutta_fehlberg_45(5, 0, 0, 0.1, 1)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'int' object is not callable\n    >>> def f(x, y):\n    ...     return x + y\n    >>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The final value of x must be greater than initial value of x.\n    >>> def f(x, y):\n    ...     return x\n    >>> y = runge_kutta_fehlberg_45(f, -1, 0, -0.2, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Step size must be positive.\n    \"\"\"\n    if x_initial >= x_final:\n        raise ValueError(\n            \"The final value of x must be greater than initial value of x.\"\n        )\n\n    if step_size <= 0:\n        raise ValueError(\"Step size must be positive.\")\n\n    n = int((x_final - x_initial) / step_size)\n    y = np.zeros(\n        (n + 1),\n    )\n    x = np.zeros(n + 1)\n    y[0] = y_initial\n    x[0] = x_initial\n    for i in range(n):\n        k1 = step_size * func(x[i], y[i])\n        k2 = step_size * func(x[i] + step_size / 4, y[i] + k1 / 4)\n        k3 = step_size * func(\n            x[i] + (3 / 8) * step_size, y[i] + (3 / 32) * k1 + (9 / 32) * k2\n        )\n        k4 = step_size * func(\n            x[i] + (12 / 13) * step_size,\n            y[i] + (1932 / 2197) * k1 - (7200 / 2197) * k2 + (7296 / 2197) * k3,\n        )\n        k5 = step_size * func(\n            x[i] + step_size,\n            y[i] + (439 / 216) * k1 - 8 * k2 + (3680 / 513) * k3 - (845 / 4104) * k4,\n        )\n        k6 = step_size * func(\n            x[i] + step_size / 2,\n            y[i]\n            - (8 / 27) * k1\n            + 2 * k2\n            - (3544 / 2565) * k3\n            + (1859 / 4104) * k4\n            - (11 / 40) * k5,\n        )\n        y[i + 1] = (\n            y[i]\n            + (16 / 135) * k1\n            + (6656 / 12825) * k3\n            + (28561 / 56430) * k4\n            - (9 / 50) * k5\n            + (2 / 55) * k6\n        )\n        x[i + 1] = step_size + x[i]\n    return y",
    "docstring": "Solve an Ordinary Differential Equations using Runge-Kutta-Fehlberg Method (rkf45)\nof order 5.\n\nhttps://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method\n\nargs:\nfunc: An ordinary differential equation (ODE) as function of x and y.\nx_initial: The initial value of x.\ny_initial: The initial value of y.\nstep_size: The increment value of x.\nx_final: The final value of x.\n\nReturns:\n    Solution of y at each nodal point\n\n# exact value of y[1] is tan(0.2) = 0.2027100937470787\n>>> def f(x, y):\n...     return 1 + y**2\n>>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, 1)\n>>> float(y[1])\n0.2027100937470787\n>>> def f(x,y):\n...     return x\n>>> y = runge_kutta_fehlberg_45(f, -1, 0, 0.2, 0)\n>>> float(y[1])\n-0.18000000000000002\n>>> y = runge_kutta_fehlberg_45(5, 0, 0, 0.1, 1)\nTraceback (most recent call last):\n    ...\nTypeError: 'int' object is not callable\n>>> def f(x, y):\n...     return x + y\n>>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, -1)\nTraceback (most recent call last):\n    ...\nValueError: The final value of x must be greater than initial value of x.\n>>> def f(x, y):\n...     return x\n>>> y = runge_kutta_fehlberg_45(f, -1, 0, -0.2, 0)\nTraceback (most recent call last):\n    ...\nValueError: Step size must be positive."
  },
  {
    "function": "runge_kutta_gills",
    "code": "def runge_kutta_gills(\n    func: Callable[[float, float], float],\n    x_initial: float,\n    y_initial: float,\n    step_size: float,\n    x_final: float,\n) -> np.ndarray:\n    \"\"\"\n    Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4.\n\n    args:\n    func: An ordinary differential equation (ODE) as function of x and y.\n    x_initial: The initial value of x.\n    y_initial: The initial value of y.\n    step_size: The increment value of x.\n    x_final: The final value of x.\n\n    Returns:\n        Solution of y at each nodal point\n\n    >>> def f(x, y):\n    ...     return (x-y)/2\n    >>> y = runge_kutta_gills(f, 0, 3, 0.2, 5)\n    >>> float(y[-1])\n    3.4104259225717537\n\n    >>> def f(x,y):\n    ...     return x\n    >>> y = runge_kutta_gills(f, -1, 0, 0.2, 0)\n    >>> y\n    array([ 0.  , -0.18, -0.32, -0.42, -0.48, -0.5 ])\n\n    >>> def f(x, y):\n    ...     return x + y\n    >>> y = runge_kutta_gills(f, 0, 0, 0.2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The final value of x must be greater than initial value of x.\n\n    >>> def f(x, y):\n    ...     return x\n    >>> y = runge_kutta_gills(f, -1, 0, -0.2, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Step size must be positive.\n    \"\"\"\n    if x_initial >= x_final:\n        raise ValueError(\n            \"The final value of x must be greater than initial value of x.\"\n        )\n\n    if step_size <= 0:\n        raise ValueError(\"Step size must be positive.\")\n\n    n = int((x_final - x_initial) / step_size)\n    y = np.zeros(n + 1)\n    y[0] = y_initial\n    for i in range(n):\n        k1 = step_size * func(x_initial, y[i])\n        k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)\n        k3 = step_size * func(\n            x_initial + step_size / 2,\n            y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,\n        )\n        k4 = step_size * func(\n            x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3\n        )\n\n        y[i + 1] = y[i] + (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4) / 6\n        x_initial += step_size\n    return y",
    "docstring": "Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4.\n\nargs:\nfunc: An ordinary differential equation (ODE) as function of x and y.\nx_initial: The initial value of x.\ny_initial: The initial value of y.\nstep_size: The increment value of x.\nx_final: The final value of x.\n\nReturns:\n    Solution of y at each nodal point\n\n>>> def f(x, y):\n...     return (x-y)/2\n>>> y = runge_kutta_gills(f, 0, 3, 0.2, 5)\n>>> float(y[-1])\n3.4104259225717537\n\n>>> def f(x,y):\n...     return x\n>>> y = runge_kutta_gills(f, -1, 0, 0.2, 0)\n>>> y\narray([ 0.  , -0.18, -0.32, -0.42, -0.48, -0.5 ])\n\n>>> def f(x, y):\n...     return x + y\n>>> y = runge_kutta_gills(f, 0, 0, 0.2, -1)\nTraceback (most recent call last):\n    ...\nValueError: The final value of x must be greater than initial value of x.\n\n>>> def f(x, y):\n...     return x\n>>> y = runge_kutta_gills(f, -1, 0, -0.2, 0)\nTraceback (most recent call last):\n    ...\nValueError: Step size must be positive."
  },
  {
    "function": "f",
    "code": "def f(x: float) -> float:\n    \"\"\"\n    >>> f(5)\n    39.98652410600183\n    \"\"\"\n    return 8 * x - 2 * exp(-x)",
    "docstring": ">>> f(5)\n39.98652410600183"
  },
  {
    "function": "secant_method",
    "code": "def secant_method(lower_bound: float, upper_bound: float, repeats: int) -> float:\n    \"\"\"\n    >>> secant_method(1, 3, 2)\n    0.2139409276214589\n    \"\"\"\n    x0 = lower_bound\n    x1 = upper_bound\n    for _ in range(repeats):\n        x0, x1 = x1, x1 - (f(x1) * (x1 - x0)) / (f(x1) - f(x0))\n    return x1",
    "docstring": ">>> secant_method(1, 3, 2)\n0.2139409276214589"
  },
  {
    "function": "method_2",
    "code": "def method_2(boundary: list[int], steps: int) -> float:\n    # \"Simpson Rule\"\n    # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)\n    \"\"\"\n    Calculate the definite integral of a function using Simpson's Rule.\n    :param boundary: A list containing the lower and upper bounds of integration.\n    :param steps: The number of steps or resolution for the integration.\n    :return: The approximate integral value.\n\n    >>> round(method_2([0, 2, 4], 10), 10)\n    2.6666666667\n    >>> round(method_2([2, 0], 10), 10)\n    -0.2666666667\n    >>> round(method_2([-2, -1], 10), 10)\n    2.172\n    >>> round(method_2([0, 1], 10), 10)\n    0.3333333333\n    >>> round(method_2([0, 2], 10), 10)\n    2.6666666667\n    >>> round(method_2([0, 2], 100), 10)\n    2.5621226667\n    >>> round(method_2([0, 1], 1000), 10)\n    0.3320026653\n    >>> round(method_2([0, 2], 0), 10)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: Number of steps must be greater than zero\n    >>> round(method_2([0, 2], -10), 10)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: Number of steps must be greater than zero\n    \"\"\"\n    if steps <= 0:\n        raise ZeroDivisionError(\"Number of steps must be greater than zero\")\n\n    h = (boundary[1] - boundary[0]) / steps\n    a = boundary[0]\n    b = boundary[1]\n    x_i = make_points(a, b, h)\n    y = 0.0\n    y += (h / 3.0) * f(a)\n    cnt = 2\n    for i in x_i:\n        y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)\n        cnt += 1\n    y += (h / 3.0) * f(b)\n    return y",
    "docstring": "Calculate the definite integral of a function using Simpson's Rule.\n:param boundary: A list containing the lower and upper bounds of integration.\n:param steps: The number of steps or resolution for the integration.\n:return: The approximate integral value.\n\n>>> round(method_2([0, 2, 4], 10), 10)\n2.6666666667\n>>> round(method_2([2, 0], 10), 10)\n-0.2666666667\n>>> round(method_2([-2, -1], 10), 10)\n2.172\n>>> round(method_2([0, 1], 10), 10)\n0.3333333333\n>>> round(method_2([0, 2], 10), 10)\n2.6666666667\n>>> round(method_2([0, 2], 100), 10)\n2.5621226667\n>>> round(method_2([0, 1], 1000), 10)\n0.3320026653\n>>> round(method_2([0, 2], 0), 10)\nTraceback (most recent call last):\n    ...\nZeroDivisionError: Number of steps must be greater than zero\n>>> round(method_2([0, 2], -10), 10)\nTraceback (most recent call last):\n    ...\nZeroDivisionError: Number of steps must be greater than zero"
  },
  {
    "function": "square_root_iterative",
    "code": "def square_root_iterative(\n    a: float, max_iter: int = 9999, tolerance: float = 1e-14\n) -> float:\n    \"\"\"\n    Square root approximated using Newton's method.\n    https://en.wikipedia.org/wiki/Newton%27s_method\n\n    >>> all(abs(square_root_iterative(i) - math.sqrt(i)) <= 1e-14 for i in range(500))\n    True\n\n    >>> square_root_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n\n    >>> square_root_iterative(4)\n    2.0\n\n    >>> square_root_iterative(3.2)\n    1.788854381999832\n\n    >>> square_root_iterative(140)\n    11.832159566199232\n    \"\"\"\n\n    if a < 0:\n        raise ValueError(\"math domain error\")\n\n    value = get_initial_point(a)\n\n    for _ in range(max_iter):\n        prev_value = value\n        value = value - fx(value, a) / fx_derivative(value)\n        if abs(prev_value - value) < tolerance:\n            return value\n\n    return value",
    "docstring": "Square root approximated using Newton's method.\nhttps://en.wikipedia.org/wiki/Newton%27s_method\n\n>>> all(abs(square_root_iterative(i) - math.sqrt(i)) <= 1e-14 for i in range(500))\nTrue\n\n>>> square_root_iterative(-1)\nTraceback (most recent call last):\n    ...\nValueError: math domain error\n\n>>> square_root_iterative(4)\n2.0\n\n>>> square_root_iterative(3.2)\n1.788854381999832\n\n>>> square_root_iterative(140)\n11.832159566199232"
  },
  {
    "function": "weierstrass_method",
    "code": "def weierstrass_method(\n    polynomial: Callable[[np.ndarray], np.ndarray],\n    degree: int,\n    roots: np.ndarray | None = None,\n    max_iter: int = 100,\n) -> np.ndarray:\n    \"\"\"\n    Approximates all complex roots of a polynomial using the\n    Weierstrass (Durand-Kerner) method.\n    Args:\n        polynomial: A function that takes a NumPy array of complex numbers and returns\n                    the polynomial values at those points.\n        degree: Degree of the polynomial (number of roots to find). Must be \u2265 1.\n        roots:  Optional initial guess as a NumPy array of complex numbers.\n                Must have length equal to 'degree'.\n                If None, perturbed complex roots of unity are used.\n        max_iter: Number of iterations to perform (default: 100).\n\n    Returns:\n        np.ndarray: Array of approximated complex roots.\n\n    Raises:\n        ValueError: If degree < 1, or if initial roots length doesn't match the degree.\n\n    Note:\n        - Root updates are clipped to prevent numerical overflow.\n\n    Example:\n        >>> import numpy as np\n        >>> def check(poly, degree, expected):\n        ...     roots = weierstrass_method(poly, degree)\n        ...     return np.allclose(np.sort(roots), np.sort(expected))\n\n        >>> check(\n        ...     lambda x: x**2 - 1,\n        ...     2,\n        ...     np.array([-1, 1]))\n        True\n\n        >>> check(\n        ...     lambda x: x**3 - 4.5*x**2 + 5.75*x - 1.875,\n        ...     3,\n        ...     np.array([1.5, 0.5, 2.5])\n        ... )\n        True\n\n    See Also:\n        https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method\n    \"\"\"\n\n    if degree < 1:\n        raise ValueError(\"Degree of the polynomial must be at least 1.\")\n\n    if roots is None:\n        # Use perturbed complex roots of unity as initial guesses\n        rng = np.random.default_rng()\n        roots = np.array(\n            [\n                np.exp(2j * np.pi * i / degree) * (1 + 1e-3 * rng.random())\n                for i in range(degree)\n            ],\n            dtype=np.complex128,\n        )\n\n    else:\n        roots = np.asarray(roots, dtype=np.complex128)\n        if roots.shape[0] != degree:\n            raise ValueError(\n                \"Length of initial roots must match the degree of the polynomial.\"\n            )\n\n    for _ in range(max_iter):\n        # Construct the product denominator for each root\n        denominator = np.array([root - roots for root in roots], dtype=np.complex128)\n        np.fill_diagonal(denominator, 1.0)  # Avoid zero in diagonal\n        denominator = np.prod(denominator, axis=1)\n\n        # Evaluate polynomial at each root\n        numerator = polynomial(roots).astype(np.complex128)\n\n        # Compute update and clip to prevent overflow\n        delta = numerator / denominator\n        delta = np.clip(delta, -1e10, 1e10)\n        roots -= delta\n\n    return roots",
    "docstring": "Approximates all complex roots of a polynomial using the\nWeierstrass (Durand-Kerner) method.\nArgs:\n    polynomial: A function that takes a NumPy array of complex numbers and returns\n                the polynomial values at those points.\n    degree: Degree of the polynomial (number of roots to find). Must be \u2265 1.\n    roots:  Optional initial guess as a NumPy array of complex numbers.\n            Must have length equal to 'degree'.\n            If None, perturbed complex roots of unity are used.\n    max_iter: Number of iterations to perform (default: 100).\n\nReturns:\n    np.ndarray: Array of approximated complex roots.\n\nRaises:\n    ValueError: If degree < 1, or if initial roots length doesn't match the degree.\n\nNote:\n    - Root updates are clipped to prevent numerical overflow.\n\nExample:\n    >>> import numpy as np\n    >>> def check(poly, degree, expected):\n    ...     roots = weierstrass_method(poly, degree)\n    ...     return np.allclose(np.sort(roots), np.sort(expected))\n\n    >>> check(\n    ...     lambda x: x**2 - 1,\n    ...     2,\n    ...     np.array([-1, 1]))\n    True\n\n    >>> check(\n    ...     lambda x: x**3 - 4.5*x**2 + 5.75*x - 1.875,\n    ...     3,\n    ...     np.array([1.5, 0.5, 2.5])\n    ... )\n    True\n\nSee Also:\n    https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method"
  },
  {
    "function": "is_arithmetic_series",
    "code": "def is_arithmetic_series(series: list) -> bool:\n    \"\"\"\n    checking whether the input series is arithmetic series or not\n    >>> is_arithmetic_series([2, 4, 6])\n    True\n    >>> is_arithmetic_series([3, 6, 12, 24])\n    False\n    >>> is_arithmetic_series([1, 2, 3])\n    True\n    >>> is_arithmetic_series(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 6]\n    >>> is_arithmetic_series([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    if len(series) == 1:\n        return True\n    common_diff = series[1] - series[0]\n    for index in range(len(series) - 1):\n        if series[index + 1] - series[index] != common_diff:\n            return False\n    return True",
    "docstring": "checking whether the input series is arithmetic series or not\n>>> is_arithmetic_series([2, 4, 6])\nTrue\n>>> is_arithmetic_series([3, 6, 12, 24])\nFalse\n>>> is_arithmetic_series([1, 2, 3])\nTrue\n>>> is_arithmetic_series(4)\nTraceback (most recent call last):\n    ...\nValueError: Input series is not valid, valid series - [2, 4, 6]\n>>> is_arithmetic_series([])\nTraceback (most recent call last):\n    ...\nValueError: Input list must be a non empty list"
  },
  {
    "function": "arithmetic_mean",
    "code": "def arithmetic_mean(series: list) -> float:\n    \"\"\"\n    return the arithmetic mean of series\n\n    >>> arithmetic_mean([2, 4, 6])\n    4.0\n    >>> arithmetic_mean([3, 6, 9, 12])\n    7.5\n    >>> arithmetic_mean(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 6]\n    >>> arithmetic_mean([4, 8, 1])\n    4.333333333333333\n    >>> arithmetic_mean([1, 2, 3])\n    2.0\n    >>> arithmetic_mean([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 0\n    for val in series:\n        answer += val\n    return answer / len(series)",
    "docstring": "return the arithmetic mean of series\n\n>>> arithmetic_mean([2, 4, 6])\n4.0\n>>> arithmetic_mean([3, 6, 9, 12])\n7.5\n>>> arithmetic_mean(4)\nTraceback (most recent call last):\n    ...\nValueError: Input series is not valid, valid series - [2, 4, 6]\n>>> arithmetic_mean([4, 8, 1])\n4.333333333333333\n>>> arithmetic_mean([1, 2, 3])\n2.0\n>>> arithmetic_mean([])\nTraceback (most recent call last):\n    ...\nValueError: Input list must be a non empty list"
  },
  {
    "function": "is_geometric_series",
    "code": "def is_geometric_series(series: list) -> bool:\n    \"\"\"\n    checking whether the input series is geometric series or not\n    >>> is_geometric_series([2, 4, 8])\n    True\n    >>> is_geometric_series([3, 6, 12, 24])\n    True\n    >>> is_geometric_series([1, 2, 3])\n    False\n    >>> is_geometric_series([0, 0, 3])\n    False\n    >>> is_geometric_series([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n    >>> is_geometric_series(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 8]\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    if len(series) == 1:\n        return True\n    try:\n        common_ratio = series[1] / series[0]\n        for index in range(len(series) - 1):\n            if series[index + 1] / series[index] != common_ratio:\n                return False\n    except ZeroDivisionError:\n        return False\n    return True",
    "docstring": "checking whether the input series is geometric series or not\n>>> is_geometric_series([2, 4, 8])\nTrue\n>>> is_geometric_series([3, 6, 12, 24])\nTrue\n>>> is_geometric_series([1, 2, 3])\nFalse\n>>> is_geometric_series([0, 0, 3])\nFalse\n>>> is_geometric_series([])\nTraceback (most recent call last):\n    ...\nValueError: Input list must be a non empty list\n>>> is_geometric_series(4)\nTraceback (most recent call last):\n    ...\nValueError: Input series is not valid, valid series - [2, 4, 8]"
  },
  {
    "function": "geometric_mean",
    "code": "def geometric_mean(series: list) -> float:\n    \"\"\"\n    return the geometric mean of series\n\n    >>> geometric_mean([2, 4, 8])\n    3.9999999999999996\n    >>> geometric_mean([3, 6, 12, 24])\n    8.48528137423857\n    >>> geometric_mean([4, 8, 16])\n    7.999999999999999\n    >>> geometric_mean(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 8]\n    >>> geometric_mean([1, 2, 3])\n    1.8171205928321397\n    >>> geometric_mean([0, 2, 3])\n    0.0\n    >>> geometric_mean([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 1\n    for value in series:\n        answer *= value\n    return pow(answer, 1 / len(series))",
    "docstring": "return the geometric mean of series\n\n>>> geometric_mean([2, 4, 8])\n3.9999999999999996\n>>> geometric_mean([3, 6, 12, 24])\n8.48528137423857\n>>> geometric_mean([4, 8, 16])\n7.999999999999999\n>>> geometric_mean(4)\nTraceback (most recent call last):\n    ...\nValueError: Input series is not valid, valid series - [2, 4, 8]\n>>> geometric_mean([1, 2, 3])\n1.8171205928321397\n>>> geometric_mean([0, 2, 3])\n0.0\n>>> geometric_mean([])\nTraceback (most recent call last):\n    ...\nValueError: Input list must be a non empty list"
  },
  {
    "function": "geometric_series",
    "code": "def geometric_series(\n    nth_term: float,\n    start_term_a: float,\n    common_ratio_r: float,\n) -> list[float]:\n    \"\"\"\n    Pure Python implementation of Geometric Series algorithm\n\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\n    >>> geometric_series(4, 2, -2)\n    [2, -4.0, 8.0, -16.0]\n    >>> geometric_series(4, -2, 2)\n    [-2, -4.0, -8.0, -16.0]\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if not series:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series",
    "docstring": "Pure Python implementation of Geometric Series algorithm\n\n:param nth_term: The last term (nth term of Geometric Series)\n:param start_term_a : The first term of Geometric Series\n:param common_ratio_r : The common ratio between all the terms\n:return: The Geometric Series starting from first term a and multiple of common\n    ration with first term with increase in power till last term (nth term)\nExamples:\n>>> geometric_series(4, 2, 2)\n[2, 4.0, 8.0, 16.0]\n>>> geometric_series(4.0, 2.0, 2.0)\n[2.0, 4.0, 8.0, 16.0]\n>>> geometric_series(4.1, 2.1, 2.1)\n[2.1, 4.41, 9.261000000000001, 19.448100000000004]\n>>> geometric_series(4, 2, -2)\n[2, -4.0, 8.0, -16.0]\n>>> geometric_series(4, -2, 2)\n[-2, -4.0, -8.0, -16.0]\n>>> geometric_series(-4, 2, 2)\n[]\n>>> geometric_series(0, 100, 500)\n[]\n>>> geometric_series(1, 1, 1)\n[1]\n>>> geometric_series(0, 0, 0)\n[]"
  },
  {
    "function": "is_harmonic_series",
    "code": "def is_harmonic_series(series: list) -> bool:\n    \"\"\"\n    checking whether the input series is arithmetic series or not\n    >>> is_harmonic_series([ 1, 2/3, 1/2, 2/5, 1/3])\n    True\n    >>> is_harmonic_series([ 1, 2/3, 2/5, 1/3])\n    False\n    >>> is_harmonic_series([1, 2, 3])\n    False\n    >>> is_harmonic_series([1/2, 1/3, 1/4])\n    True\n    >>> is_harmonic_series([2/5, 2/10, 2/15, 2/20, 2/25])\n    True\n    >>> is_harmonic_series(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [1, 2/3, 2]\n    >>> is_harmonic_series([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n    >>> is_harmonic_series([0])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series cannot have 0 as an element\n    >>> is_harmonic_series([1,2,0,6])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series cannot have 0 as an element\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [1, 2/3, 2]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    if len(series) == 1 and series[0] != 0:\n        return True\n    rec_series = []\n    series_len = len(series)\n    for i in range(series_len):\n        if series[i] == 0:\n            raise ValueError(\"Input series cannot have 0 as an element\")\n        rec_series.append(1 / series[i])\n    common_diff = rec_series[1] - rec_series[0]\n    for index in range(2, series_len):\n        if rec_series[index] - rec_series[index - 1] != common_diff:\n            return False\n    return True",
    "docstring": "checking whether the input series is arithmetic series or not\n>>> is_harmonic_series([ 1, 2/3, 1/2, 2/5, 1/3])\nTrue\n>>> is_harmonic_series([ 1, 2/3, 2/5, 1/3])\nFalse\n>>> is_harmonic_series([1, 2, 3])\nFalse\n>>> is_harmonic_series([1/2, 1/3, 1/4])\nTrue\n>>> is_harmonic_series([2/5, 2/10, 2/15, 2/20, 2/25])\nTrue\n>>> is_harmonic_series(4)\nTraceback (most recent call last):\n    ...\nValueError: Input series is not valid, valid series - [1, 2/3, 2]\n>>> is_harmonic_series([])\nTraceback (most recent call last):\n    ...\nValueError: Input list must be a non empty list\n>>> is_harmonic_series([0])\nTraceback (most recent call last):\n    ...\nValueError: Input series cannot have 0 as an element\n>>> is_harmonic_series([1,2,0,6])\nTraceback (most recent call last):\n    ...\nValueError: Input series cannot have 0 as an element"
  },
  {
    "function": "harmonic_mean",
    "code": "def harmonic_mean(series: list) -> float:\n    \"\"\"\n    return the harmonic mean of series\n\n    >>> harmonic_mean([1, 4, 4])\n    2.0\n    >>> harmonic_mean([3, 6, 9, 12])\n    5.759999999999999\n    >>> harmonic_mean(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 6]\n    >>> harmonic_mean([1, 2, 3])\n    1.6363636363636365\n    >>> harmonic_mean([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 0\n    for val in series:\n        answer += 1 / val\n    return len(series) / answer",
    "docstring": "return the harmonic mean of series\n\n>>> harmonic_mean([1, 4, 4])\n2.0\n>>> harmonic_mean([3, 6, 9, 12])\n5.759999999999999\n>>> harmonic_mean(4)\nTraceback (most recent call last):\n    ...\nValueError: Input series is not valid, valid series - [2, 4, 6]\n>>> harmonic_mean([1, 2, 3])\n1.6363636363636365\n>>> harmonic_mean([])\nTraceback (most recent call last):\n    ...\nValueError: Input list must be a non empty list"
  },
  {
    "function": "harmonic_series",
    "code": "def harmonic_series(n_term: str) -> list:\n    \"\"\"Pure Python implementation of Harmonic Series algorithm\n\n    :param n_term: The last (nth) term of Harmonic Series\n    :return: The Harmonic Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> harmonic_series(5)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.0)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.1)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(-5)\n    []\n    >>> harmonic_series(0)\n    []\n    >>> harmonic_series(1)\n    ['1']\n    \"\"\"\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series",
    "docstring": "Pure Python implementation of Harmonic Series algorithm\n\n:param n_term: The last (nth) term of Harmonic Series\n:return: The Harmonic Series starting from 1 to last (nth) term\n\nExamples:\n>>> harmonic_series(5)\n['1', '1/2', '1/3', '1/4', '1/5']\n>>> harmonic_series(5.0)\n['1', '1/2', '1/3', '1/4', '1/5']\n>>> harmonic_series(5.1)\n['1', '1/2', '1/3', '1/4', '1/5']\n>>> harmonic_series(-5)\n[]\n>>> harmonic_series(0)\n[]\n>>> harmonic_series(1)\n['1']"
  },
  {
    "function": "hexagonal_numbers",
    "code": "def hexagonal_numbers(length: int) -> list[int]:\n    \"\"\"\n    :param len: max number of elements\n    :type len: int\n    :return: Hexagonal numbers as a list\n\n    Tests:\n    >>> hexagonal_numbers(10)\n    [0, 1, 6, 15, 28, 45, 66, 91, 120, 153]\n    >>> hexagonal_numbers(5)\n    [0, 1, 6, 15, 28]\n    >>> hexagonal_numbers(0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Length must be a positive integer.\n    \"\"\"\n\n    if length <= 0 or not isinstance(length, int):\n        raise ValueError(\"Length must be a positive integer.\")\n    return [n * (2 * n - 1) for n in range(length)]",
    "docstring": ":param len: max number of elements\n:type len: int\n:return: Hexagonal numbers as a list\n\nTests:\n>>> hexagonal_numbers(10)\n[0, 1, 6, 15, 28, 45, 66, 91, 120, 153]\n>>> hexagonal_numbers(5)\n[0, 1, 6, 15, 28]\n>>> hexagonal_numbers(0)\nTraceback (most recent call last):\n  ...\nValueError: Length must be a positive integer."
  },
  {
    "function": "p_series",
    "code": "def p_series(nth_term: float | str, power: float | str) -> list[str]:\n    \"\"\"\n    Pure Python implementation of P-Series algorithm\n    :return: The P-Series starting from 1 to last (nth) term\n    Examples:\n    >>> p_series(5, 2)\n    ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']\n    >>> p_series(\"\", 1000)\n    ['']\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    ['1']\n    \"\"\"\n    if nth_term == \"\":\n        return [\"\"]\n    nth_term = int(nth_term)\n    power = int(power)\n    series: list[str] = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")\n    return series",
    "docstring": "Pure Python implementation of P-Series algorithm\n:return: The P-Series starting from 1 to last (nth) term\nExamples:\n>>> p_series(5, 2)\n['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']\n>>> p_series(-5, 2)\n[]\n>>> p_series(5, -2)\n['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']\n>>> p_series(\"\", 1000)\n['']\n>>> p_series(0, 0)\n[]\n>>> p_series(1, 1)\n['1']"
  },
  {
    "function": "armstrong_number",
    "code": "def armstrong_number(n: int) -> bool:\n    \"\"\"\n    Return True if n is an Armstrong number or False if it is not.\n\n    >>> all(armstrong_number(n) for n in PASSING)\n    True\n    >>> any(armstrong_number(n) for n in FAILING)\n    False\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        return False\n\n    # Initialization of sum and number of digits.\n    total = 0\n    number_of_digits = 0\n    temp = n\n    # Calculation of digits of the number\n    number_of_digits = len(str(n))\n    # Dividing number into separate digits and find Armstrong number\n    temp = n\n    while temp > 0:\n        rem = temp % 10\n        total += rem**number_of_digits\n        temp //= 10\n    return n == total",
    "docstring": "Return True if n is an Armstrong number or False if it is not.\n\n>>> all(armstrong_number(n) for n in PASSING)\nTrue\n>>> any(armstrong_number(n) for n in FAILING)\nFalse"
  },
  {
    "function": "pluperfect_number",
    "code": "def pluperfect_number(n: int) -> bool:\n    \"\"\"Return True if n is a pluperfect number or False if it is not\n\n    >>> all(pluperfect_number(n) for n in PASSING)\n    True\n    >>> any(pluperfect_number(n) for n in FAILING)\n    False\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        return False\n\n    # Init a \"histogram\" of the digits\n    digit_histogram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    digit_total = 0\n    total = 0\n    temp = n\n    while temp > 0:\n        temp, rem = divmod(temp, 10)\n        digit_histogram[rem] += 1\n        digit_total += 1\n\n    for cnt, i in zip(digit_histogram, range(len(digit_histogram))):\n        total += cnt * i**digit_total\n\n    return n == total",
    "docstring": "Return True if n is a pluperfect number or False if it is not\n\n>>> all(pluperfect_number(n) for n in PASSING)\nTrue\n>>> any(pluperfect_number(n) for n in FAILING)\nFalse"
  },
  {
    "function": "narcissistic_number",
    "code": "def narcissistic_number(n: int) -> bool:\n    \"\"\"Return True if n is a narcissistic number or False if it is not.\n\n    >>> all(narcissistic_number(n) for n in PASSING)\n    True\n    >>> any(narcissistic_number(n) for n in FAILING)\n    False\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        return False\n    expo = len(str(n))  # the power that all digits will be raised to\n    # check if sum of each digit multiplied expo times is equal to number\n    return n == sum(int(i) ** expo for i in str(n))",
    "docstring": "Return True if n is a narcissistic number or False if it is not.\n\n>>> all(narcissistic_number(n) for n in PASSING)\nTrue\n>>> any(narcissistic_number(n) for n in FAILING)\nFalse"
  },
  {
    "function": "main",
    "code": "def main():\n    \"\"\"\n    Request that user input an integer and tell them if it is Armstrong number.\n    \"\"\"\n    num = int(input(\"Enter an integer to see if it is an Armstrong number: \").strip())\n    print(f\"{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number.\")\n    print(f\"{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number.\")\n    print(f\"{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number.\")",
    "docstring": "Request that user input an integer and tell them if it is Armstrong number."
  },
  {
    "function": "is_automorphic_number",
    "code": "def is_automorphic_number(number: int) -> bool:\n    \"\"\"\n    # doctest: +NORMALIZE_WHITESPACE\n    This functions takes an integer number as input.\n    returns True if the number is automorphic.\n    >>> is_automorphic_number(-1)\n    False\n    >>> is_automorphic_number(0)\n    True\n    >>> is_automorphic_number(5)\n    True\n    >>> is_automorphic_number(6)\n    True\n    >>> is_automorphic_number(7)\n    False\n    >>> is_automorphic_number(25)\n    True\n    >>> is_automorphic_number(259918212890625)\n    True\n    >>> is_automorphic_number(259918212890636)\n    False\n    >>> is_automorphic_number(740081787109376)\n    True\n    >>> is_automorphic_number(5.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=5.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 0:\n        return False\n    number_square = number * number\n    while number > 0:\n        if number % 10 != number_square % 10:\n            return False\n        number //= 10\n        number_square //= 10\n    return True",
    "docstring": "# doctest: +NORMALIZE_WHITESPACE\nThis functions takes an integer number as input.\nreturns True if the number is automorphic.\n>>> is_automorphic_number(-1)\nFalse\n>>> is_automorphic_number(0)\nTrue\n>>> is_automorphic_number(5)\nTrue\n>>> is_automorphic_number(6)\nTrue\n>>> is_automorphic_number(7)\nFalse\n>>> is_automorphic_number(25)\nTrue\n>>> is_automorphic_number(259918212890625)\nTrue\n>>> is_automorphic_number(259918212890636)\nFalse\n>>> is_automorphic_number(740081787109376)\nTrue\n>>> is_automorphic_number(5.0)\nTraceback (most recent call last):\n    ...\nTypeError: Input value of [number=5.0] must be an integer"
  },
  {
    "function": "bell_numbers",
    "code": "def bell_numbers(max_set_length: int) -> list[int]:\n    \"\"\"\n    Calculate Bell numbers for the sets of lengths from 0 to max_set_length.\n    In other words, calculate first (max_set_length + 1) Bell numbers.\n\n    Args:\n        max_set_length (int): The maximum length of the sets for which\n        Bell numbers are calculated.\n\n    Returns:\n        list: A list of Bell numbers for sets of lengths from 0 to max_set_length.\n\n    Examples:\n    >>> bell_numbers(-2)\n    Traceback (most recent call last):\n        ...\n    ValueError: max_set_length must be non-negative\n    >>> bell_numbers(0)\n    [1]\n    >>> bell_numbers(1)\n    [1, 1]\n    >>> bell_numbers(5)\n    [1, 1, 2, 5, 15, 52]\n    \"\"\"\n    if max_set_length < 0:\n        raise ValueError(\"max_set_length must be non-negative\")\n\n    bell = [0] * (max_set_length + 1)\n    bell[0] = 1\n\n    for i in range(1, max_set_length + 1):\n        for j in range(i):\n            bell[i] += _binomial_coefficient(i - 1, j) * bell[j]\n\n    return bell",
    "docstring": "Calculate Bell numbers for the sets of lengths from 0 to max_set_length.\nIn other words, calculate first (max_set_length + 1) Bell numbers.\n\nArgs:\n    max_set_length (int): The maximum length of the sets for which\n    Bell numbers are calculated.\n\nReturns:\n    list: A list of Bell numbers for sets of lengths from 0 to max_set_length.\n\nExamples:\n>>> bell_numbers(-2)\nTraceback (most recent call last):\n    ...\nValueError: max_set_length must be non-negative\n>>> bell_numbers(0)\n[1]\n>>> bell_numbers(1)\n[1, 1]\n>>> bell_numbers(5)\n[1, 1, 2, 5, 15, 52]"
  },
  {
    "function": "_binomial_coefficient",
    "code": "def _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\n    Args:\n        total_elements (int): The total number of elements.\n        elements_to_choose (int): The number of elements to choose.\n\n    Returns:\n        int: The binomial coefficient C(total_elements, elements_to_choose).\n\n    Examples:\n    >>> _binomial_coefficient(5, 2)\n    10\n    >>> _binomial_coefficient(6, 3)\n    20\n    \"\"\"\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient",
    "docstring": "Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\nArgs:\n    total_elements (int): The total number of elements.\n    elements_to_choose (int): The number of elements to choose.\n\nReturns:\n    int: The binomial coefficient C(total_elements, elements_to_choose).\n\nExamples:\n>>> _binomial_coefficient(5, 2)\n10\n>>> _binomial_coefficient(6, 3)\n20"
  },
  {
    "function": "power",
    "code": "def power(x: int, y: int, mod: int) -> int:\n    \"\"\"\n    Examples:\n    >>> power(2, 15, 3)\n    2\n    >>> power(5, 1, 30)\n    5\n    \"\"\"\n\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, mod) % mod\n    temp = (temp * temp) % mod\n    if y % 2 == 1:\n        temp = (temp * x) % mod\n    return temp",
    "docstring": "Examples:\n>>> power(2, 15, 3)\n2\n>>> power(5, 1, 30)\n5"
  },
  {
    "function": "is_carmichael_number",
    "code": "def is_carmichael_number(n: int) -> bool:\n    \"\"\"\n    Examples:\n    >>> is_carmichael_number(4)\n    False\n    >>> is_carmichael_number(561)\n    True\n    >>> is_carmichael_number(562)\n    False\n    >>> is_carmichael_number(900)\n    False\n    >>> is_carmichael_number(1105)\n    True\n    >>> is_carmichael_number(8911)\n    True\n    >>> is_carmichael_number(5.1)\n    Traceback (most recent call last):\n         ...\n    ValueError: Number 5.1 must instead be a positive integer\n\n    >>> is_carmichael_number(-7)\n    Traceback (most recent call last):\n         ...\n    ValueError: Number -7 must instead be a positive integer\n\n    >>> is_carmichael_number(0)\n    Traceback (most recent call last):\n         ...\n    ValueError: Number 0 must instead be a positive integer\n    \"\"\"\n\n    if n <= 0 or not isinstance(n, int):\n        msg = f\"Number {n} must instead be a positive integer\"\n        raise ValueError(msg)\n\n    return all(\n        power(b, n - 1, n) == 1\n        for b in range(2, n)\n        if greatest_common_divisor(b, n) == 1\n    )",
    "docstring": "Examples:\n>>> is_carmichael_number(4)\nFalse\n>>> is_carmichael_number(561)\nTrue\n>>> is_carmichael_number(562)\nFalse\n>>> is_carmichael_number(900)\nFalse\n>>> is_carmichael_number(1105)\nTrue\n>>> is_carmichael_number(8911)\nTrue\n>>> is_carmichael_number(5.1)\nTraceback (most recent call last):\n     ...\nValueError: Number 5.1 must instead be a positive integer\n\n>>> is_carmichael_number(-7)\nTraceback (most recent call last):\n     ...\nValueError: Number -7 must instead be a positive integer\n\n>>> is_carmichael_number(0)\nTraceback (most recent call last):\n     ...\nValueError: Number 0 must instead be a positive integer"
  },
  {
    "function": "catalan",
    "code": "def catalan(number: int) -> int:\n    \"\"\"\n    :param number: nth catalan number to calculate\n    :return: the nth catalan number\n    Note: A catalan number is only defined for positive integers\n\n    >>> catalan(5)\n    14\n    >>> catalan(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=0] must be > 0\n    >>> catalan(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=-1] must be > 0\n    >>> catalan(5.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=5.0] must be an integer\n    \"\"\"\n\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n\n    if number < 1:\n        msg = f\"Input value of [number={number}] must be > 0\"\n        raise ValueError(msg)\n\n    current_number = 1\n\n    for i in range(1, number):\n        current_number *= 4 * i - 2\n        current_number //= i + 1\n\n    return current_number",
    "docstring": ":param number: nth catalan number to calculate\n:return: the nth catalan number\nNote: A catalan number is only defined for positive integers\n\n>>> catalan(5)\n14\n>>> catalan(0)\nTraceback (most recent call last):\n    ...\nValueError: Input value of [number=0] must be > 0\n>>> catalan(-1)\nTraceback (most recent call last):\n    ...\nValueError: Input value of [number=-1] must be > 0\n>>> catalan(5.0)\nTraceback (most recent call last):\n    ...\nTypeError: Input value of [number=5.0] must be an integer"
  },
  {
    "function": "hamming",
    "code": "def hamming(n_element: int) -> list:\n    \"\"\"\n    This function creates an ordered list of n length as requested, and afterwards\n    returns the last value of the list. It must be given a positive integer.\n\n    :param n_element: The number of elements on the list\n    :return: The nth element of the list\n\n    >>> hamming(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: n_element should be a positive number\n    >>> hamming(5)\n    [1, 2, 3, 4, 5]\n    >>> hamming(10)\n    [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]\n    >>> hamming(15)\n    [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]\n    \"\"\"\n    n_element = int(n_element)\n    if n_element < 1:\n        my_error = ValueError(\"n_element should be a positive number\")\n        raise my_error\n\n    hamming_list = [1]\n    i, j, k = (0, 0, 0)\n    index = 1\n    while index < n_element:\n        while hamming_list[i] * 2 <= hamming_list[-1]:\n            i += 1\n        while hamming_list[j] * 3 <= hamming_list[-1]:\n            j += 1\n        while hamming_list[k] * 5 <= hamming_list[-1]:\n            k += 1\n        hamming_list.append(\n            min(hamming_list[i] * 2, hamming_list[j] * 3, hamming_list[k] * 5)\n        )\n        index += 1\n    return hamming_list",
    "docstring": "This function creates an ordered list of n length as requested, and afterwards\nreturns the last value of the list. It must be given a positive integer.\n\n:param n_element: The number of elements on the list\n:return: The nth element of the list\n\n>>> hamming(-5)\nTraceback (most recent call last):\n    ...\nValueError: n_element should be a positive number\n>>> hamming(5)\n[1, 2, 3, 4, 5]\n>>> hamming(10)\n[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]\n>>> hamming(15)\n[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]"
  },
  {
    "function": "is_happy_number",
    "code": "def is_happy_number(number: int) -> bool:\n    \"\"\"\n    A happy number is a number which eventually reaches 1 when replaced by the sum of\n    the square of each digit.\n\n    :param number: The number to check for happiness.\n    :return: True if the number is a happy number, False otherwise.\n\n    >>> is_happy_number(19)\n    True\n    >>> is_happy_number(2)\n    False\n    >>> is_happy_number(23)\n    True\n    >>> is_happy_number(1)\n    True\n    >>> is_happy_number(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: number=0 must be a positive integer\n    >>> is_happy_number(-19)\n    Traceback (most recent call last):\n        ...\n    ValueError: number=-19 must be a positive integer\n    >>> is_happy_number(19.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number=19.1 must be a positive integer\n    >>> is_happy_number(\"happy\")\n    Traceback (most recent call last):\n        ...\n    ValueError: number='happy' must be a positive integer\n    \"\"\"\n    if not isinstance(number, int) or number <= 0:\n        msg = f\"{number=} must be a positive integer\"\n        raise ValueError(msg)\n\n    seen = set()\n    while number != 1 and number not in seen:\n        seen.add(number)\n        number = sum(int(digit) ** 2 for digit in str(number))\n    return number == 1",
    "docstring": "A happy number is a number which eventually reaches 1 when replaced by the sum of\nthe square of each digit.\n\n:param number: The number to check for happiness.\n:return: True if the number is a happy number, False otherwise.\n\n>>> is_happy_number(19)\nTrue\n>>> is_happy_number(2)\nFalse\n>>> is_happy_number(23)\nTrue\n>>> is_happy_number(1)\nTrue\n>>> is_happy_number(0)\nTraceback (most recent call last):\n    ...\nValueError: number=0 must be a positive integer\n>>> is_happy_number(-19)\nTraceback (most recent call last):\n    ...\nValueError: number=-19 must be a positive integer\n>>> is_happy_number(19.1)\nTraceback (most recent call last):\n    ...\nValueError: number=19.1 must be a positive integer\n>>> is_happy_number(\"happy\")\nTraceback (most recent call last):\n    ...\nValueError: number='happy' must be a positive integer"
  },
  {
    "function": "int_to_base",
    "code": "def int_to_base(number: int, base: int) -> str:\n    \"\"\"\n    Convert a given positive decimal integer to base 'base'.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> int_to_base(0, 21)\n    '0'\n    >>> int_to_base(23, 2)\n    '10111'\n    >>> int_to_base(58, 5)\n    '213'\n    >>> int_to_base(167, 16)\n    'A7'\n    >>> # bases below 2 and beyond 36 will error\n    >>> int_to_base(98, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> int_to_base(98, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> int_to_base(-99, 16)\n    Traceback (most recent call last):\n        ...\n    ValueError: number must be a positive integer\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    result = \"\"\n\n    if number < 0:\n        raise ValueError(\"number must be a positive integer\")\n\n    while number > 0:\n        number, remainder = divmod(number, base)\n        result = digits[remainder] + result\n\n    if result == \"\":\n        result = \"0\"\n\n    return result",
    "docstring": "Convert a given positive decimal integer to base 'base'.\nWhere 'base' ranges from 2 to 36.\n\nExamples:\n>>> int_to_base(0, 21)\n'0'\n>>> int_to_base(23, 2)\n'10111'\n>>> int_to_base(58, 5)\n'213'\n>>> int_to_base(167, 16)\n'A7'\n>>> # bases below 2 and beyond 36 will error\n>>> int_to_base(98, 1)\nTraceback (most recent call last):\n    ...\nValueError: 'base' must be between 2 and 36 inclusive\n>>> int_to_base(98, 37)\nTraceback (most recent call last):\n    ...\nValueError: 'base' must be between 2 and 36 inclusive\n>>> int_to_base(-99, 16)\nTraceback (most recent call last):\n    ...\nValueError: number must be a positive integer"
  },
  {
    "function": "sum_of_digits",
    "code": "def sum_of_digits(num: int, base: int) -> str:\n    \"\"\"\n    Calculate the sum of digit values in a positive integer\n    converted to the given 'base'.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> sum_of_digits(103, 12)\n    '13'\n    >>> sum_of_digits(1275, 4)\n    '30'\n    >>> sum_of_digits(6645, 2)\n    '1001'\n    >>> # bases below 2 and beyond 36 will error\n    >>> sum_of_digits(543, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> sum_of_digits(543, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    num_str = int_to_base(num, base)\n    res = sum(int(char, base) for char in num_str)\n    res_str = int_to_base(res, base)\n    return res_str",
    "docstring": "Calculate the sum of digit values in a positive integer\nconverted to the given 'base'.\nWhere 'base' ranges from 2 to 36.\n\nExamples:\n>>> sum_of_digits(103, 12)\n'13'\n>>> sum_of_digits(1275, 4)\n'30'\n>>> sum_of_digits(6645, 2)\n'1001'\n>>> # bases below 2 and beyond 36 will error\n>>> sum_of_digits(543, 1)\nTraceback (most recent call last):\n    ...\nValueError: 'base' must be between 2 and 36 inclusive\n>>> sum_of_digits(543, 37)\nTraceback (most recent call last):\n    ...\nValueError: 'base' must be between 2 and 36 inclusive"
  },
  {
    "function": "harshad_numbers_in_base",
    "code": "def harshad_numbers_in_base(limit: int, base: int) -> list[str]:\n    \"\"\"\n    Finds all Harshad numbers smaller than num in base 'base'.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> harshad_numbers_in_base(15, 2)\n    ['1', '10', '100', '110', '1000', '1010', '1100']\n    >>> harshad_numbers_in_base(12, 34)\n    ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B']\n    >>> harshad_numbers_in_base(12, 4)\n    ['1', '2', '3', '10', '12', '20', '21']\n    >>> # bases below 2 and beyond 36 will error\n    >>> harshad_numbers_in_base(234, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> harshad_numbers_in_base(234, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> harshad_numbers_in_base(-12, 6)\n    []\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    if limit < 0:\n        return []\n\n    numbers = [\n        int_to_base(i, base)\n        for i in range(1, limit)\n        if i % int(sum_of_digits(i, base), base) == 0\n    ]\n\n    return numbers",
    "docstring": "Finds all Harshad numbers smaller than num in base 'base'.\nWhere 'base' ranges from 2 to 36.\n\nExamples:\n>>> harshad_numbers_in_base(15, 2)\n['1', '10', '100', '110', '1000', '1010', '1100']\n>>> harshad_numbers_in_base(12, 34)\n['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B']\n>>> harshad_numbers_in_base(12, 4)\n['1', '2', '3', '10', '12', '20', '21']\n>>> # bases below 2 and beyond 36 will error\n>>> harshad_numbers_in_base(234, 37)\nTraceback (most recent call last):\n    ...\nValueError: 'base' must be between 2 and 36 inclusive\n>>> harshad_numbers_in_base(234, 1)\nTraceback (most recent call last):\n    ...\nValueError: 'base' must be between 2 and 36 inclusive\n>>> harshad_numbers_in_base(-12, 6)\n[]"
  },
  {
    "function": "is_harshad_number_in_base",
    "code": "def is_harshad_number_in_base(num: int, base: int) -> bool:\n    \"\"\"\n    Determines whether n in base 'base' is a harshad number.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> is_harshad_number_in_base(18, 10)\n    True\n    >>> is_harshad_number_in_base(21, 10)\n    True\n    >>> is_harshad_number_in_base(-21, 5)\n    False\n    >>> # bases below 2 and beyond 36 will error\n    >>> is_harshad_number_in_base(45, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> is_harshad_number_in_base(45, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    if num < 0:\n        return False\n\n    n = int_to_base(num, base)\n    d = sum_of_digits(num, base)\n    return int(n, base) % int(d, base) == 0",
    "docstring": "Determines whether n in base 'base' is a harshad number.\nWhere 'base' ranges from 2 to 36.\n\nExamples:\n>>> is_harshad_number_in_base(18, 10)\nTrue\n>>> is_harshad_number_in_base(21, 10)\nTrue\n>>> is_harshad_number_in_base(-21, 5)\nFalse\n>>> # bases below 2 and beyond 36 will error\n>>> is_harshad_number_in_base(45, 37)\nTraceback (most recent call last):\n    ...\nValueError: 'base' must be between 2 and 36 inclusive\n>>> is_harshad_number_in_base(45, 1)\nTraceback (most recent call last):\n    ...\nValueError: 'base' must be between 2 and 36 inclusive"
  },
  {
    "function": "hexagonal",
    "code": "def hexagonal(number: int) -> int:\n    \"\"\"\n    :param number: nth hexagonal number to calculate\n    :return: the nth hexagonal number\n    Note: A hexagonal number is only defined for positive integers\n    >>> hexagonal(4)\n    28\n    >>> hexagonal(11)\n    231\n    >>> hexagonal(22)\n    946\n    >>> hexagonal(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer\n    >>> hexagonal(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer\n    >>> hexagonal(11.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=11.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    return number * (2 * number - 1)",
    "docstring": ":param number: nth hexagonal number to calculate\n:return: the nth hexagonal number\nNote: A hexagonal number is only defined for positive integers\n>>> hexagonal(4)\n28\n>>> hexagonal(11)\n231\n>>> hexagonal(22)\n946\n>>> hexagonal(0)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a positive integer\n>>> hexagonal(-1)\nTraceback (most recent call last):\n    ...\nValueError: Input must be a positive integer\n>>> hexagonal(11.0)\nTraceback (most recent call last):\n    ...\nTypeError: Input value of [number=11.0] must be an integer"
  },
  {
    "function": "factorial",
    "code": "def factorial(digit: int) -> int:\n    \"\"\"\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    >>> factorial(5)\n    120\n    \"\"\"\n\n    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))",
    "docstring": ">>> factorial(3)\n6\n>>> factorial(0)\n1\n>>> factorial(5)\n120"
  },
  {
    "function": "krishnamurthy",
    "code": "def krishnamurthy(number: int) -> bool:\n    \"\"\"\n    >>> krishnamurthy(145)\n    True\n    >>> krishnamurthy(240)\n    False\n    >>> krishnamurthy(1)\n    True\n    \"\"\"\n\n    fact_sum = 0\n    duplicate = number\n    while duplicate > 0:\n        duplicate, digit = divmod(duplicate, 10)\n        fact_sum += factorial(digit)\n    return fact_sum == number",
    "docstring": ">>> krishnamurthy(145)\nTrue\n>>> krishnamurthy(240)\nFalse\n>>> krishnamurthy(1)\nTrue"
  },
  {
    "function": "perfect",
    "code": "def perfect(number: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect number.\n\n    A perfect number is a positive integer that is equal to the sum of its proper\n    divisors (excluding itself).\n\n    Args:\n        number: The number to be checked.\n\n    Returns:\n        True if the number is a perfect number, False otherwise.\n\n    Start from 1 because dividing by 0 will raise ZeroDivisionError.\n    A number at most can be divisible by the half of the number except the number\n    itself. For example, 6 is at most can be divisible by 3 except by 6 itself.\n\n    Examples:\n    >>> perfect(27)\n    False\n    >>> perfect(28)\n    True\n    >>> perfect(29)\n    False\n    >>> perfect(6)\n    True\n    >>> perfect(12)\n    False\n    >>> perfect(496)\n    True\n    >>> perfect(8128)\n    True\n    >>> perfect(0)\n    False\n    >>> perfect(-1)\n    False\n    >>> perfect(12.34)\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    >>> perfect(\"Hello\")\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        raise ValueError(\"number must be an integer\")\n    if number <= 0:\n        return False\n    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number",
    "docstring": "Check if a number is a perfect number.\n\nA perfect number is a positive integer that is equal to the sum of its proper\ndivisors (excluding itself).\n\nArgs:\n    number: The number to be checked.\n\nReturns:\n    True if the number is a perfect number, False otherwise.\n\nStart from 1 because dividing by 0 will raise ZeroDivisionError.\nA number at most can be divisible by the half of the number except the number\nitself. For example, 6 is at most can be divisible by 3 except by 6 itself.\n\nExamples:\n>>> perfect(27)\nFalse\n>>> perfect(28)\nTrue\n>>> perfect(29)\nFalse\n>>> perfect(6)\nTrue\n>>> perfect(12)\nFalse\n>>> perfect(496)\nTrue\n>>> perfect(8128)\nTrue\n>>> perfect(0)\nFalse\n>>> perfect(-1)\nFalse\n>>> perfect(12.34)\nTraceback (most recent call last):\n  ...\nValueError: number must be an integer\n>>> perfect(\"Hello\")\nTraceback (most recent call last):\n  ...\nValueError: number must be an integer"
  },
  {
    "function": "polygonal_num",
    "code": "def polygonal_num(num: int, sides: int) -> int:\n    \"\"\"\n    Returns the `num`th `sides`-gonal number. It is assumed that `num` >= 0 and\n    `sides` >= 3 (see for reference https://en.wikipedia.org/wiki/Polygonal_number).\n\n    >>> polygonal_num(0, 3)\n    0\n    >>> polygonal_num(3, 3)\n    6\n    >>> polygonal_num(5, 4)\n    25\n    >>> polygonal_num(2, 5)\n    5\n    >>> polygonal_num(-1, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input: num must be >= 0 and sides must be >= 3.\n    >>> polygonal_num(0, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input: num must be >= 0 and sides must be >= 3.\n    \"\"\"\n    if num < 0 or sides < 3:\n        raise ValueError(\"Invalid input: num must be >= 0 and sides must be >= 3.\")\n\n    return ((sides - 2) * num**2 - (sides - 4) * num) // 2",
    "docstring": "Returns the `num`th `sides`-gonal number. It is assumed that `num` >= 0 and\n`sides` >= 3 (see for reference https://en.wikipedia.org/wiki/Polygonal_number).\n\n>>> polygonal_num(0, 3)\n0\n>>> polygonal_num(3, 3)\n6\n>>> polygonal_num(5, 4)\n25\n>>> polygonal_num(2, 5)\n5\n>>> polygonal_num(-1, 0)\nTraceback (most recent call last):\n    ...\nValueError: Invalid input: num must be >= 0 and sides must be >= 3.\n>>> polygonal_num(0, 2)\nTraceback (most recent call last):\n    ...\nValueError: Invalid input: num must be >= 0 and sides must be >= 3."
  },
  {
    "function": "is_pronic",
    "code": "def is_pronic(number: int) -> bool:\n    \"\"\"\n    # doctest: +NORMALIZE_WHITESPACE\n    This functions takes an integer number as input.\n    returns True if the number is pronic.\n    >>> is_pronic(-1)\n    False\n    >>> is_pronic(0)\n    True\n    >>> is_pronic(2)\n    True\n    >>> is_pronic(5)\n    False\n    >>> is_pronic(6)\n    True\n    >>> is_pronic(8)\n    False\n    >>> is_pronic(30)\n    True\n    >>> is_pronic(32)\n    False\n    >>> is_pronic(2147441940)\n    True\n    >>> is_pronic(9223372033963249500)\n    True\n    >>> is_pronic(6.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=6.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 0 or number % 2 == 1:\n        return False\n    number_sqrt = int(number**0.5)\n    return number == number_sqrt * (number_sqrt + 1)",
    "docstring": "# doctest: +NORMALIZE_WHITESPACE\nThis functions takes an integer number as input.\nreturns True if the number is pronic.\n>>> is_pronic(-1)\nFalse\n>>> is_pronic(0)\nTrue\n>>> is_pronic(2)\nTrue\n>>> is_pronic(5)\nFalse\n>>> is_pronic(6)\nTrue\n>>> is_pronic(8)\nFalse\n>>> is_pronic(30)\nTrue\n>>> is_pronic(32)\nFalse\n>>> is_pronic(2147441940)\nTrue\n>>> is_pronic(9223372033963249500)\nTrue\n>>> is_pronic(6.0)\nTraceback (most recent call last):\n    ...\nTypeError: Input value of [number=6.0] must be an integer"
  },
  {
    "function": "proth",
    "code": "def proth(number: int) -> int:\n    \"\"\"\n    :param number: nth number to calculate in the sequence\n    :return: the nth number in Proth number\n    Note: indexing starts at 1 i.e. proth(1) gives the first Proth number of 3\n    >>> proth(6)\n    25\n    >>> proth(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=0] must be > 0\n    >>> proth(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=-1] must be > 0\n    >>> proth(6.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=6.0] must be an integer\n    \"\"\"\n\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n\n    if number < 1:\n        msg = f\"Input value of [number={number}] must be > 0\"\n        raise ValueError(msg)\n    elif number == 1:\n        return 3\n    elif number == 2:\n        return 5\n    else:\n        \"\"\"\n        +1 for binary starting at 0 i.e. 2^0, 2^1, etc.\n        +1 to start the sequence at the 3rd Proth number\n        Hence, we have a +2 in the below statement\n        \"\"\"\n        block_index = int(math.log(number // 3, 2)) + 2\n\n        proth_list = [3, 5]\n        proth_index = 2\n        increment = 3\n        for block in range(1, block_index):\n            for _ in range(increment):\n                proth_list.append(2 ** (block + 1) + proth_list[proth_index - 1])\n                proth_index += 1\n            increment *= 2\n\n    return proth_list[number - 1]",
    "docstring": ":param number: nth number to calculate in the sequence\n:return: the nth number in Proth number\nNote: indexing starts at 1 i.e. proth(1) gives the first Proth number of 3\n>>> proth(6)\n25\n>>> proth(0)\nTraceback (most recent call last):\n    ...\nValueError: Input value of [number=0] must be > 0\n>>> proth(-1)\nTraceback (most recent call last):\n    ...\nValueError: Input value of [number=-1] must be > 0\n>>> proth(6.0)\nTraceback (most recent call last):\n    ...\nTypeError: Input value of [number=6.0] must be an integer"
  },
  {
    "function": "is_proth_number",
    "code": "def is_proth_number(number: int) -> bool:\n    \"\"\"\n    :param number: positive integer number\n    :return: true if number is a Proth number, false otherwise\n    >>> is_proth_number(1)\n    False\n    >>> is_proth_number(2)\n    False\n    >>> is_proth_number(3)\n    True\n    >>> is_proth_number(4)\n    False\n    >>> is_proth_number(5)\n    True\n    >>> is_proth_number(34)\n    False\n    >>> is_proth_number(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=-1] must be > 0\n    >>> is_proth_number(6.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=6.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        message = f\"Input value of [{number=}] must be an integer\"\n        raise TypeError(message)\n\n    if number <= 0:\n        message = f\"Input value of [{number=}] must be > 0\"\n        raise ValueError(message)\n\n    if number == 1:\n        return False\n\n    number -= 1\n    n = 0\n    while number % 2 == 0:\n        n += 1\n        number //= 2\n    return number < 2**n",
    "docstring": ":param number: positive integer number\n:return: true if number is a Proth number, false otherwise\n>>> is_proth_number(1)\nFalse\n>>> is_proth_number(2)\nFalse\n>>> is_proth_number(3)\nTrue\n>>> is_proth_number(4)\nFalse\n>>> is_proth_number(5)\nTrue\n>>> is_proth_number(34)\nFalse\n>>> is_proth_number(-1)\nTraceback (most recent call last):\n    ...\nValueError: Input value of [number=-1] must be > 0\n>>> is_proth_number(6.0)\nTraceback (most recent call last):\n    ...\nTypeError: Input value of [number=6.0] must be an integer"
  },
  {
    "function": "triangular_number",
    "code": "def triangular_number(position: int) -> int:\n    \"\"\"\n    Generate the triangular number at the specified position.\n\n    Args:\n        position (int): The position of the triangular number to generate.\n\n    Returns:\n        int: The triangular number at the specified position.\n\n    Raises:\n        ValueError: If `position` is negative.\n\n    Examples:\n    >>> triangular_number(1)\n    1\n    >>> triangular_number(3)\n    6\n    >>> triangular_number(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: param `position` must be non-negative\n    \"\"\"\n    if position < 0:\n        raise ValueError(\"param `position` must be non-negative\")\n\n    return position * (position + 1) // 2",
    "docstring": "Generate the triangular number at the specified position.\n\nArgs:\n    position (int): The position of the triangular number to generate.\n\nReturns:\n    int: The triangular number at the specified position.\n\nRaises:\n    ValueError: If `position` is negative.\n\nExamples:\n>>> triangular_number(1)\n1\n>>> triangular_number(3)\n6\n>>> triangular_number(-1)\nTraceback (most recent call last):\n    ...\nValueError: param `position` must be non-negative"
  },
  {
    "function": "ugly_numbers",
    "code": "def ugly_numbers(n: int) -> int:\n    \"\"\"\n    Returns the nth ugly number.\n    >>> ugly_numbers(100)\n    1536\n    >>> ugly_numbers(0)\n    1\n    >>> ugly_numbers(20)\n    36\n    >>> ugly_numbers(-5)\n    1\n    >>> ugly_numbers(-5.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    \"\"\"\n    ugly_nums = [1]\n\n    i2, i3, i5 = 0, 0, 0\n    next_2 = ugly_nums[i2] * 2\n    next_3 = ugly_nums[i3] * 3\n    next_5 = ugly_nums[i5] * 5\n\n    for _ in range(1, n):\n        next_num = min(next_2, next_3, next_5)\n        ugly_nums.append(next_num)\n        if next_num == next_2:\n            i2 += 1\n            next_2 = ugly_nums[i2] * 2\n        if next_num == next_3:\n            i3 += 1\n            next_3 = ugly_nums[i3] * 3\n        if next_num == next_5:\n            i5 += 1\n            next_5 = ugly_nums[i5] * 5\n    return ugly_nums[-1]",
    "docstring": "Returns the nth ugly number.\n>>> ugly_numbers(100)\n1536\n>>> ugly_numbers(0)\n1\n>>> ugly_numbers(20)\n36\n>>> ugly_numbers(-5)\n1\n>>> ugly_numbers(-5.5)\nTraceback (most recent call last):\n    ...\nTypeError: 'float' object cannot be interpreted as an integer"
  },
  {
    "function": "factors",
    "code": "def factors(number: int) -> list[int]:\n    \"\"\"\n    >>> factors(12)\n    [1, 2, 3, 4, 6]\n    >>> factors(1)\n    [1]\n    >>> factors(100)\n    [1, 2, 4, 5, 10, 20, 25, 50]\n\n    # >>> factors(-12)\n    # [1, 2, 3, 4, 6]\n    \"\"\"\n\n    values = [1]\n    for i in range(2, int(sqrt(number)) + 1, 1):\n        if number % i == 0:\n            values.append(i)\n            if int(number // i) != i:\n                values.append(int(number // i))\n    return sorted(values)",
    "docstring": ">>> factors(12)\n[1, 2, 3, 4, 6]\n>>> factors(1)\n[1]\n>>> factors(100)\n[1, 2, 4, 5, 10, 20, 25, 50]\n\n# >>> factors(-12)\n# [1, 2, 3, 4, 6]"
  },
  {
    "function": "abundant",
    "code": "def abundant(n: int) -> bool:\n    \"\"\"\n    >>> abundant(0)\n    True\n    >>> abundant(1)\n    False\n    >>> abundant(12)\n    True\n    >>> abundant(13)\n    False\n    >>> abundant(20)\n    True\n\n    # >>> abundant(-12)\n    # True\n    \"\"\"\n    return sum(factors(n)) > n",
    "docstring": ">>> abundant(0)\nTrue\n>>> abundant(1)\nFalse\n>>> abundant(12)\nTrue\n>>> abundant(13)\nFalse\n>>> abundant(20)\nTrue\n\n# >>> abundant(-12)\n# True"
  },
  {
    "function": "semi_perfect",
    "code": "def semi_perfect(number: int) -> bool:\n    \"\"\"\n    >>> semi_perfect(0)\n    True\n    >>> semi_perfect(1)\n    True\n    >>> semi_perfect(12)\n    True\n    >>> semi_perfect(13)\n    False\n\n    # >>> semi_perfect(-12)\n    # True\n    \"\"\"\n    values = factors(number)\n    r = len(values)\n    subset = [[0 for i in range(number + 1)] for j in range(r + 1)]\n    for i in range(r + 1):\n        subset[i][0] = True\n\n    for i in range(1, number + 1):\n        subset[0][i] = False\n\n    for i in range(1, r + 1):\n        for j in range(1, number + 1):\n            if j < values[i - 1]:\n                subset[i][j] = subset[i - 1][j]\n            else:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - values[i - 1]]\n\n    return subset[r][number] != 0",
    "docstring": ">>> semi_perfect(0)\nTrue\n>>> semi_perfect(1)\nTrue\n>>> semi_perfect(12)\nTrue\n>>> semi_perfect(13)\nFalse\n\n# >>> semi_perfect(-12)\n# True"
  },
  {
    "function": "weird",
    "code": "def weird(number: int) -> bool:\n    \"\"\"\n    >>> weird(0)\n    False\n    >>> weird(70)\n    True\n    >>> weird(77)\n    False\n    \"\"\"\n    return abundant(number) and not semi_perfect(number)",
    "docstring": ">>> weird(0)\nFalse\n>>> weird(70)\nTrue\n>>> weird(77)\nFalse"
  },
  {
    "function": "binary_search",
    "code": "def binary_search(array: list, lower_bound: int, upper_bound: int, value: int) -> int:\n    \"\"\"\n    This function carries out Binary search on a 1d array and\n    return -1 if it do not exist\n    array: A 1d sorted array\n    value : the value meant to be searched\n    >>> matrix = [1, 4, 7, 11, 15]\n    >>> binary_search(matrix, 0, len(matrix) - 1, 1)\n    0\n    >>> binary_search(matrix, 0, len(matrix) - 1, 23)\n    -1\n    \"\"\"\n\n    r = int((lower_bound + upper_bound) // 2)\n    if array[r] == value:\n        return r\n    if lower_bound >= upper_bound:\n        return -1\n    if array[r] < value:\n        return binary_search(array, r + 1, upper_bound, value)\n    else:\n        return binary_search(array, lower_bound, r - 1, value)",
    "docstring": "This function carries out Binary search on a 1d array and\nreturn -1 if it do not exist\narray: A 1d sorted array\nvalue : the value meant to be searched\n>>> matrix = [1, 4, 7, 11, 15]\n>>> binary_search(matrix, 0, len(matrix) - 1, 1)\n0\n>>> binary_search(matrix, 0, len(matrix) - 1, 23)\n-1"
  },
  {
    "function": "mat_bin_search",
    "code": "def mat_bin_search(value: int, matrix: list) -> list:\n    \"\"\"\n    This function loops over a 2d matrix and calls binarySearch on\n    the selected 1d array and returns [-1, -1] is it do not exist\n    value : value meant to be searched\n    matrix = a sorted 2d matrix\n    >>> matrix = [[1, 4, 7, 11, 15],\n    ...           [2, 5, 8, 12, 19],\n    ...           [3, 6, 9, 16, 22],\n    ...           [10, 13, 14, 17, 24],\n    ...           [18, 21, 23, 26, 30]]\n    >>> target = 1\n    >>> mat_bin_search(target, matrix)\n    [0, 0]\n    >>> target = 34\n    >>> mat_bin_search(target, matrix)\n    [-1, -1]\n    \"\"\"\n    index = 0\n    if matrix[index][0] == value:\n        return [index, 0]\n    while index < len(matrix) and matrix[index][0] < value:\n        r = binary_search(matrix[index], 0, len(matrix[index]) - 1, value)\n        if r != -1:\n            return [index, r]\n        index += 1\n    return [-1, -1]",
    "docstring": "This function loops over a 2d matrix and calls binarySearch on\nthe selected 1d array and returns [-1, -1] is it do not exist\nvalue : value meant to be searched\nmatrix = a sorted 2d matrix\n>>> matrix = [[1, 4, 7, 11, 15],\n...           [2, 5, 8, 12, 19],\n...           [3, 6, 9, 16, 22],\n...           [10, 13, 14, 17, 24],\n...           [18, 21, 23, 26, 30]]\n>>> target = 1\n>>> mat_bin_search(target, matrix)\n[0, 0]\n>>> target = 34\n>>> mat_bin_search(target, matrix)\n[-1, -1]"
  },
  {
    "function": "generate_large_matrix",
    "code": "def generate_large_matrix() -> list[list[int]]:\n    \"\"\"\n    >>> generate_large_matrix() # doctest: +ELLIPSIS\n    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]\n    \"\"\"\n    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]",
    "docstring": ">>> generate_large_matrix() # doctest: +ELLIPSIS\n[[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]"
  },
  {
    "function": "validate_grid",
    "code": "def validate_grid(grid: list[list[int]]) -> None:\n    \"\"\"\n    Validate that the rows and columns of the grid is sorted in decreasing order.\n    >>> for grid in test_grids:\n    ...     validate_grid(grid)\n    \"\"\"\n    assert all(row == sorted(row, reverse=True) for row in grid)\n    assert all(list(col) == sorted(col, reverse=True) for col in zip(*grid))",
    "docstring": "Validate that the rows and columns of the grid is sorted in decreasing order.\n>>> for grid in test_grids:\n...     validate_grid(grid)"
  },
  {
    "function": "find_negative_index",
    "code": "def find_negative_index(array: list[int]) -> int:\n    \"\"\"\n    Find the smallest negative index\n\n    >>> find_negative_index([0,0,0,0])\n    4\n    >>> find_negative_index([4,3,2,-1])\n    3\n    >>> find_negative_index([1,0,-1,-10])\n    2\n    >>> find_negative_index([0,0,0,-1])\n    3\n    >>> find_negative_index([11,8,7,-3,-5,-9])\n    3\n    >>> find_negative_index([-1,-1,-2,-3])\n    0\n    >>> find_negative_index([5,1,0])\n    3\n    >>> find_negative_index([-5,-5,-5])\n    0\n    >>> find_negative_index([0])\n    1\n    >>> find_negative_index([])\n    0\n    \"\"\"\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)",
    "docstring": "Find the smallest negative index\n\n>>> find_negative_index([0,0,0,0])\n4\n>>> find_negative_index([4,3,2,-1])\n3\n>>> find_negative_index([1,0,-1,-10])\n2\n>>> find_negative_index([0,0,0,-1])\n3\n>>> find_negative_index([11,8,7,-3,-5,-9])\n3\n>>> find_negative_index([-1,-1,-2,-3])\n0\n>>> find_negative_index([5,1,0])\n3\n>>> find_negative_index([-5,-5,-5])\n0\n>>> find_negative_index([0])\n1\n>>> find_negative_index([])\n0"
  },
  {
    "function": "count_negatives_binary_search",
    "code": "def count_negatives_binary_search(grid: list[list[int]]) -> int:\n    \"\"\"\n    An O(m logn) solution that uses binary search in order to find the boundary between\n    positive and negative numbers\n\n    >>> [count_negatives_binary_search(grid) for grid in test_grids]\n    [8, 0, 0, 3, 1498500]\n    \"\"\"\n    total = 0\n    bound = len(grid[0])\n\n    for i in range(len(grid)):\n        bound = find_negative_index(grid[i][:bound])\n        total += bound\n    return (len(grid) * len(grid[0])) - total",
    "docstring": "An O(m logn) solution that uses binary search in order to find the boundary between\npositive and negative numbers\n\n>>> [count_negatives_binary_search(grid) for grid in test_grids]\n[8, 0, 0, 3, 1498500]"
  },
  {
    "function": "count_negatives_brute_force",
    "code": "def count_negatives_brute_force(grid: list[list[int]]) -> int:\n    \"\"\"\n    This solution is O(n^2) because it iterates through every column and row.\n\n    >>> [count_negatives_brute_force(grid) for grid in test_grids]\n    [8, 0, 0, 3, 1498500]\n    \"\"\"\n    return len([number for row in grid for number in row if number < 0])",
    "docstring": "This solution is O(n^2) because it iterates through every column and row.\n\n>>> [count_negatives_brute_force(grid) for grid in test_grids]\n[8, 0, 0, 3, 1498500]"
  },
  {
    "function": "count_negatives_brute_force_with_break",
    "code": "def count_negatives_brute_force_with_break(grid: list[list[int]]) -> int:\n    \"\"\"\n    Similar to the brute force solution above but uses break in order to reduce the\n    number of iterations.\n\n    >>> [count_negatives_brute_force_with_break(grid) for grid in test_grids]\n    [8, 0, 0, 3, 1498500]\n    \"\"\"\n    total = 0\n    for row in grid:\n        for i, number in enumerate(row):\n            if number < 0:\n                total += len(row) - i\n                break\n    return total",
    "docstring": "Similar to the brute force solution above but uses break in order to reduce the\nnumber of iterations.\n\n>>> [count_negatives_brute_force_with_break(grid) for grid in test_grids]\n[8, 0, 0, 3, 1498500]"
  },
  {
    "function": "benchmark",
    "code": "def benchmark() -> None:\n    \"\"\"Benchmark our functions next to each other\"\"\"\n    from timeit import timeit\n\n    print(\"Running benchmarks\")\n    setup = (\n        \"from __main__ import count_negatives_binary_search, \"\n        \"count_negatives_brute_force, count_negatives_brute_force_with_break, grid\"\n    )\n    for func in (\n        \"count_negatives_binary_search\",  # took 0.7727 seconds\n        \"count_negatives_brute_force_with_break\",  # took 4.6505 seconds\n        \"count_negatives_brute_force\",  # took 12.8160 seconds\n    ):\n        time = timeit(f\"{func}(grid=grid)\", setup=setup, number=500)\n        print(f\"{func}() took {time:0.4f} seconds\")",
    "docstring": "Benchmark our functions next to each other"
  },
  {
    "function": "depth_first_search",
    "code": "def depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:\n    \"\"\"\n    Recursive Backtracking Depth First Search Algorithm\n\n    Starting from top left of a matrix, count the number of\n    paths that can reach the bottom right of a matrix.\n    1 represents a block (inaccessible)\n    0 represents a valid space (accessible)\n\n    0  0  0  0\n    1  1  0  0\n    0  0  0  1\n    0  1  0  0\n    >>> grid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n\n    0  0  0  0  0\n    0  1  1  1  0\n    0  1  1  1  0\n    0  0  0  0  0\n    >>> grid = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n    \"\"\"\n    row_length, col_length = len(grid), len(grid[0])\n    if (\n        min(row, col) < 0\n        or row == row_length\n        or col == col_length\n        or (row, col) in visit\n        or grid[row][col] == 1\n    ):\n        return 0\n    if row == row_length - 1 and col == col_length - 1:\n        return 1\n\n    visit.add((row, col))\n\n    count = 0\n    count += depth_first_search(grid, row + 1, col, visit)\n    count += depth_first_search(grid, row - 1, col, visit)\n    count += depth_first_search(grid, row, col + 1, visit)\n    count += depth_first_search(grid, row, col - 1, visit)\n\n    visit.remove((row, col))\n    return count",
    "docstring": "Recursive Backtracking Depth First Search Algorithm\n\nStarting from top left of a matrix, count the number of\npaths that can reach the bottom right of a matrix.\n1 represents a block (inaccessible)\n0 represents a valid space (accessible)\n\n0  0  0  0\n1  1  0  0\n0  0  0  1\n0  1  0  0\n>>> grid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]\n>>> depth_first_search(grid, 0, 0, set())\n2\n\n0  0  0  0  0\n0  1  1  1  0\n0  1  1  1  0\n0  0  0  0  0\n>>> grid = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]\n>>> depth_first_search(grid, 0, 0, set())\n2"
  },
  {
    "function": "cramers_rule_2x2",
    "code": "def cramers_rule_2x2(equation1: list[int], equation2: list[int]) -> tuple[float, float]:\n    \"\"\"\n    Solves the system of linear equation in 2 variables.\n    :param: equation1: list of 3 numbers\n    :param: equation2: list of 3 numbers\n    :return: String of result\n    input format : [a1, b1, d1], [a2, b2, d2]\n    determinant = [[a1, b1], [a2, b2]]\n    determinant_x = [[d1, b1], [d2, b2]]\n    determinant_y = [[a1, d1], [a2, d2]]\n\n    >>> cramers_rule_2x2([2, 3, 0], [5, 1, 0])\n    (0.0, 0.0)\n    >>> cramers_rule_2x2([0, 4, 50], [2, 0, 26])\n    (13.0, 12.5)\n    >>> cramers_rule_2x2([11, 2, 30], [1, 0, 4])\n    (4.0, -7.0)\n    >>> cramers_rule_2x2([4, 7, 1], [1, 2, 0])\n    (2.0, -1.0)\n\n    >>> cramers_rule_2x2([1, 2, 3], [2, 4, 6])\n    Traceback (most recent call last):\n        ...\n    ValueError: Infinite solutions. (Consistent system)\n    >>> cramers_rule_2x2([1, 2, 3], [2, 4, 7])\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution. (Inconsistent system)\n    >>> cramers_rule_2x2([1, 2, 3], [11, 22])\n    Traceback (most recent call last):\n        ...\n    ValueError: Please enter a valid equation.\n    >>> cramers_rule_2x2([0, 1, 6], [0, 0, 3])\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution. (Inconsistent system)\n    >>> cramers_rule_2x2([0, 0, 6], [0, 0, 3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Both a & b of two equations can't be zero.\n    >>> cramers_rule_2x2([1, 2, 3], [1, 2, 3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Infinite solutions. (Consistent system)\n    >>> cramers_rule_2x2([0, 4, 50], [0, 3, 99])\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution. (Inconsistent system)\n    \"\"\"\n\n    # Check if the input is valid\n    if not len(equation1) == len(equation2) == 3:\n        raise ValueError(\"Please enter a valid equation.\")\n    if equation1[0] == equation1[1] == equation2[0] == equation2[1] == 0:\n        raise ValueError(\"Both a & b of two equations can't be zero.\")\n\n    # Extract the coefficients\n    a1, b1, c1 = equation1\n    a2, b2, c2 = equation2\n\n    # Calculate the determinants of the matrices\n    determinant = a1 * b2 - a2 * b1\n    determinant_x = c1 * b2 - c2 * b1\n    determinant_y = a1 * c2 - a2 * c1\n\n    # Check if the system of linear equations has a solution (using Cramer's rule)\n    if determinant == 0:\n        if determinant_x == determinant_y == 0:\n            raise ValueError(\"Infinite solutions. (Consistent system)\")\n        else:\n            raise ValueError(\"No solution. (Inconsistent system)\")\n    elif determinant_x == determinant_y == 0:\n        # Trivial solution (Inconsistent system)\n        return (0.0, 0.0)\n    else:\n        x = determinant_x / determinant\n        y = determinant_y / determinant\n        # Non-Trivial Solution (Consistent system)\n        return (x, y)",
    "docstring": "Solves the system of linear equation in 2 variables.\n:param: equation1: list of 3 numbers\n:param: equation2: list of 3 numbers\n:return: String of result\ninput format : [a1, b1, d1], [a2, b2, d2]\ndeterminant = [[a1, b1], [a2, b2]]\ndeterminant_x = [[d1, b1], [d2, b2]]\ndeterminant_y = [[a1, d1], [a2, d2]]\n\n>>> cramers_rule_2x2([2, 3, 0], [5, 1, 0])\n(0.0, 0.0)\n>>> cramers_rule_2x2([0, 4, 50], [2, 0, 26])\n(13.0, 12.5)\n>>> cramers_rule_2x2([11, 2, 30], [1, 0, 4])\n(4.0, -7.0)\n>>> cramers_rule_2x2([4, 7, 1], [1, 2, 0])\n(2.0, -1.0)\n\n>>> cramers_rule_2x2([1, 2, 3], [2, 4, 6])\nTraceback (most recent call last):\n    ...\nValueError: Infinite solutions. (Consistent system)\n>>> cramers_rule_2x2([1, 2, 3], [2, 4, 7])\nTraceback (most recent call last):\n    ...\nValueError: No solution. (Inconsistent system)\n>>> cramers_rule_2x2([1, 2, 3], [11, 22])\nTraceback (most recent call last):\n    ...\nValueError: Please enter a valid equation.\n>>> cramers_rule_2x2([0, 1, 6], [0, 0, 3])\nTraceback (most recent call last):\n    ...\nValueError: No solution. (Inconsistent system)\n>>> cramers_rule_2x2([0, 0, 6], [0, 0, 3])\nTraceback (most recent call last):\n    ...\nValueError: Both a & b of two equations can't be zero.\n>>> cramers_rule_2x2([1, 2, 3], [1, 2, 3])\nTraceback (most recent call last):\n    ...\nValueError: Infinite solutions. (Consistent system)\n>>> cramers_rule_2x2([0, 4, 50], [0, 3, 99])\nTraceback (most recent call last):\n    ...\nValueError: No solution. (Inconsistent system)"
  },
  {
    "function": "inverse_of_matrix",
    "code": "def inverse_of_matrix(matrix: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    A matrix multiplied with its inverse gives the identity matrix.\n    This function finds the inverse of a 2x2 and 3x3 matrix.\n    If the determinant of a matrix is 0, its inverse does not exist.\n\n    Sources for fixing inaccurate float arithmetic:\n    https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python\n    https://docs.python.org/3/library/decimal.html\n\n    Doctests for 2x2\n    >>> inverse_of_matrix([[2, 5], [2, 0]])\n    [[0.0, 0.5], [0.2, -0.2]]\n    >>> inverse_of_matrix([[2.5, 5], [1, 2]])\n    Traceback (most recent call last):\n        ...\n    ValueError: This matrix has no inverse.\n    >>> inverse_of_matrix([[12, -16], [-9, 0]])\n    [[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]\n    >>> inverse_of_matrix([[12, 3], [16, 8]])\n    [[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]\n    >>> inverse_of_matrix([[10, 5], [3, 2.5]])\n    [[0.25, -0.5], [-0.3, 1.0]]\n\n    Doctests for 3x3\n    >>> inverse_of_matrix([[2, 5, 7], [2, 0, 1], [1, 2, 3]])\n    [[2.0, 5.0, -4.0], [1.0, 1.0, -1.0], [-5.0, -12.0, 10.0]]\n    >>> inverse_of_matrix([[1, 2, 2], [1, 2, 2], [3, 2, -1]])\n    Traceback (most recent call last):\n        ...\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[],[]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2], [3, 4], [5, 6]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 1], [0,3, 4]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 3], [7, 8, 9], [7, 8, 9]])\n    Traceback (most recent call last):\n        ...\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    \"\"\"\n\n    d = Decimal\n\n    # Check if the provided matrix has 2 rows and 2 columns\n    # since this implementation only works for 2x2 matrices\n    if len(matrix) == 2 and len(matrix[0]) == 2 and len(matrix[1]) == 2:\n        # Calculate the determinant of the matrix\n        determinant = float(\n            d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[1][0]) * d(matrix[0][1])\n        )\n        if determinant == 0:\n            raise ValueError(\"This matrix has no inverse.\")\n\n        # Creates a copy of the matrix with swapped positions of the elements\n        swapped_matrix = [[0.0, 0.0], [0.0, 0.0]]\n        swapped_matrix[0][0], swapped_matrix[1][1] = matrix[1][1], matrix[0][0]\n        swapped_matrix[1][0], swapped_matrix[0][1] = -matrix[1][0], -matrix[0][1]\n\n        # Calculate the inverse of the matrix\n        return [\n            [(float(d(n)) / determinant) or 0.0 for n in row] for row in swapped_matrix\n        ]\n    elif (\n        len(matrix) == 3\n        and len(matrix[0]) == 3\n        and len(matrix[1]) == 3\n        and len(matrix[2]) == 3\n    ):\n        # Calculate the determinant of the matrix using Sarrus rule\n        determinant = float(\n            (\n                (d(matrix[0][0]) * d(matrix[1][1]) * d(matrix[2][2]))\n                + (d(matrix[0][1]) * d(matrix[1][2]) * d(matrix[2][0]))\n                + (d(matrix[0][2]) * d(matrix[1][0]) * d(matrix[2][1]))\n            )\n            - (\n                (d(matrix[0][2]) * d(matrix[1][1]) * d(matrix[2][0]))\n                + (d(matrix[0][1]) * d(matrix[1][0]) * d(matrix[2][2]))\n                + (d(matrix[0][0]) * d(matrix[1][2]) * d(matrix[2][1]))\n            )\n        )\n        if determinant == 0:\n            raise ValueError(\"This matrix has no inverse.\")\n\n        # Creating cofactor matrix\n        cofactor_matrix = [\n            [d(0.0), d(0.0), d(0.0)],\n            [d(0.0), d(0.0), d(0.0)],\n            [d(0.0), d(0.0), d(0.0)],\n        ]\n        cofactor_matrix[0][0] = (d(matrix[1][1]) * d(matrix[2][2])) - (\n            d(matrix[1][2]) * d(matrix[2][1])\n        )\n        cofactor_matrix[0][1] = -(\n            (d(matrix[1][0]) * d(matrix[2][2])) - (d(matrix[1][2]) * d(matrix[2][0]))\n        )\n        cofactor_matrix[0][2] = (d(matrix[1][0]) * d(matrix[2][1])) - (\n            d(matrix[1][1]) * d(matrix[2][0])\n        )\n        cofactor_matrix[1][0] = -(\n            (d(matrix[0][1]) * d(matrix[2][2])) - (d(matrix[0][2]) * d(matrix[2][1]))\n        )\n        cofactor_matrix[1][1] = (d(matrix[0][0]) * d(matrix[2][2])) - (\n            d(matrix[0][2]) * d(matrix[2][0])\n        )\n        cofactor_matrix[1][2] = -(\n            (d(matrix[0][0]) * d(matrix[2][1])) - (d(matrix[0][1]) * d(matrix[2][0]))\n        )\n        cofactor_matrix[2][0] = (d(matrix[0][1]) * d(matrix[1][2])) - (\n            d(matrix[0][2]) * d(matrix[1][1])\n        )\n        cofactor_matrix[2][1] = -(\n            (d(matrix[0][0]) * d(matrix[1][2])) - (d(matrix[0][2]) * d(matrix[1][0]))\n        )\n        cofactor_matrix[2][2] = (d(matrix[0][0]) * d(matrix[1][1])) - (\n            d(matrix[0][1]) * d(matrix[1][0])\n        )\n\n        # Transpose the cofactor matrix (Adjoint matrix)\n        adjoint_matrix = array(cofactor_matrix)\n        for i in range(3):\n            for j in range(3):\n                adjoint_matrix[i][j] = cofactor_matrix[j][i]\n\n        # Inverse of the matrix using the formula (1/determinant) * adjoint matrix\n        inverse_matrix = array(cofactor_matrix)\n        for i in range(3):\n            for j in range(3):\n                inverse_matrix[i][j] /= d(determinant)\n\n        # Calculate the inverse of the matrix\n        return [[float(d(n)) or 0.0 for n in row] for row in inverse_matrix]\n    raise ValueError(\"Please provide a matrix of size 2x2 or 3x3.\")",
    "docstring": "A matrix multiplied with its inverse gives the identity matrix.\nThis function finds the inverse of a 2x2 and 3x3 matrix.\nIf the determinant of a matrix is 0, its inverse does not exist.\n\nSources for fixing inaccurate float arithmetic:\nhttps://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python\nhttps://docs.python.org/3/library/decimal.html\n\nDoctests for 2x2\n>>> inverse_of_matrix([[2, 5], [2, 0]])\n[[0.0, 0.5], [0.2, -0.2]]\n>>> inverse_of_matrix([[2.5, 5], [1, 2]])\nTraceback (most recent call last):\n    ...\nValueError: This matrix has no inverse.\n>>> inverse_of_matrix([[12, -16], [-9, 0]])\n[[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]\n>>> inverse_of_matrix([[12, 3], [16, 8]])\n[[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]\n>>> inverse_of_matrix([[10, 5], [3, 2.5]])\n[[0.25, -0.5], [-0.3, 1.0]]\n\nDoctests for 3x3\n>>> inverse_of_matrix([[2, 5, 7], [2, 0, 1], [1, 2, 3]])\n[[2.0, 5.0, -4.0], [1.0, 1.0, -1.0], [-5.0, -12.0, 10.0]]\n>>> inverse_of_matrix([[1, 2, 2], [1, 2, 2], [3, 2, -1]])\nTraceback (most recent call last):\n    ...\nValueError: This matrix has no inverse.\n\n>>> inverse_of_matrix([[],[]])\nTraceback (most recent call last):\n    ...\nValueError: Please provide a matrix of size 2x2 or 3x3.\n\n>>> inverse_of_matrix([[1, 2], [3, 4], [5, 6]])\nTraceback (most recent call last):\n    ...\nValueError: Please provide a matrix of size 2x2 or 3x3.\n\n>>> inverse_of_matrix([[1, 2, 1], [0,3, 4]])\nTraceback (most recent call last):\n    ...\nValueError: Please provide a matrix of size 2x2 or 3x3.\n\n>>> inverse_of_matrix([[1, 2, 3], [7, 8, 9], [7, 8, 9]])\nTraceback (most recent call last):\n    ...\nValueError: This matrix has no inverse.\n\n>>> inverse_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]"
  },
  {
    "function": "largest_square_area_in_matrix_top_down_approch",
    "code": "def largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We aren't using dp_array here, so the time complexity would be exponential.\n\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]",
    "docstring": "Function updates the largest_square_area[0], if recursive call found\nsquare with maximum area.\n\nWe aren't using dp_array here, so the time complexity would be exponential.\n\n>>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])\n2\n>>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])\n0"
  },
  {
    "function": "largest_square_area_in_matrix_top_down_approch_with_dp",
    "code": "def largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]",
    "docstring": "Function updates the largest_square_area[0], if recursive call found\nsquare with maximum area.\n\nWe are using dp_array here, so the time complexity would be O(N^2).\n\n>>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n2\n>>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n0"
  },
  {
    "function": "largest_square_area_in_matrix_bottom_up",
    "code": "def largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up approach.\n\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n    0\n\n    \"\"\"\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area",
    "docstring": "Function updates the largest_square_area, using bottom up approach.\n\n>>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n2\n>>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n0"
  },
  {
    "function": "largest_square_area_in_matrix_bottom_up_space_optimization",
    "code": "def largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area",
    "docstring": "Function updates the largest_square_area, using bottom up\napproach. with space optimization.\n\n>>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n2\n>>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n0"
  },
  {
    "function": "validate_matrix_size",
    "code": "def validate_matrix_size(size: int) -> None:\n    \"\"\"\n    >>> validate_matrix_size(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Matrix size must be a positive integer.\n    \"\"\"\n    if not isinstance(size, int) or size <= 0:\n        raise ValueError(\"Matrix size must be a positive integer.\")",
    "docstring": ">>> validate_matrix_size(-1)\nTraceback (most recent call last):\n    ...\nValueError: Matrix size must be a positive integer."
  },
  {
    "function": "validate_matrix_content",
    "code": "def validate_matrix_content(matrix: list[str], size: int) -> None:\n    \"\"\"\n    Validates that the number of elements in the matrix matches the given size.\n\n    >>> validate_matrix_content(['aaaa', 'aaaa', 'aaaa', 'aaaa'], 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: The matrix dont match with size.\n    >>> validate_matrix_content(['aa%', 'aaa', 'aaa'], 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Matrix rows can only contain letters and numbers.\n    >>> validate_matrix_content(['aaa', 'aaa', 'aaaa'], 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Each row in the matrix must have exactly 3 characters.\n    \"\"\"\n    print(matrix)\n    if len(matrix) != size:\n        raise ValueError(\"The matrix dont match with size.\")\n    for row in matrix:\n        if len(row) != size:\n            msg = f\"Each row in the matrix must have exactly {size} characters.\"\n            raise ValueError(msg)\n        if not all(char.isalnum() for char in row):\n            raise ValueError(\"Matrix rows can only contain letters and numbers.\")",
    "docstring": "Validates that the number of elements in the matrix matches the given size.\n\n>>> validate_matrix_content(['aaaa', 'aaaa', 'aaaa', 'aaaa'], 3)\nTraceback (most recent call last):\n    ...\nValueError: The matrix dont match with size.\n>>> validate_matrix_content(['aa%', 'aaa', 'aaa'], 3)\nTraceback (most recent call last):\n    ...\nValueError: Matrix rows can only contain letters and numbers.\n>>> validate_matrix_content(['aaa', 'aaa', 'aaaa'], 3)\nTraceback (most recent call last):\n    ...\nValueError: Each row in the matrix must have exactly 3 characters."
  },
  {
    "function": "validate_moves",
    "code": "def validate_moves(moves: list[tuple[int, int]], size: int) -> None:\n    \"\"\"\n    >>> validate_moves([(1, 2), (-1, 0)], 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Move is out of bounds for a matrix.\n    \"\"\"\n    for move in moves:\n        x, y = move\n        if not (0 <= x < size and 0 <= y < size):\n            raise ValueError(\"Move is out of bounds for a matrix.\")",
    "docstring": ">>> validate_moves([(1, 2), (-1, 0)], 3)\nTraceback (most recent call last):\n    ...\nValueError: Move is out of bounds for a matrix."
  },
  {
    "function": "parse_moves",
    "code": "def parse_moves(input_str: str) -> list[tuple[int, int]]:\n    \"\"\"\n    >>> parse_moves(\"0 1, 1 1\")\n    [(0, 1), (1, 1)]\n    >>> parse_moves(\"0 1, 1 1, 2\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Each move must have exactly two numbers.\n    >>> parse_moves(\"0 1, 1 1, 2 4 5 6\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Each move must have exactly two numbers.\n    \"\"\"\n    moves = []\n    for pair in input_str.split(\",\"):\n        parts = pair.strip().split()\n        if len(parts) != 2:\n            raise ValueError(\"Each move must have exactly two numbers.\")\n        x, y = map(int, parts)\n        moves.append((x, y))\n    return moves",
    "docstring": ">>> parse_moves(\"0 1, 1 1\")\n[(0, 1), (1, 1)]\n>>> parse_moves(\"0 1, 1 1, 2\")\nTraceback (most recent call last):\n    ...\nValueError: Each move must have exactly two numbers.\n>>> parse_moves(\"0 1, 1 1, 2 4 5 6\")\nTraceback (most recent call last):\n    ...\nValueError: Each move must have exactly two numbers."
  },
  {
    "function": "find_repeat",
    "code": "def find_repeat(\n    matrix_g: list[list[str]], row: int, column: int, size: int\n) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all connected elements of the same type from a given position.\n\n    >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)\n    {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}\n    >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)\n    set()\n    \"\"\"\n\n    column = size - 1 - column\n    visited = set()\n    repeated = set()\n\n    if (color := matrix_g[column][row]) != \"-\":\n\n        def dfs(row_n: int, column_n: int) -> None:\n            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:\n                return\n            if (row_n, column_n) in visited:\n                return\n            visited.add((row_n, column_n))\n            if matrix_g[row_n][column_n] == color:\n                repeated.add((row_n, column_n))\n                dfs(row_n - 1, column_n)\n                dfs(row_n + 1, column_n)\n                dfs(row_n, column_n - 1)\n                dfs(row_n, column_n + 1)\n\n        dfs(column, row)\n\n    return repeated",
    "docstring": "Finds all connected elements of the same type from a given position.\n\n>>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)\n{(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}\n>>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)\nset()"
  },
  {
    "function": "increment_score",
    "code": "def increment_score(count: int) -> int:\n    \"\"\"\n    Calculates the score for a move based on the number of elements removed.\n\n    >>> increment_score(3)\n    6\n    >>> increment_score(0)\n    0\n    \"\"\"\n    return int(count * (count + 1) / 2)",
    "docstring": "Calculates the score for a move based on the number of elements removed.\n\n>>> increment_score(3)\n6\n>>> increment_score(0)\n0"
  },
  {
    "function": "move_x",
    "code": "def move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n    \"\"\"\n    Simulates gravity in a specific column.\n\n    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n    [['-', '-'], ['-', 'A'], ['-', 'C']]\n    \"\"\"\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g",
    "docstring": "Simulates gravity in a specific column.\n\n>>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n[['-', '-'], ['-', 'A'], ['-', 'C']]"
  },
  {
    "function": "move_y",
    "code": "def move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:\n    \"\"\"\n    Shifts all columns leftward when an entire column becomes empty.\n\n    >>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2)\n    [['A', '-'], ['-', '-'], ['-', 'C']]\n    \"\"\"\n\n    empty_columns = []\n\n    for column in range(size - 1, -1, -1):\n        if all(matrix_g[row][column] == \"-\" for row in range(size)):\n            empty_columns.append(column)\n\n    for column in empty_columns:\n        for col in range(column + 1, size):\n            for row in range(size):\n                matrix_g[row][col - 1] = matrix_g[row][col]\n        for row in range(size):\n            matrix_g[row][-1] = \"-\"\n\n    return matrix_g",
    "docstring": "Shifts all columns leftward when an entire column becomes empty.\n\n>>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2)\n[['A', '-'], ['-', '-'], ['-', 'C']]"
  },
  {
    "function": "play",
    "code": "def play(\n    matrix_g: list[list[str]], pos_x: int, pos_y: int, size: int\n) -> tuple[list[list[str]], int]:\n    \"\"\"\n    Processes a single move, updating the matrix and calculating the score.\n\n    >>> play([['R', 'G'], ['R', 'G']], 0, 0, 2)\n    ([['G', '-'], ['G', '-']], 3)\n    \"\"\"\n\n    same_colors = find_repeat(matrix_g, pos_x, pos_y, size)\n\n    if len(same_colors) != 0:\n        for pos in same_colors:\n            matrix_g[pos[0]][pos[1]] = \"-\"\n        for column in range(size):\n            matrix_g = move_x(matrix_g, column, size)\n\n        matrix_g = move_y(matrix_g, size)\n\n    return (matrix_g, increment_score(len(same_colors)))",
    "docstring": "Processes a single move, updating the matrix and calculating the score.\n\n>>> play([['R', 'G'], ['R', 'G']], 0, 0, 2)\n([['G', '-'], ['G', '-']], 3)"
  },
  {
    "function": "process_game",
    "code": "def process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:\n    \"\"\"Processes the game logic for the given matrix and moves.\n\n    Args:\n        size (int): Size of the game board.\n        matrix (List[str]): Initial game matrix.\n        moves (List[Tuple[int, int]]): List of moves as (x, y) coordinates.\n\n    Returns:\n        int: The total score obtained.\n    >>> process_game(3, ['aaa', 'bbb', 'ccc'], [(0, 0)])\n    6\n    \"\"\"\n\n    game_matrix = [list(row) for row in matrix]\n    total_score = 0\n\n    for move in moves:\n        pos_x, pos_y = move\n        game_matrix, score = play(game_matrix, pos_x, pos_y, size)\n        total_score += score\n\n    return total_score",
    "docstring": "Processes the game logic for the given matrix and moves.\n\nArgs:\n    size (int): Size of the game board.\n    matrix (List[str]): Initial game matrix.\n    moves (List[Tuple[int, int]]): List of moves as (x, y) coordinates.\n\nReturns:\n    int: The total score obtained.\n>>> process_game(3, ['aaa', 'bbb', 'ccc'], [(0, 0)])\n6"
  },
  {
    "function": "array_equalization",
    "code": "def array_equalization(vector: list[int], step_size: int) -> int:\n    \"\"\"\n    This algorithm equalizes all elements of the input vector\n    to a common value, by making the minimal number of\n    \"updates\" under the constraint of a step size (step_size).\n\n    >>> array_equalization([1, 1, 6, 2, 4, 6, 5, 1, 7, 2, 2, 1, 7, 2, 2], 4)\n    4\n    >>> array_equalization([22, 81, 88, 71, 22, 81, 632, 81, 81, 22, 92], 2)\n    5\n    >>> array_equalization([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5)\n    0\n    >>> array_equalization([22, 22, 22, 33, 33, 33], 2)\n    2\n    >>> array_equalization([1, 2, 3], 0)\n    Traceback (most recent call last):\n    ValueError: Step size must be positive and non-zero.\n    >>> array_equalization([1, 2, 3], -1)\n    Traceback (most recent call last):\n    ValueError: Step size must be positive and non-zero.\n    >>> array_equalization([1, 2, 3], 0.5)\n    Traceback (most recent call last):\n    ValueError: Step size must be an integer.\n    >>> array_equalization([1, 2, 3], maxsize)\n    1\n    \"\"\"\n    if step_size <= 0:\n        raise ValueError(\"Step size must be positive and non-zero.\")\n    if not isinstance(step_size, int):\n        raise ValueError(\"Step size must be an integer.\")\n\n    unique_elements = set(vector)\n    min_updates = maxsize\n\n    for element in unique_elements:\n        elem_index = 0\n        updates = 0\n        while elem_index < len(vector):\n            if vector[elem_index] != element:\n                updates += 1\n                elem_index += step_size\n            else:\n                elem_index += 1\n        min_updates = min(min_updates, updates)\n\n    return min_updates",
    "docstring": "This algorithm equalizes all elements of the input vector\nto a common value, by making the minimal number of\n\"updates\" under the constraint of a step size (step_size).\n\n>>> array_equalization([1, 1, 6, 2, 4, 6, 5, 1, 7, 2, 2, 1, 7, 2, 2], 4)\n4\n>>> array_equalization([22, 81, 88, 71, 22, 81, 632, 81, 81, 22, 92], 2)\n5\n>>> array_equalization([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5)\n0\n>>> array_equalization([22, 22, 22, 33, 33, 33], 2)\n2\n>>> array_equalization([1, 2, 3], 0)\nTraceback (most recent call last):\nValueError: Step size must be positive and non-zero.\n>>> array_equalization([1, 2, 3], -1)\nTraceback (most recent call last):\nValueError: Step size must be positive and non-zero.\n>>> array_equalization([1, 2, 3], 0.5)\nTraceback (most recent call last):\nValueError: Step size must be an integer.\n>>> array_equalization([1, 2, 3], maxsize)\n1"
  },
  {
    "function": "is_square",
    "code": "def is_square(matrix: Matrix) -> bool:\n    \"\"\"\n    >>> is_square([])\n    True\n    >>> is_square(matrix_1_to_4)\n    True\n    >>> is_square(matrix_5_to_9_high)\n    False\n    \"\"\"\n    len_matrix = len(matrix)\n    return all(len(row) == len_matrix for row in matrix)",
    "docstring": ">>> is_square([])\nTrue\n>>> is_square(matrix_1_to_4)\nTrue\n>>> is_square(matrix_5_to_9_high)\nFalse"
  },
  {
    "function": "matrix_multiply",
    "code": "def matrix_multiply(matrix_a: Matrix, matrix_b: Matrix) -> Matrix:\n    \"\"\"\n    >>> matrix_multiply(matrix_1_to_4, matrix_5_to_8)\n    [[19, 22], [43, 50]]\n    \"\"\"\n    return [\n        [sum(a * b for a, b in zip(row, col)) for col in zip(*matrix_b)]\n        for row in matrix_a\n    ]",
    "docstring": ">>> matrix_multiply(matrix_1_to_4, matrix_5_to_8)\n[[19, 22], [43, 50]]"
  },
  {
    "function": "matrix_multiply_recursive",
    "code": "def matrix_multiply_recursive(matrix_a: Matrix, matrix_b: Matrix) -> Matrix:\n    \"\"\"\n    :param matrix_a: A square Matrix.\n    :param matrix_b: Another square Matrix with the same dimensions as matrix_a.\n    :return: Result of matrix_a * matrix_b.\n    :raises ValueError: If the matrices cannot be multiplied.\n\n    >>> matrix_multiply_recursive([], [])\n    []\n    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_8)\n    [[19, 22], [43, 50]]\n    >>> matrix_multiply_recursive(matrix_count_up, matrix_unordered)\n    [[37, 61, 74, 61], [105, 165, 166, 129], [173, 269, 258, 197], [241, 373, 350, 265]]\n    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_wide)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid matrix dimensions\n    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_high)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid matrix dimensions\n    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_count_up)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid matrix dimensions\n    \"\"\"\n    if not matrix_a or not matrix_b:\n        return []\n    if not all(\n        (len(matrix_a) == len(matrix_b), is_square(matrix_a), is_square(matrix_b))\n    ):\n        raise ValueError(\"Invalid matrix dimensions\")\n\n    # Initialize the result matrix with zeros\n    result = [[0] * len(matrix_b[0]) for _ in range(len(matrix_a))]\n\n    # Recursive multiplication of matrices\n    def multiply(\n        i_loop: int,\n        j_loop: int,\n        k_loop: int,\n        matrix_a: Matrix,\n        matrix_b: Matrix,\n        result: Matrix,\n    ) -> None:\n        \"\"\"\n        :param matrix_a: A square Matrix.\n        :param matrix_b: Another square Matrix with the same dimensions as matrix_a.\n        :param result: Result matrix\n        :param i: Index used for iteration during multiplication.\n        :param j: Index used for iteration during multiplication.\n        :param k: Index used for iteration during multiplication.\n        >>> 0 > 1  # Doctests in inner functions are never run\n        True\n        \"\"\"\n        if i_loop >= len(matrix_a):\n            return\n        if j_loop >= len(matrix_b[0]):\n            return multiply(i_loop + 1, 0, 0, matrix_a, matrix_b, result)\n        if k_loop >= len(matrix_b):\n            return multiply(i_loop, j_loop + 1, 0, matrix_a, matrix_b, result)\n        result[i_loop][j_loop] += matrix_a[i_loop][k_loop] * matrix_b[k_loop][j_loop]\n        return multiply(i_loop, j_loop, k_loop + 1, matrix_a, matrix_b, result)\n\n    # Perform the recursive matrix multiplication\n    multiply(0, 0, 0, matrix_a, matrix_b, result)\n    return result",
    "docstring": ":param matrix_a: A square Matrix.\n:param matrix_b: Another square Matrix with the same dimensions as matrix_a.\n:return: Result of matrix_a * matrix_b.\n:raises ValueError: If the matrices cannot be multiplied.\n\n>>> matrix_multiply_recursive([], [])\n[]\n>>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_8)\n[[19, 22], [43, 50]]\n>>> matrix_multiply_recursive(matrix_count_up, matrix_unordered)\n[[37, 61, 74, 61], [105, 165, 166, 129], [173, 269, 258, 197], [241, 373, 350, 265]]\n>>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_wide)\nTraceback (most recent call last):\n    ...\nValueError: Invalid matrix dimensions\n>>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_high)\nTraceback (most recent call last):\n    ...\nValueError: Invalid matrix dimensions\n>>> matrix_multiply_recursive(matrix_1_to_4, matrix_count_up)\nTraceback (most recent call last):\n    ...\nValueError: Invalid matrix dimensions"
  },
  {
    "function": "add",
    "code": "def add(*matrix_s: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> add([[1,2],[3,4]],[[2,3],[4,5]])\n    [[3, 5], [7, 9]]\n    >>> add([[1.2,2.4],[3,4]],[[2,3],[4,5]])\n    [[3.2, 5.4], [7, 9]]\n    >>> add([[1, 2], [4, 5]], [[3, 7], [3, 4]], [[3, 5], [5, 7]])\n    [[7, 14], [12, 16]]\n    >>> add([3], [4, 5])\n    Traceback (most recent call last):\n      ...\n    TypeError: Expected a matrix, got int/list instead\n    \"\"\"\n    if all(_check_not_integer(m) for m in matrix_s):\n        for i in matrix_s[1:]:\n            _verify_matrix_sizes(matrix_s[0], i)\n        return [[sum(t) for t in zip(*m)] for m in zip(*matrix_s)]\n    raise TypeError(\"Expected a matrix, got int/list instead\")",
    "docstring": ">>> add([[1,2],[3,4]],[[2,3],[4,5]])\n[[3, 5], [7, 9]]\n>>> add([[1.2,2.4],[3,4]],[[2,3],[4,5]])\n[[3.2, 5.4], [7, 9]]\n>>> add([[1, 2], [4, 5]], [[3, 7], [3, 4]], [[3, 5], [5, 7]])\n[[7, 14], [12, 16]]\n>>> add([3], [4, 5])\nTraceback (most recent call last):\n  ...\nTypeError: Expected a matrix, got int/list instead"
  },
  {
    "function": "subtract",
    "code": "def subtract(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> subtract([[1,2],[3,4]],[[2,3],[4,5]])\n    [[-1, -1], [-1, -1]]\n    >>> subtract([[1,2.5],[3,4]],[[2,3],[4,5.5]])\n    [[-1, -0.5], [-1, -1.5]]\n    >>> subtract([3], [4, 5])\n    Traceback (most recent call last):\n      ...\n    TypeError: Expected a matrix, got int/list instead\n    \"\"\"\n    if (\n        _check_not_integer(matrix_a)\n        and _check_not_integer(matrix_b)\n        and _verify_matrix_sizes(matrix_a, matrix_b)\n    ):\n        return [[i - j for i, j in zip(*m)] for m in zip(matrix_a, matrix_b)]\n    raise TypeError(\"Expected a matrix, got int/list instead\")",
    "docstring": ">>> subtract([[1,2],[3,4]],[[2,3],[4,5]])\n[[-1, -1], [-1, -1]]\n>>> subtract([[1,2.5],[3,4]],[[2,3],[4,5.5]])\n[[-1, -0.5], [-1, -1.5]]\n>>> subtract([3], [4, 5])\nTraceback (most recent call last):\n  ...\nTypeError: Expected a matrix, got int/list instead"
  },
  {
    "function": "scalar_multiply",
    "code": "def scalar_multiply(matrix: list[list[int]], n: float) -> list[list[float]]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]",
    "docstring": ">>> scalar_multiply([[1,2],[3,4]],5)\n[[5, 10], [15, 20]]\n>>> scalar_multiply([[1.4,2.3],[3,4]],5)\n[[7.0, 11.5], [15, 20]]"
  },
  {
    "function": "multiply",
    "code": "def multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> multiply([[1,2],[3,4]],[[5,5],[7,5]])\n    [[19, 15], [43, 35]]\n    >>> multiply([[1,2.5],[3,4.5]],[[5,5],[7,5]])\n    [[22.5, 17.5], [46.5, 37.5]]\n    >>> multiply([[1, 2, 3]], [[2], [3], [4]])\n    [[20]]\n    \"\"\"\n    if _check_not_integer(matrix_a) and _check_not_integer(matrix_b):\n        rows, cols = _verify_matrix_sizes(matrix_a, matrix_b)\n\n    if cols[0] != rows[1]:\n        msg = (\n            \"Cannot multiply matrix of dimensions \"\n            f\"({rows[0]},{cols[0]}) and ({rows[1]},{cols[1]})\"\n        )\n        raise ValueError(msg)\n    return [\n        [sum(m * n for m, n in zip(i, j)) for j in zip(*matrix_b)] for i in matrix_a\n    ]",
    "docstring": ">>> multiply([[1,2],[3,4]],[[5,5],[7,5]])\n[[19, 15], [43, 35]]\n>>> multiply([[1,2.5],[3,4.5]],[[5,5],[7,5]])\n[[22.5, 17.5], [46.5, 37.5]]\n>>> multiply([[1, 2, 3]], [[2], [3], [4]])\n[[20]]"
  },
  {
    "function": "identity",
    "code": "def identity(n: int) -> list[list[int]]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]",
    "docstring": ":param n: dimension for nxn matrix\n:type n: int\n:return: Identity matrix of shape [n, n]\n>>> identity(3)\n[[1, 0, 0], [0, 1, 0], [0, 0, 1]]"
  },
  {
    "function": "transpose",
    "code": "def transpose(\n    matrix: list[list[int]], return_map: bool = True\n) -> list[list[int]] | map[list[int]]:\n    \"\"\"\n    >>> transpose([[1,2],[3,4]]) # doctest: +ELLIPSIS\n    <map object at ...\n    >>> transpose([[1,2],[3,4]], return_map=False)\n    [[1, 3], [2, 4]]\n    >>> transpose([1, [2, 3]])\n    Traceback (most recent call last):\n      ...\n    TypeError: Expected a matrix, got int/list instead\n    \"\"\"\n    if _check_not_integer(matrix):\n        if return_map:\n            return map(list, zip(*matrix))\n        else:\n            return list(map(list, zip(*matrix)))\n    raise TypeError(\"Expected a matrix, got int/list instead\")",
    "docstring": ">>> transpose([[1,2],[3,4]]) # doctest: +ELLIPSIS\n<map object at ...\n>>> transpose([[1,2],[3,4]], return_map=False)\n[[1, 3], [2, 4]]\n>>> transpose([1, [2, 3]])\nTraceback (most recent call last):\n  ...\nTypeError: Expected a matrix, got int/list instead"
  },
  {
    "function": "minor",
    "code": "def minor(matrix: list[list[int]], row: int, column: int) -> list[list[int]]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]",
    "docstring": ">>> minor([[1, 2], [3, 4]], 1, 1)\n[[1]]"
  },
  {
    "function": "determinant",
    "code": "def determinant(matrix: list[list[int]]) -> Any:\n    \"\"\"\n    >>> determinant([[1, 2], [3, 4]])\n    -2\n    >>> determinant([[1.5, 2.5], [3, 4]])\n    -1.5\n    \"\"\"\n    if len(matrix) == 1:\n        return matrix[0][0]\n\n    return sum(\n        x * determinant(minor(matrix, 0, i)) * (-1) ** i\n        for i, x in enumerate(matrix[0])\n    )",
    "docstring": ">>> determinant([[1, 2], [3, 4]])\n-2\n>>> determinant([[1.5, 2.5], [3, 4]])\n-1.5"
  },
  {
    "function": "inverse",
    "code": "def inverse(matrix: list[list[int]]) -> list[list[float]] | None:\n    \"\"\"\n    >>> inverse([[1, 2], [3, 4]])\n    [[-2.0, 1.0], [1.5, -0.5]]\n    >>> inverse([[1, 1], [1, 1]])\n    \"\"\"\n    # https://stackoverflow.com/questions/20047519/python-doctests-test-for-none\n    det = determinant(matrix)\n    if det == 0:\n        return None\n\n    matrix_minor = [\n        [determinant(minor(matrix, i, j)) for j in range(len(matrix))]\n        for i in range(len(matrix))\n    ]\n\n    cofactors = [\n        [x * (-1) ** (row + col) for col, x in enumerate(matrix_minor[row])]\n        for row in range(len(matrix))\n    ]\n    adjugate = list(transpose(cofactors))\n    return scalar_multiply(adjugate, 1 / det)",
    "docstring": ">>> inverse([[1, 2], [3, 4]])\n[[-2.0, 1.0], [1.5, -0.5]]\n>>> inverse([[1, 1], [1, 1]])"
  },
  {
    "function": "is_safe",
    "code": "def is_safe(row: int, col: int, rows: int, cols: int) -> bool:\n    \"\"\"\n    Checking whether coordinate (row, col) is valid or not.\n\n    >>> is_safe(0, 0, 5, 5)\n    True\n    >>> is_safe(-1,-1, 5, 5)\n    False\n    \"\"\"\n    return 0 <= row < rows and 0 <= col < cols",
    "docstring": "Checking whether coordinate (row, col) is valid or not.\n\n>>> is_safe(0, 0, 5, 5)\nTrue\n>>> is_safe(-1,-1, 5, 5)\nFalse"
  },
  {
    "function": "depth_first_search",
    "code": "def depth_first_search(row: int, col: int, seen: set, mat: list[list[int]]) -> int:\n    \"\"\"\n    Returns the current area of the island\n\n    >>> depth_first_search(0, 0, set(), matrix)\n    0\n    \"\"\"\n    rows = len(mat)\n    cols = len(mat[0])\n    if is_safe(row, col, rows, cols) and (row, col) not in seen and mat[row][col] == 1:\n        seen.add((row, col))\n        return (\n            1\n            + depth_first_search(row + 1, col, seen, mat)\n            + depth_first_search(row - 1, col, seen, mat)\n            + depth_first_search(row, col + 1, seen, mat)\n            + depth_first_search(row, col - 1, seen, mat)\n        )\n    else:\n        return 0",
    "docstring": "Returns the current area of the island\n\n>>> depth_first_search(0, 0, set(), matrix)\n0"
  },
  {
    "function": "find_max_area",
    "code": "def find_max_area(mat: list[list[int]]) -> int:\n    \"\"\"\n    Finds the area of all islands and returns the maximum area.\n\n    >>> find_max_area(matrix)\n    6\n    \"\"\"\n    seen: set = set()\n\n    max_area = 0\n    for row, line in enumerate(mat):\n        for col, item in enumerate(line):\n            if item == 1 and (row, col) not in seen:\n                # Maximizing the area\n                max_area = max(max_area, depth_first_search(row, col, seen, mat))\n    return max_area",
    "docstring": "Finds the area of all islands and returns the maximum area.\n\n>>> find_max_area(matrix)\n6"
  },
  {
    "function": "median",
    "code": "def median(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Calculate the median of a sorted matrix.\n\n    Args:\n        matrix: A 2D matrix of integers.\n\n    Returns:\n        The median value of the matrix.\n\n    Examples:\n        >>> matrix = [[1, 3, 5], [2, 6, 9], [3, 6, 9]]\n        >>> median(matrix)\n        5\n\n        >>> matrix = [[1, 2, 3], [4, 5, 6]]\n        >>> median(matrix)\n        3\n    \"\"\"\n    # Flatten the matrix into a sorted 1D list\n    linear = sorted(num for row in matrix for num in row)\n\n    # Calculate the middle index\n    mid = (len(linear) - 1) // 2\n\n    # Return the median\n    return linear[mid]",
    "docstring": "Calculate the median of a sorted matrix.\n\nArgs:\n    matrix: A 2D matrix of integers.\n\nReturns:\n    The median value of the matrix.\n\nExamples:\n    >>> matrix = [[1, 3, 5], [2, 6, 9], [3, 6, 9]]\n    >>> median(matrix)\n    5\n\n    >>> matrix = [[1, 2, 3], [4, 5, 6]]\n    >>> median(matrix)\n    3"
  },
  {
    "function": "nth_fibonacci_matrix",
    "code": "def nth_fibonacci_matrix(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_matrix(100)\n    354224848179261915075\n    >>> nth_fibonacci_matrix(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    res_matrix = identity(2)\n    fibonacci_matrix = [[1, 1], [1, 0]]\n    n = n - 1\n    while n > 0:\n        if n % 2 == 1:\n            res_matrix = multiply(res_matrix, fibonacci_matrix)\n        fibonacci_matrix = multiply(fibonacci_matrix, fibonacci_matrix)\n        n = int(n / 2)\n    return res_matrix[0][0]",
    "docstring": ">>> nth_fibonacci_matrix(100)\n354224848179261915075\n>>> nth_fibonacci_matrix(-100)\n-100"
  },
  {
    "function": "nth_fibonacci_bruteforce",
    "code": "def nth_fibonacci_bruteforce(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_bruteforce(100)\n    354224848179261915075\n    >>> nth_fibonacci_bruteforce(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    fib0 = 0\n    fib1 = 1\n    for _ in range(2, n + 1):\n        fib0, fib1 = fib1, fib0 + fib1\n    return fib1",
    "docstring": ">>> nth_fibonacci_bruteforce(100)\n354224848179261915075\n>>> nth_fibonacci_bruteforce(-100)\n-100"
  },
  {
    "function": "print_pascal_triangle",
    "code": "def print_pascal_triangle(num_rows: int) -> None:\n    \"\"\"\n    Print Pascal's triangle for different number of rows\n    >>> print_pascal_triangle(5)\n        1\n       1 1\n      1 2 1\n     1 3 3 1\n    1 4 6 4 1\n    \"\"\"\n    triangle = generate_pascal_triangle(num_rows)\n    for row_idx in range(num_rows):\n        # Print left spaces\n        for _ in range(num_rows - row_idx - 1):\n            print(end=\" \")\n        # Print row values\n        for col_idx in range(row_idx + 1):\n            if col_idx != row_idx:\n                print(triangle[row_idx][col_idx], end=\" \")\n            else:\n                print(triangle[row_idx][col_idx], end=\"\")\n        print()",
    "docstring": "Print Pascal's triangle for different number of rows\n>>> print_pascal_triangle(5)\n    1\n   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1"
  },
  {
    "function": "generate_pascal_triangle",
    "code": "def generate_pascal_triangle(num_rows: int) -> list[list[int]]:\n    \"\"\"\n    Create Pascal's triangle for different number of rows\n    >>> generate_pascal_triangle(0)\n    []\n    >>> generate_pascal_triangle(1)\n    [[1]]\n    >>> generate_pascal_triangle(2)\n    [[1], [1, 1]]\n    >>> generate_pascal_triangle(3)\n    [[1], [1, 1], [1, 2, 1]]\n    >>> generate_pascal_triangle(4)\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]\n    >>> generate_pascal_triangle(5)\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    >>> generate_pascal_triangle(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value of 'num_rows' should be greater than or equal to 0\n    >>> generate_pascal_triangle(7.89)\n    Traceback (most recent call last):\n        ...\n    TypeError: The input value of 'num_rows' should be 'int'\n    \"\"\"\n\n    if not isinstance(num_rows, int):\n        raise TypeError(\"The input value of 'num_rows' should be 'int'\")\n\n    if num_rows == 0:\n        return []\n    elif num_rows < 0:\n        raise ValueError(\n            \"The input value of 'num_rows' should be greater than or equal to 0\"\n        )\n\n    triangle: list[list[int]] = []\n    for current_row_idx in range(num_rows):\n        current_row = populate_current_row(triangle, current_row_idx)\n        triangle.append(current_row)\n    return triangle",
    "docstring": "Create Pascal's triangle for different number of rows\n>>> generate_pascal_triangle(0)\n[]\n>>> generate_pascal_triangle(1)\n[[1]]\n>>> generate_pascal_triangle(2)\n[[1], [1, 1]]\n>>> generate_pascal_triangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generate_pascal_triangle(4)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]\n>>> generate_pascal_triangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n>>> generate_pascal_triangle(-5)\nTraceback (most recent call last):\n    ...\nValueError: The input value of 'num_rows' should be greater than or equal to 0\n>>> generate_pascal_triangle(7.89)\nTraceback (most recent call last):\n    ...\nTypeError: The input value of 'num_rows' should be 'int'"
  },
  {
    "function": "populate_current_row",
    "code": "def populate_current_row(triangle: list[list[int]], current_row_idx: int) -> list[int]:\n    \"\"\"\n    >>> triangle = [[1]]\n    >>> populate_current_row(triangle, 1)\n    [1, 1]\n    \"\"\"\n    current_row = [-1] * (current_row_idx + 1)\n    # first and last elements of current row are equal to 1\n    current_row[0], current_row[-1] = 1, 1\n    for current_col_idx in range(1, current_row_idx):\n        calculate_current_element(\n            triangle, current_row, current_row_idx, current_col_idx\n        )\n    return current_row",
    "docstring": ">>> triangle = [[1]]\n>>> populate_current_row(triangle, 1)\n[1, 1]"
  },
  {
    "function": "calculate_current_element",
    "code": "def calculate_current_element(\n    triangle: list[list[int]],\n    current_row: list[int],\n    current_row_idx: int,\n    current_col_idx: int,\n) -> None:\n    \"\"\"\n    >>> triangle = [[1], [1, 1]]\n    >>> current_row = [1, -1, 1]\n    >>> calculate_current_element(triangle, current_row, 2, 1)\n    >>> current_row\n    [1, 2, 1]\n    \"\"\"\n    above_to_left_elt = triangle[current_row_idx - 1][current_col_idx - 1]\n    above_to_right_elt = triangle[current_row_idx - 1][current_col_idx]\n    current_row[current_col_idx] = above_to_left_elt + above_to_right_elt",
    "docstring": ">>> triangle = [[1], [1, 1]]\n>>> current_row = [1, -1, 1]\n>>> calculate_current_element(triangle, current_row, 2, 1)\n>>> current_row\n[1, 2, 1]"
  },
  {
    "function": "generate_pascal_triangle_optimized",
    "code": "def generate_pascal_triangle_optimized(num_rows: int) -> list[list[int]]:\n    \"\"\"\n    This function returns a matrix representing the corresponding pascal's triangle\n    according to the given input of number of rows of Pascal's triangle to be generated.\n    It reduces the operations done to generate a row by half\n    by eliminating redundant calculations.\n\n    :param num_rows: Integer specifying the number of rows in the Pascal's triangle\n    :return: 2-D List (matrix) representing the Pascal's triangle\n\n    Return the Pascal's triangle of given rows\n    >>> generate_pascal_triangle_optimized(3)\n    [[1], [1, 1], [1, 2, 1]]\n    >>> generate_pascal_triangle_optimized(1)\n    [[1]]\n    >>> generate_pascal_triangle_optimized(0)\n    []\n    >>> generate_pascal_triangle_optimized(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value of 'num_rows' should be greater than or equal to 0\n    >>> generate_pascal_triangle_optimized(7.89)\n    Traceback (most recent call last):\n        ...\n    TypeError: The input value of 'num_rows' should be 'int'\n    \"\"\"\n\n    if not isinstance(num_rows, int):\n        raise TypeError(\"The input value of 'num_rows' should be 'int'\")\n\n    if num_rows == 0:\n        return []\n    elif num_rows < 0:\n        raise ValueError(\n            \"The input value of 'num_rows' should be greater than or equal to 0\"\n        )\n\n    result: list[list[int]] = [[1]]\n\n    for row_index in range(1, num_rows):\n        temp_row = [0] + result[-1] + [0]\n        row_length = row_index + 1\n        # Calculate the number of distinct elements in a row\n        distinct_elements = sum(divmod(row_length, 2))\n        row_first_half = [\n            temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)\n        ]\n        row_second_half = row_first_half[: (row_index + 1) // 2]\n        row_second_half.reverse()\n        row = row_first_half + row_second_half\n        result.append(row)\n\n    return result",
    "docstring": "This function returns a matrix representing the corresponding pascal's triangle\naccording to the given input of number of rows of Pascal's triangle to be generated.\nIt reduces the operations done to generate a row by half\nby eliminating redundant calculations.\n\n:param num_rows: Integer specifying the number of rows in the Pascal's triangle\n:return: 2-D List (matrix) representing the Pascal's triangle\n\nReturn the Pascal's triangle of given rows\n>>> generate_pascal_triangle_optimized(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generate_pascal_triangle_optimized(1)\n[[1]]\n>>> generate_pascal_triangle_optimized(0)\n[]\n>>> generate_pascal_triangle_optimized(-5)\nTraceback (most recent call last):\n    ...\nValueError: The input value of 'num_rows' should be greater than or equal to 0\n>>> generate_pascal_triangle_optimized(7.89)\nTraceback (most recent call last):\n    ...\nTypeError: The input value of 'num_rows' should be 'int'"
  },
  {
    "function": "benchmark",
    "code": "def benchmark() -> None:\n    \"\"\"\n    Benchmark multiple functions, with three different length int values.\n    \"\"\"\n    from collections.abc import Callable\n    from timeit import timeit\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        # print(f\"{call:38} = {func(value)} -- {timing:.4f} seconds\")\n        print(f\"{call:38} -- {timing:.4f} seconds\")\n\n    for value in range(15):  # (1, 7, 14):\n        for func in (generate_pascal_triangle, generate_pascal_triangle_optimized):\n            benchmark_a_function(func, value)\n        print()",
    "docstring": "Benchmark multiple functions, with three different length int values."
  },
  {
    "function": "make_matrix",
    "code": "def make_matrix(row_size: int = 4) -> list[list[int]]:\n    \"\"\"\n    >>> make_matrix()\n    [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n    >>> make_matrix(1)\n    [[1]]\n    >>> make_matrix(-2)\n    [[1, 2], [3, 4]]\n    >>> make_matrix(3)\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    >>> make_matrix() == make_matrix(4)\n    True\n    \"\"\"\n    row_size = abs(row_size) or 4\n    return [[1 + x + y * row_size for x in range(row_size)] for y in range(row_size)]",
    "docstring": ">>> make_matrix()\n[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n>>> make_matrix(1)\n[[1]]\n>>> make_matrix(-2)\n[[1, 2], [3, 4]]\n>>> make_matrix(3)\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n>>> make_matrix() == make_matrix(4)\nTrue"
  },
  {
    "function": "rotate_90",
    "code": "def rotate_90(matrix: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> rotate_90(make_matrix())\n    [[4, 8, 12, 16], [3, 7, 11, 15], [2, 6, 10, 14], [1, 5, 9, 13]]\n    >>> rotate_90(make_matrix()) == transpose(reverse_column(make_matrix()))\n    True\n    \"\"\"\n\n    return reverse_row(transpose(matrix))",
    "docstring": ">>> rotate_90(make_matrix())\n[[4, 8, 12, 16], [3, 7, 11, 15], [2, 6, 10, 14], [1, 5, 9, 13]]\n>>> rotate_90(make_matrix()) == transpose(reverse_column(make_matrix()))\nTrue"
  },
  {
    "function": "rotate_180",
    "code": "def rotate_180(matrix: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> rotate_180(make_matrix())\n    [[16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1]]\n    >>> rotate_180(make_matrix()) == reverse_column(reverse_row(make_matrix()))\n    True\n    \"\"\"\n\n    return reverse_row(reverse_column(matrix))",
    "docstring": ">>> rotate_180(make_matrix())\n[[16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1]]\n>>> rotate_180(make_matrix()) == reverse_column(reverse_row(make_matrix()))\nTrue"
  },
  {
    "function": "rotate_270",
    "code": "def rotate_270(matrix: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> rotate_270(make_matrix())\n    [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]\n    >>> rotate_270(make_matrix()) == transpose(reverse_row(make_matrix()))\n    True\n    \"\"\"\n\n    return reverse_column(transpose(matrix))",
    "docstring": ">>> rotate_270(make_matrix())\n[[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]\n>>> rotate_270(make_matrix()) == transpose(reverse_row(make_matrix()))\nTrue"
  },
  {
    "function": "search_in_a_sorted_matrix",
    "code": "def search_in_a_sorted_matrix(mat: list[list[int]], m: int, n: int, key: float) -> None:\n    \"\"\"\n    >>> search_in_a_sorted_matrix(\n    ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 5)\n    Key 5 found at row- 1 column- 2\n    >>> search_in_a_sorted_matrix(\n    ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 21)\n    Key 21 not found\n    >>> search_in_a_sorted_matrix(\n    ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.1)\n    Key 2.1 found at row- 1 column- 1\n    >>> search_in_a_sorted_matrix(\n    ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.2)\n    Key 2.2 not found\n    \"\"\"\n    i, j = m - 1, 0\n    while i >= 0 and j < n:\n        if key == mat[i][j]:\n            print(f\"Key {key} found at row- {i + 1} column- {j + 1}\")\n            return\n        if key < mat[i][j]:\n            i -= 1\n        else:\n            j += 1\n    print(f\"Key {key} not found\")",
    "docstring": ">>> search_in_a_sorted_matrix(\n...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 5)\nKey 5 found at row- 1 column- 2\n>>> search_in_a_sorted_matrix(\n...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 21)\nKey 21 not found\n>>> search_in_a_sorted_matrix(\n...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.1)\nKey 2.1 found at row- 1 column- 1\n>>> search_in_a_sorted_matrix(\n...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.2)\nKey 2.2 not found"
  },
  {
    "function": "spiral_print_clockwise",
    "code": "def spiral_print_clockwise(a: list[list[int]]) -> None:\n    \"\"\"\n    >>> spiral_print_clockwise([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    1\n    2\n    3\n    4\n    8\n    12\n    11\n    10\n    9\n    5\n    6\n    7\n    \"\"\"\n    if check_matrix(a) and len(a) > 0:\n        a = [list(row) for row in a]\n        mat_row = len(a)\n        if isinstance(a[0], list):\n            mat_col = len(a[0])\n        else:\n            for dat in a:\n                print(dat)\n            return\n\n        # horizotal printing increasing\n        for i in range(mat_col):\n            print(a[0][i])\n        # vertical printing down\n        for i in range(1, mat_row):\n            print(a[i][mat_col - 1])\n        # horizotal printing decreasing\n        if mat_row > 1:\n            for i in range(mat_col - 2, -1, -1):\n                print(a[mat_row - 1][i])\n        # vertical printing up\n        for i in range(mat_row - 2, 0, -1):\n            print(a[i][0])\n        remain_mat = [row[1 : mat_col - 1] for row in a[1 : mat_row - 1]]\n        if len(remain_mat) > 0:\n            spiral_print_clockwise(remain_mat)\n        else:\n            return\n    else:\n        print(\"Not a valid matrix\")\n        return",
    "docstring": ">>> spiral_print_clockwise([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n1\n2\n3\n4\n8\n12\n11\n10\n9\n5\n6\n7"
  },
  {
    "function": "spiral_traversal",
    "code": "def spiral_traversal(matrix: list[list]) -> list[int]:\n    \"\"\"\n    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n    Example:\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    Algorithm:\n        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n                output of [step 2])\n        Step 2. Now perform matrix's Transpose operation (Change rows to column\n                and vice versa) and reverse the resultant matrix.\n        Step 3. Pass the output of [2nd step], to same recursive function till\n                base case hits.\n    Dry Run:\n    Stage 1.\n    [1, 2, 3, 4] +   spiral_traversal([\n        [8, 12], [7, 11], [6, 10], [5, 9]]\n     ])\n    Stage 2.\n    [1, 2, 3, 4, 8, 12] + spiral_traversal([\n        [11, 10, 9], [7, 6, 5]\n    ])\n    Stage 3.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 4.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 5.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\n    Stage 6.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])\n    \"\"\"\n    if matrix:\n        return list(matrix.pop(0)) + spiral_traversal(\n            [list(row) for row in zip(*matrix)][::-1]\n        )\n    else:\n        return []",
    "docstring": ">>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\nExample:\nmatrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\nAlgorithm:\n    Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n            output of [step 2])\n    Step 2. Now perform matrix's Transpose operation (Change rows to column\n            and vice versa) and reverse the resultant matrix.\n    Step 3. Pass the output of [2nd step], to same recursive function till\n            base case hits.\nDry Run:\nStage 1.\n[1, 2, 3, 4] +   spiral_traversal([\n    [8, 12], [7, 11], [6, 10], [5, 9]]\n ])\nStage 2.\n[1, 2, 3, 4, 8, 12] + spiral_traversal([\n    [11, 10, 9], [7, 6, 5]\n])\nStage 3.\n[1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n    [5], [6], [7]\n])\nStage 4.\n[1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n    [5], [6], [7]\n])\nStage 5.\n[1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\nStage 6.\n[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])"
  },
  {
    "function": "is_valid_sudoku_board",
    "code": "def is_valid_sudoku_board(sudoku_board: list[list[str]]) -> bool:\n    \"\"\"\n    This function validates (but does not solve) a sudoku board.\n    The board may be valid but unsolvable.\n\n    >>> is_valid_sudoku_board([\n    ...  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n    ... ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n    ... ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n    ... ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n    ... ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n    ... ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n    ... ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n    ... ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n    ... ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n    ... ])\n    True\n    >>> is_valid_sudoku_board([\n    ...  [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n    ... ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n    ... ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n    ... ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n    ... ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n    ... ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n    ... ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n    ... ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n    ... ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n    ... ])\n    False\n    >>> is_valid_sudoku_board([\n    ...  [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n    ... ,[\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\",\"3\"]\n    ... ,[\"7\",\"8\",\"9\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ])\n    True\n    >>> is_valid_sudoku_board([\n    ...  [\"1\",\"2\",\"3\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\"4\",\"5\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\"7\",\"8\",\"9\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\"4\",\"5\",\"6\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\"7\",\"8\",\"9\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\"1\",\"2\",\"3\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"8\",\"9\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\"1\",\"2\",\"3\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\"4\",\"5\",\"6\"]\n    ... ])\n    True\n    >>> is_valid_sudoku_board([\n    ...  [\"1\",\"2\",\"3\",\".\",\".\",\".\",\"5\",\"6\",\"4\"]\n    ... ,[\"4\",\"5\",\"6\",\".\",\".\",\".\",\"8\",\"9\",\"7\"]\n    ... ,[\"7\",\"8\",\"9\",\".\",\".\",\".\",\"2\",\"3\",\"1\"]\n    ... ,[\".\",\".\",\".\",\"4\",\"5\",\"6\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\"7\",\"8\",\"9\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\"1\",\"2\",\"3\",\".\",\".\",\".\"]\n    ... ,[\"3\",\"1\",\"2\",\".\",\".\",\".\",\"7\",\"8\",\"9\"]\n    ... ,[\"6\",\"4\",\"5\",\".\",\".\",\".\",\"1\",\"2\",\"3\"]\n    ... ,[\"9\",\"7\",\"8\",\".\",\".\",\".\",\"4\",\"5\",\"6\"]\n    ... ])\n    True\n    >>> is_valid_sudoku_board([\n    ...  [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n    ... ,[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"]\n    ... ,[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"]\n    ... ,[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"]\n    ... ,[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]\n    ... ,[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"]\n    ... ,[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"]\n    ... ,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"]\n    ... ,[\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"]\n    ... ])\n    False\n    >>> is_valid_sudoku_board([\n    ...  [\"1\",\"2\",\"3\",\"8\",\"9\",\"7\",\"5\",\"6\",\"4\"]\n    ... ,[\"4\",\"5\",\"6\",\"2\",\"3\",\"1\",\"8\",\"9\",\"7\"]\n    ... ,[\"7\",\"8\",\"9\",\"5\",\"6\",\"4\",\"2\",\"3\",\"1\"]\n    ... ,[\"2\",\"3\",\"1\",\"4\",\"5\",\"6\",\"9\",\"7\",\"8\"]\n    ... ,[\"5\",\"6\",\"4\",\"7\",\"8\",\"9\",\"3\",\"1\",\"2\"]\n    ... ,[\"8\",\"9\",\"7\",\"1\",\"2\",\"3\",\"6\",\"4\",\"5\"]\n    ... ,[\"3\",\"1\",\"2\",\"6\",\"4\",\"5\",\"7\",\"8\",\"9\"]\n    ... ,[\"6\",\"4\",\"5\",\"9\",\"7\",\"8\",\"1\",\"2\",\"3\"]\n    ... ,[\"9\",\"7\",\"8\",\"3\",\"1\",\"2\",\"4\",\"5\",\"6\"]\n    ... ])\n    True\n    >>> is_valid_sudoku_board([[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Sudoku boards must be 9x9 squares.\n    >>> is_valid_sudoku_board(\n    ...        [[\"1\"], [\"2\"], [\"3\"], [\"4\"], [\"5\"], [\"6\"], [\"7\"], [\"8\"], [\"9\"]]\n    ...  )\n    Traceback (most recent call last):\n        ...\n    ValueError: Sudoku boards must be 9x9 squares.\n    \"\"\"\n    if len(sudoku_board) != NUM_SQUARES or (\n        any(len(row) != NUM_SQUARES for row in sudoku_board)\n    ):\n        error_message = f\"Sudoku boards must be {NUM_SQUARES}x{NUM_SQUARES} squares.\"\n        raise ValueError(error_message)\n\n    row_values: defaultdict[int, set[str]] = defaultdict(set)\n    col_values: defaultdict[int, set[str]] = defaultdict(set)\n    box_values: defaultdict[tuple[int, int], set[str]] = defaultdict(set)\n\n    for row in range(NUM_SQUARES):\n        for col in range(NUM_SQUARES):\n            value = sudoku_board[row][col]\n\n            if value == EMPTY_CELL:\n                continue\n\n            box = (row // 3, col // 3)\n\n            if (\n                value in row_values[row]\n                or value in col_values[col]\n                or value in box_values[box]\n            ):\n                return False\n\n            row_values[row].add(value)\n            col_values[col].add(value)\n            box_values[box].add(value)\n\n    return True",
    "docstring": "This function validates (but does not solve) a sudoku board.\nThe board may be valid but unsolvable.\n\n>>> is_valid_sudoku_board([\n...  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n... ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n... ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n... ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n... ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n... ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n... ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n... ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n... ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n... ])\nTrue\n>>> is_valid_sudoku_board([\n...  [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n... ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n... ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n... ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n... ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n... ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n... ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n... ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n... ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n... ])\nFalse\n>>> is_valid_sudoku_board([\n...  [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n... ,[\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\",\"3\"]\n... ,[\"7\",\"8\",\"9\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n... ])\nTrue\n>>> is_valid_sudoku_board([\n...  [\"1\",\"2\",\"3\",\".\",\".\",\".\",\".\",\".\",\".\"]\n... ,[\"4\",\"5\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"]\n... ,[\"7\",\"8\",\"9\",\".\",\".\",\".\",\".\",\".\",\".\"]\n... ,[\".\",\".\",\".\",\"4\",\"5\",\"6\",\".\",\".\",\".\"]\n... ,[\".\",\".\",\".\",\"7\",\"8\",\"9\",\".\",\".\",\".\"]\n... ,[\".\",\".\",\".\",\"1\",\"2\",\"3\",\".\",\".\",\".\"]\n... ,[\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"8\",\"9\"]\n... ,[\".\",\".\",\".\",\".\",\".\",\".\",\"1\",\"2\",\"3\"]\n... ,[\".\",\".\",\".\",\".\",\".\",\".\",\"4\",\"5\",\"6\"]\n... ])\nTrue\n>>> is_valid_sudoku_board([\n...  [\"1\",\"2\",\"3\",\".\",\".\",\".\",\"5\",\"6\",\"4\"]\n... ,[\"4\",\"5\",\"6\",\".\",\".\",\".\",\"8\",\"9\",\"7\"]\n... ,[\"7\",\"8\",\"9\",\".\",\".\",\".\",\"2\",\"3\",\"1\"]\n... ,[\".\",\".\",\".\",\"4\",\"5\",\"6\",\".\",\".\",\".\"]\n... ,[\".\",\".\",\".\",\"7\",\"8\",\"9\",\".\",\".\",\".\"]\n... ,[\".\",\".\",\".\",\"1\",\"2\",\"3\",\".\",\".\",\".\"]\n... ,[\"3\",\"1\",\"2\",\".\",\".\",\".\",\"7\",\"8\",\"9\"]\n... ,[\"6\",\"4\",\"5\",\".\",\".\",\".\",\"1\",\"2\",\"3\"]\n... ,[\"9\",\"7\",\"8\",\".\",\".\",\".\",\"4\",\"5\",\"6\"]\n... ])\nTrue\n>>> is_valid_sudoku_board([\n...  [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n... ,[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"]\n... ,[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"]\n... ,[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"]\n... ,[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]\n... ,[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"]\n... ,[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"]\n... ,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"]\n... ,[\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"]\n... ])\nFalse\n>>> is_valid_sudoku_board([\n...  [\"1\",\"2\",\"3\",\"8\",\"9\",\"7\",\"5\",\"6\",\"4\"]\n... ,[\"4\",\"5\",\"6\",\"2\",\"3\",\"1\",\"8\",\"9\",\"7\"]\n... ,[\"7\",\"8\",\"9\",\"5\",\"6\",\"4\",\"2\",\"3\",\"1\"]\n... ,[\"2\",\"3\",\"1\",\"4\",\"5\",\"6\",\"9\",\"7\",\"8\"]\n... ,[\"5\",\"6\",\"4\",\"7\",\"8\",\"9\",\"3\",\"1\",\"2\"]\n... ,[\"8\",\"9\",\"7\",\"1\",\"2\",\"3\",\"6\",\"4\",\"5\"]\n... ,[\"3\",\"1\",\"2\",\"6\",\"4\",\"5\",\"7\",\"8\",\"9\"]\n... ,[\"6\",\"4\",\"5\",\"9\",\"7\",\"8\",\"1\",\"2\",\"3\"]\n... ,[\"9\",\"7\",\"8\",\"3\",\"1\",\"2\",\"4\",\"5\",\"6\"]\n... ])\nTrue\n>>> is_valid_sudoku_board([[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]])\nTraceback (most recent call last):\n    ...\nValueError: Sudoku boards must be 9x9 squares.\n>>> is_valid_sudoku_board(\n...        [[\"1\"], [\"2\"], [\"3\"], [\"4\"], [\"5\"], [\"6\"], [\"7\"], [\"8\"], [\"9\"]]\n...  )\nTraceback (most recent call last):\n    ...\nValueError: Sudoku boards must be 9x9 squares."
  },
  {
    "function": "breadth_first_search",
    "code": "def breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:\n    \"\"\"\n    This function returns True if there is a node that has not iterated.\n\n    Args:\n        graph: Adjacency matrix of graph\n        source: Source\n        sink: Sink\n        parents: Parent list\n\n    Returns:\n        True if there is a node that has not iterated.\n\n    >>> breadth_first_search(graph, 0, 5, [-1, -1, -1, -1, -1, -1])\n    True\n    >>> breadth_first_search(graph, 0, 6, [-1, -1, -1, -1, -1, -1])\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n    visited = [False] * len(graph)  # Mark all nodes as not visited\n    queue = []  # breadth-first search queue\n\n    # Source node\n    queue.append(source)\n    visited[source] = True\n\n    while queue:\n        u = queue.pop(0)  # Pop the front node\n        # Traverse all adjacent nodes of u\n        for ind, node in enumerate(graph[u]):\n            if visited[ind] is False and node > 0:\n                queue.append(ind)\n                visited[ind] = True\n                parents[ind] = u\n    return visited[sink]",
    "docstring": "This function returns True if there is a node that has not iterated.\n\nArgs:\n    graph: Adjacency matrix of graph\n    source: Source\n    sink: Sink\n    parents: Parent list\n\nReturns:\n    True if there is a node that has not iterated.\n\n>>> breadth_first_search(graph, 0, 5, [-1, -1, -1, -1, -1, -1])\nTrue\n>>> breadth_first_search(graph, 0, 6, [-1, -1, -1, -1, -1, -1])\nTraceback (most recent call last):\n    ...\nIndexError: list index out of range"
  },
  {
    "function": "ford_fulkerson",
    "code": "def ford_fulkerson(graph: list, source: int, sink: int) -> int:\n    \"\"\"\n    This function returns the maximum flow from source to sink in the given graph.\n\n    CAUTION: This function changes the given graph.\n\n    Args:\n        graph: Adjacency matrix of graph\n        source: Source\n        sink: Sink\n\n    Returns:\n        Maximum flow\n\n    >>> test_graph = [\n    ...     [0, 16, 13, 0, 0, 0],\n    ...     [0, 0, 10, 12, 0, 0],\n    ...     [0, 4, 0, 0, 14, 0],\n    ...     [0, 0, 9, 0, 0, 20],\n    ...     [0, 0, 0, 7, 0, 4],\n    ...     [0, 0, 0, 0, 0, 0],\n    ... ]\n    >>> ford_fulkerson(test_graph, 0, 5)\n    23\n    \"\"\"\n    # This array is filled by breadth-first search and to store path\n    parent = [-1] * (len(graph))\n    max_flow = 0\n\n    # While there is a path from source to sink\n    while breadth_first_search(graph, source, sink, parent):\n        path_flow = int(1e9)  # Infinite value\n        s = sink\n\n        while s != source:\n            # Find the minimum value in the selected path\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n\n        max_flow += path_flow\n        v = sink\n\n        while v != source:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n\n    return max_flow",
    "docstring": "This function returns the maximum flow from source to sink in the given graph.\n\nCAUTION: This function changes the given graph.\n\nArgs:\n    graph: Adjacency matrix of graph\n    source: Source\n    sink: Sink\n\nReturns:\n    Maximum flow\n\n>>> test_graph = [\n...     [0, 16, 13, 0, 0, 0],\n...     [0, 0, 10, 12, 0, 0],\n...     [0, 4, 0, 0, 14, 0],\n...     [0, 0, 9, 0, 0, 20],\n...     [0, 0, 0, 7, 0, 4],\n...     [0, 0, 0, 0, 0, 0],\n... ]\n>>> ford_fulkerson(test_graph, 0, 5)\n23"
  },
  {
    "function": "mincut",
    "code": "def mincut(graph, source, sink):\n    \"\"\"This array is filled by BFS and to store path\n    >>> mincut(test_graph, source=0, sink=5)\n    [(1, 3), (4, 3), (4, 5)]\n    \"\"\"\n    parent = [-1] * (len(graph))\n    max_flow = 0\n    res = []\n    temp = [i[:] for i in graph]  # Record original cut, copy.\n    while bfs(graph, source, sink, parent):\n        path_flow = float(\"Inf\")\n        s = sink\n\n        while s != source:\n            # Find the minimum value in select path\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n\n        max_flow += path_flow\n        v = sink\n\n        while v != source:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n\n    for i in range(len(graph)):\n        for j in range(len(graph[0])):\n            if graph[i][j] == 0 and temp[i][j] > 0:\n                res.append((i, j))\n\n    return res",
    "docstring": "This array is filled by BFS and to store path\n>>> mincut(test_graph, source=0, sink=5)\n[(1, 3), (4, 3), (4, 5)]"
  },
  {
    "function": "_extract_images",
    "code": "def _extract_images(f):\n    \"\"\"Extract the images into a 4D uint8 numpy array [index, y, x, depth].\n\n    Args:\n      f: A file object that can be passed into a gzip reader.\n\n    Returns:\n      data: A 4D uint8 numpy array [index, y, x, depth].\n\n    Raises:\n      ValueError: If the bytestream does not start with 2051.\n\n    \"\"\"\n    print(\"Extracting\", f.name)\n    with gzip.GzipFile(fileobj=f) as bytestream:\n        magic = _read32(bytestream)\n        if magic != 2051:\n            msg = f\"Invalid magic number {magic} in MNIST image file: {f.name}\"\n            raise ValueError(msg)\n        num_images = _read32(bytestream)\n        rows = _read32(bytestream)\n        cols = _read32(bytestream)\n        buf = bytestream.read(rows * cols * num_images)\n        data = np.frombuffer(buf, dtype=np.uint8)\n        data = data.reshape(num_images, rows, cols, 1)\n        return data",
    "docstring": "Extract the images into a 4D uint8 numpy array [index, y, x, depth].\n\nArgs:\n  f: A file object that can be passed into a gzip reader.\n\nReturns:\n  data: A 4D uint8 numpy array [index, y, x, depth].\n\nRaises:\n  ValueError: If the bytestream does not start with 2051."
  },
  {
    "function": "_dense_to_one_hot",
    "code": "def _dense_to_one_hot(labels_dense, num_classes):\n    \"\"\"Convert class labels from scalars to one-hot vectors.\"\"\"\n    num_labels = labels_dense.shape[0]\n    index_offset = np.arange(num_labels) * num_classes\n    labels_one_hot = np.zeros((num_labels, num_classes))\n    labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1\n    return labels_one_hot",
    "docstring": "Convert class labels from scalars to one-hot vectors."
  },
  {
    "function": "_extract_labels",
    "code": "def _extract_labels(f, one_hot=False, num_classes=10):\n    \"\"\"Extract the labels into a 1D uint8 numpy array [index].\n\n    Args:\n      f: A file object that can be passed into a gzip reader.\n      one_hot: Does one hot encoding for the result.\n      num_classes: Number of classes for the one hot encoding.\n\n    Returns:\n      labels: a 1D uint8 numpy array.\n\n    Raises:\n      ValueError: If the bystream doesn't start with 2049.\n    \"\"\"\n    print(\"Extracting\", f.name)\n    with gzip.GzipFile(fileobj=f) as bytestream:\n        magic = _read32(bytestream)\n        if magic != 2049:\n            msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"\n            raise ValueError(msg)\n        num_items = _read32(bytestream)\n        buf = bytestream.read(num_items)\n        labels = np.frombuffer(buf, dtype=np.uint8)\n        if one_hot:\n            return _dense_to_one_hot(labels, num_classes)\n        return labels",
    "docstring": "Extract the labels into a 1D uint8 numpy array [index].\n\nArgs:\n  f: A file object that can be passed into a gzip reader.\n  one_hot: Does one hot encoding for the result.\n  num_classes: Number of classes for the one hot encoding.\n\nReturns:\n  labels: a 1D uint8 numpy array.\n\nRaises:\n  ValueError: If the bystream doesn't start with 2049."
  },
  {
    "function": "_maybe_download",
    "code": "def _maybe_download(filename, work_directory, source_url):\n    \"\"\"Download the data from source url, unless it's already here.\n\n    Args:\n        filename: string, name of the file in the directory.\n        work_directory: string, path to working directory.\n        source_url: url to download from if file doesn't exist.\n\n    Returns:\n        Path to resulting file.\n    \"\"\"\n    if not gfile.Exists(work_directory):\n        gfile.MakeDirs(work_directory)\n    filepath = os.path.join(work_directory, filename)\n    if not gfile.Exists(filepath):\n        urllib.request.urlretrieve(source_url, filepath)  # noqa: S310\n        with gfile.GFile(filepath) as f:\n            size = f.size()\n        print(\"Successfully downloaded\", filename, size, \"bytes.\")\n    return filepath",
    "docstring": "Download the data from source url, unless it's already here.\n\nArgs:\n    filename: string, name of the file in the directory.\n    work_directory: string, path to working directory.\n    source_url: url to download from if file doesn't exist.\n\nReturns:\n    Path to resulting file."
  },
  {
    "function": "sigmoid_function",
    "code": "def sigmoid_function(value: float, deriv: bool = False) -> float:\n    \"\"\"Return the sigmoid function of a float.\n\n    >>> sigmoid_function(3.5)\n    0.9706877692486436\n    >>> sigmoid_function(3.5, True)\n    -8.75\n    \"\"\"\n    if deriv:\n        return value * (1 - value)\n    return 1 / (1 + math.exp(-value))",
    "docstring": "Return the sigmoid function of a float.\n\n>>> sigmoid_function(3.5)\n0.9706877692486436\n>>> sigmoid_function(3.5, True)\n-8.75"
  },
  {
    "function": "forward_propagation",
    "code": "def forward_propagation(expected: int, number_propagations: int) -> float:\n    \"\"\"Return the value found after the forward propagation training.\n\n    >>> res = forward_propagation(32, 450_000)  # Was 10_000_000\n    >>> res > 31 and res < 33\n    True\n\n    >>> res = forward_propagation(32, 1000)\n    >>> res > 31 and res < 33\n    False\n    \"\"\"\n\n    # Random weight\n    weight = float(2 * (random.randint(1, 100)) - 1)\n\n    for _ in range(number_propagations):\n        # Forward propagation\n        layer_1 = sigmoid_function(INITIAL_VALUE * weight)\n        # How much did we miss?\n        layer_1_error = (expected / 100) - layer_1\n        # Error delta\n        layer_1_delta = layer_1_error * sigmoid_function(layer_1, True)\n        # Update weight\n        weight += INITIAL_VALUE * layer_1_delta\n\n    return layer_1 * 100",
    "docstring": "Return the value found after the forward propagation training.\n\n>>> res = forward_propagation(32, 450_000)  # Was 10_000_000\n>>> res > 31 and res < 33\nTrue\n\n>>> res = forward_propagation(32, 1000)\n>>> res > 31 and res < 33\nFalse"
  },
  {
    "function": "sigmoid",
    "code": "def sigmoid(value: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies sigmoid activation function.\n\n    return normalized values\n\n    >>> sigmoid(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64))\n    array([[0.73105858, 0.5       , 0.88079708],\n           [0.73105858, 0.5       , 0.5       ]])\n    \"\"\"\n    return 1 / (1 + np.exp(-value))",
    "docstring": "Applies sigmoid activation function.\n\nreturn normalized values\n\n>>> sigmoid(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64))\narray([[0.73105858, 0.5       , 0.88079708],\n       [0.73105858, 0.5       , 0.5       ]])"
  },
  {
    "function": "sigmoid_derivative",
    "code": "def sigmoid_derivative(value: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Provides the derivative value of the sigmoid function.\n\n    returns derivative of the sigmoid value\n\n    >>> sigmoid_derivative(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64))\n    array([[ 0.,  0., -2.],\n           [ 0.,  0.,  0.]])\n    \"\"\"\n    return (value) * (1 - (value))",
    "docstring": "Provides the derivative value of the sigmoid function.\n\nreturns derivative of the sigmoid value\n\n>>> sigmoid_derivative(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64))\narray([[ 0.,  0., -2.],\n       [ 0.,  0.,  0.]])"
  },
  {
    "function": "example",
    "code": "def example() -> int:\n    \"\"\"\n    Example for \"how to use the neural network class and use the\n    respected methods for the desired output\".\n    Calls the TwoHiddenLayerNeuralNetwork class and\n    provides the fixed input output values to the model.\n    Model is trained for a fixed amount of iterations then the predict method is called.\n    In this example the output is divided into 2 classes i.e. binary classification,\n    the two classes are represented by '0' and '1'.\n\n    >>> example() in (0, 1)\n    True\n    \"\"\"\n    # Input values.\n    test_input = np.array(\n        (\n            [0, 0, 0],\n            [0, 0, 1],\n            [0, 1, 0],\n            [0, 1, 1],\n            [1, 0, 0],\n            [1, 0, 1],\n            [1, 1, 0],\n            [1, 1, 1],\n        ),\n        dtype=np.float64,\n    )\n\n    # True output values for the given input values.\n    output = np.array(([0], [1], [1], [0], [1], [0], [0], [1]), dtype=np.float64)\n\n    # Calling neural network class.\n    neural_network = TwoHiddenLayerNeuralNetwork(\n        input_array=test_input, output_array=output\n    )\n\n    # Calling training function.\n    # Set give_loss to True if you want to see loss in every iteration.\n    neural_network.train(output=output, iterations=10, give_loss=False)\n\n    return neural_network.predict(np.array(([1, 1, 1]), dtype=np.float64))",
    "docstring": "Example for \"how to use the neural network class and use the\nrespected methods for the desired output\".\nCalls the TwoHiddenLayerNeuralNetwork class and\nprovides the fixed input output values to the model.\nModel is trained for a fixed amount of iterations then the predict method is called.\nIn this example the output is divided into 2 classes i.e. binary classification,\nthe two classes are represented by '0' and '1'.\n\n>>> example() in (0, 1)\nTrue"
  },
  {
    "function": "binary_step",
    "code": "def binary_step(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the binary step function\n\n    Parameters:\n        vector (ndarray): A vector that consists of numeric values\n\n    Returns:\n        vector (ndarray): Input vector after applying binary step function\n\n    >>> vector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])\n    >>> binary_step(vector)\n    array([0, 1, 1, 1, 0, 1])\n    \"\"\"\n\n    return np.where(vector >= 0, 1, 0)",
    "docstring": "Implements the binary step function\n\nParameters:\n    vector (ndarray): A vector that consists of numeric values\n\nReturns:\n    vector (ndarray): Input vector after applying binary step function\n\n>>> vector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])\n>>> binary_step(vector)\narray([0, 1, 1, 1, 0, 1])"
  },
  {
    "function": "exponential_linear_unit",
    "code": "def exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:\n    \"\"\"\n         Implements the ELU activation function.\n         Parameters:\n             vector: the array containing input of elu activation\n             alpha: hyper-parameter\n         return:\n         elu (np.array): The input numpy array after applying elu.\n\n         Mathematically, f(x) = x, x>0 else (alpha * (e^x -1)), x<=0, alpha >=0\n\n    Examples:\n    >>> exponential_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)\n    array([ 2.3       ,  0.6       , -0.25939942, -0.29328877])\n\n    >>> exponential_linear_unit(vector=np.array([-9.2,-0.3,0.45,-4.56]), alpha=0.067)\n    array([-0.06699323, -0.01736518,  0.45      , -0.06629904])\n\n\n    \"\"\"\n    return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))",
    "docstring": "Implements the ELU activation function.\n     Parameters:\n         vector: the array containing input of elu activation\n         alpha: hyper-parameter\n     return:\n     elu (np.array): The input numpy array after applying elu.\n\n     Mathematically, f(x) = x, x>0 else (alpha * (e^x -1)), x<=0, alpha >=0\n\nExamples:\n>>> exponential_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)\narray([ 2.3       ,  0.6       , -0.25939942, -0.29328877])\n\n>>> exponential_linear_unit(vector=np.array([-9.2,-0.3,0.45,-4.56]), alpha=0.067)\narray([-0.06699323, -0.01736518,  0.45      , -0.06629904])"
  },
  {
    "function": "sigmoid",
    "code": "def sigmoid(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Mathematical function sigmoid takes a vector x of K real numbers as input and\n    returns 1/ (1 + e^-x).\n    https://en.wikipedia.org/wiki/Sigmoid_function\n\n    >>> sigmoid(np.array([-1.0, 1.0, 2.0]))\n    array([0.26894142, 0.73105858, 0.88079708])\n    \"\"\"\n    return 1 / (1 + np.exp(-vector))",
    "docstring": "Mathematical function sigmoid takes a vector x of K real numbers as input and\nreturns 1/ (1 + e^-x).\nhttps://en.wikipedia.org/wiki/Sigmoid_function\n\n>>> sigmoid(np.array([-1.0, 1.0, 2.0]))\narray([0.26894142, 0.73105858, 0.88079708])"
  },
  {
    "function": "gaussian_error_linear_unit",
    "code": "def gaussian_error_linear_unit(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the Gaussian Error Linear Unit (GELU) function\n\n    Parameters:\n        vector (np.ndarray): A  numpy array of shape (1, n) consisting of real values\n\n    Returns:\n        gelu_vec (np.ndarray): The input numpy array, after applying gelu\n\n    Examples:\n    >>> gaussian_error_linear_unit(np.array([-1.0, 1.0, 2.0]))\n    array([-0.15420423,  0.84579577,  1.93565862])\n\n    >>> gaussian_error_linear_unit(np.array([-3]))\n    array([-0.01807131])\n    \"\"\"\n    return vector * sigmoid(1.702 * vector)",
    "docstring": "Implements the Gaussian Error Linear Unit (GELU) function\n\nParameters:\n    vector (np.ndarray): A  numpy array of shape (1, n) consisting of real values\n\nReturns:\n    gelu_vec (np.ndarray): The input numpy array, after applying gelu\n\nExamples:\n>>> gaussian_error_linear_unit(np.array([-1.0, 1.0, 2.0]))\narray([-0.15420423,  0.84579577,  1.93565862])\n\n>>> gaussian_error_linear_unit(np.array([-3]))\narray([-0.01807131])"
  },
  {
    "function": "leaky_rectified_linear_unit",
    "code": "def leaky_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:\n    \"\"\"\n        Implements the LeakyReLU activation function.\n\n        Parameters:\n            vector (np.ndarray): The input array for LeakyReLU activation.\n            alpha (float): The slope for negative values.\n\n        Returns:\n            np.ndarray: The input array after applying the LeakyReLU activation.\n\n        Formula: f(x) = x if x > 0 else f(x) = alpha * x\n\n    Examples:\n    >>> leaky_rectified_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)\n    array([ 2.3 ,  0.6 , -0.6 , -1.14])\n\n    >>> leaky_rectified_linear_unit(np.array([-9.2, -0.3, 0.45, -4.56]), alpha=0.067)\n    array([-0.6164 , -0.0201 ,  0.45   , -0.30552])\n\n    \"\"\"\n    return np.where(vector > 0, vector, alpha * vector)",
    "docstring": "Implements the LeakyReLU activation function.\n\n    Parameters:\n        vector (np.ndarray): The input array for LeakyReLU activation.\n        alpha (float): The slope for negative values.\n\n    Returns:\n        np.ndarray: The input array after applying the LeakyReLU activation.\n\n    Formula: f(x) = x if x > 0 else f(x) = alpha * x\n\nExamples:\n>>> leaky_rectified_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)\narray([ 2.3 ,  0.6 , -0.6 , -1.14])\n\n>>> leaky_rectified_linear_unit(np.array([-9.2, -0.3, 0.45, -4.56]), alpha=0.067)\narray([-0.6164 , -0.0201 ,  0.45   , -0.30552])"
  },
  {
    "function": "mish",
    "code": "def mish(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n        Implements the Mish activation function.\n\n        Parameters:\n            vector (np.ndarray): The input array for Mish activation.\n\n        Returns:\n            np.ndarray: The input array after applying the Mish activation.\n\n        Formula:\n            f(x) = x * tanh(softplus(x)) = x * tanh(ln(1 + e^x))\n\n    Examples:\n    >>> mish(vector=np.array([2.3,0.6,-2,-3.8]))\n    array([ 2.26211893,  0.46613649, -0.25250148, -0.08405831])\n\n    >>> mish(np.array([-9.2, -0.3, 0.45, -4.56]))\n    array([-0.00092952, -0.15113318,  0.33152014, -0.04745745])\n\n    \"\"\"\n    return vector * np.tanh(softplus(vector))",
    "docstring": "Implements the Mish activation function.\n\n    Parameters:\n        vector (np.ndarray): The input array for Mish activation.\n\n    Returns:\n        np.ndarray: The input array after applying the Mish activation.\n\n    Formula:\n        f(x) = x * tanh(softplus(x)) = x * tanh(ln(1 + e^x))\n\nExamples:\n>>> mish(vector=np.array([2.3,0.6,-2,-3.8]))\narray([ 2.26211893,  0.46613649, -0.25250148, -0.08405831])\n\n>>> mish(np.array([-9.2, -0.3, 0.45, -4.56]))\narray([-0.00092952, -0.15113318,  0.33152014, -0.04745745])"
  },
  {
    "function": "relu",
    "code": "def relu(vector: list[float]):\n    \"\"\"\n    Implements the relu function\n\n    Parameters:\n        vector (np.array,list,tuple): A  numpy array of shape (1,n)\n        consisting of real values or a similar list,tuple\n\n\n    Returns:\n        relu_vec (np.array): The input numpy array, after applying\n        relu.\n\n    >>> vec = np.array([-1, 0, 5])\n    >>> relu(vec)\n    array([0, 0, 5])\n    \"\"\"\n\n    # compare two arrays and then return element-wise maxima.\n    return np.maximum(0, vector)",
    "docstring": "Implements the relu function\n\nParameters:\n    vector (np.array,list,tuple): A  numpy array of shape (1,n)\n    consisting of real values or a similar list,tuple\n\n\nReturns:\n    relu_vec (np.array): The input numpy array, after applying\n    relu.\n\n>>> vec = np.array([-1, 0, 5])\n>>> relu(vec)\narray([0, 0, 5])"
  },
  {
    "function": "scaled_exponential_linear_unit",
    "code": "def scaled_exponential_linear_unit(\n    vector: np.ndarray, alpha: float = 1.6732, lambda_: float = 1.0507\n) -> np.ndarray:\n    \"\"\"\n    Applies the Scaled Exponential Linear Unit function to each element of the vector.\n    Parameters :\n        vector : np.ndarray\n        alpha : float (default = 1.6732)\n        lambda_ : float (default = 1.0507)\n\n    Returns : np.ndarray\n    Formula : f(x) = lambda_ * x if x > 0\n                     lambda_ * alpha * (e**x - 1) if x <= 0\n    Examples :\n    >>> scaled_exponential_linear_unit(vector=np.array([1.3, 3.7, 2.4]))\n    array([1.36591, 3.88759, 2.52168])\n\n    >>> scaled_exponential_linear_unit(vector=np.array([1.3, 4.7, 8.2]))\n    array([1.36591, 4.93829, 8.61574])\n    \"\"\"\n    return lambda_ * np.where(vector > 0, vector, alpha * (np.exp(vector) - 1))",
    "docstring": "Applies the Scaled Exponential Linear Unit function to each element of the vector.\nParameters :\n    vector : np.ndarray\n    alpha : float (default = 1.6732)\n    lambda_ : float (default = 1.0507)\n\nReturns : np.ndarray\nFormula : f(x) = lambda_ * x if x > 0\n                 lambda_ * alpha * (e**x - 1) if x <= 0\nExamples :\n>>> scaled_exponential_linear_unit(vector=np.array([1.3, 3.7, 2.4]))\narray([1.36591, 3.88759, 2.52168])\n\n>>> scaled_exponential_linear_unit(vector=np.array([1.3, 4.7, 8.2]))\narray([1.36591, 4.93829, 8.61574])"
  },
  {
    "function": "soboleva_modified_hyperbolic_tangent",
    "code": "def soboleva_modified_hyperbolic_tangent(\n    vector: np.ndarray, a_value: float, b_value: float, c_value: float, d_value: float\n) -> np.ndarray:\n    \"\"\"\n    Implements the Soboleva Modified Hyperbolic Tangent function\n\n    Parameters:\n        vector (ndarray): A vector that consists of numeric values\n        a_value (float): parameter a of the equation\n        b_value (float): parameter b of the equation\n        c_value (float): parameter c of the equation\n        d_value (float): parameter d of the equation\n\n    Returns:\n        vector (ndarray): Input array after applying SMHT function\n\n    >>> vector = np.array([5.4, -2.4, 6.3, -5.23, 3.27, 0.56])\n    >>> soboleva_modified_hyperbolic_tangent(vector, 0.2, 0.4, 0.6, 0.8)\n    array([ 0.11075085, -0.28236685,  0.07861169, -0.1180085 ,  0.22999056,\n            0.1566043 ])\n    \"\"\"\n\n    # Separate the numerator and denominator for simplicity\n    # Calculate the numerator and denominator element-wise\n    numerator = np.exp(a_value * vector) - np.exp(-b_value * vector)\n    denominator = np.exp(c_value * vector) + np.exp(-d_value * vector)\n\n    # Calculate and return the final result element-wise\n    return numerator / denominator",
    "docstring": "Implements the Soboleva Modified Hyperbolic Tangent function\n\nParameters:\n    vector (ndarray): A vector that consists of numeric values\n    a_value (float): parameter a of the equation\n    b_value (float): parameter b of the equation\n    c_value (float): parameter c of the equation\n    d_value (float): parameter d of the equation\n\nReturns:\n    vector (ndarray): Input array after applying SMHT function\n\n>>> vector = np.array([5.4, -2.4, 6.3, -5.23, 3.27, 0.56])\n>>> soboleva_modified_hyperbolic_tangent(vector, 0.2, 0.4, 0.6, 0.8)\narray([ 0.11075085, -0.28236685,  0.07861169, -0.1180085 ,  0.22999056,\n        0.1566043 ])"
  },
  {
    "function": "softplus",
    "code": "def softplus(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the Softplus activation function.\n\n    Parameters:\n        vector (np.ndarray): The input array for the Softplus activation.\n\n    Returns:\n        np.ndarray: The input array after applying the Softplus activation.\n\n    Formula: f(x) = ln(1 + e^x)\n\n    Examples:\n    >>> softplus(np.array([2.3, 0.6, -2, -3.8]))\n    array([2.39554546, 1.03748795, 0.12692801, 0.02212422])\n\n    >>> softplus(np.array([-9.2, -0.3, 0.45, -4.56]))\n    array([1.01034298e-04, 5.54355244e-01, 9.43248946e-01, 1.04077103e-02])\n    \"\"\"\n    return np.log(1 + np.exp(vector))",
    "docstring": "Implements the Softplus activation function.\n\nParameters:\n    vector (np.ndarray): The input array for the Softplus activation.\n\nReturns:\n    np.ndarray: The input array after applying the Softplus activation.\n\nFormula: f(x) = ln(1 + e^x)\n\nExamples:\n>>> softplus(np.array([2.3, 0.6, -2, -3.8]))\narray([2.39554546, 1.03748795, 0.12692801, 0.02212422])\n\n>>> softplus(np.array([-9.2, -0.3, 0.45, -4.56]))\narray([1.01034298e-04, 5.54355244e-01, 9.43248946e-01, 1.04077103e-02])"
  },
  {
    "function": "squareplus",
    "code": "def squareplus(vector: np.ndarray, beta: float) -> np.ndarray:\n    \"\"\"\n    Implements the SquarePlus activation function.\n\n    Parameters:\n        vector (np.ndarray): The input array for the SquarePlus activation.\n        beta (float): size of the curved region\n\n    Returns:\n        np.ndarray: The input array after applying the SquarePlus activation.\n\n    Formula: f(x) = ( x + sqrt(x^2 + b) ) / 2\n\n    Examples:\n    >>> squareplus(np.array([2.3, 0.6, -2, -3.8]), beta=2)\n    array([2.5       , 1.06811457, 0.22474487, 0.12731349])\n\n    >>> squareplus(np.array([-9.2, -0.3, 0.45, -4.56]), beta=3)\n    array([0.0808119 , 0.72891979, 1.11977651, 0.15893419])\n    \"\"\"\n    return (vector + np.sqrt(vector**2 + beta)) / 2",
    "docstring": "Implements the SquarePlus activation function.\n\nParameters:\n    vector (np.ndarray): The input array for the SquarePlus activation.\n    beta (float): size of the curved region\n\nReturns:\n    np.ndarray: The input array after applying the SquarePlus activation.\n\nFormula: f(x) = ( x + sqrt(x^2 + b) ) / 2\n\nExamples:\n>>> squareplus(np.array([2.3, 0.6, -2, -3.8]), beta=2)\narray([2.5       , 1.06811457, 0.22474487, 0.12731349])\n\n>>> squareplus(np.array([-9.2, -0.3, 0.45, -4.56]), beta=3)\narray([0.0808119 , 0.72891979, 1.11977651, 0.15893419])"
  },
  {
    "function": "sigmoid",
    "code": "def sigmoid(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Mathematical function sigmoid takes a vector x of K real numbers as input and\n    returns 1/ (1 + e^-x).\n    https://en.wikipedia.org/wiki/Sigmoid_function\n\n    >>> sigmoid(np.array([-1.0, 1.0, 2.0]))\n    array([0.26894142, 0.73105858, 0.88079708])\n    \"\"\"\n    return 1 / (1 + np.exp(-vector))",
    "docstring": "Mathematical function sigmoid takes a vector x of K real numbers as input and\nreturns 1/ (1 + e^-x).\nhttps://en.wikipedia.org/wiki/Sigmoid_function\n\n>>> sigmoid(np.array([-1.0, 1.0, 2.0]))\narray([0.26894142, 0.73105858, 0.88079708])"
  },
  {
    "function": "sigmoid_linear_unit",
    "code": "def sigmoid_linear_unit(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the Sigmoid Linear Unit (SiLU) or swish function\n\n    Parameters:\n        vector (np.ndarray): A  numpy array consisting of real values\n\n    Returns:\n        swish_vec (np.ndarray): The input numpy array, after applying swish\n\n    Examples:\n    >>> sigmoid_linear_unit(np.array([-1.0, 1.0, 2.0]))\n    array([-0.26894142,  0.73105858,  1.76159416])\n\n    >>> sigmoid_linear_unit(np.array([-2]))\n    array([-0.23840584])\n    \"\"\"\n    return vector * sigmoid(vector)",
    "docstring": "Implements the Sigmoid Linear Unit (SiLU) or swish function\n\nParameters:\n    vector (np.ndarray): A  numpy array consisting of real values\n\nReturns:\n    swish_vec (np.ndarray): The input numpy array, after applying swish\n\nExamples:\n>>> sigmoid_linear_unit(np.array([-1.0, 1.0, 2.0]))\narray([-0.26894142,  0.73105858,  1.76159416])\n\n>>> sigmoid_linear_unit(np.array([-2]))\narray([-0.23840584])"
  },
  {
    "function": "swish",
    "code": "def swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:\n    \"\"\"\n    Parameters:\n        vector (np.ndarray): A  numpy array consisting of real values\n        trainable_parameter: Use to implement various Swish Activation Functions\n\n    Returns:\n        swish_vec (np.ndarray): The input numpy array, after applying swish\n\n    Examples:\n    >>> swish(np.array([-1.0, 1.0, 2.0]), 2)\n    array([-0.11920292,  0.88079708,  1.96402758])\n\n    >>> swish(np.array([-2]), 1)\n    array([-0.23840584])\n    \"\"\"\n    return vector * sigmoid(trainable_parameter * vector)",
    "docstring": "Parameters:\n    vector (np.ndarray): A  numpy array consisting of real values\n    trainable_parameter: Use to implement various Swish Activation Functions\n\nReturns:\n    swish_vec (np.ndarray): The input numpy array, after applying swish\n\nExamples:\n>>> swish(np.array([-1.0, 1.0, 2.0]), 2)\narray([-0.11920292,  0.88079708,  1.96402758])\n\n>>> swish(np.array([-2]), 1)\narray([-0.23840584])"
  },
  {
    "function": "print_max_activities",
    "code": "def print_max_activities(start: list[int], finish: list[int]) -> None:\n    \"\"\"\n    >>> start = [1, 3, 0, 5, 8, 5]\n    >>> finish = [2, 4, 6, 7, 9, 9]\n    >>> print_max_activities(start, finish)\n    The following activities are selected:\n    0,1,3,4,\n    \"\"\"\n    n = len(finish)\n    print(\"The following activities are selected:\")\n\n    # The first activity is always selected\n    i = 0\n    print(i, end=\",\")\n\n    # Consider rest of the activities\n    for j in range(n):\n        # If this activity has start time greater than\n        # or equal to the finish time of previously\n        # selected activity, then select it\n        if start[j] >= finish[i]:\n            print(j, end=\",\")\n            i = j",
    "docstring": ">>> start = [1, 3, 0, 5, 8, 5]\n>>> finish = [2, 4, 6, 7, 9, 9]\n>>> print_max_activities(start, finish)\nThe following activities are selected:\n0,1,3,4,"
  },
  {
    "function": "alternative_list_arrange",
    "code": "def alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    \"\"\"\n    The method arranges two lists as one list in alternative forms of the list elements.\n    :param first_input_list:\n    :param second_input_list:\n    :return: List\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\n    >>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\n    >>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list",
    "docstring": "The method arranges two lists as one list in alternative forms of the list elements.\n:param first_input_list:\n:param second_input_list:\n:return: List\n>>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n[1, 'A', 2, 'B', 3, 'C', 4, 5]\n>>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n['A', 1, 'B', 2, 'C', 3, 4, 5]\n>>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n['X', 9, 'Y', 8, 'Z', 7, 6]\n>>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n[1, 2, 3, 4, 5]"
  },
  {
    "function": "generate_clause",
    "code": "def generate_clause() -> Clause:\n    \"\"\"\n    | Randomly generate a clause.\n    | All literals have the name Ax, where x is an integer from ``1`` to ``5``.\n    \"\"\"\n    literals = []\n    no_of_literals = random.randint(1, 5)\n    base_var = \"A\"\n    i = 0\n    while i < no_of_literals:\n        var_no = random.randint(1, 5)\n        var_name = base_var + str(var_no)\n        var_complement = random.randint(0, 1)\n        if var_complement == 1:\n            var_name += \"'\"\n        if var_name in literals:\n            i -= 1\n        else:\n            literals.append(var_name)\n        i += 1\n    return Clause(literals)",
    "docstring": "| Randomly generate a clause.\n| All literals have the name Ax, where x is an integer from ``1`` to ``5``."
  },
  {
    "function": "generate_formula",
    "code": "def generate_formula() -> Formula:\n    \"\"\"\n    Randomly generate a formula.\n    \"\"\"\n    clauses: set[Clause] = set()\n    no_of_clauses = random.randint(1, 10)\n    while len(clauses) < no_of_clauses:\n        clauses.add(generate_clause())\n    return Formula(clauses)",
    "docstring": "Randomly generate a formula."
  },
  {
    "function": "generate_parameters",
    "code": "def generate_parameters(formula: Formula) -> tuple[list[Clause], list[str]]:\n    \"\"\"\n    | Return the clauses and symbols from a formula.\n    | A symbol is the uncomplemented form of a literal.\n\n    For example,\n      * Symbol of A3 is A3.\n      * Symbol of A5' is A5.\n\n    >>> formula = Formula([Clause([\"A1\", \"A2'\", \"A3\"]), Clause([\"A5'\", \"A2'\", \"A1\"])])\n    >>> clauses, symbols = generate_parameters(formula)\n    >>> clauses_list = [str(i) for i in clauses]\n    >>> clauses_list\n    [\"{A1 , A2' , A3}\", \"{A5' , A2' , A1}\"]\n    >>> symbols\n    ['A1', 'A2', 'A3', 'A5']\n    \"\"\"\n    clauses = formula.clauses\n    symbols_set = []\n    for clause in formula.clauses:\n        for literal in clause.literals:\n            symbol = literal[:2]\n            if symbol not in symbols_set:\n                symbols_set.append(symbol)\n    return clauses, symbols_set",
    "docstring": "| Return the clauses and symbols from a formula.\n| A symbol is the uncomplemented form of a literal.\n\nFor example,\n  * Symbol of A3 is A3.\n  * Symbol of A5' is A5.\n\n>>> formula = Formula([Clause([\"A1\", \"A2'\", \"A3\"]), Clause([\"A5'\", \"A2'\", \"A1\"])])\n>>> clauses, symbols = generate_parameters(formula)\n>>> clauses_list = [str(i) for i in clauses]\n>>> clauses_list\n[\"{A1 , A2' , A3}\", \"{A5' , A2' , A1}\"]\n>>> symbols\n['A1', 'A2', 'A3', 'A5']"
  },
  {
    "function": "find_pure_symbols",
    "code": "def find_pure_symbols(\n    clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]\n) -> tuple[list[str], dict[str, bool | None]]:\n    \"\"\"\n    | Return pure symbols and their values to satisfy clause.\n    | Pure symbols are symbols in a formula that exist only in one form,\n    | either complemented or otherwise.\n    | For example,\n    |   {{A4 , A3 , A5' , A1 , A3'} , {A4} , {A3}} has pure symbols A4, A5' and A1.\n\n    This has the following steps:\n      1. Ignore clauses that have already evaluated to be ``True``.\n      2. Find symbols that occur only in one form in the rest of the clauses.\n      3. Assign value ``True`` or ``False`` depending on whether the symbols occurs\n         in normal or complemented form respectively.\n\n    >>> formula = Formula([Clause([\"A1\", \"A2'\", \"A3\"]), Clause([\"A5'\", \"A2'\", \"A1\"])])\n    >>> clauses, symbols = generate_parameters(formula)\n    >>> pure_symbols, values = find_pure_symbols(clauses, symbols, {})\n    >>> pure_symbols\n    ['A1', 'A2', 'A3', 'A5']\n    >>> values\n    {'A1': True, 'A2': False, 'A3': True, 'A5': False}\n    \"\"\"\n    pure_symbols = []\n    assignment: dict[str, bool | None] = {}\n    literals = []\n\n    for clause in clauses:\n        if clause.evaluate(model):\n            continue\n        for literal in clause.literals:\n            literals.append(literal)\n\n    for s in symbols:\n        sym = s + \"'\"\n        if (s in literals and sym not in literals) or (\n            s not in literals and sym in literals\n        ):\n            pure_symbols.append(s)\n    for p in pure_symbols:\n        assignment[p] = None\n    for s in pure_symbols:\n        sym = s + \"'\"\n        if s in literals:\n            assignment[s] = True\n        elif sym in literals:\n            assignment[s] = False\n    return pure_symbols, assignment",
    "docstring": "| Return pure symbols and their values to satisfy clause.\n| Pure symbols are symbols in a formula that exist only in one form,\n| either complemented or otherwise.\n| For example,\n|   {{A4 , A3 , A5' , A1 , A3'} , {A4} , {A3}} has pure symbols A4, A5' and A1.\n\nThis has the following steps:\n  1. Ignore clauses that have already evaluated to be ``True``.\n  2. Find symbols that occur only in one form in the rest of the clauses.\n  3. Assign value ``True`` or ``False`` depending on whether the symbols occurs\n     in normal or complemented form respectively.\n\n>>> formula = Formula([Clause([\"A1\", \"A2'\", \"A3\"]), Clause([\"A5'\", \"A2'\", \"A1\"])])\n>>> clauses, symbols = generate_parameters(formula)\n>>> pure_symbols, values = find_pure_symbols(clauses, symbols, {})\n>>> pure_symbols\n['A1', 'A2', 'A3', 'A5']\n>>> values\n{'A1': True, 'A2': False, 'A3': True, 'A5': False}"
  },
  {
    "function": "find_unit_clauses",
    "code": "def find_unit_clauses(\n    clauses: list[Clause],\n    model: dict[str, bool | None],  # noqa: ARG001\n) -> tuple[list[str], dict[str, bool | None]]:\n    \"\"\"\n    Returns the unit symbols and their values to satisfy clause.\n\n    Unit symbols are symbols in a formula that are:\n      - Either the only symbol in a clause\n      - Or all other literals in that clause have been assigned ``False``\n\n    This has the following steps:\n      1. Find symbols that are the only occurrences in a clause.\n      2. Find symbols in a clause where all other literals are assigned ``False``.\n      3. Assign ``True`` or ``False`` depending on whether the symbols occurs in\n         normal or complemented form respectively.\n\n    >>> clause1 = Clause([\"A4\", \"A3\", \"A5'\", \"A1\", \"A3'\"])\n    >>> clause2 = Clause([\"A4\"])\n    >>> clause3 = Clause([\"A3\"])\n    >>> clauses, symbols = generate_parameters(Formula([clause1, clause2, clause3]))\n    >>> unit_clauses, values = find_unit_clauses(clauses, {})\n    >>> unit_clauses\n    ['A4', 'A3']\n    >>> values\n    {'A4': True, 'A3': True}\n    \"\"\"\n    unit_symbols = []\n    for clause in clauses:\n        if len(clause) == 1:\n            unit_symbols.append(next(iter(clause.literals.keys())))\n        else:\n            f_count, n_count = 0, 0\n            for literal, value in clause.literals.items():\n                if value is False:\n                    f_count += 1\n                elif value is None:\n                    sym = literal\n                    n_count += 1\n            if f_count == len(clause) - 1 and n_count == 1:\n                unit_symbols.append(sym)\n    assignment: dict[str, bool | None] = {}\n    for i in unit_symbols:\n        symbol = i[:2]\n        assignment[symbol] = len(i) == 2\n    unit_symbols = [i[:2] for i in unit_symbols]\n\n    return unit_symbols, assignment",
    "docstring": "Returns the unit symbols and their values to satisfy clause.\n\nUnit symbols are symbols in a formula that are:\n  - Either the only symbol in a clause\n  - Or all other literals in that clause have been assigned ``False``\n\nThis has the following steps:\n  1. Find symbols that are the only occurrences in a clause.\n  2. Find symbols in a clause where all other literals are assigned ``False``.\n  3. Assign ``True`` or ``False`` depending on whether the symbols occurs in\n     normal or complemented form respectively.\n\n>>> clause1 = Clause([\"A4\", \"A3\", \"A5'\", \"A1\", \"A3'\"])\n>>> clause2 = Clause([\"A4\"])\n>>> clause3 = Clause([\"A3\"])\n>>> clauses, symbols = generate_parameters(Formula([clause1, clause2, clause3]))\n>>> unit_clauses, values = find_unit_clauses(clauses, {})\n>>> unit_clauses\n['A4', 'A3']\n>>> values\n{'A4': True, 'A3': True}"
  },
  {
    "function": "dpll_algorithm",
    "code": "def dpll_algorithm(\n    clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]\n) -> tuple[bool | None, dict[str, bool | None] | None]:\n    \"\"\"\n    Returns the model if the formula is satisfiable, else ``None``\n\n    This has the following steps:\n      1. If every clause in clauses is ``True``, return ``True``.\n      2. If some clause in clauses is ``False``, return ``False``.\n      3. Find pure symbols.\n      4. Find unit symbols.\n\n    >>> formula = Formula([Clause([\"A4\", \"A3\", \"A5'\", \"A1\", \"A3'\"]), Clause([\"A4\"])])\n    >>> clauses, symbols = generate_parameters(formula)\n    >>> soln, model = dpll_algorithm(clauses, symbols, {})\n    >>> soln\n    True\n    >>> model\n    {'A4': True}\n    \"\"\"\n    check_clause_all_true = True\n    for clause in clauses:\n        clause_check = clause.evaluate(model)\n        if clause_check is False:\n            return False, None\n        elif clause_check is None:\n            check_clause_all_true = False\n            continue\n\n    if check_clause_all_true:\n        return True, model\n\n    try:\n        pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)\n    except RecursionError:\n        print(\"raises a RecursionError and is\")\n        return None, {}\n    p = None\n    if len(pure_symbols) > 0:\n        p, value = pure_symbols[0], assignment[pure_symbols[0]]\n\n    if p:\n        tmp_model = model\n        tmp_model[p] = value\n        tmp_symbols = list(symbols)\n        if p in tmp_symbols:\n            tmp_symbols.remove(p)\n        return dpll_algorithm(clauses, tmp_symbols, tmp_model)\n\n    unit_symbols, assignment = find_unit_clauses(clauses, model)\n    p = None\n    if len(unit_symbols) > 0:\n        p, value = unit_symbols[0], assignment[unit_symbols[0]]\n    if p:\n        tmp_model = model\n        tmp_model[p] = value\n        tmp_symbols = list(symbols)\n        if p in tmp_symbols:\n            tmp_symbols.remove(p)\n        return dpll_algorithm(clauses, tmp_symbols, tmp_model)\n    p = symbols[0]\n    rest = symbols[1:]\n    tmp1, tmp2 = model, model\n    tmp1[p], tmp2[p] = True, False\n\n    return dpll_algorithm(clauses, rest, tmp1) or dpll_algorithm(clauses, rest, tmp2)",
    "docstring": "Returns the model if the formula is satisfiable, else ``None``\n\nThis has the following steps:\n  1. If every clause in clauses is ``True``, return ``True``.\n  2. If some clause in clauses is ``False``, return ``False``.\n  3. Find pure symbols.\n  4. Find unit symbols.\n\n>>> formula = Formula([Clause([\"A4\", \"A3\", \"A5'\", \"A1\", \"A3'\"]), Clause([\"A4\"])])\n>>> clauses, symbols = generate_parameters(formula)\n>>> soln, model = dpll_algorithm(clauses, symbols, {})\n>>> soln\nTrue\n>>> model\n{'A4': True}"
  },
  {
    "function": "get_week_day",
    "code": "def get_week_day(year: int, month: int, day: int) -> str:\n    \"\"\"Returns the week-day name out of a given date.\n\n    >>> get_week_day(2020, 10, 24)\n    'Saturday'\n    >>> get_week_day(2017, 10, 24)\n    'Tuesday'\n    >>> get_week_day(2019, 5, 3)\n    'Friday'\n    >>> get_week_day(1970, 9, 16)\n    'Wednesday'\n    >>> get_week_day(1870, 8, 13)\n    'Saturday'\n    >>> get_week_day(2040, 3, 14)\n    'Wednesday'\n\n    \"\"\"\n    # minimal input check:\n    assert len(str(year)) > 2, \"year should be in YYYY format\"\n    assert 1 <= month <= 12, \"month should be between 1 to 12\"\n    assert 1 <= day <= 31, \"day should be between 1 to 31\"\n\n    # Doomsday algorithm:\n    century = year // 100\n    century_anchor = (5 * (century % 4) + 2) % 7\n    centurian = year % 100\n    centurian_m = centurian % 12\n    dooms_day = (\n        (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor\n    ) % 7\n    day_anchor = (\n        DOOMSDAY_NOT_LEAP[month - 1]\n        if year % 4 != 0 or (centurian == 0 and year % 400 != 0)\n        else DOOMSDAY_LEAP[month - 1]\n    )\n    week_day = (dooms_day + day - day_anchor) % 7\n    return WEEK_DAY_NAMES[week_day]",
    "docstring": "Returns the week-day name out of a given date.\n\n>>> get_week_day(2020, 10, 24)\n'Saturday'\n>>> get_week_day(2017, 10, 24)\n'Tuesday'\n>>> get_week_day(2019, 5, 3)\n'Friday'\n>>> get_week_day(1970, 9, 16)\n'Wednesday'\n>>> get_week_day(1870, 8, 13)\n'Saturday'\n>>> get_week_day(2040, 3, 14)\n'Wednesday'"
  },
  {
    "function": "gauss_easter",
    "code": "def gauss_easter(year: int) -> datetime:\n    \"\"\"\n    Calculation Gregorian easter date for given year\n\n    >>> gauss_easter(2007)\n    datetime.datetime(2007, 4, 8, 0, 0, tzinfo=datetime.timezone.utc)\n\n    >>> gauss_easter(2008)\n    datetime.datetime(2008, 3, 23, 0, 0, tzinfo=datetime.timezone.utc)\n\n    >>> gauss_easter(2020)\n    datetime.datetime(2020, 4, 12, 0, 0, tzinfo=datetime.timezone.utc)\n\n    >>> gauss_easter(2021)\n    datetime.datetime(2021, 4, 4, 0, 0, tzinfo=datetime.timezone.utc)\n    \"\"\"\n    metonic_cycle = year % 19\n    julian_leap_year = year % 4\n    non_leap_year = year % 7\n    leap_day_inhibits = math.floor(year / 100)\n    lunar_orbit_correction = math.floor((13 + 8 * leap_day_inhibits) / 25)\n    leap_day_reinstall_number = leap_day_inhibits / 4\n    secular_moon_shift = (\n        15 - lunar_orbit_correction + leap_day_inhibits - leap_day_reinstall_number\n    ) % 30\n    century_starting_point = (4 + leap_day_inhibits - leap_day_reinstall_number) % 7\n\n    # days to be added to March 21\n    days_to_add = (19 * metonic_cycle + secular_moon_shift) % 30\n\n    # PHM -> Paschal Full Moon\n    days_from_phm_to_sunday = (\n        2 * julian_leap_year\n        + 4 * non_leap_year\n        + 6 * days_to_add\n        + century_starting_point\n    ) % 7\n\n    if days_to_add == 29 and days_from_phm_to_sunday == 6:\n        return datetime(year, 4, 19, tzinfo=UTC)\n    elif days_to_add == 28 and days_from_phm_to_sunday == 6:\n        return datetime(year, 4, 18, tzinfo=UTC)\n    else:\n        return datetime(year, 3, 22, tzinfo=UTC) + timedelta(\n            days=int(days_to_add + days_from_phm_to_sunday)\n        )",
    "docstring": "Calculation Gregorian easter date for given year\n\n>>> gauss_easter(2007)\ndatetime.datetime(2007, 4, 8, 0, 0, tzinfo=datetime.timezone.utc)\n\n>>> gauss_easter(2008)\ndatetime.datetime(2008, 3, 23, 0, 0, tzinfo=datetime.timezone.utc)\n\n>>> gauss_easter(2020)\ndatetime.datetime(2020, 4, 12, 0, 0, tzinfo=datetime.timezone.utc)\n\n>>> gauss_easter(2021)\ndatetime.datetime(2021, 4, 4, 0, 0, tzinfo=datetime.timezone.utc)"
  },
  {
    "function": "angle_comparer",
    "code": "def angle_comparer(point: tuple[int, int], minx: int, miny: int) -> float:\n    \"\"\"Return the angle toward to point from (minx, miny)\n\n    :param point: The target point\n           minx: The starting point's x\n           miny: The starting point's y\n    :return: the angle\n\n    Examples:\n    >>> angle_comparer((1,1), 0, 0)\n    45.0\n\n    >>> angle_comparer((100,1), 10, 10)\n    -5.710593137499642\n\n    >>> angle_comparer((5,5), 2, 3)\n    33.690067525979785\n    \"\"\"\n    # sort the points accorgind to the angle from the lowest and the most left point\n    x, y = point\n    return degrees(atan2(y - miny, x - minx))",
    "docstring": "Return the angle toward to point from (minx, miny)\n\n:param point: The target point\n       minx: The starting point's x\n       miny: The starting point's y\n:return: the angle\n\nExamples:\n>>> angle_comparer((1,1), 0, 0)\n45.0\n\n>>> angle_comparer((100,1), 10, 10)\n-5.710593137499642\n\n>>> angle_comparer((5,5), 2, 3)\n33.690067525979785"
  },
  {
    "function": "check_direction",
    "code": "def check_direction(\n    starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int]\n) -> Direction:\n    \"\"\"Return the direction toward to the line from via to target from starting\n\n    :param starting: The starting point\n           via: The via point\n           target: The target point\n    :return: the Direction\n\n    Examples:\n    >>> check_direction((1,1), (2,2), (3,3))\n    Direction.straight\n\n    >>> check_direction((60,1), (-50,199), (30,2))\n    Direction.left\n\n    >>> check_direction((0,0), (5,5), (10,0))\n    Direction.right\n    \"\"\"\n    x0, y0 = starting\n    x1, y1 = via\n    x2, y2 = target\n    via_angle = degrees(atan2(y1 - y0, x1 - x0))\n    via_angle %= 360\n    target_angle = degrees(atan2(y2 - y0, x2 - x0))\n    target_angle %= 360\n    # t-\n    #  \\ \\\n    #   \\ v\n    #    \\|\n    #     s\n    # via_angle is always lower than target_angle, if direction is left.\n    # If they are same, it means they are on a same line of convex hull.\n    if target_angle > via_angle:\n        return Direction.left\n    elif target_angle == via_angle:\n        return Direction.straight\n    else:\n        return Direction.right",
    "docstring": "Return the direction toward to the line from via to target from starting\n\n:param starting: The starting point\n       via: The via point\n       target: The target point\n:return: the Direction\n\nExamples:\n>>> check_direction((1,1), (2,2), (3,3))\nDirection.straight\n\n>>> check_direction((60,1), (-50,199), (30,2))\nDirection.left\n\n>>> check_direction((0,0), (5,5), (10,0))\nDirection.right"
  },
  {
    "function": "graham_scan",
    "code": "def graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:\n    \"\"\"Pure implementation of graham scan algorithm in Python\n\n    :param points: The unique points on coordinates.\n    :return: The points on convex hell.\n\n    Examples:\n    >>> graham_scan([(9, 6), (3, 1), (0, 0), (5, 5), (5, 2), (7, 0), (3, 3), (1, 4)])\n    [(0, 0), (7, 0), (9, 6), (5, 5), (1, 4)]\n\n    >>> graham_scan([(0, 0), (1, 0), (1, 1), (0, 1)])\n    [(0, 0), (1, 0), (1, 1), (0, 1)]\n\n    >>> graham_scan([(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)])\n    [(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)]\n\n    >>> graham_scan([(-100, 20), (99, 3), (1, 10000001), (5133186, -25), (-66, -4)])\n    [(5133186, -25), (1, 10000001), (-100, 20), (-66, -4)]\n    \"\"\"\n\n    if len(points) <= 2:\n        # There is no convex hull\n        raise ValueError(\"graham_scan: argument must contain more than 3 points.\")\n    if len(points) == 3:\n        return points\n    # find the lowest and the most left point\n    minidx = 0\n    miny, minx = maxsize, maxsize\n    for i, point in enumerate(points):\n        x = point[0]\n        y = point[1]\n        if y < miny:\n            miny = y\n            minx = x\n            minidx = i\n        if y == miny and x < minx:\n            minx = x\n            minidx = i\n\n    # remove the lowest and the most left point from points for preparing for sort\n    points.pop(minidx)\n\n    sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))\n    # This insert actually costs complexity,\n    # and you should instead add (minx, miny) into stack later.\n    # I'm using insert just for easy understanding.\n    sorted_points.insert(0, (minx, miny))\n\n    stack: deque[tuple[int, int]] = deque()\n    stack.append(sorted_points[0])\n    stack.append(sorted_points[1])\n    stack.append(sorted_points[2])\n    # The first 3 points lines are towards the left because we sort them by their angle\n    # from minx, miny.\n    current_direction = Direction.left\n\n    for i in range(3, len(sorted_points)):\n        while True:\n            starting = stack[-2]\n            via = stack[-1]\n            target = sorted_points[i]\n            next_direction = check_direction(starting, via, target)\n\n            if next_direction == Direction.left:\n                current_direction = Direction.left\n                break\n            if next_direction == Direction.straight:\n                if current_direction == Direction.left:\n                    # We keep current_direction as left.\n                    # Because if the straight line keeps as straight,\n                    # we want to know if this straight line is towards left.\n                    break\n                elif current_direction == Direction.right:\n                    # If the straight line is towards right,\n                    # every previous points on that straight line is not convex hull.\n                    stack.pop()\n            if next_direction == Direction.right:\n                stack.pop()\n        stack.append(sorted_points[i])\n    return list(stack)",
    "docstring": "Pure implementation of graham scan algorithm in Python\n\n:param points: The unique points on coordinates.\n:return: The points on convex hell.\n\nExamples:\n>>> graham_scan([(9, 6), (3, 1), (0, 0), (5, 5), (5, 2), (7, 0), (3, 3), (1, 4)])\n[(0, 0), (7, 0), (9, 6), (5, 5), (1, 4)]\n\n>>> graham_scan([(0, 0), (1, 0), (1, 1), (0, 1)])\n[(0, 0), (1, 0), (1, 1), (0, 1)]\n\n>>> graham_scan([(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)])\n[(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)]\n\n>>> graham_scan([(-100, 20), (99, 3), (1, 10000001), (5133186, -25), (-66, -4)])\n[(5133186, -25), (1, 10000001), (-100, 20), (-66, -4)]"
  },
  {
    "function": "test_greedy",
    "code": "def test_greedy():\n    \"\"\"\n    >>> food = [\"Burger\", \"Pizza\", \"Coca Cola\", \"Rice\",\n    ...         \"Sambhar\", \"Chicken\", \"Fries\", \"Milk\"]\n    >>> value = [80, 100, 60, 70, 50, 110, 90, 60]\n    >>> weight = [40, 60, 40, 70, 100, 85, 55, 70]\n    >>> foods = build_menu(food, value, weight)\n    >>> foods  # doctest: +NORMALIZE_WHITESPACE\n    [Things(Burger, 80, 40), Things(Pizza, 100, 60), Things(Coca Cola, 60, 40),\n     Things(Rice, 70, 70), Things(Sambhar, 50, 100), Things(Chicken, 110, 85),\n     Things(Fries, 90, 55), Things(Milk, 60, 70)]\n    >>> greedy(foods, 500, Things.get_value)  # doctest: +NORMALIZE_WHITESPACE\n    ([Things(Chicken, 110, 85), Things(Pizza, 100, 60), Things(Fries, 90, 55),\n      Things(Burger, 80, 40), Things(Rice, 70, 70), Things(Coca Cola, 60, 40),\n      Things(Milk, 60, 70)], 570.0)\n    \"\"\"",
    "docstring": ">>> food = [\"Burger\", \"Pizza\", \"Coca Cola\", \"Rice\",\n...         \"Sambhar\", \"Chicken\", \"Fries\", \"Milk\"]\n>>> value = [80, 100, 60, 70, 50, 110, 90, 60]\n>>> weight = [40, 60, 40, 70, 100, 85, 55, 70]\n>>> foods = build_menu(food, value, weight)\n>>> foods  # doctest: +NORMALIZE_WHITESPACE\n[Things(Burger, 80, 40), Things(Pizza, 100, 60), Things(Coca Cola, 60, 40),\n Things(Rice, 70, 70), Things(Sambhar, 50, 100), Things(Chicken, 110, 85),\n Things(Fries, 90, 55), Things(Milk, 60, 70)]\n>>> greedy(foods, 500, Things.get_value)  # doctest: +NORMALIZE_WHITESPACE\n([Things(Chicken, 110, 85), Things(Pizza, 100, 60), Things(Fries, 90, 55),\n  Things(Burger, 80, 40), Things(Rice, 70, 70), Things(Coca Cola, 60, 40),\n  Things(Milk, 60, 70)], 570.0)"
  },
  {
    "function": "temp_input_value",
    "code": "def temp_input_value(\n    min_val: int = 10, max_val: int = 1000, option: bool = True\n) -> int:\n    \"\"\"\n    Temporary input values for tests\n\n    >>> temp_input_value(option=True)\n    10\n\n    >>> temp_input_value(option=False)\n    1000\n\n    >>> temp_input_value(min_val=100, option=True)\n    100\n\n    >>> temp_input_value(min_val=100, max_val=50)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid value for min_val or max_val (min_value < max_value)\n\n    >>> temp_input_value(\"ten\",\"fifty\",1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: Invalid type of value(s) specified to function!\n\n    >>> temp_input_value(min_val=-100, max_val=500)\n    -100\n\n    >>> temp_input_value(min_val=-5100, max_val=-100)\n    -5100\n    \"\"\"\n    assert (\n        isinstance(min_val, int)\n        and isinstance(max_val, int)\n        and isinstance(option, bool)\n    ), \"Invalid type of value(s) specified to function!\"\n\n    if min_val > max_val:\n        raise ValueError(\"Invalid value for min_val or max_val (min_value < max_value)\")\n    return min_val if option else max_val",
    "docstring": "Temporary input values for tests\n\n>>> temp_input_value(option=True)\n10\n\n>>> temp_input_value(option=False)\n1000\n\n>>> temp_input_value(min_val=100, option=True)\n100\n\n>>> temp_input_value(min_val=100, max_val=50)\nTraceback (most recent call last):\n    ...\nValueError: Invalid value for min_val or max_val (min_value < max_value)\n\n>>> temp_input_value(\"ten\",\"fifty\",1)\nTraceback (most recent call last):\n    ...\nAssertionError: Invalid type of value(s) specified to function!\n\n>>> temp_input_value(min_val=-100, max_val=500)\n-100\n\n>>> temp_input_value(min_val=-5100, max_val=-100)\n-5100"
  },
  {
    "function": "get_avg",
    "code": "def get_avg(number_1: int, number_2: int) -> int:\n    \"\"\"\n    Return the mid-number(whole) of two integers a and b\n\n    >>> get_avg(10, 15)\n    12\n\n    >>> get_avg(20, 300)\n    160\n\n    >>> get_avg(\"abcd\", 300)\n    Traceback (most recent call last):\n        ...\n    TypeError: can only concatenate str (not \"int\") to str\n\n    >>> get_avg(10.5,50.25)\n    30\n    \"\"\"\n    return int((number_1 + number_2) / 2)",
    "docstring": "Return the mid-number(whole) of two integers a and b\n\n>>> get_avg(10, 15)\n12\n\n>>> get_avg(20, 300)\n160\n\n>>> get_avg(\"abcd\", 300)\nTraceback (most recent call last):\n    ...\nTypeError: can only concatenate str (not \"int\") to str\n\n>>> get_avg(10.5,50.25)\n30"
  },
  {
    "function": "guess_the_number",
    "code": "def guess_the_number(lower: int, higher: int, to_guess: int) -> None:\n    \"\"\"\n    The `guess_the_number` function that guess the number by some operations\n    and using inner functions\n\n    >>> guess_the_number(10, 1000, 17)\n    started...\n    guess the number : 17\n    details : [505, 257, 133, 71, 40, 25, 17]\n\n    >>> guess_the_number(-10000, 10000, 7)\n    started...\n    guess the number : 7\n    details : [0, 5000, 2500, 1250, 625, 312, 156, 78, 39, 19, 9, 4, 6, 7]\n\n    >>> guess_the_number(10, 1000, \"a\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: argument values must be type of \"int\"\n\n    >>> guess_the_number(10, 1000, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: guess value must be within the range of lower and higher value\n\n    >>> guess_the_number(10000, 100, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: argument value for lower and higher must be(lower > higher)\n    \"\"\"\n    assert (\n        isinstance(lower, int) and isinstance(higher, int) and isinstance(to_guess, int)\n    ), 'argument values must be type of \"int\"'\n\n    if lower > higher:\n        raise ValueError(\"argument value for lower and higher must be(lower > higher)\")\n\n    if not lower < to_guess < higher:\n        raise ValueError(\n            \"guess value must be within the range of lower and higher value\"\n        )\n\n    def answer(number: int) -> str:\n        \"\"\"\n        Returns value by comparing with entered `to_guess` number\n        \"\"\"\n        if number > to_guess:\n            return \"high\"\n        elif number < to_guess:\n            return \"low\"\n        else:\n            return \"same\"\n\n    print(\"started...\")\n\n    last_lowest = lower\n    last_highest = higher\n\n    last_numbers = []\n\n    while True:\n        number = get_avg(last_lowest, last_highest)\n        last_numbers.append(number)\n\n        if answer(number) == \"low\":\n            last_lowest = number\n        elif answer(number) == \"high\":\n            last_highest = number\n        else:\n            break\n\n    print(f\"guess the number : {last_numbers[-1]}\")\n    print(f\"details : {last_numbers!s}\")",
    "docstring": "The `guess_the_number` function that guess the number by some operations\nand using inner functions\n\n>>> guess_the_number(10, 1000, 17)\nstarted...\nguess the number : 17\ndetails : [505, 257, 133, 71, 40, 25, 17]\n\n>>> guess_the_number(-10000, 10000, 7)\nstarted...\nguess the number : 7\ndetails : [0, 5000, 2500, 1250, 625, 312, 156, 78, 39, 19, 9, 4, 6, 7]\n\n>>> guess_the_number(10, 1000, \"a\")\nTraceback (most recent call last):\n    ...\nAssertionError: argument values must be type of \"int\"\n\n>>> guess_the_number(10, 1000, 5)\nTraceback (most recent call last):\n    ...\nValueError: guess value must be within the range of lower and higher value\n\n>>> guess_the_number(10000, 100, 5)\nTraceback (most recent call last):\n    ...\nValueError: argument value for lower and higher must be(lower > higher)"
  },
  {
    "function": "main",
    "code": "def main() -> None:\n    \"\"\"\n    starting point or function of script\n    \"\"\"\n    lower = int(input(\"Enter lower value : \").strip())\n    higher = int(input(\"Enter high value : \").strip())\n    guess = int(input(\"Enter value to guess : \").strip())\n    guess_the_number(lower, higher, guess)",
    "docstring": "starting point or function of script"
  },
  {
    "function": "h_index",
    "code": "def h_index(citations: list[int]) -> int:\n    \"\"\"\n    Return H-index of citations\n\n    >>> h_index([3, 0, 6, 1, 5])\n    3\n    >>> h_index([1, 3, 1])\n    1\n    >>> h_index([1, 2, 3])\n    2\n    >>> h_index('test')\n    Traceback (most recent call last):\n        ...\n    ValueError: The citations should be a list of non negative integers.\n    >>> h_index([1,2,'3'])\n    Traceback (most recent call last):\n        ...\n    ValueError: The citations should be a list of non negative integers.\n    >>> h_index([1,2,-3])\n    Traceback (most recent call last):\n        ...\n    ValueError: The citations should be a list of non negative integers.\n    \"\"\"\n\n    # validate:\n    if not isinstance(citations, list) or not all(\n        isinstance(item, int) and item >= 0 for item in citations\n    ):\n        raise ValueError(\"The citations should be a list of non negative integers.\")\n\n    citations.sort()\n    len_citations = len(citations)\n\n    for i in range(len_citations):\n        if citations[len_citations - 1 - i] <= i:\n            return i\n\n    return len_citations",
    "docstring": "Return H-index of citations\n\n>>> h_index([3, 0, 6, 1, 5])\n3\n>>> h_index([1, 3, 1])\n1\n>>> h_index([1, 2, 3])\n2\n>>> h_index('test')\nTraceback (most recent call last):\n    ...\nValueError: The citations should be a list of non negative integers.\n>>> h_index([1,2,'3'])\nTraceback (most recent call last):\n    ...\nValueError: The citations should be a list of non negative integers.\n>>> h_index([1,2,-3])\nTraceback (most recent call last):\n    ...\nValueError: The citations should be a list of non negative integers."
  },
  {
    "function": "floyd",
    "code": "def floyd(n):\n    \"\"\"\n    Print the upper half of a diamond pattern with '*' characters.\n\n    Args:\n        n (int): Size of the pattern.\n\n    Examples:\n        >>> floyd(3)\n        '  * \\\\n * * \\\\n* * * \\\\n'\n\n        >>> floyd(5)\n        '    * \\\\n   * * \\\\n  * * * \\\\n * * * * \\\\n* * * * * \\\\n'\n    \"\"\"\n    result = \"\"\n    for i in range(n):\n        for _ in range(n - i - 1):  # printing spaces\n            result += \" \"\n        for _ in range(i + 1):  # printing stars\n            result += \"* \"\n        result += \"\\n\"\n    return result",
    "docstring": "Print the upper half of a diamond pattern with '*' characters.\n\nArgs:\n    n (int): Size of the pattern.\n\nExamples:\n    >>> floyd(3)\n    '  * \\n * * \\n* * * \\n'\n\n    >>> floyd(5)\n    '    * \\n   * * \\n  * * * \\n * * * * \\n* * * * * \\n'"
  },
  {
    "function": "reverse_floyd",
    "code": "def reverse_floyd(n):\n    \"\"\"\n    Print the lower half of a diamond pattern with '*' characters.\n\n    Args:\n        n (int): Size of the pattern.\n\n    Examples:\n        >>> reverse_floyd(3)\n        '* * * \\\\n * * \\\\n  * \\\\n   '\n\n        >>> reverse_floyd(5)\n        '* * * * * \\\\n * * * * \\\\n  * * * \\\\n   * * \\\\n    * \\\\n     '\n    \"\"\"\n    result = \"\"\n    for i in range(n, 0, -1):\n        for _ in range(i, 0, -1):  # printing stars\n            result += \"* \"\n        result += \"\\n\"\n        for _ in range(n - i + 1, 0, -1):  # printing spaces\n            result += \" \"\n    return result",
    "docstring": "Print the lower half of a diamond pattern with '*' characters.\n\nArgs:\n    n (int): Size of the pattern.\n\nExamples:\n    >>> reverse_floyd(3)\n    '* * * \\n * * \\n  * \\n   '\n\n    >>> reverse_floyd(5)\n    '* * * * * \\n * * * * \\n  * * * \\n   * * \\n    * \\n     '"
  },
  {
    "function": "pretty_print",
    "code": "def pretty_print(n):\n    \"\"\"\n    Print a complete diamond pattern with '*' characters.\n\n    Args:\n        n (int): Size of the pattern.\n\n    Examples:\n        >>> pretty_print(0)\n        '       ...       ....        nothing printing :('\n\n        >>> pretty_print(3)\n        '  * \\\\n * * \\\\n* * * \\\\n* * * \\\\n * * \\\\n  * \\\\n   '\n    \"\"\"\n    if n <= 0:\n        return \"       ...       ....        nothing printing :(\"\n    upper_half = floyd(n)  # upper half\n    lower_half = reverse_floyd(n)  # lower half\n    return upper_half + lower_half",
    "docstring": "Print a complete diamond pattern with '*' characters.\n\nArgs:\n    n (int): Size of the pattern.\n\nExamples:\n    >>> pretty_print(0)\n    '       ...       ....        nothing printing :('\n\n    >>> pretty_print(3)\n    '  * \\n * * \\n* * * \\n* * * \\n * * \\n  * \\n   '"
  },
  {
    "function": "majority_vote",
    "code": "def majority_vote(votes: list[int], votes_needed_to_win: int) -> list[int]:\n    \"\"\"\n    >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 3)\n    [2]\n    >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 2)\n    []\n    >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 4)\n    [1, 2, 3]\n    \"\"\"\n    majority_candidate_counter: Counter[int] = Counter()\n    for vote in votes:\n        majority_candidate_counter[vote] += 1\n        if len(majority_candidate_counter) == votes_needed_to_win:\n            majority_candidate_counter -= Counter(set(majority_candidate_counter))\n    majority_candidate_counter = Counter(\n        vote for vote in votes if vote in majority_candidate_counter\n    )\n    return [\n        vote\n        for vote in majority_candidate_counter\n        if majority_candidate_counter[vote] > len(votes) / votes_needed_to_win\n    ]",
    "docstring": ">>> majority_vote([1, 2, 2, 3, 1, 3, 2], 3)\n[2]\n>>> majority_vote([1, 2, 2, 3, 1, 3, 2], 2)\n[]\n>>> majority_vote([1, 2, 2, 3, 1, 3, 2], 4)\n[1, 2, 3]"
  },
  {
    "function": "max_subsequence_sum",
    "code": "def max_subsequence_sum(nums: Sequence[int] | None = None) -> int:\n    \"\"\"Return the maximum possible sum amongst all non - empty subsequences.\n\n    Raises:\n      ValueError: when nums is empty.\n\n    >>> max_subsequence_sum([1,2,3,4,-2])\n    10\n    >>> max_subsequence_sum([-2, -3, -1, -4, -6])\n    -1\n    >>> max_subsequence_sum([])\n    Traceback (most recent call last):\n        . . .\n    ValueError: Input sequence should not be empty\n    >>> max_subsequence_sum()\n    Traceback (most recent call last):\n        . . .\n    ValueError: Input sequence should not be empty\n    \"\"\"\n    if nums is None or not nums:\n        raise ValueError(\"Input sequence should not be empty\")\n\n    ans = nums[0]\n    for i in range(1, len(nums)):\n        num = nums[i]\n        ans = max(ans, ans + num, num)\n\n    return ans",
    "docstring": "Return the maximum possible sum amongst all non - empty subsequences.\n\nRaises:\n  ValueError: when nums is empty.\n\n>>> max_subsequence_sum([1,2,3,4,-2])\n10\n>>> max_subsequence_sum([-2, -3, -1, -4, -6])\n-1\n>>> max_subsequence_sum([])\nTraceback (most recent call last):\n    . . .\nValueError: Input sequence should not be empty\n>>> max_subsequence_sum()\nTraceback (most recent call last):\n    . . .\nValueError: Input sequence should not be empty"
  },
  {
    "function": "is_balanced",
    "code": "def is_balanced(s: str) -> bool:\n    \"\"\"\n    >>> is_balanced(\"\")\n    True\n    >>> is_balanced(\"()\")\n    True\n    >>> is_balanced(\"[]\")\n    True\n    >>> is_balanced(\"{}\")\n    True\n    >>> is_balanced(\"()[]{}\")\n    True\n    >>> is_balanced(\"(())\")\n    True\n    >>> is_balanced(\"[[\")\n    False\n    >>> is_balanced(\"([{}])\")\n    True\n    >>> is_balanced(\"(()[)]\")\n    False\n    >>> is_balanced(\"([)]\")\n    False\n    >>> is_balanced(\"[[()]]\")\n    True\n    >>> is_balanced(\"(()(()))\")\n    True\n    >>> is_balanced(\"]\")\n    False\n    >>> is_balanced(\"Life is a bowl of cherries.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che{}ies.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che}{ies.\")\n    False\n    \"\"\"\n    open_to_closed = {\"{\": \"}\", \"[\": \"]\", \"(\": \")\"}\n    stack = []\n    for symbol in s:\n        if symbol in open_to_closed:\n            stack.append(symbol)\n        elif symbol in open_to_closed.values() and (\n            not stack or open_to_closed[stack.pop()] != symbol\n        ):\n            return False\n    return not stack  # stack should be empty",
    "docstring": ">>> is_balanced(\"\")\nTrue\n>>> is_balanced(\"()\")\nTrue\n>>> is_balanced(\"[]\")\nTrue\n>>> is_balanced(\"{}\")\nTrue\n>>> is_balanced(\"()[]{}\")\nTrue\n>>> is_balanced(\"(())\")\nTrue\n>>> is_balanced(\"[[\")\nFalse\n>>> is_balanced(\"([{}])\")\nTrue\n>>> is_balanced(\"(()[)]\")\nFalse\n>>> is_balanced(\"([)]\")\nFalse\n>>> is_balanced(\"[[()]]\")\nTrue\n>>> is_balanced(\"(()(()))\")\nTrue\n>>> is_balanced(\"]\")\nFalse\n>>> is_balanced(\"Life is a bowl of cherries.\")\nTrue\n>>> is_balanced(\"Life is a bowl of che{}ies.\")\nTrue\n>>> is_balanced(\"Life is a bowl of che}{ies.\")\nFalse"
  },
  {
    "function": "password_generator",
    "code": "def password_generator(length: int = 8) -> str:\n    \"\"\"\n    Password Generator allows you to generate a random password of length N.\n\n    >>> len(password_generator())\n    8\n    >>> len(password_generator(length=16))\n    16\n    >>> len(password_generator(257))\n    257\n    >>> len(password_generator(length=0))\n    0\n    >>> len(password_generator(-1))\n    0\n    \"\"\"\n    chars = ascii_letters + digits + punctuation\n    return \"\".join(secrets.choice(chars) for _ in range(length))",
    "docstring": "Password Generator allows you to generate a random password of length N.\n\n>>> len(password_generator())\n8\n>>> len(password_generator(length=16))\n16\n>>> len(password_generator(257))\n257\n>>> len(password_generator(length=0))\n0\n>>> len(password_generator(-1))\n0"
  },
  {
    "function": "is_strong_password",
    "code": "def is_strong_password(password: str, min_length: int = 8) -> bool:\n    \"\"\"\n    This will check whether a given password is strong or not. The password must be at\n    least as long as the provided minimum length, and it must contain at least 1\n    lowercase letter, 1 uppercase letter, 1 number and 1 special character.\n\n    >>> is_strong_password('Hwea7$2!')\n    True\n    >>> is_strong_password('Sh0r1')\n    False\n    >>> is_strong_password('Hello123')\n    False\n    >>> is_strong_password('Hello1238udfhiaf038fajdvjjf!jaiuFhkqi1')\n    True\n    >>> is_strong_password('0')\n    False\n    \"\"\"\n\n    if len(password) < min_length:\n        return False\n\n    upper = any(char in ascii_uppercase for char in password)\n    lower = any(char in ascii_lowercase for char in password)\n    num = any(char in digits for char in password)\n    spec_char = any(char in punctuation for char in password)\n\n    return upper and lower and num and spec_char",
    "docstring": "This will check whether a given password is strong or not. The password must be at\nleast as long as the provided minimum length, and it must contain at least 1\nlowercase letter, 1 uppercase letter, 1 number and 1 special character.\n\n>>> is_strong_password('Hwea7$2!')\nTrue\n>>> is_strong_password('Sh0r1')\nFalse\n>>> is_strong_password('Hello123')\nFalse\n>>> is_strong_password('Hello1238udfhiaf038fajdvjjf!jaiuFhkqi1')\nTrue\n>>> is_strong_password('0')\nFalse"
  },
  {
    "function": "get_data",
    "code": "def get_data(source_data: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])\n    [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]\n    \"\"\"\n    data_lists: list[list[float]] = []\n    for data in source_data:\n        for i, el in enumerate(data):\n            if len(data_lists) < i + 1:\n                data_lists.append([])\n            data_lists[i].append(float(el))\n    return data_lists",
    "docstring": ">>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])\n[[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]"
  },
  {
    "function": "calculate_each_score",
    "code": "def calculate_each_score(\n    data_lists: list[list[float]], weights: list[int]\n) -> list[list[float]]:\n    \"\"\"\n    >>> calculate_each_score([[20, 23, 22], [60, 90, 50], [2012, 2015, 2011]],\n    ...                      [0, 0, 1])\n    [[1.0, 0.0, 0.33333333333333337], [0.75, 0.0, 1.0], [0.25, 1.0, 0.0]]\n    \"\"\"\n    score_lists: list[list[float]] = []\n    for dlist, weight in zip(data_lists, weights):\n        mind = min(dlist)\n        maxd = max(dlist)\n\n        score: list[float] = []\n        # for weight 0 score is 1 - actual score\n        if weight == 0:\n            for item in dlist:\n                try:\n                    score.append(1 - ((item - mind) / (maxd - mind)))\n                except ZeroDivisionError:\n                    score.append(1)\n\n        elif weight == 1:\n            for item in dlist:\n                try:\n                    score.append((item - mind) / (maxd - mind))\n                except ZeroDivisionError:\n                    score.append(0)\n\n        # weight not 0 or 1\n        else:\n            msg = f\"Invalid weight of {weight:f} provided\"\n            raise ValueError(msg)\n\n        score_lists.append(score)\n\n    return score_lists",
    "docstring": ">>> calculate_each_score([[20, 23, 22], [60, 90, 50], [2012, 2015, 2011]],\n...                      [0, 0, 1])\n[[1.0, 0.0, 0.33333333333333337], [0.75, 0.0, 1.0], [0.25, 1.0, 0.0]]"
  },
  {
    "function": "generate_final_scores",
    "code": "def generate_final_scores(score_lists: list[list[float]]) -> list[float]:\n    \"\"\"\n    >>> generate_final_scores([[1.0, 0.0, 0.33333333333333337],\n    ...                        [0.75, 0.0, 1.0],\n    ...                        [0.25, 1.0, 0.0]])\n    [2.0, 1.0, 1.3333333333333335]\n    \"\"\"\n    # initialize final scores\n    final_scores: list[float] = [0 for i in range(len(score_lists[0]))]\n\n    for slist in score_lists:\n        for j, ele in enumerate(slist):\n            final_scores[j] = final_scores[j] + ele\n\n    return final_scores",
    "docstring": ">>> generate_final_scores([[1.0, 0.0, 0.33333333333333337],\n...                        [0.75, 0.0, 1.0],\n...                        [0.25, 1.0, 0.0]])\n[2.0, 1.0, 1.3333333333333335]"
  },
  {
    "function": "procentual_proximity",
    "code": "def procentual_proximity(\n    source_data: list[list[float]], weights: list[int]\n) -> list[list[float]]:\n    \"\"\"\n    | `weights` - ``int`` list\n    | possible values - ``0`` / ``1``\n\n        * ``0`` if lower values have higher weight in the data set\n        * ``1`` if higher values have higher weight in the data set\n\n    >>> procentual_proximity([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]], [0, 0, 1])\n    [[20, 60, 2012, 2.0], [23, 90, 2015, 1.0], [22, 50, 2011, 1.3333333333333335]]\n    \"\"\"\n\n    data_lists = get_data(source_data)\n    score_lists = calculate_each_score(data_lists, weights)\n    final_scores = generate_final_scores(score_lists)\n\n    # append scores to source data\n    for i, ele in enumerate(final_scores):\n        source_data[i].append(ele)\n\n    return source_data",
    "docstring": "| `weights` - ``int`` list\n| possible values - ``0`` / ``1``\n\n    * ``0`` if lower values have higher weight in the data set\n    * ``1`` if higher values have higher weight in the data set\n\n>>> procentual_proximity([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]], [0, 0, 1])\n[[20, 60, 2012, 2.0], [23, 90, 2015, 1.0], [22, 50, 2011, 1.3333333333333335]]"
  },
  {
    "function": "apply_table",
    "code": "def apply_table(inp, table):\n    \"\"\"\n    >>> apply_table(\"0123456789\", list(range(10)))\n    '9012345678'\n    >>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n    '8765432109'\n    \"\"\"\n    res = \"\"\n    for i in table:\n        res += inp[i - 1]\n    return res",
    "docstring": ">>> apply_table(\"0123456789\", list(range(10)))\n'9012345678'\n>>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n'8765432109'"
  },
  {
    "function": "left_shift",
    "code": "def left_shift(data):\n    \"\"\"\n    >>> left_shift(\"0123456789\")\n    '1234567890'\n    \"\"\"\n    return data[1:] + data[0]",
    "docstring": ">>> left_shift(\"0123456789\")\n'1234567890'"
  },
  {
    "function": "xor",
    "code": "def xor(a, b):\n    \"\"\"\n    >>> xor(\"01010101\", \"00001111\")\n    '01011010'\n    \"\"\"\n    res = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            res += \"0\"\n        else:\n            res += \"1\"\n    return res",
    "docstring": ">>> xor(\"01010101\", \"00001111\")\n'01011010'"
  },
  {
    "function": "move_tower",
    "code": "def move_tower(height, from_pole, to_pole, with_pole):\n    \"\"\"\n    >>> move_tower(3, 'A', 'B', 'C')\n    moving disk from A to B\n    moving disk from A to C\n    moving disk from B to C\n    moving disk from A to B\n    moving disk from C to A\n    moving disk from C to B\n    moving disk from A to B\n    \"\"\"\n    if height >= 1:\n        move_tower(height - 1, from_pole, with_pole, to_pole)\n        move_disk(from_pole, to_pole)\n        move_tower(height - 1, with_pole, to_pole, from_pole)",
    "docstring": ">>> move_tower(3, 'A', 'B', 'C')\nmoving disk from A to B\nmoving disk from A to C\nmoving disk from B to C\nmoving disk from A to B\nmoving disk from C to A\nmoving disk from C to B\nmoving disk from A to B"
  },
  {
    "function": "visualise_word_search",
    "code": "def visualise_word_search(\n    board: list[list[str | None]] | None = None, *, add_fake_chars: bool = True\n) -> None:\n    \"\"\"\n    Graphically displays the word search in the terminal.\n\n    >>> ws = WordSearch(WORDS, 5, 5)\n    >>> ws.insert_north(\"cat\", [4], [4])\n    >>> visualise_word_search(\n    ...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE\n    # # # # #\n    # # # # #\n    # # # # t\n    # # # # a\n    # # # # c\n    >>> ws.insert_northeast(\"snake\", [4], [4, 3, 2, 1, 0])\n    >>> visualise_word_search(\n    ...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE\n    # # # # e\n    # # # k #\n    # # a # t\n    # n # # a\n    s # # # c\n    \"\"\"\n    if board is None:\n        word_search = WordSearch(WORDS, WIDTH, HEIGHT)\n        word_search.generate_board()\n        board = word_search.board\n\n    result = \"\"\n    for row in range(len(board)):\n        for col in range(len(board[0])):\n            character = \"#\"\n            if (letter := board[row][col]) is not None:\n                character = letter\n            # Empty char, so add a fake char\n            elif add_fake_chars:\n                character = chr(randint(97, 122))\n            result += f\"{character} \"\n        result += \"\\n\"\n    print(result, end=\"\")",
    "docstring": "Graphically displays the word search in the terminal.\n\n>>> ws = WordSearch(WORDS, 5, 5)\n>>> ws.insert_north(\"cat\", [4], [4])\n>>> visualise_word_search(\n...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE\n# # # # #\n# # # # #\n# # # # t\n# # # # a\n# # # # c\n>>> ws.insert_northeast(\"snake\", [4], [4, 3, 2, 1, 0])\n>>> visualise_word_search(\n...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE\n# # # # e\n# # # k #\n# # a # t\n# n # # a\ns # # # c"
  },
  {
    "function": "get_altitude_at_pressure",
    "code": "def get_altitude_at_pressure(pressure: float) -> float:\n    \"\"\"\n    This method calculates the altitude from Pressure wrt to\n    Sea level pressure as reference .Pressure is in Pascals\n    https://en.wikipedia.org/wiki/Pressure_altitude\n    https://community.bosch-sensortec.com/t5/Question-and-answers/How-to-calculate-the-altitude-from-the-pressure-sensor-data/qaq-p/5702\n\n    H = 44330 * [1 - (P/p0)^(1/5.255) ]\n\n    Where :\n    H = altitude (m)\n    P = measured pressure\n    p0 = reference pressure at sea level 101325 Pa\n\n    Examples:\n    >>> get_altitude_at_pressure(pressure=100_000)\n    105.47836610778828\n    >>> get_altitude_at_pressure(pressure=101_325)\n    0.0\n    >>> get_altitude_at_pressure(pressure=80_000)\n    1855.873388064995\n    >>> get_altitude_at_pressure(pressure=201_325)\n    Traceback (most recent call last):\n      ...\n    ValueError: Value Higher than Pressure at Sea Level !\n    >>> get_altitude_at_pressure(pressure=-80_000)\n    Traceback (most recent call last):\n      ...\n    ValueError: Atmospheric Pressure can not be negative !\n    \"\"\"\n\n    if pressure > 101325:\n        raise ValueError(\"Value Higher than Pressure at Sea Level !\")\n    if pressure < 0:\n        raise ValueError(\"Atmospheric Pressure can not be negative !\")\n    return 44_330 * (1 - (pressure / 101_325) ** (1 / 5.5255))",
    "docstring": "This method calculates the altitude from Pressure wrt to\nSea level pressure as reference .Pressure is in Pascals\nhttps://en.wikipedia.org/wiki/Pressure_altitude\nhttps://community.bosch-sensortec.com/t5/Question-and-answers/How-to-calculate-the-altitude-from-the-pressure-sensor-data/qaq-p/5702\n\nH = 44330 * [1 - (P/p0)^(1/5.255) ]\n\nWhere :\nH = altitude (m)\nP = measured pressure\np0 = reference pressure at sea level 101325 Pa\n\nExamples:\n>>> get_altitude_at_pressure(pressure=100_000)\n105.47836610778828\n>>> get_altitude_at_pressure(pressure=101_325)\n0.0\n>>> get_altitude_at_pressure(pressure=80_000)\n1855.873388064995\n>>> get_altitude_at_pressure(pressure=201_325)\nTraceback (most recent call last):\n  ...\nValueError: Value Higher than Pressure at Sea Level !\n>>> get_altitude_at_pressure(pressure=-80_000)\nTraceback (most recent call last):\n  ...\nValueError: Atmospheric Pressure can not be negative !"
  },
  {
    "function": "archimedes_principle",
    "code": "def archimedes_principle(\n    fluid_density: float, volume: float, gravity: float = g\n) -> float:\n    \"\"\"\n    Args:\n        fluid_density: density of fluid (kg/m^3)\n        volume: volume of object/liquid being displaced by the object (m^3)\n        gravity: Acceleration from gravity. Gravitational force on the system,\n            The default is Earth Gravity\n    returns:\n        the buoyant force on an object in Newtons\n\n    >>> archimedes_principle(fluid_density=500, volume=4, gravity=9.8)\n    19600.0\n    >>> archimedes_principle(fluid_density=997, volume=0.5, gravity=9.8)\n    4885.3\n    >>> archimedes_principle(fluid_density=997, volume=0.7)\n    6844.061035\n    >>> archimedes_principle(fluid_density=997, volume=-0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible object volume\n    >>> archimedes_principle(fluid_density=0, volume=0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible fluid density\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=0)\n    0.0\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=-9.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible gravity\n    \"\"\"\n\n    if fluid_density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if volume <= 0:\n        raise ValueError(\"Impossible object volume\")\n    if gravity < 0:\n        raise ValueError(\"Impossible gravity\")\n\n    return fluid_density * gravity * volume",
    "docstring": "Args:\n    fluid_density: density of fluid (kg/m^3)\n    volume: volume of object/liquid being displaced by the object (m^3)\n    gravity: Acceleration from gravity. Gravitational force on the system,\n        The default is Earth Gravity\nreturns:\n    the buoyant force on an object in Newtons\n\n>>> archimedes_principle(fluid_density=500, volume=4, gravity=9.8)\n19600.0\n>>> archimedes_principle(fluid_density=997, volume=0.5, gravity=9.8)\n4885.3\n>>> archimedes_principle(fluid_density=997, volume=0.7)\n6844.061035\n>>> archimedes_principle(fluid_density=997, volume=-0.7)\nTraceback (most recent call last):\n    ...\nValueError: Impossible object volume\n>>> archimedes_principle(fluid_density=0, volume=0.7)\nTraceback (most recent call last):\n    ...\nValueError: Impossible fluid density\n>>> archimedes_principle(fluid_density=997, volume=0.7, gravity=0)\n0.0\n>>> archimedes_principle(fluid_density=997, volume=0.7, gravity=-9.8)\nTraceback (most recent call last):\n    ...\nValueError: Impossible gravity"
  },
  {
    "function": "capture_radii",
    "code": "def capture_radii(\n    target_body_radius: float, target_body_mass: float, projectile_velocity: float\n) -> float:\n    \"\"\"\n    Input Params:\n    -------------\n    target_body_radius: Radius of the central body SI units: meters | m\n    target_body_mass: Mass of the central body SI units: kilograms | kg\n    projectile_velocity: Velocity of object moving toward central body\n        SI units: meters/second | m/s\n    Returns:\n    --------\n    >>> capture_radii(6.957e8, 1.99e30, 25000.0)\n    17209590691.0\n    >>> capture_radii(-6.957e8, 1.99e30, 25000.0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Radius cannot be less than 0\n    >>> capture_radii(6.957e8, -1.99e30, 25000.0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass cannot be less than 0\n    >>> capture_radii(6.957e8, 1.99e30, c+1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Cannot go beyond speed of light\n\n    Returned SI units:\n    ------------------\n    meters | m\n    \"\"\"\n\n    if target_body_mass < 0:\n        raise ValueError(\"Mass cannot be less than 0\")\n    if target_body_radius < 0:\n        raise ValueError(\"Radius cannot be less than 0\")\n    if projectile_velocity > c:\n        raise ValueError(\"Cannot go beyond speed of light\")\n\n    escape_velocity_squared = (2 * G * target_body_mass) / target_body_radius\n    capture_radius = target_body_radius * sqrt(\n        1 + escape_velocity_squared / pow(projectile_velocity, 2)\n    )\n    return round(capture_radius, 0)",
    "docstring": "Input Params:\n-------------\ntarget_body_radius: Radius of the central body SI units: meters | m\ntarget_body_mass: Mass of the central body SI units: kilograms | kg\nprojectile_velocity: Velocity of object moving toward central body\n    SI units: meters/second | m/s\nReturns:\n--------\n>>> capture_radii(6.957e8, 1.99e30, 25000.0)\n17209590691.0\n>>> capture_radii(-6.957e8, 1.99e30, 25000.0)\nTraceback (most recent call last):\n    ...\nValueError: Radius cannot be less than 0\n>>> capture_radii(6.957e8, -1.99e30, 25000.0)\nTraceback (most recent call last):\n    ...\nValueError: Mass cannot be less than 0\n>>> capture_radii(6.957e8, 1.99e30, c+1)\nTraceback (most recent call last):\n    ...\nValueError: Cannot go beyond speed of light\n\nReturned SI units:\n------------------\nmeters | m"
  },
  {
    "function": "capture_area",
    "code": "def capture_area(capture_radius: float) -> float:\n    \"\"\"\n    Input Param:\n    ------------\n    capture_radius: The radius of orbital capture and impact for a central body of\n    mass M and a projectile moving towards it with velocity v\n        SI units: meters | m\n    Returns:\n    --------\n    >>> capture_area(17209590691)\n    9.304455331329126e+20\n    >>> capture_area(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Cannot have a capture radius less than 0\n\n    Returned SI units:\n    ------------------\n    meters*meters | m**2\n    \"\"\"\n\n    if capture_radius < 0:\n        raise ValueError(\"Cannot have a capture radius less than 0\")\n    sigma = pi * pow(capture_radius, 2)\n    return round(sigma, 0)",
    "docstring": "Input Param:\n------------\ncapture_radius: The radius of orbital capture and impact for a central body of\nmass M and a projectile moving towards it with velocity v\n    SI units: meters | m\nReturns:\n--------\n>>> capture_area(17209590691)\n9.304455331329126e+20\n>>> capture_area(-1)\nTraceback (most recent call last):\n    ...\nValueError: Cannot have a capture radius less than 0\n\nReturned SI units:\n------------------\nmeters*meters | m**2"
  },
  {
    "function": "casimir_force",
    "code": "def casimir_force(force: float, area: float, distance: float) -> dict[str, float]:\n    \"\"\"\n    Input Parameters\n    ----------------\n    force -> Casimir Force : magnitude in Newtons\n\n    area -> Surface area of each plate : magnitude in square meters\n\n    distance -> Distance between two plates : distance in Meters\n\n    Returns\n    -------\n    result : dict name, value pair of the parameter having Zero as it's value\n\n    Returns the value of one of the parameters specified as 0, provided the values of\n    other parameters are given.\n    >>> casimir_force(force = 0, area = 4, distance = 0.03)\n    {'force': 6.4248189174864216e-21}\n\n    >>> casimir_force(force = 2635e-13, area = 0.0023, distance = 0)\n    {'distance': 1.0323056015031114e-05}\n\n    >>> casimir_force(force = 2737e-21, area = 0, distance = 0.0023746)\n    {'area': 0.06688838837354052}\n\n    >>> casimir_force(force = 3457e-12, area = 0, distance = 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: One and only one argument must be 0\n\n    >>> casimir_force(force = 3457e-12, area = 0, distance = -0.00344)\n    Traceback (most recent call last):\n        ...\n    ValueError: Distance can not be negative\n\n    >>> casimir_force(force = -912e-12, area = 0, distance = 0.09374)\n    Traceback (most recent call last):\n        ...\n    ValueError: Magnitude of force can not be negative\n    \"\"\"\n\n    if (force, area, distance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if force < 0:\n        raise ValueError(\"Magnitude of force can not be negative\")\n    if distance < 0:\n        raise ValueError(\"Distance can not be negative\")\n    if area < 0:\n        raise ValueError(\"Area can not be negative\")\n    if force == 0:\n        force = (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (\n            240 * (distance) ** 4\n        )\n        return {\"force\": force}\n    elif area == 0:\n        area = (240 * force * (distance) ** 4) / (\n            REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2\n        )\n        return {\"area\": area}\n    elif distance == 0:\n        distance = (\n            (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (240 * force)\n        ) ** (1 / 4)\n        return {\"distance\": distance}\n    raise ValueError(\"One and only one argument must be 0\")",
    "docstring": "Input Parameters\n----------------\nforce -> Casimir Force : magnitude in Newtons\n\narea -> Surface area of each plate : magnitude in square meters\n\ndistance -> Distance between two plates : distance in Meters\n\nReturns\n-------\nresult : dict name, value pair of the parameter having Zero as it's value\n\nReturns the value of one of the parameters specified as 0, provided the values of\nother parameters are given.\n>>> casimir_force(force = 0, area = 4, distance = 0.03)\n{'force': 6.4248189174864216e-21}\n\n>>> casimir_force(force = 2635e-13, area = 0.0023, distance = 0)\n{'distance': 1.0323056015031114e-05}\n\n>>> casimir_force(force = 2737e-21, area = 0, distance = 0.0023746)\n{'area': 0.06688838837354052}\n\n>>> casimir_force(force = 3457e-12, area = 0, distance = 0)\nTraceback (most recent call last):\n    ...\nValueError: One and only one argument must be 0\n\n>>> casimir_force(force = 3457e-12, area = 0, distance = -0.00344)\nTraceback (most recent call last):\n    ...\nValueError: Distance can not be negative\n\n>>> casimir_force(force = -912e-12, area = 0, distance = 0.09374)\nTraceback (most recent call last):\n    ...\nValueError: Magnitude of force can not be negative"
  },
  {
    "function": "center_of_mass",
    "code": "def center_of_mass(particles: list[Particle]) -> Coord3D:\n    \"\"\"\n    Input Parameters\n    ----------------\n    particles: list(Particle):\n    A list of particles where each particle is a tuple with it's (x, y, z) position and\n    it's mass.\n\n    Returns\n    -------\n    Coord3D:\n    A tuple with the coordinates of the center of mass (Xcm, Ycm, Zcm) rounded to two\n    decimal places.\n\n    Examples\n    --------\n    >>> center_of_mass([\n    ...     Particle(1.5, 4, 3.4, 4),\n    ...     Particle(5, 6.8, 7, 8.1),\n    ...     Particle(9.4, 10.1, 11.6, 12)\n    ... ])\n    Coord3D(x=6.61, y=7.98, z=8.69)\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, 4),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Coord3D(x=6.33, y=7.33, z=8.33)\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, -4),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass of all particles must be greater than 0\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, 0),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass of all particles must be greater than 0\n\n    >>> center_of_mass([])\n    Traceback (most recent call last):\n        ...\n    ValueError: No particles provided\n    \"\"\"\n    if not particles:\n        raise ValueError(\"No particles provided\")\n\n    if any(particle.mass <= 0 for particle in particles):\n        raise ValueError(\"Mass of all particles must be greater than 0\")\n\n    total_mass = sum(particle.mass for particle in particles)\n\n    center_of_mass_x = round(\n        sum(particle.x * particle.mass for particle in particles) / total_mass, 2\n    )\n    center_of_mass_y = round(\n        sum(particle.y * particle.mass for particle in particles) / total_mass, 2\n    )\n    center_of_mass_z = round(\n        sum(particle.z * particle.mass for particle in particles) / total_mass, 2\n    )\n    return Coord3D(center_of_mass_x, center_of_mass_y, center_of_mass_z)",
    "docstring": "Input Parameters\n----------------\nparticles: list(Particle):\nA list of particles where each particle is a tuple with it's (x, y, z) position and\nit's mass.\n\nReturns\n-------\nCoord3D:\nA tuple with the coordinates of the center of mass (Xcm, Ycm, Zcm) rounded to two\ndecimal places.\n\nExamples\n--------\n>>> center_of_mass([\n...     Particle(1.5, 4, 3.4, 4),\n...     Particle(5, 6.8, 7, 8.1),\n...     Particle(9.4, 10.1, 11.6, 12)\n... ])\nCoord3D(x=6.61, y=7.98, z=8.69)\n\n>>> center_of_mass([\n...     Particle(1, 2, 3, 4),\n...     Particle(5, 6, 7, 8),\n...     Particle(9, 10, 11, 12)\n... ])\nCoord3D(x=6.33, y=7.33, z=8.33)\n\n>>> center_of_mass([\n...     Particle(1, 2, 3, -4),\n...     Particle(5, 6, 7, 8),\n...     Particle(9, 10, 11, 12)\n... ])\nTraceback (most recent call last):\n    ...\nValueError: Mass of all particles must be greater than 0\n\n>>> center_of_mass([\n...     Particle(1, 2, 3, 0),\n...     Particle(5, 6, 7, 8),\n...     Particle(9, 10, 11, 12)\n... ])\nTraceback (most recent call last):\n    ...\nValueError: Mass of all particles must be greater than 0\n\n>>> center_of_mass([])\nTraceback (most recent call last):\n    ...\nValueError: No particles provided"
  },
  {
    "function": "centripetal",
    "code": "def centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius",
    "docstring": "The Centripetal Force formula is given as: (m*v*v)/r\n\n>>> round(centripetal(15.5,-30,10),2)\n1395.0\n>>> round(centripetal(10,15,5),2)\n450.0\n>>> round(centripetal(20,-50,15),2)\n3333.33\n>>> round(centripetal(12.25,40,25),2)\n784.0\n>>> round(centripetal(50,100,50),2)\n10000.0"
  },
  {
    "function": "coulombs_law",
    "code": "def coulombs_law(q1: float, q2: float, radius: float) -> float:\n    \"\"\"\n    Calculate the electrostatic force of attraction or repulsion\n    between two point charges\n\n    >>> coulombs_law(15.5, 20, 15)\n    12382849136.06\n    >>> coulombs_law(1, 15, 5)\n    5392531075.38\n    >>> coulombs_law(20, -50, 15)\n    -39944674632.44\n    >>> coulombs_law(-5, -8, 10)\n    3595020716.92\n    >>> coulombs_law(50, 100, 50)\n    17975103584.6\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)",
    "docstring": "Calculate the electrostatic force of attraction or repulsion\nbetween two point charges\n\n>>> coulombs_law(15.5, 20, 15)\n12382849136.06\n>>> coulombs_law(1, 15, 5)\n5392531075.38\n>>> coulombs_law(20, -50, 15)\n-39944674632.44\n>>> coulombs_law(-5, -8, 10)\n3595020716.92\n>>> coulombs_law(50, 100, 50)\n17975103584.6"
  },
  {
    "function": "doppler_effect",
    "code": "def doppler_effect(\n    org_freq: float, wave_vel: float, obs_vel: float, src_vel: float\n) -> float:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    org_freq: frequency of the wave when the source is stationary\n    wave_vel: velocity of the wave in the medium\n    obs_vel: velocity of the observer, +ve if the observer is moving towards the source\n    src_vel: velocity of the source, +ve if the source is moving towards the observer\n\n    Returns:\n    --------\n    f: frequency of the wave as perceived by the observer\n\n    Docstring Tests:\n    >>> doppler_effect(100, 330, 10, 0)  # observer moving towards the source\n    103.03030303030303\n    >>> doppler_effect(100, 330, -10, 0)  # observer moving away from the source\n    96.96969696969697\n    >>> doppler_effect(100, 330, 0, 10)  # source moving towards the observer\n    103.125\n    >>> doppler_effect(100, 330, 0, -10)  # source moving away from the observer\n    97.05882352941177\n    >>> doppler_effect(100, 330, 10, 10)  # source & observer moving towards each other\n    106.25\n    >>> doppler_effect(100, 330, -10, -10)  # source and observer moving away\n    94.11764705882354\n    >>> doppler_effect(100, 330, 10, 330)  # source moving at same speed as the wave\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: Division by zero implies vs=v and observer in front of the source\n    >>> doppler_effect(100, 330, 10, 340)  # source moving faster than the wave\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction)\n    >>> doppler_effect(100, 330, -340, 10)  # observer moving faster than the wave\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction)\n    \"\"\"\n\n    if wave_vel == src_vel:\n        raise ZeroDivisionError(\n            \"Division by zero implies vs=v and observer in front of the source\"\n        )\n    doppler_freq = (org_freq * (wave_vel + obs_vel)) / (wave_vel - src_vel)\n    if doppler_freq <= 0:\n        raise ValueError(\n            \"Non-positive frequency implies vs>v or v0>v (in the opposite direction)\"\n        )\n    return doppler_freq",
    "docstring": "Input Parameters:\n-----------------\norg_freq: frequency of the wave when the source is stationary\nwave_vel: velocity of the wave in the medium\nobs_vel: velocity of the observer, +ve if the observer is moving towards the source\nsrc_vel: velocity of the source, +ve if the source is moving towards the observer\n\nReturns:\n--------\nf: frequency of the wave as perceived by the observer\n\nDocstring Tests:\n>>> doppler_effect(100, 330, 10, 0)  # observer moving towards the source\n103.03030303030303\n>>> doppler_effect(100, 330, -10, 0)  # observer moving away from the source\n96.96969696969697\n>>> doppler_effect(100, 330, 0, 10)  # source moving towards the observer\n103.125\n>>> doppler_effect(100, 330, 0, -10)  # source moving away from the observer\n97.05882352941177\n>>> doppler_effect(100, 330, 10, 10)  # source & observer moving towards each other\n106.25\n>>> doppler_effect(100, 330, -10, -10)  # source and observer moving away\n94.11764705882354\n>>> doppler_effect(100, 330, 10, 330)  # source moving at same speed as the wave\nTraceback (most recent call last):\n    ...\nZeroDivisionError: Division by zero implies vs=v and observer in front of the source\n>>> doppler_effect(100, 330, 10, 340)  # source moving faster than the wave\nTraceback (most recent call last):\n    ...\nValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction)\n>>> doppler_effect(100, 330, -340, 10)  # observer moving faster than the wave\nTraceback (most recent call last):\n    ...\nValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction)"
  },
  {
    "function": "escape_velocity",
    "code": "def escape_velocity(mass: float, radius: float) -> float:\n    \"\"\"\n    Calculates the escape velocity needed to break free from a celestial body's\n    gravitational field.\n\n    The formula used is:\n        v = sqrt(2 * G * M / R)\n\n    where:\n        v = escape velocity (m/s)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the celestial body (kg)\n        R = radius from the center of mass (m)\n\n    Source:\n        https://en.wikipedia.org/wiki/Escape_velocity\n\n    Args:\n        mass (float): Mass of the celestial body in kilograms.\n        radius (float): Radius from the center of mass in meters.\n\n    Returns:\n        float: Escape velocity in meters per second, rounded to 3 decimal places.\n\n    Examples:\n        >>> escape_velocity(mass=5.972e24, radius=6.371e6)  # Earth\n        11185.978\n        >>> escape_velocity(mass=7.348e22, radius=1.737e6)  # Moon\n        2376.307\n        >>> escape_velocity(mass=1.898e27, radius=6.9911e7)  # Jupiter\n        60199.545\n        >>> escape_velocity(mass=0, radius=1.0)\n        0.0\n        >>> escape_velocity(mass=1.0, radius=0)\n        Traceback (most recent call last):\n            ...\n        ZeroDivisionError: Radius cannot be zero.\n    \"\"\"\n    gravitational_constant = 6.67430e-11  # m^3 kg^-1 s^-2\n\n    if radius == 0:\n        raise ZeroDivisionError(\"Radius cannot be zero.\")\n\n    velocity = math.sqrt(2 * gravitational_constant * mass / radius)\n    return round(velocity, 3)",
    "docstring": "Calculates the escape velocity needed to break free from a celestial body's\ngravitational field.\n\nThe formula used is:\n    v = sqrt(2 * G * M / R)\n\nwhere:\n    v = escape velocity (m/s)\n    G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n    M = mass of the celestial body (kg)\n    R = radius from the center of mass (m)\n\nSource:\n    https://en.wikipedia.org/wiki/Escape_velocity\n\nArgs:\n    mass (float): Mass of the celestial body in kilograms.\n    radius (float): Radius from the center of mass in meters.\n\nReturns:\n    float: Escape velocity in meters per second, rounded to 3 decimal places.\n\nExamples:\n    >>> escape_velocity(mass=5.972e24, radius=6.371e6)  # Earth\n    11185.978\n    >>> escape_velocity(mass=7.348e22, radius=1.737e6)  # Moon\n    2376.307\n    >>> escape_velocity(mass=1.898e27, radius=6.9911e7)  # Jupiter\n    60199.545\n    >>> escape_velocity(mass=0, radius=1.0)\n    0.0\n    >>> escape_velocity(mass=1.0, radius=0)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: Radius cannot be zero."
  },
  {
    "function": "validate",
    "code": "def validate(*values: float) -> bool:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> validate(2.016, 4.002)\n    True\n    >>> validate(-2.016, 4.002)\n    False\n    >>> validate()\n    False\n    \"\"\"\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result",
    "docstring": "Input Parameters:\n-----------------\neffusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\neffusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\nmolar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\nmolar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\nReturns:\n--------\n>>> validate(2.016, 4.002)\nTrue\n>>> validate(-2.016, 4.002)\nFalse\n>>> validate()\nFalse"
  },
  {
    "function": "effusion_ratio",
    "code": "def effusion_ratio(molar_mass_1: float, molar_mass_2: float) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> effusion_ratio(2.016, 4.002)\n    1.408943\n    >>> effusion_ratio(-2.016, 4.002)\n    ValueError('Input Error: Molar mass values must greater than 0.')\n    >>> effusion_ratio(2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: effusion_ratio() missing 1 required positional argument: 'molar_mass_2'\n    \"\"\"\n    return (\n        round(sqrt(molar_mass_2 / molar_mass_1), 6)\n        if validate(molar_mass_1, molar_mass_2)\n        else ValueError(\"Input Error: Molar mass values must greater than 0.\")\n    )",
    "docstring": "Input Parameters:\n-----------------\nmolar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\nmolar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\nReturns:\n--------\n>>> effusion_ratio(2.016, 4.002)\n1.408943\n>>> effusion_ratio(-2.016, 4.002)\nValueError('Input Error: Molar mass values must greater than 0.')\n>>> effusion_ratio(2.016)\nTraceback (most recent call last):\n  ...\nTypeError: effusion_ratio() missing 1 required positional argument: 'molar_mass_2'"
  },
  {
    "function": "first_effusion_rate",
    "code": "def first_effusion_rate(\n    effusion_rate: float, molar_mass_1: float, molar_mass_2: float\n) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> first_effusion_rate(1, 2.016, 4.002)\n    1.408943\n    >>> first_effusion_rate(-1, 2.016, 4.002)\n    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n    >>> first_effusion_rate(1)\n    Traceback (most recent call last):\n      ...\n    TypeError: first_effusion_rate() missing 2 required positional arguments: \\\n'molar_mass_1' and 'molar_mass_2'\n    >>> first_effusion_rate(1, 2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: first_effusion_rate() missing 1 required positional argument: \\\n'molar_mass_2'\n    \"\"\"\n    return (\n        round(effusion_rate * sqrt(molar_mass_2 / molar_mass_1), 6)\n        if validate(effusion_rate, molar_mass_1, molar_mass_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )",
    "docstring": "Input Parameters:\n-----------------\neffusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\nmolar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\nmolar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\nReturns:\n--------\n>>> first_effusion_rate(1, 2.016, 4.002)\n1.408943\n>>> first_effusion_rate(-1, 2.016, 4.002)\nValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n>>> first_effusion_rate(1)\nTraceback (most recent call last):\n  ...\nTypeError: first_effusion_rate() missing 2 required positional arguments: 'molar_mass_1' and 'molar_mass_2'\n>>> first_effusion_rate(1, 2.016)\nTraceback (most recent call last):\n  ...\nTypeError: first_effusion_rate() missing 1 required positional argument: 'molar_mass_2'"
  },
  {
    "function": "second_effusion_rate",
    "code": "def second_effusion_rate(\n    effusion_rate: float, molar_mass_1: float, molar_mass_2: float\n) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> second_effusion_rate(1, 2.016, 4.002)\n    0.709752\n    >>> second_effusion_rate(-1, 2.016, 4.002)\n    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n    >>> second_effusion_rate(1)\n    Traceback (most recent call last):\n      ...\n    TypeError: second_effusion_rate() missing 2 required positional arguments: \\\n'molar_mass_1' and 'molar_mass_2'\n    >>> second_effusion_rate(1, 2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: second_effusion_rate() missing 1 required positional argument: \\\n'molar_mass_2'\n    \"\"\"\n    return (\n        round(effusion_rate / sqrt(molar_mass_2 / molar_mass_1), 6)\n        if validate(effusion_rate, molar_mass_1, molar_mass_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )",
    "docstring": "Input Parameters:\n-----------------\neffusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\nmolar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\nmolar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\nReturns:\n--------\n>>> second_effusion_rate(1, 2.016, 4.002)\n0.709752\n>>> second_effusion_rate(-1, 2.016, 4.002)\nValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n>>> second_effusion_rate(1)\nTraceback (most recent call last):\n  ...\nTypeError: second_effusion_rate() missing 2 required positional arguments: 'molar_mass_1' and 'molar_mass_2'\n>>> second_effusion_rate(1, 2.016)\nTraceback (most recent call last):\n  ...\nTypeError: second_effusion_rate() missing 1 required positional argument: 'molar_mass_2'"
  },
  {
    "function": "first_molar_mass",
    "code": "def first_molar_mass(\n    molar_mass: float, effusion_rate_1: float, effusion_rate_2: float\n) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    molar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n\n    Returns:\n    --------\n    >>> first_molar_mass(2, 1.408943, 0.709752)\n    0.507524\n    >>> first_molar_mass(-1, 2.016, 4.002)\n    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n    >>> first_molar_mass(1)\n    Traceback (most recent call last):\n      ...\n    TypeError: first_molar_mass() missing 2 required positional arguments: \\\n'effusion_rate_1' and 'effusion_rate_2'\n    >>> first_molar_mass(1, 2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: first_molar_mass() missing 1 required positional argument: \\\n'effusion_rate_2'\n    \"\"\"\n    return (\n        round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)\n        if validate(molar_mass, effusion_rate_1, effusion_rate_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )",
    "docstring": "Input Parameters:\n-----------------\nmolar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.)\neffusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\neffusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n\nReturns:\n--------\n>>> first_molar_mass(2, 1.408943, 0.709752)\n0.507524\n>>> first_molar_mass(-1, 2.016, 4.002)\nValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n>>> first_molar_mass(1)\nTraceback (most recent call last):\n  ...\nTypeError: first_molar_mass() missing 2 required positional arguments: 'effusion_rate_1' and 'effusion_rate_2'\n>>> first_molar_mass(1, 2.016)\nTraceback (most recent call last):\n  ...\nTypeError: first_molar_mass() missing 1 required positional argument: 'effusion_rate_2'"
  },
  {
    "function": "second_molar_mass",
    "code": "def second_molar_mass(\n    molar_mass: float, effusion_rate_1: float, effusion_rate_2: float\n) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    molar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n\n    Returns:\n    --------\n    >>> second_molar_mass(2, 1.408943, 0.709752)\n    1.970351\n    >>> second_molar_mass(-2, 1.408943, 0.709752)\n    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n    >>> second_molar_mass(1)\n    Traceback (most recent call last):\n      ...\n    TypeError: second_molar_mass() missing 2 required positional arguments: \\\n'effusion_rate_1' and 'effusion_rate_2'\n    >>> second_molar_mass(1, 2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: second_molar_mass() missing 1 required positional argument: \\\n'effusion_rate_2'\n    \"\"\"\n    return (\n        round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)\n        if validate(molar_mass, effusion_rate_1, effusion_rate_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )",
    "docstring": "Input Parameters:\n-----------------\nmolar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.)\neffusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\neffusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n\nReturns:\n--------\n>>> second_molar_mass(2, 1.408943, 0.709752)\n1.970351\n>>> second_molar_mass(-2, 1.408943, 0.709752)\nValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n>>> second_molar_mass(1)\nTraceback (most recent call last):\n  ...\nTypeError: second_molar_mass() missing 2 required positional arguments: 'effusion_rate_1' and 'effusion_rate_2'\n>>> second_molar_mass(1, 2.016)\nTraceback (most recent call last):\n  ...\nTypeError: second_molar_mass() missing 1 required positional argument: 'effusion_rate_2'"
  },
  {
    "function": "check_args",
    "code": "def check_args(init_velocity: float, angle: float) -> None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n\n    # Ensure valid instance\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError(\"Invalid velocity. Should be an integer or float.\")\n\n    if not isinstance(angle, (int, float)):\n        raise TypeError(\"Invalid angle. Should be an integer or float.\")\n\n    # Ensure valid angle\n    if angle > 90 or angle < 1:\n        raise ValueError(\"Invalid angle. Range is 1-90 degrees.\")\n\n    # Ensure valid velocity\n    if init_velocity < 0:\n        raise ValueError(\"Invalid velocity. Should be a positive number.\")",
    "docstring": "Check that the arguments are valid"
  },
  {
    "function": "horizontal_distance",
    "code": "def horizontal_distance(init_velocity: float, angle: float) -> float:\n    r\"\"\"\n    Returns the horizontal distance that the object cover\n\n    Formula:\n        .. math::\n            \\frac{v_0^2 \\cdot \\sin(2 \\alpha)}{g}\n\n            v_0 - \\text{initial velocity}\n\n            \\alpha - \\text{angle}\n\n    >>> horizontal_distance(30, 45)\n    91.77\n    >>> horizontal_distance(100, 78)\n    414.76\n    >>> horizontal_distance(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = deg_to_rad(2 * angle)\n    return round(init_velocity**2 * sin(radians) / g, 2)",
    "docstring": "Returns the horizontal distance that the object cover\n\nFormula:\n    .. math::\n        \\frac{v_0^2 \\cdot \\sin(2 \\alpha)}{g}\n\n        v_0 - \\text{initial velocity}\n\n        \\alpha - \\text{angle}\n\n>>> horizontal_distance(30, 45)\n91.77\n>>> horizontal_distance(100, 78)\n414.76\n>>> horizontal_distance(-1, 20)\nTraceback (most recent call last):\n    ...\nValueError: Invalid velocity. Should be a positive number.\n>>> horizontal_distance(30, -20)\nTraceback (most recent call last):\n    ...\nValueError: Invalid angle. Range is 1-90 degrees."
  },
  {
    "function": "max_height",
    "code": "def max_height(init_velocity: float, angle: float) -> float:\n    r\"\"\"\n    Returns the maximum height that the object reach\n\n    Formula:\n        .. math::\n            \\frac{v_0^2 \\cdot \\sin^2 (\\alpha)}{2 g}\n\n            v_0 - \\text{initial velocity}\n\n            \\alpha - \\text{angle}\n\n    >>> max_height(30, 45)\n    22.94\n    >>> max_height(100, 78)\n    487.82\n    >>> max_height(\"a\", 20)\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid velocity. Should be an integer or float.\n    >>> horizontal_distance(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Should be an integer or float.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = deg_to_rad(angle)\n    return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)",
    "docstring": "Returns the maximum height that the object reach\n\nFormula:\n    .. math::\n        \\frac{v_0^2 \\cdot \\sin^2 (\\alpha)}{2 g}\n\n        v_0 - \\text{initial velocity}\n\n        \\alpha - \\text{angle}\n\n>>> max_height(30, 45)\n22.94\n>>> max_height(100, 78)\n487.82\n>>> max_height(\"a\", 20)\nTraceback (most recent call last):\n    ...\nTypeError: Invalid velocity. Should be an integer or float.\n>>> horizontal_distance(30, \"b\")\nTraceback (most recent call last):\n    ...\nTypeError: Invalid angle. Should be an integer or float."
  },
  {
    "function": "total_time",
    "code": "def total_time(init_velocity: float, angle: float) -> float:\n    r\"\"\"\n    Returns total time of the motion\n\n    Formula:\n        .. math::\n            \\frac{2 v_0 \\cdot \\sin (\\alpha)}{g}\n\n            v_0 - \\text{initial velocity}\n\n            \\alpha - \\text{angle}\n\n    >>> total_time(30, 45)\n    4.33\n    >>> total_time(100, 78)\n    19.95\n    >>> total_time(-10, 40)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> total_time(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Should be an integer or float.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = deg_to_rad(angle)\n    return round(2 * init_velocity * sin(radians) / g, 2)",
    "docstring": "Returns total time of the motion\n\nFormula:\n    .. math::\n        \\frac{2 v_0 \\cdot \\sin (\\alpha)}{g}\n\n        v_0 - \\text{initial velocity}\n\n        \\alpha - \\text{angle}\n\n>>> total_time(30, 45)\n4.33\n>>> total_time(100, 78)\n19.95\n>>> total_time(-10, 40)\nTraceback (most recent call last):\n    ...\nValueError: Invalid velocity. Should be a positive number.\n>>> total_time(30, \"b\")\nTraceback (most recent call last):\n    ...\nTypeError: Invalid angle. Should be an integer or float."
  },
  {
    "function": "test_motion",
    "code": "def test_motion() -> None:\n    \"\"\"\n    Test motion\n\n    >>> test_motion()\n    \"\"\"\n    v0, angle = 25, 20\n    assert horizontal_distance(v0, angle) == 40.97\n    assert max_height(v0, angle) == 3.73\n    assert total_time(v0, angle) == 1.74",
    "docstring": "Test motion\n\n>>> test_motion()"
  },
  {
    "function": "hubble_parameter",
    "code": "def hubble_parameter(\n    hubble_constant: float,\n    radiation_density: float,\n    matter_density: float,\n    dark_energy: float,\n    redshift: float,\n) -> float:\n    \"\"\"\n    Input Parameters\n    ----------------\n    hubble_constant: Hubble constante is the expansion rate today usually\n    given in km/(s*Mpc)\n\n    radiation_density: relative radiation density today\n\n    matter_density: relative mass density today\n\n    dark_energy: relative dark energy density today\n\n    redshift: the light redshift\n\n    Returns\n    -------\n    result : Hubble parameter in and the unit km/s/Mpc (the unit can be\n    changed if you want, just need to change the unit of the Hubble constant)\n\n    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n    ... matter_density=-0.3, dark_energy=0.7, redshift=1)\n    Traceback (most recent call last):\n    ...\n    ValueError: All input parameters must be positive\n\n    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n    ... matter_density= 1.2, dark_energy=0.7, redshift=1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Relative densities cannot be greater than one\n\n    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n    ... matter_density= 0.3, dark_energy=0.7, redshift=0)\n    68.3\n    \"\"\"\n    parameters = [redshift, radiation_density, matter_density, dark_energy]\n    if any(p < 0 for p in parameters):\n        raise ValueError(\"All input parameters must be positive\")\n\n    if any(p > 1 for p in parameters[1:4]):\n        raise ValueError(\"Relative densities cannot be greater than one\")\n    else:\n        curvature = 1 - (matter_density + radiation_density + dark_energy)\n\n        e_2 = (\n            radiation_density * (redshift + 1) ** 4\n            + matter_density * (redshift + 1) ** 3\n            + curvature * (redshift + 1) ** 2\n            + dark_energy\n        )\n\n        hubble = hubble_constant * e_2 ** (1 / 2)\n        return hubble",
    "docstring": "Input Parameters\n----------------\nhubble_constant: Hubble constante is the expansion rate today usually\ngiven in km/(s*Mpc)\n\nradiation_density: relative radiation density today\n\nmatter_density: relative mass density today\n\ndark_energy: relative dark energy density today\n\nredshift: the light redshift\n\nReturns\n-------\nresult : Hubble parameter in and the unit km/s/Mpc (the unit can be\nchanged if you want, just need to change the unit of the Hubble constant)\n\n>>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n... matter_density=-0.3, dark_energy=0.7, redshift=1)\nTraceback (most recent call last):\n...\nValueError: All input parameters must be positive\n\n>>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n... matter_density= 1.2, dark_energy=0.7, redshift=1)\nTraceback (most recent call last):\n...\nValueError: Relative densities cannot be greater than one\n\n>>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n... matter_density= 0.3, dark_energy=0.7, redshift=0)\n68.3"
  },
  {
    "function": "pressure_of_gas_system",
    "code": "def pressure_of_gas_system(moles: float, kelvin: float, volume: float) -> float:\n    \"\"\"\n    >>> pressure_of_gas_system(2, 100, 5)\n    332.57848\n    >>> pressure_of_gas_system(0.5, 273, 0.004)\n    283731.01575\n    >>> pressure_of_gas_system(3, -0.46, 23.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter positive value.\n    \"\"\"\n    if moles < 0 or kelvin < 0 or volume < 0:\n        raise ValueError(\"Invalid inputs. Enter positive value.\")\n    return moles * kelvin * UNIVERSAL_GAS_CONSTANT / volume",
    "docstring": ">>> pressure_of_gas_system(2, 100, 5)\n332.57848\n>>> pressure_of_gas_system(0.5, 273, 0.004)\n283731.01575\n>>> pressure_of_gas_system(3, -0.46, 23.5)\nTraceback (most recent call last):\n    ...\nValueError: Invalid inputs. Enter positive value."
  },
  {
    "function": "volume_of_gas_system",
    "code": "def volume_of_gas_system(moles: float, kelvin: float, pressure: float) -> float:\n    \"\"\"\n    >>> volume_of_gas_system(2, 100, 5)\n    332.57848\n    >>> volume_of_gas_system(0.5, 273, 0.004)\n    283731.01575\n    >>> volume_of_gas_system(3, -0.46, 23.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter positive value.\n    \"\"\"\n    if moles < 0 or kelvin < 0 or pressure < 0:\n        raise ValueError(\"Invalid inputs. Enter positive value.\")\n    return moles * kelvin * UNIVERSAL_GAS_CONSTANT / pressure",
    "docstring": ">>> volume_of_gas_system(2, 100, 5)\n332.57848\n>>> volume_of_gas_system(0.5, 273, 0.004)\n283731.01575\n>>> volume_of_gas_system(3, -0.46, 23.5)\nTraceback (most recent call last):\n    ...\nValueError: Invalid inputs. Enter positive value."
  },
  {
    "function": "temperature_of_gas_system",
    "code": "def temperature_of_gas_system(moles: float, volume: float, pressure: float) -> float:\n    \"\"\"\n    >>> temperature_of_gas_system(2, 100, 5)\n    30.068090996146232\n    >>> temperature_of_gas_system(11, 5009, 1000)\n    54767.66101807144\n    >>> temperature_of_gas_system(3, -0.46, 23.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter positive value.\n    \"\"\"\n    if moles < 0 or volume < 0 or pressure < 0:\n        raise ValueError(\"Invalid inputs. Enter positive value.\")\n\n    return pressure * volume / (moles * UNIVERSAL_GAS_CONSTANT)",
    "docstring": ">>> temperature_of_gas_system(2, 100, 5)\n30.068090996146232\n>>> temperature_of_gas_system(11, 5009, 1000)\n54767.66101807144\n>>> temperature_of_gas_system(3, -0.46, 23.5)\nTraceback (most recent call last):\n    ...\nValueError: Invalid inputs. Enter positive value."
  },
  {
    "function": "moles_of_gas_system",
    "code": "def moles_of_gas_system(kelvin: float, volume: float, pressure: float) -> float:\n    \"\"\"\n    >>> moles_of_gas_system(100, 5, 10)\n    0.06013618199229246\n    >>> moles_of_gas_system(110, 5009, 1000)\n    5476.766101807144\n    >>> moles_of_gas_system(3, -0.46, 23.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter positive value.\n    \"\"\"\n    if kelvin < 0 or volume < 0 or pressure < 0:\n        raise ValueError(\"Invalid inputs. Enter positive value.\")\n\n    return pressure * volume / (kelvin * UNIVERSAL_GAS_CONSTANT)",
    "docstring": ">>> moles_of_gas_system(100, 5, 10)\n0.06013618199229246\n>>> moles_of_gas_system(110, 5009, 1000)\n5476.766101807144\n>>> moles_of_gas_system(3, -0.46, 23.5)\nTraceback (most recent call last):\n    ...\nValueError: Invalid inputs. Enter positive value."
  },
  {
    "function": "polar_force",
    "code": "def polar_force(\n    magnitude: float, angle: float, radian_mode: bool = False\n) -> list[float]:\n    \"\"\"\n    Resolves force along rectangular components.\n    (force, angle) => (force_x, force_y)\n    >>> import math\n    >>> force = polar_force(10, 45)\n    >>> math.isclose(force[0], 7.071067811865477)\n    True\n    >>> math.isclose(force[1], 7.0710678118654755)\n    True\n    >>> force = polar_force(10, 3.14, radian_mode=True)\n    >>> math.isclose(force[0], -9.999987317275396)\n    True\n    >>> math.isclose(force[1], 0.01592652916486828)\n    True\n    \"\"\"\n    if radian_mode:\n        return [magnitude * cos(angle), magnitude * sin(angle)]\n    return [magnitude * cos(radians(angle)), magnitude * sin(radians(angle))]",
    "docstring": "Resolves force along rectangular components.\n(force, angle) => (force_x, force_y)\n>>> import math\n>>> force = polar_force(10, 45)\n>>> math.isclose(force[0], 7.071067811865477)\nTrue\n>>> math.isclose(force[1], 7.0710678118654755)\nTrue\n>>> force = polar_force(10, 3.14, radian_mode=True)\n>>> math.isclose(force[0], -9.999987317275396)\nTrue\n>>> math.isclose(force[1], 0.01592652916486828)\nTrue"
  },
  {
    "function": "in_static_equilibrium",
    "code": "def in_static_equilibrium(\n    forces: NDArray[float64], location: NDArray[float64], eps: float = 10**-1\n) -> bool:\n    \"\"\"\n    Check if a system is in equilibrium.\n    It takes two numpy.array objects.\n    forces ==>  [\n                        [force1_x, force1_y],\n                        [force2_x, force2_y],\n                        ....]\n    location ==>  [\n                        [x1, y1],\n                        [x2, y2],\n                        ....]\n    >>> force = array([[1, 1], [-1, 2]])\n    >>> location = array([[1, 0], [10, 0]])\n    >>> in_static_equilibrium(force, location)\n    False\n    \"\"\"\n    # summation of moments is zero\n    moments: NDArray[float64] = cross(location, forces)\n    sum_moments: float = sum(moments)\n    return bool(abs(sum_moments) < eps)",
    "docstring": "Check if a system is in equilibrium.\nIt takes two numpy.array objects.\nforces ==>  [\n                    [force1_x, force1_y],\n                    [force2_x, force2_y],\n                    ....]\nlocation ==>  [\n                    [x1, y1],\n                    [x2, y2],\n                    ....]\n>>> force = array([[1, 1], [-1, 2]])\n>>> location = array([[1, 0], [10, 0]])\n>>> in_static_equilibrium(force, location)\nFalse"
  },
  {
    "function": "kinetic_energy",
    "code": "def kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is \u00bdmv\u00b2\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)",
    "docstring": "Calculate kinetic energy.\n\nThe kinetic energy of a non-rotating object of mass m traveling at a speed v is \u00bdmv\u00b2\n\n>>> kinetic_energy(10,10)\n500.0\n>>> kinetic_energy(0,10)\n0.0\n>>> kinetic_energy(10,0)\n0.0\n>>> kinetic_energy(20,-20)\n4000.0\n>>> kinetic_energy(0,0)\n0.0\n>>> kinetic_energy(2,2)\n4.0\n>>> kinetic_energy(100,100)\n500000.0"
  },
  {
    "function": "focal_length_of_lens",
    "code": "def focal_length_of_lens(\n    object_distance_from_lens: float, image_distance_from_lens: float\n) -> float:\n    \"\"\"\n    Doctests:\n    >>> from math import isclose\n    >>> isclose(focal_length_of_lens(10,4), 6.666666666666667)\n    True\n    >>> from math import isclose\n    >>> isclose(focal_length_of_lens(2.7,5.8), -5.0516129032258075)\n    True\n    >>> focal_length_of_lens(0, 20)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n\n    if object_distance_from_lens == 0 or image_distance_from_lens == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n    focal_length = 1 / (\n        (1 / image_distance_from_lens) - (1 / object_distance_from_lens)\n    )\n    return focal_length",
    "docstring": "Doctests:\n>>> from math import isclose\n>>> isclose(focal_length_of_lens(10,4), 6.666666666666667)\nTrue\n>>> from math import isclose\n>>> isclose(focal_length_of_lens(2.7,5.8), -5.0516129032258075)\nTrue\n>>> focal_length_of_lens(0, 20)  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: Invalid inputs. Enter non zero values with respect\nto the sign convention."
  },
  {
    "function": "object_distance",
    "code": "def object_distance(\n    focal_length_of_lens: float, image_distance_from_lens: float\n) -> float:\n    \"\"\"\n    Doctests:\n    >>> from math import isclose\n    >>> isclose(object_distance(10,40), -13.333333333333332)\n    True\n\n    >>> from math import isclose\n    >>> isclose(object_distance(6.2,1.5), 1.9787234042553192)\n    True\n\n    >>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n\n    if image_distance_from_lens == 0 or focal_length_of_lens == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n\n    object_distance = 1 / ((1 / image_distance_from_lens) - (1 / focal_length_of_lens))\n    return object_distance",
    "docstring": "Doctests:\n>>> from math import isclose\n>>> isclose(object_distance(10,40), -13.333333333333332)\nTrue\n\n>>> from math import isclose\n>>> isclose(object_distance(6.2,1.5), 1.9787234042553192)\nTrue\n\n>>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: Invalid inputs. Enter non zero values with respect\nto the sign convention."
  },
  {
    "function": "image_distance",
    "code": "def image_distance(\n    focal_length_of_lens: float, object_distance_from_lens: float\n) -> float:\n    \"\"\"\n    Doctests:\n    >>> from math import isclose\n    >>> isclose(image_distance(50,40), 22.22222222222222)\n    True\n    >>> from math import isclose\n    >>> isclose(image_distance(5.3,7.9), 3.1719696969696973)\n    True\n\n    >>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n    if object_distance_from_lens == 0 or focal_length_of_lens == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n    image_distance = 1 / ((1 / object_distance_from_lens) + (1 / focal_length_of_lens))\n    return image_distance",
    "docstring": "Doctests:\n>>> from math import isclose\n>>> isclose(image_distance(50,40), 22.22222222222222)\nTrue\n>>> from math import isclose\n>>> isclose(image_distance(5.3,7.9), 3.1719696969696973)\nTrue\n\n>>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: Invalid inputs. Enter non zero values with respect\nto the sign convention."
  },
  {
    "function": "beta",
    "code": "def beta(velocity: float) -> float:\n    \"\"\"\n    Calculates \u03b2 = v/c, the given velocity as a fraction of c\n    >>> beta(c)\n    1.0\n    >>> beta(199792458)\n    0.666435904801848\n    >>> beta(1e5)\n    0.00033356409519815205\n    >>> beta(0.2)\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must be greater than or equal to 1!\n    \"\"\"\n    if velocity > c:\n        raise ValueError(\"Speed must not exceed light speed 299,792,458 [m/s]!\")\n    elif velocity < 1:\n        # Usually the speed should be much higher than 1 (c order of magnitude)\n        raise ValueError(\"Speed must be greater than or equal to 1!\")\n\n    return velocity / c",
    "docstring": "Calculates \u03b2 = v/c, the given velocity as a fraction of c\n>>> beta(c)\n1.0\n>>> beta(199792458)\n0.666435904801848\n>>> beta(1e5)\n0.00033356409519815205\n>>> beta(0.2)\nTraceback (most recent call last):\n  ...\nValueError: Speed must be greater than or equal to 1!"
  },
  {
    "function": "gamma",
    "code": "def gamma(velocity: float) -> float:\n    \"\"\"\n    Calculate the Lorentz factor y = 1 / \u221a(1 - v\u00b2/c\u00b2) for a given velocity\n    >>> gamma(4)\n    1.0000000000000002\n    >>> gamma(1e5)\n    1.0000000556325075\n    >>> gamma(3e7)\n    1.005044845777813\n    >>> gamma(2.8e8)\n    2.7985595722318277\n    >>> gamma(299792451)\n    4627.49902669495\n    >>> gamma(0.3)\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must be greater than or equal to 1!\n    >>> gamma(2 * c)\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must not exceed light speed 299,792,458 [m/s]!\n    \"\"\"\n    return 1 / sqrt(1 - beta(velocity) ** 2)",
    "docstring": "Calculate the Lorentz factor y = 1 / \u221a(1 - v\u00b2/c\u00b2) for a given velocity\n>>> gamma(4)\n1.0000000000000002\n>>> gamma(1e5)\n1.0000000556325075\n>>> gamma(3e7)\n1.005044845777813\n>>> gamma(2.8e8)\n2.7985595722318277\n>>> gamma(299792451)\n4627.49902669495\n>>> gamma(0.3)\nTraceback (most recent call last):\n  ...\nValueError: Speed must be greater than or equal to 1!\n>>> gamma(2 * c)\nTraceback (most recent call last):\n  ...\nValueError: Speed must not exceed light speed 299,792,458 [m/s]!"
  },
  {
    "function": "transformation_matrix",
    "code": "def transformation_matrix(velocity: float) -> np.ndarray:\n    \"\"\"\n    Calculate the Lorentz transformation matrix for movement in the x direction:\n\n    | y  -\u03b3\u03b2  0  0|\n    |-\u03b3\u03b2  y   0  0|\n    | 0   0   1  0|\n    | 0   0   0  1|\n\n    where y is the Lorentz factor and \u03b2 is the velocity as a fraction of c\n    >>> transformation_matrix(29979245)\n    array([[ 1.00503781, -0.10050378,  0.        ,  0.        ],\n           [-0.10050378,  1.00503781,  0.        ,  0.        ],\n           [ 0.        ,  0.        ,  1.        ,  0.        ],\n           [ 0.        ,  0.        ,  0.        ,  1.        ]])\n    >>> transformation_matrix(19979245.2)\n    array([[ 1.00222811, -0.06679208,  0.        ,  0.        ],\n           [-0.06679208,  1.00222811,  0.        ,  0.        ],\n           [ 0.        ,  0.        ,  1.        ,  0.        ],\n           [ 0.        ,  0.        ,  0.        ,  1.        ]])\n    >>> transformation_matrix(1)\n    array([[ 1.00000000e+00, -3.33564095e-09,  0.00000000e+00,\n             0.00000000e+00],\n           [-3.33564095e-09,  1.00000000e+00,  0.00000000e+00,\n             0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00,\n             0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n             1.00000000e+00]])\n    >>> transformation_matrix(0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must be greater than or equal to 1!\n    >>> transformation_matrix(c * 1.5)\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must not exceed light speed 299,792,458 [m/s]!\n    \"\"\"\n    return np.array(\n        [\n            [gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],\n            [-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n        ]\n    )",
    "docstring": "Calculate the Lorentz transformation matrix for movement in the x direction:\n\n| y  -\u03b3\u03b2  0  0|\n|-\u03b3\u03b2  y   0  0|\n| 0   0   1  0|\n| 0   0   0  1|\n\nwhere y is the Lorentz factor and \u03b2 is the velocity as a fraction of c\n>>> transformation_matrix(29979245)\narray([[ 1.00503781, -0.10050378,  0.        ,  0.        ],\n       [-0.10050378,  1.00503781,  0.        ,  0.        ],\n       [ 0.        ,  0.        ,  1.        ,  0.        ],\n       [ 0.        ,  0.        ,  0.        ,  1.        ]])\n>>> transformation_matrix(19979245.2)\narray([[ 1.00222811, -0.06679208,  0.        ,  0.        ],\n       [-0.06679208,  1.00222811,  0.        ,  0.        ],\n       [ 0.        ,  0.        ,  1.        ,  0.        ],\n       [ 0.        ,  0.        ,  0.        ,  1.        ]])\n>>> transformation_matrix(1)\narray([[ 1.00000000e+00, -3.33564095e-09,  0.00000000e+00,\n         0.00000000e+00],\n       [-3.33564095e-09,  1.00000000e+00,  0.00000000e+00,\n         0.00000000e+00],\n       [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00,\n         0.00000000e+00],\n       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n         1.00000000e+00]])\n>>> transformation_matrix(0)\nTraceback (most recent call last):\n  ...\nValueError: Speed must be greater than or equal to 1!\n>>> transformation_matrix(c * 1.5)\nTraceback (most recent call last):\n  ...\nValueError: Speed must not exceed light speed 299,792,458 [m/s]!"
  },
  {
    "function": "transform",
    "code": "def transform(velocity: float, event: np.ndarray | None = None) -> np.ndarray:\n    \"\"\"\n    Calculate a Lorentz transformation for movement in the x direction given a\n    velocity and a four-vector for an inertial reference frame\n\n    If no four-vector is given, then calculate the transformation symbolically\n    with variables\n    >>> transform(29979245, np.array([1, 2, 3, 4]))\n    array([ 3.01302757e+08, -3.01302729e+07,  3.00000000e+00,  4.00000000e+00])\n    >>> transform(29979245)\n    array([1.00503781498831*ct - 0.100503778816875*x,\n           -0.100503778816875*ct + 1.00503781498831*x, 1.0*y, 1.0*z],\n          dtype=object)\n    >>> transform(19879210.2)\n    array([1.0022057787097*ct - 0.066456172618675*x,\n           -0.066456172618675*ct + 1.0022057787097*x, 1.0*y, 1.0*z],\n          dtype=object)\n    >>> transform(299792459, np.array([1, 1, 1, 1]))\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must not exceed light speed 299,792,458 [m/s]!\n    >>> transform(-1, np.array([1, 1, 1, 1]))\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must be greater than or equal to 1!\n    \"\"\"\n    # Ensure event is not empty\n    if event is None:\n        event = np.array([ct, x, y, z])  # Symbolic four vector\n    else:\n        event[0] *= c  # x0 is ct (speed of light * time)\n\n    return transformation_matrix(velocity) @ event",
    "docstring": "Calculate a Lorentz transformation for movement in the x direction given a\nvelocity and a four-vector for an inertial reference frame\n\nIf no four-vector is given, then calculate the transformation symbolically\nwith variables\n>>> transform(29979245, np.array([1, 2, 3, 4]))\narray([ 3.01302757e+08, -3.01302729e+07,  3.00000000e+00,  4.00000000e+00])\n>>> transform(29979245)\narray([1.00503781498831*ct - 0.100503778816875*x,\n       -0.100503778816875*ct + 1.00503781498831*x, 1.0*y, 1.0*z],\n      dtype=object)\n>>> transform(19879210.2)\narray([1.0022057787097*ct - 0.066456172618675*x,\n       -0.066456172618675*ct + 1.0022057787097*x, 1.0*y, 1.0*z],\n      dtype=object)\n>>> transform(299792459, np.array([1, 1, 1, 1]))\nTraceback (most recent call last):\n  ...\nValueError: Speed must not exceed light speed 299,792,458 [m/s]!\n>>> transform(-1, np.array([1, 1, 1, 1]))\nTraceback (most recent call last):\n  ...\nValueError: Speed must be greater than or equal to 1!"
  },
  {
    "function": "malus_law",
    "code": "def malus_law(initial_intensity: float, angle: float) -> float:\n    \"\"\"\n    >>> round(malus_law(10,45),2)\n    5.0\n    >>> round(malus_law(100,60),2)\n    25.0\n    >>> round(malus_law(50,150),2)\n    37.5\n    >>> round(malus_law(75,270),2)\n    0.0\n    >>> round(malus_law(10,-900),2)\n    Traceback (most recent call last):\n        ...\n    ValueError: In Malus Law, the angle is in the range 0-360 degrees\n    >>> round(malus_law(10,900),2)\n    Traceback (most recent call last):\n        ...\n    ValueError: In Malus Law, the angle is in the range 0-360 degrees\n    >>> round(malus_law(-100,900),2)\n    Traceback (most recent call last):\n        ...\n    ValueError: The value of intensity cannot be negative\n    >>> round(malus_law(100,180),2)\n    100.0\n    >>> round(malus_law(100,360),2)\n    100.0\n    \"\"\"\n\n    if initial_intensity < 0:\n        raise ValueError(\"The value of intensity cannot be negative\")\n        # handling of negative values of initial intensity\n    if angle < 0 or angle > 360:\n        raise ValueError(\"In Malus Law, the angle is in the range 0-360 degrees\")\n        # handling of values out of allowed range\n    return initial_intensity * (math.cos(math.radians(angle)) ** 2)",
    "docstring": ">>> round(malus_law(10,45),2)\n5.0\n>>> round(malus_law(100,60),2)\n25.0\n>>> round(malus_law(50,150),2)\n37.5\n>>> round(malus_law(75,270),2)\n0.0\n>>> round(malus_law(10,-900),2)\nTraceback (most recent call last):\n    ...\nValueError: In Malus Law, the angle is in the range 0-360 degrees\n>>> round(malus_law(10,900),2)\nTraceback (most recent call last):\n    ...\nValueError: In Malus Law, the angle is in the range 0-360 degrees\n>>> round(malus_law(-100,900),2)\nTraceback (most recent call last):\n    ...\nValueError: The value of intensity cannot be negative\n>>> round(malus_law(100,180),2)\n100.0\n>>> round(malus_law(100,360),2)\n100.0"
  },
  {
    "function": "energy_from_mass",
    "code": "def energy_from_mass(mass: float) -> float:\n    \"\"\"\n    Calculates the Energy equivalence of the Mass using E = mc\u00b2\n    in SI units J from Mass in kg.\n\n    mass (float): Mass of body.\n\n    Usage example:\n    >>> energy_from_mass(124.56)\n    1.11948945063458e+19\n    >>> energy_from_mass(320)\n    2.8760165719578165e+19\n    >>> energy_from_mass(0)\n    0.0\n    >>> energy_from_mass(-967.9)\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass can't be negative.\n\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"Mass can't be negative.\")\n    return mass * c**2",
    "docstring": "Calculates the Energy equivalence of the Mass using E = mc\u00b2\nin SI units J from Mass in kg.\n\nmass (float): Mass of body.\n\nUsage example:\n>>> energy_from_mass(124.56)\n1.11948945063458e+19\n>>> energy_from_mass(320)\n2.8760165719578165e+19\n>>> energy_from_mass(0)\n0.0\n>>> energy_from_mass(-967.9)\nTraceback (most recent call last):\n    ...\nValueError: Mass can't be negative."
  },
  {
    "function": "mass_from_energy",
    "code": "def mass_from_energy(energy: float) -> float:\n    \"\"\"\n    Calculates the Mass equivalence of the Energy using m = E/c\u00b2\n    in SI units kg from Energy in J.\n\n    energy (float): Mass of body.\n\n    Usage example:\n    >>> mass_from_energy(124.56)\n    1.3859169098203872e-15\n    >>> mass_from_energy(320)\n    3.560480179371579e-15\n    >>> mass_from_energy(0)\n    0.0\n    >>> mass_from_energy(-967.9)\n    Traceback (most recent call last):\n        ...\n    ValueError: Energy can't be negative.\n\n    \"\"\"\n    if energy < 0:\n        raise ValueError(\"Energy can't be negative.\")\n    return energy / c**2",
    "docstring": "Calculates the Mass equivalence of the Energy using m = E/c\u00b2\nin SI units kg from Energy in J.\n\nenergy (float): Mass of body.\n\nUsage example:\n>>> mass_from_energy(124.56)\n1.3859169098203872e-15\n>>> mass_from_energy(320)\n3.560480179371579e-15\n>>> mass_from_energy(0)\n0.0\n>>> mass_from_energy(-967.9)\nTraceback (most recent call last):\n    ...\nValueError: Energy can't be negative."
  },
  {
    "function": "focal_length",
    "code": "def focal_length(distance_of_object: float, distance_of_image: float) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(focal_length(10, 20), 6.66666666666666)\n    True\n    >>> from math import isclose\n    >>> isclose(focal_length(9.5, 6.7), 3.929012346)\n    True\n    >>> focal_length(0, 20)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n\n    if distance_of_object == 0 or distance_of_image == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n    focal_length = 1 / ((1 / distance_of_object) + (1 / distance_of_image))\n    return focal_length",
    "docstring": ">>> from math import isclose\n>>> isclose(focal_length(10, 20), 6.66666666666666)\nTrue\n>>> from math import isclose\n>>> isclose(focal_length(9.5, 6.7), 3.929012346)\nTrue\n>>> focal_length(0, 20)  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: Invalid inputs. Enter non zero values with respect\nto the sign convention."
  },
  {
    "function": "object_distance",
    "code": "def object_distance(focal_length: float, distance_of_image: float) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(object_distance(30, 20), -60.0)\n    True\n    >>> from math import isclose\n    >>> isclose(object_distance(10.5, 11.7), 102.375)\n    True\n    >>> object_distance(90, 0)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n\n    if distance_of_image == 0 or focal_length == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n    object_distance = 1 / ((1 / focal_length) - (1 / distance_of_image))\n    return object_distance",
    "docstring": ">>> from math import isclose\n>>> isclose(object_distance(30, 20), -60.0)\nTrue\n>>> from math import isclose\n>>> isclose(object_distance(10.5, 11.7), 102.375)\nTrue\n>>> object_distance(90, 0)  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: Invalid inputs. Enter non zero values with respect\nto the sign convention."
  },
  {
    "function": "image_distance",
    "code": "def image_distance(focal_length: float, distance_of_object: float) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(image_distance(10, 40), 13.33333333)\n    True\n    >>> from math import isclose\n    >>> isclose(image_distance(1.5, 6.7), 1.932692308)\n    True\n    >>> image_distance(0, 0)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n\n    if distance_of_object == 0 or focal_length == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n    image_distance = 1 / ((1 / focal_length) - (1 / distance_of_object))\n    return image_distance",
    "docstring": ">>> from math import isclose\n>>> isclose(image_distance(10, 40), 13.33333333)\nTrue\n>>> from math import isclose\n>>> isclose(image_distance(1.5, 6.7), 1.932692308)\nTrue\n>>> image_distance(0, 0)  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: Invalid inputs. Enter non zero values with respect\nto the sign convention."
  },
  {
    "function": "gravitational_law",
    "code": "def gravitational_law(\n    force: float, mass_1: float, mass_2: float, distance: float\n) -> dict[str, float]:\n    \"\"\"\n    Input Parameters\n    ----------------\n    force : magnitude in Newtons\n\n    mass_1 : mass in Kilograms\n\n    mass_2 : mass in Kilograms\n\n    distance : distance in Meters\n\n    Returns\n    -------\n    result : dict name, value pair of the parameter having Zero as it's value\n\n    Returns the value of one of the parameters specified as 0, provided the values of\n    other parameters are given.\n    >>> gravitational_law(force=0, mass_1=5, mass_2=10, distance=20)\n    {'force': 8.342875e-12}\n\n    >>> gravitational_law(force=7367.382, mass_1=0, mass_2=74, distance=3048)\n    {'mass_1': 1.385816317292268e+19}\n\n    >>> gravitational_law(force=36337.283, mass_1=0, mass_2=0, distance=35584)\n    Traceback (most recent call last):\n        ...\n    ValueError: One and only one argument must be 0\n\n    >>> gravitational_law(force=36337.283, mass_1=-674, mass_2=0, distance=35584)\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass can not be negative\n\n    >>> gravitational_law(force=-847938e12, mass_1=674, mass_2=0, distance=9374)\n    Traceback (most recent call last):\n        ...\n    ValueError: Gravitational force can not be negative\n    \"\"\"\n\n    product_of_mass = mass_1 * mass_2\n\n    if (force, mass_1, mass_2, distance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if force < 0:\n        raise ValueError(\"Gravitational force can not be negative\")\n    if distance < 0:\n        raise ValueError(\"Distance can not be negative\")\n    if mass_1 < 0 or mass_2 < 0:\n        raise ValueError(\"Mass can not be negative\")\n    if force == 0:\n        force = GRAVITATIONAL_CONSTANT * product_of_mass / (distance**2)\n        return {\"force\": force}\n    elif mass_1 == 0:\n        mass_1 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_2)\n        return {\"mass_1\": mass_1}\n    elif mass_2 == 0:\n        mass_2 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_1)\n        return {\"mass_2\": mass_2}\n    elif distance == 0:\n        distance = (GRAVITATIONAL_CONSTANT * product_of_mass / (force)) ** 0.5\n        return {\"distance\": distance}\n    raise ValueError(\"One and only one argument must be 0\")",
    "docstring": "Input Parameters\n----------------\nforce : magnitude in Newtons\n\nmass_1 : mass in Kilograms\n\nmass_2 : mass in Kilograms\n\ndistance : distance in Meters\n\nReturns\n-------\nresult : dict name, value pair of the parameter having Zero as it's value\n\nReturns the value of one of the parameters specified as 0, provided the values of\nother parameters are given.\n>>> gravitational_law(force=0, mass_1=5, mass_2=10, distance=20)\n{'force': 8.342875e-12}\n\n>>> gravitational_law(force=7367.382, mass_1=0, mass_2=74, distance=3048)\n{'mass_1': 1.385816317292268e+19}\n\n>>> gravitational_law(force=36337.283, mass_1=0, mass_2=0, distance=35584)\nTraceback (most recent call last):\n    ...\nValueError: One and only one argument must be 0\n\n>>> gravitational_law(force=36337.283, mass_1=-674, mass_2=0, distance=35584)\nTraceback (most recent call last):\n    ...\nValueError: Mass can not be negative\n\n>>> gravitational_law(force=-847938e12, mass_1=674, mass_2=0, distance=9374)\nTraceback (most recent call last):\n    ...\nValueError: Gravitational force can not be negative"
  },
  {
    "function": "newtons_second_law_of_motion",
    "code": "def newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    Calculates force from `mass` and `acceleration`\n\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force",
    "docstring": "Calculates force from `mass` and `acceleration`\n\n>>> newtons_second_law_of_motion(10, 10)\n100\n>>> newtons_second_law_of_motion(2.0, 1)\n2.0"
  },
  {
    "function": "update_step",
    "code": "def update_step(\n    body_system: BodySystem, delta_time: float, patches: list[plt.Circle]\n) -> None:\n    \"\"\"\n    Updates the body-system and applies the change to the patch-list used for plotting\n\n    >>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)])\n    >>> patches_1 = [plt.Circle((body.position_x, body.position_y), body.size,\n    ... fc=body.color)for body in body_system_1.bodies] #doctest: +ELLIPSIS\n    >>> update_step(body_system_1, 1, patches_1)\n    >>> patches_1[0].center\n    (0.01, 0.0)\n\n    >>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10)\n    >>> patches_2 = [plt.Circle((body.position_x, body.position_y), body.size,\n    ... fc=body.color)for body in body_system_2.bodies] #doctest: +ELLIPSIS\n    >>> update_step(body_system_2, 1, patches_2)\n    >>> patches_2[0].center\n    (-9.0, 0.0)\n    \"\"\"\n    # Update the positions of the bodies\n    body_system.update_system(delta_time)\n\n    # Update the positions of the patches\n    for patch, body in zip(patches, body_system.bodies):\n        patch.center = (body.position_x, body.position_y)",
    "docstring": "Updates the body-system and applies the change to the patch-list used for plotting\n\n>>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)])\n>>> patches_1 = [plt.Circle((body.position_x, body.position_y), body.size,\n... fc=body.color)for body in body_system_1.bodies] #doctest: +ELLIPSIS\n>>> update_step(body_system_1, 1, patches_1)\n>>> patches_1[0].center\n(0.01, 0.0)\n\n>>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10)\n>>> patches_2 = [plt.Circle((body.position_x, body.position_y), body.size,\n... fc=body.color)for body in body_system_2.bodies] #doctest: +ELLIPSIS\n>>> update_step(body_system_2, 1, patches_2)\n>>> patches_2[0].center\n(-9.0, 0.0)"
  },
  {
    "function": "plot",
    "code": "def plot(\n    title: str,\n    body_system: BodySystem,\n    x_start: float = -1,\n    x_end: float = 1,\n    y_start: float = -1,\n    y_end: float = 1,\n) -> None:\n    \"\"\"\n    Utility function to plot how the given body-system evolves over time.\n    No doctest provided since this function does not have a return value.\n    \"\"\"\n    fig = plt.figure()\n    fig.canvas.manager.set_window_title(title)\n    ax = plt.axes(\n        xlim=(x_start, x_end), ylim=(y_start, y_end)\n    )  # Set section to be plotted\n    plt.gca().set_aspect(\"equal\")  # Fix aspect ratio\n\n    # Each body is drawn as a patch by the plt-function\n    patches = [\n        plt.Circle((body.position_x, body.position_y), body.size, fc=body.color)\n        for body in body_system.bodies\n    ]\n\n    for patch in patches:\n        ax.add_patch(patch)\n\n    # Function called at each step of the animation\n    def update(frame: int) -> list[plt.Circle]:  # noqa: ARG001\n        update_step(body_system, DELTA_TIME, patches)\n        return patches\n\n    anim = animation.FuncAnimation(  # noqa: F841\n        fig, update, interval=INTERVAL, blit=True\n    )\n\n    plt.show()",
    "docstring": "Utility function to plot how the given body-system evolves over time.\nNo doctest provided since this function does not have a return value."
  },
  {
    "function": "example_1",
    "code": "def example_1() -> BodySystem:\n    \"\"\"\n    Example 1: figure-8 solution to the 3-body-problem\n    This example can be seen as a test of the implementation: given the right\n    initial conditions, the bodies should move in a figure-8.\n    (initial conditions taken from http://www.artcompsci.org/vol_1/v1_web/node56.html)\n    >>> body_system = example_1()\n    >>> len(body_system)\n    3\n    \"\"\"\n\n    position_x = 0.9700436\n    position_y = -0.24308753\n    velocity_x = 0.466203685\n    velocity_y = 0.43236573\n\n    bodies1 = [\n        Body(position_x, position_y, velocity_x, velocity_y, size=0.2, color=\"red\"),\n        Body(-position_x, -position_y, velocity_x, velocity_y, size=0.2, color=\"green\"),\n        Body(0, 0, -2 * velocity_x, -2 * velocity_y, size=0.2, color=\"blue\"),\n    ]\n    return BodySystem(bodies1, time_factor=3)",
    "docstring": "Example 1: figure-8 solution to the 3-body-problem\nThis example can be seen as a test of the implementation: given the right\ninitial conditions, the bodies should move in a figure-8.\n(initial conditions taken from http://www.artcompsci.org/vol_1/v1_web/node56.html)\n>>> body_system = example_1()\n>>> len(body_system)\n3"
  },
  {
    "function": "example_2",
    "code": "def example_2() -> BodySystem:\n    \"\"\"\n    Example 2: Moon's orbit around the earth\n    This example can be seen as a test of the implementation: given the right\n    initial conditions, the moon should orbit around the earth as it actually does.\n    (mass, velocity and distance taken from https://en.wikipedia.org/wiki/Earth\n    and https://en.wikipedia.org/wiki/Moon)\n    No doctest provided since this function does not have a return value.\n    \"\"\"\n\n    moon_mass = 7.3476e22\n    earth_mass = 5.972e24\n    velocity_dif = 1022\n    earth_moon_distance = 384399000\n    gravitation_constant = 6.674e-11\n\n    # Calculation of the respective velocities so that total impulse is zero,\n    # i.e. the two bodies together don't move\n    moon_velocity = earth_mass * velocity_dif / (earth_mass + moon_mass)\n    earth_velocity = moon_velocity - velocity_dif\n\n    moon = Body(-earth_moon_distance, 0, 0, moon_velocity, moon_mass, 10000000, \"grey\")\n    earth = Body(0, 0, 0, earth_velocity, earth_mass, 50000000, \"blue\")\n    return BodySystem([earth, moon], gravitation_constant, time_factor=1000000)",
    "docstring": "Example 2: Moon's orbit around the earth\nThis example can be seen as a test of the implementation: given the right\ninitial conditions, the moon should orbit around the earth as it actually does.\n(mass, velocity and distance taken from https://en.wikipedia.org/wiki/Earth\nand https://en.wikipedia.org/wiki/Moon)\nNo doctest provided since this function does not have a return value."
  },
  {
    "function": "example_3",
    "code": "def example_3() -> BodySystem:\n    \"\"\"\n    Example 3: Random system with many bodies.\n    No doctest provided since this function does not have a return value.\n    \"\"\"\n\n    bodies = []\n    for _ in range(10):\n        velocity_x = random.uniform(-0.5, 0.5)\n        velocity_y = random.uniform(-0.5, 0.5)\n\n        # Bodies are created pairwise with opposite velocities so that the\n        # total impulse remains zero\n        bodies.append(\n            Body(\n                random.uniform(-0.5, 0.5),\n                random.uniform(-0.5, 0.5),\n                velocity_x,\n                velocity_y,\n                size=0.05,\n            )\n        )\n        bodies.append(\n            Body(\n                random.uniform(-0.5, 0.5),\n                random.uniform(-0.5, 0.5),\n                -velocity_x,\n                -velocity_y,\n                size=0.05,\n            )\n        )\n    return BodySystem(bodies, 0.01, 10, 0.1)",
    "docstring": "Example 3: Random system with many bodies.\nNo doctest provided since this function does not have a return value."
  },
  {
    "function": "orbital_transfer_work",
    "code": "def orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    \"\"\"\n    Calculates the work required to move an object from one orbit to another in a\n    gravitational field based on the change in total mechanical energy.\n\n    The formula used is:\n        W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\n    where:\n        W = work done (Joules)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the central body (kg)\n        m = mass of the orbiting object (kg)\n        r_initial = initial orbit radius (m)\n        r_final = final orbit radius (m)\n\n    Args:\n        mass_central (float): Mass of the central body (kg)\n        mass_object (float): Mass of the object being moved (kg)\n        r_initial (float): Initial orbital radius (m)\n        r_final (float): Final orbital radius (m)\n\n    Returns:\n        str: Work done in Joules as a string in scientific notation (3 decimals)\n\n    Examples:\n        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n        '2.811e+09'\n        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n        '-1.405e+09'\n        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n        '1.514e+11'\n    \"\"\"\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\"",
    "docstring": "Calculates the work required to move an object from one orbit to another in a\ngravitational field based on the change in total mechanical energy.\n\nThe formula used is:\n    W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\nwhere:\n    W = work done (Joules)\n    G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n    M = mass of the central body (kg)\n    m = mass of the orbiting object (kg)\n    r_initial = initial orbit radius (m)\n    r_final = final orbit radius (m)\n\nArgs:\n    mass_central (float): Mass of the central body (kg)\n    mass_object (float): Mass of the object being moved (kg)\n    r_initial (float): Initial orbital radius (m)\n    r_final (float): Final orbital radius (m)\n\nReturns:\n    str: Work done in Joules as a string in scientific notation (3 decimals)\n\nExamples:\n    >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n    '2.811e+09'\n    >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n    '-1.405e+09'\n    >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n    '1.514e+11'"
  },
  {
    "function": "period_of_pendulum",
    "code": "def period_of_pendulum(length: float) -> float:\n    \"\"\"\n    >>> period_of_pendulum(1.23)\n    2.2252155506257845\n    >>> period_of_pendulum(2.37)\n    3.0888278441908574\n    >>> period_of_pendulum(5.63)\n    4.76073193364765\n    >>> period_of_pendulum(-12)\n    Traceback (most recent call last):\n        ...\n    ValueError: The length should be non-negative\n    >>> period_of_pendulum(0)\n    0.0\n    \"\"\"\n    if length < 0:\n        raise ValueError(\"The length should be non-negative\")\n    return 2 * pi * (length / g) ** 0.5",
    "docstring": ">>> period_of_pendulum(1.23)\n2.2252155506257845\n>>> period_of_pendulum(2.37)\n3.0888278441908574\n>>> period_of_pendulum(5.63)\n4.76073193364765\n>>> period_of_pendulum(-12)\nTraceback (most recent call last):\n    ...\nValueError: The length should be non-negative\n>>> period_of_pendulum(0)\n0.0"
  },
  {
    "function": "maximum_kinetic_energy",
    "code": "def maximum_kinetic_energy(\n    frequency: float, work_function: float, in_ev: bool = False\n) -> float:\n    \"\"\"\n    Calculates the maximum kinetic energy of emitted electron from the surface.\n    if the maximum kinetic energy is zero then no electron will be emitted\n    or given electromagnetic wave frequency is small.\n\n    frequency (float): Frequency of electromagnetic wave.\n    work_function (float): Work function of the surface.\n    in_ev (optional)(bool): Pass True if values are in eV.\n\n    Usage example:\n    >>> maximum_kinetic_energy(1000000,2)\n    0\n    >>> maximum_kinetic_energy(1000000,2,True)\n    0\n    >>> maximum_kinetic_energy(10000000000000000,2,True)\n    39.357000000000006\n    >>> maximum_kinetic_energy(-9,20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Frequency can't be negative.\n\n    >>> maximum_kinetic_energy(1000,\"a\")\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'float' and 'str'\n\n    \"\"\"\n    if frequency < 0:\n        raise ValueError(\"Frequency can't be negative.\")\n    if in_ev:\n        return max(PLANCK_CONSTANT_EVS * frequency - work_function, 0)\n    return max(PLANCK_CONSTANT_JS * frequency - work_function, 0)",
    "docstring": "Calculates the maximum kinetic energy of emitted electron from the surface.\nif the maximum kinetic energy is zero then no electron will be emitted\nor given electromagnetic wave frequency is small.\n\nfrequency (float): Frequency of electromagnetic wave.\nwork_function (float): Work function of the surface.\nin_ev (optional)(bool): Pass True if values are in eV.\n\nUsage example:\n>>> maximum_kinetic_energy(1000000,2)\n0\n>>> maximum_kinetic_energy(1000000,2,True)\n0\n>>> maximum_kinetic_energy(10000000000000000,2,True)\n39.357000000000006\n>>> maximum_kinetic_energy(-9,20)\nTraceback (most recent call last):\n    ...\nValueError: Frequency can't be negative.\n\n>>> maximum_kinetic_energy(1000,\"a\")\nTraceback (most recent call last):\n    ...\nTypeError: unsupported operand type(s) for -: 'float' and 'str'"
  },
  {
    "function": "potential_energy",
    "code": "def potential_energy(mass: float, height: float) -> float:\n    # function will accept mass and height as parameters and return potential energy\n    \"\"\"\n    >>> potential_energy(10,10)\n    980.665\n    >>> potential_energy(0,5)\n    0.0\n    >>> potential_energy(8,0)\n    0.0\n    >>> potential_energy(10,5)\n    490.3325\n    >>> potential_energy(0,0)\n    0.0\n    >>> potential_energy(2,8)\n    156.9064\n    >>> potential_energy(20,100)\n    19613.3\n    \"\"\"\n    if mass < 0:\n        # handling of negative values of mass\n        raise ValueError(\"The mass of a body cannot be negative\")\n    if height < 0:\n        # handling of negative values of height\n        raise ValueError(\"The height above the ground cannot be negative\")\n    return mass * g * height",
    "docstring": ">>> potential_energy(10,10)\n980.665\n>>> potential_energy(0,5)\n0.0\n>>> potential_energy(8,0)\n0.0\n>>> potential_energy(10,5)\n490.3325\n>>> potential_energy(0,0)\n0.0\n>>> potential_energy(2,8)\n156.9064\n>>> potential_energy(20,100)\n19613.3"
  },
  {
    "function": "rainfall_intensity",
    "code": "def rainfall_intensity(\n    coefficient_k: float,\n    coefficient_a: float,\n    coefficient_b: float,\n    coefficient_c: float,\n    return_period: float,\n    duration: float,\n) -> float:\n    \"\"\"\n    Calculate the intensity of a rainfall event for a given duration and return period.\n    It's based on the Sherman intensity-duration-frequency curve:\n\n    I = k * T^a / (D + b)^c\n\n    where:\n        I = Intensity of the rainfall event [mm/h]\n        k, a, b, c = Coefficients obtained through statistical distribution adjust\n        T = Return period in years\n        D = Rainfall event duration in minutes\n\n    Parameters\n    ----------\n    coefficient_k : float\n        Coefficient obtained through statistical distribution adjust.\n    coefficient_a : float\n        Coefficient obtained through statistical distribution adjust.\n    coefficient_b : float\n        Coefficient obtained through statistical distribution adjust.\n    coefficient_c : float\n        Coefficient obtained through statistical distribution adjust.\n    return_period : float\n        Return period in years.\n    duration : float\n        Rainfall event duration in minutes.\n\n    Returns\n    -------\n    intensity : float\n        Intensity of the rainfall event in mm/h.\n\n    Raises\n    ------\n    ValueError\n        If any of the parameters are not positive.\n\n    Examples\n    --------\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 60)\n    49.83339231138578\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 30)\n    77.36319588106228\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 5, 60)\n    43.382487747633625\n\n    >>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, -0.2, 11.6, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, -11.6, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, -0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0, 11.6, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, 0, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 0, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    \"\"\"\n    if (\n        coefficient_k <= 0\n        or coefficient_a <= 0\n        or coefficient_b <= 0\n        or coefficient_c <= 0\n        or return_period <= 0\n        or duration <= 0\n    ):\n        raise ValueError(\"All parameters must be positive.\")\n    intensity = (coefficient_k * (return_period**coefficient_a)) / (\n        (duration + coefficient_b) ** coefficient_c\n    )\n    return intensity",
    "docstring": "Calculate the intensity of a rainfall event for a given duration and return period.\nIt's based on the Sherman intensity-duration-frequency curve:\n\nI = k * T^a / (D + b)^c\n\nwhere:\n    I = Intensity of the rainfall event [mm/h]\n    k, a, b, c = Coefficients obtained through statistical distribution adjust\n    T = Return period in years\n    D = Rainfall event duration in minutes\n\nParameters\n----------\ncoefficient_k : float\n    Coefficient obtained through statistical distribution adjust.\ncoefficient_a : float\n    Coefficient obtained through statistical distribution adjust.\ncoefficient_b : float\n    Coefficient obtained through statistical distribution adjust.\ncoefficient_c : float\n    Coefficient obtained through statistical distribution adjust.\nreturn_period : float\n    Return period in years.\nduration : float\n    Rainfall event duration in minutes.\n\nReturns\n-------\nintensity : float\n    Intensity of the rainfall event in mm/h.\n\nRaises\n------\nValueError\n    If any of the parameters are not positive.\n\nExamples\n--------\n\n>>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 60)\n49.83339231138578\n\n>>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 30)\n77.36319588106228\n\n>>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 5, 60)\n43.382487747633625\n\n>>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60)\nTraceback (most recent call last):\n...\nValueError: All parameters must be positive.\n\n>>> rainfall_intensity(1000, -0.2, 11.6, 0.81, 10, 60)\nTraceback (most recent call last):\n...\nValueError: All parameters must be positive.\n\n>>> rainfall_intensity(1000, 0.2, -11.6, 0.81, 10, 60)\nTraceback (most recent call last):\n...\nValueError: All parameters must be positive.\n\n>>> rainfall_intensity(1000, 0.2, 11.6, -0.81, 10, 60)\nTraceback (most recent call last):\n...\nValueError: All parameters must be positive.\n\n>>> rainfall_intensity(1000, 0, 11.6, 0.81, 10, 60)\nTraceback (most recent call last):\n...\nValueError: All parameters must be positive.\n\n>>> rainfall_intensity(1000, 0.2, 0, 0.81, 10, 60)\nTraceback (most recent call last):\n...\nValueError: All parameters must be positive.\n\n>>> rainfall_intensity(1000, 0.2, 11.6, 0, 10, 60)\nTraceback (most recent call last):\n...\nValueError: All parameters must be positive.\n\n>>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60)\nTraceback (most recent call last):\n...\nValueError: All parameters must be positive.\n\n>>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 0, 60)\nTraceback (most recent call last):\n...\nValueError: All parameters must be positive.\n\n>>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 0)\nTraceback (most recent call last):\n...\nValueError: All parameters must be positive."
  },
  {
    "function": "reynolds_number",
    "code": "def reynolds_number(\n    density: float, velocity: float, diameter: float, viscosity: float\n) -> float:\n    \"\"\"\n    >>> reynolds_number(900, 2.5, 0.05, 0.4)\n    281.25\n    >>> reynolds_number(450, 3.86, 0.078, 0.23)\n    589.0695652173912\n    >>> reynolds_number(234, -4.5, 0.3, 0.44)\n    717.9545454545454\n    >>> reynolds_number(-90, 2, 0.045, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: please ensure that density, diameter and viscosity are positive\n    >>> reynolds_number(0, 2, -0.4, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: please ensure that density, diameter and viscosity are positive\n    \"\"\"\n\n    if density <= 0 or diameter <= 0 or viscosity <= 0:\n        raise ValueError(\n            \"please ensure that density, diameter and viscosity are positive\"\n        )\n    return (density * abs(velocity) * diameter) / viscosity",
    "docstring": ">>> reynolds_number(900, 2.5, 0.05, 0.4)\n281.25\n>>> reynolds_number(450, 3.86, 0.078, 0.23)\n589.0695652173912\n>>> reynolds_number(234, -4.5, 0.3, 0.44)\n717.9545454545454\n>>> reynolds_number(-90, 2, 0.045, 1)\nTraceback (most recent call last):\n    ...\nValueError: please ensure that density, diameter and viscosity are positive\n>>> reynolds_number(0, 2, -0.4, -2)\nTraceback (most recent call last):\n    ...\nValueError: please ensure that density, diameter and viscosity are positive"
  },
  {
    "function": "rms_speed_of_molecule",
    "code": "def rms_speed_of_molecule(temperature: float, molar_mass: float) -> float:\n    \"\"\"\n    >>> rms_speed_of_molecule(100, 2)\n    35.315279554323226\n    >>> rms_speed_of_molecule(273, 12)\n    23.821458421977443\n    \"\"\"\n    if temperature < 0:\n        raise Exception(\"Temperature cannot be less than 0 K\")\n    if molar_mass <= 0:\n        raise Exception(\"Molar mass cannot be less than or equal to 0 kg/mol\")\n    else:\n        return (3 * UNIVERSAL_GAS_CONSTANT * temperature / molar_mass) ** 0.5",
    "docstring": ">>> rms_speed_of_molecule(100, 2)\n35.315279554323226\n>>> rms_speed_of_molecule(273, 12)\n23.821458421977443"
  },
  {
    "function": "shear_stress",
    "code": "def shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )",
    "docstring": "This function can calculate any one of the three -\n1. Shear Stress\n2. Tangential Force\n3. Cross-sectional Area\nThis is calculated from the other two provided values\nExamples -\n>>> shear_stress(stress=25, tangential_force=100, area=0)\n('area', 4.0)\n>>> shear_stress(stress=0, tangential_force=1600, area=200)\n('stress', 8.0)\n>>> shear_stress(stress=1000, tangential_force=0, area=1200)\n('tangential_force', 1200000)"
  },
  {
    "function": "avg_speed_of_molecule",
    "code": "def avg_speed_of_molecule(temperature: float, molar_mass: float) -> float:\n    \"\"\"\n    Takes the temperature (in K) and molar mass (in kg/mol) of a gas\n    and returns the average speed of a molecule in the gas (in m/s).\n\n    Examples:\n\n    >>> avg_speed_of_molecule(273, 0.028) # nitrogen at 273 K\n    454.3488755062257\n    >>> avg_speed_of_molecule(300, 0.032) # oxygen at 300 K\n    445.5257273433045\n    >>> avg_speed_of_molecule(-273, 0.028) # invalid temperature\n    Traceback (most recent call last):\n        ...\n    Exception: Absolute temperature cannot be less than 0 K\n    >>> avg_speed_of_molecule(273, 0) # invalid molar mass\n    Traceback (most recent call last):\n        ...\n    Exception: Molar mass should be greater than 0 kg/mol\n    \"\"\"\n\n    if temperature < 0:\n        raise Exception(\"Absolute temperature cannot be less than 0 K\")\n    if molar_mass <= 0:\n        raise Exception(\"Molar mass should be greater than 0 kg/mol\")\n    return (8 * R * temperature / (pi * molar_mass)) ** 0.5",
    "docstring": "Takes the temperature (in K) and molar mass (in kg/mol) of a gas\nand returns the average speed of a molecule in the gas (in m/s).\n\nExamples:\n\n>>> avg_speed_of_molecule(273, 0.028) # nitrogen at 273 K\n454.3488755062257\n>>> avg_speed_of_molecule(300, 0.032) # oxygen at 300 K\n445.5257273433045\n>>> avg_speed_of_molecule(-273, 0.028) # invalid temperature\nTraceback (most recent call last):\n    ...\nException: Absolute temperature cannot be less than 0 K\n>>> avg_speed_of_molecule(273, 0) # invalid molar mass\nTraceback (most recent call last):\n    ...\nException: Molar mass should be greater than 0 kg/mol"
  },
  {
    "function": "mps_speed_of_molecule",
    "code": "def mps_speed_of_molecule(temperature: float, molar_mass: float) -> float:\n    \"\"\"\n    Takes the temperature (in K) and molar mass (in kg/mol) of a gas\n    and returns the most probable speed of a molecule in the gas (in m/s).\n\n    Examples:\n\n    >>> mps_speed_of_molecule(273, 0.028) # nitrogen at 273 K\n    402.65620702280023\n    >>> mps_speed_of_molecule(300, 0.032) # oxygen at 300 K\n    394.8368955535605\n    >>> mps_speed_of_molecule(-273, 0.028) # invalid temperature\n    Traceback (most recent call last):\n        ...\n    Exception: Absolute temperature cannot be less than 0 K\n    >>> mps_speed_of_molecule(273, 0) # invalid molar mass\n    Traceback (most recent call last):\n        ...\n    Exception: Molar mass should be greater than 0 kg/mol\n    \"\"\"\n\n    if temperature < 0:\n        raise Exception(\"Absolute temperature cannot be less than 0 K\")\n    if molar_mass <= 0:\n        raise Exception(\"Molar mass should be greater than 0 kg/mol\")\n    return (2 * R * temperature / molar_mass) ** 0.5",
    "docstring": "Takes the temperature (in K) and molar mass (in kg/mol) of a gas\nand returns the most probable speed of a molecule in the gas (in m/s).\n\nExamples:\n\n>>> mps_speed_of_molecule(273, 0.028) # nitrogen at 273 K\n402.65620702280023\n>>> mps_speed_of_molecule(300, 0.032) # oxygen at 300 K\n394.8368955535605\n>>> mps_speed_of_molecule(-273, 0.028) # invalid temperature\nTraceback (most recent call last):\n    ...\nException: Absolute temperature cannot be less than 0 K\n>>> mps_speed_of_molecule(273, 0) # invalid molar mass\nTraceback (most recent call last):\n    ...\nException: Molar mass should be greater than 0 kg/mol"
  },
  {
    "function": "speed_of_sound_in_a_fluid",
    "code": "def speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20\u00b0C: bulk_modulus= 2.15MPa, density=998kg/m\u00b3\n    Example 2 --> Mercury 20\u00b0C: bulk_modulus= 28.5MPa, density=13600kg/m\u00b3\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5",
    "docstring": "Calculates the speed of sound in a fluid from its density and bulk modulus\n\nExamples:\nExample 1 --> Water 20\u00b0C: bulk_modulus= 2.15MPa, density=998kg/m\u00b3\nExample 2 --> Mercury 20\u00b0C: bulk_modulus= 28.5MPa, density=13600kg/m\u00b3\n\n>>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n1467.7563207952705\n>>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n1447.614670861731"
  },
  {
    "function": "terminal_velocity",
    "code": "def terminal_velocity(\n    mass: float, density: float, area: float, drag_coefficient: float\n) -> float:\n    \"\"\"\n    >>> terminal_velocity(1, 25, 0.6, 0.77)\n    1.3031197996044768\n    >>> terminal_velocity(2, 100, 0.45, 0.23)\n    1.9467947148674276\n    >>> terminal_velocity(5, 50, 0.2, 0.5)\n    4.428690551393267\n    >>> terminal_velocity(-5, 50, -0.2, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: mass, density, area and the drag coefficient all need to be positive\n    >>> terminal_velocity(3, -20, -1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: mass, density, area and the drag coefficient all need to be positive\n    >>> terminal_velocity(-2, -1, -0.44, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: mass, density, area and the drag coefficient all need to be positive\n    \"\"\"\n    if mass <= 0 or density <= 0 or area <= 0 or drag_coefficient <= 0:\n        raise ValueError(\n            \"mass, density, area and the drag coefficient all need to be positive\"\n        )\n    return ((2 * mass * g) / (density * area * drag_coefficient)) ** 0.5",
    "docstring": ">>> terminal_velocity(1, 25, 0.6, 0.77)\n1.3031197996044768\n>>> terminal_velocity(2, 100, 0.45, 0.23)\n1.9467947148674276\n>>> terminal_velocity(5, 50, 0.2, 0.5)\n4.428690551393267\n>>> terminal_velocity(-5, 50, -0.2, -2)\nTraceback (most recent call last):\n    ...\nValueError: mass, density, area and the drag coefficient all need to be positive\n>>> terminal_velocity(3, -20, -1, 2)\nTraceback (most recent call last):\n    ...\nValueError: mass, density, area and the drag coefficient all need to be positive\n>>> terminal_velocity(-2, -1, -0.44, -1)\nTraceback (most recent call last):\n    ...\nValueError: mass, density, area and the drag coefficient all need to be positive"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    >>> solution(-7)\n    0\n    \"\"\"\n\n    return sum(e for e in range(3, n) if e % 3 == 0 or e % 5 == 0)",
    "docstring": "Returns the sum of all the multiples of 3 or 5 below n.\n\n>>> solution(3)\n0\n>>> solution(4)\n3\n>>> solution(10)\n23\n>>> solution(600)\n83700\n>>> solution(-7)\n0"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    total = 0\n    terms = (n - 1) // 3\n    total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.\n    terms = (n - 1) // 5\n    total += ((terms) * (10 + (terms - 1) * 5)) // 2\n    terms = (n - 1) // 15\n    total -= ((terms) * (30 + (terms - 1) * 15)) // 2\n    return total",
    "docstring": "Returns the sum of all the multiples of 3 or 5 below n.\n\n>>> solution(3)\n0\n>>> solution(4)\n3\n>>> solution(10)\n23\n>>> solution(600)\n83700"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    This solution is based on the pattern that the successive numbers in the\n    series follow: 0+3,+2,+1,+3,+1,+2,+3.\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    total = 0\n    num = 0\n    while 1:\n        num += 3\n        if num >= n:\n            break\n        total += num\n        num += 2\n        if num >= n:\n            break\n        total += num\n        num += 1\n        if num >= n:\n            break\n        total += num\n        num += 3\n        if num >= n:\n            break\n        total += num\n        num += 1\n        if num >= n:\n            break\n        total += num\n        num += 2\n        if num >= n:\n            break\n        total += num\n        num += 3\n        if num >= n:\n            break\n        total += num\n    return total",
    "docstring": "This solution is based on the pattern that the successive numbers in the\nseries follow: 0+3,+2,+1,+3,+1,+2,+3.\nReturns the sum of all the multiples of 3 or 5 below n.\n\n>>> solution(3)\n0\n>>> solution(4)\n3\n>>> solution(10)\n23\n>>> solution(600)\n83700"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    xmulti = []\n    zmulti = []\n    z = 3\n    x = 5\n    temp = 1\n    while True:\n        result = z * temp\n        if result < n:\n            zmulti.append(result)\n            temp += 1\n        else:\n            temp = 1\n            break\n    while True:\n        result = x * temp\n        if result < n:\n            xmulti.append(result)\n            temp += 1\n        else:\n            break\n    collection = list(set(xmulti + zmulti))\n    return sum(collection)",
    "docstring": "Returns the sum of all the multiples of 3 or 5 below n.\n\n>>> solution(3)\n0\n>>> solution(4)\n3\n>>> solution(10)\n23\n>>> solution(600)\n83700"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n    A straightforward pythonic solution using list comprehension.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)",
    "docstring": "Returns the sum of all the multiples of 3 or 5 below n.\nA straightforward pythonic solution using list comprehension.\n\n>>> solution(3)\n0\n>>> solution(4)\n3\n>>> solution(10)\n23\n>>> solution(600)\n83700"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    a = 3\n    result = 0\n    while a < n:\n        if a % 3 == 0 or a % 5 == 0:\n            result += a\n        elif a % 15 == 0:\n            result -= a\n        a += 1\n    return result",
    "docstring": "Returns the sum of all the multiples of 3 or 5 below n.\n\n>>> solution(3)\n0\n>>> solution(4)\n3\n>>> solution(10)\n23\n>>> solution(600)\n83700"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    result = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            result += i\n    return result",
    "docstring": "Returns the sum of all the multiples of 3 or 5 below n.\n\n>>> solution(3)\n0\n>>> solution(4)\n3\n>>> solution(10)\n23\n>>> solution(600)\n83700"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    \"\"\"\n\n    i = 1\n    j = 2\n    total = 0\n    while j <= n:\n        if j % 2 == 0:\n            total += j\n        i, j = j, i + j\n\n    return total",
    "docstring": "Returns the sum of all even fibonacci sequence elements that are lower\nor equal to n.\n\n>>> solution(10)\n10\n>>> solution(15)\n10\n>>> solution(2)\n2\n>>> solution(1)\n0\n>>> solution(34)\n44"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    \"\"\"\n\n    even_fibs = []\n    a, b = 0, 1\n    while b <= n:\n        if b % 2 == 0:\n            even_fibs.append(b)\n        a, b = b, a + b\n    return sum(even_fibs)",
    "docstring": "Returns the sum of all even fibonacci sequence elements that are lower\nor equal to n.\n\n>>> solution(10)\n10\n>>> solution(15)\n10\n>>> solution(2)\n2\n>>> solution(1)\n0\n>>> solution(34)\n44"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    a = 0\n    b = 2\n    count = 0\n    while 4 * b + a <= n:\n        a, b = b, 4 * b + a\n        count += a\n    return count + b",
    "docstring": "Returns the sum of all even fibonacci sequence elements that are lower\nor equal to n.\n\n>>> solution(10)\n10\n>>> solution(15)\n10\n>>> solution(2)\n2\n>>> solution(1)\n0\n>>> solution(34)\n44"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    >>> solution(3.4)\n    2\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    getcontext().prec = 100\n    phi = (Decimal(5) ** Decimal(\"0.5\") + 1) / Decimal(2)\n\n    index = (math.floor(math.log(n * (phi + 2), phi) - 1) // 3) * 3 + 2\n    num = Decimal(round(phi ** Decimal(index + 1))) / (phi + 2)\n    total = num // 2\n    return int(total)",
    "docstring": "Returns the sum of all even fibonacci sequence elements that are lower\nor equal to n.\n\n>>> solution(10)\n10\n>>> solution(15)\n10\n>>> solution(2)\n2\n>>> solution(1)\n0\n>>> solution(34)\n44\n>>> solution(3.4)\n2\n>>> solution(0)\nTraceback (most recent call last):\n    ...\nValueError: Parameter n must be greater than or equal to one.\n>>> solution(-17)\nTraceback (most recent call last):\n    ...\nValueError: Parameter n must be greater than or equal to one.\n>>> solution([])\nTraceback (most recent call last):\n    ...\nTypeError: Parameter n must be int or castable to int.\n>>> solution(\"asd\")\nTraceback (most recent call last):\n    ...\nTypeError: Parameter n must be int or castable to int."
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    \"\"\"\n\n    fib = [0, 1]\n    i = 0\n    while fib[i] <= n:\n        fib.append(fib[i] + fib[i + 1])\n        if fib[i + 2] > n:\n            break\n        i += 1\n    total = 0\n    for j in range(len(fib) - 1):\n        if fib[j] % 2 == 0:\n            total += fib[j]\n\n    return total",
    "docstring": "Returns the sum of all even fibonacci sequence elements that are lower\nor equal to n.\n\n>>> solution(10)\n10\n>>> solution(15)\n10\n>>> solution(2)\n2\n>>> solution(1)\n0\n>>> solution(34)\n44"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\nA number is prime if it has exactly two factors: 1 and itself.\nReturns boolean representing primality of given number (i.e., if the\nresult is true, then the number is indeed prime else it is not).\n\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(2999)\nTrue\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 600851475143) -> int:\n    \"\"\"\n    Returns the largest prime factor of a given number n.\n\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    max_number = 0\n    if is_prime(n):\n        return n\n    while n % 2 == 0:\n        n //= 2\n    if is_prime(n):\n        return n\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            if is_prime(n // i):\n                max_number = n // i\n                break\n            elif is_prime(i):\n                max_number = i\n    return max_number",
    "docstring": "Returns the largest prime factor of a given number n.\n\n>>> solution(13195)\n29\n>>> solution(10)\n5\n>>> solution(17)\n17\n>>> solution(3.4)\n3\n>>> solution(0)\nTraceback (most recent call last):\n    ...\nValueError: Parameter n must be greater than or equal to one.\n>>> solution(-17)\nTraceback (most recent call last):\n    ...\nValueError: Parameter n must be greater than or equal to one.\n>>> solution([])\nTraceback (most recent call last):\n    ...\nTypeError: Parameter n must be int or castable to int.\n>>> solution(\"asd\")\nTraceback (most recent call last):\n    ...\nTypeError: Parameter n must be int or castable to int."
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 600851475143) -> int:\n    \"\"\"\n    Returns the largest prime factor of a given number n.\n\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    prime = 1\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        prime = n\n    return int(prime)",
    "docstring": "Returns the largest prime factor of a given number n.\n\n>>> solution(13195)\n29\n>>> solution(10)\n5\n>>> solution(17)\n17\n>>> solution(3.4)\n3\n>>> solution(0)\nTraceback (most recent call last):\n    ...\nValueError: Parameter n must be greater than or equal to one.\n>>> solution(-17)\nTraceback (most recent call last):\n    ...\nValueError: Parameter n must be greater than or equal to one.\n>>> solution([])\nTraceback (most recent call last):\n    ...\nTypeError: Parameter n must be int or castable to int.\n>>> solution(\"asd\")\nTraceback (most recent call last):\n    ...\nTypeError: Parameter n must be int or castable to int."
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 600851475143) -> int:\n    \"\"\"\n    Returns the largest prime factor of a given number n.\n\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    i = 2\n    ans = 0\n    if n == 2:\n        return 2\n    while n > 2:\n        while n % i != 0:\n            i += 1\n        ans = i\n        while n % i == 0:\n            n = n // i\n        i += 1\n    return int(ans)",
    "docstring": "Returns the largest prime factor of a given number n.\n\n>>> solution(13195)\n29\n>>> solution(10)\n5\n>>> solution(17)\n17\n>>> solution(3.4)\n3\n>>> solution(0)\nTraceback (most recent call last):\n    ...\nValueError: Parameter n must be greater than or equal to one.\n>>> solution(-17)\nTraceback (most recent call last):\n    ...\nValueError: Parameter n must be greater than or equal to one.\n>>> solution([])\nTraceback (most recent call last):\n    ...\nTypeError: Parameter n must be int or castable to int.\n>>> solution(\"asd\")\nTraceback (most recent call last):\n    ...\nTypeError: Parameter n must be int or castable to int."
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 998001) -> int:\n    \"\"\"\n    Returns the largest palindrome made from the product of two 3-digit\n    numbers which is less than n.\n\n    >>> solution(20000)\n    19591\n    >>> solution(30000)\n    29992\n    >>> solution(40000)\n    39893\n    >>> solution(10000)\n    Traceback (most recent call last):\n        ...\n    ValueError: That number is larger than our acceptable range.\n    \"\"\"\n\n    # fetches the next number\n    for number in range(n - 1, 9999, -1):\n        str_number = str(number)\n\n        # checks whether 'str_number' is a palindrome.\n        if str_number == str_number[::-1]:\n            divisor = 999\n\n            # if 'number' is a product of two 3-digit numbers\n            # then number is the answer otherwise fetch next number.\n            while divisor != 99:\n                if (number % divisor == 0) and (len(str(number // divisor)) == 3.0):\n                    return number\n                divisor -= 1\n    raise ValueError(\"That number is larger than our acceptable range.\")",
    "docstring": "Returns the largest palindrome made from the product of two 3-digit\nnumbers which is less than n.\n\n>>> solution(20000)\n19591\n>>> solution(30000)\n29992\n>>> solution(40000)\n39893\n>>> solution(10000)\nTraceback (most recent call last):\n    ...\nValueError: That number is larger than our acceptable range."
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 998001) -> int:\n    \"\"\"\n    Returns the largest palindrome made from the product of two 3-digit\n    numbers which is less than n.\n\n    >>> solution(20000)\n    19591\n    >>> solution(30000)\n    29992\n    >>> solution(40000)\n    39893\n    \"\"\"\n\n    answer = 0\n    for i in range(999, 99, -1):  # 3 digit numbers range from 999 down to 100\n        for j in range(999, 99, -1):\n            product_string = str(i * j)\n            if product_string == product_string[::-1] and i * j < n:\n                answer = max(answer, i * j)\n    return answer",
    "docstring": "Returns the largest palindrome made from the product of two 3-digit\nnumbers which is less than n.\n\n>>> solution(20000)\n19591\n>>> solution(30000)\n29992\n>>> solution(40000)\n39893"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 20) -> int:\n    \"\"\"\n    Returns the smallest positive number that is evenly divisible (divisible\n    with no remainder) by all of the numbers from 1 to n.\n\n    >>> solution(10)\n    2520\n    >>> solution(15)\n    360360\n    >>> solution(22)\n    232792560\n    >>> solution(3.4)\n    6\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    i = 0\n    while 1:\n        i += n * (n - 1)\n        nfound = 0\n        for j in range(2, n):\n            if i % j != 0:\n                nfound = 1\n                break\n        if nfound == 0:\n            if i == 0:\n                i = 1\n            return i\n    return None",
    "docstring": "Returns the smallest positive number that is evenly divisible (divisible\nwith no remainder) by all of the numbers from 1 to n.\n\n>>> solution(10)\n2520\n>>> solution(15)\n360360\n>>> solution(22)\n232792560\n>>> solution(3.4)\n6\n>>> solution(0)\nTraceback (most recent call last):\n    ...\nValueError: Parameter n must be greater than or equal to one.\n>>> solution(-17)\nTraceback (most recent call last):\n    ...\nValueError: Parameter n must be greater than or equal to one.\n>>> solution([])\nTraceback (most recent call last):\n    ...\nTypeError: Parameter n must be int or castable to int.\n>>> solution(\"asd\")\nTraceback (most recent call last):\n    ...\nTypeError: Parameter n must be int or castable to int."
  },
  {
    "function": "lcm",
    "code": "def lcm(x: int, y: int) -> int:\n    \"\"\"\n    Least Common Multiple.\n\n    Using the property that lcm(a, b) * greatest_common_divisor(a, b) = a*b\n\n    >>> lcm(3, 15)\n    15\n    >>> lcm(1, 27)\n    27\n    >>> lcm(13, 27)\n    351\n    >>> lcm(64, 48)\n    192\n    \"\"\"\n\n    return (x * y) // greatest_common_divisor(x, y)",
    "docstring": "Least Common Multiple.\n\nUsing the property that lcm(a, b) * greatest_common_divisor(a, b) = a*b\n\n>>> lcm(3, 15)\n15\n>>> lcm(1, 27)\n27\n>>> lcm(13, 27)\n351\n>>> lcm(64, 48)\n192"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 20) -> int:\n    \"\"\"\n    Returns the smallest positive number that is evenly divisible (divisible\n    with no remainder) by all of the numbers from 1 to n.\n\n    >>> solution(10)\n    2520\n    >>> solution(15)\n    360360\n    >>> solution(22)\n    232792560\n    \"\"\"\n\n    g = 1\n    for i in range(1, n + 1):\n        g = lcm(g, i)\n    return g",
    "docstring": "Returns the smallest positive number that is evenly divisible (divisible\nwith no remainder) by all of the numbers from 1 to n.\n\n>>> solution(10)\n2520\n>>> solution(15)\n360360\n>>> solution(22)\n232792560"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i**2\n        sum_of_ints += i\n    return sum_of_ints**2 - sum_of_squares",
    "docstring": "Returns the difference between the sum of the squares of the first n\nnatural numbers and the square of the sum.\n\n>>> solution(10)\n2640\n>>> solution(15)\n13160\n>>> solution(20)\n41230\n>>> solution(50)\n1582700"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares",
    "docstring": "Returns the difference between the sum of the squares of the first n\nnatural numbers and the square of the sum.\n\n>>> solution(10)\n2640\n>>> solution(15)\n13160\n>>> solution(20)\n41230\n>>> solution(50)\n1582700"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_of_squares = sum(i * i for i in range(1, n + 1))\n    square_of_sum = int(math.pow(sum(range(1, n + 1)), 2))\n    return square_of_sum - sum_of_squares",
    "docstring": "Returns the difference between the sum of the squares of the first n\nnatural numbers and the square of the sum.\n\n>>> solution(10)\n2640\n>>> solution(15)\n13160\n>>> solution(20)\n41230\n>>> solution(50)\n1582700"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)",
    "docstring": "Returns the difference between the sum of the squares of the first n\nnatural numbers and the square of the sum.\n\n>>> solution(10)\n2640\n>>> solution(15)\n13160\n>>> solution(20)\n41230\n>>> solution(50)\n1582700"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\nA number is prime if it has exactly two factors: 1 and itself.\nReturns boolean representing primality of given number (i.e., if the\nresult is true, then the number is indeed prime else it is not).\n\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(2999)\nTrue\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(nth: int = 10001) -> int:\n    \"\"\"\n    Returns the n-th prime number.\n\n    >>> solution(6)\n    13\n    >>> solution(1)\n    2\n    >>> solution(3)\n    5\n    >>> solution(20)\n    71\n    >>> solution(50)\n    229\n    >>> solution(100)\n    541\n    \"\"\"\n\n    count = 0\n    number = 1\n    while count != nth and number < 3:\n        number += 1\n        if is_prime(number):\n            count += 1\n    while count != nth:\n        number += 2\n        if is_prime(number):\n            count += 1\n    return number",
    "docstring": "Returns the n-th prime number.\n\n>>> solution(6)\n13\n>>> solution(1)\n2\n>>> solution(3)\n5\n>>> solution(20)\n71\n>>> solution(50)\n229\n>>> solution(100)\n541"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\nA number is prime if it has exactly two factors: 1 and itself.\nReturns boolean representing primality of given number (i.e., if the\nresult is true, then the number is indeed prime else it is not).\n\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(2999)\nTrue\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(nth: int = 10001) -> int:\n    \"\"\"\n    Returns the n-th prime number.\n\n    >>> solution(6)\n    13\n    >>> solution(1)\n    2\n    >>> solution(3)\n    5\n    >>> solution(20)\n    71\n    >>> solution(50)\n    229\n    >>> solution(100)\n    541\n    >>> solution(3.4)\n    5\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter nth must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter nth must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter nth must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter nth must be int or castable to int.\n    \"\"\"\n\n    try:\n        nth = int(nth)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter nth must be int or castable to int.\") from None\n    if nth <= 0:\n        raise ValueError(\"Parameter nth must be greater than or equal to one.\")\n    primes: list[int] = []\n    num = 2\n    while len(primes) < nth:\n        if is_prime(num):\n            primes.append(num)\n            num += 1\n        else:\n            num += 1\n    return primes[len(primes) - 1]",
    "docstring": "Returns the n-th prime number.\n\n>>> solution(6)\n13\n>>> solution(1)\n2\n>>> solution(3)\n5\n>>> solution(20)\n71\n>>> solution(50)\n229\n>>> solution(100)\n541\n>>> solution(3.4)\n5\n>>> solution(0)\nTraceback (most recent call last):\n    ...\nValueError: Parameter nth must be greater than or equal to one.\n>>> solution(-17)\nTraceback (most recent call last):\n    ...\nValueError: Parameter nth must be greater than or equal to one.\n>>> solution([])\nTraceback (most recent call last):\n    ...\nTypeError: Parameter nth must be int or castable to int.\n>>> solution(\"asd\")\nTraceback (most recent call last):\n    ...\nTypeError: Parameter nth must be int or castable to int."
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\nA number is prime if it has exactly two factors: 1 and itself.\nReturns boolean representing primality of given number (i.e., if the\nresult is true, then the number is indeed prime else it is not).\n\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(2999)\nTrue\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse"
  },
  {
    "function": "prime_generator",
    "code": "def prime_generator():\n    \"\"\"\n    Generate a sequence of prime numbers\n    \"\"\"\n\n    num = 2\n    while True:\n        if is_prime(num):\n            yield num\n        num += 1",
    "docstring": "Generate a sequence of prime numbers"
  },
  {
    "function": "solution",
    "code": "def solution(nth: int = 10001) -> int:\n    \"\"\"\n    Returns the n-th prime number.\n\n    >>> solution(6)\n    13\n    >>> solution(1)\n    2\n    >>> solution(3)\n    5\n    >>> solution(20)\n    71\n    >>> solution(50)\n    229\n    >>> solution(100)\n    541\n    \"\"\"\n    return next(itertools.islice(prime_generator(), nth - 1, nth))",
    "docstring": "Returns the n-th prime number.\n\n>>> solution(6)\n13\n>>> solution(1)\n2\n>>> solution(3)\n5\n>>> solution(20)\n71\n>>> solution(50)\n229\n>>> solution(100)\n541"
  },
  {
    "function": "solution",
    "code": "def solution(n: str = N) -> int:\n    \"\"\"\n    Find the thirteen adjacent digits in the 1000-digit number n that have\n    the greatest product and returns it.\n\n    >>> solution(\"13978431290823798458352374\")\n    609638400\n    >>> solution(\"13978431295823798458352374\")\n    2612736000\n    >>> solution(\"1397843129582379841238352374\")\n    209018880\n    \"\"\"\n\n    largest_product = -sys.maxsize - 1\n    for i in range(len(n) - 12):\n        product = 1\n        for j in range(13):\n            product *= int(n[i + j])\n        largest_product = max(largest_product, product)\n    return largest_product",
    "docstring": "Find the thirteen adjacent digits in the 1000-digit number n that have\nthe greatest product and returns it.\n\n>>> solution(\"13978431290823798458352374\")\n609638400\n>>> solution(\"13978431295823798458352374\")\n2612736000\n>>> solution(\"1397843129582379841238352374\")\n209018880"
  },
  {
    "function": "solution",
    "code": "def solution(n: str = N) -> int:\n    \"\"\"\n    Find the thirteen adjacent digits in the 1000-digit number n that have\n    the greatest product and returns it.\n\n    >>> solution(\"13978431290823798458352374\")\n    609638400\n    >>> solution(\"13978431295823798458352374\")\n    2612736000\n    >>> solution(\"1397843129582379841238352374\")\n    209018880\n    \"\"\"\n\n    return max(\n        # mypy cannot properly interpret reduce\n        int(reduce(lambda x, y: str(int(x) * int(y)), n[i : i + 13]))\n        for i in range(len(n) - 12)\n    )",
    "docstring": "Find the thirteen adjacent digits in the 1000-digit number n that have\nthe greatest product and returns it.\n\n>>> solution(\"13978431290823798458352374\")\n609638400\n>>> solution(\"13978431295823798458352374\")\n2612736000\n>>> solution(\"1397843129582379841238352374\")\n209018880"
  },
  {
    "function": "str_eval",
    "code": "def str_eval(s: str) -> int:\n    \"\"\"\n    Returns product of digits in given string n\n\n    >>> str_eval(\"987654321\")\n    362880\n    >>> str_eval(\"22222222\")\n    256\n    \"\"\"\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product",
    "docstring": "Returns product of digits in given string n\n\n>>> str_eval(\"987654321\")\n362880\n>>> str_eval(\"22222222\")\n256"
  },
  {
    "function": "solution",
    "code": "def solution(n: str = N) -> int:\n    \"\"\"\n    Find the thirteen adjacent digits in the 1000-digit number n that have\n    the greatest product and returns it.\n    \"\"\"\n\n    largest_product = -sys.maxsize - 1\n    substr = n[:13]\n    cur_index = 13\n    while cur_index < len(n) - 13:\n        if int(n[cur_index]) >= int(substr[0]):\n            substr = substr[1:] + n[cur_index]\n            cur_index += 1\n        else:\n            largest_product = max(largest_product, str_eval(substr))\n            substr = n[cur_index : cur_index + 13]\n            cur_index += 13\n    return largest_product",
    "docstring": "Find the thirteen adjacent digits in the 1000-digit number n that have\nthe greatest product and returns it."
  },
  {
    "function": "solution",
    "code": "def solution() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(a + 1, 400):\n            for c in range(b + 1, 500):\n                if (a + b + c) == 1000 and (a**2) + (b**2) == (c**2):\n                    return a * b * c\n\n    return -1",
    "docstring": "Returns the product of a,b,c which are Pythagorean Triplet that satisfies\nthe following:\n  1. a < b < c\n  2. a**2 + b**2 = c**2\n  3. a + b + c = 1000\n\n>>> solution()\n31875000"
  },
  {
    "function": "solution_fast",
    "code": "def solution_fast() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution_fast()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(400):\n            c = 1000 - a - b\n            if a < b < c and (a**2) + (b**2) == (c**2):\n                return a * b * c\n\n    return -1",
    "docstring": "Returns the product of a,b,c which are Pythagorean Triplet that satisfies\nthe following:\n  1. a < b < c\n  2. a**2 + b**2 = c**2\n  3. a + b + c = 1000\n\n>>> solution_fast()\n31875000"
  },
  {
    "function": "benchmark",
    "code": "def benchmark() -> None:\n    \"\"\"\n    Benchmark code comparing two different version function.\n    \"\"\"\n    import timeit\n\n    print(\n        timeit.timeit(\"solution()\", setup=\"from __main__ import solution\", number=1000)\n    )\n    print(\n        timeit.timeit(\n            \"solution_fast()\", setup=\"from __main__ import solution_fast\", number=1000\n        )\n    )",
    "docstring": "Benchmark code comparing two different version function."
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    Return the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = n\n\n    >>> solution(36)\n    1620\n    >>> solution(126)\n    66780\n    \"\"\"\n\n    product = -1\n    candidate = 0\n    for a in range(1, n // 3):\n        # Solving the two equations a**2+b**2=c**2 and a+b+c=N eliminating c\n        b = (n * n - 2 * a * n) // (2 * n - 2 * a)\n        c = n - a - b\n        if c * c == (a * a + b * b):\n            candidate = a * b * c\n            product = max(product, candidate)\n    return product",
    "docstring": "Return the product of a,b,c which are Pythagorean Triplet that satisfies\nthe following:\n  1. a < b < c\n  2. a**2 + b**2 = c**2\n  3. a + b + c = n\n\n>>> solution(36)\n1620\n>>> solution(126)\n66780"
  },
  {
    "function": "solution",
    "code": "def solution() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a**2 + b**2 = c**2\n      2. a + b + c = 1000\n\n    >>> solution()\n    31875000\n    \"\"\"\n\n    return next(\n        iter(\n            [\n                a * b * (1000 - a - b)\n                for a in range(1, 999)\n                for b in range(a, 999)\n                if (a * a + b * b == (1000 - a - b) ** 2)\n            ]\n        )\n    )",
    "docstring": "Returns the product of a,b,c which are Pythagorean Triplet that satisfies\nthe following:\n  1. a**2 + b**2 = c**2\n  2. a + b + c = 1000\n\n>>> solution()\n31875000"
  },
  {
    "function": "get_squares",
    "code": "def get_squares(n: int) -> list[int]:\n    \"\"\"\n    >>> get_squares(0)\n    []\n    >>> get_squares(1)\n    [0]\n    >>> get_squares(2)\n    [0, 1]\n    >>> get_squares(3)\n    [0, 1, 4]\n    >>> get_squares(4)\n    [0, 1, 4, 9]\n    \"\"\"\n    return [number * number for number in range(n)]",
    "docstring": ">>> get_squares(0)\n[]\n>>> get_squares(1)\n[0]\n>>> get_squares(2)\n[0, 1]\n>>> get_squares(3)\n[0, 1, 4]\n>>> get_squares(4)\n[0, 1, 4, 9]"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    Precomputing squares and checking if a^2 + b^2 is the square by set look-up.\n\n    >>> solution(12)\n    60\n    >>> solution(36)\n    1620\n    \"\"\"\n\n    squares = get_squares(n)\n    squares_set = set(squares)\n    for a in range(1, n // 3):\n        for b in range(a + 1, (n - a) // 2 + 1):\n            if (\n                squares[a] + squares[b] in squares_set\n                and squares[n - a - b] == squares[a] + squares[b]\n            ):\n                return a * b * (n - a - b)\n\n    return -1",
    "docstring": "Precomputing squares and checking if a^2 + b^2 is the square by set look-up.\n\n>>> solution(12)\n60\n>>> solution(36)\n1620"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number num (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\nA number is prime if it has exactly two factors: 1 and itself.\nReturns boolean representing primality of given number num (i.e., if the\nresult is true, then the number is indeed prime else it is not).\n\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(2999)\nTrue\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 2000000) -> int:\n    \"\"\"\n    Returns the sum of all the primes below n.\n\n    >>> solution(1000)\n    76127\n    >>> solution(5000)\n    1548136\n    >>> solution(10000)\n    5736396\n    >>> solution(7)\n    10\n    \"\"\"\n\n    return sum(num for num in range(3, n, 2) if is_prime(num)) + 2 if n > 2 else 0",
    "docstring": "Returns the sum of all the primes below n.\n\n>>> solution(1000)\n76127\n>>> solution(5000)\n1548136\n>>> solution(10000)\n5736396\n>>> solution(7)\n10"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number num (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\nA number is prime if it has exactly two factors: 1 and itself.\nReturns boolean representing primality of given number num (i.e., if the\nresult is true, then the number is indeed prime else it is not).\n\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(2999)\nTrue\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse"
  },
  {
    "function": "prime_generator",
    "code": "def prime_generator() -> Iterator[int]:\n    \"\"\"\n    Generate a list sequence of prime numbers\n    \"\"\"\n\n    num = 2\n    while True:\n        if is_prime(num):\n            yield num\n        num += 1",
    "docstring": "Generate a list sequence of prime numbers"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 2000000) -> int:\n    \"\"\"\n    Returns the sum of all the primes below n.\n\n    >>> solution(1000)\n    76127\n    >>> solution(5000)\n    1548136\n    >>> solution(10000)\n    5736396\n    >>> solution(7)\n    10\n    \"\"\"\n\n    return sum(takewhile(lambda x: x < n, prime_generator()))",
    "docstring": "Returns the sum of all the primes below n.\n\n>>> solution(1000)\n76127\n>>> solution(5000)\n1548136\n>>> solution(10000)\n5736396\n>>> solution(7)\n10"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 2000000) -> int:\n    \"\"\"\n    Returns the sum of all the primes below n using Sieve of Eratosthenes:\n\n    The sieve of Eratosthenes is one of the most efficient ways to find all primes\n    smaller than n when n is smaller than 10 million.  Only for positive numbers.\n\n    >>> solution(1000)\n    76127\n    >>> solution(5000)\n    1548136\n    >>> solution(10000)\n    5736396\n    >>> solution(7)\n    10\n    >>> solution(7.1)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> solution(-7)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    IndexError: list assignment index out of range\n    >>> solution(\"seven\")  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: can only concatenate str (not \"int\") to str\n    \"\"\"\n\n    primality_list = [0 for i in range(n + 1)]\n    primality_list[0] = 1\n    primality_list[1] = 1\n\n    for i in range(2, int(n**0.5) + 1):\n        if primality_list[i] == 0:\n            for j in range(i * i, n + 1, i):\n                primality_list[j] = 1\n    sum_of_primes = 0\n    for i in range(n):\n        if primality_list[i] == 0:\n            sum_of_primes += i\n    return sum_of_primes",
    "docstring": "Returns the sum of all the primes below n using Sieve of Eratosthenes:\n\nThe sieve of Eratosthenes is one of the most efficient ways to find all primes\nsmaller than n when n is smaller than 10 million.  Only for positive numbers.\n\n>>> solution(1000)\n76127\n>>> solution(5000)\n1548136\n>>> solution(10000)\n5736396\n>>> solution(7)\n10\n>>> solution(7.1)  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nTypeError: 'float' object cannot be interpreted as an integer\n>>> solution(-7)  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nIndexError: list assignment index out of range\n>>> solution(\"seven\")  # doctest: +ELLIPSIS\nTraceback (most recent call last):\n    ...\nTypeError: can only concatenate str (not \"int\") to str"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"Returns the greatest product of four adjacent numbers (horizontally,\n    vertically, or diagonally).\n\n    >>> solution()\n    70600674\n    \"\"\"\n    grid = []\n    with open(os.path.dirname(__file__) + \"/grid.txt\") as file:\n        for line in file:\n            grid.append(line.strip(\"\\n\").split(\" \"))\n\n    grid = [[int(i) for i in grid[j]] for j in range(len(grid))]\n\n    return largest_product(grid)",
    "docstring": "Returns the greatest product of four adjacent numbers (horizontally,\nvertically, or diagonally).\n\n>>> solution()\n70600674"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"Returns the greatest product of four adjacent numbers (horizontally,\n    vertically, or diagonally).\n\n    >>> solution()\n    70600674\n    \"\"\"\n    with open(os.path.dirname(__file__) + \"/grid.txt\") as f:\n        grid = []\n        for _ in range(20):\n            grid.append([int(x) for x in f.readline().split()])\n\n        maximum = 0\n\n        # right\n        for i in range(20):\n            for j in range(17):\n                temp = grid[i][j] * grid[i][j + 1] * grid[i][j + 2] * grid[i][j + 3]\n                maximum = max(maximum, temp)\n\n        # down\n        for i in range(17):\n            for j in range(20):\n                temp = grid[i][j] * grid[i + 1][j] * grid[i + 2][j] * grid[i + 3][j]\n                maximum = max(maximum, temp)\n\n        # diagonal 1\n        for i in range(17):\n            for j in range(17):\n                temp = (\n                    grid[i][j]\n                    * grid[i + 1][j + 1]\n                    * grid[i + 2][j + 2]\n                    * grid[i + 3][j + 3]\n                )\n                maximum = max(maximum, temp)\n\n        # diagonal 2\n        for i in range(17):\n            for j in range(3, 20):\n                temp = (\n                    grid[i][j]\n                    * grid[i + 1][j - 1]\n                    * grid[i + 2][j - 2]\n                    * grid[i + 3][j - 3]\n                )\n                maximum = max(maximum, temp)\n        return maximum",
    "docstring": "Returns the greatest product of four adjacent numbers (horizontally,\nvertically, or diagonally).\n\n>>> solution()\n70600674"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"Returns the value of the first triangle number to have over five hundred\n    divisors.\n\n    >>> solution()\n    76576500\n    \"\"\"\n    t_num = 1\n    i = 1\n\n    while True:\n        i += 1\n        t_num += i\n\n        if count_divisors(t_num) > 500:\n            break\n\n    return t_num",
    "docstring": "Returns the value of the first triangle number to have over five hundred\ndivisors.\n\n>>> solution()\n76576500"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"Returns the value of the first triangle number to have over five hundred\n    divisors.\n\n    >>> solution()\n    76576500\n    \"\"\"\n    return next(i for i in triangle_number_generator() if count_divisors(i) > 500)",
    "docstring": "Returns the value of the first triangle number to have over five hundred\ndivisors.\n\n>>> solution()\n76576500"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"\n    Returns the first ten digits of the sum of the array elements\n    from the file num.txt\n\n    >>> solution()\n    '5537376230'\n    \"\"\"\n    file_path = os.path.join(os.path.dirname(__file__), \"num.txt\")\n    with open(file_path) as file_hand:\n        return str(sum(int(line) for line in file_hand))[:10]",
    "docstring": "Returns the first ten digits of the sum of the array elements\nfrom the file num.txt\n\n>>> solution()\n'5537376230'"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000000) -> int:\n    \"\"\"Returns the number under n that generates the longest sequence using the\n    formula:\n    n \u2192 n/2 (n is even)\n    n \u2192 3n + 1 (n is odd)\n\n    >>> solution(1000000)\n    837799\n    >>> solution(200)\n    171\n    >>> solution(5000)\n    3711\n    >>> solution(15000)\n    13255\n    \"\"\"\n    largest_number = 1\n    pre_counter = 1\n    counters = {1: 1}\n\n    for input1 in range(2, n):\n        counter = 0\n        number = input1\n\n        while True:\n            if number in counters:\n                counter += counters[number]\n                break\n            if number % 2 == 0:\n                number //= 2\n                counter += 1\n            else:\n                number = (3 * number) + 1\n                counter += 1\n\n        if input1 not in counters:\n            counters[input1] = counter\n\n        if counter > pre_counter:\n            largest_number = input1\n            pre_counter = counter\n    return largest_number",
    "docstring": "Returns the number under n that generates the longest sequence using the\nformula:\nn \u2192 n/2 (n is even)\nn \u2192 3n + 1 (n is odd)\n\n>>> solution(1000000)\n837799\n>>> solution(200)\n171\n>>> solution(5000)\n3711\n>>> solution(15000)\n13255"
  },
  {
    "function": "collatz_sequence_length",
    "code": "def collatz_sequence_length(n: int) -> int:\n    \"\"\"Returns the Collatz sequence length for n.\"\"\"\n    if n in COLLATZ_SEQUENCE_LENGTHS:\n        return COLLATZ_SEQUENCE_LENGTHS[n]\n    next_n = n // 2 if n % 2 == 0 else 3 * n + 1\n    sequence_length = collatz_sequence_length(next_n) + 1\n    COLLATZ_SEQUENCE_LENGTHS[n] = sequence_length\n    return sequence_length",
    "docstring": "Returns the Collatz sequence length for n."
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000000) -> int:\n    \"\"\"Returns the number under n that generates the longest Collatz sequence.\n\n    >>> solution(1000000)\n    837799\n    >>> solution(200)\n    171\n    >>> solution(5000)\n    3711\n    >>> solution(15000)\n    13255\n    \"\"\"\n\n    result = max((collatz_sequence_length(i), i) for i in range(1, n))\n    return result[1]",
    "docstring": "Returns the number under n that generates the longest Collatz sequence.\n\n>>> solution(1000000)\n837799\n>>> solution(200)\n171\n>>> solution(5000)\n3711\n>>> solution(15000)\n13255"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 20) -> int:\n    \"\"\"\n    Returns the number of paths possible in a n x n grid starting at top left\n    corner going to bottom right corner and being able to move right and down\n    only.\n    >>> solution(25)\n    126410606437752\n    >>> solution(23)\n    8233430727600\n    >>> solution(20)\n    137846528820\n    >>> solution(15)\n    155117520\n    >>> solution(1)\n    2\n    \"\"\"\n    n = 2 * n  # middle entry of odd rows starting at row 3 is the solution for n = 1,\n    # 2, 3,...\n    k = n // 2\n\n    return int(factorial(n) / (factorial(k) * factorial(n - k)))",
    "docstring": "Returns the number of paths possible in a n x n grid starting at top left\ncorner going to bottom right corner and being able to move right and down\nonly.\n>>> solution(25)\n126410606437752\n>>> solution(23)\n8233430727600\n>>> solution(20)\n137846528820\n>>> solution(15)\n155117520\n>>> solution(1)\n2"
  },
  {
    "function": "solution",
    "code": "def solution(power: int = 1000) -> int:\n    \"\"\"Returns the sum of the digits of the number 2^power.\n    >>> solution(1000)\n    1366\n    >>> solution(50)\n    76\n    >>> solution(20)\n    31\n    >>> solution(15)\n    26\n    \"\"\"\n    num = 2**power\n    string_num = str(num)\n    list_num = list(string_num)\n    sum_of_num = 0\n\n    for i in list_num:\n        sum_of_num += int(i)\n\n    return sum_of_num",
    "docstring": "Returns the sum of the digits of the number 2^power.\n>>> solution(1000)\n1366\n>>> solution(50)\n76\n>>> solution(20)\n31\n>>> solution(15)\n26"
  },
  {
    "function": "solution",
    "code": "def solution(power: int = 1000) -> int:\n    \"\"\"Returns the sum of the digits of the number 2^power.\n\n    >>> solution(1000)\n    1366\n    >>> solution(50)\n    76\n    >>> solution(20)\n    31\n    >>> solution(15)\n    26\n    \"\"\"\n    n = 2**power\n    r = 0\n    while n:\n        r, n = r + n % 10, n // 10\n    return r",
    "docstring": "Returns the sum of the digits of the number 2^power.\n\n>>> solution(1000)\n1366\n>>> solution(50)\n76\n>>> solution(20)\n31\n>>> solution(15)\n26"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"Returns the number of letters used to write all numbers from 1 to n.\n    where n is lower or equals to 1000.\n    >>> solution(1000)\n    21124\n    >>> solution(5)\n    19\n    \"\"\"\n    # number of letters in zero, one, two, ..., nineteen (0 for zero since it's\n    # never said aloud)\n    ones_counts = [0, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6, 6, 8, 8, 7, 7, 9, 8, 8]\n    # number of letters in twenty, thirty, ..., ninety (0 for numbers less than\n    # 20 due to inconsistency in teens)\n    tens_counts = [0, 0, 6, 6, 5, 5, 5, 7, 6, 6]\n\n    count = 0\n\n    for i in range(1, n + 1):\n        if i < 1000:\n            if i >= 100:\n                # add number of letters for \"n hundred\"\n                count += ones_counts[i // 100] + 7\n\n                if i % 100 != 0:\n                    # add number of letters for \"and\" if number is not multiple\n                    # of 100\n                    count += 3\n\n            if 0 < i % 100 < 20:\n                # add number of letters for one, two, three, ..., nineteen\n                # (could be combined with below if not for inconsistency in\n                # teens)\n                count += ones_counts[i % 100]\n            else:\n                # add number of letters for twenty, twenty one, ..., ninety\n                # nine\n                count += ones_counts[i % 10]\n                count += tens_counts[(i % 100 - i % 10) // 10]\n        else:\n            count += ones_counts[i // 1000] + 8\n    return count",
    "docstring": "Returns the number of letters used to write all numbers from 1 to n.\nwhere n is lower or equals to 1000.\n>>> solution(1000)\n21124\n>>> solution(5)\n19"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"\n    Finds the maximum total in a triangle as described by the problem statement\n    above.\n\n    >>> solution()\n    1074\n    \"\"\"\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    triangle = os.path.join(script_dir, \"triangle.txt\")\n\n    with open(triangle) as f:\n        triangle = f.readlines()\n\n    a = [[int(y) for y in x.rstrip(\"\\r\\n\").split(\" \")] for x in triangle]\n\n    for i in range(1, len(a)):\n        for j in range(len(a[i])):\n            number1 = a[i - 1][j] if j != len(a[i - 1]) else 0\n            number2 = a[i - 1][j - 1] if j > 0 else 0\n            a[i][j] += max(number1, number2)\n    return max(a[-1])",
    "docstring": "Finds the maximum total in a triangle as described by the problem statement\nabove.\n\n>>> solution()\n1074"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"Returns the number of mondays that fall on the first of the month during\n    the twentieth century (1 Jan 1901 to 31 Dec 2000)?\n\n    >>> solution()\n    171\n    \"\"\"\n    days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    day = 6\n    month = 1\n    year = 1901\n\n    sundays = 0\n\n    while year < 2001:\n        day += 7\n\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            if day > days_per_month[month - 1] and month != 2:\n                month += 1\n                day = day - days_per_month[month - 2]\n            elif day > 29 and month == 2:\n                month += 1\n                day = day - 29\n        elif day > days_per_month[month - 1]:\n            month += 1\n            day = day - days_per_month[month - 2]\n\n        if month > 12:\n            year += 1\n            month = 1\n\n        if year < 2001 and day == 1:\n            sundays += 1\n    return sundays",
    "docstring": "Returns the number of mondays that fall on the first of the month during\nthe twentieth century (1 Jan 1901 to 31 Dec 2000)?\n\n>>> solution()\n171"
  },
  {
    "function": "factorial",
    "code": "def factorial(num: int) -> int:\n    \"\"\"Find the factorial of a given number n\"\"\"\n    fact = 1\n    for i in range(1, num + 1):\n        fact *= i\n    return fact",
    "docstring": "Find the factorial of a given number n"
  },
  {
    "function": "split_and_add",
    "code": "def split_and_add(number: int) -> int:\n    \"\"\"Split number digits and add them.\"\"\"\n    sum_of_digits = 0\n    while number > 0:\n        last_digit = number % 10\n        sum_of_digits += last_digit\n        number = number // 10  # Removing the last_digit from the given number\n    return sum_of_digits",
    "docstring": "Split number digits and add them."
  },
  {
    "function": "solution",
    "code": "def solution(num: int = 100) -> int:\n    \"\"\"Returns the sum of the digits in the factorial of num\n    >>> solution(100)\n    648\n    >>> solution(50)\n    216\n    >>> solution(10)\n    27\n    >>> solution(5)\n    3\n    >>> solution(3)\n    6\n    >>> solution(2)\n    2\n    >>> solution(1)\n    1\n    \"\"\"\n    nfact = factorial(num)\n    result = split_and_add(nfact)\n    return result",
    "docstring": "Returns the sum of the digits in the factorial of num\n>>> solution(100)\n648\n>>> solution(50)\n216\n>>> solution(10)\n27\n>>> solution(5)\n3\n>>> solution(3)\n6\n>>> solution(2)\n2\n>>> solution(1)\n1"
  },
  {
    "function": "solution",
    "code": "def solution(num: int = 100) -> int:\n    \"\"\"Returns the sum of the digits in the factorial of num\n    >>> solution(100)\n    648\n    >>> solution(50)\n    216\n    >>> solution(10)\n    27\n    >>> solution(5)\n    3\n    >>> solution(3)\n    6\n    >>> solution(2)\n    2\n    >>> solution(1)\n    1\n    \"\"\"\n    return sum(int(x) for x in str(factorial(num)))",
    "docstring": "Returns the sum of the digits in the factorial of num\n>>> solution(100)\n648\n>>> solution(50)\n216\n>>> solution(10)\n27\n>>> solution(5)\n3\n>>> solution(3)\n6\n>>> solution(2)\n2\n>>> solution(1)\n1"
  },
  {
    "function": "solution",
    "code": "def solution(num: int = 100) -> int:\n    \"\"\"Returns the sum of the digits in the factorial of num\n    >>> solution(1000)\n    10539\n    >>> solution(200)\n    1404\n    >>> solution(100)\n    648\n    >>> solution(50)\n    216\n    >>> solution(10)\n    27\n    >>> solution(5)\n    3\n    >>> solution(3)\n    6\n    >>> solution(2)\n    2\n    >>> solution(1)\n    1\n    >>> solution(0)\n    1\n    \"\"\"\n    return sum(map(int, str(factorial(num))))",
    "docstring": "Returns the sum of the digits in the factorial of num\n>>> solution(1000)\n10539\n>>> solution(200)\n1404\n>>> solution(100)\n648\n>>> solution(50)\n216\n>>> solution(10)\n27\n>>> solution(5)\n3\n>>> solution(3)\n6\n>>> solution(2)\n2\n>>> solution(1)\n1\n>>> solution(0)\n1"
  },
  {
    "function": "solution",
    "code": "def solution(num: int = 100) -> int:\n    \"\"\"Returns the sum of the digits in the factorial of num\n    >>> solution(100)\n    648\n    >>> solution(50)\n    216\n    >>> solution(10)\n    27\n    >>> solution(5)\n    3\n    >>> solution(3)\n    6\n    >>> solution(2)\n    2\n    >>> solution(1)\n    1\n    \"\"\"\n    fact = 1\n    result = 0\n    for i in range(1, num + 1):\n        fact *= i\n\n    for j in str(fact):\n        result += int(j)\n\n    return result",
    "docstring": "Returns the sum of the digits in the factorial of num\n>>> solution(100)\n648\n>>> solution(50)\n216\n>>> solution(10)\n27\n>>> solution(5)\n3\n>>> solution(3)\n6\n>>> solution(2)\n2\n>>> solution(1)\n1"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 10000) -> int:\n    \"\"\"Returns the sum of all the amicable numbers under n.\n\n    >>> solution(10000)\n    31626\n    >>> solution(5000)\n    8442\n    >>> solution(1000)\n    504\n    >>> solution(100)\n    0\n    >>> solution(50)\n    0\n    \"\"\"\n    total = sum(\n        i\n        for i in range(1, n)\n        if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i\n    )\n    return total",
    "docstring": "Returns the sum of all the amicable numbers under n.\n\n>>> solution(10000)\n31626\n>>> solution(5000)\n8442\n>>> solution(1000)\n504\n>>> solution(100)\n0\n>>> solution(50)\n0"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"Returns the total of all the name scores in the file.\n\n    >>> solution()\n    871198282\n    \"\"\"\n    with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:\n        names = str(file.readlines()[0])\n        names = names.replace('\"', \"\").split(\",\")\n\n    names.sort()\n\n    name_score = 0\n    total_score = 0\n\n    for i, name in enumerate(names):\n        for letter in name:\n            name_score += ord(letter) - 64\n\n        total_score += (i + 1) * name_score\n        name_score = 0\n    return total_score",
    "docstring": "Returns the total of all the name scores in the file.\n\n>>> solution()\n871198282"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"Returns the total of all the name scores in the file.\n\n    >>> solution()\n    871198282\n    \"\"\"\n    total_sum = 0\n    temp_sum = 0\n    with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:\n        name = str(file.readlines()[0])\n        name = name.replace('\"', \"\").split(\",\")\n\n    name.sort()\n    for i in range(len(name)):\n        for j in name[i]:\n            temp_sum += ord(j) - ord(\"A\") + 1\n        total_sum += (i + 1) * temp_sum\n        temp_sum = 0\n    return total_sum",
    "docstring": "Returns the total of all the name scores in the file.\n\n>>> solution()\n871198282"
  },
  {
    "function": "solution",
    "code": "def solution(limit=28123):\n    \"\"\"\n    Finds the sum of all the positive integers which cannot be written as\n    the sum of two abundant numbers\n    as described by the statement above.\n\n    >>> solution()\n    4179871\n    \"\"\"\n    sum_divs = [1] * (limit + 1)\n\n    for i in range(2, int(limit**0.5) + 1):\n        sum_divs[i * i] += i\n        for k in range(i + 1, limit // i + 1):\n            sum_divs[k * i] += k + i\n\n    abundants = set()\n    res = 0\n\n    for n in range(1, limit + 1):\n        if sum_divs[n] > n:\n            abundants.add(n)\n\n        if not any((n - a in abundants) for a in abundants):\n            res += n\n\n    return res",
    "docstring": "Finds the sum of all the positive integers which cannot be written as\nthe sum of two abundant numbers\nas described by the statement above.\n\n>>> solution()\n4179871"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"Returns the millionth lexicographic permutation of the digits 0, 1, 2,\n    3, 4, 5, 6, 7, 8 and 9.\n\n    >>> solution()\n    '2783915460'\n    \"\"\"\n    result = list(map(\"\".join, permutations(\"0123456789\")))\n    return result[999999]",
    "docstring": "Returns the millionth lexicographic permutation of the digits 0, 1, 2,\n3, 4, 5, 6, 7, 8 and 9.\n\n>>> solution()\n'2783915460'"
  },
  {
    "function": "fibonacci",
    "code": "def fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]",
    "docstring": "Computes the Fibonacci number for input n by iterating through n numbers\nand creating an array of ints using the Fibonacci formula.\nReturns the nth element of the array.\n\n>>> fibonacci(2)\n1\n>>> fibonacci(3)\n2\n>>> fibonacci(5)\n5\n>>> fibonacci(10)\n55\n>>> fibonacci(12)\n144"
  },
  {
    "function": "fibonacci_digits_index",
    "code": "def fibonacci_digits_index(n: int) -> int:\n    \"\"\"\n    Computes incrementing Fibonacci numbers starting from 3 until the length\n    of the resulting Fibonacci result is the input value n. Returns the term\n    of the Fibonacci sequence where this occurs.\n\n    >>> fibonacci_digits_index(1000)\n    4782\n    >>> fibonacci_digits_index(100)\n    476\n    >>> fibonacci_digits_index(50)\n    237\n    >>> fibonacci_digits_index(3)\n    12\n    \"\"\"\n    digits = 0\n    index = 2\n\n    while digits < n:\n        index += 1\n        digits = len(str(fibonacci(index)))\n\n    return index",
    "docstring": "Computes incrementing Fibonacci numbers starting from 3 until the length\nof the resulting Fibonacci result is the input value n. Returns the term\nof the Fibonacci sequence where this occurs.\n\n>>> fibonacci_digits_index(1000)\n4782\n>>> fibonacci_digits_index(100)\n476\n>>> fibonacci_digits_index(50)\n237\n>>> fibonacci_digits_index(3)\n12"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the index of the first term in the Fibonacci sequence to contain\n    n digits.\n\n    >>> solution(1000)\n    4782\n    >>> solution(100)\n    476\n    >>> solution(50)\n    237\n    >>> solution(3)\n    12\n    \"\"\"\n    return fibonacci_digits_index(n)",
    "docstring": "Returns the index of the first term in the Fibonacci sequence to contain\nn digits.\n\n>>> solution(1000)\n4782\n>>> solution(100)\n476\n>>> solution(50)\n237\n>>> solution(3)\n12"
  },
  {
    "function": "fibonacci_generator",
    "code": "def fibonacci_generator() -> Generator[int]:\n    \"\"\"\n    A generator that produces numbers in the Fibonacci sequence\n\n    >>> generator = fibonacci_generator()\n    >>> next(generator)\n    1\n    >>> next(generator)\n    2\n    >>> next(generator)\n    3\n    >>> next(generator)\n    5\n    >>> next(generator)\n    8\n    \"\"\"\n    a, b = 0, 1\n    while True:\n        a, b = b, a + b\n        yield b",
    "docstring": "A generator that produces numbers in the Fibonacci sequence\n\n>>> generator = fibonacci_generator()\n>>> next(generator)\n1\n>>> next(generator)\n2\n>>> next(generator)\n3\n>>> next(generator)\n5\n>>> next(generator)\n8"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"Returns the index of the first term in the Fibonacci sequence to contain\n    n digits.\n\n    >>> solution(1000)\n    4782\n    >>> solution(100)\n    476\n    >>> solution(50)\n    237\n    >>> solution(3)\n    12\n    \"\"\"\n    answer = 1\n    gen = fibonacci_generator()\n    while len(str(next(gen))) < n:\n        answer += 1\n    return answer + 1",
    "docstring": "Returns the index of the first term in the Fibonacci sequence to contain\nn digits.\n\n>>> solution(1000)\n4782\n>>> solution(100)\n476\n>>> solution(50)\n237\n>>> solution(3)\n12"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"Returns the index of the first term in the Fibonacci sequence to contain\n    n digits.\n\n    >>> solution(1000)\n    4782\n    >>> solution(100)\n    476\n    >>> solution(50)\n    237\n    >>> solution(3)\n    12\n    \"\"\"\n    f1, f2 = 1, 1\n    index = 2\n    while True:\n        i = 0\n        f = f1 + f2\n        f1, f2 = f2, f\n        index += 1\n        for _ in str(f):\n            i += 1\n        if i == n:\n            break\n    return index",
    "docstring": "Returns the index of the first term in the Fibonacci sequence to contain\nn digits.\n\n>>> solution(1000)\n4782\n>>> solution(100)\n476\n>>> solution(50)\n237\n>>> solution(3)\n12"
  },
  {
    "function": "solution",
    "code": "def solution(numerator: int = 1, digit: int = 1000) -> int:\n    \"\"\"\n    Considering any range can be provided,\n    because as per the problem, the digit d < 1000\n    >>> solution(1, 10)\n    7\n    >>> solution(10, 100)\n    97\n    >>> solution(10, 1000)\n    983\n    \"\"\"\n    the_digit = 1\n    longest_list_length = 0\n\n    for divide_by_number in range(numerator, digit + 1):\n        has_been_divided: list[int] = []\n        now_divide = numerator\n        for _ in range(1, digit + 1):\n            if now_divide in has_been_divided:\n                if longest_list_length < len(has_been_divided):\n                    longest_list_length = len(has_been_divided)\n                    the_digit = divide_by_number\n            else:\n                has_been_divided.append(now_divide)\n                now_divide = now_divide * 10 % divide_by_number\n\n    return the_digit",
    "docstring": "Considering any range can be provided,\nbecause as per the problem, the digit d < 1000\n>>> solution(1, 10)\n7\n>>> solution(10, 100)\n97\n>>> solution(10, 1000)\n983"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number num (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(-10)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\nA number is prime if it has exactly two factors: 1 and itself.\nReturns boolean representing primality of given number num (i.e., if the\nresult is true, then the number is indeed prime else it is not).\n\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(2999)\nTrue\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse\n>>> is_prime(-10)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(a_limit: int = 1000, b_limit: int = 1000) -> int:\n    \"\"\"\n    >>> solution(1000, 1000)\n    -59231\n    >>> solution(200, 1000)\n    -59231\n    >>> solution(200, 200)\n    -4925\n    >>> solution(-1000, 1000)\n    0\n    >>> solution(-1000, -1000)\n    0\n    \"\"\"\n    longest = [0, 0, 0]  # length, a, b\n    for a in range((a_limit * -1) + 1, a_limit):\n        for b in range(2, b_limit):\n            if is_prime(b):\n                count = 0\n                n = 0\n                while is_prime((n**2) + (a * n) + b):\n                    count += 1\n                    n += 1\n                if count > longest[0]:\n                    longest = [count, a, b]\n    ans = longest[1] * longest[2]\n    return ans",
    "docstring": ">>> solution(1000, 1000)\n-59231\n>>> solution(200, 1000)\n-59231\n>>> solution(200, 200)\n-4925\n>>> solution(-1000, 1000)\n0\n>>> solution(-1000, -1000)\n0"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1001) -> int:\n    \"\"\"Returns the sum of the numbers on the diagonals in a n by n spiral\n    formed in the same way.\n\n    >>> solution(1001)\n    669171001\n    >>> solution(500)\n    82959497\n    >>> solution(100)\n    651897\n    >>> solution(50)\n    79697\n    >>> solution(10)\n    537\n    \"\"\"\n    total = 1\n\n    for i in range(1, ceil(n / 2.0)):\n        odd = 2 * i + 1\n        even = 2 * i\n        total = total + 4 * odd**2 - 6 * even\n\n    return total",
    "docstring": "Returns the sum of the numbers on the diagonals in a n by n spiral\nformed in the same way.\n\n>>> solution(1001)\n669171001\n>>> solution(500)\n82959497\n>>> solution(100)\n651897\n>>> solution(50)\n79697\n>>> solution(10)\n537"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the number of distinct terms in the sequence generated by a^b\n    for 2 <= a <= 100 and 2 <= b <= 100.\n\n    >>> solution(100)\n    9183\n    >>> solution(50)\n    2184\n    >>> solution(20)\n    324\n    >>> solution(5)\n    15\n    >>> solution(2)\n    1\n    >>> solution(1)\n    0\n    \"\"\"\n    collect_powers = set()\n\n    current_pow = 0\n\n    n = n + 1  # maximum limit\n\n    for a in range(2, n):\n        for b in range(2, n):\n            current_pow = a**b  # calculates the current power\n            collect_powers.add(current_pow)  # adds the result to the set\n    return len(collect_powers)",
    "docstring": "Returns the number of distinct terms in the sequence generated by a^b\nfor 2 <= a <= 100 and 2 <= b <= 100.\n\n>>> solution(100)\n9183\n>>> solution(50)\n2184\n>>> solution(20)\n324\n>>> solution(5)\n15\n>>> solution(2)\n1\n>>> solution(1)\n0"
  },
  {
    "function": "digits_fifth_powers_sum",
    "code": "def digits_fifth_powers_sum(number: int) -> int:\n    \"\"\"\n    >>> digits_fifth_powers_sum(1234)\n    1300\n    \"\"\"\n    return sum(DIGITS_FIFTH_POWER[digit] for digit in str(number))",
    "docstring": ">>> digits_fifth_powers_sum(1234)\n1300"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 200) -> int:\n    \"\"\"Returns the number of different ways can n pence be made using any number of\n    coins?\n\n    >>> solution(500)\n    6295434\n    >>> solution(200)\n    73682\n    >>> solution(50)\n    451\n    >>> solution(10)\n    11\n    \"\"\"\n    return two_pound(n)",
    "docstring": "Returns the number of different ways can n pence be made using any number of\ncoins?\n\n>>> solution(500)\n6295434\n>>> solution(200)\n73682\n>>> solution(50)\n451\n>>> solution(10)\n11"
  },
  {
    "function": "solution",
    "code": "def solution(pence: int = 200) -> int:\n    \"\"\"Returns the number of different ways to make X pence using any number of coins.\n    The solution is based on dynamic programming paradigm in a bottom-up fashion.\n\n    >>> solution(500)\n    6295434\n    >>> solution(200)\n    73682\n    >>> solution(50)\n    451\n    >>> solution(10)\n    11\n    \"\"\"\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    number_of_ways = [0] * (pence + 1)\n    number_of_ways[0] = 1  # base case: 1 way to make 0 pence\n\n    for coin in coins:\n        for i in range(coin, pence + 1, 1):\n            number_of_ways[i] += number_of_ways[i - coin]\n    return number_of_ways[pence]",
    "docstring": "Returns the number of different ways to make X pence using any number of coins.\nThe solution is based on dynamic programming paradigm in a bottom-up fashion.\n\n>>> solution(500)\n6295434\n>>> solution(200)\n73682\n>>> solution(50)\n451\n>>> solution(10)\n11"
  },
  {
    "function": "is_combination_valid",
    "code": "def is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )",
    "docstring": "Checks if a combination (a tuple of 9 digits)\nis a valid product equation.\n\n>>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\nTrue\n\n>>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"\n    Finds the sum of all products whose multiplicand/multiplier/product identity\n    can be written as a 1 through 9 pandigital\n\n    >>> solution()\n    45228\n    \"\"\"\n\n    return sum(\n        {\n            int(\"\".join(pandigital[5:9]))\n            for pandigital in itertools.permutations(\"123456789\")\n            if is_combination_valid(pandigital)\n        }\n    )",
    "docstring": "Finds the sum of all products whose multiplicand/multiplier/product identity\ncan be written as a 1 through 9 pandigital\n\n>>> solution()\n45228"
  },
  {
    "function": "fraction_list",
    "code": "def fraction_list(digit_len: int) -> list[str]:\n    \"\"\"\n    >>> fraction_list(2)\n    ['16/64', '19/95', '26/65', '49/98']\n    >>> fraction_list(3)\n    ['16/64', '19/95', '26/65', '49/98']\n    >>> fraction_list(4)\n    ['16/64', '19/95', '26/65', '49/98']\n    >>> fraction_list(0)\n    []\n    >>> fraction_list(5)\n    ['16/64', '19/95', '26/65', '49/98']\n    \"\"\"\n    solutions = []\n    den = 11\n    last_digit = int(\"1\" + \"0\" * digit_len)\n    for num in range(den, last_digit):\n        while den <= 99:\n            if (\n                (num != den)\n                and (num % 10 == den // 10)\n                and (den % 10 != 0)\n                and is_digit_cancelling(num, den)\n            ):\n                solutions.append(f\"{num}/{den}\")\n            den += 1\n        num += 1\n        den = 10\n    return solutions",
    "docstring": ">>> fraction_list(2)\n['16/64', '19/95', '26/65', '49/98']\n>>> fraction_list(3)\n['16/64', '19/95', '26/65', '49/98']\n>>> fraction_list(4)\n['16/64', '19/95', '26/65', '49/98']\n>>> fraction_list(0)\n[]\n>>> fraction_list(5)\n['16/64', '19/95', '26/65', '49/98']"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 2) -> int:\n    \"\"\"\n    Return the solution to the problem\n    \"\"\"\n    result = 1.0\n    for fraction in fraction_list(n):\n        frac = Fraction(fraction)\n        result *= frac.denominator / frac.numerator\n    return int(result)",
    "docstring": "Return the solution to the problem"
  },
  {
    "function": "sum_of_digit_factorial",
    "code": "def sum_of_digit_factorial(n: int) -> int:\n    \"\"\"\n    Returns the sum of the factorial of digits in n\n    >>> sum_of_digit_factorial(15)\n    121\n    >>> sum_of_digit_factorial(0)\n    1\n    \"\"\"\n    return sum(DIGIT_FACTORIAL[d] for d in str(n))",
    "docstring": "Returns the sum of the factorial of digits in n\n>>> sum_of_digit_factorial(15)\n121\n>>> sum_of_digit_factorial(0)\n1"
  },
  {
    "function": "solution",
    "code": "def solution() -> int:\n    \"\"\"\n    Returns the sum of all numbers whose\n    sum of the factorials of all digits\n    add up to the number itself.\n    >>> solution()\n    40730\n    \"\"\"\n    limit = 7 * factorial(9) + 1\n    return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)",
    "docstring": "Returns the sum of all numbers whose\nsum of the factorials of all digits\nadd up to the number itself.\n>>> solution()\n40730"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(n: int) -> bool:\n    \"\"\"\n    For 2 <= n <= 1000000, return True if n is prime.\n    >>> is_prime(87)\n    False\n    >>> is_prime(23)\n    True\n    >>> is_prime(25363)\n    False\n    \"\"\"\n    return sieve[n]",
    "docstring": "For 2 <= n <= 1000000, return True if n is prime.\n>>> is_prime(87)\nFalse\n>>> is_prime(23)\nTrue\n>>> is_prime(25363)\nFalse"
  },
  {
    "function": "contains_an_even_digit",
    "code": "def contains_an_even_digit(n: int) -> bool:\n    \"\"\"\n    Return True if n contains an even digit.\n    >>> contains_an_even_digit(0)\n    True\n    >>> contains_an_even_digit(975317933)\n    False\n    >>> contains_an_even_digit(-245679)\n    True\n    \"\"\"\n    return any(digit in \"02468\" for digit in str(n))",
    "docstring": "Return True if n contains an even digit.\n>>> contains_an_even_digit(0)\nTrue\n>>> contains_an_even_digit(975317933)\nFalse\n>>> contains_an_even_digit(-245679)\nTrue"
  },
  {
    "function": "find_circular_primes",
    "code": "def find_circular_primes(limit: int = 1000000) -> list[int]:\n    \"\"\"\n    Return circular primes below limit.\n    >>> len(find_circular_primes(100))\n    13\n    >>> len(find_circular_primes(1000000))\n    55\n    \"\"\"\n    result = [2]  # result already includes the number 2.\n    for num in range(3, limit + 1, 2):\n        if is_prime(num) and not contains_an_even_digit(num):\n            str_num = str(num)\n            list_nums = [int(str_num[j:] + str_num[:j]) for j in range(len(str_num))]\n            if all(is_prime(i) for i in list_nums):\n                result.append(num)\n    return result",
    "docstring": "Return circular primes below limit.\n>>> len(find_circular_primes(100))\n13\n>>> len(find_circular_primes(1000000))\n55"
  },
  {
    "function": "solution",
    "code": "def solution() -> int:\n    \"\"\"\n    >>> solution()\n    55\n    \"\"\"\n    return len(find_circular_primes())",
    "docstring": ">>> solution()\n55"
  },
  {
    "function": "is_palindrome",
    "code": "def is_palindrome(n: int | str) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return n == n[::-1]",
    "docstring": "Return true if the input n is a palindrome.\nOtherwise return false. n can be an integer or a string.\n\n>>> is_palindrome(909)\nTrue\n>>> is_palindrome(908)\nFalse\n>>> is_palindrome('10101')\nTrue\n>>> is_palindrome('10111')\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000000):\n    \"\"\"Return the sum of all numbers, less than n , which are palindromic in\n    base 10 and base 2.\n\n    >>> solution(1000000)\n    872187\n    >>> solution(500000)\n    286602\n    >>> solution(100000)\n    286602\n    >>> solution(1000)\n    1772\n    >>> solution(100)\n    157\n    >>> solution(10)\n    25\n    >>> solution(2)\n    1\n    >>> solution(1)\n    0\n    \"\"\"\n    total = 0\n\n    for i in range(1, n):\n        if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):\n            total += i\n    return total",
    "docstring": "Return the sum of all numbers, less than n , which are palindromic in\nbase 10 and base 2.\n\n>>> solution(1000000)\n872187\n>>> solution(500000)\n286602\n>>> solution(100000)\n286602\n>>> solution(1000)\n1772\n>>> solution(100)\n157\n>>> solution(10)\n25\n>>> solution(2)\n1\n>>> solution(1)\n0"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\n\nA number is prime if it has exactly two factors: 1 and itself.\n\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(87)\nFalse\n>>> is_prime(563)\nTrue\n>>> is_prime(2999)\nTrue\n>>> is_prime(67483)\nFalse"
  },
  {
    "function": "list_truncated_nums",
    "code": "def list_truncated_nums(n: int) -> list[int]:\n    \"\"\"\n    Returns a list of all left and right truncated numbers of n\n    >>> list_truncated_nums(927628)\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\n    >>> list_truncated_nums(467)\n    [467, 67, 46, 7, 4]\n    >>> list_truncated_nums(58)\n    [58, 8, 5]\n    \"\"\"\n    str_num = str(n)\n    list_nums = [n]\n    for i in range(1, len(str_num)):\n        list_nums.append(int(str_num[i:]))\n        list_nums.append(int(str_num[:-i]))\n    return list_nums",
    "docstring": "Returns a list of all left and right truncated numbers of n\n>>> list_truncated_nums(927628)\n[927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\n>>> list_truncated_nums(467)\n[467, 67, 46, 7, 4]\n>>> list_truncated_nums(58)\n[58, 8, 5]"
  },
  {
    "function": "validate",
    "code": "def validate(n: int) -> bool:\n    \"\"\"\n    To optimize the approach, we will rule out the numbers above 1000,\n    whose first or last three digits are not prime\n    >>> validate(74679)\n    False\n    >>> validate(235693)\n    False\n    >>> validate(3797)\n    True\n    \"\"\"\n    return not (\n        len(str(n)) > 3\n        and (not is_prime(int(str(n)[-3:])) or not is_prime(int(str(n)[:3])))\n    )",
    "docstring": "To optimize the approach, we will rule out the numbers above 1000,\nwhose first or last three digits are not prime\n>>> validate(74679)\nFalse\n>>> validate(235693)\nFalse\n>>> validate(3797)\nTrue"
  },
  {
    "function": "compute_truncated_primes",
    "code": "def compute_truncated_primes(count: int = 11) -> list[int]:\n    \"\"\"\n    Returns the list of truncated primes\n    >>> compute_truncated_primes(11)\n    [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797, 739397]\n    \"\"\"\n    list_truncated_primes: list[int] = []\n    num = 13\n    while len(list_truncated_primes) != count:\n        if validate(num):\n            list_nums = list_truncated_nums(num)\n            if all(is_prime(i) for i in list_nums):\n                list_truncated_primes.append(num)\n        num += 2\n    return list_truncated_primes",
    "docstring": "Returns the list of truncated primes\n>>> compute_truncated_primes(11)\n[23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797, 739397]"
  },
  {
    "function": "solution",
    "code": "def solution() -> int:\n    \"\"\"\n    Returns the sum of truncated primes\n    \"\"\"\n    return sum(compute_truncated_primes(11))",
    "docstring": "Returns the sum of truncated primes"
  },
  {
    "function": "is_9_pandigital",
    "code": "def is_9_pandigital(n: int) -> bool:\n    \"\"\"\n    Checks whether n is a 9-digit 1 to 9 pandigital number.\n    >>> is_9_pandigital(12345)\n    False\n    >>> is_9_pandigital(156284973)\n    True\n    >>> is_9_pandigital(1562849733)\n    False\n    \"\"\"\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")",
    "docstring": "Checks whether n is a 9-digit 1 to 9 pandigital number.\n>>> is_9_pandigital(12345)\nFalse\n>>> is_9_pandigital(156284973)\nTrue\n>>> is_9_pandigital(1562849733)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution() -> int | None:\n    \"\"\"\n    Return the largest 1 to 9 pandigital 9-digital number that can be formed as the\n    concatenated product of an integer with (1,2,...,n) where n > 1.\n    \"\"\"\n    for base_num in range(9999, 4999, -1):\n        candidate = 100002 * base_num\n        if is_9_pandigital(candidate):\n            return candidate\n\n    for base_num in range(333, 99, -1):\n        candidate = 1002003 * base_num\n        if is_9_pandigital(candidate):\n            return candidate\n\n    return None",
    "docstring": "Return the largest 1 to 9 pandigital 9-digital number that can be formed as the\nconcatenated product of an integer with (1,2,...,n) where n > 1."
  },
  {
    "function": "pythagorean_triple",
    "code": "def pythagorean_triple(max_perimeter: int) -> typing.Counter[int]:\n    \"\"\"\n    Returns a dictionary with keys as the perimeter of a right angled triangle\n    and value as the number of corresponding triplets.\n    >>> pythagorean_triple(15)\n    Counter({12: 1})\n    >>> pythagorean_triple(40)\n    Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1})\n    >>> pythagorean_triple(50)\n    Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1, 48: 1})\n    \"\"\"\n    triplets: typing.Counter[int] = Counter()\n    for base in range(1, max_perimeter + 1):\n        for perpendicular in range(base, max_perimeter + 1):\n            hypotenuse = (base * base + perpendicular * perpendicular) ** 0.5\n            if hypotenuse == int(hypotenuse):\n                perimeter = int(base + perpendicular + hypotenuse)\n                if perimeter > max_perimeter:\n                    continue\n                triplets[perimeter] += 1\n    return triplets",
    "docstring": "Returns a dictionary with keys as the perimeter of a right angled triangle\nand value as the number of corresponding triplets.\n>>> pythagorean_triple(15)\nCounter({12: 1})\n>>> pythagorean_triple(40)\nCounter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1})\n>>> pythagorean_triple(50)\nCounter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1, 48: 1})"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns perimeter with maximum solutions.\n    >>> solution(100)\n    90\n    >>> solution(200)\n    180\n    >>> solution(1000)\n    840\n    \"\"\"\n    triplets = pythagorean_triple(n)\n    return triplets.most_common(1)[0][0]",
    "docstring": "Returns perimeter with maximum solutions.\n>>> solution(100)\n90\n>>> solution(200)\n180\n>>> solution(1000)\n840"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"Returns\n\n    >>> solution()\n    210\n    \"\"\"\n    constant = []\n    i = 1\n\n    while len(constant) < 1e6:\n        constant.append(str(i))\n        i += 1\n\n    constant = \"\".join(constant)\n\n    return (\n        int(constant[0])\n        * int(constant[9])\n        * int(constant[99])\n        * int(constant[999])\n        * int(constant[9999])\n        * int(constant[99999])\n        * int(constant[999999])\n    )",
    "docstring": "Returns\n\n>>> solution()\n210"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\n\nA number is prime if it has exactly two factors: 1 and itself.\n\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(87)\nFalse\n>>> is_prime(563)\nTrue\n>>> is_prime(2999)\nTrue\n>>> is_prime(67483)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 7) -> int:\n    \"\"\"\n    Returns the maximum pandigital prime number of length n.\n    If there are none, then it will return 0.\n    >>> solution(2)\n    0\n    >>> solution(4)\n    4231\n    >>> solution(7)\n    7652413\n    \"\"\"\n    pandigital_str = \"\".join(str(i) for i in range(1, n + 1))\n    perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]\n    pandigitals = [num for num in perm_list if is_prime(num)]\n    return max(pandigitals) if pandigitals else 0",
    "docstring": "Returns the maximum pandigital prime number of length n.\nIf there are none, then it will return 0.\n>>> solution(2)\n0\n>>> solution(4)\n4231\n>>> solution(7)\n7652413"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"\n    Finds the amount of triangular words in the words file.\n\n    >>> solution()\n    162\n    \"\"\"\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    words_file_path = os.path.join(script_dir, \"words.txt\")\n\n    words = \"\"\n    with open(words_file_path) as f:\n        words = f.readline()\n\n    words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]\n    words = [\n        word\n        for word in [sum(ord(x) - 64 for x in word) for word in words]\n        if word in TRIANGULAR_NUMBERS\n    ]\n    return len(words)",
    "docstring": "Finds the amount of triangular words in the words file.\n\n>>> solution()\n162"
  },
  {
    "function": "is_substring_divisible",
    "code": "def is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True",
    "docstring": "Returns True if the pandigital number passes\nall the divisibility tests.\n>>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\nFalse\n>>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\nFalse\n>>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\nTrue"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 10) -> int:\n    \"\"\"\n    Returns the sum of all pandigital numbers which pass the\n    divisibility tests.\n    >>> solution(10)\n    16695334890\n    \"\"\"\n    return sum(\n        int(\"\".join(map(str, num)))\n        for num in permutations(range(n))\n        if is_substring_divisible(num)\n    )",
    "docstring": "Returns the sum of all pandigital numbers which pass the\ndivisibility tests.\n>>> solution(10)\n16695334890"
  },
  {
    "function": "is_pentagonal",
    "code": "def is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0",
    "docstring": "Returns True if n is pentagonal, False otherwise.\n>>> is_pentagonal(330)\nTrue\n>>> is_pentagonal(7683)\nFalse\n>>> is_pentagonal(2380)\nTrue"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 5000) -> int:\n    \"\"\"\n    Returns the minimum difference of two pentagonal numbers P1 and P2 such that\n    P1 + P2 is pentagonal and P2 - P1 is pentagonal.\n    >>> solution(5000)\n    5482660\n    \"\"\"\n    pentagonal_nums = [(i * (3 * i - 1)) // 2 for i in range(1, limit)]\n    for i, pentagonal_i in enumerate(pentagonal_nums):\n        for j in range(i, len(pentagonal_nums)):\n            pentagonal_j = pentagonal_nums[j]\n            a = pentagonal_i + pentagonal_j\n            b = pentagonal_j - pentagonal_i\n            if is_pentagonal(a) and is_pentagonal(b):\n                return b\n\n    return -1",
    "docstring": "Returns the minimum difference of two pentagonal numbers P1 and P2 such that\nP1 + P2 is pentagonal and P2 - P1 is pentagonal.\n>>> solution(5000)\n5482660"
  },
  {
    "function": "hexagonal_num",
    "code": "def hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)",
    "docstring": "Returns nth hexagonal number\n>>> hexagonal_num(143)\n40755\n>>> hexagonal_num(21)\n861\n>>> hexagonal_num(10)\n190"
  },
  {
    "function": "is_pentagonal",
    "code": "def is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0",
    "docstring": "Returns True if n is pentagonal, False otherwise.\n>>> is_pentagonal(330)\nTrue\n>>> is_pentagonal(7683)\nFalse\n>>> is_pentagonal(2380)\nTrue"
  },
  {
    "function": "solution",
    "code": "def solution(start: int = 144) -> int:\n    \"\"\"\n    Returns the next number which is triangular, pentagonal and hexagonal.\n    >>> solution(144)\n    1533776805\n    \"\"\"\n    n = start\n    num = hexagonal_num(n)\n    while not is_pentagonal(num):\n        n += 1\n        num = hexagonal_num(n)\n    return num",
    "docstring": "Returns the next number which is triangular, pentagonal and hexagonal.\n>>> solution(144)\n1533776805"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\n\nA number is prime if it has exactly two factors: 1 and itself.\n\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(87)\nFalse\n>>> is_prime(563)\nTrue\n>>> is_prime(2999)\nTrue\n>>> is_prime(67483)\nFalse"
  },
  {
    "function": "compute_nums",
    "code": "def compute_nums(n: int) -> list[int]:\n    \"\"\"\n    Returns a list of first n odd composite numbers which do\n    not follow the conjecture.\n    >>> compute_nums(1)\n    [5777]\n    >>> compute_nums(2)\n    [5777, 5993]\n    >>> compute_nums(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be >= 0\n    >>> compute_nums(\"a\")\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be an integer\n    >>> compute_nums(1.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be an integer\n\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be >= 0\")\n\n    list_nums = []\n    for num in range(len(odd_composites)):\n        i = 0\n        while 2 * i * i <= odd_composites[num]:\n            rem = odd_composites[num] - 2 * i * i\n            if is_prime(rem):\n                break\n            i += 1\n        else:\n            list_nums.append(odd_composites[num])\n            if len(list_nums) == n:\n                return list_nums\n\n    return []",
    "docstring": "Returns a list of first n odd composite numbers which do\nnot follow the conjecture.\n>>> compute_nums(1)\n[5777]\n>>> compute_nums(2)\n[5777, 5993]\n>>> compute_nums(0)\nTraceback (most recent call last):\n    ...\nValueError: n must be >= 0\n>>> compute_nums(\"a\")\nTraceback (most recent call last):\n    ...\nValueError: n must be an integer\n>>> compute_nums(1.1)\nTraceback (most recent call last):\n    ...\nValueError: n must be an integer"
  },
  {
    "function": "solution",
    "code": "def solution() -> int:\n    \"\"\"Return the solution to the problem\"\"\"\n    return compute_nums(1)[0]",
    "docstring": "Return the solution to the problem"
  },
  {
    "function": "unique_prime_factors",
    "code": "def unique_prime_factors(n: int) -> set:\n    \"\"\"\n    Find unique prime factors of an integer.\n    Tests include sorting because only the set matters,\n    not the order in which it is produced.\n    >>> sorted(set(unique_prime_factors(14)))\n    [2, 7]\n    >>> sorted(set(unique_prime_factors(644)))\n    [2, 7, 23]\n    >>> sorted(set(unique_prime_factors(646)))\n    [2, 17, 19]\n    \"\"\"\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors",
    "docstring": "Find unique prime factors of an integer.\nTests include sorting because only the set matters,\nnot the order in which it is produced.\n>>> sorted(set(unique_prime_factors(14)))\n[2, 7]\n>>> sorted(set(unique_prime_factors(644)))\n[2, 7, 23]\n>>> sorted(set(unique_prime_factors(646)))\n[2, 17, 19]"
  },
  {
    "function": "upf_len",
    "code": "def upf_len(num: int) -> int:\n    \"\"\"\n    Memoize upf() length results for a given value.\n    >>> upf_len(14)\n    2\n    \"\"\"\n    return len(unique_prime_factors(num))",
    "docstring": "Memoize upf() length results for a given value.\n>>> upf_len(14)\n2"
  },
  {
    "function": "equality",
    "code": "def equality(iterable: list) -> bool:\n    \"\"\"\n    Check the equality of ALL elements in an iterable\n    >>> equality([1, 2, 3, 4])\n    False\n    >>> equality([2, 2, 2, 2])\n    True\n    >>> equality([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    return len(set(iterable)) in (0, 1)",
    "docstring": "Check the equality of ALL elements in an iterable\n>>> equality([1, 2, 3, 4])\nFalse\n>>> equality([2, 2, 2, 2])\nTrue\n>>> equality([1, 2, 3, 2, 1])\nFalse"
  },
  {
    "function": "run",
    "code": "def run(n: int) -> list[int]:\n    \"\"\"\n    Runs core process to find problem solution.\n    >>> run(3)\n    [644, 645, 646]\n    \"\"\"\n\n    # Incrementor variable for our group list comprehension.\n    # This is the first number in each list of values\n    # to test.\n    base = 2\n\n    while True:\n        # Increment each value of a generated range\n        group = [base + i for i in range(n)]\n\n        # Run elements through the unique_prime_factors function\n        # Append our target number to the end.\n        checker = [upf_len(x) for x in group]\n        checker.append(n)\n\n        # If all numbers in the list are equal, return the group variable.\n        if equality(checker):\n            return group\n\n        # Increment our base variable by 1\n        base += 1",
    "docstring": "Runs core process to find problem solution.\n>>> run(3)\n[644, 645, 646]"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 4) -> int | None:\n    \"\"\"Return the first value of the first four consecutive integers to have four\n    distinct prime factors each.\n    >>> solution()\n    134043\n    \"\"\"\n    results = run(n)\n    return results[0] if len(results) else None",
    "docstring": "Return the first value of the first four consecutive integers to have four\ndistinct prime factors each.\n>>> solution()\n134043"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"\n    Returns the last 10 digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in range(1, 1001):\n        total += i**i\n    return str(total)[-10:]",
    "docstring": "Returns the last 10 digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.\n\n>>> solution()\n'9110846700'"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\n\nA number is prime if it has exactly two factors: 1 and itself.\n\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(87)\nFalse\n>>> is_prime(563)\nTrue\n>>> is_prime(2999)\nTrue\n>>> is_prime(67483)\nFalse"
  },
  {
    "function": "search",
    "code": "def search(target: int, prime_list: list) -> bool:\n    \"\"\"\n    function to search a number in a list using Binary Search.\n    >>> search(3, [1, 2, 3])\n    True\n    >>> search(4, [1, 2, 3])\n    False\n    >>> search(101, list(range(-100, 100)))\n    False\n    \"\"\"\n\n    left, right = 0, len(prime_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if prime_list[middle] == target:\n            return True\n        elif prime_list[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return False",
    "docstring": "function to search a number in a list using Binary Search.\n>>> search(3, [1, 2, 3])\nTrue\n>>> search(4, [1, 2, 3])\nFalse\n>>> search(101, list(range(-100, 100)))\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"\n    Return the solution of the problem.\n    >>> solution()\n    296962999629\n    \"\"\"\n    prime_list = [n for n in range(1001, 10000, 2) if is_prime(n)]\n    candidates = []\n\n    for number in prime_list:\n        tmp_numbers = []\n\n        for prime_member in permutations(list(str(number))):\n            prime = int(\"\".join(prime_member))\n\n            if prime % 2 == 0:\n                continue\n\n            if search(prime, prime_list):\n                tmp_numbers.append(prime)\n\n        tmp_numbers.sort()\n        if len(tmp_numbers) >= 3:\n            candidates.append(tmp_numbers)\n\n    passed = []\n    for candidate in candidates:\n        length = len(candidate)\n        found = False\n\n        for i in range(length):\n            for j in range(i + 1, length):\n                for k in range(j + 1, length):\n                    if (\n                        abs(candidate[i] - candidate[j])\n                        == abs(candidate[j] - candidate[k])\n                        and len({candidate[i], candidate[j], candidate[k]}) == 3\n                    ):\n                        passed.append(\n                            sorted([candidate[i], candidate[j], candidate[k]])\n                        )\n                        found = True\n\n                    if found:\n                        break\n                if found:\n                    break\n            if found:\n                break\n\n    answer = set()\n    for seq in passed:\n        answer.add(\"\".join([str(i) for i in seq]))\n\n    return max(int(x) for x in answer)",
    "docstring": "Return the solution of the problem.\n>>> solution()\n296962999629"
  },
  {
    "function": "prime_sieve",
    "code": "def prime_sieve(limit: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit**0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes",
    "docstring": "Sieve of Erotosthenes\nFunction to return all the prime numbers up to a number 'limit'\nhttps://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n>>> prime_sieve(3)\n[2]\n\n>>> prime_sieve(50)\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]"
  },
  {
    "function": "solution",
    "code": "def solution(ceiling: int = 1_000_000) -> int:\n    \"\"\"\n    Returns the biggest prime, below the celing, that can be written as the sum\n    of consecutive the most consecutive primes.\n\n    >>> solution(500)\n    499\n\n    >>> solution(1_000)\n    953\n\n    >>> solution(10_000)\n    9521\n    \"\"\"\n    primes = prime_sieve(ceiling)\n    length = 0\n    largest = 0\n\n    for i in range(len(primes)):\n        for j in range(i + length, len(primes)):\n            sol = sum(primes[i:j])\n            if sol >= ceiling:\n                break\n\n            if sol in primes:\n                length = j - i\n                largest = sol\n\n    return largest",
    "docstring": "Returns the biggest prime, below the celing, that can be written as the sum\nof consecutive the most consecutive primes.\n\n>>> solution(500)\n499\n\n>>> solution(1_000)\n953\n\n>>> solution(10_000)\n9521"
  },
  {
    "function": "prime_sieve",
    "code": "def prime_sieve(n: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n**0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes",
    "docstring": "Sieve of Erotosthenes\nFunction to return all the prime numbers up to a certain number\nhttps://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n>>> prime_sieve(3)\n[2]\n\n>>> prime_sieve(50)\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]"
  },
  {
    "function": "digit_replacements",
    "code": "def digit_replacements(number: int) -> list[list[int]]:\n    \"\"\"\n    Returns all the possible families of digit replacements in a number which\n    contains at least one repeating digit\n\n    >>> digit_replacements(544)\n    [[500, 511, 522, 533, 544, 555, 566, 577, 588, 599]]\n\n    >>> digit_replacements(3112)\n    [[3002, 3112, 3222, 3332, 3442, 3552, 3662, 3772, 3882, 3992]]\n    \"\"\"\n    number_str = str(number)\n    replacements = []\n    digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n\n    for duplicate in Counter(number_str) - Counter(set(number_str)):\n        family = [int(number_str.replace(duplicate, digit)) for digit in digits]\n        replacements.append(family)\n\n    return replacements",
    "docstring": "Returns all the possible families of digit replacements in a number which\ncontains at least one repeating digit\n\n>>> digit_replacements(544)\n[[500, 511, 522, 533, 544, 555, 566, 577, 588, 599]]\n\n>>> digit_replacements(3112)\n[[3002, 3112, 3222, 3332, 3442, 3552, 3662, 3772, 3882, 3992]]"
  },
  {
    "function": "solution",
    "code": "def solution(family_length: int = 8) -> int:\n    \"\"\"\n    Returns the solution of the problem\n\n    >>> solution(2)\n    229399\n\n    >>> solution(3)\n    221311\n    \"\"\"\n    numbers_checked = set()\n\n    # Filter primes with less than 3 replaceable digits\n    primes = {\n        x for x in set(prime_sieve(1_000_000)) if len(str(x)) - len(set(str(x))) >= 3\n    }\n\n    for prime in primes:\n        if prime in numbers_checked:\n            continue\n\n        replacements = digit_replacements(prime)\n\n        for family in replacements:\n            numbers_checked.update(family)\n            primes_in_family = primes.intersection(family)\n\n            if len(primes_in_family) != family_length:\n                continue\n\n            return min(primes_in_family)\n\n    return -1",
    "docstring": "Returns the solution of the problem\n\n>>> solution(2)\n229399\n\n>>> solution(3)\n221311"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"Returns the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and\n    6x, contain the same digits.\n\n    >>> solution()\n    142857\n    \"\"\"\n    i = 1\n\n    while True:\n        if (\n            sorted(str(i))\n            == sorted(str(2 * i))\n            == sorted(str(3 * i))\n            == sorted(str(4 * i))\n            == sorted(str(5 * i))\n            == sorted(str(6 * i))\n        ):\n            return i\n\n        i += 1",
    "docstring": "Returns the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and\n6x, contain the same digits.\n\n>>> solution()\n142857"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"Returns the number of values of nCr, for 1 \u2264 n \u2264 100, are greater than\n    one-million\n\n    >>> solution()\n    4075\n    \"\"\"\n    total = 0\n\n    for i in range(1, 101):\n        for j in range(1, i + 1):\n            if combinations(i, j) > 1e6:\n                total += 1\n    return total",
    "docstring": "Returns the number of values of nCr, for 1 \u2264 n \u2264 100, are greater than\none-million\n\n>>> solution()\n4075"
  },
  {
    "function": "is_palindrome",
    "code": "def is_palindrome(n: int) -> bool:\n    \"\"\"\n    Returns True if a number is palindrome.\n    >>> is_palindrome(12567321)\n    False\n    >>> is_palindrome(1221)\n    True\n    >>> is_palindrome(9876789)\n    True\n    \"\"\"\n    return str(n) == str(n)[::-1]",
    "docstring": "Returns True if a number is palindrome.\n>>> is_palindrome(12567321)\nFalse\n>>> is_palindrome(1221)\nTrue\n>>> is_palindrome(9876789)\nTrue"
  },
  {
    "function": "sum_reverse",
    "code": "def sum_reverse(n: int) -> int:\n    \"\"\"\n    Returns the sum of n and reverse of n.\n    >>> sum_reverse(123)\n    444\n    >>> sum_reverse(3478)\n    12221\n    >>> sum_reverse(12)\n    33\n    \"\"\"\n    return int(n) + int(str(n)[::-1])",
    "docstring": "Returns the sum of n and reverse of n.\n>>> sum_reverse(123)\n444\n>>> sum_reverse(3478)\n12221\n>>> sum_reverse(12)\n33"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 10000) -> int:\n    \"\"\"\n    Returns the count of all lychrel numbers below limit.\n    >>> solution(10000)\n    249\n    >>> solution(5000)\n    76\n    >>> solution(1000)\n    13\n    \"\"\"\n    lychrel_nums = []\n    for num in range(1, limit):\n        iterations = 0\n        a = num\n        while iterations < 50:\n            num = sum_reverse(num)\n            iterations += 1\n            if is_palindrome(num):\n                break\n        else:\n            lychrel_nums.append(a)\n    return len(lychrel_nums)",
    "docstring": "Returns the count of all lychrel numbers below limit.\n>>> solution(10000)\n249\n>>> solution(5000)\n76\n>>> solution(1000)\n13"
  },
  {
    "function": "solution",
    "code": "def solution(a: int = 100, b: int = 100) -> int:\n    \"\"\"\n    Considering natural numbers of the form, a**b, where a, b < 100,\n    what is the maximum digital sum?\n    :param a:\n    :param b:\n    :return:\n    >>> solution(10,10)\n    45\n\n    >>> solution(100,100)\n    972\n\n    >>> solution(100,200)\n    1872\n    \"\"\"\n\n    # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of\n    # BASE raised to the POWER\n    return max(\n        sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)\n    )",
    "docstring": "Considering natural numbers of the form, a**b, where a, b < 100,\nwhat is the maximum digital sum?\n:param a:\n:param b:\n:return:\n>>> solution(10,10)\n45\n\n>>> solution(100,100)\n972\n\n>>> solution(100,200)\n1872"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    returns number of fractions containing a numerator with more digits than\n    the denominator in the first n expansions.\n    >>> solution(14)\n    2\n    >>> solution(100)\n    15\n    >>> solution(10000)\n    1508\n    \"\"\"\n    prev_numerator, prev_denominator = 1, 1\n    result = []\n    for i in range(1, n + 1):\n        numerator = prev_numerator + 2 * prev_denominator\n        denominator = prev_numerator + prev_denominator\n        if len(str(numerator)) > len(str(denominator)):\n            result.append(i)\n        prev_numerator = numerator\n        prev_denominator = denominator\n\n    return len(result)",
    "docstring": "returns number of fractions containing a numerator with more digits than\nthe denominator in the first n expansions.\n>>> solution(14)\n2\n>>> solution(100)\n15\n>>> solution(10000)\n1508"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True",
    "docstring": "Checks to see if a number is a prime in O(sqrt(n)).\n\nA number is prime if it has exactly two factors: 1 and itself.\n\n>>> is_prime(0)\nFalse\n>>> is_prime(1)\nFalse\n>>> is_prime(2)\nTrue\n>>> is_prime(3)\nTrue\n>>> is_prime(27)\nFalse\n>>> is_prime(87)\nFalse\n>>> is_prime(563)\nTrue\n>>> is_prime(2999)\nTrue\n>>> is_prime(67483)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(ratio: float = 0.1) -> int:\n    \"\"\"\n    Returns the side length of the square spiral of odd length greater\n    than 1 for which the ratio of primes along both diagonals\n    first falls below the given ratio.\n    >>> solution(.5)\n    11\n    >>> solution(.2)\n    309\n    >>> solution(.111)\n    11317\n    \"\"\"\n\n    j = 3\n    primes = 3\n\n    while primes / (2 * j - 1) >= ratio:\n        for i in range(j * j + j + 1, (j + 2) * (j + 2), j + 1):\n            primes += is_prime(i)\n        j += 2\n    return j",
    "docstring": "Returns the side length of the square spiral of odd length greater\nthan 1 for which the ratio of primes along both diagonals\nfirst falls below the given ratio.\n>>> solution(.5)\n11\n>>> solution(.2)\n309\n>>> solution(.111)\n11317"
  },
  {
    "function": "try_key",
    "code": "def try_key(ciphertext: list[int], key: tuple[int, ...]) -> str | None:\n    \"\"\"\n    Given an encrypted message and a possible 3-character key, decrypt the message.\n    If the decrypted message contains a invalid character, i.e. not an ASCII letter,\n    a digit, punctuation or whitespace, then we know the key is incorrect, so return\n    None.\n    >>> try_key([0, 17, 20, 4, 27], (104, 116, 120))\n    'hello'\n    >>> try_key([68, 10, 300, 4, 27], (104, 116, 120)) is None\n    True\n    \"\"\"\n    decoded: str = \"\"\n    keychar: int\n    cipherchar: int\n    decodedchar: int\n\n    for keychar, cipherchar in zip(cycle(key), ciphertext):\n        decodedchar = cipherchar ^ keychar\n        if decodedchar not in VALID_INTS:\n            return None\n        decoded += chr(decodedchar)\n\n    return decoded",
    "docstring": "Given an encrypted message and a possible 3-character key, decrypt the message.\nIf the decrypted message contains a invalid character, i.e. not an ASCII letter,\na digit, punctuation or whitespace, then we know the key is incorrect, so return\nNone.\n>>> try_key([0, 17, 20, 4, 27], (104, 116, 120))\n'hello'\n>>> try_key([68, 10, 300, 4, 27], (104, 116, 120)) is None\nTrue"
  },
  {
    "function": "filter_valid_chars",
    "code": "def filter_valid_chars(ciphertext: list[int]) -> list[str]:\n    \"\"\"\n    Given an encrypted message, test all 3-character strings to try and find the\n    key. Return a list of the possible decrypted messages.\n    >>> from itertools import cycle\n    >>> text = \"The enemy's gate is down\"\n    >>> key = \"end\"\n    >>> encoded = [ord(k) ^ ord(c) for k,c in zip(cycle(key), text)]\n    >>> text in filter_valid_chars(encoded)\n    True\n    \"\"\"\n    possibles: list[str] = []\n    for key in product(LOWERCASE_INTS, repeat=3):\n        encoded = try_key(ciphertext, key)\n        if encoded is not None:\n            possibles.append(encoded)\n    return possibles",
    "docstring": "Given an encrypted message, test all 3-character strings to try and find the\nkey. Return a list of the possible decrypted messages.\n>>> from itertools import cycle\n>>> text = \"The enemy's gate is down\"\n>>> key = \"end\"\n>>> encoded = [ord(k) ^ ord(c) for k,c in zip(cycle(key), text)]\n>>> text in filter_valid_chars(encoded)\nTrue"
  },
  {
    "function": "filter_common_word",
    "code": "def filter_common_word(possibles: list[str], common_word: str) -> list[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]",
    "docstring": "Given a list of possible decoded messages, narrow down the possibilities\nfor checking for the presence of a specified common word. Only decoded messages\ncontaining common_word will be returned.\n>>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n['I am here']\n>>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n['athla amf', 'I am here']"
  },
  {
    "function": "solution",
    "code": "def solution(filename: str = \"p059_cipher.txt\") -> int:\n    \"\"\"\n    Test the ciphertext against all possible 3-character keys, then narrow down the\n    possibilities by filtering using common words until there's only one possible\n    decoded message.\n    >>> solution(\"test_cipher.txt\")\n    3000\n    \"\"\"\n    ciphertext: list[int]\n    possibles: list[str]\n    common_word: str\n    decoded_text: str\n    data: str = Path(__file__).parent.joinpath(filename).read_text(encoding=\"utf-8\")\n\n    ciphertext = [int(number) for number in data.strip().split(\",\")]\n\n    possibles = filter_valid_chars(ciphertext)\n    for common_word in COMMON_WORDS:\n        possibles = filter_common_word(possibles, common_word)\n        if len(possibles) == 1:\n            break\n\n    decoded_text = possibles[0]\n    return sum(ord(char) for char in decoded_text)",
    "docstring": "Test the ciphertext against all possible 3-character keys, then narrow down the\npossibilities by filtering using common words until there's only one possible\ndecoded message.\n>>> solution(\"test_cipher.txt\")\n3000"
  },
  {
    "function": "solution",
    "code": "def solution(max_base: int = 5) -> int:\n    \"\"\"\n    Iterate through every possible cube and sort the cube's digits in\n    ascending order. Sorting maintains an ordering of the digits that allows\n    you to compare permutations. Store each sorted sequence of digits in a\n    dictionary, whose key is the sequence of digits and value is a list of\n    numbers that are the base of the cube.\n\n    Once you find 5 numbers that produce the same sequence of digits, return\n    the smallest one, which is at index 0 since we insert each base number in\n    ascending order.\n\n    >>> solution(2)\n    125\n    >>> solution(3)\n    41063625\n    \"\"\"\n    freqs = defaultdict(list)\n    num = 0\n\n    while True:\n        digits = get_digits(num)\n        freqs[digits].append(num)\n\n        if len(freqs[digits]) == max_base:\n            base = freqs[digits][0] ** 3\n            return base\n\n        num += 1",
    "docstring": "Iterate through every possible cube and sort the cube's digits in\nascending order. Sorting maintains an ordering of the digits that allows\nyou to compare permutations. Store each sorted sequence of digits in a\ndictionary, whose key is the sequence of digits and value is a list of\nnumbers that are the base of the cube.\n\nOnce you find 5 numbers that produce the same sequence of digits, return\nthe smallest one, which is at index 0 since we insert each base number in\nascending order.\n\n>>> solution(2)\n125\n>>> solution(3)\n41063625"
  },
  {
    "function": "get_digits",
    "code": "def get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))",
    "docstring": "Computes the sorted sequence of digits of the cube of num.\n\n>>> get_digits(3)\n'27'\n>>> get_digits(99)\n'027999'\n>>> get_digits(123)\n'0166788'"
  },
  {
    "function": "solution",
    "code": "def solution(max_base: int = 10, max_power: int = 22) -> int:\n    \"\"\"\n    Returns the count of all n-digit numbers which are nth power\n    >>> solution(10, 22)\n    49\n    >>> solution(0, 0)\n    0\n    >>> solution(1, 1)\n    0\n    >>> solution(-1, -1)\n    0\n    \"\"\"\n    bases = range(1, max_base)\n    powers = range(1, max_power)\n    return sum(\n        1 for power in powers for base in bases if len(str(base**power)) == power\n    )",
    "docstring": "Returns the count of all n-digit numbers which are nth power\n>>> solution(10, 22)\n49\n>>> solution(0, 0)\n0\n>>> solution(1, 1)\n0\n>>> solution(-1, -1)\n0"
  },
  {
    "function": "continuous_fraction_period",
    "code": "def continuous_fraction_period(n: int) -> int:\n    \"\"\"\n    Returns the continued fraction period of a number n.\n\n    >>> continuous_fraction_period(2)\n    1\n    >>> continuous_fraction_period(5)\n    1\n    >>> continuous_fraction_period(7)\n    4\n    >>> continuous_fraction_period(11)\n    2\n    >>> continuous_fraction_period(13)\n    5\n    \"\"\"\n    numerator = 0.0\n    denominator = 1.0\n    root = int(sqrt(n))\n    integer_part = root\n    period = 0\n    while integer_part != 2 * root:\n        numerator = denominator * integer_part - numerator\n        denominator = (n - numerator**2) / denominator\n        integer_part = int((root + numerator) / denominator)\n        period += 1\n    return period",
    "docstring": "Returns the continued fraction period of a number n.\n\n>>> continuous_fraction_period(2)\n1\n>>> continuous_fraction_period(5)\n1\n>>> continuous_fraction_period(7)\n4\n>>> continuous_fraction_period(11)\n2\n>>> continuous_fraction_period(13)\n5"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 10000) -> int:\n    \"\"\"\n    Returns the count of numbers <= 10000 with odd periods.\n    This function calls continuous_fraction_period for numbers which are\n    not perfect squares.\n    This is checked in if sr - floor(sr) != 0 statement.\n    If an odd period is returned by continuous_fraction_period,\n    count_odd_periods is increased by 1.\n\n    >>> solution(2)\n    1\n    >>> solution(5)\n    2\n    >>> solution(7)\n    2\n    >>> solution(11)\n    3\n    >>> solution(13)\n    4\n    \"\"\"\n    count_odd_periods = 0\n    for i in range(2, n + 1):\n        sr = sqrt(i)\n        if sr - floor(sr) != 0 and continuous_fraction_period(i) % 2 == 1:\n            count_odd_periods += 1\n    return count_odd_periods",
    "docstring": "Returns the count of numbers <= 10000 with odd periods.\nThis function calls continuous_fraction_period for numbers which are\nnot perfect squares.\nThis is checked in if sr - floor(sr) != 0 statement.\nIf an odd period is returned by continuous_fraction_period,\ncount_odd_periods is increased by 1.\n\n>>> solution(2)\n1\n>>> solution(5)\n2\n>>> solution(7)\n2\n>>> solution(11)\n3\n>>> solution(13)\n4"
  },
  {
    "function": "sum_digits",
    "code": "def sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum",
    "docstring": "Returns the sum of every digit in num.\n\n>>> sum_digits(1)\n1\n>>> sum_digits(12345)\n15\n>>> sum_digits(999001)\n28"
  },
  {
    "function": "solution",
    "code": "def solution(max_n: int = 100) -> int:\n    \"\"\"\n    Returns the sum of the digits in the numerator of the max-th convergent of\n    the continued fraction for e.\n\n    >>> solution(9)\n    13\n    >>> solution(10)\n    17\n    >>> solution(50)\n    91\n    \"\"\"\n    pre_numerator = 1\n    cur_numerator = 2\n\n    for i in range(2, max_n + 1):\n        temp = pre_numerator\n        e_cont = 2 * i // 3 if i % 3 == 0 else 1\n        pre_numerator = cur_numerator\n        cur_numerator = e_cont * pre_numerator + temp\n\n    return sum_digits(cur_numerator)",
    "docstring": "Returns the sum of the digits in the numerator of the max-th convergent of\nthe continued fraction for e.\n\n>>> solution(9)\n13\n>>> solution(10)\n17\n>>> solution(50)\n91"
  },
  {
    "function": "solution",
    "code": "def solution():\n    \"\"\"\n    Finds the maximum total in a triangle as described by the problem statement\n    above.\n\n    >>> solution()\n    7273\n    \"\"\"\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    triangle = os.path.join(script_dir, \"triangle.txt\")\n\n    with open(triangle) as f:\n        triangle = f.readlines()\n\n    a = []\n    for line in triangle:\n        numbers_from_line = []\n        for number in line.strip().split(\" \"):\n            numbers_from_line.append(int(number))\n        a.append(numbers_from_line)\n\n    for i in range(1, len(a)):\n        for j in range(len(a[i])):\n            number1 = a[i - 1][j] if j != len(a[i - 1]) else 0\n            number2 = a[i - 1][j - 1] if j > 0 else 0\n            a[i][j] += max(number1, number2)\n    return max(a[-1])",
    "docstring": "Finds the maximum total in a triangle as described by the problem statement\nabove.\n\n>>> solution()\n7273"
  },
  {
    "function": "solution",
    "code": "def solution() -> int:\n    \"\"\"\n    Finds the maximum total in a triangle as described by the problem statement\n    above.\n    >>> solution()\n    7273\n    \"\"\"\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    triangle_path = os.path.join(script_dir, \"triangle.txt\")\n\n    with open(triangle_path) as in_file:\n        triangle = [[int(i) for i in line.split()] for line in in_file]\n\n    while len(triangle) != 1:\n        last_row = triangle.pop()\n        curr_row = triangle[-1]\n        for j in range(len(last_row) - 1):\n            curr_row[j] += max(last_row[j], last_row[j + 1])\n    return triangle[0][0]",
    "docstring": "Finds the maximum total in a triangle as described by the problem statement\nabove.\n>>> solution()\n7273"
  },
  {
    "function": "solution",
    "code": "def solution(gon_side: int = 5) -> int:\n    \"\"\"\n    Find the maximum number for a \"magic\" gon_side-gon ring\n\n    The gon_side parameter should be in the range [3, 5],\n    other side numbers aren't tested\n\n    >>> solution(3)\n    432621513\n    >>> solution(4)\n    426561813732\n    >>> solution()\n    6531031914842725\n    >>> solution(6)\n    Traceback (most recent call last):\n    ValueError: gon_side must be in the range [3, 5]\n    \"\"\"\n    if gon_side < 3 or gon_side > 5:\n        raise ValueError(\"gon_side must be in the range [3, 5]\")\n\n    # Since it's 16, we know 10 is on the outer ring\n    # Put the big numbers at the end so that they are never the first number\n    small_numbers = list(range(gon_side + 1, 0, -1))\n    big_numbers = list(range(gon_side + 2, gon_side * 2 + 1))\n\n    for perm in permutations(small_numbers + big_numbers):\n        numbers = generate_gon_ring(gon_side, list(perm))\n        if is_magic_gon(numbers):\n            return int(\"\".join(str(n) for n in numbers))\n\n    msg = f\"Magic {gon_side}-gon ring is impossible\"\n    raise ValueError(msg)",
    "docstring": "Find the maximum number for a \"magic\" gon_side-gon ring\n\nThe gon_side parameter should be in the range [3, 5],\nother side numbers aren't tested\n\n>>> solution(3)\n432621513\n>>> solution(4)\n426561813732\n>>> solution()\n6531031914842725\n>>> solution(6)\nTraceback (most recent call last):\nValueError: gon_side must be in the range [3, 5]"
  },
  {
    "function": "generate_gon_ring",
    "code": "def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result",
    "docstring": "Generate a gon_side-gon ring from a permutation state\nThe permutation state is the ring, but every duplicate is removed\n\n>>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n[4, 2, 3, 5, 3, 1, 6, 1, 2]\n>>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n[6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]"
  },
  {
    "function": "is_magic_gon",
    "code": "def is_magic_gon(numbers: list[int]) -> bool:\n    \"\"\"\n    Check if the solution set is a magic n-gon ring\n    Check that the first number is the smallest number on the outer ring\n    Take a list, and check if the sum of each 3 numbers chunk is equal to the same total\n\n    >>> is_magic_gon([4, 2, 3, 5, 3, 1, 6, 1, 2])\n    True\n    >>> is_magic_gon([4, 3, 2, 6, 2, 1, 5, 1, 3])\n    True\n    >>> is_magic_gon([2, 3, 5, 4, 5, 1, 6, 1, 3])\n    True\n    >>> is_magic_gon([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    False\n    >>> is_magic_gon([1])\n    Traceback (most recent call last):\n    ValueError: a gon ring should have a length that is a multiple of 3\n    \"\"\"\n    if len(numbers) % 3 != 0:\n        raise ValueError(\"a gon ring should have a length that is a multiple of 3\")\n\n    if min(numbers[::3]) != numbers[0]:\n        return False\n\n    total = sum(numbers[:3])\n\n    return all(sum(numbers[i : i + 3]) == total for i in range(3, len(numbers), 3))",
    "docstring": "Check if the solution set is a magic n-gon ring\nCheck that the first number is the smallest number on the outer ring\nTake a list, and check if the sum of each 3 numbers chunk is equal to the same total\n\n>>> is_magic_gon([4, 2, 3, 5, 3, 1, 6, 1, 2])\nTrue\n>>> is_magic_gon([4, 3, 2, 6, 2, 1, 5, 1, 3])\nTrue\n>>> is_magic_gon([2, 3, 5, 4, 5, 1, 6, 1, 3])\nTrue\n>>> is_magic_gon([1, 2, 3, 4, 5, 6, 7, 8, 9])\nFalse\n>>> is_magic_gon([1])\nTraceback (most recent call last):\nValueError: a gon ring should have a length that is a multiple of 3"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 10**6) -> int:\n    \"\"\"\n    Returns solution to problem.\n    Algorithm:\n    1. Precompute \u03c6(k) for all natural k, k <= n using product formula (wikilink below)\n    https://en.wikipedia.org/wiki/Euler%27s_totient_function#Euler's_product_formula\n\n    2. Find k/\u03c6(k) for all k \u2264 n and return the k that attains maximum\n\n    >>> solution(10)\n    6\n\n    >>> solution(100)\n    30\n\n    >>> solution(9973)\n    2310\n\n    \"\"\"\n\n    if n <= 0:\n        raise ValueError(\"Please enter an integer greater than 0\")\n\n    phi = list(range(n + 1))\n    for number in range(2, n + 1):\n        if phi[number] == number:\n            phi[number] -= 1\n            for multiple in range(number * 2, n + 1, number):\n                phi[multiple] = (phi[multiple] // number) * (number - 1)\n\n    answer = 1\n    for number in range(1, n + 1):\n        if (answer / phi[answer]) < (number / phi[number]):\n            answer = number\n\n    return answer",
    "docstring": "Returns solution to problem.\nAlgorithm:\n1. Precompute \u03c6(k) for all natural k, k <= n using product formula (wikilink below)\nhttps://en.wikipedia.org/wiki/Euler%27s_totient_function#Euler's_product_formula\n\n2. Find k/\u03c6(k) for all k \u2264 n and return the k that attains maximum\n\n>>> solution(10)\n6\n\n>>> solution(100)\n30\n\n>>> solution(9973)\n2310"
  },
  {
    "function": "get_totients",
    "code": "def get_totients(max_one: int) -> list[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = np.arange(max_one)\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            x = np.arange(i, max_one, i)  # array of indexes to select\n            totients[x] -= totients[x] // i\n\n    return totients.tolist()",
    "docstring": "Calculates a list of totients from 0 to max_one exclusive, using the\ndefinition of Euler's product formula.\n\n>>> get_totients(5)\n[0, 1, 1, 2, 2]\n\n>>> get_totients(10)\n[0, 1, 1, 2, 2, 4, 2, 6, 4, 6]"
  },
  {
    "function": "has_same_digits",
    "code": "def has_same_digits(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if num1 and num2 have the same frequency of every digit, False\n    otherwise.\n\n    >>> has_same_digits(123456789, 987654321)\n    True\n\n    >>> has_same_digits(123, 23)\n    False\n\n    >>> has_same_digits(1234566, 123456)\n    False\n    \"\"\"\n    return sorted(str(num1)) == sorted(str(num2))",
    "docstring": "Return True if num1 and num2 have the same frequency of every digit, False\notherwise.\n\n>>> has_same_digits(123456789, 987654321)\nTrue\n\n>>> has_same_digits(123, 23)\nFalse\n\n>>> has_same_digits(1234566, 123456)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(max_n: int = 10000000) -> int:\n    \"\"\"\n    Finds the value of n from 1 to max such that n/\u03c6(n) produces a minimum.\n\n    >>> solution(100)\n    21\n\n    >>> solution(10000)\n    4435\n    \"\"\"\n\n    min_numerator = 1  # i\n    min_denominator = 0  # \u03c6(i)\n    totients = get_totients(max_n + 1)\n\n    for i in range(2, max_n + 1):\n        t = totients[i]\n\n        if i * min_denominator < min_numerator * t and has_same_digits(i, t):\n            min_numerator = i\n            min_denominator = t\n\n    return min_numerator",
    "docstring": "Finds the value of n from 1 to max such that n/\u03c6(n) produces a minimum.\n\n>>> solution(100)\n21\n\n>>> solution(10000)\n4435"
  },
  {
    "function": "solution",
    "code": "def solution(numerator: int = 3, denominator: int = 7, limit: int = 1000000) -> int:\n    \"\"\"\n    Returns the closest numerator of the fraction immediately to the\n    left of given fraction (numerator/denominator) from a list of reduced\n    proper fractions.\n    >>> solution()\n    428570\n    >>> solution(3, 7, 8)\n    2\n    >>> solution(6, 7, 60)\n    47\n    \"\"\"\n    max_numerator = 0\n    max_denominator = 1\n\n    for current_denominator in range(1, limit + 1):\n        current_numerator = current_denominator * numerator // denominator\n        if current_denominator % denominator == 0:\n            current_numerator -= 1\n        if current_numerator * max_denominator > current_denominator * max_numerator:\n            max_numerator = current_numerator\n            max_denominator = current_denominator\n    return max_numerator",
    "docstring": "Returns the closest numerator of the fraction immediately to the\nleft of given fraction (numerator/denominator) from a list of reduced\nproper fractions.\n>>> solution()\n428570\n>>> solution(3, 7, 8)\n2\n>>> solution(6, 7, 60)\n47"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 1_000_000) -> int:\n    \"\"\"\n    Returns an integer, the solution to the problem\n    >>> solution(10)\n    31\n    >>> solution(100)\n    3043\n    >>> solution(1_000)\n    304191\n    \"\"\"\n\n    # generating an array from -1 to limit\n    phi = np.arange(-1, limit)\n\n    for i in range(2, limit + 1):\n        if phi[i] == i - 1:\n            ind = np.arange(2 * i, limit + 1, i)  # indexes for selection\n            phi[ind] -= phi[ind] // i\n\n    return int(np.sum(phi[2 : limit + 1]))",
    "docstring": "Returns an integer, the solution to the problem\n>>> solution(10)\n31\n>>> solution(100)\n3043\n>>> solution(1_000)\n304191"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 1000000) -> int:\n    \"\"\"\n    Return the number of reduced proper fractions with denominator less than limit.\n    >>> solution(8)\n    21\n    >>> solution(1000)\n    304191\n    \"\"\"\n    primes = set(range(3, limit, 2))\n    primes.add(2)\n    for p in range(3, limit, 2):\n        if p not in primes:\n            continue\n        primes.difference_update(set(range(p * p, limit, p)))\n\n    phi = [float(n) for n in range(limit + 1)]\n\n    for p in primes:\n        for n in range(p, limit + 1, p):\n            phi[n] *= 1 - 1 / p\n\n    return int(sum(phi[2:]))",
    "docstring": "Return the number of reduced proper fractions with denominator less than limit.\n>>> solution(8)\n21\n>>> solution(1000)\n304191"
  },
  {
    "function": "solution",
    "code": "def solution(max_d: int = 12_000) -> int:\n    \"\"\"\n    Returns number of fractions lie between 1/3 and 1/2 in the sorted set\n    of reduced proper fractions for d \u2264 max_d\n\n    >>> solution(4)\n    0\n\n    >>> solution(5)\n    1\n\n    >>> solution(8)\n    3\n    \"\"\"\n\n    fractions_number = 0\n    for d in range(max_d + 1):\n        n_start = d // 3 + 1\n        n_step = 1\n        if d % 2 == 0:\n            n_start += 1 - n_start % 2\n            n_step = 2\n        for n in range(n_start, (d + 1) // 2, n_step):\n            if gcd(n, d) == 1:\n                fractions_number += 1\n    return fractions_number",
    "docstring": "Returns number of fractions lie between 1/3 and 1/2 in the sorted set\nof reduced proper fractions for d \u2264 max_d\n\n>>> solution(4)\n0\n\n>>> solution(5)\n1\n\n>>> solution(8)\n3"
  },
  {
    "function": "sum_digit_factorials",
    "code": "def sum_digit_factorials(n: int) -> int:\n    \"\"\"\n    Return the sum of the factorial of the digits of n.\n    >>> sum_digit_factorials(145)\n    145\n    >>> sum_digit_factorials(45361)\n    871\n    >>> sum_digit_factorials(540)\n    145\n    \"\"\"\n    if n in CACHE_SUM_DIGIT_FACTORIALS:\n        return CACHE_SUM_DIGIT_FACTORIALS[n]\n    ret = sum(DIGIT_FACTORIALS[let] for let in str(n))\n    CACHE_SUM_DIGIT_FACTORIALS[n] = ret\n    return ret",
    "docstring": "Return the sum of the factorial of the digits of n.\n>>> sum_digit_factorials(145)\n145\n>>> sum_digit_factorials(45361)\n871\n>>> sum_digit_factorials(540)\n145"
  },
  {
    "function": "chain_length",
    "code": "def chain_length(n: int, previous: set | None = None) -> int:\n    \"\"\"\n    Calculate the length of the chain of non-repeating terms starting with n.\n    Previous is a set containing the previous member of the chain.\n    >>> chain_length(10101)\n    11\n    >>> chain_length(555)\n    20\n    >>> chain_length(178924)\n    39\n    \"\"\"\n    previous = previous or set()\n    if n in CHAIN_LENGTH_CACHE:\n        return CHAIN_LENGTH_CACHE[n]\n    next_number = sum_digit_factorials(n)\n    if next_number in previous:\n        CHAIN_LENGTH_CACHE[n] = 0\n        return 0\n    else:\n        previous.add(n)\n        ret = 1 + chain_length(next_number, previous)\n        CHAIN_LENGTH_CACHE[n] = ret\n        return ret",
    "docstring": "Calculate the length of the chain of non-repeating terms starting with n.\nPrevious is a set containing the previous member of the chain.\n>>> chain_length(10101)\n11\n>>> chain_length(555)\n20\n>>> chain_length(178924)\n39"
  },
  {
    "function": "solution",
    "code": "def solution(num_terms: int = 60, max_start: int = 1000000) -> int:\n    \"\"\"\n    Return the number of chains with a starting number below one million which\n    contain exactly n non-repeating terms.\n    >>> solution(10,1000)\n    28\n    \"\"\"\n    return sum(1 for i in range(1, max_start) if chain_length(i) == num_terms)",
    "docstring": "Return the number of chains with a starting number below one million which\ncontain exactly n non-repeating terms.\n>>> solution(10,1000)\n28"
  },
  {
    "function": "digit_factorial_sum",
    "code": "def digit_factorial_sum(number: int) -> int:\n    \"\"\"\n    Function to perform the sum of the factorial of all the digits in number\n\n    >>> digit_factorial_sum(69.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter number must be int\n\n    >>> digit_factorial_sum(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter number must be greater than or equal to 0\n\n    >>> digit_factorial_sum(0)\n    1\n\n    >>> digit_factorial_sum(69)\n    363600\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Parameter number must be int\")\n\n    if number < 0:\n        raise ValueError(\"Parameter number must be greater than or equal to 0\")\n\n    # Converts number in string to iterate on its digits and adds its factorial.\n    return sum(DIGIT_FACTORIAL[digit] for digit in str(number))",
    "docstring": "Function to perform the sum of the factorial of all the digits in number\n\n>>> digit_factorial_sum(69.0)\nTraceback (most recent call last):\n    ...\nTypeError: Parameter number must be int\n\n>>> digit_factorial_sum(-1)\nTraceback (most recent call last):\n    ...\nValueError: Parameter number must be greater than or equal to 0\n\n>>> digit_factorial_sum(0)\n1\n\n>>> digit_factorial_sum(69)\n363600"
  },
  {
    "function": "solution",
    "code": "def solution(chain_length: int = 60, number_limit: int = 1000000) -> int:\n    \"\"\"\n    Returns the number of numbers below number_limit that produce chains with exactly\n    chain_length non repeating elements.\n\n    >>> solution(10.0, 1000)\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameters chain_length and number_limit must be int\n\n    >>> solution(10, 1000.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameters chain_length and number_limit must be int\n\n    >>> solution(0, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameters chain_length and number_limit must be greater than 0\n\n    >>> solution(10, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameters chain_length and number_limit must be greater than 0\n\n    >>> solution(10, 1000)\n    26\n    \"\"\"\n\n    if not isinstance(chain_length, int) or not isinstance(number_limit, int):\n        raise TypeError(\"Parameters chain_length and number_limit must be int\")\n\n    if chain_length <= 0 or number_limit <= 0:\n        raise ValueError(\n            \"Parameters chain_length and number_limit must be greater than 0\"\n        )\n\n    # the counter for the chains with the exact desired length\n    chains_counter = 0\n    # the cached sizes of the previous chains\n    chain_sets_lengths: dict[int, int] = {}\n\n    for start_chain_element in range(1, number_limit):\n        # The temporary set will contain the elements of the chain\n        chain_set = set()\n        chain_set_length = 0\n\n        # Stop computing the chain when you find a cached size, a repeating item or the\n        # length is greater then the desired one.\n        chain_element = start_chain_element\n        while (\n            chain_element not in chain_sets_lengths\n            and chain_element not in chain_set\n            and chain_set_length <= chain_length\n        ):\n            chain_set.add(chain_element)\n            chain_set_length += 1\n            chain_element = digit_factorial_sum(chain_element)\n\n        if chain_element in chain_sets_lengths:\n            chain_set_length += chain_sets_lengths[chain_element]\n\n        chain_sets_lengths[start_chain_element] = chain_set_length\n\n        # If chain contains the exact amount of elements increase the counter\n        if chain_set_length == chain_length:\n            chains_counter += 1\n\n    return chains_counter",
    "docstring": "Returns the number of numbers below number_limit that produce chains with exactly\nchain_length non repeating elements.\n\n>>> solution(10.0, 1000)\nTraceback (most recent call last):\n    ...\nTypeError: Parameters chain_length and number_limit must be int\n\n>>> solution(10, 1000.0)\nTraceback (most recent call last):\n    ...\nTypeError: Parameters chain_length and number_limit must be int\n\n>>> solution(0, 1000)\nTraceback (most recent call last):\n    ...\nValueError: Parameters chain_length and number_limit must be greater than 0\n\n>>> solution(10, 0)\nTraceback (most recent call last):\n    ...\nValueError: Parameters chain_length and number_limit must be greater than 0\n\n>>> solution(10, 1000)\n26"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 1500000) -> int:\n    \"\"\"\n    Return the number of values of L <= limit such that a wire of length L can be\n    formmed into an integer sided right angle triangle in exactly one way.\n    >>> solution(50)\n    6\n    >>> solution(1000)\n    112\n    >>> solution(50000)\n    5502\n    \"\"\"\n    frequencies: defaultdict = defaultdict(int)\n    euclid_m = 2\n    while 2 * euclid_m * (euclid_m + 1) <= limit:\n        for euclid_n in range((euclid_m % 2) + 1, euclid_m, 2):\n            if gcd(euclid_m, euclid_n) > 1:\n                continue\n            primitive_perimeter = 2 * euclid_m * (euclid_m + euclid_n)\n            for perimeter in range(primitive_perimeter, limit + 1, primitive_perimeter):\n                frequencies[perimeter] += 1\n        euclid_m += 1\n    return sum(1 for frequency in frequencies.values() if frequency == 1)",
    "docstring": "Return the number of values of L <= limit such that a wire of length L can be\nformmed into an integer sided right angle triangle in exactly one way.\n>>> solution(50)\n6\n>>> solution(1000)\n112\n>>> solution(50000)\n5502"
  },
  {
    "function": "solution",
    "code": "def solution(m: int = 100) -> int:\n    \"\"\"\n    Returns the number of different ways the number m can be written as a\n    sum of at least two positive integers.\n\n    >>> solution(100)\n    190569291\n    >>> solution(50)\n    204225\n    >>> solution(30)\n    5603\n    >>> solution(10)\n    41\n    >>> solution(5)\n    6\n    >>> solution(3)\n    2\n    >>> solution(2)\n    1\n    >>> solution(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1",
    "docstring": "Returns the number of different ways the number m can be written as a\nsum of at least two positive integers.\n\n>>> solution(100)\n190569291\n>>> solution(50)\n204225\n>>> solution(30)\n5603\n>>> solution(10)\n41\n>>> solution(5)\n6\n>>> solution(3)\n2\n>>> solution(2)\n1\n>>> solution(1)\n0"
  },
  {
    "function": "partition",
    "code": "def partition(number_to_partition: int) -> set[int]:\n    \"\"\"\n    Return a set of integers corresponding to unique prime partitions of n.\n    The unique prime partitions can be represented as unique prime decompositions,\n    e.g. (7+3) <-> 7*3 = 12, (3+3+2+2) = 3*3*2*2 = 36\n    >>> partition(10)\n    {32, 36, 21, 25, 30}\n    >>> partition(15)\n    {192, 160, 105, 44, 112, 243, 180, 150, 216, 26, 125, 126}\n    >>> len(partition(20))\n    26\n    \"\"\"\n    if number_to_partition < 0:\n        return set()\n    elif number_to_partition == 0:\n        return {1}\n\n    ret: set[int] = set()\n    prime: int\n    sub: int\n\n    for prime in primes:\n        if prime > number_to_partition:\n            continue\n        for sub in partition(number_to_partition - prime):\n            ret.add(sub * prime)\n\n    return ret",
    "docstring": "Return a set of integers corresponding to unique prime partitions of n.\nThe unique prime partitions can be represented as unique prime decompositions,\ne.g. (7+3) <-> 7*3 = 12, (3+3+2+2) = 3*3*2*2 = 36\n>>> partition(10)\n{32, 36, 21, 25, 30}\n>>> partition(15)\n{192, 160, 105, 44, 112, 243, 180, 150, 216, 26, 125, 126}\n>>> len(partition(20))\n26"
  },
  {
    "function": "solution",
    "code": "def solution(number_unique_partitions: int = 5000) -> int | None:\n    \"\"\"\n    Return the smallest integer that can be written as the sum of primes in over\n    m unique ways.\n    >>> solution(4)\n    10\n    >>> solution(500)\n    45\n    >>> solution(1000)\n    53\n    \"\"\"\n    for number_to_partition in range(1, NUM_PRIMES):\n        if len(partition(number_to_partition)) > number_unique_partitions:\n            return number_to_partition\n    return None",
    "docstring": "Return the smallest integer that can be written as the sum of primes in over\nm unique ways.\n>>> solution(4)\n10\n>>> solution(500)\n45\n>>> solution(1000)\n53"
  },
  {
    "function": "solution",
    "code": "def solution(number: int = 1000000) -> int:\n    \"\"\"\n    >>> solution(1)\n    1\n\n    >>> solution(9)\n    14\n\n    >>> solution()\n    55374\n    \"\"\"\n    partitions = [1]\n\n    for i in itertools.count(len(partitions)):\n        item = 0\n        for j in itertools.count(1):\n            sign = -1 if j % 2 == 0 else +1\n            index = (j * j * 3 - j) // 2\n            if index > i:\n                break\n            item += partitions[i - index] * sign\n            item %= number\n            index += j\n            if index > i:\n                break\n            item += partitions[i - index] * sign\n            item %= number\n\n        if item == 0:\n            return i\n        partitions.append(item)\n\n    return 0",
    "docstring": ">>> solution(1)\n1\n\n>>> solution(9)\n14\n\n>>> solution()\n55374"
  },
  {
    "function": "find_secret_passcode",
    "code": "def find_secret_passcode(logins: list[str]) -> int:\n    \"\"\"\n    Returns the shortest possible secret passcode of unknown length.\n\n    >>> find_secret_passcode([\"135\", \"259\", \"235\", \"189\", \"690\", \"168\", \"120\",\n    ...     \"136\", \"289\", \"589\", \"160\", \"165\", \"580\", \"369\", \"250\", \"280\"])\n    12365890\n\n    >>> find_secret_passcode([\"426\", \"281\", \"061\", \"819\" \"268\", \"406\", \"420\",\n    ...     \"428\", \"209\", \"689\", \"019\", \"421\", \"469\", \"261\", \"681\", \"201\"])\n    4206819\n    \"\"\"\n\n    # Split each login by character e.g. '319' -> ('3', '1', '9')\n    split_logins = [tuple(login) for login in logins]\n\n    unique_chars = {char for login in split_logins for char in login}\n\n    for permutation in itertools.permutations(unique_chars):\n        satisfied = True\n        for login in logins:\n            if not (\n                permutation.index(login[0])\n                < permutation.index(login[1])\n                < permutation.index(login[2])\n            ):\n                satisfied = False\n                break\n\n        if satisfied:\n            return int(\"\".join(permutation))\n\n    raise Exception(\"Unable to find the secret passcode\")",
    "docstring": "Returns the shortest possible secret passcode of unknown length.\n\n>>> find_secret_passcode([\"135\", \"259\", \"235\", \"189\", \"690\", \"168\", \"120\",\n...     \"136\", \"289\", \"589\", \"160\", \"165\", \"580\", \"369\", \"250\", \"280\"])\n12365890\n\n>>> find_secret_passcode([\"426\", \"281\", \"061\", \"819\" \"268\", \"406\", \"420\",\n...     \"428\", \"209\", \"689\", \"019\", \"421\", \"469\", \"261\", \"681\", \"201\"])\n4206819"
  },
  {
    "function": "solution",
    "code": "def solution(input_file: str = \"keylog.txt\") -> int:\n    \"\"\"\n    Returns the shortest possible secret passcode of unknown length\n    for successful login attempts given by `input_file` text file.\n\n    >>> solution(\"keylog_test.txt\")\n    6312980\n    \"\"\"\n    logins = Path(__file__).parent.joinpath(input_file).read_text().splitlines()\n\n    return find_secret_passcode(logins)",
    "docstring": "Returns the shortest possible secret passcode of unknown length\nfor successful login attempts given by `input_file` text file.\n\n>>> solution(\"keylog_test.txt\")\n6312980"
  },
  {
    "function": "solution",
    "code": "def solution() -> int:\n    \"\"\"\n    To evaluate the sum, Used decimal python module to calculate the decimal\n    places up to 100, the most important thing would be take calculate\n    a few extra places for decimal otherwise there will be rounding\n    error.\n\n    >>> solution()\n    40886\n    \"\"\"\n    answer = 0\n    decimal_context = decimal.Context(prec=105)\n    for i in range(2, 100):\n        number = decimal.Decimal(i)\n        sqrt_number = number.sqrt(decimal_context)\n        if len(str(sqrt_number)) > 1:\n            answer += int(str(sqrt_number)[0])\n            sqrt_number_str = str(sqrt_number)[2:101]\n            answer += sum(int(x) for x in sqrt_number_str)\n    return answer",
    "docstring": "To evaluate the sum, Used decimal python module to calculate the decimal\nplaces up to 100, the most important thing would be take calculate\na few extra places for decimal otherwise there will be rounding\nerror.\n\n>>> solution()\n40886"
  },
  {
    "function": "solution",
    "code": "def solution(filename: str = \"matrix.txt\") -> int:\n    \"\"\"\n    Returns the minimal path sum from the top left to the bottom right of the matrix.\n    >>> solution()\n    427337\n    \"\"\"\n    with open(os.path.join(os.path.dirname(__file__), filename)) as in_file:\n        data = in_file.read()\n\n    grid = [[int(cell) for cell in row.split(\",\")] for row in data.strip().splitlines()]\n    dp = [[0 for cell in row] for row in grid]\n    n = len(grid[0])\n\n    dp = [[0 for i in range(n)] for j in range(n)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, n):\n        dp[0][i] = grid[0][i] + dp[0][i - 1]\n    for i in range(1, n):\n        dp[i][0] = grid[i][0] + dp[i - 1][0]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]",
    "docstring": "Returns the minimal path sum from the top left to the bottom right of the matrix.\n>>> solution()\n427337"
  },
  {
    "function": "solution",
    "code": "def solution(filename: str = \"input.txt\") -> int:\n    \"\"\"\n    Returns the minimal path sum in the matrix from the file, by starting in any cell\n    in the left column and finishing in any cell in the right column,\n    and only moving up, down, and right\n\n    >>> solution(\"test_matrix.txt\")\n    994\n    \"\"\"\n\n    with open(os.path.join(os.path.dirname(__file__), filename)) as input_file:\n        matrix = [\n            [int(element) for element in line.split(\",\")]\n            for line in input_file.readlines()\n        ]\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    minimal_path_sums = [[-1 for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        minimal_path_sums[i][0] = matrix[i][0]\n\n    for j in range(1, cols):\n        for i in range(rows):\n            minimal_path_sums[i][j] = minimal_path_sums[i][j - 1] + matrix[i][j]\n\n        for i in range(1, rows):\n            minimal_path_sums[i][j] = min(\n                minimal_path_sums[i][j], minimal_path_sums[i - 1][j] + matrix[i][j]\n            )\n\n        for i in range(rows - 2, -1, -1):\n            minimal_path_sums[i][j] = min(\n                minimal_path_sums[i][j], minimal_path_sums[i + 1][j] + matrix[i][j]\n            )\n\n    return min(minimal_path_sums_row[-1] for minimal_path_sums_row in minimal_path_sums)",
    "docstring": "Returns the minimal path sum in the matrix from the file, by starting in any cell\nin the left column and finishing in any cell in the right column,\nand only moving up, down, and right\n\n>>> solution(\"test_matrix.txt\")\n994"
  },
  {
    "function": "solution",
    "code": "def solution(target: int = 2000000) -> int:\n    \"\"\"\n    Find the area of the grid which contains as close to two million rectangles\n    as possible.\n    >>> solution(20)\n    6\n    >>> solution(2000)\n    72\n    >>> solution(2000000000)\n    86595\n    \"\"\"\n    triangle_numbers: list[int] = [0]\n    idx: int\n\n    for idx in range(1, ceil(sqrt(target * 2) * 1.1)):\n        triangle_numbers.append(triangle_numbers[-1] + idx)\n\n    # we want this to be as close as possible to target\n    best_product: int = 0\n    # the area corresponding to the grid that gives the product closest to target\n    area: int = 0\n    # an estimate of b, using the quadratic formula\n    b_estimate: float\n    # the largest integer less than b_estimate\n    b_floor: int\n    # the largest integer less than b_estimate\n    b_ceil: int\n    # the triangle number corresponding to b_floor\n    triangle_b_first_guess: int\n    # the triangle number corresponding to b_ceil\n    triangle_b_second_guess: int\n\n    for idx_a, triangle_a in enumerate(triangle_numbers[1:], 1):\n        b_estimate = (-1 + sqrt(1 + 8 * target / triangle_a)) / 2\n        b_floor = floor(b_estimate)\n        b_ceil = ceil(b_estimate)\n        triangle_b_first_guess = triangle_numbers[b_floor]\n        triangle_b_second_guess = triangle_numbers[b_ceil]\n\n        if abs(target - triangle_b_first_guess * triangle_a) < abs(\n            target - best_product\n        ):\n            best_product = triangle_b_first_guess * triangle_a\n            area = idx_a * b_floor\n\n        if abs(target - triangle_b_second_guess * triangle_a) < abs(\n            target - best_product\n        ):\n            best_product = triangle_b_second_guess * triangle_a\n            area = idx_a * b_ceil\n\n    return area",
    "docstring": "Find the area of the grid which contains as close to two million rectangles\nas possible.\n>>> solution(20)\n6\n>>> solution(2000)\n72\n>>> solution(2000000000)\n86595"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 1000000) -> int:\n    \"\"\"\n    Return the least value of M such that there are more than one million cuboids\n    of side lengths 1 <= a,b,c <= M such that the shortest distance between two\n    opposite vertices of the cuboid is integral.\n    >>> solution(100)\n    24\n    >>> solution(1000)\n    72\n    >>> solution(2000)\n    100\n    >>> solution(20000)\n    288\n    \"\"\"\n    num_cuboids: int = 0\n    max_cuboid_size: int = 0\n    sum_shortest_sides: int\n\n    while num_cuboids <= limit:\n        max_cuboid_size += 1\n        for sum_shortest_sides in range(2, 2 * max_cuboid_size + 1):\n            if sqrt(sum_shortest_sides**2 + max_cuboid_size**2).is_integer():\n                num_cuboids += (\n                    min(max_cuboid_size, sum_shortest_sides // 2)\n                    - max(1, sum_shortest_sides - max_cuboid_size)\n                    + 1\n                )\n\n    return max_cuboid_size",
    "docstring": "Return the least value of M such that there are more than one million cuboids\nof side lengths 1 <= a,b,c <= M such that the shortest distance between two\nopposite vertices of the cuboid is integral.\n>>> solution(100)\n24\n>>> solution(1000)\n72\n>>> solution(2000)\n100\n>>> solution(20000)\n288"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 50000000) -> int:\n    \"\"\"\n    Return the number of integers less than limit which can be expressed as the sum\n    of a prime square, prime cube, and prime fourth power.\n    >>> solution(50)\n    4\n    \"\"\"\n    ret = set()\n    prime_square_limit = int((limit - 24) ** (1 / 2))\n\n    primes = set(range(3, prime_square_limit + 1, 2))\n    primes.add(2)\n    for p in range(3, prime_square_limit + 1, 2):\n        if p not in primes:\n            continue\n        primes.difference_update(set(range(p * p, prime_square_limit + 1, p)))\n\n    for prime1 in primes:\n        square = prime1 * prime1\n        for prime2 in primes:\n            cube = prime2 * prime2 * prime2\n            if square + cube >= limit - 16:\n                break\n            for prime3 in primes:\n                tetr = prime3 * prime3 * prime3 * prime3\n                total = square + cube + tetr\n                if total >= limit:\n                    break\n                ret.add(total)\n\n    return len(ret)",
    "docstring": "Return the number of integers less than limit which can be expressed as the sum\nof a prime square, prime cube, and prime fourth power.\n>>> solution(50)\n4"
  },
  {
    "function": "parse_roman_numerals",
    "code": "def parse_roman_numerals(numerals: str) -> int:\n    \"\"\"\n    Converts a string of roman numerals to an integer.\n    e.g.\n    >>> parse_roman_numerals(\"LXXXIX\")\n    89\n    >>> parse_roman_numerals(\"IIII\")\n    4\n    \"\"\"\n\n    total_value = 0\n\n    index = 0\n    while index < len(numerals) - 1:\n        current_value = SYMBOLS[numerals[index]]\n        next_value = SYMBOLS[numerals[index + 1]]\n        if current_value < next_value:\n            total_value -= current_value\n        else:\n            total_value += current_value\n        index += 1\n    total_value += SYMBOLS[numerals[index]]\n\n    return total_value",
    "docstring": "Converts a string of roman numerals to an integer.\ne.g.\n>>> parse_roman_numerals(\"LXXXIX\")\n89\n>>> parse_roman_numerals(\"IIII\")\n4"
  },
  {
    "function": "generate_roman_numerals",
    "code": "def generate_roman_numerals(num: int) -> str:\n    \"\"\"\n    Generates a string of roman numerals for a given integer.\n    e.g.\n    >>> generate_roman_numerals(89)\n    'LXXXIX'\n    >>> generate_roman_numerals(4)\n    'IV'\n    \"\"\"\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals",
    "docstring": "Generates a string of roman numerals for a given integer.\ne.g.\n>>> generate_roman_numerals(89)\n'LXXXIX'\n>>> generate_roman_numerals(4)\n'IV'"
  },
  {
    "function": "solution",
    "code": "def solution(roman_numerals_filename: str = \"/p089_roman.txt\") -> int:\n    \"\"\"\n    Calculates and returns the answer to project euler problem 89.\n\n    >>> solution(\"/numeralcleanup_test.txt\")\n    16\n    \"\"\"\n\n    savings = 0\n\n    with open(os.path.dirname(__file__) + roman_numerals_filename) as file1:\n        lines = file1.readlines()\n\n    for line in lines:\n        original = line.strip()\n        num = parse_roman_numerals(original)\n        shortened = generate_roman_numerals(num)\n        savings += len(original) - len(shortened)\n\n    return savings",
    "docstring": "Calculates and returns the answer to project euler problem 89.\n\n>>> solution(\"/numeralcleanup_test.txt\")\n16"
  },
  {
    "function": "is_right",
    "code": "def is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n    Note: this doesn't check if P and Q are equal, but that's handled by the use of\n    itertools.combinations in the solution function.\n\n    >>> is_right(0, 1, 2, 0)\n    True\n    >>> is_right(1, 0, 2, 2)\n    False\n    \"\"\"\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )",
    "docstring": "Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\nNote: this doesn't check if P and Q are equal, but that's handled by the use of\nitertools.combinations in the solution function.\n\n>>> is_right(0, 1, 2, 0)\nTrue\n>>> is_right(1, 0, 2, 2)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 50) -> int:\n    \"\"\"\n    Return the number of right triangles OPQ that can be formed by two points P, Q\n    which have both x- and y- coordinates between 0 and limit inclusive.\n\n    >>> solution(2)\n    14\n    >>> solution(10)\n    448\n    \"\"\"\n    return sum(\n        1\n        for pt1, pt2 in combinations(product(range(limit + 1), repeat=2), 2)\n        if is_right(*pt1, *pt2)\n    )",
    "docstring": "Return the number of right triangles OPQ that can be formed by two points P, Q\nwhich have both x- and y- coordinates between 0 and limit inclusive.\n\n>>> solution(2)\n14\n>>> solution(10)\n448"
  },
  {
    "function": "next_number",
    "code": "def next_number(number: int) -> int:\n    \"\"\"\n    Returns the next number of the chain by adding the square of each digit\n    to form a new number.\n    For example, if number = 12, next_number() will return 1^2 + 2^2 = 5.\n    Therefore, 5 is the next number of the chain.\n    >>> next_number(44)\n    32\n    >>> next_number(10)\n    1\n    >>> next_number(32)\n    13\n    \"\"\"\n\n    sum_of_digits_squared = 0\n    while number:\n        # Increased Speed Slightly by checking every 5 digits together.\n        sum_of_digits_squared += DIGITS_SQUARED[number % 100000]\n        number //= 100000\n\n    return sum_of_digits_squared",
    "docstring": "Returns the next number of the chain by adding the square of each digit\nto form a new number.\nFor example, if number = 12, next_number() will return 1^2 + 2^2 = 5.\nTherefore, 5 is the next number of the chain.\n>>> next_number(44)\n32\n>>> next_number(10)\n1\n>>> next_number(32)\n13"
  },
  {
    "function": "chain",
    "code": "def chain(number: int) -> bool:\n    \"\"\"\n    The function generates the chain of numbers until the next number is 1 or 89.\n    For example, if starting number is 44, then the function generates the\n    following chain of numbers:\n    44 \u2192 32 \u2192 13 \u2192 10 \u2192 1 \u2192 1.\n    Once the next number generated is 1 or 89, the function returns whether\n    or not the next number generated by next_number() is 1.\n    >>> chain(10)\n    True\n    >>> chain(58)\n    False\n    >>> chain(1)\n    True\n    \"\"\"\n\n    if CHAINS[number - 1] is not None:\n        return CHAINS[number - 1]  # type: ignore[return-value]\n\n    number_chain = chain(next_number(number))\n    CHAINS[number - 1] = number_chain\n\n    while number < 10000000:\n        CHAINS[number - 1] = number_chain\n        number *= 10\n\n    return number_chain",
    "docstring": "The function generates the chain of numbers until the next number is 1 or 89.\nFor example, if starting number is 44, then the function generates the\nfollowing chain of numbers:\n44 \u2192 32 \u2192 13 \u2192 10 \u2192 1 \u2192 1.\nOnce the next number generated is 1 or 89, the function returns whether\nor not the next number generated by next_number() is 1.\n>>> chain(10)\nTrue\n>>> chain(58)\nFalse\n>>> chain(1)\nTrue"
  },
  {
    "function": "solution",
    "code": "def solution(number: int = 10000000) -> int:\n    \"\"\"\n    The function returns the number of integers that end up being 89 in each chain.\n    The function accepts a range number and the function checks all the values\n    under value number.\n\n    >>> solution(100)\n    80\n    >>> solution(10000000)\n    8581146\n    \"\"\"\n    for i in range(1, number):\n        if CHAINS[i] is None:\n            chain(i + 1)\n\n    return CHAINS[:number].count(False)",
    "docstring": "The function returns the number of integers that end up being 89 in each chain.\nThe function accepts a range number and the function checks all the values\nunder value number.\n\n>>> solution(100)\n80\n>>> solution(10000000)\n8581146"
  },
  {
    "function": "solution",
    "code": "def solution(max_perimeter: int = 10**9) -> int:\n    \"\"\"\n    Returns the sum of the perimeters of all almost equilateral triangles with integral\n    side lengths and area and whose perimeters do not exceed max_perimeter\n\n    >>> solution(20)\n    16\n    \"\"\"\n\n    prev_value = 1\n    value = 2\n\n    perimeters_sum = 0\n    i = 0\n    perimeter = 0\n    while perimeter <= max_perimeter:\n        perimeters_sum += perimeter\n\n        prev_value += 2 * value\n        value += prev_value\n\n        perimeter = 2 * value + 2 if i % 2 == 0 else 2 * value - 2\n        i += 1\n\n    return perimeters_sum",
    "docstring": "Returns the sum of the perimeters of all almost equilateral triangles with integral\nside lengths and area and whose perimeters do not exceed max_perimeter\n\n>>> solution(20)\n16"
  },
  {
    "function": "generate_primes",
    "code": "def generate_primes(max_num: int) -> list[int]:\n    \"\"\"\n    Calculates the list of primes up to and including `max_num`.\n\n    >>> generate_primes(6)\n    [2, 3, 5]\n    \"\"\"\n    are_primes = [True] * (max_num + 1)\n    are_primes[0] = are_primes[1] = False\n    for i in range(2, isqrt(max_num) + 1):\n        if are_primes[i]:\n            for j in range(i * i, max_num + 1, i):\n                are_primes[j] = False\n\n    return [prime for prime, is_prime in enumerate(are_primes) if is_prime]",
    "docstring": "Calculates the list of primes up to and including `max_num`.\n\n>>> generate_primes(6)\n[2, 3, 5]"
  },
  {
    "function": "multiply",
    "code": "def multiply(\n    chain: list[int],\n    primes: list[int],\n    min_prime_idx: int,\n    prev_num: int,\n    max_num: int,\n    prev_sum: int,\n    primes_degrees: dict[int, int],\n) -> None:\n    \"\"\"\n    Run over all prime combinations to generate non-prime numbers.\n\n    >>> chain = [0] * 3\n    >>> primes_degrees = {}\n    >>> multiply(\n    ...     chain=chain,\n    ...     primes=[2],\n    ...     min_prime_idx=0,\n    ...     prev_num=1,\n    ...     max_num=2,\n    ...     prev_sum=0,\n    ...     primes_degrees=primes_degrees,\n    ... )\n    >>> chain\n    [0, 0, 1]\n    >>> primes_degrees\n    {2: 1}\n    \"\"\"\n\n    min_prime = primes[min_prime_idx]\n    num = prev_num * min_prime\n\n    min_prime_degree = primes_degrees.get(min_prime, 0)\n    min_prime_degree += 1\n    primes_degrees[min_prime] = min_prime_degree\n\n    new_sum = prev_sum * min_prime + (prev_sum + prev_num) * (min_prime - 1) // (\n        min_prime**min_prime_degree - 1\n    )\n    chain[num] = new_sum\n\n    for prime_idx in range(min_prime_idx, len(primes)):\n        if primes[prime_idx] * num > max_num:\n            break\n\n        multiply(\n            chain=chain,\n            primes=primes,\n            min_prime_idx=prime_idx,\n            prev_num=num,\n            max_num=max_num,\n            prev_sum=new_sum,\n            primes_degrees=primes_degrees.copy(),\n        )",
    "docstring": "Run over all prime combinations to generate non-prime numbers.\n\n>>> chain = [0] * 3\n>>> primes_degrees = {}\n>>> multiply(\n...     chain=chain,\n...     primes=[2],\n...     min_prime_idx=0,\n...     prev_num=1,\n...     max_num=2,\n...     prev_sum=0,\n...     primes_degrees=primes_degrees,\n... )\n>>> chain\n[0, 0, 1]\n>>> primes_degrees\n{2: 1}"
  },
  {
    "function": "find_longest_chain",
    "code": "def find_longest_chain(chain: list[int], max_num: int) -> int:\n    \"\"\"\n    Finds the smallest element of longest chain\n\n    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n    6\n    \"\"\"\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem",
    "docstring": "Finds the smallest element of longest chain\n\n>>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n6"
  },
  {
    "function": "solution",
    "code": "def solution(max_num: int = 1000000) -> int:\n    \"\"\"\n    Runs the calculation for numbers <= `max_num`.\n\n    >>> solution(10)\n    6\n    >>> solution(200000)\n    12496\n    \"\"\"\n\n    primes = generate_primes(max_num)\n    chain = [0] * (max_num + 1)\n    for prime_idx, prime in enumerate(primes):\n        if prime**2 > max_num:\n            break\n\n        multiply(\n            chain=chain,\n            primes=primes,\n            min_prime_idx=prime_idx,\n            prev_num=1,\n            max_num=max_num,\n            prev_sum=0,\n            primes_degrees={},\n        )\n\n    return find_longest_chain(chain=chain, max_num=max_num)",
    "docstring": "Runs the calculation for numbers <= `max_num`.\n\n>>> solution(10)\n6\n>>> solution(200000)\n12496"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 10) -> str:\n    \"\"\"\n    Returns the last n digits of NUMBER.\n    >>> solution()\n    '8739992577'\n    >>> solution(8)\n    '39992577'\n    >>> solution(1)\n    '7'\n    >>> solution(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    >>> solution(8.3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    >>> solution(\"a\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Invalid input\")\n    modulus = 10**n\n    number = 28433 * (pow(2, 7830457, modulus)) + 1\n    return str(number % modulus)",
    "docstring": "Returns the last n digits of NUMBER.\n>>> solution()\n'8739992577'\n>>> solution(8)\n'39992577'\n>>> solution(1)\n'7'\n>>> solution(-1)\nTraceback (most recent call last):\n    ...\nValueError: Invalid input\n>>> solution(8.3)\nTraceback (most recent call last):\n    ...\nValueError: Invalid input\n>>> solution(\"a\")\nTraceback (most recent call last):\n    ...\nValueError: Invalid input"
  },
  {
    "function": "solution",
    "code": "def solution(data_file: str = \"base_exp.txt\") -> int:\n    \"\"\"\n    >>> solution()\n    709\n    \"\"\"\n    largest: float = 0\n    result = 0\n    for i, line in enumerate(open(os.path.join(os.path.dirname(__file__), data_file))):\n        a, x = list(map(int, line.split(\",\")))\n        if x * log10(a) > largest:\n            largest = x * log10(a)\n            result = i + 1\n    return result",
    "docstring": ">>> solution()\n709"
  },
  {
    "function": "solution",
    "code": "def solution(min_total: int = 10**12) -> int:\n    \"\"\"\n    Returns the number of blue discs for the first arrangement to contain\n    over min_total discs in total\n\n    >>> solution(2)\n    3\n\n    >>> solution(4)\n    15\n\n    >>> solution(21)\n    85\n    \"\"\"\n\n    prev_numerator = 1\n    prev_denominator = 0\n\n    numerator = 1\n    denominator = 1\n\n    while numerator <= 2 * min_total - 1:\n        prev_numerator += 2 * numerator\n        numerator += 2 * prev_numerator\n\n        prev_denominator += 2 * denominator\n        denominator += 2 * prev_denominator\n\n    return (denominator + 1) // 2",
    "docstring": "Returns the number of blue discs for the first arrangement to contain\nover min_total discs in total\n\n>>> solution(2)\n3\n\n>>> solution(4)\n15\n\n>>> solution(21)\n85"
  },
  {
    "function": "solve",
    "code": "def solve(matrix: Matrix, vector: Matrix) -> Matrix:\n    \"\"\"\n    Solve the linear system of equations Ax = b (A = \"matrix\", b = \"vector\")\n    for x using Gaussian elimination and back substitution. We assume that A\n    is an invertible square matrix and that b is a column vector of the\n    same height.\n    >>> solve([[1, 0], [0, 1]], [[1],[2]])\n    [[1.0], [2.0]]\n    >>> solve([[2, 1, -1],[-3, -1, 2],[-2, 1, 2]],[[8], [-11],[-3]])\n    [[2.0], [3.0], [-1.0]]\n    \"\"\"\n    size: int = len(matrix)\n    augmented: Matrix = [[0 for _ in range(size + 1)] for _ in range(size)]\n    row: int\n    row2: int\n    col: int\n    col2: int\n    pivot_row: int\n    ratio: float\n\n    for row in range(size):\n        for col in range(size):\n            augmented[row][col] = matrix[row][col]\n\n        augmented[row][size] = vector[row][0]\n\n    row = 0\n    col = 0\n    while row < size and col < size:\n        # pivoting\n        pivot_row = max((abs(augmented[row2][col]), row2) for row2 in range(col, size))[\n            1\n        ]\n        if augmented[pivot_row][col] == 0:\n            col += 1\n            continue\n        else:\n            augmented[row], augmented[pivot_row] = augmented[pivot_row], augmented[row]\n\n        for row2 in range(row + 1, size):\n            ratio = augmented[row2][col] / augmented[row][col]\n            augmented[row2][col] = 0\n            for col2 in range(col + 1, size + 1):\n                augmented[row2][col2] -= augmented[row][col2] * ratio\n\n        row += 1\n        col += 1\n\n    # back substitution\n    for col in range(1, size):\n        for row in range(col):\n            ratio = augmented[row][col] / augmented[col][col]\n            for col2 in range(col, size + 1):\n                augmented[row][col2] -= augmented[col][col2] * ratio\n\n    # round to get rid of numbers like 2.000000000000004\n    return [\n        [round(augmented[row][size] / augmented[row][row], 10)] for row in range(size)\n    ]",
    "docstring": "Solve the linear system of equations Ax = b (A = \"matrix\", b = \"vector\")\nfor x using Gaussian elimination and back substitution. We assume that A\nis an invertible square matrix and that b is a column vector of the\nsame height.\n>>> solve([[1, 0], [0, 1]], [[1],[2]])\n[[1.0], [2.0]]\n>>> solve([[2, 1, -1],[-3, -1, 2],[-2, 1, 2]],[[8], [-11],[-3]])\n[[2.0], [3.0], [-1.0]]"
  },
  {
    "function": "interpolate",
    "code": "def interpolate(y_list: list[int]) -> Callable[[int], int]:\n    \"\"\"\n    Given a list of data points (1,y0),(2,y1), ..., return a function that\n    interpolates the data points. We find the coefficients of the interpolating\n    polynomial by solving a system of linear equations corresponding to\n    x = 1, 2, 3...\n\n    >>> interpolate([1])(3)\n    1\n    >>> interpolate([1, 8])(3)\n    15\n    >>> interpolate([1, 8, 27])(4)\n    58\n    >>> interpolate([1, 8, 27, 64])(6)\n    216\n    \"\"\"\n\n    size: int = len(y_list)\n    matrix: Matrix = [[0 for _ in range(size)] for _ in range(size)]\n    vector: Matrix = [[0] for _ in range(size)]\n    coeffs: Matrix\n    x_val: int\n    y_val: int\n    col: int\n\n    for x_val, y_val in enumerate(y_list):\n        for col in range(size):\n            matrix[x_val][col] = (x_val + 1) ** (size - col - 1)\n        vector[x_val][0] = y_val\n\n    coeffs = solve(matrix, vector)\n\n    def interpolated_func(var: int) -> int:\n        \"\"\"\n        >>> interpolate([1])(3)\n        1\n        >>> interpolate([1, 8])(3)\n        15\n        >>> interpolate([1, 8, 27])(4)\n        58\n        >>> interpolate([1, 8, 27, 64])(6)\n        216\n        \"\"\"\n        return sum(\n            round(coeffs[x_val][0]) * (var ** (size - x_val - 1))\n            for x_val in range(size)\n        )\n\n    return interpolated_func",
    "docstring": "Given a list of data points (1,y0),(2,y1), ..., return a function that\ninterpolates the data points. We find the coefficients of the interpolating\npolynomial by solving a system of linear equations corresponding to\nx = 1, 2, 3...\n\n>>> interpolate([1])(3)\n1\n>>> interpolate([1, 8])(3)\n15\n>>> interpolate([1, 8, 27])(4)\n58\n>>> interpolate([1, 8, 27, 64])(6)\n216"
  },
  {
    "function": "question_function",
    "code": "def question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )",
    "docstring": "The generating function u as specified in the question.\n>>> question_function(0)\n1\n>>> question_function(1)\n1\n>>> question_function(5)\n8138021\n>>> question_function(10)\n9090909091"
  },
  {
    "function": "solution",
    "code": "def solution(func: Callable[[int], int] = question_function, order: int = 10) -> int:\n    \"\"\"\n    Find the sum of the FITs of the BOPS. For each interpolating polynomial of order\n    1, 2, ... , 10, find the first x such that the value of the polynomial at x does\n    not equal u(x).\n    >>> solution(lambda n: n ** 3, 3)\n    74\n    \"\"\"\n    data_points: list[int] = [func(x_val) for x_val in range(1, order + 1)]\n\n    polynomials: list[Callable[[int], int]] = [\n        interpolate(data_points[:max_coeff]) for max_coeff in range(1, order + 1)\n    ]\n\n    ret: int = 0\n    poly: Callable[[int], int]\n    x_val: int\n\n    for poly in polynomials:\n        x_val = 1\n        while func(x_val) == poly(x_val):\n            x_val += 1\n\n        ret += poly(x_val)\n\n    return ret",
    "docstring": "Find the sum of the FITs of the BOPS. For each interpolating polynomial of order\n1, 2, ... , 10, find the first x such that the value of the polynomial at x does\nnot equal u(x).\n>>> solution(lambda n: n ** 3, 3)\n74"
  },
  {
    "function": "vector_product",
    "code": "def vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]",
    "docstring": "Return the 2-d vector product of two vectors.\n>>> vector_product((1, 2), (-5, 0))\n10\n>>> vector_product((3, 1), (6, 10))\n24"
  },
  {
    "function": "contains_origin",
    "code": "def contains_origin(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> bool:\n    \"\"\"\n    Check if the triangle given by the points A(x1, y1), B(x2, y2), C(x3, y3)\n    contains the origin.\n    >>> contains_origin(-340, 495, -153, -910, 835, -947)\n    True\n    >>> contains_origin(-175, 41, -421, -714, 574, -645)\n    False\n    \"\"\"\n    point_a: tuple[int, int] = (x1, y1)\n    point_a_to_b: tuple[int, int] = (x2 - x1, y2 - y1)\n    point_a_to_c: tuple[int, int] = (x3 - x1, y3 - y1)\n    a: float = -vector_product(point_a, point_a_to_b) / vector_product(\n        point_a_to_c, point_a_to_b\n    )\n    b: float = +vector_product(point_a, point_a_to_c) / vector_product(\n        point_a_to_c, point_a_to_b\n    )\n\n    return a > 0 and b > 0 and a + b < 1",
    "docstring": "Check if the triangle given by the points A(x1, y1), B(x2, y2), C(x3, y3)\ncontains the origin.\n>>> contains_origin(-340, 495, -153, -910, 835, -947)\nTrue\n>>> contains_origin(-175, 41, -421, -714, 574, -645)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(filename: str = \"p102_triangles.txt\") -> int:\n    \"\"\"\n    Find the number of triangles whose interior contains the origin.\n    >>> solution(\"test_triangles.txt\")\n    1\n    \"\"\"\n    data: str = Path(__file__).parent.joinpath(filename).read_text(encoding=\"utf-8\")\n\n    triangles: list[list[int]] = []\n    for line in data.strip().split(\"\\n\"):\n        triangles.append([int(number) for number in line.split(\",\")])\n\n    ret: int = 0\n    triangle: list[int]\n\n    for triangle in triangles:\n        ret += contains_origin(*triangle)\n\n    return ret",
    "docstring": "Find the number of triangles whose interior contains the origin.\n>>> solution(\"test_triangles.txt\")\n1"
  },
  {
    "function": "check",
    "code": "def check(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital both from start and end\n\n\n    >>> check(123456789987654321)\n    True\n\n    >>> check(120000987654321)\n    False\n\n    >>> check(1234567895765677987654321)\n    True\n\n    \"\"\"\n\n    check_last = [0] * 11\n    check_front = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    if not f:\n        return f\n\n    # mark first 9 numbers\n    number = int(str(number)[:9])\n\n    for _ in range(9):\n        check_front[int(number % 10)] = 1\n        number = number // 10\n\n    # check first 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_front[x + 1]:\n            f = False\n    return f",
    "docstring": "Takes a number and checks if it is pandigital both from start and end\n\n\n>>> check(123456789987654321)\nTrue\n\n>>> check(120000987654321)\nFalse\n\n>>> check(1234567895765677987654321)\nTrue"
  },
  {
    "function": "check1",
    "code": "def check1(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital from END\n\n    >>> check1(123456789987654321)\n    True\n\n    >>> check1(120000987654321)\n    True\n\n    >>> check1(12345678957656779870004321)\n    False\n\n    \"\"\"\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f",
    "docstring": "Takes a number and checks if it is pandigital from END\n\n>>> check1(123456789987654321)\nTrue\n\n>>> check1(120000987654321)\nTrue\n\n>>> check1(12345678957656779870004321)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution() -> int:\n    \"\"\"\n    Outputs the answer is the least Fibonacci number pandigital from both sides.\n    >>> solution()\n    329468\n    \"\"\"\n\n    a = 1\n    b = 1\n    c = 2\n    # temporary Fibonacci numbers\n\n    a1 = 1\n    b1 = 1\n    c1 = 2\n    # temporary Fibonacci numbers mod 1e9\n\n    # mod m=1e9, done for fast optimisation\n    tocheck = [0] * 1000000\n    m = 1000000000\n\n    for x in range(1000000):\n        c1 = (a1 + b1) % m\n        a1 = b1 % m\n        b1 = c1 % m\n        if check1(b1):\n            tocheck[x + 3] = 1\n\n    for x in range(1000000):\n        c = a + b\n        a = b\n        b = c\n        # perform check only if in tocheck\n        if tocheck[x + 3] and check(b):\n            return x + 3  # first 2 already done\n    return -1",
    "docstring": "Outputs the answer is the least Fibonacci number pandigital from both sides.\n>>> solution()\n329468"
  },
  {
    "function": "solution",
    "code": "def solution(filename: str = \"p107_network.txt\") -> int:\n    \"\"\"\n    Find the maximum saving which can be achieved by removing redundant edges\n    whilst ensuring that the network remains connected.\n    >>> solution(\"test_network.txt\")\n    150\n    \"\"\"\n    script_dir: str = os.path.abspath(os.path.dirname(__file__))\n    network_file: str = os.path.join(script_dir, filename)\n    edges: dict[EdgeT, int] = {}\n    data: list[str]\n    edge1: int\n    edge2: int\n\n    with open(network_file) as f:\n        data = f.read().strip().split(\"\\n\")\n\n    adjaceny_matrix = [line.split(\",\") for line in data]\n\n    for edge1 in range(1, len(adjaceny_matrix)):\n        for edge2 in range(edge1):\n            if adjaceny_matrix[edge1][edge2] != \"-\":\n                edges[(edge2, edge1)] = int(adjaceny_matrix[edge1][edge2])\n\n    graph: Graph = Graph(set(range(len(adjaceny_matrix))), edges)\n\n    subgraph: Graph = graph.prims_algorithm()\n\n    initial_total: int = sum(graph.edges.values())\n    optimal_total: int = sum(subgraph.edges.values())\n\n    return initial_total - optimal_total",
    "docstring": "Find the maximum saving which can be achieved by removing redundant edges\nwhilst ensuring that the network remains connected.\n>>> solution(\"test_network.txt\")\n150"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 100) -> int:\n    \"\"\"\n    Count the number of distinct ways a player can checkout with a score\n    less than limit.\n    >>> solution(171)\n    42336\n    >>> solution(50)\n    12577\n    \"\"\"\n    singles: list[int] = [*list(range(1, 21)), 25]\n    doubles: list[int] = [2 * x for x in range(1, 21)] + [50]\n    triples: list[int] = [3 * x for x in range(1, 21)]\n    all_values: list[int] = singles + doubles + triples + [0]\n\n    num_checkouts: int = 0\n    double: int\n    throw1: int\n    throw2: int\n    checkout_total: int\n\n    for double in doubles:\n        for throw1, throw2 in combinations_with_replacement(all_values, 2):\n            checkout_total = double + throw1 + throw2\n            if checkout_total < limit:\n                num_checkouts += 1\n\n    return num_checkouts",
    "docstring": "Count the number of distinct ways a player can checkout with a score\nless than limit.\n>>> solution(171)\n42336\n>>> solution(50)\n12577"
  },
  {
    "function": "check_bouncy",
    "code": "def check_bouncy(n: int) -> bool:\n    \"\"\"\n    Returns True if number is bouncy, False otherwise\n    >>> check_bouncy(6789)\n    False\n    >>> check_bouncy(-12345)\n    False\n    >>> check_bouncy(0)\n    False\n    >>> check_bouncy(6.74)\n    Traceback (most recent call last):\n        ...\n    ValueError: check_bouncy() accepts only integer arguments\n    >>> check_bouncy(132475)\n    True\n    >>> check_bouncy(34)\n    False\n    >>> check_bouncy(341)\n    True\n    >>> check_bouncy(47)\n    False\n    >>> check_bouncy(-12.54)\n    Traceback (most recent call last):\n        ...\n    ValueError: check_bouncy() accepts only integer arguments\n    >>> check_bouncy(-6548)\n    True\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"check_bouncy() accepts only integer arguments\")\n    str_n = str(n)\n    sorted_str_n = \"\".join(sorted(str_n))\n    return str_n not in {sorted_str_n, sorted_str_n[::-1]}",
    "docstring": "Returns True if number is bouncy, False otherwise\n>>> check_bouncy(6789)\nFalse\n>>> check_bouncy(-12345)\nFalse\n>>> check_bouncy(0)\nFalse\n>>> check_bouncy(6.74)\nTraceback (most recent call last):\n    ...\nValueError: check_bouncy() accepts only integer arguments\n>>> check_bouncy(132475)\nTrue\n>>> check_bouncy(34)\nFalse\n>>> check_bouncy(341)\nTrue\n>>> check_bouncy(47)\nFalse\n>>> check_bouncy(-12.54)\nTraceback (most recent call last):\n    ...\nValueError: check_bouncy() accepts only integer arguments\n>>> check_bouncy(-6548)\nTrue"
  },
  {
    "function": "solution",
    "code": "def solution(percent: float = 99) -> int:\n    \"\"\"\n    Returns the least number for which the proportion of bouncy numbers is\n    exactly 'percent'\n    >>> solution(50)\n    538\n    >>> solution(90)\n    21780\n    >>> solution(80)\n    4770\n    >>> solution(105)\n    Traceback (most recent call last):\n        ...\n    ValueError: solution() only accepts values from 0 to 100\n    >>> solution(100.011)\n    Traceback (most recent call last):\n        ...\n    ValueError: solution() only accepts values from 0 to 100\n    \"\"\"\n    if not 0 < percent < 100:\n        raise ValueError(\"solution() only accepts values from 0 to 100\")\n    bouncy_num = 0\n    num = 1\n\n    while True:\n        if check_bouncy(num):\n            bouncy_num += 1\n        if (bouncy_num / num) * 100 >= percent:\n            return num\n        num += 1",
    "docstring": "Returns the least number for which the proportion of bouncy numbers is\nexactly 'percent'\n>>> solution(50)\n538\n>>> solution(90)\n21780\n>>> solution(80)\n4770\n>>> solution(105)\nTraceback (most recent call last):\n    ...\nValueError: solution() only accepts values from 0 to 100\n>>> solution(100.011)\nTraceback (most recent call last):\n    ...\nValueError: solution() only accepts values from 0 to 100"
  },
  {
    "function": "choose",
    "code": "def choose(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n    >>> choose(4,2)\n    6\n    >>> choose(5,3)\n    10\n    >>> choose(20,6)\n    38760\n    \"\"\"\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)",
    "docstring": "Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n>>> choose(4,2)\n6\n>>> choose(5,3)\n10\n>>> choose(20,6)\n38760"
  },
  {
    "function": "non_bouncy_exact",
    "code": "def non_bouncy_exact(n: int) -> int:\n    \"\"\"\n    Calculate the number of non-bouncy numbers with at most n digits.\n    >>> non_bouncy_exact(1)\n    9\n    >>> non_bouncy_exact(6)\n    7998\n    >>> non_bouncy_exact(10)\n    136126\n    \"\"\"\n    return choose(8 + n, n) + choose(9 + n, n) - 10",
    "docstring": "Calculate the number of non-bouncy numbers with at most n digits.\n>>> non_bouncy_exact(1)\n9\n>>> non_bouncy_exact(6)\n7998\n>>> non_bouncy_exact(10)\n136126"
  },
  {
    "function": "non_bouncy_upto",
    "code": "def non_bouncy_upto(n: int) -> int:\n    \"\"\"\n    Calculate the number of non-bouncy numbers with at most n digits.\n    >>> non_bouncy_upto(1)\n    9\n    >>> non_bouncy_upto(6)\n    12951\n    >>> non_bouncy_upto(10)\n    277032\n    \"\"\"\n    return sum(non_bouncy_exact(i) for i in range(1, n + 1))",
    "docstring": "Calculate the number of non-bouncy numbers with at most n digits.\n>>> non_bouncy_upto(1)\n9\n>>> non_bouncy_upto(6)\n12951\n>>> non_bouncy_upto(10)\n277032"
  },
  {
    "function": "solution",
    "code": "def solution(num_digits: int = 100) -> int:\n    \"\"\"\n    Calculate the number of non-bouncy numbers less than a googol.\n    >>> solution(6)\n    12951\n    >>> solution(10)\n    277032\n    \"\"\"\n    return non_bouncy_upto(num_digits)",
    "docstring": "Calculate the number of non-bouncy numbers less than a googol.\n>>> solution(6)\n12951\n>>> solution(10)\n277032"
  },
  {
    "function": "solution",
    "code": "def solution(length: int = 50) -> int:\n    \"\"\"\n    Returns the number of ways a row of the given length can be filled\n\n    >>> solution(7)\n    17\n    \"\"\"\n\n    ways_number = [1] * (length + 1)\n\n    for row_length in range(3, length + 1):\n        for block_length in range(3, row_length + 1):\n            for block_start in range(row_length - block_length):\n                ways_number[row_length] += ways_number[\n                    row_length - block_start - block_length - 1\n                ]\n\n            ways_number[row_length] += 1\n\n    return ways_number[length]",
    "docstring": "Returns the number of ways a row of the given length can be filled\n\n>>> solution(7)\n17"
  },
  {
    "function": "solution",
    "code": "def solution(min_block_length: int = 50) -> int:\n    \"\"\"\n    Returns for given minimum block length the least value of n\n    for which the fill-count function first exceeds one million\n\n    >>> solution(3)\n    30\n\n    >>> solution(10)\n    57\n    \"\"\"\n\n    fill_count_functions = [1] * min_block_length\n\n    for n in count(min_block_length):\n        fill_count_functions.append(1)\n\n        for block_length in range(min_block_length, n + 1):\n            for block_start in range(n - block_length):\n                fill_count_functions[n] += fill_count_functions[\n                    n - block_start - block_length - 1\n                ]\n\n            fill_count_functions[n] += 1\n\n        if fill_count_functions[n] > 1_000_000:\n            break\n\n    return n",
    "docstring": "Returns for given minimum block length the least value of n\nfor which the fill-count function first exceeds one million\n\n>>> solution(3)\n30\n\n>>> solution(10)\n57"
  },
  {
    "function": "solution",
    "code": "def solution(length: int = 50) -> int:\n    \"\"\"\n    Returns the number of different ways can the grey tiles in a row\n    of the given length be replaced if colours cannot be mixed\n    and at least one coloured tile must be used\n\n    >>> solution(5)\n    12\n    \"\"\"\n\n    different_colour_ways_number = [[0] * 3 for _ in range(length + 1)]\n\n    for row_length in range(length + 1):\n        for tile_length in range(2, 5):\n            for tile_start in range(row_length - tile_length + 1):\n                different_colour_ways_number[row_length][tile_length - 2] += (\n                    different_colour_ways_number[row_length - tile_start - tile_length][\n                        tile_length - 2\n                    ]\n                    + 1\n                )\n\n    return sum(different_colour_ways_number[length])",
    "docstring": "Returns the number of different ways can the grey tiles in a row\nof the given length be replaced if colours cannot be mixed\nand at least one coloured tile must be used\n\n>>> solution(5)\n12"
  },
  {
    "function": "solution",
    "code": "def solution(length: int = 50) -> int:\n    \"\"\"\n    Returns the number of ways can a row of the given length be tiled\n\n    >>> solution(5)\n    15\n    \"\"\"\n\n    ways_number = [1] * (length + 1)\n\n    for row_length in range(length + 1):\n        for tile_length in range(2, 5):\n            for tile_start in range(row_length - tile_length + 1):\n                ways_number[row_length] += ways_number[\n                    row_length - tile_start - tile_length\n                ]\n\n    return ways_number[length]",
    "docstring": "Returns the number of ways can a row of the given length be tiled\n\n>>> solution(5)\n15"
  },
  {
    "function": "digit_sum",
    "code": "def digit_sum(n: int) -> int:\n    \"\"\"\n    Returns the sum of the digits of the number.\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(456)\n    15\n    >>> digit_sum(78910)\n    25\n    \"\"\"\n    return sum(int(digit) for digit in str(n))",
    "docstring": "Returns the sum of the digits of the number.\n>>> digit_sum(123)\n6\n>>> digit_sum(456)\n15\n>>> digit_sum(78910)\n25"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 30) -> int:\n    \"\"\"\n    Returns the value of 30th digit power sum.\n    >>> solution(2)\n    512\n    >>> solution(5)\n    5832\n    >>> solution(10)\n    614656\n    \"\"\"\n    digit_to_powers = []\n    for digit in range(2, 100):\n        for power in range(2, 100):\n            number = int(math.pow(digit, power))\n            if digit == digit_sum(number):\n                digit_to_powers.append(number)\n\n    digit_to_powers.sort()\n    return digit_to_powers[n - 1]",
    "docstring": "Returns the value of 30th digit power sum.\n>>> solution(2)\n512\n>>> solution(5)\n5832\n>>> solution(10)\n614656"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns \u2211 r_max for 3 <= a <= n as explained above\n    >>> solution(10)\n    300\n    >>> solution(100)\n    330750\n    >>> solution(1000)\n    333082500\n    \"\"\"\n    return sum(2 * a * ((a - 1) // 2) for a in range(3, n + 1))",
    "docstring": "Returns \u2211 r_max for 3 <= a <= n as explained above\n>>> solution(10)\n300\n>>> solution(100)\n330750\n>>> solution(1000)\n333082500"
  },
  {
    "function": "solution",
    "code": "def solution(num_turns: int = 15) -> int:\n    \"\"\"\n    Find the maximum prize fund that should be allocated to a single game in which\n    fifteen turns are played.\n    >>> solution(4)\n    10\n    >>> solution(10)\n    225\n    \"\"\"\n    total_prob: float = 0.0\n    prob: float\n    num_blue: int\n    num_red: int\n    ind: int\n    col: int\n    series: tuple[int, ...]\n\n    for series in product(range(2), repeat=num_turns):\n        num_blue = series.count(1)\n        num_red = num_turns - num_blue\n        if num_red >= num_blue:\n            continue\n        prob = 1.0\n        for ind, col in enumerate(series, 2):\n            if col == 0:\n                prob *= (ind - 1) / ind\n            else:\n                prob *= 1 / ind\n\n        total_prob += prob\n\n    return int(1 / total_prob)",
    "docstring": "Find the maximum prize fund that should be allocated to a single game in which\nfifteen turns are played.\n>>> solution(4)\n10\n>>> solution(10)\n225"
  },
  {
    "function": "solve",
    "code": "def solve(nums: list[int], goal: int, depth: int) -> bool:\n    \"\"\"\n    Checks if nums can have a sum equal to goal, given that length of nums does\n    not exceed depth.\n\n    >>> solve([1], 2, 2)\n    True\n    >>> solve([1], 2, 0)\n    False\n    \"\"\"\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False",
    "docstring": "Checks if nums can have a sum equal to goal, given that length of nums does\nnot exceed depth.\n\n>>> solve([1], 2, 2)\nTrue\n>>> solve([1], 2, 0)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 200) -> int:\n    \"\"\"\n    Calculates sum of smallest number of multiplactions for each number up to\n    and including n.\n\n    >>> solution(1)\n    0\n    >>> solution(2)\n    1\n    >>> solution(14)\n    45\n    >>> solution(15)\n    50\n    \"\"\"\n    total = 0\n    for i in range(2, n + 1):\n        max_length = 0\n        while True:\n            nums = [1]\n            max_length += 1\n            if solve(nums=nums, goal=i, depth=max_length):\n                break\n        total += max_length\n    return total",
    "docstring": "Calculates sum of smallest number of multiplactions for each number up to\nand including n.\n\n>>> solution(1)\n0\n>>> solution(2)\n1\n>>> solution(14)\n45\n>>> solution(15)\n50"
  },
  {
    "function": "sieve",
    "code": "def sieve() -> Generator[int]:\n    \"\"\"\n    Returns a prime number generator using sieve method.\n    >>> type(sieve())\n    <class 'generator'>\n    >>> primes = sieve()\n    >>> next(primes)\n    2\n    >>> next(primes)\n    3\n    >>> next(primes)\n    5\n    >>> next(primes)\n    7\n    >>> next(primes)\n    11\n    >>> next(primes)\n    13\n    \"\"\"\n    factor_map: dict[int, int] = {}\n    prime = 2\n    while True:\n        factor = factor_map.pop(prime, None)\n        if factor:\n            x = factor + prime\n            while x in factor_map:\n                x += factor\n            factor_map[x] = factor\n        else:\n            factor_map[prime * prime] = prime\n            yield prime\n        prime += 1",
    "docstring": "Returns a prime number generator using sieve method.\n>>> type(sieve())\n<class 'generator'>\n>>> primes = sieve()\n>>> next(primes)\n2\n>>> next(primes)\n3\n>>> next(primes)\n5\n>>> next(primes)\n7\n>>> next(primes)\n11\n>>> next(primes)\n13"
  },
  {
    "function": "solution",
    "code": "def solution(limit: float = 1e10) -> int:\n    \"\"\"\n    Returns the least value of n for which the remainder first exceeds 10^10.\n    >>> solution(1e8)\n    2371\n    >>> solution(1e9)\n    7037\n    \"\"\"\n    primes = sieve()\n\n    n = 1\n    while True:\n        prime = next(primes)\n        if (2 * prime * n) > limit:\n            return n\n        # Ignore the next prime as the reminder will be 2.\n        next(primes)\n        n += 2",
    "docstring": "Returns the least value of n for which the remainder first exceeds 10^10.\n>>> solution(1e8)\n2371\n>>> solution(1e9)\n7037"
  },
  {
    "function": "is_palindrome",
    "code": "def is_palindrome(n: int) -> bool:\n    \"\"\"\n    Check if an integer is palindromic.\n    >>> is_palindrome(12521)\n    True\n    >>> is_palindrome(12522)\n    False\n    >>> is_palindrome(12210)\n    False\n    \"\"\"\n    if n % 10 == 0:\n        return False\n    s = str(n)\n    return s == s[::-1]",
    "docstring": "Check if an integer is palindromic.\n>>> is_palindrome(12521)\nTrue\n>>> is_palindrome(12522)\nFalse\n>>> is_palindrome(12210)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution() -> int:\n    \"\"\"\n    Returns the sum of all numbers less than 1e8 that are both palindromic and\n    can be written as the sum of consecutive squares.\n    \"\"\"\n    answer = set()\n    first_square = 1\n    sum_squares = 5\n    while sum_squares < LIMIT:\n        last_square = first_square + 1\n        while sum_squares < LIMIT:\n            if is_palindrome(sum_squares):\n                answer.add(sum_squares)\n            last_square += 1\n            sum_squares += last_square**2\n        first_square += 1\n        sum_squares = first_square**2 + (first_square + 1) ** 2\n\n    return sum(answer)",
    "docstring": "Returns the sum of all numbers less than 1e8 that are both palindromic and\ncan be written as the sum of consecutive squares."
  },
  {
    "function": "least_divisible_repunit",
    "code": "def least_divisible_repunit(divisor: int) -> int:\n    \"\"\"\n    Return the least value k such that the Repunit of length k is divisible by divisor.\n    >>> least_divisible_repunit(7)\n    6\n    >>> least_divisible_repunit(41)\n    5\n    >>> least_divisible_repunit(1234567)\n    34020\n    \"\"\"\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index",
    "docstring": "Return the least value k such that the Repunit of length k is divisible by divisor.\n>>> least_divisible_repunit(7)\n6\n>>> least_divisible_repunit(41)\n5\n>>> least_divisible_repunit(1234567)\n34020"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 1000000) -> int:\n    \"\"\"\n    Return the least value of n for which least_divisible_repunit(n)\n    first exceeds limit.\n    >>> solution(10)\n    17\n    >>> solution(100)\n    109\n    >>> solution(1000)\n    1017\n    \"\"\"\n    divisor = limit - 1\n    if divisor % 2 == 0:\n        divisor += 1\n    while least_divisible_repunit(divisor) <= limit:\n        divisor += 2\n    return divisor",
    "docstring": "Return the least value of n for which least_divisible_repunit(n)\nfirst exceeds limit.\n>>> solution(10)\n17\n>>> solution(100)\n109\n>>> solution(1000)\n1017"
  },
  {
    "function": "is_prime",
    "code": "def is_prime(number: int) -> bool:\n    \"\"\"\n    Determines whether number is prime\n\n    >>> is_prime(3)\n    True\n\n    >>> is_prime(4)\n    False\n    \"\"\"\n\n    return all(number % divisor != 0 for divisor in range(2, isqrt(number) + 1))",
    "docstring": "Determines whether number is prime\n\n>>> is_prime(3)\nTrue\n\n>>> is_prime(4)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(max_prime: int = 10**6) -> int:\n    \"\"\"\n    Returns number of primes below max_prime with the property\n\n    >>> solution(100)\n    4\n    \"\"\"\n\n    primes_count = 0\n    cube_index = 1\n    prime_candidate = 7\n    while prime_candidate < max_prime:\n        primes_count += is_prime(prime_candidate)\n\n        cube_index += 1\n        prime_candidate += 6 * cube_index\n\n    return primes_count",
    "docstring": "Returns number of primes below max_prime with the property\n\n>>> solution(100)\n4"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 1000000) -> int:\n    \"\"\"\n    returns the values of n less than or equal to the limit\n    have exactly ten distinct solutions.\n    >>> solution(100)\n    0\n    >>> solution(10000)\n    45\n    >>> solution(50050)\n    292\n    \"\"\"\n    limit = limit + 1\n    frequency = [0] * limit\n    for first_term in range(1, limit):\n        for n in range(first_term, limit, first_term):\n            common_difference = first_term + n / first_term\n            if common_difference % 4:  # d must be divisible by 4\n                continue\n            else:\n                common_difference /= 4\n                if (\n                    first_term > common_difference\n                    and first_term < 4 * common_difference\n                ):  # since x, y, z are positive integers\n                    frequency[n] += 1  # so z > 0, a > d and 4d < a\n\n    count = sum(1 for x in frequency[1:limit] if x == 10)\n\n    return count",
    "docstring": "returns the values of n less than or equal to the limit\nhave exactly ten distinct solutions.\n>>> solution(100)\n0\n>>> solution(10000)\n45\n>>> solution(50050)\n292"
  },
  {
    "function": "solution",
    "code": "def solution(n_limit: int = 50 * 10**6) -> int:\n    \"\"\"\n    Define n count list and loop over delta, y to get the counts, then check\n    which n has count == 1.\n\n    >>> solution(3)\n    0\n    >>> solution(10)\n    3\n    >>> solution(100)\n    25\n    >>> solution(110)\n    27\n    \"\"\"\n    n_sol = [0] * n_limit\n\n    for delta in range(1, (n_limit + 1) // 4 + 1):\n        for y in range(4 * delta - 1, delta, -1):\n            n = y * (4 * delta - y)\n            if n >= n_limit:\n                break\n            n_sol[n] += 1\n\n    ans = 0\n    for i in range(n_limit):\n        if n_sol[i] == 1:\n            ans += 1\n\n    return ans",
    "docstring": "Define n count list and loop over delta, y to get the counts, then check\nwhich n has count == 1.\n\n>>> solution(3)\n0\n>>> solution(10)\n3\n>>> solution(100)\n25\n>>> solution(110)\n27"
  },
  {
    "function": "next_point",
    "code": "def next_point(\n    point_x: float, point_y: float, incoming_gradient: float\n) -> tuple[float, float, float]:\n    \"\"\"\n    Given that a laser beam hits the interior of the white cell at point\n    (point_x, point_y) with gradient incoming_gradient, return a tuple (x,y,m1)\n    where the next point of contact with the interior is (x,y) with gradient m1.\n    >>> next_point(5.0, 0.0, 0.0)\n    (-5.0, 0.0, 0.0)\n    >>> next_point(5.0, 0.0, -2.0)\n    (0.0, -10.0, 2.0)\n    \"\"\"\n    # normal_gradient = gradient of line through which the beam is reflected\n    # outgoing_gradient = gradient of reflected line\n    normal_gradient = point_y / 4 / point_x\n    s2 = 2 * normal_gradient / (1 + normal_gradient * normal_gradient)\n    c2 = (1 - normal_gradient * normal_gradient) / (\n        1 + normal_gradient * normal_gradient\n    )\n    outgoing_gradient = (s2 - c2 * incoming_gradient) / (c2 + s2 * incoming_gradient)\n\n    # to find the next point, solve the simultaeneous equations:\n    # y^2 + 4x^2 = 100\n    # y - b = m * (x - a)\n    # ==> A x^2 + B x + C = 0\n    quadratic_term = outgoing_gradient**2 + 4\n    linear_term = 2 * outgoing_gradient * (point_y - outgoing_gradient * point_x)\n    constant_term = (point_y - outgoing_gradient * point_x) ** 2 - 100\n\n    x_minus = (\n        -linear_term - sqrt(linear_term**2 - 4 * quadratic_term * constant_term)\n    ) / (2 * quadratic_term)\n    x_plus = (\n        -linear_term + sqrt(linear_term**2 - 4 * quadratic_term * constant_term)\n    ) / (2 * quadratic_term)\n\n    # two solutions, one of which is our input point\n    next_x = x_minus if isclose(x_plus, point_x) else x_plus\n    next_y = point_y + outgoing_gradient * (next_x - point_x)\n\n    return next_x, next_y, outgoing_gradient",
    "docstring": "Given that a laser beam hits the interior of the white cell at point\n(point_x, point_y) with gradient incoming_gradient, return a tuple (x,y,m1)\nwhere the next point of contact with the interior is (x,y) with gradient m1.\n>>> next_point(5.0, 0.0, 0.0)\n(-5.0, 0.0, 0.0)\n>>> next_point(5.0, 0.0, -2.0)\n(0.0, -10.0, 2.0)"
  },
  {
    "function": "solution",
    "code": "def solution(first_x_coord: float = 1.4, first_y_coord: float = -9.6) -> int:\n    \"\"\"\n    Return the number of times that the beam hits the interior wall of the\n    cell before exiting.\n    >>> solution(0.00001,-10)\n    1\n    >>> solution(5, 0)\n    287\n    \"\"\"\n    num_reflections: int = 0\n    point_x: float = first_x_coord\n    point_y: float = first_y_coord\n    gradient: float = (10.1 - point_y) / (0.0 - point_x)\n\n    while not (-0.01 <= point_x <= 0.01 and point_y > 0):\n        point_x, point_y, gradient = next_point(point_x, point_y, gradient)\n        num_reflections += 1\n\n    return num_reflections",
    "docstring": "Return the number of times that the beam hits the interior wall of the\ncell before exiting.\n>>> solution(0.00001,-10)\n1\n>>> solution(5, 0)\n287"
  },
  {
    "function": "slow_reversible_numbers",
    "code": "def slow_reversible_numbers(\n    remaining_length: int, remainder: int, digits: list[int], length: int\n) -> int:\n    \"\"\"\n    Count the number of reversible numbers of given length.\n    Iterate over possible digits considering parity of current sum remainder.\n    >>> slow_reversible_numbers(1, 0, [0], 1)\n    0\n    >>> slow_reversible_numbers(2, 0, [0] * 2, 2)\n    20\n    >>> slow_reversible_numbers(3, 0, [0] * 3, 3)\n    100\n    \"\"\"\n    if remaining_length == 0:\n        if digits[0] == 0 or digits[-1] == 0:\n            return 0\n\n        for i in range(length // 2 - 1, -1, -1):\n            remainder += digits[i] + digits[length - i - 1]\n\n            if remainder % 2 == 0:\n                return 0\n\n            remainder //= 10\n\n        return 1\n\n    if remaining_length == 1:\n        if remainder % 2 == 0:\n            return 0\n\n        result = 0\n        for digit in range(10):\n            digits[length // 2] = digit\n            result += slow_reversible_numbers(\n                0, (remainder + 2 * digit) // 10, digits, length\n            )\n        return result\n\n    result = 0\n    for digit1 in range(10):\n        digits[(length + remaining_length) // 2 - 1] = digit1\n\n        if (remainder + digit1) % 2 == 0:\n            other_parity_digits = ODD_DIGITS\n        else:\n            other_parity_digits = EVEN_DIGITS\n\n        for digit2 in other_parity_digits:\n            digits[(length - remaining_length) // 2] = digit2\n            result += slow_reversible_numbers(\n                remaining_length - 2,\n                (remainder + digit1 + digit2) // 10,\n                digits,\n                length,\n            )\n    return result",
    "docstring": "Count the number of reversible numbers of given length.\nIterate over possible digits considering parity of current sum remainder.\n>>> slow_reversible_numbers(1, 0, [0], 1)\n0\n>>> slow_reversible_numbers(2, 0, [0] * 2, 2)\n20\n>>> slow_reversible_numbers(3, 0, [0] * 3, 3)\n100"
  },
  {
    "function": "slow_solution",
    "code": "def slow_solution(max_power: int = 9) -> int:\n    \"\"\"\n    To evaluate the solution, use solution()\n    >>> slow_solution(3)\n    120\n    >>> slow_solution(6)\n    18720\n    >>> slow_solution(7)\n    68720\n    \"\"\"\n    result = 0\n    for length in range(1, max_power + 1):\n        result += slow_reversible_numbers(length, 0, [0] * length, length)\n    return result",
    "docstring": "To evaluate the solution, use solution()\n>>> slow_solution(3)\n120\n>>> slow_solution(6)\n18720\n>>> slow_solution(7)\n68720"
  },
  {
    "function": "reversible_numbers",
    "code": "def reversible_numbers(\n    remaining_length: int, remainder: int, digits: list[int], length: int\n) -> int:\n    \"\"\"\n    Count the number of reversible numbers of given length.\n    Iterate over possible digits considering parity of current sum remainder.\n    >>> reversible_numbers(1, 0, [0], 1)\n    0\n    >>> reversible_numbers(2, 0, [0] * 2, 2)\n    20\n    >>> reversible_numbers(3, 0, [0] * 3, 3)\n    100\n    \"\"\"\n    # There exist no reversible 1, 5, 9, 13 (ie. 4k+1) digit numbers\n    if (length - 1) % 4 == 0:\n        return 0\n\n    return slow_reversible_numbers(remaining_length, remainder, digits, length)",
    "docstring": "Count the number of reversible numbers of given length.\nIterate over possible digits considering parity of current sum remainder.\n>>> reversible_numbers(1, 0, [0], 1)\n0\n>>> reversible_numbers(2, 0, [0] * 2, 2)\n20\n>>> reversible_numbers(3, 0, [0] * 3, 3)\n100"
  },
  {
    "function": "solution",
    "code": "def solution(max_power: int = 9) -> int:\n    \"\"\"\n    To evaluate the solution, use solution()\n    >>> solution(3)\n    120\n    >>> solution(6)\n    18720\n    >>> solution(7)\n    68720\n    \"\"\"\n    result = 0\n    for length in range(1, max_power + 1):\n        result += reversible_numbers(length, 0, [0] * length, length)\n    return result",
    "docstring": "To evaluate the solution, use solution()\n>>> solution(3)\n120\n>>> solution(6)\n18720\n>>> solution(7)\n68720"
  },
  {
    "function": "solve",
    "code": "def solve(\n    digit: int, prev1: int, prev2: int, sum_max: int, first: bool, cache: dict[str, int]\n) -> int:\n    \"\"\"\n    Solve for remaining 'digit' digits, with previous 'prev1' digit, and\n    previous-previous 'prev2' digit, total sum of 'sum_max'.\n    Pass around 'cache' to store/reuse intermediate results.\n\n    >>> solve(digit=1, prev1=0, prev2=0, sum_max=9, first=True, cache={})\n    9\n    >>> solve(digit=1, prev1=0, prev2=0, sum_max=9, first=False, cache={})\n    10\n    \"\"\"\n    if digit == 0:\n        return 1\n\n    cache_str = f\"{digit},{prev1},{prev2}\"\n    if cache_str in cache:\n        return cache[cache_str]\n\n    comb = 0\n    for curr in range(sum_max - prev1 - prev2 + 1):\n        if first and curr == 0:\n            continue\n\n        comb += solve(\n            digit=digit - 1,\n            prev1=curr,\n            prev2=prev1,\n            sum_max=sum_max,\n            first=False,\n            cache=cache,\n        )\n\n    cache[cache_str] = comb\n    return comb",
    "docstring": "Solve for remaining 'digit' digits, with previous 'prev1' digit, and\nprevious-previous 'prev2' digit, total sum of 'sum_max'.\nPass around 'cache' to store/reuse intermediate results.\n\n>>> solve(digit=1, prev1=0, prev2=0, sum_max=9, first=True, cache={})\n9\n>>> solve(digit=1, prev1=0, prev2=0, sum_max=9, first=False, cache={})\n10"
  },
  {
    "function": "solution",
    "code": "def solution(n_digits: int = 20) -> int:\n    \"\"\"\n    Solves the problem for n_digits number of digits.\n\n    >>> solution(2)\n    45\n    >>> solution(10)\n    21838806\n    \"\"\"\n    cache: dict[str, int] = {}\n    return solve(digit=n_digits, prev1=0, prev2=0, sum_max=9, first=True, cache=cache)",
    "docstring": "Solves the problem for n_digits number of digits.\n\n>>> solution(2)\n45\n>>> solution(10)\n21838806"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 1000000) -> int:\n    \"\"\"\n    Return the number of different square laminae that can be formed using up to\n    one million tiles.\n    >>> solution(100)\n    41\n    \"\"\"\n    answer = 0\n\n    for outer_width in range(3, (limit // 4) + 2):\n        if outer_width**2 > limit:\n            hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)\n        else:\n            hole_width_lower_bound = 1\n        if (outer_width - hole_width_lower_bound) % 2:\n            hole_width_lower_bound += 1\n\n        answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1\n\n    return answer",
    "docstring": "Return the number of different square laminae that can be formed using up to\none million tiles.\n>>> solution(100)\n41"
  },
  {
    "function": "solution",
    "code": "def solution(t_limit: int = 1000000, n_limit: int = 10) -> int:\n    \"\"\"\n    Return the sum of N(n) for 1 <= n <= n_limit.\n\n    >>> solution(1000,5)\n    222\n    >>> solution(1000,10)\n    249\n    >>> solution(10000,10)\n    2383\n    \"\"\"\n    count: defaultdict = defaultdict(int)\n\n    for outer_width in range(3, (t_limit // 4) + 2):\n        if outer_width * outer_width > t_limit:\n            hole_width_lower_bound = max(\n                ceil(sqrt(outer_width * outer_width - t_limit)), 1\n            )\n        else:\n            hole_width_lower_bound = 1\n\n        hole_width_lower_bound += (outer_width - hole_width_lower_bound) % 2\n\n        for hole_width in range(hole_width_lower_bound, outer_width - 1, 2):\n            count[outer_width * outer_width - hole_width * hole_width] += 1\n\n    return sum(1 for n in count.values() if 1 <= n <= n_limit)",
    "docstring": "Return the sum of N(n) for 1 <= n <= n_limit.\n\n>>> solution(1000,5)\n222\n>>> solution(1000,10)\n249\n>>> solution(10000,10)\n2383"
  },
  {
    "function": "is_sq",
    "code": "def is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq",
    "docstring": "Check if number is a perfect square.\n\n>>> is_sq(1)\nTrue\n>>> is_sq(1000001)\nFalse\n>>> is_sq(1000000)\nTrue"
  },
  {
    "function": "add_three",
    "code": "def add_three(\n    x_num: int, x_den: int, y_num: int, y_den: int, z_num: int, z_den: int\n) -> tuple[int, int]:\n    \"\"\"\n    Given the numerators and denominators of three fractions, return the\n    numerator and denominator of their sum in lowest form.\n    >>> add_three(1, 3, 1, 3, 1, 3)\n    (1, 1)\n    >>> add_three(2, 5, 4, 11, 12, 3)\n    (262, 55)\n    \"\"\"\n    top: int = x_num * y_den * z_den + y_num * x_den * z_den + z_num * x_den * y_den\n    bottom: int = x_den * y_den * z_den\n    hcf: int = gcd(top, bottom)\n    top //= hcf\n    bottom //= hcf\n    return top, bottom",
    "docstring": "Given the numerators and denominators of three fractions, return the\nnumerator and denominator of their sum in lowest form.\n>>> add_three(1, 3, 1, 3, 1, 3)\n(1, 1)\n>>> add_three(2, 5, 4, 11, 12, 3)\n(262, 55)"
  },
  {
    "function": "solution",
    "code": "def solution(order: int = 35) -> int:\n    \"\"\"\n    Find the sum of the numerator and denominator of the sum of all s(x,y,z) for\n    golden triples (x,y,z) of the given order.\n\n    >>> solution(5)\n    296\n    >>> solution(10)\n    12519\n    >>> solution(20)\n    19408891927\n    \"\"\"\n    unique_s: set = set()\n    hcf: int\n    total: Fraction = Fraction(0)\n    fraction_sum: tuple[int, int]\n\n    for x_num in range(1, order + 1):\n        for x_den in range(x_num + 1, order + 1):\n            for y_num in range(1, order + 1):\n                for y_den in range(y_num + 1, order + 1):\n                    # n=1\n                    z_num = x_num * y_den + x_den * y_num\n                    z_den = x_den * y_den\n                    hcf = gcd(z_num, z_den)\n                    z_num //= hcf\n                    z_den //= hcf\n                    if 0 < z_num < z_den <= order:\n                        fraction_sum = add_three(\n                            x_num, x_den, y_num, y_den, z_num, z_den\n                        )\n                        unique_s.add(fraction_sum)\n\n                    # n=2\n                    z_num = (\n                        x_num * x_num * y_den * y_den + x_den * x_den * y_num * y_num\n                    )\n                    z_den = x_den * x_den * y_den * y_den\n                    if is_sq(z_num) and is_sq(z_den):\n                        z_num = int(sqrt(z_num))\n                        z_den = int(sqrt(z_den))\n                        hcf = gcd(z_num, z_den)\n                        z_num //= hcf\n                        z_den //= hcf\n                        if 0 < z_num < z_den <= order:\n                            fraction_sum = add_three(\n                                x_num, x_den, y_num, y_den, z_num, z_den\n                            )\n                            unique_s.add(fraction_sum)\n\n                    # n=-1\n                    z_num = x_num * y_num\n                    z_den = x_den * y_num + x_num * y_den\n                    hcf = gcd(z_num, z_den)\n                    z_num //= hcf\n                    z_den //= hcf\n                    if 0 < z_num < z_den <= order:\n                        fraction_sum = add_three(\n                            x_num, x_den, y_num, y_den, z_num, z_den\n                        )\n                        unique_s.add(fraction_sum)\n\n                    # n=2\n                    z_num = x_num * x_num * y_num * y_num\n                    z_den = (\n                        x_den * x_den * y_num * y_num + x_num * x_num * y_den * y_den\n                    )\n                    if is_sq(z_num) and is_sq(z_den):\n                        z_num = int(sqrt(z_num))\n                        z_den = int(sqrt(z_den))\n                        hcf = gcd(z_num, z_den)\n                        z_num //= hcf\n                        z_den //= hcf\n                        if 0 < z_num < z_den <= order:\n                            fraction_sum = add_three(\n                                x_num, x_den, y_num, y_den, z_num, z_den\n                            )\n                            unique_s.add(fraction_sum)\n\n    for num, den in unique_s:\n        total += Fraction(num, den)\n\n    return total.denominator + total.numerator",
    "docstring": "Find the sum of the numerator and denominator of the sum of all s(x,y,z) for\ngolden triples (x,y,z) of the given order.\n\n>>> solution(5)\n296\n>>> solution(10)\n12519\n>>> solution(20)\n19408891927"
  },
  {
    "function": "slow_calculate_prime_numbers",
    "code": "def slow_calculate_prime_numbers(max_number: int) -> list[int]:\n    \"\"\"\n    Returns prime numbers below max_number.\n    See: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> slow_calculate_prime_numbers(10)\n    [2, 3, 5, 7]\n\n    >>> slow_calculate_prime_numbers(2)\n    []\n    \"\"\"\n\n    # List containing a bool value for every number below max_number/2\n    is_prime = [True] * max_number\n\n    for i in range(2, isqrt(max_number - 1) + 1):\n        if is_prime[i]:\n            # Mark all multiple of i as not prime\n            for j in range(i**2, max_number, i):\n                is_prime[j] = False\n\n    return [i for i in range(2, max_number) if is_prime[i]]",
    "docstring": "Returns prime numbers below max_number.\nSee: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n>>> slow_calculate_prime_numbers(10)\n[2, 3, 5, 7]\n\n>>> slow_calculate_prime_numbers(2)\n[]"
  },
  {
    "function": "calculate_prime_numbers",
    "code": "def calculate_prime_numbers(max_number: int) -> list[int]:\n    \"\"\"\n    Returns prime numbers below max_number.\n    See: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> calculate_prime_numbers(10)\n    [2, 3, 5, 7]\n\n    >>> calculate_prime_numbers(2)\n    []\n    \"\"\"\n\n    if max_number <= 2:\n        return []\n\n    # List containing a bool value for every odd number below max_number/2\n    is_prime = [True] * (max_number // 2)\n\n    for i in range(3, isqrt(max_number - 1) + 1, 2):\n        if is_prime[i // 2]:\n            # Mark all multiple of i as not prime using list slicing\n            is_prime[i**2 // 2 :: i] = [False] * (\n                # Same as: (max_number - (i**2)) // (2 * i) + 1\n                # but faster than len(is_prime[i**2 // 2 :: i])\n                len(range(i**2 // 2, max_number // 2, i))\n            )\n\n    return [2] + [2 * i + 1 for i in range(1, max_number // 2) if is_prime[i]]",
    "docstring": "Returns prime numbers below max_number.\nSee: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n>>> calculate_prime_numbers(10)\n[2, 3, 5, 7]\n\n>>> calculate_prime_numbers(2)\n[]"
  },
  {
    "function": "slow_solution",
    "code": "def slow_solution(max_number: int = 10**8) -> int:\n    \"\"\"\n    Returns the number of composite integers below max_number have precisely two,\n    not necessarily distinct, prime factors.\n\n    >>> slow_solution(30)\n    10\n    \"\"\"\n\n    prime_numbers = slow_calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left <= right:\n        while prime_numbers[left] * prime_numbers[right] >= max_number:\n            right -= 1\n        semiprimes_count += right - left + 1\n        left += 1\n\n    return semiprimes_count",
    "docstring": "Returns the number of composite integers below max_number have precisely two,\nnot necessarily distinct, prime factors.\n\n>>> slow_solution(30)\n10"
  },
  {
    "function": "while_solution",
    "code": "def while_solution(max_number: int = 10**8) -> int:\n    \"\"\"\n    Returns the number of composite integers below max_number have precisely two,\n    not necessarily distinct, prime factors.\n\n    >>> while_solution(30)\n    10\n    \"\"\"\n\n    prime_numbers = calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left <= right:\n        while prime_numbers[left] * prime_numbers[right] >= max_number:\n            right -= 1\n        semiprimes_count += right - left + 1\n        left += 1\n\n    return semiprimes_count",
    "docstring": "Returns the number of composite integers below max_number have precisely two,\nnot necessarily distinct, prime factors.\n\n>>> while_solution(30)\n10"
  },
  {
    "function": "solution",
    "code": "def solution(max_number: int = 10**8) -> int:\n    \"\"\"\n    Returns the number of composite integers below max_number have precisely two,\n    not necessarily distinct, prime factors.\n\n    >>> solution(30)\n    10\n    \"\"\"\n\n    prime_numbers = calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    right = len(prime_numbers) - 1\n    for left in range(len(prime_numbers)):\n        if left > right:\n            break\n        for r in range(right, left - 2, -1):\n            if prime_numbers[left] * prime_numbers[r] < max_number:\n                break\n        right = r\n        semiprimes_count += right - left + 1\n\n    return semiprimes_count",
    "docstring": "Returns the number of composite integers below max_number have precisely two,\nnot necessarily distinct, prime factors.\n\n>>> solution(30)\n10"
  },
  {
    "function": "_modexpt",
    "code": "def _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value",
    "docstring": "Returns the modular exponentiation, that is the value\nof `base ** exponent % modulo_value`, without calculating\nthe actual number.\n>>> _modexpt(2, 4, 10)\n6\n>>> _modexpt(2, 1024, 100)\n16\n>>> _modexpt(13, 65535, 7)\n6"
  },
  {
    "function": "solution",
    "code": "def solution(base: int = 1777, height: int = 1855, digits: int = 8) -> int:\n    \"\"\"\n    Returns the last 8 digits of the hyperexponentiation of base by\n    height, i.e. the number base\u2191\u2191height:\n\n    >>> solution(base=3, height=2)\n    27\n    >>> solution(base=3, height=3)\n    97484987\n    >>> solution(base=123, height=456, digits=4)\n    2547\n    \"\"\"\n\n    # calculate base\u2191\u2191height by right-assiciative repeated modular\n    # exponentiation\n    result = base\n    for _ in range(1, height):\n        result = _modexpt(base, result, 10**digits)\n\n    return result",
    "docstring": "Returns the last 8 digits of the hyperexponentiation of base by\nheight, i.e. the number base\u2191\u2191height:\n\n>>> solution(base=3, height=2)\n27\n>>> solution(base=3, height=3)\n97484987\n>>> solution(base=123, height=456, digits=4)\n2547"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 15) -> int:\n    \"\"\"\n    Calculate sum of |_ P_m _| for m from 2 to n.\n\n    >>> solution(2)\n    1\n    >>> solution(3)\n    2\n    >>> solution(4)\n    4\n    >>> solution(5)\n    10\n    \"\"\"\n    total = 0\n    for m in range(2, n + 1):\n        x1 = 2 / (m + 1)\n        p = 1.0\n        for i in range(1, m + 1):\n            xi = i * x1\n            p *= xi**i\n        total += int(p)\n    return total",
    "docstring": "Calculate sum of |_ P_m _| for m from 2 to n.\n\n>>> solution(2)\n1\n>>> solution(3)\n2\n>>> solution(4)\n4\n>>> solution(5)\n10"
  },
  {
    "function": "_calculate",
    "code": "def _calculate(days: int, absent: int, late: int) -> int:\n    \"\"\"\n    A small helper function for the recursion, mainly to have\n    a clean interface for the solution() function below.\n\n    It should get called with the number of days (corresponding\n    to the desired length of the 'prize strings'), and the\n    initial values for the number of consecutive absent days and\n    number of total late days.\n\n    >>> _calculate(days=4, absent=0, late=0)\n    43\n    >>> _calculate(days=30, absent=2, late=0)\n    0\n    >>> _calculate(days=30, absent=1, late=0)\n    98950096\n    \"\"\"\n\n    # if we are absent twice, or late 3 consecutive days,\n    # no further prize strings are possible\n    if late == 3 or absent == 2:\n        return 0\n\n    # if we have no days left, and have not failed any other rules,\n    # we have a prize string\n    if days == 0:\n        return 1\n\n    # No easy solution, so now we need to do the recursive calculation\n\n    # First, check if the combination is already in the cache, and\n    # if yes, return the stored value from there since we already\n    # know the number of possible prize strings from this point on\n    key = (days, absent, late)\n    if key in cache:\n        return cache[key]\n\n    # now we calculate the three possible ways that can unfold from\n    # this point on, depending on our attendance today\n\n    # 1) if we are late (but not absent), the \"absent\" counter stays as\n    # it is, but the \"late\" counter increases by one\n    state_late = _calculate(days - 1, absent, late + 1)\n\n    # 2) if we are absent, the \"absent\" counter increases by 1, and the\n    # \"late\" counter resets to 0\n    state_absent = _calculate(days - 1, absent + 1, 0)\n\n    # 3) if we are on time, this resets the \"late\" counter and keeps the\n    # absent counter\n    state_ontime = _calculate(days - 1, absent, 0)\n\n    prizestrings = state_late + state_absent + state_ontime\n\n    cache[key] = prizestrings\n    return prizestrings",
    "docstring": "A small helper function for the recursion, mainly to have\na clean interface for the solution() function below.\n\nIt should get called with the number of days (corresponding\nto the desired length of the 'prize strings'), and the\ninitial values for the number of consecutive absent days and\nnumber of total late days.\n\n>>> _calculate(days=4, absent=0, late=0)\n43\n>>> _calculate(days=30, absent=2, late=0)\n0\n>>> _calculate(days=30, absent=1, late=0)\n98950096"
  },
  {
    "function": "solution",
    "code": "def solution(days: int = 30) -> int:\n    \"\"\"\n    Returns the number of possible prize strings for a particular number\n    of days, using a simple recursive function with caching to speed it up.\n\n    >>> solution()\n    1918080160\n    >>> solution(4)\n    43\n    \"\"\"\n\n    return _calculate(days, absent=0, late=0)",
    "docstring": "Returns the number of possible prize strings for a particular number\nof days, using a simple recursive function with caching to speed it up.\n\n>>> solution()\n1918080160\n>>> solution(4)\n43"
  },
  {
    "function": "get_pascal_triangle_unique_coefficients",
    "code": "def get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for _ in range(2, depth + 1):\n        coefficients_begins_one = [*previous_coefficients, 0]\n        coefficients_ends_one = [0, *previous_coefficients]\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients",
    "docstring": "Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\nThe coefficients of this triangle are symmetric. A further improvement to this\nmethod could be to calculate the coefficients once per level. Nonetheless,\nthe current implementation is fast enough for the original problem.\n\n>>> get_pascal_triangle_unique_coefficients(1)\n{1}\n>>> get_pascal_triangle_unique_coefficients(2)\n{1}\n>>> get_pascal_triangle_unique_coefficients(3)\n{1, 2}\n>>> get_pascal_triangle_unique_coefficients(8)\n{1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}"
  },
  {
    "function": "get_squarefrees",
    "code": "def get_squarefrees(unique_coefficients: set[int]) -> set[int]:\n    \"\"\"\n    Calculates the squarefree numbers inside unique_coefficients.\n\n    Based on the definition of a non-squarefree number, then any non-squarefree\n    n can be decomposed as n = p*p*r, where p is positive prime number and r\n    is a positive integer.\n\n    Under the previous formula, any coefficient that is lower than p*p is\n    squarefree as r cannot be negative. On the contrary, if any r exists such\n    that n = p*p*r, then the number is non-squarefree.\n\n    >>> get_squarefrees({1})\n    {1}\n    >>> get_squarefrees({1, 2})\n    {1, 2}\n    >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})\n    {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}\n    \"\"\"\n\n    non_squarefrees = set()\n    for number in unique_coefficients:\n        divisor = 2\n        copy_number = number\n        while divisor**2 <= copy_number:\n            multiplicity = 0\n            while copy_number % divisor == 0:\n                copy_number //= divisor\n                multiplicity += 1\n            if multiplicity >= 2:\n                non_squarefrees.add(number)\n                break\n            divisor += 1\n\n    return unique_coefficients.difference(non_squarefrees)",
    "docstring": "Calculates the squarefree numbers inside unique_coefficients.\n\nBased on the definition of a non-squarefree number, then any non-squarefree\nn can be decomposed as n = p*p*r, where p is positive prime number and r\nis a positive integer.\n\nUnder the previous formula, any coefficient that is lower than p*p is\nsquarefree as r cannot be negative. On the contrary, if any r exists such\nthat n = p*p*r, then the number is non-squarefree.\n\n>>> get_squarefrees({1})\n{1}\n>>> get_squarefrees({1, 2})\n{1, 2}\n>>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})\n{1, 2, 3, 5, 6, 7, 35, 10, 15, 21}"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 51) -> int:\n    \"\"\"\n    Returns the sum of squarefrees for a given Pascal's Triangle of depth n.\n\n    >>> solution(1)\n    1\n    >>> solution(8)\n    105\n    >>> solution(9)\n    175\n    \"\"\"\n    unique_coefficients = get_pascal_triangle_unique_coefficients(n)\n    squarefrees = get_squarefrees(unique_coefficients)\n    return sum(squarefrees)",
    "docstring": "Returns the sum of squarefrees for a given Pascal's Triangle of depth n.\n\n>>> solution(1)\n1\n>>> solution(8)\n105\n>>> solution(9)\n175"
  },
  {
    "function": "total_frequency_distribution",
    "code": "def total_frequency_distribution(sides_number: int, dice_number: int) -> list[int]:\n    \"\"\"\n    Returns frequency distribution of total\n\n    >>> total_frequency_distribution(sides_number=6, dice_number=1)\n    [0, 1, 1, 1, 1, 1, 1]\n\n    >>> total_frequency_distribution(sides_number=4, dice_number=2)\n    [0, 0, 1, 2, 3, 4, 3, 2, 1]\n    \"\"\"\n\n    max_face_number = sides_number\n    max_total = max_face_number * dice_number\n    totals_frequencies = [0] * (max_total + 1)\n\n    min_face_number = 1\n    faces_numbers = range(min_face_number, max_face_number + 1)\n    for dice_numbers in product(faces_numbers, repeat=dice_number):\n        total = sum(dice_numbers)\n        totals_frequencies[total] += 1\n\n    return totals_frequencies",
    "docstring": "Returns frequency distribution of total\n\n>>> total_frequency_distribution(sides_number=6, dice_number=1)\n[0, 1, 1, 1, 1, 1, 1]\n\n>>> total_frequency_distribution(sides_number=4, dice_number=2)\n[0, 0, 1, 2, 3, 4, 3, 2, 1]"
  },
  {
    "function": "solution",
    "code": "def solution() -> float:\n    \"\"\"\n    Returns probability that Pyramidal Peter beats Cubic Colin\n    rounded to seven decimal places in the form 0.abcdefg\n\n    >>> solution()\n    0.5731441\n    \"\"\"\n\n    peter_totals_frequencies = total_frequency_distribution(\n        sides_number=4, dice_number=9\n    )\n    colin_totals_frequencies = total_frequency_distribution(\n        sides_number=6, dice_number=6\n    )\n\n    peter_wins_count = 0\n    min_peter_total = 9\n    max_peter_total = 4 * 9\n    min_colin_total = 6\n    for peter_total in range(min_peter_total, max_peter_total + 1):\n        peter_wins_count += peter_totals_frequencies[peter_total] * sum(\n            colin_totals_frequencies[min_colin_total:peter_total]\n        )\n\n    total_games_number = (4**9) * (6**6)\n    peter_win_probability = peter_wins_count / total_games_number\n\n    rounded_peter_win_probability = round(peter_win_probability, ndigits=7)\n\n    return rounded_peter_win_probability",
    "docstring": "Returns probability that Pyramidal Peter beats Cubic Colin\nrounded to seven decimal places in the form 0.abcdefg\n\n>>> solution()\n0.5731441"
  },
  {
    "function": "is_square_form",
    "code": "def is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True",
    "docstring": "Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n>>> is_square_form(1)\nFalse\n>>> is_square_form(112233445566778899)\nTrue\n>>> is_square_form(123456789012345678)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution() -> int:\n    \"\"\"\n    Returns the first integer whose square is of the form 1_2_3_4_5_6_7_8_9_0\n    \"\"\"\n    num = 138902663\n\n    while not is_square_form(num * num):\n        if num % 10 == 3:\n            num -= 6  # (3 - 6) % 10 = 7\n        else:\n            num -= 4  # (7 - 4) % 10 = 3\n\n    return num * 10",
    "docstring": "Returns the first integer whose square is of the form 1_2_3_4_5_6_7_8_9_0"
  },
  {
    "function": "check_partition_perfect",
    "code": "def check_partition_perfect(positive_integer: int) -> bool:\n    \"\"\"\n\n    Check if t = f(positive_integer) = log2(sqrt(4*positive_integer+1)/2 + 1/2) is a\n    real number.\n\n    >>> check_partition_perfect(2)\n    True\n\n    >>> check_partition_perfect(6)\n    False\n\n    \"\"\"\n\n    exponent = math.log2(math.sqrt(4 * positive_integer + 1) / 2 + 1 / 2)\n\n    return exponent == int(exponent)",
    "docstring": "Check if t = f(positive_integer) = log2(sqrt(4*positive_integer+1)/2 + 1/2) is a\nreal number.\n\n>>> check_partition_perfect(2)\nTrue\n\n>>> check_partition_perfect(6)\nFalse"
  },
  {
    "function": "solution",
    "code": "def solution(max_proportion: float = 1 / 12345) -> int:\n    \"\"\"\n    Find m for which the proportion of perfect partitions to total partitions is lower\n    than max_proportion\n\n    >>> solution(1) > 5\n    True\n\n    >>> solution(1/2) > 10\n    True\n\n    >>> solution(3 / 13) > 185\n    True\n\n    \"\"\"\n\n    total_partitions = 0\n    perfect_partitions = 0\n\n    integer = 3\n    while True:\n        partition_candidate = (integer**2 - 1) / 4\n        # if candidate is an integer, then there is a partition for k\n        if partition_candidate == int(partition_candidate):\n            partition_candidate = int(partition_candidate)\n            total_partitions += 1\n            if check_partition_perfect(partition_candidate):\n                perfect_partitions += 1\n        if (\n            perfect_partitions > 0\n            and perfect_partitions / total_partitions < max_proportion\n        ):\n            return int(partition_candidate)\n        integer += 1",
    "docstring": "Find m for which the proportion of perfect partitions to total partitions is lower\nthan max_proportion\n\n>>> solution(1) > 5\nTrue\n\n>>> solution(1/2) > 10\nTrue\n\n>>> solution(3 / 13) > 185\nTrue"
  },
  {
    "function": "prime_sieve",
    "code": "def prime_sieve(n: int) -> list:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n    >>> prime_sieve(3)\n    [2]\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n**0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes",
    "docstring": "Sieve of Erotosthenes\nFunction to return all the prime numbers up to a certain number\nhttps://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n>>> prime_sieve(3)\n[2]\n>>> prime_sieve(50)\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]"
  },
  {
    "function": "solution",
    "code": "def solution(limit: int = 999_966_663_333) -> int:\n    \"\"\"\n    Computes the solution to the problem up to the specified limit\n    >>> solution(1000)\n    34825\n\n    >>> solution(10_000)\n    1134942\n\n    >>> solution(100_000)\n    36393008\n    \"\"\"\n    primes_upper_bound = math.floor(math.sqrt(limit)) + 100\n    primes = prime_sieve(primes_upper_bound)\n\n    matches_sum = 0\n    prime_index = 0\n    last_prime = primes[prime_index]\n\n    while (last_prime**2) <= limit:\n        next_prime = primes[prime_index + 1]\n\n        lower_bound = last_prime**2\n        upper_bound = next_prime**2\n\n        # Get numbers divisible by lps(current)\n        current = lower_bound + last_prime\n        while upper_bound > current <= limit:\n            matches_sum += current\n            current += last_prime\n\n        # Reset the upper_bound\n        while (upper_bound - next_prime) > limit:\n            upper_bound -= next_prime\n\n        # Add the numbers divisible by ups(current)\n        current = upper_bound - next_prime\n        while current > lower_bound:\n            matches_sum += current\n            current -= next_prime\n\n        # Remove the numbers divisible by both ups and lps\n        current = 0\n        while upper_bound > current <= limit:\n            if current <= lower_bound:\n                # Increment the current number\n                current += last_prime * next_prime\n                continue\n\n            if current > limit:\n                break\n\n            # Remove twice since it was added by both ups and lps\n            matches_sum -= current * 2\n\n            # Increment the current number\n            current += last_prime * next_prime\n\n        # Setup for next pair\n        last_prime = next_prime\n        prime_index += 1\n\n    return matches_sum",
    "docstring": "Computes the solution to the problem up to the specified limit\n>>> solution(1000)\n34825\n\n>>> solution(10_000)\n1134942\n\n>>> solution(100_000)\n36393008"
  },
  {
    "function": "solution",
    "code": "def solution(exponent: int = 30) -> int:\n    \"\"\"\n    For any given exponent x >= 0, 1 <= n <= 2^x.\n    This function returns how many Nim games are lost given that\n    each Nim game has three heaps of the form (n, 2*n, 3*n).\n    >>> solution(0)\n    1\n    >>> solution(2)\n    3\n    >>> solution(10)\n    144\n    \"\"\"\n    # To find how many total games were lost for a given exponent x,\n    # we need to find the Fibonacci number F(x+2).\n    fibonacci_index = exponent + 2\n    phi = (1 + 5**0.5) / 2\n    fibonacci = (phi**fibonacci_index - (phi - 1) ** fibonacci_index) / 5**0.5\n\n    return int(fibonacci)",
    "docstring": "For any given exponent x >= 0, 1 <= n <= 2^x.\nThis function returns how many Nim games are lost given that\neach Nim game has three heaps of the form (n, 2*n, 3*n).\n>>> solution(0)\n1\n>>> solution(2)\n3\n>>> solution(10)\n144"
  },
  {
    "function": "solve",
    "code": "def solve(arr: NDArray, row: int, cols: set[int], cache: dict[str, int]) -> int:\n    \"\"\"\n    Finds the max sum for array `arr` starting with row index `row`, and with columns\n    included in `cols`. `cache` is used for caching intermediate results.\n\n    >>> solve(arr=np.array([[1, 2], [3, 4]]), row=0, cols={0, 1}, cache={})\n    5\n    \"\"\"\n\n    cache_id = f\"{row}, {sorted(cols)}\"\n    if cache_id in cache:\n        return cache[cache_id]\n\n    if row == len(arr):\n        return 0\n\n    max_sum = 0\n    for col in cols:\n        new_cols = cols - {col}\n        max_sum = max(\n            max_sum,\n            int(arr[row, col])\n            + solve(arr=arr, row=row + 1, cols=new_cols, cache=cache),\n        )\n    cache[cache_id] = max_sum\n    return max_sum",
    "docstring": "Finds the max sum for array `arr` starting with row index `row`, and with columns\nincluded in `cols`. `cache` is used for caching intermediate results.\n\n>>> solve(arr=np.array([[1, 2], [3, 4]]), row=0, cols={0, 1}, cache={})\n5"
  },
  {
    "function": "solution",
    "code": "def solution(matrix_str: list[str] = MATRIX_2) -> int:\n    \"\"\"\n    Takes list of strings `matrix_str` to parse the matrix and calculates the max sum.\n\n    >>> solution([\"1 2\", \"3 4\"])\n    5\n    >>> solution(MATRIX_1)\n    3315\n    \"\"\"\n\n    n = len(matrix_str)\n    arr = np.empty(shape=(n, n), dtype=int)\n    for row, matrix_row_str in enumerate(matrix_str):\n        matrix_row_list_str = matrix_row_str.split()\n        for col, elem_str in enumerate(matrix_row_list_str):\n            arr[row, col] = int(elem_str)\n\n    cache: dict[str, int] = {}\n    return solve(arr=arr, row=0, cols=set(range(n)), cache=cache)",
    "docstring": "Takes list of strings `matrix_str` to parse the matrix and calculates the max sum.\n\n>>> solution([\"1 2\", \"3 4\"])\n5\n>>> solution(MATRIX_1)\n3315"
  },
  {
    "function": "solution",
    "code": "def solution(num_picks: int = 20) -> str:\n    \"\"\"\n    Calculates the expected number of distinct colours\n\n    >>> solution(10)\n    '5.669644129'\n\n    >>> solution(30)\n    '6.985042712'\n    \"\"\"\n    total = math.comb(NUM_BALLS, num_picks)\n    missing_colour = math.comb(NUM_BALLS - BALLS_PER_COLOUR, num_picks)\n\n    result = NUM_COLOURS * (1 - missing_colour / total)\n\n    return f\"{result:.9f}\"",
    "docstring": "Calculates the expected number of distinct colours\n\n>>> solution(10)\n'5.669644129'\n\n>>> solution(30)\n'6.985042712'"
  },
  {
    "function": "next_term",
    "code": "def next_term(a_i, k, i, n):\n    \"\"\"\n    Calculates and updates a_i in-place to either the n-th term or the\n    smallest term for which c > 10^k when the terms are written in the form:\n            a(i) = b * 10^k + c\n\n    For any a(i), if digitsum(b) and c have the same value, the difference\n    between subsequent terms will be the same until c >= 10^k.  This difference\n    is cached to greatly speed up the computation.\n\n    Arguments:\n    a_i -- array of digits starting from the one's place that represent\n           the i-th term in the sequence\n    k --  k when terms are written in the from a(i) = b*10^k + c.\n          Term are calulcated until c > 10^k or the n-th term is reached.\n    i -- position along the sequence\n    n -- term to calculate up to if k is large enough\n\n    Return: a tuple of difference between ending term and starting term, and\n    the number of terms calculated. ex. if starting term is a_0=1, and\n    ending term is a_10=62, then (61, 9) is returned.\n    \"\"\"\n    # ds_b - digitsum(b)\n    ds_b = sum(a_i[j] for j in range(k, len(a_i)))\n    c = sum(a_i[j] * base[j] for j in range(min(len(a_i), k)))\n\n    diff, dn = 0, 0\n    max_dn = n - i\n\n    sub_memo = memo.get(ds_b)\n\n    if sub_memo is not None:\n        jumps = sub_memo.get(c)\n\n        if jumps is not None and len(jumps) > 0:\n            # find and make the largest jump without going over\n            max_jump = -1\n            for _k in range(len(jumps) - 1, -1, -1):\n                if jumps[_k][2] <= k and jumps[_k][1] <= max_dn:\n                    max_jump = _k\n                    break\n\n            if max_jump >= 0:\n                diff, dn, _kk = jumps[max_jump]\n                # since the difference between jumps is cached, add c\n                new_c = diff + c\n                for j in range(min(k, len(a_i))):\n                    new_c, a_i[j] = divmod(new_c, 10)\n                if new_c > 0:\n                    add(a_i, k, new_c)\n\n        else:\n            sub_memo[c] = []\n    else:\n        sub_memo = {c: []}\n        memo[ds_b] = sub_memo\n\n    if dn >= max_dn or c + diff >= base[k]:\n        return diff, dn\n\n    if k > ks[0]:\n        while True:\n            # keep doing smaller jumps\n            _diff, terms_jumped = next_term(a_i, k - 1, i + dn, n)\n            diff += _diff\n            dn += terms_jumped\n\n            if dn >= max_dn or c + diff >= base[k]:\n                break\n    else:\n        # would be too small a jump, just compute sequential terms instead\n        _diff, terms_jumped = compute(a_i, k, i + dn, n)\n        diff += _diff\n        dn += terms_jumped\n\n    jumps = sub_memo[c]\n\n    # keep jumps sorted by # of terms skipped\n    j = 0\n    while j < len(jumps):\n        if jumps[j][1] > dn:\n            break\n        j += 1\n\n    # cache the jump for this value digitsum(b) and c\n    sub_memo[c].insert(j, (diff, dn, k))\n    return (diff, dn)",
    "docstring": "Calculates and updates a_i in-place to either the n-th term or the\nsmallest term for which c > 10^k when the terms are written in the form:\n        a(i) = b * 10^k + c\n\nFor any a(i), if digitsum(b) and c have the same value, the difference\nbetween subsequent terms will be the same until c >= 10^k.  This difference\nis cached to greatly speed up the computation.\n\nArguments:\na_i -- array of digits starting from the one's place that represent\n       the i-th term in the sequence\nk --  k when terms are written in the from a(i) = b*10^k + c.\n      Term are calulcated until c > 10^k or the n-th term is reached.\ni -- position along the sequence\nn -- term to calculate up to if k is large enough\n\nReturn: a tuple of difference between ending term and starting term, and\nthe number of terms calculated. ex. if starting term is a_0=1, and\nending term is a_10=62, then (61, 9) is returned."
  },
  {
    "function": "compute",
    "code": "def compute(a_i, k, i, n):\n    \"\"\"\n    same as next_term(a_i, k, i, n) but computes terms without memoizing results.\n    \"\"\"\n    if i >= n:\n        return 0, i\n    if k > len(a_i):\n        a_i.extend([0 for _ in range(k - len(a_i))])\n\n    # note: a_i -> b * 10^k + c\n    # ds_b -> digitsum(b)\n    # ds_c -> digitsum(c)\n    start_i = i\n    ds_b, ds_c, diff = 0, 0, 0\n    for j in range(len(a_i)):\n        if j >= k:\n            ds_b += a_i[j]\n        else:\n            ds_c += a_i[j]\n\n    while i < n:\n        i += 1\n        addend = ds_c + ds_b\n        diff += addend\n        ds_c = 0\n        for j in range(k):\n            s = a_i[j] + addend\n            addend, a_i[j] = divmod(s, 10)\n\n            ds_c += a_i[j]\n\n        if addend > 0:\n            break\n\n    if addend > 0:\n        add(a_i, k, addend)\n    return diff, i - start_i",
    "docstring": "same as next_term(a_i, k, i, n) but computes terms without memoizing results."
  },
  {
    "function": "add",
    "code": "def add(digits, k, addend):\n    \"\"\"\n    adds addend to digit array given in digits\n    starting at index k\n    \"\"\"\n    for j in range(k, len(digits)):\n        s = digits[j] + addend\n        if s >= 10:\n            quotient, digits[j] = divmod(s, 10)\n            addend = addend // 10 + quotient\n        else:\n            digits[j] = s\n            addend = addend // 10\n\n        if addend == 0:\n            break\n\n    while addend > 0:\n        addend, digit = divmod(addend, 10)\n        digits.append(digit)",
    "docstring": "adds addend to digit array given in digits\nstarting at index k"
  },
  {
    "function": "solution",
    "code": "def solution(n: int = 10**15) -> int:\n    \"\"\"\n    returns n-th term of sequence\n\n    >>> solution(10)\n    62\n\n    >>> solution(10**6)\n    31054319\n\n    >>> solution(10**15)\n    73597483551591773\n    \"\"\"\n\n    digits = [1]\n    i = 1\n    dn = 0\n    while True:\n        _diff, terms_jumped = next_term(digits, 20, i + dn, n)\n        dn += terms_jumped\n        if dn == n - i:\n            break\n\n    a_n = 0\n    for j in range(len(digits)):\n        a_n += digits[j] * 10**j\n    return a_n",
    "docstring": "returns n-th term of sequence\n\n>>> solution(10)\n62\n\n>>> solution(10**6)\n31054319\n\n>>> solution(10**15)\n73597483551591773"
  },
  {
    "function": "circle_bottom_arc_integral",
    "code": "def circle_bottom_arc_integral(point: float) -> float:\n    \"\"\"\n    Returns integral of circle bottom arc y = 1 / 2 - sqrt(1 / 4 - (x - 1 / 2) ^ 2)\n\n    >>> circle_bottom_arc_integral(0)\n    0.39269908169872414\n\n    >>> circle_bottom_arc_integral(1 / 2)\n    0.44634954084936207\n\n    >>> circle_bottom_arc_integral(1)\n    0.5\n    \"\"\"\n\n    return (\n        (1 - 2 * point) * sqrt(point - point**2) + 2 * point + asin(sqrt(1 - point))\n    ) / 4",
    "docstring": "Returns integral of circle bottom arc y = 1 / 2 - sqrt(1 / 4 - (x - 1 / 2) ^ 2)\n\n>>> circle_bottom_arc_integral(0)\n0.39269908169872414\n\n>>> circle_bottom_arc_integral(1 / 2)\n0.44634954084936207\n\n>>> circle_bottom_arc_integral(1)\n0.5"
  },
  {
    "function": "concave_triangle_area",
    "code": "def concave_triangle_area(circles_number: int) -> float:\n    \"\"\"\n    Returns area of concave triangle\n\n    >>> concave_triangle_area(1)\n    0.026825229575318944\n\n    >>> concave_triangle_area(2)\n    0.01956236140083944\n    \"\"\"\n\n    intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (\n        2 * (circles_number**2 + 1)\n    )\n    intersection_x = circles_number * intersection_y\n\n    triangle_area = intersection_x * intersection_y / 2\n    concave_region_area = circle_bottom_arc_integral(\n        1 / 2\n    ) - circle_bottom_arc_integral(intersection_x)\n\n    return triangle_area + concave_region_area",
    "docstring": "Returns area of concave triangle\n\n>>> concave_triangle_area(1)\n0.026825229575318944\n\n>>> concave_triangle_area(2)\n0.01956236140083944"
  },
  {
    "function": "solution",
    "code": "def solution(fraction: float = 1 / 1000) -> int:\n    \"\"\"\n    Returns least value of n\n    for which the concave triangle occupies less than fraction of the L-section\n\n    >>> solution(1 / 10)\n    15\n    \"\"\"\n\n    l_section_area = (1 - pi / 4) / 4\n\n    for n in count(1):\n        if concave_triangle_area(n) / l_section_area < fraction:\n            return n\n\n    return -1",
    "docstring": "Returns least value of n\nfor which the concave triangle occupies less than fraction of the L-section\n\n>>> solution(1 / 10)\n15"
  },
  {
    "function": "log_difference",
    "code": "def log_difference(number: int) -> float:\n    \"\"\"\n    This function returns the decimal value of a number multiplied with log(2)\n    Since the problem is on powers of two, finding the powers of two with\n    large exponents is time consuming. Hence we use log to reduce compute time.\n\n    We can find out that the first power of 2 with starting digits 123 is 90.\n    Computing 2^90 is time consuming.\n    Hence we find log(2^90) = 90*log(2) = 27.092699609758302\n    But we require only the decimal part to determine whether the power starts with 123.\n    So we just return the decimal part of the log product.\n    Therefore we return 0.092699609758302\n\n    >>> log_difference(90)\n    0.092699609758302\n    >>> log_difference(379)\n    0.090368356648852\n\n    \"\"\"\n\n    log_number = math.log(2, 10) * number\n    difference = round((log_number - int(log_number)), 15)\n\n    return difference",
    "docstring": "This function returns the decimal value of a number multiplied with log(2)\nSince the problem is on powers of two, finding the powers of two with\nlarge exponents is time consuming. Hence we use log to reduce compute time.\n\nWe can find out that the first power of 2 with starting digits 123 is 90.\nComputing 2^90 is time consuming.\nHence we find log(2^90) = 90*log(2) = 27.092699609758302\nBut we require only the decimal part to determine whether the power starts with 123.\nSo we just return the decimal part of the log product.\nTherefore we return 0.092699609758302\n\n>>> log_difference(90)\n0.092699609758302\n>>> log_difference(379)\n0.090368356648852"
  },
  {
    "function": "solution",
    "code": "def solution(number: int = 678910) -> int:\n    \"\"\"\n    This function calculates the power of two which is nth (n = number)\n    smallest value of power of 2\n    such that the starting digits of the 2^power is 123.\n\n    For example the powers of 2 for which starting digits is 123 are:\n    90, 379, 575, 864, 1060, 1545, 1741, 2030, 2226, 2515 and so on.\n    90 is the first power of 2 whose starting digits are 123,\n    379 is second power of 2 whose starting digits are 123,\n    and so on.\n\n    So if number = 10, then solution returns 2515 as we observe from above series.\n\n    We will define a lowerbound and upperbound.\n    lowerbound = log(1.23), upperbound = log(1.24)\n    because we need to find the powers that yield 123 as starting digits.\n\n    log(1.23) = 0.08990511143939792, log(1,24) = 0.09342168516223506.\n    We use 1.23 and not 12.3 or 123, because log(1.23) yields only decimal value\n    which is less than 1.\n    log(12.3) will be same decimal value but 1 added to it\n    which is log(12.3) = 1.093421685162235.\n    We observe that decimal value remains same no matter 1.23 or 12.3\n    Since we use the function log_difference(),\n    which returns the value that is only decimal part, using 1.23 is logical.\n\n    If we see, 90*log(2) = 27.092699609758302,\n    decimal part = 0.092699609758302, which is inside the range of lowerbound\n    and upperbound.\n\n    If we compute the difference between all the powers which lead to 123\n    starting digits is as follows:\n\n    379 - 90 = 289\n    575 - 379 = 196\n    864 - 575 = 289\n    1060 - 864 = 196\n\n    We see a pattern here. The difference is either 196 or 289 = 196 + 93.\n\n    Hence to optimize the algorithm we will increment by 196 or 93 depending upon the\n    log_difference() value.\n\n    Let's take for example 90.\n    Since 90 is the first power leading to staring digits as 123,\n    we will increment iterator by 196.\n    Because the difference between any two powers leading to 123\n    as staring digits is greater than or equal to 196.\n    After incrementing by 196 we get 286.\n\n    log_difference(286) = 0.09457875989861 which is greater than upperbound.\n    The next power is 379, and we need to add 93 to get there.\n    The iterator will now become 379,\n    which is the next power leading to 123 as starting digits.\n\n    Let's take 1060. We increment by 196, we get 1256.\n    log_difference(1256) = 0.09367455396034,\n    Which is greater than upperbound hence we increment by 93. Now iterator is 1349.\n    log_difference(1349) = 0.08946415071057 which is less than lowerbound.\n    The next power is 1545 and we need to add 196 to get 1545.\n\n    Conditions are as follows:\n\n    1) If we find a power whose log_difference() is in the range of\n    lower and upperbound, we will increment by 196.\n    which implies that the power is a number which will lead to 123 as starting digits.\n    2) If we find a power, whose log_difference() is greater than or equal upperbound,\n    we will increment by 93.\n    3) if log_difference() < lowerbound, we increment by 196.\n\n    Reference to the above logic:\n    https://math.stackexchange.com/questions/4093970/powers-of-2-starting-with-123-does-a-pattern-exist\n\n    >>> solution(1000)\n    284168\n\n    >>> solution(56000)\n    15924915\n\n    >>> solution(678910)\n    193060223\n\n    \"\"\"\n\n    power_iterator = 90\n    position = 0\n\n    lower_limit = math.log(1.23, 10)\n    upper_limit = math.log(1.24, 10)\n    previous_power = 0\n\n    while position < number:\n        difference = log_difference(power_iterator)\n\n        if difference >= upper_limit:\n            power_iterator += 93\n\n        elif difference < lower_limit:\n            power_iterator += 196\n\n        else:\n            previous_power = power_iterator\n            power_iterator += 196\n            position += 1\n\n    return previous_power",
    "docstring": "This function calculates the power of two which is nth (n = number)\nsmallest value of power of 2\nsuch that the starting digits of the 2^power is 123.\n\nFor example the powers of 2 for which starting digits is 123 are:\n90, 379, 575, 864, 1060, 1545, 1741, 2030, 2226, 2515 and so on.\n90 is the first power of 2 whose starting digits are 123,\n379 is second power of 2 whose starting digits are 123,\nand so on.\n\nSo if number = 10, then solution returns 2515 as we observe from above series.\n\nWe will define a lowerbound and upperbound.\nlowerbound = log(1.23), upperbound = log(1.24)\nbecause we need to find the powers that yield 123 as starting digits.\n\nlog(1.23) = 0.08990511143939792, log(1,24) = 0.09342168516223506.\nWe use 1.23 and not 12.3 or 123, because log(1.23) yields only decimal value\nwhich is less than 1.\nlog(12.3) will be same decimal value but 1 added to it\nwhich is log(12.3) = 1.093421685162235.\nWe observe that decimal value remains same no matter 1.23 or 12.3\nSince we use the function log_difference(),\nwhich returns the value that is only decimal part, using 1.23 is logical.\n\nIf we see, 90*log(2) = 27.092699609758302,\ndecimal part = 0.092699609758302, which is inside the range of lowerbound\nand upperbound.\n\nIf we compute the difference between all the powers which lead to 123\nstarting digits is as follows:\n\n379 - 90 = 289\n575 - 379 = 196\n864 - 575 = 289\n1060 - 864 = 196\n\nWe see a pattern here. The difference is either 196 or 289 = 196 + 93.\n\nHence to optimize the algorithm we will increment by 196 or 93 depending upon the\nlog_difference() value.\n\nLet's take for example 90.\nSince 90 is the first power leading to staring digits as 123,\nwe will increment iterator by 196.\nBecause the difference between any two powers leading to 123\nas staring digits is greater than or equal to 196.\nAfter incrementing by 196 we get 286.\n\nlog_difference(286) = 0.09457875989861 which is greater than upperbound.\nThe next power is 379, and we need to add 93 to get there.\nThe iterator will now become 379,\nwhich is the next power leading to 123 as starting digits.\n\nLet's take 1060. We increment by 196, we get 1256.\nlog_difference(1256) = 0.09367455396034,\nWhich is greater than upperbound hence we increment by 93. Now iterator is 1349.\nlog_difference(1349) = 0.08946415071057 which is less than lowerbound.\nThe next power is 1545 and we need to add 196 to get 1545.\n\nConditions are as follows:\n\n1) If we find a power whose log_difference() is in the range of\nlower and upperbound, we will increment by 196.\nwhich implies that the power is a number which will lead to 123 as starting digits.\n2) If we find a power, whose log_difference() is greater than or equal upperbound,\nwe will increment by 93.\n3) if log_difference() < lowerbound, we increment by 196.\n\nReference to the above logic:\nhttps://math.stackexchange.com/questions/4093970/powers-of-2-starting-with-123-does-a-pattern-exist\n\n>>> solution(1000)\n284168\n\n>>> solution(56000)\n15924915\n\n>>> solution(678910)\n193060223"
  },
  {
    "function": "calculate_prime_numbers",
    "code": "def calculate_prime_numbers(max_number: int) -> list[int]:\n    \"\"\"\n    Returns prime numbers below max_number\n\n    >>> calculate_prime_numbers(10)\n    [2, 3, 5, 7]\n    \"\"\"\n\n    is_prime = [True] * max_number\n    for i in range(2, isqrt(max_number - 1) + 1):\n        if is_prime[i]:\n            for j in range(i**2, max_number, i):\n                is_prime[j] = False\n\n    return [i for i in range(2, max_number) if is_prime[i]]",
    "docstring": "Returns prime numbers below max_number\n\n>>> calculate_prime_numbers(10)\n[2, 3, 5, 7]"
  },
  {
    "function": "solution",
    "code": "def solution(base: int = 800800, degree: int = 800800) -> int:\n    \"\"\"\n    Returns the number of hybrid-integers less than or equal to base^degree\n\n    >>> solution(800, 1)\n    2\n\n    >>> solution(800, 800)\n    10790\n    \"\"\"\n\n    upper_bound = degree * log2(base)\n    max_prime = int(upper_bound)\n    prime_numbers = calculate_prime_numbers(max_prime)\n\n    hybrid_integers_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left < right:\n        while (\n            prime_numbers[right] * log2(prime_numbers[left])\n            + prime_numbers[left] * log2(prime_numbers[right])\n            > upper_bound\n        ):\n            right -= 1\n        hybrid_integers_count += right - left\n        left += 1\n\n    return hybrid_integers_count",
    "docstring": "Returns the number of hybrid-integers less than or equal to base^degree\n\n>>> solution(800, 1)\n2\n\n>>> solution(800, 800)\n10790"
  },
  {
    "function": "quantum_fourier_transform",
    "code": "def quantum_fourier_transform(number_of_qubits: int = 3) -> qiskit.result.counts.Counts:\n    \"\"\"\n    # >>> quantum_fourier_transform(2)\n    # {'00': 2500, '01': 2500, '11': 2500, '10': 2500}\n    # quantum circuit for number_of_qubits = 3:\n                                               \u250c\u2500\u2500\u2500\u2510\n    qr_0: \u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500X\u2500\n                \u2502                \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/2) \u2514\u2500\u2500\u2500\u2518 \u2502\n    qr_1: \u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\n          \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/4)  \u2502P(\u03c0/2) \u2514\u2500\u2500\u2500\u2518               \u2502\n    qr_2: \u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500\n          \u2514\u2500\u2500\u2500\u2518\n    cr: 3/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    Args:\n        n : number of qubits\n    Returns:\n        qiskit.result.counts.Counts: distribute counts.\n\n    >>> quantum_fourier_transform(2)\n    {'00': 2500, '01': 2500, '10': 2500, '11': 2500}\n    >>> quantum_fourier_transform(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number of qubits must be > 0.\n    >>> quantum_fourier_transform('a')\n    Traceback (most recent call last):\n        ...\n    TypeError: number of qubits must be a integer.\n    >>> quantum_fourier_transform(100)\n    Traceback (most recent call last):\n        ...\n    ValueError: number of qubits too large to simulate(>10).\n    >>> quantum_fourier_transform(0.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: number of qubits must be exact integer.\n    \"\"\"\n    if isinstance(number_of_qubits, str):\n        raise TypeError(\"number of qubits must be a integer.\")\n    if number_of_qubits <= 0:\n        raise ValueError(\"number of qubits must be > 0.\")\n    if math.floor(number_of_qubits) != number_of_qubits:\n        raise ValueError(\"number of qubits must be exact integer.\")\n    if number_of_qubits > 10:\n        raise ValueError(\"number of qubits too large to simulate(>10).\")\n\n    qr = QuantumRegister(number_of_qubits, \"qr\")\n    cr = ClassicalRegister(number_of_qubits, \"cr\")\n\n    quantum_circuit = QuantumCircuit(qr, cr)\n\n    counter = number_of_qubits\n\n    for i in range(counter):\n        quantum_circuit.h(number_of_qubits - i - 1)\n        counter -= 1\n        for j in range(counter):\n            quantum_circuit.cp(np.pi / 2 ** (counter - j), j, counter)\n\n    for k in range(number_of_qubits // 2):\n        quantum_circuit.swap(k, number_of_qubits - k - 1)\n\n    # measure all the qubits\n    quantum_circuit.measure(qr, cr)\n    # simulate with 10000 shots\n    backend = Aer.get_backend(\"qasm_simulator\")\n    job = execute(quantum_circuit, backend, shots=10000)\n\n    return job.result().get_counts(quantum_circuit)",
    "docstring": "# >>> quantum_fourier_transform(2)\n# {'00': 2500, '01': 2500, '11': 2500, '10': 2500}\n# quantum circuit for number_of_qubits = 3:\n                                           \u250c\u2500\u2500\u2500\u2510\nqr_0: \u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500X\u2500\n            \u2502                \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/2) \u2514\u2500\u2500\u2500\u2518 \u2502\nqr_1: \u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\n      \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/4)  \u2502P(\u03c0/2) \u2514\u2500\u2500\u2500\u2518               \u2502\nqr_2: \u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500\n      \u2514\u2500\u2500\u2500\u2518\ncr: 3/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nArgs:\n    n : number of qubits\nReturns:\n    qiskit.result.counts.Counts: distribute counts.\n\n>>> quantum_fourier_transform(2)\n{'00': 2500, '01': 2500, '10': 2500, '11': 2500}\n>>> quantum_fourier_transform(-1)\nTraceback (most recent call last):\n    ...\nValueError: number of qubits must be > 0.\n>>> quantum_fourier_transform('a')\nTraceback (most recent call last):\n    ...\nTypeError: number of qubits must be a integer.\n>>> quantum_fourier_transform(100)\nTraceback (most recent call last):\n    ...\nValueError: number of qubits too large to simulate(>10).\n>>> quantum_fourier_transform(0.5)\nTraceback (most recent call last):\n    ...\nValueError: number of qubits must be exact integer."
  },
  {
    "function": "calculate_waiting_times",
    "code": "def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times",
    "docstring": "This function calculates the waiting time of some processes that have a\nspecified duration time.\n    Return: The waiting time for each process.\n>>> calculate_waiting_times([5, 10, 15])\n[0, 5, 15]\n>>> calculate_waiting_times([1, 2, 3, 4, 5])\n[0, 1, 3, 6, 10]\n>>> calculate_waiting_times([10, 3])\n[0, 10]"
  },
  {
    "function": "calculate_turnaround_times",
    "code": "def calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]",
    "docstring": "This function calculates the turnaround time of some processes.\n    Return: The time difference between the completion time and the\n            arrival time.\n            Practically waiting_time + duration_time\n>>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n[5, 15, 30]\n>>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n[1, 3, 6, 10, 15]\n>>> calculate_turnaround_times([10, 3], [0, 10])\n[10, 13]"
  },
  {
    "function": "calculate_average_turnaround_time",
    "code": "def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)",
    "docstring": "This function calculates the average of the turnaround times\n    Return: The average of the turnaround times.\n>>> calculate_average_turnaround_time([0, 5, 16])\n7.0\n>>> calculate_average_turnaround_time([1, 5, 8, 12])\n6.5\n>>> calculate_average_turnaround_time([10, 24])\n17.0"
  },
  {
    "function": "calculate_average_waiting_time",
    "code": "def calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)",
    "docstring": "This function calculates the average of the waiting times\n    Return: The average of the waiting times.\n>>> calculate_average_waiting_time([0, 5, 16])\n7.0\n>>> calculate_average_waiting_time([1, 5, 8, 12])\n6.5\n>>> calculate_average_waiting_time([10, 24])\n17.0"
  },
  {
    "function": "calculate_turn_around_time",
    "code": "def calculate_turn_around_time(\n    process_name: list, arrival_time: list, burst_time: list, no_of_process: int\n) -> list:\n    \"\"\"\n    Calculate the turn around time of each processes\n\n    Return: The turn around time time for each process.\n    >>> calculate_turn_around_time([\"A\", \"B\", \"C\"], [3, 5, 8], [2, 4, 6], 3)\n    [2, 4, 7]\n    >>> calculate_turn_around_time([\"A\", \"B\", \"C\"], [0, 2, 4], [3, 5, 7], 3)\n    [3, 6, 11]\n    \"\"\"\n\n    current_time = 0\n    # Number of processes finished\n    finished_process_count = 0\n    # Displays the finished process.\n    # If it is 0, the performance is completed if it is 1, before the performance.\n    finished_process = [0] * no_of_process\n    # List to include calculation results\n    turn_around_time = [0] * no_of_process\n\n    # Sort by arrival time.\n    burst_time = [burst_time[i] for i in np.argsort(arrival_time)]\n    process_name = [process_name[i] for i in np.argsort(arrival_time)]\n    arrival_time.sort()\n\n    while no_of_process > finished_process_count:\n        \"\"\"\n        If the current time is less than the arrival time of\n        the process that arrives first among the processes that have not been performed,\n        change the current time.\n        \"\"\"\n        i = 0\n        while finished_process[i] == 1:\n            i += 1\n        current_time = max(current_time, arrival_time[i])\n\n        response_ratio = 0\n        # Index showing the location of the process being performed\n        loc = 0\n        # Saves the current response ratio.\n        temp = 0\n        for i in range(no_of_process):\n            if finished_process[i] == 0 and arrival_time[i] <= current_time:\n                temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[\n                    i\n                ]\n            if response_ratio < temp:\n                response_ratio = temp\n                loc = i\n\n        # Calculate the turn around time\n        turn_around_time[loc] = current_time + burst_time[loc] - arrival_time[loc]\n        current_time += burst_time[loc]\n        # Indicates that the process has been performed.\n        finished_process[loc] = 1\n        # Increase finished_process_count by 1\n        finished_process_count += 1\n\n    return turn_around_time",
    "docstring": "Calculate the turn around time of each processes\n\nReturn: The turn around time time for each process.\n>>> calculate_turn_around_time([\"A\", \"B\", \"C\"], [3, 5, 8], [2, 4, 6], 3)\n[2, 4, 7]\n>>> calculate_turn_around_time([\"A\", \"B\", \"C\"], [0, 2, 4], [3, 5, 7], 3)\n[3, 6, 11]"
  },
  {
    "function": "calculate_waiting_time",
    "code": "def calculate_waiting_time(\n    process_name: list,  # noqa: ARG001\n    turn_around_time: list,\n    burst_time: list,\n    no_of_process: int,\n) -> list:\n    \"\"\"\n    Calculate the waiting time of each processes.\n\n    Return: The waiting time for each process.\n    >>> calculate_waiting_time([\"A\", \"B\", \"C\"], [2, 4, 7], [2, 4, 6], 3)\n    [0, 0, 1]\n    >>> calculate_waiting_time([\"A\", \"B\", \"C\"], [3, 6, 11], [3, 5, 7], 3)\n    [0, 1, 4]\n    \"\"\"\n\n    waiting_time = [0] * no_of_process\n    for i in range(no_of_process):\n        waiting_time[i] = turn_around_time[i] - burst_time[i]\n    return waiting_time",
    "docstring": "Calculate the waiting time of each processes.\n\nReturn: The waiting time for each process.\n>>> calculate_waiting_time([\"A\", \"B\", \"C\"], [2, 4, 7], [2, 4, 6], 3)\n[0, 0, 1]\n>>> calculate_waiting_time([\"A\", \"B\", \"C\"], [3, 6, 11], [3, 5, 7], 3)\n[0, 1, 4]"
  },
  {
    "function": "max_tasks",
    "code": "def max_tasks(tasks_info: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    Create a list of Task objects that are sorted so the highest rewards come first.\n    Return a list of those task ids that can be completed before i becomes too high.\n    >>> max_tasks([(4, 20), (1, 10), (1, 40), (1, 30)])\n    [2, 0]\n    >>> max_tasks([(1, 10), (2, 20), (3, 30), (2, 40)])\n    [3, 2]\n    >>> max_tasks([(9, 10)])\n    [0]\n    >>> max_tasks([(-9, 10)])\n    []\n    >>> max_tasks([])\n    []\n    >>> max_tasks([(0, 10), (0, 20), (0, 30), (0, 40)])\n    []\n    >>> max_tasks([(-1, 10), (-2, 20), (-3, 30), (-4, 40)])\n    []\n    \"\"\"\n    tasks = sorted(\n        (\n            Task(task_id, deadline, reward)\n            for task_id, (deadline, reward) in enumerate(tasks_info)\n        ),\n        key=attrgetter(\"reward\"),\n        reverse=True,\n    )\n    return [task.task_id for i, task in enumerate(tasks, start=1) if task.deadline >= i]",
    "docstring": "Create a list of Task objects that are sorted so the highest rewards come first.\nReturn a list of those task ids that can be completed before i becomes too high.\n>>> max_tasks([(4, 20), (1, 10), (1, 40), (1, 30)])\n[2, 0]\n>>> max_tasks([(1, 10), (2, 20), (3, 30), (2, 40)])\n[3, 2]\n>>> max_tasks([(9, 10)])\n[0]\n>>> max_tasks([(-9, 10)])\n[]\n>>> max_tasks([])\n[]\n>>> max_tasks([(0, 10), (0, 20), (0, 30), (0, 40)])\n[]\n>>> max_tasks([(-1, 10), (-2, 20), (-3, 30), (-4, 40)])\n[]"
  },
  {
    "function": "job_sequencing_with_deadlines",
    "code": "def job_sequencing_with_deadlines(jobs: list) -> list:\n    \"\"\"\n    Function to find the maximum profit by doing jobs in a given time frame\n\n    Args:\n        jobs [list]: A list of tuples of (job_id, deadline, profit)\n\n    Returns:\n        max_profit [int]: Maximum profit that can be earned by doing jobs\n        in a given time frame\n\n    Examples:\n    >>> job_sequencing_with_deadlines(\n    ... [(1, 4, 20), (2, 1, 10), (3, 1, 40), (4, 1, 30)])\n    [2, 60]\n    >>> job_sequencing_with_deadlines(\n    ... [(1, 2, 100), (2, 1, 19), (3, 2, 27), (4, 1, 25), (5, 1, 15)])\n    [2, 127]\n    \"\"\"\n\n    # Sort the jobs in descending order of profit\n    jobs = sorted(jobs, key=lambda value: value[2], reverse=True)\n\n    # Create a list of size equal to the maximum deadline\n    # and initialize it with -1\n    max_deadline = max(jobs, key=lambda value: value[1])[1]\n    time_slots = [-1] * max_deadline\n\n    # Finding the maximum profit and the count of jobs\n    count = 0\n    max_profit = 0\n    for job in jobs:\n        # Find a free time slot for this job\n        # (Note that we start from the last possible slot)\n        for i in range(job[1] - 1, -1, -1):\n            if time_slots[i] == -1:\n                time_slots[i] = job[0]\n                count += 1\n                max_profit += job[2]\n                break\n    return [count, max_profit]",
    "docstring": "Function to find the maximum profit by doing jobs in a given time frame\n\nArgs:\n    jobs [list]: A list of tuples of (job_id, deadline, profit)\n\nReturns:\n    max_profit [int]: Maximum profit that can be earned by doing jobs\n    in a given time frame\n\nExamples:\n>>> job_sequencing_with_deadlines(\n... [(1, 4, 20), (2, 1, 10), (3, 1, 40), (4, 1, 30)])\n[2, 60]\n>>> job_sequencing_with_deadlines(\n... [(1, 2, 100), (2, 1, 19), (3, 2, 27), (4, 1, 25), (5, 1, 15)])\n[2, 127]"
  },
  {
    "function": "calculate_waitingtime",
    "code": "def calculate_waitingtime(\n    arrival_time: list[int], burst_time: list[int], no_of_processes: int\n) -> list[int]:\n    \"\"\"\n    Calculate the waiting time of each processes\n\n    Return: The waiting time for each process.\n    >>> calculate_waitingtime([0,1,2], [10, 5, 8], 3)\n    [0, 9, 13]\n    >>> calculate_waitingtime([1,2,2,4], [4, 6, 3, 1], 4)\n    [0, 7, 4, 1]\n    >>> calculate_waitingtime([0,0,0], [12, 2, 10],3)\n    [12, 0, 2]\n    \"\"\"\n\n    waiting_time = [0] * no_of_processes\n    remaining_time = [0] * no_of_processes\n\n    # Initialize remaining_time to waiting_time.\n\n    for i in range(no_of_processes):\n        remaining_time[i] = burst_time[i]\n    ready_process: list[int] = []\n\n    completed = 0\n    total_time = 0\n\n    # When processes are not completed,\n    # A process whose arrival time has passed \\\n    # and has remaining execution time is put into the ready_process.\n    # The shortest process in the ready_process, target_process is executed.\n\n    while completed != no_of_processes:\n        ready_process = []\n        target_process = -1\n\n        for i in range(no_of_processes):\n            if (arrival_time[i] <= total_time) and (remaining_time[i] > 0):\n                ready_process.append(i)\n\n        if len(ready_process) > 0:\n            target_process = ready_process[0]\n            for i in ready_process:\n                if remaining_time[i] < remaining_time[target_process]:\n                    target_process = i\n            total_time += burst_time[target_process]\n            completed += 1\n            remaining_time[target_process] = 0\n            waiting_time[target_process] = (\n                total_time - arrival_time[target_process] - burst_time[target_process]\n            )\n        else:\n            total_time += 1\n\n    return waiting_time",
    "docstring": "Calculate the waiting time of each processes\n\nReturn: The waiting time for each process.\n>>> calculate_waitingtime([0,1,2], [10, 5, 8], 3)\n[0, 9, 13]\n>>> calculate_waitingtime([1,2,2,4], [4, 6, 3, 1], 4)\n[0, 7, 4, 1]\n>>> calculate_waitingtime([0,0,0], [12, 2, 10],3)\n[12, 0, 2]"
  },
  {
    "function": "calculate_turnaroundtime",
    "code": "def calculate_turnaroundtime(\n    burst_time: list[int], no_of_processes: int, waiting_time: list[int]\n) -> list[int]:\n    \"\"\"\n    Calculate the turnaround time of each process.\n\n    Return: The turnaround time for each process.\n    >>> calculate_turnaroundtime([0,1,2], 3, [0, 10, 15])\n    [0, 11, 17]\n    >>> calculate_turnaroundtime([1,2,2,4], 4, [1, 8, 5, 4])\n    [2, 10, 7, 8]\n    >>> calculate_turnaroundtime([0,0,0], 3, [12, 0, 2])\n    [12, 0, 2]\n    \"\"\"\n\n    turn_around_time = [0] * no_of_processes\n    for i in range(no_of_processes):\n        turn_around_time[i] = burst_time[i] + waiting_time[i]\n    return turn_around_time",
    "docstring": "Calculate the turnaround time of each process.\n\nReturn: The turnaround time for each process.\n>>> calculate_turnaroundtime([0,1,2], 3, [0, 10, 15])\n[0, 11, 17]\n>>> calculate_turnaroundtime([1,2,2,4], 4, [1, 8, 5, 4])\n[2, 10, 7, 8]\n>>> calculate_turnaroundtime([0,0,0], 3, [12, 0, 2])\n[12, 0, 2]"
  },
  {
    "function": "calculate_waiting_times",
    "code": "def calculate_waiting_times(burst_times: list[int]) -> list[int]:\n    \"\"\"\n    Calculate the waiting times of a list of processes that have a specified duration.\n\n    Return: The waiting time for each process.\n    >>> calculate_waiting_times([10, 5, 8])\n    [13, 10, 13]\n    >>> calculate_waiting_times([4, 6, 3, 1])\n    [5, 8, 9, 6]\n    >>> calculate_waiting_times([12, 2, 10])\n    [12, 2, 12]\n    \"\"\"\n    quantum = 2\n    rem_burst_times = list(burst_times)\n    waiting_times = [0] * len(burst_times)\n    t = 0\n    while True:\n        done = True\n        for i, burst_time in enumerate(burst_times):\n            if rem_burst_times[i] > 0:\n                done = False\n                if rem_burst_times[i] > quantum:\n                    t += quantum\n                    rem_burst_times[i] -= quantum\n                else:\n                    t += rem_burst_times[i]\n                    waiting_times[i] = t - burst_time\n                    rem_burst_times[i] = 0\n        if done is True:\n            return waiting_times",
    "docstring": "Calculate the waiting times of a list of processes that have a specified duration.\n\nReturn: The waiting time for each process.\n>>> calculate_waiting_times([10, 5, 8])\n[13, 10, 13]\n>>> calculate_waiting_times([4, 6, 3, 1])\n[5, 8, 9, 6]\n>>> calculate_waiting_times([12, 2, 10])\n[12, 2, 12]"
  },
  {
    "function": "calculate_turn_around_times",
    "code": "def calculate_turn_around_times(\n    burst_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\n    [1, 3, 6]\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\n    [20, 9, 18]\n    \"\"\"\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]",
    "docstring": ">>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\n[1, 3, 6]\n>>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\n[20, 9, 18]"
  },
  {
    "function": "calculate_waitingtime",
    "code": "def calculate_waitingtime(\n    arrival_time: list[int], burst_time: list[int], no_of_processes: int\n) -> list[int]:\n    \"\"\"\n    Calculate the waiting time of each processes\n    Return: List of waiting times.\n    >>> calculate_waitingtime([1,2,3,4],[3,3,5,1],4)\n    [0, 3, 5, 0]\n    >>> calculate_waitingtime([1,2,3],[2,5,1],3)\n    [0, 2, 0]\n    >>> calculate_waitingtime([2,3],[5,1],2)\n    [1, 0]\n    \"\"\"\n    remaining_time = [0] * no_of_processes\n    waiting_time = [0] * no_of_processes\n    # Copy the burst time into remaining_time[]\n    for i in range(no_of_processes):\n        remaining_time[i] = burst_time[i]\n\n    complete = 0\n    increment_time = 0\n    minm = 999999999\n    short = 0\n    check = False\n\n    # Process until all processes are completed\n    while complete != no_of_processes:\n        for j in range(no_of_processes):\n            if (\n                arrival_time[j] <= increment_time\n                and remaining_time[j] > 0\n                and remaining_time[j] < minm\n            ):\n                minm = remaining_time[j]\n                short = j\n                check = True\n\n        if not check:\n            increment_time += 1\n            continue\n        remaining_time[short] -= 1\n\n        minm = remaining_time[short]\n        if minm == 0:\n            minm = 999999999\n\n        if remaining_time[short] == 0:\n            complete += 1\n            check = False\n\n            # Find finish time of current process\n            finish_time = increment_time + 1\n\n            # Calculate waiting time\n            finar = finish_time - arrival_time[short]\n            waiting_time[short] = finar - burst_time[short]\n\n            waiting_time[short] = max(waiting_time[short], 0)\n\n        # Increment time\n        increment_time += 1\n    return waiting_time",
    "docstring": "Calculate the waiting time of each processes\nReturn: List of waiting times.\n>>> calculate_waitingtime([1,2,3,4],[3,3,5,1],4)\n[0, 3, 5, 0]\n>>> calculate_waitingtime([1,2,3],[2,5,1],3)\n[0, 2, 0]\n>>> calculate_waitingtime([2,3],[5,1],2)\n[1, 0]"
  },
  {
    "function": "calculate_turnaroundtime",
    "code": "def calculate_turnaroundtime(\n    burst_time: list[int], no_of_processes: int, waiting_time: list[int]\n) -> list[int]:\n    \"\"\"\n    Calculate the turn around time of each Processes\n    Return: list of turn around times.\n    >>> calculate_turnaroundtime([3,3,5,1], 4, [0,3,5,0])\n    [3, 6, 10, 1]\n    >>> calculate_turnaroundtime([3,3], 2, [0,3])\n    [3, 6]\n    >>> calculate_turnaroundtime([8,10,1], 3, [1,0,3])\n    [9, 10, 4]\n    \"\"\"\n    turn_around_time = [0] * no_of_processes\n    for i in range(no_of_processes):\n        turn_around_time[i] = burst_time[i] + waiting_time[i]\n    return turn_around_time",
    "docstring": "Calculate the turn around time of each Processes\nReturn: list of turn around times.\n>>> calculate_turnaroundtime([3,3,5,1], 4, [0,3,5,0])\n[3, 6, 10, 1]\n>>> calculate_turnaroundtime([3,3], 2, [0,3])\n[3, 6]\n>>> calculate_turnaroundtime([8,10,1], 3, [1,0,3])\n[9, 10, 4]"
  },
  {
    "function": "calculate_average_times",
    "code": "def calculate_average_times(\n    waiting_time: list[int], turn_around_time: list[int], no_of_processes: int\n) -> None:\n    \"\"\"\n    This function calculates the average of the waiting & turnaround times\n    Prints: Average Waiting time & Average Turn Around Time\n    >>> calculate_average_times([0,3,5,0],[3,6,10,1],4)\n    Average waiting time = 2.00000\n    Average turn around time = 5.0\n    >>> calculate_average_times([2,3],[3,6],2)\n    Average waiting time = 2.50000\n    Average turn around time = 4.5\n    >>> calculate_average_times([10,4,3],[2,7,6],3)\n    Average waiting time = 5.66667\n    Average turn around time = 5.0\n    \"\"\"\n    total_waiting_time = 0\n    total_turn_around_time = 0\n    for i in range(no_of_processes):\n        total_waiting_time = total_waiting_time + waiting_time[i]\n        total_turn_around_time = total_turn_around_time + turn_around_time[i]\n    print(f\"Average waiting time = {total_waiting_time / no_of_processes:.5f}\")\n    print(\"Average turn around time =\", total_turn_around_time / no_of_processes)",
    "docstring": "This function calculates the average of the waiting & turnaround times\nPrints: Average Waiting time & Average Turn Around Time\n>>> calculate_average_times([0,3,5,0],[3,6,10,1],4)\nAverage waiting time = 2.00000\nAverage turn around time = 5.0\n>>> calculate_average_times([2,3],[3,6],2)\nAverage waiting time = 2.50000\nAverage turn around time = 4.5\n>>> calculate_average_times([10,4,3],[2,7,6],3)\nAverage waiting time = 5.66667\nAverage turn around time = 5.0"
  },
  {
    "function": "md_prefix",
    "code": "def md_prefix(indent: int) -> str:\n    \"\"\"\n    Markdown prefix based on indent for bullet points\n\n    >>> md_prefix(0)\n    '\\\\n##'\n    >>> md_prefix(1)\n    '  *'\n    >>> md_prefix(2)\n    '    *'\n    >>> md_prefix(3)\n    '      *'\n    \"\"\"\n    return f\"{indent * '  '}*\" if indent else \"\\n##\"",
    "docstring": "Markdown prefix based on indent for bullet points\n\n>>> md_prefix(0)\n'\\n##'\n>>> md_prefix(1)\n'  *'\n>>> md_prefix(2)\n'    *'\n>>> md_prefix(3)\n'      *'"
  },
  {
    "function": "convert_path_to_module",
    "code": "def convert_path_to_module(file_path: pathlib.Path) -> ModuleType:\n    \"\"\"Converts a file path to a Python module\"\"\"\n    spec = importlib.util.spec_from_file_location(file_path.name, str(file_path))\n    module = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]\n    spec.loader.exec_module(module)  # type: ignore[union-attr]\n    return module",
    "docstring": "Converts a file path to a Python module"
  },
  {
    "function": "all_solution_file_paths",
    "code": "def all_solution_file_paths() -> list[pathlib.Path]:\n    \"\"\"Collects all the solution file path in the Project Euler directory\"\"\"\n    solution_file_paths = []\n    for problem_dir_path in PROJECT_EULER_DIR_PATH.iterdir():\n        if problem_dir_path.is_file() or problem_dir_path.name.startswith(\"_\"):\n            continue\n        for file_path in problem_dir_path.iterdir():\n            if file_path.suffix != \".py\" or file_path.name.startswith((\"_\", \"test\")):\n                continue\n            solution_file_paths.append(file_path)\n    return solution_file_paths",
    "docstring": "Collects all the solution file path in the Project Euler directory"
  },
  {
    "function": "get_files_url",
    "code": "def get_files_url() -> str:\n    \"\"\"Return the pull request number which triggered this action.\"\"\"\n    with open(os.environ[\"GITHUB_EVENT_PATH\"]) as file:\n        event = json.load(file)\n    return event[\"pull_request\"][\"url\"] + \"/files\"",
    "docstring": "Return the pull request number which triggered this action."
  },
  {
    "function": "added_solution_file_path",
    "code": "def added_solution_file_path() -> list[pathlib.Path]:\n    \"\"\"Collects only the solution file path which got added in the current\n    pull request.\n\n    This will only be triggered if the script is ran from GitHub Actions.\n    \"\"\"\n    solution_file_paths = []\n    headers = {\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Authorization\": \"token \" + os.environ[\"GITHUB_TOKEN\"],\n    }\n    files = httpx.get(get_files_url(), headers=headers, timeout=10).json()\n    for file in files:\n        filepath = pathlib.Path.cwd().joinpath(file[\"filename\"])\n        if (\n            filepath.suffix != \".py\"\n            or filepath.name.startswith((\"_\", \"test\"))\n            or not filepath.name.startswith(\"sol\")\n        ):\n            continue\n        solution_file_paths.append(filepath)\n    return solution_file_paths",
    "docstring": "Collects only the solution file path which got added in the current\npull request.\n\nThis will only be triggered if the script is ran from GitHub Actions."
  },
  {
    "function": "test_project_euler",
    "code": "def test_project_euler(solution_path: pathlib.Path) -> None:\n    \"\"\"Testing for all Project Euler solutions\"\"\"\n    # problem_[extract this part] and pad it with zeroes for width 3\n    problem_number: str = solution_path.parent.name[8:].zfill(3)\n    expected: str = PROBLEM_ANSWERS[problem_number]\n    solution_module = convert_path_to_module(solution_path)\n    answer = str(solution_module.solution())\n    answer = hashlib.sha256(answer.encode()).hexdigest()\n    assert answer == expected, (\n        f\"Expected solution to {problem_number} to have hash {expected}, got {answer}\"\n    )",
    "docstring": "Testing for all Project Euler solutions"
  },
  {
    "function": "bisect_left",
    "code": "def bisect_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo",
    "docstring": "Locates the first element in a sorted array that is larger or equal to a given\nvalue.\n\nIt has the same interface as\nhttps://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n:param sorted_collection: some ascending sorted collection with comparable items\n:param item: item to bisect\n:param lo: lowest index to consider (as in sorted_collection[lo:hi])\n:param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n:return: index i such that all values in sorted_collection[lo:i] are < item and all\n    values in sorted_collection[i:hi] are >= item.\n\nExamples:\n>>> bisect_left([0, 5, 7, 10, 15], 0)\n0\n>>> bisect_left([0, 5, 7, 10, 15], 6)\n2\n>>> bisect_left([0, 5, 7, 10, 15], 20)\n5\n>>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n3\n>>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n2"
  },
  {
    "function": "bisect_right",
    "code": "def bisect_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo",
    "docstring": "Locates the first element in a sorted array that is larger than a given value.\n\nIt has the same interface as\nhttps://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n:param sorted_collection: some ascending sorted collection with comparable items\n:param item: item to bisect\n:param lo: lowest index to consider (as in sorted_collection[lo:hi])\n:param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n:return: index i such that all values in sorted_collection[lo:i] are <= item and\n    all values in sorted_collection[i:hi] are > item.\n\nExamples:\n>>> bisect_right([0, 5, 7, 10, 15], 0)\n1\n>>> bisect_right([0, 5, 7, 10, 15], 15)\n5\n>>> bisect_right([0, 5, 7, 10, 15], 6)\n2\n>>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n3\n>>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n2"
  },
  {
    "function": "insort_left",
    "code": "def insort_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> None:\n    \"\"\"\n    Inserts a given value into a sorted array before other values with the same value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.insort_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to insert\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n\n    Examples:\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_left(sorted_collection, 6)\n    >>> sorted_collection\n    [0, 5, 6, 7, 10, 15]\n    >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item = (5, 5)\n    >>> insort_left(sorted_collection, item)\n    >>> sorted_collection\n    [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item is sorted_collection[1]\n    True\n    >>> item is sorted_collection[2]\n    False\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_left(sorted_collection, 20)\n    >>> sorted_collection\n    [0, 5, 7, 10, 15, 20]\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_left(sorted_collection, 15, 1, 3)\n    >>> sorted_collection\n    [0, 5, 7, 15, 10, 15]\n    \"\"\"\n    sorted_collection.insert(bisect_left(sorted_collection, item, lo, hi), item)",
    "docstring": "Inserts a given value into a sorted array before other values with the same value.\n\nIt has the same interface as\nhttps://docs.python.org/3/library/bisect.html#bisect.insort_left .\n\n:param sorted_collection: some ascending sorted collection with comparable items\n:param item: item to insert\n:param lo: lowest index to consider (as in sorted_collection[lo:hi])\n:param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n\nExamples:\n>>> sorted_collection = [0, 5, 7, 10, 15]\n>>> insort_left(sorted_collection, 6)\n>>> sorted_collection\n[0, 5, 6, 7, 10, 15]\n>>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]\n>>> item = (5, 5)\n>>> insort_left(sorted_collection, item)\n>>> sorted_collection\n[(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]\n>>> item is sorted_collection[1]\nTrue\n>>> item is sorted_collection[2]\nFalse\n>>> sorted_collection = [0, 5, 7, 10, 15]\n>>> insort_left(sorted_collection, 20)\n>>> sorted_collection\n[0, 5, 7, 10, 15, 20]\n>>> sorted_collection = [0, 5, 7, 10, 15]\n>>> insort_left(sorted_collection, 15, 1, 3)\n>>> sorted_collection\n[0, 5, 7, 15, 10, 15]"
  },
  {
    "function": "insort_right",
    "code": "def insort_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> None:\n    \"\"\"\n    Inserts a given value into a sorted array after other values with the same value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.insort_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to insert\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n\n    Examples:\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_right(sorted_collection, 6)\n    >>> sorted_collection\n    [0, 5, 6, 7, 10, 15]\n    >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item = (5, 5)\n    >>> insort_right(sorted_collection, item)\n    >>> sorted_collection\n    [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item is sorted_collection[1]\n    False\n    >>> item is sorted_collection[2]\n    True\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_right(sorted_collection, 20)\n    >>> sorted_collection\n    [0, 5, 7, 10, 15, 20]\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_right(sorted_collection, 15, 1, 3)\n    >>> sorted_collection\n    [0, 5, 7, 15, 10, 15]\n    \"\"\"\n    sorted_collection.insert(bisect_right(sorted_collection, item, lo, hi), item)",
    "docstring": "Inserts a given value into a sorted array after other values with the same value.\n\nIt has the same interface as\nhttps://docs.python.org/3/library/bisect.html#bisect.insort_right .\n\n:param sorted_collection: some ascending sorted collection with comparable items\n:param item: item to insert\n:param lo: lowest index to consider (as in sorted_collection[lo:hi])\n:param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n\nExamples:\n>>> sorted_collection = [0, 5, 7, 10, 15]\n>>> insort_right(sorted_collection, 6)\n>>> sorted_collection\n[0, 5, 6, 7, 10, 15]\n>>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]\n>>> item = (5, 5)\n>>> insort_right(sorted_collection, item)\n>>> sorted_collection\n[(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]\n>>> item is sorted_collection[1]\nFalse\n>>> item is sorted_collection[2]\nTrue\n>>> sorted_collection = [0, 5, 7, 10, 15]\n>>> insort_right(sorted_collection, 20)\n>>> sorted_collection\n[0, 5, 7, 10, 15, 20]\n>>> sorted_collection = [0, 5, 7, 10, 15]\n>>> insort_right(sorted_collection, 15, 1, 3)\n>>> sorted_collection\n[0, 5, 7, 15, 10, 15]"
  },
  {
    "function": "binary_search",
    "code": "def binary_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1",
    "docstring": "Pure implementation of a binary search algorithm in Python\n\nBe careful collection must be ascending sorted otherwise, the result will be\nunpredictable\n\n:param sorted_collection: some ascending sorted collection with comparable items\n:param item: item value to search\n:return: index of the found item or -1 if the item is not found\n\nExamples:\n>>> binary_search([0, 5, 7, 10, 15], 0)\n0\n>>> binary_search([0, 5, 7, 10, 15], 15)\n4\n>>> binary_search([0, 5, 7, 10, 15], 5)\n1\n>>> binary_search([0, 5, 7, 10, 15], 6)\n-1"
  },
  {
    "function": "binary_search_std_lib",
    "code": "def binary_search_std_lib(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python using stdlib\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    index = bisect.bisect_left(sorted_collection, item)\n    if index != len(sorted_collection) and sorted_collection[index] == item:\n        return index\n    return -1",
    "docstring": "Pure implementation of a binary search algorithm in Python using stdlib\n\nBe careful collection must be ascending sorted otherwise, the result will be\nunpredictable\n\n:param sorted_collection: some ascending sorted collection with comparable items\n:param item: item value to search\n:return: index of the found item or -1 if the item is not found\n\nExamples:\n>>> binary_search_std_lib([0, 5, 7, 10, 15], 0)\n0\n>>> binary_search_std_lib([0, 5, 7, 10, 15], 15)\n4\n>>> binary_search_std_lib([0, 5, 7, 10, 15], 5)\n1\n>>> binary_search_std_lib([0, 5, 7, 10, 15], 6)\n-1"
  },
  {
    "function": "binary_search_by_recursion",
    "code": "def binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n    -1\n    \"\"\"\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)",
    "docstring": "Pure implementation of a binary search algorithm in Python by recursion\n\nBe careful collection must be ascending sorted otherwise, the result will be\nunpredictable\nFirst recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n:param sorted_collection: some ascending sorted collection with comparable items\n:param item: item value to search\n:return: index of the found item or -1 if the item is not found\n\nExamples:\n>>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n0\n>>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n4\n>>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n1\n>>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n-1"
  },
  {
    "function": "exponential_search",
    "code": "def exponential_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of an exponential search algorithm in Python\n    Resources used:\n    https://en.wikipedia.org/wiki/Exponential_search\n\n    Be careful collection must be ascending sorted otherwise, result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    the order of this algorithm is O(lg I) where I is index position of item if exist\n\n    Examples:\n    >>> exponential_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> exponential_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> exponential_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> exponential_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    bound = 1\n    while bound < len(sorted_collection) and sorted_collection[bound] < item:\n        bound *= 2\n    left = bound // 2\n    right = min(bound, len(sorted_collection) - 1)\n    last_result = binary_search_by_recursion(\n        sorted_collection=sorted_collection, item=item, left=left, right=right\n    )\n    if last_result is None:\n        return -1\n    return last_result",
    "docstring": "Pure implementation of an exponential search algorithm in Python\nResources used:\nhttps://en.wikipedia.org/wiki/Exponential_search\n\nBe careful collection must be ascending sorted otherwise, result will be\nunpredictable\n\n:param sorted_collection: some ascending sorted collection with comparable items\n:param item: item value to search\n:return: index of the found item or -1 if the item is not found\n\nthe order of this algorithm is O(lg I) where I is index position of item if exist\n\nExamples:\n>>> exponential_search([0, 5, 7, 10, 15], 0)\n0\n>>> exponential_search([0, 5, 7, 10, 15], 15)\n4\n>>> exponential_search([0, 5, 7, 10, 15], 5)\n1\n>>> exponential_search([0, 5, 7, 10, 15], 6)\n-1"
  },
  {
    "function": "pre_order",
    "code": "def pre_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> pre_order(root)\n    1,2,4,5,3,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    print(node.data, end=\",\")\n    pre_order(node.left)\n    pre_order(node.right)",
    "docstring": ">>> root = TreeNode(1)\n>>> tree_node2 = TreeNode(2)\n>>> tree_node3 = TreeNode(3)\n>>> tree_node4 = TreeNode(4)\n>>> tree_node5 = TreeNode(5)\n>>> tree_node6 = TreeNode(6)\n>>> tree_node7 = TreeNode(7)\n>>> root.left, root.right = tree_node2, tree_node3\n>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n>>> pre_order(root)\n1,2,4,5,3,6,7,"
  },
  {
    "function": "in_order",
    "code": "def in_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> in_order(root)\n    4,2,5,1,6,3,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    in_order(node.left)\n    print(node.data, end=\",\")\n    in_order(node.right)",
    "docstring": ">>> root = TreeNode(1)\n>>> tree_node2 = TreeNode(2)\n>>> tree_node3 = TreeNode(3)\n>>> tree_node4 = TreeNode(4)\n>>> tree_node5 = TreeNode(5)\n>>> tree_node6 = TreeNode(6)\n>>> tree_node7 = TreeNode(7)\n>>> root.left, root.right = tree_node2, tree_node3\n>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n>>> in_order(root)\n4,2,5,1,6,3,7,"
  },
  {
    "function": "post_order",
    "code": "def post_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> post_order(root)\n    4,5,2,6,7,3,1,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    post_order(node.left)\n    post_order(node.right)\n    print(node.data, end=\",\")",
    "docstring": ">>> root = TreeNode(1)\n>>> tree_node2 = TreeNode(2)\n>>> tree_node3 = TreeNode(3)\n>>> tree_node4 = TreeNode(4)\n>>> tree_node5 = TreeNode(5)\n>>> tree_node6 = TreeNode(6)\n>>> tree_node7 = TreeNode(7)\n>>> root.left, root.right = tree_node2, tree_node3\n>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n>>> post_order(root)\n4,5,2,6,7,3,1,"
  },
  {
    "function": "level_order",
    "code": "def level_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> level_order(root)\n    1,2,3,4,5,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    q: queue.Queue = queue.Queue()\n    q.put(node)\n    while not q.empty():\n        node_dequeued = q.get()\n        print(node_dequeued.data, end=\",\")\n        if node_dequeued.left:\n            q.put(node_dequeued.left)\n        if node_dequeued.right:\n            q.put(node_dequeued.right)",
    "docstring": ">>> root = TreeNode(1)\n>>> tree_node2 = TreeNode(2)\n>>> tree_node3 = TreeNode(3)\n>>> tree_node4 = TreeNode(4)\n>>> tree_node5 = TreeNode(5)\n>>> tree_node6 = TreeNode(6)\n>>> tree_node7 = TreeNode(7)\n>>> root.left, root.right = tree_node2, tree_node3\n>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n>>> level_order(root)\n1,2,3,4,5,6,7,"
  },
  {
    "function": "level_order_actual",
    "code": "def level_order_actual(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> level_order_actual(root)\n    1,\n    2,3,\n    4,5,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    q: queue.Queue = queue.Queue()\n    q.put(node)\n    while not q.empty():\n        list_ = []\n        while not q.empty():\n            node_dequeued = q.get()\n            print(node_dequeued.data, end=\",\")\n            if node_dequeued.left:\n                list_.append(node_dequeued.left)\n            if node_dequeued.right:\n                list_.append(node_dequeued.right)\n        print()\n        for inner_node in list_:\n            q.put(inner_node)",
    "docstring": ">>> root = TreeNode(1)\n>>> tree_node2 = TreeNode(2)\n>>> tree_node3 = TreeNode(3)\n>>> tree_node4 = TreeNode(4)\n>>> tree_node5 = TreeNode(5)\n>>> tree_node6 = TreeNode(6)\n>>> tree_node7 = TreeNode(7)\n>>> root.left, root.right = tree_node2, tree_node3\n>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n>>> level_order_actual(root)\n1,\n2,3,\n4,5,6,7,"
  },
  {
    "function": "pre_order_iter",
    "code": "def pre_order_iter(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> pre_order_iter(root)\n    1,2,4,5,3,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    stack: list[TreeNode] = []\n    n = node\n    while n or stack:\n        while n:  # start from root node, find its left child\n            print(n.data, end=\",\")\n            stack.append(n)\n            n = n.left\n        # end of while means current node doesn't have left child\n        n = stack.pop()\n        # start to traverse its right child\n        n = n.right",
    "docstring": ">>> root = TreeNode(1)\n>>> tree_node2 = TreeNode(2)\n>>> tree_node3 = TreeNode(3)\n>>> tree_node4 = TreeNode(4)\n>>> tree_node5 = TreeNode(5)\n>>> tree_node6 = TreeNode(6)\n>>> tree_node7 = TreeNode(7)\n>>> root.left, root.right = tree_node2, tree_node3\n>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n>>> pre_order_iter(root)\n1,2,4,5,3,6,7,"
  },
  {
    "function": "in_order_iter",
    "code": "def in_order_iter(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> in_order_iter(root)\n    4,2,5,1,6,3,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    stack: list[TreeNode] = []\n    n = node\n    while n or stack:\n        while n:\n            stack.append(n)\n            n = n.left\n        n = stack.pop()\n        print(n.data, end=\",\")\n        n = n.right",
    "docstring": ">>> root = TreeNode(1)\n>>> tree_node2 = TreeNode(2)\n>>> tree_node3 = TreeNode(3)\n>>> tree_node4 = TreeNode(4)\n>>> tree_node5 = TreeNode(5)\n>>> tree_node6 = TreeNode(6)\n>>> tree_node7 = TreeNode(7)\n>>> root.left, root.right = tree_node2, tree_node3\n>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n>>> in_order_iter(root)\n4,2,5,1,6,3,7,"
  },
  {
    "function": "post_order_iter",
    "code": "def post_order_iter(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> post_order_iter(root)\n    4,5,2,6,7,3,1,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    stack1, stack2 = [], []\n    n = node\n    stack1.append(n)\n    while stack1:  # to find the reversed order of post order, store it in stack2\n        n = stack1.pop()\n        if n.left:\n            stack1.append(n.left)\n        if n.right:\n            stack1.append(n.right)\n        stack2.append(n)\n    while stack2:  # pop up from stack2 will be the post order\n        print(stack2.pop().data, end=\",\")",
    "docstring": ">>> root = TreeNode(1)\n>>> tree_node2 = TreeNode(2)\n>>> tree_node3 = TreeNode(3)\n>>> tree_node4 = TreeNode(4)\n>>> tree_node5 = TreeNode(5)\n>>> tree_node6 = TreeNode(6)\n>>> tree_node7 = TreeNode(7)\n>>> root.left, root.right = tree_node2, tree_node3\n>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n>>> post_order_iter(root)\n4,5,2,6,7,3,1,"
  },
  {
    "function": "double_linear_search",
    "code": "def double_linear_search(array: list[int], search_item: int) -> int:\n    \"\"\"\n    Iterate through the array from both sides to find the index of search_item.\n\n    :param array: the array to be searched\n    :param search_item: the item to be searched\n    :return the index of search_item, if search_item is in array, else -1\n\n    Examples:\n    >>> double_linear_search([1, 5, 5, 10], 1)\n    0\n    >>> double_linear_search([1, 5, 5, 10], 5)\n    1\n    >>> double_linear_search([1, 5, 5, 10], 100)\n    -1\n    >>> double_linear_search([1, 5, 5, 10], 10)\n    3\n    \"\"\"\n    # define the start and end index of the given array\n    start_ind, end_ind = 0, len(array) - 1\n    while start_ind <= end_ind:\n        if array[start_ind] == search_item:\n            return start_ind\n        elif array[end_ind] == search_item:\n            return end_ind\n        else:\n            start_ind += 1\n            end_ind -= 1\n    # returns -1 if search_item is not found in array\n    return -1",
    "docstring": "Iterate through the array from both sides to find the index of search_item.\n\n:param array: the array to be searched\n:param search_item: the item to be searched\n:return the index of search_item, if search_item is in array, else -1\n\nExamples:\n>>> double_linear_search([1, 5, 5, 10], 1)\n0\n>>> double_linear_search([1, 5, 5, 10], 5)\n1\n>>> double_linear_search([1, 5, 5, 10], 100)\n-1\n>>> double_linear_search([1, 5, 5, 10], 10)\n3"
  },
  {
    "function": "search",
    "code": "def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:\n    \"\"\"\n    Iterate through the array to find the index of key using recursion.\n    :param list_data: the list to be searched\n    :param key: the key to be searched\n    :param left: the index of first element\n    :param right: the index of last element\n    :return: the index of key value if found, -1 otherwise.\n\n    >>> search(list(range(0, 11)), 5)\n    5\n    >>> search([1, 2, 4, 5, 3], 4)\n    2\n    >>> search([1, 2, 4, 5, 3], 6)\n    -1\n    >>> search([5], 5)\n    0\n    >>> search([], 1)\n    -1\n    \"\"\"\n    right = right or len(list_data) - 1\n    if left > right:\n        return -1\n    elif list_data[left] == key:\n        return left\n    elif list_data[right] == key:\n        return right\n    else:\n        return search(list_data, key, left + 1, right - 1)",
    "docstring": "Iterate through the array to find the index of key using recursion.\n:param list_data: the list to be searched\n:param key: the key to be searched\n:param left: the index of first element\n:param right: the index of last element\n:return: the index of key value if found, -1 otherwise.\n\n>>> search(list(range(0, 11)), 5)\n5\n>>> search([1, 2, 4, 5, 3], 4)\n2\n>>> search([1, 2, 4, 5, 3], 6)\n-1\n>>> search([5], 5)\n0\n>>> search([], 1)\n-1"
  },
  {
    "function": "binary_search_by_recursion",
    "code": "def binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    \"\"\"Pure implementation of binary search algorithm in Python using recursion\n\n    Be careful: the collection must be ascending sorted otherwise, the result will be\n    unpredictable.\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :param left: starting index for the search\n    :param right: ending index for the search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n    -1\n    \"\"\"\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)",
    "docstring": "Pure implementation of binary search algorithm in Python using recursion\n\nBe careful: the collection must be ascending sorted otherwise, the result will be\nunpredictable.\n\n:param sorted_collection: some ascending sorted collection with comparable items\n:param item: item value to search\n:param left: starting index for the search\n:param right: ending index for the search\n:return: index of the found item or -1 if the item is not found\n\nExamples:\n>>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n0\n>>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n4\n>>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n1\n>>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n-1"
  },
  {
    "function": "exponential_search",
    "code": "def exponential_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"\n    Pure implementation of an exponential search algorithm in Python.\n    For more information, refer to:\n    https://en.wikipedia.org/wiki/Exponential_search\n\n    Be careful: the collection must be ascending sorted, otherwise the result will be\n    unpredictable.\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    The time complexity of this algorithm is O(log i) where i is the index of the item.\n\n    Examples:\n    >>> exponential_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> exponential_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> exponential_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> exponential_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n\n    if sorted_collection[0] == item:\n        return 0\n\n    bound = 1\n    while bound < len(sorted_collection) and sorted_collection[bound] < item:\n        bound *= 2\n\n    left = bound // 2\n    right = min(bound, len(sorted_collection) - 1)\n    return binary_search_by_recursion(sorted_collection, item, left, right)",
    "docstring": "Pure implementation of an exponential search algorithm in Python.\nFor more information, refer to:\nhttps://en.wikipedia.org/wiki/Exponential_search\n\nBe careful: the collection must be ascending sorted, otherwise the result will be\nunpredictable.\n\n:param sorted_collection: some ascending sorted collection with comparable items\n:param item: item value to search\n:return: index of the found item or -1 if the item is not found\n\nThe time complexity of this algorithm is O(log i) where i is the index of the item.\n\nExamples:\n>>> exponential_search([0, 5, 7, 10, 15], 0)\n0\n>>> exponential_search([0, 5, 7, 10, 15], 15)\n4\n>>> exponential_search([0, 5, 7, 10, 15], 5)\n1\n>>> exponential_search([0, 5, 7, 10, 15], 6)\n-1"
  },
  {
    "function": "fibonacci",
    "code": "def fibonacci(k: int) -> int:\n    \"\"\"Finds fibonacci number in index k.\n\n    Parameters\n    ----------\n    k :\n        Index of fibonacci.\n\n    Returns\n    -------\n    int\n        Fibonacci number in position k.\n\n    >>> fibonacci(0)\n    0\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(15)\n    610\n    >>> fibonacci('a')\n    Traceback (most recent call last):\n    TypeError: k must be an integer.\n    >>> fibonacci(-5)\n    Traceback (most recent call last):\n    ValueError: k integer must be greater or equal to zero.\n    \"\"\"\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer.\")\n    if k < 0:\n        raise ValueError(\"k integer must be greater or equal to zero.\")\n    if k == 0:\n        return 0\n    elif k == 1:\n        return 1\n    else:\n        return fibonacci(k - 1) + fibonacci(k - 2)",
    "docstring": "Finds fibonacci number in index k.\n\nParameters\n----------\nk :\n    Index of fibonacci.\n\nReturns\n-------\nint\n    Fibonacci number in position k.\n\n>>> fibonacci(0)\n0\n>>> fibonacci(2)\n1\n>>> fibonacci(5)\n5\n>>> fibonacci(15)\n610\n>>> fibonacci('a')\nTraceback (most recent call last):\nTypeError: k must be an integer.\n>>> fibonacci(-5)\nTraceback (most recent call last):\nValueError: k integer must be greater or equal to zero."
  },
  {
    "function": "fibonacci_search",
    "code": "def fibonacci_search(arr: list, val: int) -> int:\n    \"\"\"A pure Python implementation of a fibonacci search algorithm.\n\n    Parameters\n    ----------\n    arr\n        List of sorted elements.\n    val\n        Element to search in list.\n\n    Returns\n    -------\n    int\n        The index of the element in the array.\n        -1 if the element is not found.\n\n    >>> fibonacci_search([4, 5, 6, 7], 4)\n    0\n    >>> fibonacci_search([4, 5, 6, 7], -10)\n    -1\n    >>> fibonacci_search([-18, 2], -18)\n    0\n    >>> fibonacci_search([5], 5)\n    0\n    >>> fibonacci_search(['a', 'c', 'd'], 'c')\n    1\n    >>> fibonacci_search(['a', 'c', 'd'], 'f')\n    -1\n    >>> fibonacci_search([], 1)\n    -1\n    >>> fibonacci_search([.1, .4 , 7], .4)\n    1\n    >>> fibonacci_search([], 9)\n    -1\n    >>> fibonacci_search(list(range(100)), 63)\n    63\n    >>> fibonacci_search(list(range(100)), 99)\n    99\n    >>> fibonacci_search(list(range(-100, 100, 3)), -97)\n    1\n    >>> fibonacci_search(list(range(-100, 100, 3)), 0)\n    -1\n    >>> fibonacci_search(list(range(-100, 100, 5)), 0)\n    20\n    >>> fibonacci_search(list(range(-100, 100, 5)), 95)\n    39\n    \"\"\"\n    len_list = len(arr)\n    # Find m such that F_m >= n where F_i is the i_th fibonacci number.\n    i = 0\n    while True:\n        if fibonacci(i) >= len_list:\n            fibb_k = i\n            break\n        i += 1\n    offset = 0\n    while fibb_k > 0:\n        index_k = min(\n            offset + fibonacci(fibb_k - 1), len_list - 1\n        )  # Prevent out of range\n        item_k_1 = arr[index_k]\n        if item_k_1 == val:\n            return index_k\n        elif val < item_k_1:\n            fibb_k -= 1\n        elif val > item_k_1:\n            offset += fibonacci(fibb_k - 1)\n            fibb_k -= 2\n    return -1",
    "docstring": "A pure Python implementation of a fibonacci search algorithm.\n\nParameters\n----------\narr\n    List of sorted elements.\nval\n    Element to search in list.\n\nReturns\n-------\nint\n    The index of the element in the array.\n    -1 if the element is not found.\n\n>>> fibonacci_search([4, 5, 6, 7], 4)\n0\n>>> fibonacci_search([4, 5, 6, 7], -10)\n-1\n>>> fibonacci_search([-18, 2], -18)\n0\n>>> fibonacci_search([5], 5)\n0\n>>> fibonacci_search(['a', 'c', 'd'], 'c')\n1\n>>> fibonacci_search(['a', 'c', 'd'], 'f')\n-1\n>>> fibonacci_search([], 1)\n-1\n>>> fibonacci_search([.1, .4 , 7], .4)\n1\n>>> fibonacci_search([], 9)\n-1\n>>> fibonacci_search(list(range(100)), 63)\n63\n>>> fibonacci_search(list(range(100)), 99)\n99\n>>> fibonacci_search(list(range(-100, 100, 3)), -97)\n1\n>>> fibonacci_search(list(range(-100, 100, 3)), 0)\n-1\n>>> fibonacci_search(list(range(-100, 100, 5)), 0)\n20\n>>> fibonacci_search(list(range(-100, 100, 5)), 95)\n39"
  },
  {
    "function": "hill_climbing",
    "code": "def hill_climbing(\n    search_prob,\n    find_max: bool = True,\n    max_x: float = math.inf,\n    min_x: float = -math.inf,\n    max_y: float = math.inf,\n    min_y: float = -math.inf,\n    visualization: bool = False,\n    max_iter: int = 10000,\n) -> SearchProblem:\n    \"\"\"\n    Implementation of the hill climbling algorithm.\n    We start with a given state, find all its neighbors,\n    move towards the neighbor which provides the maximum (or minimum) change.\n    We keep doing this until we are at a state where we do not have any\n    neighbors which can improve the solution.\n        Args:\n            search_prob: The search state at the start.\n            find_max: If True, the algorithm should find the maximum else the minimum.\n            max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.\n            visualization: If True, a matplotlib graph is displayed.\n            max_iter: number of times to run the iteration.\n        Returns a search state having the maximum (or minimum) score.\n    \"\"\"\n    current_state = search_prob\n    scores = []  # list to store the current score at each iteration\n    iterations = 0\n    solution_found = False\n    visited = set()\n    while not solution_found and iterations < max_iter:\n        visited.add(current_state)\n        iterations += 1\n        current_score = current_state.score()\n        scores.append(current_score)\n        neighbors = current_state.get_neighbors()\n        max_change = -math.inf\n        min_change = math.inf\n        next_state = None  # to hold the next best neighbor\n        for neighbor in neighbors:\n            if neighbor in visited:\n                continue  # do not want to visit the same state again\n            if (\n                neighbor.x > max_x\n                or neighbor.x < min_x\n                or neighbor.y > max_y\n                or neighbor.y < min_y\n            ):\n                continue  # neighbor outside our bounds\n            change = neighbor.score() - current_score\n            if find_max:  # finding max\n                # going to direction with greatest ascent\n                if change > max_change and change > 0:\n                    max_change = change\n                    next_state = neighbor\n            elif change < min_change and change < 0:  # finding min\n                # to direction with greatest descent\n                min_change = change\n                next_state = neighbor\n        if next_state is not None:\n            # we found at least one neighbor which improved the current state\n            current_state = next_state\n        else:\n            # since we have no neighbor that improves the solution we stop the search\n            solution_found = True\n\n    if visualization:\n        from matplotlib import pyplot as plt\n\n        plt.plot(range(iterations), scores)\n        plt.xlabel(\"Iterations\")\n        plt.ylabel(\"Function values\")\n        plt.show()\n\n    return current_state",
    "docstring": "Implementation of the hill climbling algorithm.\nWe start with a given state, find all its neighbors,\nmove towards the neighbor which provides the maximum (or minimum) change.\nWe keep doing this until we are at a state where we do not have any\nneighbors which can improve the solution.\n    Args:\n        search_prob: The search state at the start.\n        find_max: If True, the algorithm should find the maximum else the minimum.\n        max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.\n        visualization: If True, a matplotlib graph is displayed.\n        max_iter: number of times to run the iteration.\n    Returns a search state having the maximum (or minimum) score."
  },
  {
    "function": "interpolation_search",
    "code": "def interpolation_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"\n    Searches for an item in a sorted collection by interpolation search algorithm.\n\n    Args:\n        sorted_collection: sorted list of integers\n        item: item value to search\n\n    Returns:\n        int: The index of the found item, or None if the item is not found.\n    Examples:\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([1, 2, 3, 4, 5], 4)\n    3\n    >>> interpolation_search([1, 2, 3, 4, 5], 6) is None\n    True\n    >>> interpolation_search([], 1) is None\n    True\n    >>> interpolation_search([100], 100)\n    0\n    >>> interpolation_search([1, 2, 3, 4, 5], 0) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 7) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([1, 2, 3, 4, 5], 0) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 7) is None\n    True\n    >>> interpolation_search([1, 2, 3, 4, 5], 2)\n    1\n    >>> interpolation_search([5, 5, 5, 5, 5], 3) is None\n    True\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        # avoid divided by 0 during interpolation\n        if sorted_collection[left] == sorted_collection[right]:\n            if sorted_collection[left] == item:\n                return left\n            return None\n\n        point = left + ((item - sorted_collection[left]) * (right - left)) // (\n            sorted_collection[right] - sorted_collection[left]\n        )\n\n        # out of range check\n        if point < 0 or point >= len(sorted_collection):\n            return None\n\n        current_item = sorted_collection[point]\n        if current_item == item:\n            return point\n        if point < left:\n            right = left\n            left = point\n        elif point > right:\n            left = right\n            right = point\n        elif item < current_item:\n            right = point - 1\n        else:\n            left = point + 1\n    return None",
    "docstring": "Searches for an item in a sorted collection by interpolation search algorithm.\n\nArgs:\n    sorted_collection: sorted list of integers\n    item: item value to search\n\nReturns:\n    int: The index of the found item, or None if the item is not found.\nExamples:\n>>> interpolation_search([1, 2, 3, 4, 5], 2)\n1\n>>> interpolation_search([1, 2, 3, 4, 5], 4)\n3\n>>> interpolation_search([1, 2, 3, 4, 5], 6) is None\nTrue\n>>> interpolation_search([], 1) is None\nTrue\n>>> interpolation_search([100], 100)\n0\n>>> interpolation_search([1, 2, 3, 4, 5], 0) is None\nTrue\n>>> interpolation_search([1, 2, 3, 4, 5], 7) is None\nTrue\n>>> interpolation_search([1, 2, 3, 4, 5], 2)\n1\n>>> interpolation_search([1, 2, 3, 4, 5], 0) is None\nTrue\n>>> interpolation_search([1, 2, 3, 4, 5], 7) is None\nTrue\n>>> interpolation_search([1, 2, 3, 4, 5], 2)\n1\n>>> interpolation_search([5, 5, 5, 5, 5], 3) is None\nTrue"
  },
  {
    "function": "interpolation_search_by_recursion",
    "code": "def interpolation_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int | None = None\n) -> int | None:\n    \"\"\"Pure implementation of interpolation search algorithm in Python by recursion\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    Args:\n        sorted_collection: some sorted collection with comparable items\n        item: item value to search\n        left: left index in collection\n        right: right index in collection\n\n    Returns:\n        index of item in collection or None if item is not present\n\n    Examples:\n    >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 0)\n    0\n    >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 15)\n    4\n    >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 5)\n    1\n    >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 100) is None\n    True\n    >>> interpolation_search_by_recursion([5, 5, 5, 5, 5], 3) is None\n    True\n    \"\"\"\n    if right is None:\n        right = len(sorted_collection) - 1\n    # avoid divided by 0 during interpolation\n    if sorted_collection[left] == sorted_collection[right]:\n        if sorted_collection[left] == item:\n            return left\n        return None\n\n    point = left + ((item - sorted_collection[left]) * (right - left)) // (\n        sorted_collection[right] - sorted_collection[left]\n    )\n\n    # out of range check\n    if point < 0 or point >= len(sorted_collection):\n        return None\n\n    if sorted_collection[point] == item:\n        return point\n    if point < left:\n        return interpolation_search_by_recursion(sorted_collection, item, point, left)\n    if point > right:\n        return interpolation_search_by_recursion(sorted_collection, item, right, left)\n    if sorted_collection[point] > item:\n        return interpolation_search_by_recursion(\n            sorted_collection, item, left, point - 1\n        )\n    return interpolation_search_by_recursion(sorted_collection, item, point + 1, right)",
    "docstring": "Pure implementation of interpolation search algorithm in Python by recursion\nBe careful collection must be ascending sorted, otherwise result will be\nunpredictable\nFirst recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\nArgs:\n    sorted_collection: some sorted collection with comparable items\n    item: item value to search\n    left: left index in collection\n    right: right index in collection\n\nReturns:\n    index of item in collection or None if item is not present\n\nExamples:\n>>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 0)\n0\n>>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 15)\n4\n>>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 5)\n1\n>>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 100) is None\nTrue\n>>> interpolation_search_by_recursion([5, 5, 5, 5, 5], 3) is None\nTrue"
  },
  {
    "function": "jump_search",
    "code": "def jump_search(arr: Sequence[T], item: T) -> int:\n    \"\"\"\n    Python implementation of the jump search algorithm.\n    Return the index if the `item` is found, otherwise return -1.\n\n    Examples:\n    >>> jump_search([0, 1, 2, 3, 4, 5], 3)\n    3\n    >>> jump_search([-5, -2, -1], -1)\n    2\n    >>> jump_search([0, 5, 10, 20], 8)\n    -1\n    >>> jump_search([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 55)\n    10\n    >>> jump_search([\"aa\", \"bb\", \"cc\", \"dd\", \"ee\", \"ff\"], \"ee\")\n    4\n    \"\"\"\n\n    arr_size = len(arr)\n    block_size = int(math.sqrt(arr_size))\n\n    prev = 0\n    step = block_size\n    while arr[min(step, arr_size) - 1] < item:\n        prev = step\n        step += block_size\n        if prev >= arr_size:\n            return -1\n\n    while arr[prev] < item:\n        prev += 1\n        if prev == min(step, arr_size):\n            return -1\n    if arr[prev] == item:\n        return prev\n    return -1",
    "docstring": "Python implementation of the jump search algorithm.\nReturn the index if the `item` is found, otherwise return -1.\n\nExamples:\n>>> jump_search([0, 1, 2, 3, 4, 5], 3)\n3\n>>> jump_search([-5, -2, -1], -1)\n2\n>>> jump_search([0, 5, 10, 20], 8)\n-1\n>>> jump_search([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 55)\n10\n>>> jump_search([\"aa\", \"bb\", \"cc\", \"dd\", \"ee\", \"ff\"], \"ee\")\n4"
  },
  {
    "function": "linear_search",
    "code": "def linear_search(sequence: list, target: int) -> int:\n    \"\"\"A pure Python implementation of a linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or -1 if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return -1",
    "docstring": "A pure Python implementation of a linear search algorithm\n\n:param sequence: a collection with comparable items (as sorted items not required\n    in Linear Search)\n:param target: item value to search\n:return: index of found item or -1 if item is not found\n\nExamples:\n>>> linear_search([0, 5, 7, 10, 15], 0)\n0\n>>> linear_search([0, 5, 7, 10, 15], 15)\n4\n>>> linear_search([0, 5, 7, 10, 15], 5)\n1\n>>> linear_search([0, 5, 7, 10, 15], 6)\n-1"
  },
  {
    "function": "rec_linear_search",
    "code": "def rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)",
    "docstring": "A pure Python implementation of a recursive linear search algorithm\n\n:param sequence: a collection with comparable items (as sorted items not required\n    in Linear Search)\n:param low: Lower bound of the array\n:param high: Higher bound of the array\n:param target: The element to be found\n:return: Index of the key or -1 if key not found\n\nExamples:\n>>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n0\n>>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n4\n>>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n1\n>>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n-1"
  },
  {
    "function": "median_of_five",
    "code": "def median_of_five(arr: list) -> int:\n    \"\"\"\n    Return the median of the input list\n    :param arr: Array to find median of\n    :return: median of arr\n\n    >>> median_of_five([2, 4, 5, 7, 899])\n    5\n    >>> median_of_five([5, 7, 899, 54, 32])\n    32\n    >>> median_of_five([5, 4, 3, 2])\n    4\n    >>> median_of_five([3, 5, 7, 10, 2])\n    5\n    \"\"\"\n    arr = sorted(arr)\n    return arr[len(arr) // 2]",
    "docstring": "Return the median of the input list\n:param arr: Array to find median of\n:return: median of arr\n\n>>> median_of_five([2, 4, 5, 7, 899])\n5\n>>> median_of_five([5, 7, 899, 54, 32])\n32\n>>> median_of_five([5, 4, 3, 2])\n4\n>>> median_of_five([3, 5, 7, 10, 2])\n5"
  },
  {
    "function": "median_of_medians",
    "code": "def median_of_medians(arr: list) -> int:\n    \"\"\"\n    Return a pivot to partition data on by calculating\n    Median of medians of input data\n    :param arr: The data to be checked (a list)\n    :return: median of medians of input array\n\n    >>> median_of_medians([2, 4, 5, 7, 899, 54, 32])\n    54\n    >>> median_of_medians([5, 7, 899, 54, 32])\n    32\n    >>> median_of_medians([5, 4, 3, 2])\n    4\n    >>> median_of_medians([3, 5, 7, 10, 2, 12])\n    12\n    \"\"\"\n\n    if len(arr) <= 5:\n        return median_of_five(arr)\n    medians = []\n    i = 0\n    while i < len(arr):\n        if (i + 4) <= len(arr):\n            medians.append(median_of_five(arr[i:].copy()))\n        else:\n            medians.append(median_of_five(arr[i : i + 5].copy()))\n        i += 5\n    return median_of_medians(medians)",
    "docstring": "Return a pivot to partition data on by calculating\nMedian of medians of input data\n:param arr: The data to be checked (a list)\n:return: median of medians of input array\n\n>>> median_of_medians([2, 4, 5, 7, 899, 54, 32])\n54\n>>> median_of_medians([5, 7, 899, 54, 32])\n32\n>>> median_of_medians([5, 4, 3, 2])\n4\n>>> median_of_medians([3, 5, 7, 10, 2, 12])\n12"
  },
  {
    "function": "quick_select",
    "code": "def quick_select(arr: list, target: int) -> int:\n    \"\"\"\n    Two way partition the data into smaller and greater lists,\n    in relationship to the pivot\n    :param arr: The data to be searched (a list)\n    :param target: The rank to be searched\n    :return: element at rank target\n\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)\n    32\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)\n    2\n    >>> quick_select([5, 4, 3, 2], 2)\n    3\n    >>> quick_select([3, 5, 7, 10, 2, 12], 3)\n    5\n    \"\"\"\n\n    # Invalid Input\n    if target > len(arr):\n        return -1\n\n    # x is the estimated pivot by median of medians algorithm\n    x = median_of_medians(arr)\n    left = []\n    right = []\n    check = False\n    for i in range(len(arr)):\n        if arr[i] < x:\n            left.append(arr[i])\n        elif arr[i] > x:\n            right.append(arr[i])\n        elif arr[i] == x and not check:\n            check = True\n        else:\n            right.append(arr[i])\n    rank_x = len(left) + 1\n    if rank_x == target:\n        answer = x\n    elif rank_x > target:\n        answer = quick_select(left, target)\n    elif rank_x < target:\n        answer = quick_select(right, target - rank_x)\n    return answer",
    "docstring": "Two way partition the data into smaller and greater lists,\nin relationship to the pivot\n:param arr: The data to be searched (a list)\n:param target: The rank to be searched\n:return: element at rank target\n\n>>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)\n32\n>>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)\n2\n>>> quick_select([5, 4, 3, 2], 2)\n3\n>>> quick_select([3, 5, 7, 10, 2, 12], 3)\n5"
  },
  {
    "function": "_partition",
    "code": "def _partition(data: list, pivot) -> tuple:\n    \"\"\"\n    Three way partition the data into smaller, equal and greater lists,\n    in relationship to the pivot\n    :param data: The data to be sorted (a list)\n    :param pivot: The value to partition the data on\n    :return: Three list: smaller, equal and greater\n    \"\"\"\n    less, equal, greater = [], [], []\n    for element in data:\n        if element < pivot:\n            less.append(element)\n        elif element > pivot:\n            greater.append(element)\n        else:\n            equal.append(element)\n    return less, equal, greater",
    "docstring": "Three way partition the data into smaller, equal and greater lists,\nin relationship to the pivot\n:param data: The data to be sorted (a list)\n:param pivot: The value to partition the data on\n:return: Three list: smaller, equal and greater"
  },
  {
    "function": "quick_select",
    "code": "def quick_select(items: list, index: int):\n    \"\"\"\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)\n    54\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)\n    4\n    >>> quick_select([5, 4, 3, 2], 2)\n    4\n    >>> quick_select([3, 5, 7, 10, 2, 12], 3)\n    7\n    \"\"\"\n    # index = len(items) // 2 when trying to find the median\n    #   (value of index when items is sorted)\n\n    # invalid input\n    if index >= len(items) or index < 0:\n        return None\n\n    pivot = items[random.randint(0, len(items) - 1)]\n    count = 0\n    smaller, equal, larger = _partition(items, pivot)\n    count = len(equal)\n    m = len(smaller)\n\n    # index is the pivot\n    if m <= index < m + count:\n        return pivot\n    # must be in smaller\n    elif m > index:\n        return quick_select(smaller, index)\n    # must be in larger\n    else:\n        return quick_select(larger, index - (m + count))",
    "docstring": ">>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)\n54\n>>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)\n4\n>>> quick_select([5, 4, 3, 2], 2)\n4\n>>> quick_select([3, 5, 7, 10, 2, 12], 3)\n7"
  },
  {
    "function": "median",
    "code": "def median(items: list):\n    \"\"\"\n    One common application of Quickselect is finding the median, which is\n    the middle element (or average of the two middle elements) in a sorted dataset.\n    It works efficiently on unsorted lists by partially sorting the data without\n    fully sorting the entire list.\n\n    >>> median([3, 2, 2, 9, 9])\n    3\n\n    >>> median([2, 2, 9, 9, 9, 3])\n    6.0\n    \"\"\"\n    mid, rem = divmod(len(items), 2)\n    if rem != 0:\n        return quick_select(items=items, index=mid)\n    else:\n        low_mid = quick_select(items=items, index=mid - 1)\n        high_mid = quick_select(items=items, index=mid)\n        return (low_mid + high_mid) / 2",
    "docstring": "One common application of Quickselect is finding the median, which is\nthe middle element (or average of the two middle elements) in a sorted dataset.\nIt works efficiently on unsorted lists by partially sorting the data without\nfully sorting the entire list.\n\n>>> median([3, 2, 2, 9, 9])\n3\n\n>>> median([2, 2, 9, 9, 9, 3])\n6.0"
  },
  {
    "function": "sentinel_linear_search",
    "code": "def sentinel_linear_search(sequence, target):\n    \"\"\"Pure implementation of sentinel linear search algorithm in Python\n\n    :param sequence: some sequence with comparable items\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    sequence.append(target)\n\n    index = 0\n    while sequence[index] != target:\n        index += 1\n\n    sequence.pop()\n\n    if index == len(sequence):\n        return None\n\n    return index",
    "docstring": "Pure implementation of sentinel linear search algorithm in Python\n\n:param sequence: some sequence with comparable items\n:param target: item value to search\n:return: index of found item or None if item is not found\n\nExamples:\n>>> sentinel_linear_search([0, 5, 7, 10, 15], 0)\n0\n\n>>> sentinel_linear_search([0, 5, 7, 10, 15], 15)\n4\n\n>>> sentinel_linear_search([0, 5, 7, 10, 15], 5)\n1\n\n>>> sentinel_linear_search([0, 5, 7, 10, 15], 6)"
  },
  {
    "function": "binary_search",
    "code": "def binary_search(a_list: list[int], item: int) -> bool:\n    \"\"\"\n    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n    >>> binary_search(test_list, 3)\n    False\n    >>> binary_search(test_list, 13)\n    True\n    >>> binary_search([4, 4, 5, 6, 7], 4)\n    True\n    >>> binary_search([4, 4, 5, 6, 7], -10)\n    False\n    >>> binary_search([-18, 2], -18)\n    True\n    >>> binary_search([5], 5)\n    True\n    >>> binary_search(['a', 'c', 'd'], 'c')\n    True\n    >>> binary_search(['a', 'c', 'd'], 'f')\n    False\n    >>> binary_search([], 1)\n    False\n    >>> binary_search([-.1, .1 , .8], .1)\n    True\n    >>> binary_search(range(-5000, 5000, 10), 80)\n    True\n    >>> binary_search(range(-5000, 5000, 10), 1255)\n    False\n    >>> binary_search(range(0, 10000, 5), 2)\n    False\n    \"\"\"\n    if len(a_list) == 0:\n        return False\n    midpoint = len(a_list) // 2\n    if a_list[midpoint] == item:\n        return True\n    if item < a_list[midpoint]:\n        return binary_search(a_list[:midpoint], item)\n    else:\n        return binary_search(a_list[midpoint + 1 :], item)",
    "docstring": ">>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n>>> binary_search(test_list, 3)\nFalse\n>>> binary_search(test_list, 13)\nTrue\n>>> binary_search([4, 4, 5, 6, 7], 4)\nTrue\n>>> binary_search([4, 4, 5, 6, 7], -10)\nFalse\n>>> binary_search([-18, 2], -18)\nTrue\n>>> binary_search([5], 5)\nTrue\n>>> binary_search(['a', 'c', 'd'], 'c')\nTrue\n>>> binary_search(['a', 'c', 'd'], 'f')\nFalse\n>>> binary_search([], 1)\nFalse\n>>> binary_search([-.1, .1 , .8], .1)\nTrue\n>>> binary_search(range(-5000, 5000, 10), 80)\nTrue\n>>> binary_search(range(-5000, 5000, 10), 1255)\nFalse\n>>> binary_search(range(0, 10000, 5), 2)\nFalse"
  },
  {
    "function": "simulated_annealing",
    "code": "def simulated_annealing(\n    search_prob,\n    find_max: bool = True,\n    max_x: float = math.inf,\n    min_x: float = -math.inf,\n    max_y: float = math.inf,\n    min_y: float = -math.inf,\n    visualization: bool = False,\n    start_temperate: float = 100,\n    rate_of_decrease: float = 0.01,\n    threshold_temp: float = 1,\n) -> Any:\n    \"\"\"\n    Implementation of the simulated annealing algorithm. We start with a given state,\n    find all its neighbors. Pick a random neighbor, if that neighbor improves the\n    solution, we move in that direction, if that neighbor does not improve the solution,\n    we generate a random real number between 0 and 1, if the number is within a certain\n    range (calculated using temperature) we move in that direction, else we pick\n    another neighbor randomly and repeat the process.\n\n    Args:\n        search_prob: The search state at the start.\n        find_max: If True, the algorithm should find the minimum else the minimum.\n        max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.\n        visualization: If True, a matplotlib graph is displayed.\n        start_temperate: the initial temperate of the system when the program starts.\n        rate_of_decrease: the rate at which the temperate decreases in each iteration.\n        threshold_temp: the threshold temperature below which we end the search\n    Returns a search state having the maximum (or minimum) score.\n    \"\"\"\n    search_end = False\n    current_state = search_prob\n    current_temp = start_temperate\n    scores = []\n    iterations = 0\n    best_state = None\n\n    while not search_end:\n        current_score = current_state.score()\n        if best_state is None or current_score > best_state.score():\n            best_state = current_state\n        scores.append(current_score)\n        iterations += 1\n        next_state = None\n        neighbors = current_state.get_neighbors()\n        while (\n            next_state is None and neighbors\n        ):  # till we do not find a neighbor that we can move to\n            index = random.randint(0, len(neighbors) - 1)  # picking a random neighbor\n            picked_neighbor = neighbors.pop(index)\n            change = picked_neighbor.score() - current_score\n\n            if (\n                picked_neighbor.x > max_x\n                or picked_neighbor.x < min_x\n                or picked_neighbor.y > max_y\n                or picked_neighbor.y < min_y\n            ):\n                continue  # neighbor outside our bounds\n\n            if not find_max:\n                change = change * -1  # in case we are finding minimum\n            if change > 0:  # improves the solution\n                next_state = picked_neighbor\n            else:\n                probability = (math.e) ** (\n                    change / current_temp\n                )  # probability generation function\n                if random.random() < probability:  # random number within probability\n                    next_state = picked_neighbor\n        current_temp = current_temp - (current_temp * rate_of_decrease)\n\n        if current_temp < threshold_temp or next_state is None:\n            # temperature below threshold, or could not find a suitable neighbor\n            search_end = True\n        else:\n            current_state = next_state\n\n    if visualization:\n        from matplotlib import pyplot as plt\n\n        plt.plot(range(iterations), scores)\n        plt.xlabel(\"Iterations\")\n        plt.ylabel(\"Function values\")\n        plt.show()\n    return best_state",
    "docstring": "Implementation of the simulated annealing algorithm. We start with a given state,\nfind all its neighbors. Pick a random neighbor, if that neighbor improves the\nsolution, we move in that direction, if that neighbor does not improve the solution,\nwe generate a random real number between 0 and 1, if the number is within a certain\nrange (calculated using temperature) we move in that direction, else we pick\nanother neighbor randomly and repeat the process.\n\nArgs:\n    search_prob: The search state at the start.\n    find_max: If True, the algorithm should find the minimum else the minimum.\n    max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.\n    visualization: If True, a matplotlib graph is displayed.\n    start_temperate: the initial temperate of the system when the program starts.\n    rate_of_decrease: the rate at which the temperate decreases in each iteration.\n    threshold_temp: the threshold temperature below which we end the search\nReturns a search state having the maximum (or minimum) score."
  },
  {
    "function": "generate_neighbours",
    "code": "def generate_neighbours(path):\n    \"\"\"\n    Pure implementation of generating a dictionary of neighbors and the cost with each\n    neighbor, given a path file that includes a graph.\n\n    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)\n    :return dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n\n    Example of dict_of_neighbours:\n    >>) dict_of_neighbours[a]\n    [[b,20],[c,18],[d,22],[e,26]]\n\n    This indicates the neighbors of node (city) 'a', which has neighbor the node 'b'\n    with distance 20, the node 'c' with distance 18, the node 'd' with distance 22 and\n    the node 'e' with distance 26.\n    \"\"\"\n\n    dict_of_neighbours = {}\n\n    with open(path) as f:\n        for line in f:\n            if line.split()[0] not in dict_of_neighbours:\n                _list = []\n                _list.append([line.split()[1], line.split()[2]])\n                dict_of_neighbours[line.split()[0]] = _list\n            else:\n                dict_of_neighbours[line.split()[0]].append(\n                    [line.split()[1], line.split()[2]]\n                )\n            if line.split()[1] not in dict_of_neighbours:\n                _list = []\n                _list.append([line.split()[0], line.split()[2]])\n                dict_of_neighbours[line.split()[1]] = _list\n            else:\n                dict_of_neighbours[line.split()[1]].append(\n                    [line.split()[0], line.split()[2]]\n                )\n\n    return dict_of_neighbours",
    "docstring": "Pure implementation of generating a dictionary of neighbors and the cost with each\nneighbor, given a path file that includes a graph.\n\n:param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)\n:return dict_of_neighbours: Dictionary with key each node and value a list of lists\n    with the neighbors of the node and the cost (distance) for each neighbor.\n\nExample of dict_of_neighbours:\n>>) dict_of_neighbours[a]\n[[b,20],[c,18],[d,22],[e,26]]\n\nThis indicates the neighbors of node (city) 'a', which has neighbor the node 'b'\nwith distance 20, the node 'c' with distance 18, the node 'd' with distance 22 and\nthe node 'e' with distance 26."
  },
  {
    "function": "generate_first_solution",
    "code": "def generate_first_solution(path, dict_of_neighbours):\n    \"\"\"\n    Pure implementation of generating the first solution for the Tabu search to start,\n    with the redundant resolution strategy. That means that we start from the starting\n    node (e.g. node 'a'), then we go to the city nearest (lowest distance) to this node\n    (let's assume is node 'c'), then we go to the nearest city of the node 'c', etc.\n    till we have visited all cities and return to the starting node.\n\n    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n    :return first_solution: The solution for the first iteration of Tabu search using\n        the redundant resolution strategy in a list.\n    :return distance_of_first_solution: The total distance that Travelling Salesman\n        will travel, if he follows the path in first_solution.\n    \"\"\"\n\n    with open(path) as f:\n        start_node = f.read(1)\n    end_node = start_node\n\n    first_solution = []\n\n    visiting = start_node\n\n    distance_of_first_solution = 0\n    while visiting not in first_solution:\n        minim = 10000\n        for k in dict_of_neighbours[visiting]:\n            if int(k[1]) < int(minim) and k[0] not in first_solution:\n                minim = k[1]\n                best_node = k[0]\n\n        first_solution.append(visiting)\n        distance_of_first_solution = distance_of_first_solution + int(minim)\n        visiting = best_node\n\n    first_solution.append(end_node)\n\n    position = 0\n    for k in dict_of_neighbours[first_solution[-2]]:\n        if k[0] == start_node:\n            break\n        position += 1\n\n    distance_of_first_solution = (\n        distance_of_first_solution\n        + int(dict_of_neighbours[first_solution[-2]][position][1])\n        - 10000\n    )\n    return first_solution, distance_of_first_solution",
    "docstring": "Pure implementation of generating the first solution for the Tabu search to start,\nwith the redundant resolution strategy. That means that we start from the starting\nnode (e.g. node 'a'), then we go to the city nearest (lowest distance) to this node\n(let's assume is node 'c'), then we go to the nearest city of the node 'c', etc.\ntill we have visited all cities and return to the starting node.\n\n:param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)\n:param dict_of_neighbours: Dictionary with key each node and value a list of lists\n    with the neighbors of the node and the cost (distance) for each neighbor.\n:return first_solution: The solution for the first iteration of Tabu search using\n    the redundant resolution strategy in a list.\n:return distance_of_first_solution: The total distance that Travelling Salesman\n    will travel, if he follows the path in first_solution."
  },
  {
    "function": "find_neighborhood",
    "code": "def find_neighborhood(solution, dict_of_neighbours):\n    \"\"\"\n    Pure implementation of generating the neighborhood (sorted by total distance of\n    each solution from lowest to highest) of a solution with 1-1 exchange method, that\n    means we exchange each node in a solution with each other node and generating a\n    number of solution named neighborhood.\n\n    :param solution: The solution in which we want to find the neighborhood.\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n    :return neighborhood_of_solution: A list that includes the solutions and the total\n        distance of each solution (in form of list) that are produced with 1-1 exchange\n        from the solution that the method took as an input\n\n    Example:\n    >>> find_neighborhood(['a', 'c', 'b', 'd', 'e', 'a'],\n    ...                   {'a': [['b', '20'], ['c', '18'], ['d', '22'], ['e', '26']],\n    ...                    'c': [['a', '18'], ['b', '10'], ['d', '23'], ['e', '24']],\n    ...                    'b': [['a', '20'], ['c', '10'], ['d', '11'], ['e', '12']],\n    ...                    'e': [['a', '26'], ['b', '12'], ['c', '24'], ['d', '40']],\n    ...                    'd': [['a', '22'], ['b', '11'], ['c', '23'], ['e', '40']]}\n    ...                   )  # doctest: +NORMALIZE_WHITESPACE\n    [['a', 'e', 'b', 'd', 'c', 'a', 90],\n     ['a', 'c', 'd', 'b', 'e', 'a', 90],\n     ['a', 'd', 'b', 'c', 'e', 'a', 93],\n     ['a', 'c', 'b', 'e', 'd', 'a', 102],\n     ['a', 'c', 'e', 'd', 'b', 'a', 113],\n     ['a', 'b', 'c', 'd', 'e', 'a', 119]]\n    \"\"\"\n\n    neighborhood_of_solution = []\n\n    for n in solution[1:-1]:\n        idx1 = solution.index(n)\n        for kn in solution[1:-1]:\n            idx2 = solution.index(kn)\n            if n == kn:\n                continue\n\n            _tmp = copy.deepcopy(solution)\n            _tmp[idx1] = kn\n            _tmp[idx2] = n\n\n            distance = 0\n\n            for k in _tmp[:-1]:\n                next_node = _tmp[_tmp.index(k) + 1]\n                for i in dict_of_neighbours[k]:\n                    if i[0] == next_node:\n                        distance = distance + int(i[1])\n            _tmp.append(distance)\n\n            if _tmp not in neighborhood_of_solution:\n                neighborhood_of_solution.append(_tmp)\n\n    index_of_last_item_in_the_list = len(neighborhood_of_solution[0]) - 1\n\n    neighborhood_of_solution.sort(key=lambda x: x[index_of_last_item_in_the_list])\n    return neighborhood_of_solution",
    "docstring": "Pure implementation of generating the neighborhood (sorted by total distance of\neach solution from lowest to highest) of a solution with 1-1 exchange method, that\nmeans we exchange each node in a solution with each other node and generating a\nnumber of solution named neighborhood.\n\n:param solution: The solution in which we want to find the neighborhood.\n:param dict_of_neighbours: Dictionary with key each node and value a list of lists\n    with the neighbors of the node and the cost (distance) for each neighbor.\n:return neighborhood_of_solution: A list that includes the solutions and the total\n    distance of each solution (in form of list) that are produced with 1-1 exchange\n    from the solution that the method took as an input\n\nExample:\n>>> find_neighborhood(['a', 'c', 'b', 'd', 'e', 'a'],\n...                   {'a': [['b', '20'], ['c', '18'], ['d', '22'], ['e', '26']],\n...                    'c': [['a', '18'], ['b', '10'], ['d', '23'], ['e', '24']],\n...                    'b': [['a', '20'], ['c', '10'], ['d', '11'], ['e', '12']],\n...                    'e': [['a', '26'], ['b', '12'], ['c', '24'], ['d', '40']],\n...                    'd': [['a', '22'], ['b', '11'], ['c', '23'], ['e', '40']]}\n...                   )  # doctest: +NORMALIZE_WHITESPACE\n[['a', 'e', 'b', 'd', 'c', 'a', 90],\n ['a', 'c', 'd', 'b', 'e', 'a', 90],\n ['a', 'd', 'b', 'c', 'e', 'a', 93],\n ['a', 'c', 'b', 'e', 'd', 'a', 102],\n ['a', 'c', 'e', 'd', 'b', 'a', 113],\n ['a', 'b', 'c', 'd', 'e', 'a', 119]]"
  },
  {
    "function": "tabu_search",
    "code": "def tabu_search(\n    first_solution, distance_of_first_solution, dict_of_neighbours, iters, size\n):\n    \"\"\"\n    Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in\n    Python.\n\n    :param first_solution: The solution for the first iteration of Tabu search using\n        the redundant resolution strategy in a list.\n    :param distance_of_first_solution: The total distance that Travelling Salesman will\n        travel, if he follows the path in first_solution.\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n    :param iters: The number of iterations that Tabu search will execute.\n    :param size: The size of Tabu List.\n    :return best_solution_ever: The solution with the lowest distance that occurred\n        during the execution of Tabu search.\n    :return best_cost: The total distance that Travelling Salesman will travel, if he\n        follows the path in best_solution ever.\n    \"\"\"\n    count = 1\n    solution = first_solution\n    tabu_list = []\n    best_cost = distance_of_first_solution\n    best_solution_ever = solution\n\n    while count <= iters:\n        neighborhood = find_neighborhood(solution, dict_of_neighbours)\n        index_of_best_solution = 0\n        best_solution = neighborhood[index_of_best_solution]\n        best_cost_index = len(best_solution) - 1\n\n        found = False\n        while not found:\n            i = 0\n            while i < len(best_solution):\n                if best_solution[i] != solution[i]:\n                    first_exchange_node = best_solution[i]\n                    second_exchange_node = solution[i]\n                    break\n                i = i + 1\n\n            if [first_exchange_node, second_exchange_node] not in tabu_list and [\n                second_exchange_node,\n                first_exchange_node,\n            ] not in tabu_list:\n                tabu_list.append([first_exchange_node, second_exchange_node])\n                found = True\n                solution = best_solution[:-1]\n                cost = neighborhood[index_of_best_solution][best_cost_index]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_solution_ever = solution\n            else:\n                index_of_best_solution = index_of_best_solution + 1\n                best_solution = neighborhood[index_of_best_solution]\n\n        if len(tabu_list) >= size:\n            tabu_list.pop(0)\n\n        count = count + 1\n\n    return best_solution_ever, best_cost",
    "docstring": "Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in\nPython.\n\n:param first_solution: The solution for the first iteration of Tabu search using\n    the redundant resolution strategy in a list.\n:param distance_of_first_solution: The total distance that Travelling Salesman will\n    travel, if he follows the path in first_solution.\n:param dict_of_neighbours: Dictionary with key each node and value a list of lists\n    with the neighbors of the node and the cost (distance) for each neighbor.\n:param iters: The number of iterations that Tabu search will execute.\n:param size: The size of Tabu List.\n:return best_solution_ever: The solution with the lowest distance that occurred\n    during the execution of Tabu search.\n:return best_cost: The total distance that Travelling Salesman will travel, if he\n    follows the path in best_solution ever."
  },
  {
    "function": "lin_search",
    "code": "def lin_search(left: int, right: int, array: list[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1",
    "docstring": "Perform linear search in list. Returns -1 if element is not found.\n\nParameters\n----------\nleft : int\n    left index bound.\nright : int\n    right index bound.\narray : List[int]\n    List of elements to be searched on\ntarget : int\n    Element that is searched\n\nReturns\n-------\nint\n    index of element that is looked for.\n\nExamples\n--------\n>>> lin_search(0, 4, [4, 5, 6, 7], 7)\n3\n>>> lin_search(0, 3, [4, 5, 6, 7], 7)\n-1\n>>> lin_search(0, 2, [-18, 2], -18)\n0\n>>> lin_search(0, 1, [5], 5)\n0\n>>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n1\n>>> lin_search(0, 3, [.1, .4 , -.1], .1)\n0\n>>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n2"
  },
  {
    "function": "ite_ternary_search",
    "code": "def ite_ternary_search(array: list[int], target: int) -> int:\n    \"\"\"Iterative method of the ternary search algorithm.\n    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n    >>> ite_ternary_search(test_list, 3)\n    -1\n    >>> ite_ternary_search(test_list, 13)\n    4\n    >>> ite_ternary_search([4, 5, 6, 7], 4)\n    0\n    >>> ite_ternary_search([4, 5, 6, 7], -10)\n    -1\n    >>> ite_ternary_search([-18, 2], -18)\n    0\n    >>> ite_ternary_search([5], 5)\n    0\n    >>> ite_ternary_search(['a', 'c', 'd'], 'c')\n    1\n    >>> ite_ternary_search(['a', 'c', 'd'], 'f')\n    -1\n    >>> ite_ternary_search([], 1)\n    -1\n    >>> ite_ternary_search([.1, .4 , -.1], .1)\n    0\n    \"\"\"\n\n    left = 0\n    right = len(array)\n    while left <= right:\n        if right - left < precision:\n            return lin_search(left, right, array, target)\n\n        one_third = (left + right) // 3 + 1\n        two_third = 2 * (left + right) // 3 + 1\n\n        if array[one_third] == target:\n            return one_third\n        elif array[two_third] == target:\n            return two_third\n\n        elif target < array[one_third]:\n            right = one_third - 1\n        elif array[two_third] < target:\n            left = two_third + 1\n\n        else:\n            left = one_third + 1\n            right = two_third - 1\n    return -1",
    "docstring": "Iterative method of the ternary search algorithm.\n>>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n>>> ite_ternary_search(test_list, 3)\n-1\n>>> ite_ternary_search(test_list, 13)\n4\n>>> ite_ternary_search([4, 5, 6, 7], 4)\n0\n>>> ite_ternary_search([4, 5, 6, 7], -10)\n-1\n>>> ite_ternary_search([-18, 2], -18)\n0\n>>> ite_ternary_search([5], 5)\n0\n>>> ite_ternary_search(['a', 'c', 'd'], 'c')\n1\n>>> ite_ternary_search(['a', 'c', 'd'], 'f')\n-1\n>>> ite_ternary_search([], 1)\n-1\n>>> ite_ternary_search([.1, .4 , -.1], .1)\n0"
  },
  {
    "function": "rec_ternary_search",
    "code": "def rec_ternary_search(left: int, right: int, array: list[int], target: int) -> int:\n    \"\"\"Recursive method of the ternary search algorithm.\n\n    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n    >>> rec_ternary_search(0, len(test_list), test_list, 3)\n    -1\n    >>> rec_ternary_search(4, len(test_list), test_list, 42)\n    8\n    >>> rec_ternary_search(0, 2, [4, 5, 6, 7], 4)\n    0\n    >>> rec_ternary_search(0, 3, [4, 5, 6, 7], -10)\n    -1\n    >>> rec_ternary_search(0, 1, [-18, 2], -18)\n    0\n    >>> rec_ternary_search(0, 1, [5], 5)\n    0\n    >>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'c')\n    1\n    >>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'f')\n    -1\n    >>> rec_ternary_search(0, 0, [], 1)\n    -1\n    >>> rec_ternary_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    \"\"\"\n    if left < right:\n        if right - left < precision:\n            return lin_search(left, right, array, target)\n        one_third = (left + right) // 3 + 1\n        two_third = 2 * (left + right) // 3 + 1\n\n        if array[one_third] == target:\n            return one_third\n        elif array[two_third] == target:\n            return two_third\n\n        elif target < array[one_third]:\n            return rec_ternary_search(left, one_third - 1, array, target)\n        elif array[two_third] < target:\n            return rec_ternary_search(two_third + 1, right, array, target)\n        else:\n            return rec_ternary_search(one_third + 1, two_third - 1, array, target)\n    else:\n        return -1",
    "docstring": "Recursive method of the ternary search algorithm.\n\n>>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n>>> rec_ternary_search(0, len(test_list), test_list, 3)\n-1\n>>> rec_ternary_search(4, len(test_list), test_list, 42)\n8\n>>> rec_ternary_search(0, 2, [4, 5, 6, 7], 4)\n0\n>>> rec_ternary_search(0, 3, [4, 5, 6, 7], -10)\n-1\n>>> rec_ternary_search(0, 1, [-18, 2], -18)\n0\n>>> rec_ternary_search(0, 1, [5], 5)\n0\n>>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'c')\n1\n>>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'f')\n-1\n>>> rec_ternary_search(0, 0, [], 1)\n-1\n>>> rec_ternary_search(0, 3, [.1, .4 , -.1], .1)\n0"
  },
  {
    "function": "bead_sort",
    "code": "def bead_sort(sequence: list) -> list:\n    \"\"\"\n    >>> bead_sort([6, 11, 12, 4, 1, 5])\n    [1, 4, 5, 6, 11, 12]\n\n    >>> bead_sort([9, 8, 7, 6, 5, 4 ,3, 2, 1])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    >>> bead_sort([5, 0, 4, 3])\n    [0, 3, 4, 5]\n\n    >>> bead_sort([8, 2, 1])\n    [1, 2, 8]\n\n    >>> bead_sort([1, .9, 0.0, 0, -1, -.9])\n    Traceback (most recent call last):\n        ...\n    TypeError: Sequence must be list of non-negative integers\n\n    >>> bead_sort(\"Hello world\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Sequence must be list of non-negative integers\n    \"\"\"\n    if any(not isinstance(x, int) or x < 0 for x in sequence):\n        raise TypeError(\"Sequence must be list of non-negative integers\")\n    for _ in range(len(sequence)):\n        for i, (rod_upper, rod_lower) in enumerate(zip(sequence, sequence[1:])):  # noqa: RUF007\n            if rod_upper > rod_lower:\n                sequence[i] -= rod_upper - rod_lower\n                sequence[i + 1] += rod_upper - rod_lower\n    return sequence",
    "docstring": ">>> bead_sort([6, 11, 12, 4, 1, 5])\n[1, 4, 5, 6, 11, 12]\n\n>>> bead_sort([9, 8, 7, 6, 5, 4 ,3, 2, 1])\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n>>> bead_sort([5, 0, 4, 3])\n[0, 3, 4, 5]\n\n>>> bead_sort([8, 2, 1])\n[1, 2, 8]\n\n>>> bead_sort([1, .9, 0.0, 0, -1, -.9])\nTraceback (most recent call last):\n    ...\nTypeError: Sequence must be list of non-negative integers\n\n>>> bead_sort(\"Hello world\")\nTraceback (most recent call last):\n    ...\nTypeError: Sequence must be list of non-negative integers"
  },
  {
    "function": "binary_insertion_sort",
    "code": "def binary_insertion_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the binary insertion sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Examples:\n    >>> binary_insertion_sort([0, 4, 1234, 4, 1])\n    [0, 1, 4, 4, 1234]\n    >>> binary_insertion_sort([]) == sorted([])\n    True\n    >>> binary_insertion_sort([-1, -2, -3]) == sorted([-1, -2, -3])\n    True\n    >>> lst = ['d', 'a', 'b', 'e', 'c']\n    >>> binary_insertion_sort(lst) == sorted(lst)\n    True\n    >>> import random\n    >>> collection = random.sample(range(-50, 50), 100)\n    >>> binary_insertion_sort(collection) == sorted(collection)\n    True\n    >>> import string\n    >>> collection = random.choices(string.ascii_letters + string.digits, k=100)\n    >>> binary_insertion_sort(collection) == sorted(collection)\n    True\n    \"\"\"\n\n    n = len(collection)\n    for i in range(1, n):\n        value_to_insert = collection[i]\n        low = 0\n        high = i - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if value_to_insert < collection[mid]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        for j in range(i, low, -1):\n            collection[j] = collection[j - 1]\n        collection[low] = value_to_insert\n    return collection",
    "docstring": "Sorts a list using the binary insertion sort algorithm.\n\n:param collection: A mutable ordered collection with comparable items.\n:return: The same collection ordered in ascending order.\n\nExamples:\n>>> binary_insertion_sort([0, 4, 1234, 4, 1])\n[0, 1, 4, 4, 1234]\n>>> binary_insertion_sort([]) == sorted([])\nTrue\n>>> binary_insertion_sort([-1, -2, -3]) == sorted([-1, -2, -3])\nTrue\n>>> lst = ['d', 'a', 'b', 'e', 'c']\n>>> binary_insertion_sort(lst) == sorted(lst)\nTrue\n>>> import random\n>>> collection = random.sample(range(-50, 50), 100)\n>>> binary_insertion_sort(collection) == sorted(collection)\nTrue\n>>> import string\n>>> collection = random.choices(string.ascii_letters + string.digits, k=100)\n>>> binary_insertion_sort(collection) == sorted(collection)\nTrue"
  },
  {
    "function": "comp_and_swap",
    "code": "def comp_and_swap(array: list[int], index1: int, index2: int, direction: int) -> None:\n    \"\"\"Compare the value at given index1 and index2 of the array and swap them as per\n    the given direction.\n\n    The parameter direction indicates the sorting direction, ASCENDING(1) or\n    DESCENDING(0); if (a[i] > a[j]) agrees with the direction, then a[i] and a[j] are\n    interchanged.\n\n    >>> arr = [12, 42, -21, 1]\n    >>> comp_and_swap(arr, 1, 2, 1)\n    >>> arr\n    [12, -21, 42, 1]\n\n    >>> comp_and_swap(arr, 1, 2, 0)\n    >>> arr\n    [12, 42, -21, 1]\n\n    >>> comp_and_swap(arr, 0, 3, 1)\n    >>> arr\n    [1, 42, -21, 12]\n\n    >>> comp_and_swap(arr, 0, 3, 0)\n    >>> arr\n    [12, 42, -21, 1]\n    \"\"\"\n    if (direction == 1 and array[index1] > array[index2]) or (\n        direction == 0 and array[index1] < array[index2]\n    ):\n        array[index1], array[index2] = array[index2], array[index1]",
    "docstring": "Compare the value at given index1 and index2 of the array and swap them as per\nthe given direction.\n\nThe parameter direction indicates the sorting direction, ASCENDING(1) or\nDESCENDING(0); if (a[i] > a[j]) agrees with the direction, then a[i] and a[j] are\ninterchanged.\n\n>>> arr = [12, 42, -21, 1]\n>>> comp_and_swap(arr, 1, 2, 1)\n>>> arr\n[12, -21, 42, 1]\n\n>>> comp_and_swap(arr, 1, 2, 0)\n>>> arr\n[12, 42, -21, 1]\n\n>>> comp_and_swap(arr, 0, 3, 1)\n>>> arr\n[1, 42, -21, 12]\n\n>>> comp_and_swap(arr, 0, 3, 0)\n>>> arr\n[12, 42, -21, 1]"
  },
  {
    "function": "bitonic_merge",
    "code": "def bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:\n    \"\"\"\n    It recursively sorts a bitonic sequence in ascending order, if direction = 1, and in\n    descending if direction = 0.\n    The sequence to be sorted starts at index position low, the parameter length is the\n    number of elements to be sorted.\n\n    >>> arr = [12, 42, -21, 1]\n    >>> bitonic_merge(arr, 0, 4, 1)\n    >>> arr\n    [-21, 1, 12, 42]\n\n    >>> bitonic_merge(arr, 0, 4, 0)\n    >>> arr\n    [42, 12, 1, -21]\n    \"\"\"\n    if length > 1:\n        middle = int(length / 2)\n        for i in range(low, low + middle):\n            comp_and_swap(array, i, i + middle, direction)\n        bitonic_merge(array, low, middle, direction)\n        bitonic_merge(array, low + middle, middle, direction)",
    "docstring": "It recursively sorts a bitonic sequence in ascending order, if direction = 1, and in\ndescending if direction = 0.\nThe sequence to be sorted starts at index position low, the parameter length is the\nnumber of elements to be sorted.\n\n>>> arr = [12, 42, -21, 1]\n>>> bitonic_merge(arr, 0, 4, 1)\n>>> arr\n[-21, 1, 12, 42]\n\n>>> bitonic_merge(arr, 0, 4, 0)\n>>> arr\n[42, 12, 1, -21]"
  },
  {
    "function": "bitonic_sort",
    "code": "def bitonic_sort(array: list[int], low: int, length: int, direction: int) -> None:\n    \"\"\"\n    This function first produces a bitonic sequence by recursively sorting its two\n    halves in opposite sorting orders, and then calls bitonic_merge to make them in the\n    same order.\n\n    >>> arr = [12, 34, 92, -23, 0, -121, -167, 145]\n    >>> bitonic_sort(arr, 0, 8, 1)\n    >>> arr\n    [-167, -121, -23, 0, 12, 34, 92, 145]\n\n    >>> bitonic_sort(arr, 0, 8, 0)\n    >>> arr\n    [145, 92, 34, 12, 0, -23, -121, -167]\n    \"\"\"\n    if length > 1:\n        middle = int(length / 2)\n        bitonic_sort(array, low, middle, 1)\n        bitonic_sort(array, low + middle, middle, 0)\n        bitonic_merge(array, low, length, direction)",
    "docstring": "This function first produces a bitonic sequence by recursively sorting its two\nhalves in opposite sorting orders, and then calls bitonic_merge to make them in the\nsame order.\n\n>>> arr = [12, 34, 92, -23, 0, -121, -167, 145]\n>>> bitonic_sort(arr, 0, 8, 1)\n>>> arr\n[-167, -121, -23, 0, 12, 34, 92, 145]\n\n>>> bitonic_sort(arr, 0, 8, 0)\n>>> arr\n[145, 92, 34, 12, 0, -23, -121, -167]"
  },
  {
    "function": "bogo_sort",
    "code": "def bogo_sort(collection):\n    \"\"\"Pure implementation of the bogosort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> bogo_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> bogo_sort([])\n    []\n    >>> bogo_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def is_sorted(collection):\n        for i in range(len(collection) - 1):\n            if collection[i] > collection[i + 1]:\n                return False\n        return True\n\n    while not is_sorted(collection):\n        random.shuffle(collection)\n    return collection",
    "docstring": "Pure implementation of the bogosort algorithm in Python\n:param collection: some mutable ordered collection with heterogeneous\ncomparable items inside\n:return: the same collection ordered by ascending\nExamples:\n>>> bogo_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n>>> bogo_sort([])\n[]\n>>> bogo_sort([-2, -5, -45])\n[-45, -5, -2]"
  },
  {
    "function": "bubble_sort_iterative",
    "code": "def bubble_sort_iterative(collection: list[Any]) -> list[Any]:\n    \"\"\"Pure implementation of bubble sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> bubble_sort_iterative([0, 5, 2, 3, 2])\n    [0, 2, 2, 3, 5]\n    >>> bubble_sort_iterative([])\n    []\n    >>> bubble_sort_iterative([-2, -45, -5])\n    [-45, -5, -2]\n    >>> bubble_sort_iterative([-23, 0, 6, -4, 34])\n    [-23, -4, 0, 6, 34]\n    >>> bubble_sort_iterative([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2])\n    True\n    >>> bubble_sort_iterative([]) == sorted([])\n    True\n    >>> bubble_sort_iterative([-2, -45, -5]) == sorted([-2, -45, -5])\n    True\n    >>> bubble_sort_iterative([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34])\n    True\n    >>> bubble_sort_iterative(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e'])\n    True\n    >>> bubble_sort_iterative(['z', 'a', 'y', 'b', 'x', 'c'])\n    ['a', 'b', 'c', 'x', 'y', 'z']\n    >>> bubble_sort_iterative([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])\n    [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]\n    >>> bubble_sort_iterative([1, 3.3, 5, 7.7, 2, 4.4, 6])\n    [1, 2, 3.3, 4.4, 5, 6, 7.7]\n    >>> import random\n    >>> collection_arg = random.sample(range(-50, 50), 100)\n    >>> bubble_sort_iterative(collection_arg) == sorted(collection_arg)\n    True\n    >>> import string\n    >>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100)\n    >>> bubble_sort_iterative(collection_arg) == sorted(collection_arg)\n    True\n    \"\"\"\n    length = len(collection)\n    for i in reversed(range(length)):\n        swapped = False\n        for j in range(i):\n            if collection[j] > collection[j + 1]:\n                swapped = True\n                collection[j], collection[j + 1] = collection[j + 1], collection[j]\n        if not swapped:\n            break  # Stop iteration if the collection is sorted.\n    return collection",
    "docstring": "Pure implementation of bubble sort algorithm in Python\n\n:param collection: some mutable ordered collection with heterogeneous\ncomparable items inside\n:return: the same collection ordered by ascending\n\nExamples:\n>>> bubble_sort_iterative([0, 5, 2, 3, 2])\n[0, 2, 2, 3, 5]\n>>> bubble_sort_iterative([])\n[]\n>>> bubble_sort_iterative([-2, -45, -5])\n[-45, -5, -2]\n>>> bubble_sort_iterative([-23, 0, 6, -4, 34])\n[-23, -4, 0, 6, 34]\n>>> bubble_sort_iterative([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2])\nTrue\n>>> bubble_sort_iterative([]) == sorted([])\nTrue\n>>> bubble_sort_iterative([-2, -45, -5]) == sorted([-2, -45, -5])\nTrue\n>>> bubble_sort_iterative([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34])\nTrue\n>>> bubble_sort_iterative(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e'])\nTrue\n>>> bubble_sort_iterative(['z', 'a', 'y', 'b', 'x', 'c'])\n['a', 'b', 'c', 'x', 'y', 'z']\n>>> bubble_sort_iterative([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])\n[1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]\n>>> bubble_sort_iterative([1, 3.3, 5, 7.7, 2, 4.4, 6])\n[1, 2, 3.3, 4.4, 5, 6, 7.7]\n>>> import random\n>>> collection_arg = random.sample(range(-50, 50), 100)\n>>> bubble_sort_iterative(collection_arg) == sorted(collection_arg)\nTrue\n>>> import string\n>>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100)\n>>> bubble_sort_iterative(collection_arg) == sorted(collection_arg)\nTrue"
  },
  {
    "function": "bubble_sort_recursive",
    "code": "def bubble_sort_recursive(collection: list[Any]) -> list[Any]:\n    \"\"\"It is similar iterative bubble sort but recursive.\n\n    :param collection: mutable ordered sequence of elements\n    :return: the same list in ascending order\n\n    Examples:\n    >>> bubble_sort_recursive([0, 5, 2, 3, 2])\n    [0, 2, 2, 3, 5]\n    >>> bubble_sort_iterative([])\n    []\n    >>> bubble_sort_recursive([-2, -45, -5])\n    [-45, -5, -2]\n    >>> bubble_sort_recursive([-23, 0, 6, -4, 34])\n    [-23, -4, 0, 6, 34]\n    >>> bubble_sort_recursive([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2])\n    True\n    >>> bubble_sort_recursive([]) == sorted([])\n    True\n    >>> bubble_sort_recursive([-2, -45, -5]) == sorted([-2, -45, -5])\n    True\n    >>> bubble_sort_recursive([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34])\n    True\n    >>> bubble_sort_recursive(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e'])\n    True\n    >>> bubble_sort_recursive(['z', 'a', 'y', 'b', 'x', 'c'])\n    ['a', 'b', 'c', 'x', 'y', 'z']\n    >>> bubble_sort_recursive([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])\n    [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]\n    >>> bubble_sort_recursive([1, 3.3, 5, 7.7, 2, 4.4, 6])\n    [1, 2, 3.3, 4.4, 5, 6, 7.7]\n    >>> bubble_sort_recursive(['a', 'Z', 'B', 'C', 'A', 'c'])\n    ['A', 'B', 'C', 'Z', 'a', 'c']\n    >>> import random\n    >>> collection_arg = random.sample(range(-50, 50), 100)\n    >>> bubble_sort_recursive(collection_arg) == sorted(collection_arg)\n    True\n    >>> import string\n    >>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100)\n    >>> bubble_sort_recursive(collection_arg) == sorted(collection_arg)\n    True\n    \"\"\"\n    length = len(collection)\n    swapped = False\n    for i in range(length - 1):\n        if collection[i] > collection[i + 1]:\n            collection[i], collection[i + 1] = collection[i + 1], collection[i]\n            swapped = True\n\n    return collection if not swapped else bubble_sort_recursive(collection)",
    "docstring": "It is similar iterative bubble sort but recursive.\n\n:param collection: mutable ordered sequence of elements\n:return: the same list in ascending order\n\nExamples:\n>>> bubble_sort_recursive([0, 5, 2, 3, 2])\n[0, 2, 2, 3, 5]\n>>> bubble_sort_iterative([])\n[]\n>>> bubble_sort_recursive([-2, -45, -5])\n[-45, -5, -2]\n>>> bubble_sort_recursive([-23, 0, 6, -4, 34])\n[-23, -4, 0, 6, 34]\n>>> bubble_sort_recursive([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2])\nTrue\n>>> bubble_sort_recursive([]) == sorted([])\nTrue\n>>> bubble_sort_recursive([-2, -45, -5]) == sorted([-2, -45, -5])\nTrue\n>>> bubble_sort_recursive([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34])\nTrue\n>>> bubble_sort_recursive(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e'])\nTrue\n>>> bubble_sort_recursive(['z', 'a', 'y', 'b', 'x', 'c'])\n['a', 'b', 'c', 'x', 'y', 'z']\n>>> bubble_sort_recursive([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])\n[1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]\n>>> bubble_sort_recursive([1, 3.3, 5, 7.7, 2, 4.4, 6])\n[1, 2, 3.3, 4.4, 5, 6, 7.7]\n>>> bubble_sort_recursive(['a', 'Z', 'B', 'C', 'A', 'c'])\n['A', 'B', 'C', 'Z', 'a', 'c']\n>>> import random\n>>> collection_arg = random.sample(range(-50, 50), 100)\n>>> bubble_sort_recursive(collection_arg) == sorted(collection_arg)\nTrue\n>>> import string\n>>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100)\n>>> bubble_sort_recursive(collection_arg) == sorted(collection_arg)\nTrue"
  },
  {
    "function": "bucket_sort",
    "code": "def bucket_sort(my_list: list, bucket_count: int = 10) -> list:\n    \"\"\"\n    >>> data = [-1, 2, -5, 0]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> data = [9, 8, 7, 6, -12]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> data = [.4, 1.2, .1, .2, -.9]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> bucket_sort([]) == sorted([])\n    True\n    >>> data = [-1e10, 1e10]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> import random\n    >>> collection = random.sample(range(-50, 50), 50)\n    >>> bucket_sort(collection) == sorted(collection)\n    True\n    >>> data = [1, 2, 2, 1, 1, 3]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> data = [5, 5, 5, 5, 5]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> data = [1000, -1000, 500, -500, 0]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> data = [5.5, 2.2, -1.1, 3.3, 0.0]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> bucket_sort([1]) == [1]\n    True\n    >>> data = [-1.1, -1.5, -3.4, 2.5, 3.6, -3.3]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> data = [9, 2, 7, 1, 5]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    \"\"\"\n\n    if len(my_list) == 0 or bucket_count <= 0:\n        return []\n\n    min_value, max_value = min(my_list), max(my_list)\n    if min_value == max_value:\n        return my_list\n\n    bucket_size = (max_value - min_value) / bucket_count\n    buckets: list[list] = [[] for _ in range(bucket_count)]\n\n    for val in my_list:\n        index = min(int((val - min_value) / bucket_size), bucket_count - 1)\n        buckets[index].append(val)\n\n    return [val for bucket in buckets for val in sorted(bucket)]",
    "docstring": ">>> data = [-1, 2, -5, 0]\n>>> bucket_sort(data) == sorted(data)\nTrue\n>>> data = [9, 8, 7, 6, -12]\n>>> bucket_sort(data) == sorted(data)\nTrue\n>>> data = [.4, 1.2, .1, .2, -.9]\n>>> bucket_sort(data) == sorted(data)\nTrue\n>>> bucket_sort([]) == sorted([])\nTrue\n>>> data = [-1e10, 1e10]\n>>> bucket_sort(data) == sorted(data)\nTrue\n>>> import random\n>>> collection = random.sample(range(-50, 50), 50)\n>>> bucket_sort(collection) == sorted(collection)\nTrue\n>>> data = [1, 2, 2, 1, 1, 3]\n>>> bucket_sort(data) == sorted(data)\nTrue\n>>> data = [5, 5, 5, 5, 5]\n>>> bucket_sort(data) == sorted(data)\nTrue\n>>> data = [1000, -1000, 500, -500, 0]\n>>> bucket_sort(data) == sorted(data)\nTrue\n>>> data = [5.5, 2.2, -1.1, 3.3, 0.0]\n>>> bucket_sort(data) == sorted(data)\nTrue\n>>> bucket_sort([1]) == [1]\nTrue\n>>> data = [-1.1, -1.5, -3.4, 2.5, 3.6, -3.3]\n>>> bucket_sort(data) == sorted(data)\nTrue\n>>> data = [9, 2, 7, 1, 5]\n>>> bucket_sort(data) == sorted(data)\nTrue"
  },
  {
    "function": "circle_sort",
    "code": "def circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection",
    "docstring": "A pure Python implementation of circle sort algorithm\n\n:param collection: a mutable collection of comparable items in any order\n:return: the same collection in ascending order\n\nExamples:\n>>> circle_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n>>> circle_sort([])\n[]\n>>> circle_sort([-2, 5, 0, -45])\n[-45, -2, 0, 5]\n>>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n>>> all(sorted(collection) == circle_sort(collection) for collection in collections)\nTrue"
  },
  {
    "function": "cocktail_shaker_sort",
    "code": "def cocktail_shaker_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Cocktail Shaker Sort algorithm.\n\n    :param arr: List of elements to be sorted.\n    :return: Sorted list.\n\n    >>> cocktail_shaker_sort([4, 5, 2, 1, 2])\n    [1, 2, 2, 4, 5]\n    >>> cocktail_shaker_sort([-4, 5, 0, 1, 2, 11])\n    [-4, 0, 1, 2, 5, 11]\n    >>> cocktail_shaker_sort([0.1, -2.4, 4.4, 2.2])\n    [-2.4, 0.1, 2.2, 4.4]\n    >>> cocktail_shaker_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> cocktail_shaker_sort([-4, -5, -24, -7, -11])\n    [-24, -11, -7, -5, -4]\n    >>> cocktail_shaker_sort([\"elderberry\", \"banana\", \"date\", \"apple\", \"cherry\"])\n    ['apple', 'banana', 'cherry', 'date', 'elderberry']\n    >>> cocktail_shaker_sort((-4, -5, -24, -7, -11))\n    Traceback (most recent call last):\n        ...\n    TypeError: 'tuple' object does not support item assignment\n    \"\"\"\n    start, end = 0, len(arr) - 1\n\n    while start < end:\n        swapped = False\n\n        # Pass from left to right\n        for i in range(start, end):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n\n        if not swapped:\n            break\n\n        end -= 1  # Decrease the end pointer after each pass\n\n        # Pass from right to left\n        for i in range(end, start, -1):\n            if arr[i] < arr[i - 1]:\n                arr[i], arr[i - 1] = arr[i - 1], arr[i]\n                swapped = True\n\n        if not swapped:\n            break\n\n        start += 1  # Increase the start pointer after each pass\n\n    return arr",
    "docstring": "Sorts a list using the Cocktail Shaker Sort algorithm.\n\n:param arr: List of elements to be sorted.\n:return: Sorted list.\n\n>>> cocktail_shaker_sort([4, 5, 2, 1, 2])\n[1, 2, 2, 4, 5]\n>>> cocktail_shaker_sort([-4, 5, 0, 1, 2, 11])\n[-4, 0, 1, 2, 5, 11]\n>>> cocktail_shaker_sort([0.1, -2.4, 4.4, 2.2])\n[-2.4, 0.1, 2.2, 4.4]\n>>> cocktail_shaker_sort([1, 2, 3, 4, 5])\n[1, 2, 3, 4, 5]\n>>> cocktail_shaker_sort([-4, -5, -24, -7, -11])\n[-24, -11, -7, -5, -4]\n>>> cocktail_shaker_sort([\"elderberry\", \"banana\", \"date\", \"apple\", \"cherry\"])\n['apple', 'banana', 'cherry', 'date', 'elderberry']\n>>> cocktail_shaker_sort((-4, -5, -24, -7, -11))\nTraceback (most recent call last):\n    ...\nTypeError: 'tuple' object does not support item assignment"
  },
  {
    "function": "comb_sort",
    "code": "def comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data",
    "docstring": "Pure implementation of comb sort algorithm in Python\n:param data: mutable collection with comparable items\n:return: the same collection in ascending order\nExamples:\n>>> comb_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n>>> comb_sort([])\n[]\n>>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n[-15, -7, 0, 2, 3, 8, 45, 99]"
  },
  {
    "function": "counting_sort",
    "code": "def counting_sort(collection):\n    \"\"\"Pure implementation of counting sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> counting_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> counting_sort([])\n    []\n    >>> counting_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered",
    "docstring": "Pure implementation of counting sort algorithm in Python\n:param collection: some mutable ordered collection with heterogeneous\ncomparable items inside\n:return: the same collection ordered by ascending\nExamples:\n>>> counting_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n>>> counting_sort([])\n[]\n>>> counting_sort([-2, -5, -45])\n[-45, -5, -2]"
  },
  {
    "function": "counting_sort_string",
    "code": "def counting_sort_string(string):\n    \"\"\"\n    >>> counting_sort_string(\"thisisthestring\")\n    'eghhiiinrsssttt'\n    \"\"\"\n    return \"\".join([chr(i) for i in counting_sort([ord(c) for c in string])])",
    "docstring": ">>> counting_sort_string(\"thisisthestring\")\n'eghhiiinrsssttt'"
  },
  {
    "function": "cycle_sort",
    "code": "def cycle_sort(array: list) -> list:\n    \"\"\"\n    >>> cycle_sort([4, 3, 2, 1])\n    [1, 2, 3, 4]\n\n    >>> cycle_sort([-4, 20, 0, -50, 100, -1])\n    [-50, -4, -1, 0, 20, 100]\n\n    >>> cycle_sort([-.1, -.2, 1.3, -.8])\n    [-0.8, -0.2, -0.1, 1.3]\n\n    >>> cycle_sort([])\n    []\n    \"\"\"\n    array_len = len(array)\n    for cycle_start in range(array_len - 1):\n        item = array[cycle_start]\n\n        pos = cycle_start\n        for i in range(cycle_start + 1, array_len):\n            if array[i] < item:\n                pos += 1\n\n        if pos == cycle_start:\n            continue\n\n        while item == array[pos]:\n            pos += 1\n\n        array[pos], item = item, array[pos]\n        while pos != cycle_start:\n            pos = cycle_start\n            for i in range(cycle_start + 1, array_len):\n                if array[i] < item:\n                    pos += 1\n\n            while item == array[pos]:\n                pos += 1\n\n            array[pos], item = item, array[pos]\n\n    return array",
    "docstring": ">>> cycle_sort([4, 3, 2, 1])\n[1, 2, 3, 4]\n\n>>> cycle_sort([-4, 20, 0, -50, 100, -1])\n[-50, -4, -1, 0, 20, 100]\n\n>>> cycle_sort([-.1, -.2, 1.3, -.8])\n[-0.8, -0.2, -0.1, 1.3]\n\n>>> cycle_sort([])\n[]"
  },
  {
    "function": "cyclic_sort",
    "code": "def cyclic_sort(nums: list[int]) -> list[int]:\n    \"\"\"\n    Sorts the input list of n integers from 1 to n in-place\n    using the Cyclic Sort algorithm.\n\n    :param nums: List of n integers from 1 to n to be sorted.\n    :return: The same list sorted in ascending order.\n\n    Time complexity: O(n), where n is the number of integers in the list.\n\n    Examples:\n    >>> cyclic_sort([])\n    []\n    >>> cyclic_sort([3, 5, 2, 1, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums",
    "docstring": "Sorts the input list of n integers from 1 to n in-place\nusing the Cyclic Sort algorithm.\n\n:param nums: List of n integers from 1 to n to be sorted.\n:return: The same list sorted in ascending order.\n\nTime complexity: O(n), where n is the number of integers in the list.\n\nExamples:\n>>> cyclic_sort([])\n[]\n>>> cyclic_sort([3, 5, 2, 1, 4])\n[1, 2, 3, 4, 5]"
  },
  {
    "function": "double_sort",
    "code": "def double_sort(collection: list[Any]) -> list[Any]:\n    \"\"\"This sorting algorithm sorts an array using the principle of bubble sort,\n    but does it both from left to right and right to left.\n    Hence, it's called \"Double sort\"\n    :param collection: mutable ordered sequence of elements\n    :return: the same collection in ascending order\n    Examples:\n    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6 ,-7])\n    [-7, -6, -5, -4, -3, -2, -1]\n    >>> double_sort([])\n    []\n    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6])\n    [-6, -5, -4, -3, -2, -1]\n    >>> double_sort([-3, 10, 16, -42, 29]) == sorted([-3, 10, 16, -42, 29])\n    True\n    \"\"\"\n    no_of_elements = len(collection)\n    for _ in range(\n        int(((no_of_elements - 1) / 2) + 1)\n    ):  # we don't need to traverse to end of list as\n        for j in range(no_of_elements - 1):\n            # apply the bubble sort algorithm from left to right (or forwards)\n            if collection[j + 1] < collection[j]:\n                collection[j], collection[j + 1] = collection[j + 1], collection[j]\n            # apply the bubble sort algorithm from right to left (or backwards)\n            if collection[no_of_elements - 1 - j] < collection[no_of_elements - 2 - j]:\n                (\n                    collection[no_of_elements - 1 - j],\n                    collection[no_of_elements - 2 - j],\n                ) = (\n                    collection[no_of_elements - 2 - j],\n                    collection[no_of_elements - 1 - j],\n                )\n    return collection",
    "docstring": "This sorting algorithm sorts an array using the principle of bubble sort,\nbut does it both from left to right and right to left.\nHence, it's called \"Double sort\"\n:param collection: mutable ordered sequence of elements\n:return: the same collection in ascending order\nExamples:\n>>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6 ,-7])\n[-7, -6, -5, -4, -3, -2, -1]\n>>> double_sort([])\n[]\n>>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6])\n[-6, -5, -4, -3, -2, -1]\n>>> double_sort([-3, 10, 16, -42, 29]) == sorted([-3, 10, 16, -42, 29])\nTrue"
  },
  {
    "function": "dutch_national_flag_sort",
    "code": "def dutch_national_flag_sort(sequence: list) -> list:\n    \"\"\"\n    A pure Python implementation of Dutch National Flag sort algorithm.\n    :param data: 3 unique integer values (e.g., 0, 1, 2) in an sequence\n    :return: The same collection in ascending order\n\n    >>> dutch_national_flag_sort([])\n    []\n    >>> dutch_national_flag_sort([0])\n    [0]\n    >>> dutch_national_flag_sort([2, 1, 0, 0, 1, 2])\n    [0, 0, 1, 1, 2, 2]\n    >>> dutch_national_flag_sort([0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2]\n    >>> dutch_national_flag_sort(\"abacab\")\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort(\"Abacab\")\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort([3, 2, 3, 1, 3, 0, 3])\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort([-1, 2, -1, 1, -1, 0, -1])\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort([1.1, 2, 1.1, 1, 1.1, 0, 1.1])\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    \"\"\"\n    if not sequence:\n        return []\n    if len(sequence) == 1:\n        return list(sequence)\n    low = 0\n    high = len(sequence) - 1\n    mid = 0\n    while mid <= high:\n        if sequence[mid] == colors[0]:\n            sequence[low], sequence[mid] = sequence[mid], sequence[low]\n            low += 1\n            mid += 1\n        elif sequence[mid] == colors[1]:\n            mid += 1\n        elif sequence[mid] == colors[2]:\n            sequence[mid], sequence[high] = sequence[high], sequence[mid]\n            high -= 1\n        else:\n            msg = f\"The elements inside the sequence must contains only {colors} values\"\n            raise ValueError(msg)\n    return sequence",
    "docstring": "A pure Python implementation of Dutch National Flag sort algorithm.\n:param data: 3 unique integer values (e.g., 0, 1, 2) in an sequence\n:return: The same collection in ascending order\n\n>>> dutch_national_flag_sort([])\n[]\n>>> dutch_national_flag_sort([0])\n[0]\n>>> dutch_national_flag_sort([2, 1, 0, 0, 1, 2])\n[0, 0, 1, 1, 2, 2]\n>>> dutch_national_flag_sort([0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1])\n[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2]\n>>> dutch_national_flag_sort(\"abacab\")\nTraceback (most recent call last):\n  ...\nValueError: The elements inside the sequence must contains only (0, 1, 2) values\n>>> dutch_national_flag_sort(\"Abacab\")\nTraceback (most recent call last):\n  ...\nValueError: The elements inside the sequence must contains only (0, 1, 2) values\n>>> dutch_national_flag_sort([3, 2, 3, 1, 3, 0, 3])\nTraceback (most recent call last):\n  ...\nValueError: The elements inside the sequence must contains only (0, 1, 2) values\n>>> dutch_national_flag_sort([-1, 2, -1, 1, -1, 0, -1])\nTraceback (most recent call last):\n  ...\nValueError: The elements inside the sequence must contains only (0, 1, 2) values\n>>> dutch_national_flag_sort([1.1, 2, 1.1, 1, 1.1, 0, 1.1])\nTraceback (most recent call last):\n  ...\nValueError: The elements inside the sequence must contains only (0, 1, 2) values"
  },
  {
    "function": "exchange_sort",
    "code": "def exchange_sort(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Uses exchange sort to sort a list of numbers.\n    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    >>> exchange_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([-1, -2, -3])\n    [-3, -2, -1]\n    >>> exchange_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([0, 10, -2, 5, 3])\n    [-2, 0, 3, 5, 10]\n    >>> exchange_sort([])\n    []\n    \"\"\"\n    numbers_length = len(numbers)\n    for i in range(numbers_length):\n        for j in range(i + 1, numbers_length):\n            if numbers[j] < numbers[i]:\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n    return numbers",
    "docstring": "Uses exchange sort to sort a list of numbers.\nSource: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n>>> exchange_sort([5, 4, 3, 2, 1])\n[1, 2, 3, 4, 5]\n>>> exchange_sort([-1, -2, -3])\n[-3, -2, -1]\n>>> exchange_sort([1, 2, 3, 4, 5])\n[1, 2, 3, 4, 5]\n>>> exchange_sort([0, 10, -2, 5, 3])\n[-2, 0, 3, 5, 10]\n>>> exchange_sort([])\n[]"
  },
  {
    "function": "gnome_sort",
    "code": "def gnome_sort(lst: list) -> list:\n    \"\"\"\n    Pure implementation of the gnome sort algorithm in Python\n\n    Take some mutable ordered collection with heterogeneous comparable items inside as\n    arguments, return the same collection ordered by ascending.\n\n    Examples:\n    >>> gnome_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> gnome_sort([])\n    []\n\n    >>> gnome_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    >>> \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\"))))\n    ' !Gadeimnoprstu'\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n\n    i = 1\n\n    while i < len(lst):\n        if lst[i - 1] <= lst[i]:\n            i += 1\n        else:\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1\n\n    return lst",
    "docstring": "Pure implementation of the gnome sort algorithm in Python\n\nTake some mutable ordered collection with heterogeneous comparable items inside as\narguments, return the same collection ordered by ascending.\n\nExamples:\n>>> gnome_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n\n>>> gnome_sort([])\n[]\n\n>>> gnome_sort([-2, -5, -45])\n[-45, -5, -2]\n\n>>> \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\"))))\n' !Gadeimnoprstu'"
  },
  {
    "function": "heapify",
    "code": "def heapify(unsorted: list[int], index: int, heap_size: int) -> None:\n    \"\"\"\n    :param unsorted: unsorted list containing integers numbers\n    :param index: index\n    :param heap_size: size of the heap\n    :return: None\n    >>> unsorted = [1, 4, 3, 5, 2]\n    >>> heapify(unsorted, 0, len(unsorted))\n    >>> unsorted\n    [4, 5, 3, 1, 2]\n    >>> heapify(unsorted, 0, len(unsorted))\n    >>> unsorted\n    [5, 4, 3, 1, 2]\n    \"\"\"\n    largest = index\n    left_index = 2 * index + 1\n    right_index = 2 * index + 2\n    if left_index < heap_size and unsorted[left_index] > unsorted[largest]:\n        largest = left_index\n\n    if right_index < heap_size and unsorted[right_index] > unsorted[largest]:\n        largest = right_index\n\n    if largest != index:\n        unsorted[largest], unsorted[index] = (unsorted[index], unsorted[largest])\n        heapify(unsorted, largest, heap_size)",
    "docstring": ":param unsorted: unsorted list containing integers numbers\n:param index: index\n:param heap_size: size of the heap\n:return: None\n>>> unsorted = [1, 4, 3, 5, 2]\n>>> heapify(unsorted, 0, len(unsorted))\n>>> unsorted\n[4, 5, 3, 1, 2]\n>>> heapify(unsorted, 0, len(unsorted))\n>>> unsorted\n[5, 4, 3, 1, 2]"
  },
  {
    "function": "heap_sort",
    "code": "def heap_sort(unsorted: list[int]) -> list[int]:\n    \"\"\"\n    A pure Python implementation of the heap sort algorithm\n\n    :param collection: a mutable ordered collection of heterogeneous comparable items\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> heap_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> heap_sort([])\n    []\n    >>> heap_sort([-2, -5, -45])\n    [-45, -5, -2]\n    >>> heap_sort([3, 7, 9, 28, 123, -5, 8, -30, -200, 0, 4])\n    [-200, -30, -5, 0, 3, 4, 7, 8, 9, 28, 123]\n    \"\"\"\n    n = len(unsorted)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(unsorted, i, n)\n    for i in range(n - 1, 0, -1):\n        unsorted[0], unsorted[i] = unsorted[i], unsorted[0]\n        heapify(unsorted, 0, i)\n    return unsorted",
    "docstring": "A pure Python implementation of the heap sort algorithm\n\n:param collection: a mutable ordered collection of heterogeneous comparable items\n:return: the same collection ordered by ascending\n\nExamples:\n>>> heap_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n>>> heap_sort([])\n[]\n>>> heap_sort([-2, -5, -45])\n[-45, -5, -2]\n>>> heap_sort([3, 7, 9, 28, 123, -5, 8, -30, -200, 0, 4])\n[-200, -30, -5, 0, 3, 4, 7, 8, 9, 28, 123]"
  },
  {
    "function": "insertion_sort",
    "code": "def insertion_sort[T: Comparable](collection: MutableSequence[T]) -> MutableSequence[T]:\n    \"\"\"A pure Python implementation of the insertion sort algorithm\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> insertion_sort([]) == sorted([])\n    True\n    >>> insertion_sort([-2, -5, -45]) == sorted([-2, -5, -45])\n    True\n    >>> insertion_sort(['d', 'a', 'b', 'e', 'c']) == sorted(['d', 'a', 'b', 'e', 'c'])\n    True\n    >>> import random\n    >>> collection = random.sample(range(-50, 50), 100)\n    >>> insertion_sort(collection) == sorted(collection)\n    True\n    >>> import string\n    >>> collection = random.choices(string.ascii_letters + string.digits, k=100)\n    >>> insertion_sort(collection) == sorted(collection)\n    True\n    \"\"\"\n\n    for insert_index in range(1, len(collection)):\n        insert_value = collection[insert_index]\n        while insert_index > 0 and insert_value < collection[insert_index - 1]:\n            collection[insert_index] = collection[insert_index - 1]\n            insert_index -= 1\n        collection[insert_index] = insert_value\n    return collection",
    "docstring": "A pure Python implementation of the insertion sort algorithm\n\n:param collection: some mutable ordered collection with heterogeneous\ncomparable items inside\n:return: the same collection ordered by ascending\n\nExamples:\n>>> insertion_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n>>> insertion_sort([]) == sorted([])\nTrue\n>>> insertion_sort([-2, -5, -45]) == sorted([-2, -5, -45])\nTrue\n>>> insertion_sort(['d', 'a', 'b', 'e', 'c']) == sorted(['d', 'a', 'b', 'e', 'c'])\nTrue\n>>> import random\n>>> collection = random.sample(range(-50, 50), 100)\n>>> insertion_sort(collection) == sorted(collection)\nTrue\n>>> import string\n>>> collection = random.choices(string.ascii_letters + string.digits, k=100)\n>>> insertion_sort(collection) == sorted(collection)\nTrue"
  },
  {
    "function": "insertion_sort",
    "code": "def insertion_sort(array: list, start: int = 0, end: int = 0) -> list:\n    \"\"\"\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> insertion_sort(array, 0, len(array))\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n    >>> array = [21, 15, 11, 45, -2, -11, 46]\n    >>> insertion_sort(array, 0, len(array))\n    [-11, -2, 11, 15, 21, 45, 46]\n    >>> array = [-2, 0, 89, 11, 48, 79, 12]\n    >>> insertion_sort(array, 0, len(array))\n    [-2, 0, 11, 12, 48, 79, 89]\n    >>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o']\n    >>> insertion_sort(array, 0, len(array))\n    ['a', 'd', 'l', 'o', 'o', 'p', 'v', 'z']\n    >>> array = [73.568, 73.56, -45.03, 1.7, 0, 89.45]\n    >>> insertion_sort(array, 0, len(array))\n    [-45.03, 0, 1.7, 73.56, 73.568, 89.45]\n    \"\"\"\n    end = end or len(array)\n    for i in range(start, end):\n        temp_index = i\n        temp_index_value = array[i]\n        while temp_index != start and temp_index_value < array[temp_index - 1]:\n            array[temp_index] = array[temp_index - 1]\n            temp_index -= 1\n        array[temp_index] = temp_index_value\n    return array",
    "docstring": ">>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n>>> insertion_sort(array, 0, len(array))\n[1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n>>> array = [21, 15, 11, 45, -2, -11, 46]\n>>> insertion_sort(array, 0, len(array))\n[-11, -2, 11, 15, 21, 45, 46]\n>>> array = [-2, 0, 89, 11, 48, 79, 12]\n>>> insertion_sort(array, 0, len(array))\n[-2, 0, 11, 12, 48, 79, 89]\n>>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o']\n>>> insertion_sort(array, 0, len(array))\n['a', 'd', 'l', 'o', 'o', 'p', 'v', 'z']\n>>> array = [73.568, 73.56, -45.03, 1.7, 0, 89.45]\n>>> insertion_sort(array, 0, len(array))\n[-45.03, 0, 1.7, 73.56, 73.568, 89.45]"
  },
  {
    "function": "heapify",
    "code": "def heapify(array: list, index: int, heap_size: int) -> None:  # Max Heap\n    \"\"\"\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> heapify(array, len(array) // 2, len(array))\n    \"\"\"\n    largest = index\n    left_index = 2 * index + 1  # Left Node\n    right_index = 2 * index + 2  # Right Node\n\n    if left_index < heap_size and array[largest] < array[left_index]:\n        largest = left_index\n\n    if right_index < heap_size and array[largest] < array[right_index]:\n        largest = right_index\n\n    if largest != index:\n        array[index], array[largest] = array[largest], array[index]\n        heapify(array, largest, heap_size)",
    "docstring": ">>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n>>> heapify(array, len(array) // 2, len(array))"
  },
  {
    "function": "heap_sort",
    "code": "def heap_sort(array: list) -> list:\n    \"\"\"\n    >>> heap_sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n    >>> heap_sort([-2, -11, 0, 0, 0, 87, 45, -69, 78, 12, 10, 103, 89, 52])\n    [-69, -11, -2, 0, 0, 0, 10, 12, 45, 52, 78, 87, 89, 103]\n    >>> heap_sort(['b', 'd', 'e', 'f', 'g', 'p', 'x', 'z', 'b', 's', 'e', 'u', 'v'])\n    ['b', 'b', 'd', 'e', 'e', 'f', 'g', 'p', 's', 'u', 'v', 'x', 'z']\n    >>> heap_sort([6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7])\n    [-457.0, -45.54, 0, 1, 1.7, 2.879, 6.2, 11.7, 758.56, 8465.2]\n    \"\"\"\n    n = len(array)\n\n    for i in range(n // 2, -1, -1):\n        heapify(array, i, n)\n\n    for i in range(n - 1, 0, -1):\n        array[i], array[0] = array[0], array[i]\n        heapify(array, 0, i)\n\n    return array",
    "docstring": ">>> heap_sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])\n[1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n>>> heap_sort([-2, -11, 0, 0, 0, 87, 45, -69, 78, 12, 10, 103, 89, 52])\n[-69, -11, -2, 0, 0, 0, 10, 12, 45, 52, 78, 87, 89, 103]\n>>> heap_sort(['b', 'd', 'e', 'f', 'g', 'p', 'x', 'z', 'b', 's', 'e', 'u', 'v'])\n['b', 'b', 'd', 'e', 'e', 'f', 'g', 'p', 's', 'u', 'v', 'x', 'z']\n>>> heap_sort([6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7])\n[-457.0, -45.54, 0, 1, 1.7, 2.879, 6.2, 11.7, 758.56, 8465.2]"
  },
  {
    "function": "median_of_3",
    "code": "def median_of_3(\n    array: list, first_index: int, middle_index: int, last_index: int\n) -> int:\n    \"\"\"\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)\n    12\n    >>> array = [13, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)\n    13\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 15, 14, 27, 79, 23, 45, 14, 16]\n    >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)\n    14\n    \"\"\"\n    if (array[first_index] > array[middle_index]) != (\n        array[first_index] > array[last_index]\n    ):\n        return array[first_index]\n    elif (array[middle_index] > array[first_index]) != (\n        array[middle_index] > array[last_index]\n    ):\n        return array[middle_index]\n    else:\n        return array[last_index]",
    "docstring": ">>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n>>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)\n12\n>>> array = [13, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n>>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)\n13\n>>> array = [4, 2, 6, 8, 1, 7, 8, 22, 15, 14, 27, 79, 23, 45, 14, 16]\n>>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)\n14"
  },
  {
    "function": "partition",
    "code": "def partition(array: list, low: int, high: int, pivot: int) -> int:\n    \"\"\"\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> partition(array, 0, len(array), 12)\n    8\n    >>> array = [21, 15, 11, 45, -2, -11, 46]\n    >>> partition(array, 0, len(array), 15)\n    3\n    >>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o']\n    >>> partition(array, 0, len(array), 'p')\n    5\n    >>> array = [6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7]\n    >>> partition(array, 0, len(array), 2.879)\n    6\n    \"\"\"\n    i = low\n    j = high\n    while True:\n        while array[i] < pivot:\n            i += 1\n        j -= 1\n        while pivot < array[j]:\n            j -= 1\n        if i >= j:\n            return i\n        array[i], array[j] = array[j], array[i]\n        i += 1",
    "docstring": ">>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n>>> partition(array, 0, len(array), 12)\n8\n>>> array = [21, 15, 11, 45, -2, -11, 46]\n>>> partition(array, 0, len(array), 15)\n3\n>>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o']\n>>> partition(array, 0, len(array), 'p')\n5\n>>> array = [6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7]\n>>> partition(array, 0, len(array), 2.879)\n6"
  },
  {
    "function": "sort",
    "code": "def sort(array: list) -> list:\n    \"\"\"\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n    >>> sort([-1, -5, -3, -13, -44])\n    [-44, -13, -5, -3, -1]\n    >>> sort([])\n    []\n    >>> sort([5])\n    [5]\n    >>> sort([-3, 0, -7, 6, 23, -34])\n    [-34, -7, -3, 0, 6, 23]\n    >>> sort([1.7, 1.0, 3.3, 2.1, 0.3 ])\n    [0.3, 1.0, 1.7, 2.1, 3.3]\n    >>> sort(['d', 'a', 'b', 'e', 'c'])\n    ['a', 'b', 'c', 'd', 'e']\n    \"\"\"\n    if len(array) == 0:\n        return array\n    max_depth = 2 * math.ceil(math.log2(len(array)))\n    size_threshold = 16\n    return intro_sort(array, 0, len(array), size_threshold, max_depth)",
    "docstring": ":param collection: some mutable ordered collection with heterogeneous\ncomparable items inside\n:return: the same collection ordered by ascending\n\nExamples:\n>>> sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])\n[1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n>>> sort([-1, -5, -3, -13, -44])\n[-44, -13, -5, -3, -1]\n>>> sort([])\n[]\n>>> sort([5])\n[5]\n>>> sort([-3, 0, -7, 6, 23, -34])\n[-34, -7, -3, 0, 6, 23]\n>>> sort([1.7, 1.0, 3.3, 2.1, 0.3 ])\n[0.3, 1.0, 1.7, 2.1, 3.3]\n>>> sort(['d', 'a', 'b', 'e', 'c'])\n['a', 'b', 'c', 'd', 'e']"
  },
  {
    "function": "intro_sort",
    "code": "def intro_sort(\n    array: list, start: int, end: int, size_threshold: int, max_depth: int\n) -> list:\n    \"\"\"\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> max_depth = 2 * math.ceil(math.log2(len(array)))\n    >>> intro_sort(array, 0, len(array), 16, max_depth)\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n    \"\"\"\n    while end - start > size_threshold:\n        if max_depth == 0:\n            return heap_sort(array)\n        max_depth -= 1\n        pivot = median_of_3(array, start, start + ((end - start) // 2) + 1, end - 1)\n        p = partition(array, start, end, pivot)\n        intro_sort(array, p, end, size_threshold, max_depth)\n        end = p\n    return insertion_sort(array, start, end)",
    "docstring": ">>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n>>> max_depth = 2 * math.ceil(math.log2(len(array)))\n>>> intro_sort(array, 0, len(array), 16, max_depth)\n[1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]"
  },
  {
    "function": "merge",
    "code": "def merge(input_list: list, low: int, mid: int, high: int) -> list:\n    \"\"\"\n    sorting left-half and right-half individually\n    then merging them into result\n    \"\"\"\n    result = []\n    left, right = input_list[low:mid], input_list[mid : high + 1]\n    while left and right:\n        result.append((left if left[0] <= right[0] else right).pop(0))\n    input_list[low : high + 1] = result + left + right\n    return input_list",
    "docstring": "sorting left-half and right-half individually\nthen merging them into result"
  },
  {
    "function": "iter_merge_sort",
    "code": "def iter_merge_sort(input_list: list) -> list:\n    \"\"\"\n    Return a sorted copy of the input list\n\n    >>> iter_merge_sort([5, 9, 8, 7, 1, 2, 7])\n    [1, 2, 5, 7, 7, 8, 9]\n    >>> iter_merge_sort([1])\n    [1]\n    >>> iter_merge_sort([2, 1])\n    [1, 2]\n    >>> iter_merge_sort([2, 1, 3])\n    [1, 2, 3]\n    >>> iter_merge_sort([4, 3, 2, 1])\n    [1, 2, 3, 4]\n    >>> iter_merge_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> iter_merge_sort(['c', 'b', 'a'])\n    ['a', 'b', 'c']\n    >>> iter_merge_sort([0.3, 0.2, 0.1])\n    [0.1, 0.2, 0.3]\n    >>> iter_merge_sort(['dep', 'dang', 'trai'])\n    ['dang', 'dep', 'trai']\n    >>> iter_merge_sort([6])\n    [6]\n    >>> iter_merge_sort([])\n    []\n    >>> iter_merge_sort([-2, -9, -1, -4])\n    [-9, -4, -2, -1]\n    >>> iter_merge_sort([1.1, 1, 0.0, -1, -1.1])\n    [-1.1, -1, 0.0, 1, 1.1]\n    >>> iter_merge_sort(['c', 'b', 'a'])\n    ['a', 'b', 'c']\n    >>> iter_merge_sort('cba')\n    ['a', 'b', 'c']\n    \"\"\"\n    if len(input_list) <= 1:\n        return input_list\n    input_list = list(input_list)\n\n    # iteration for two-way merging\n    p = 2\n    while p <= len(input_list):\n        # getting low, high and middle value for merge-sort of single list\n        for i in range(0, len(input_list), p):\n            low = i\n            high = i + p - 1\n            mid = (low + high + 1) // 2\n            input_list = merge(input_list, low, mid, high)\n        # final merge of last two parts\n        if p * 2 >= len(input_list):\n            mid = i\n            input_list = merge(input_list, 0, mid, len(input_list) - 1)\n            break\n        p *= 2\n\n    return input_list",
    "docstring": "Return a sorted copy of the input list\n\n>>> iter_merge_sort([5, 9, 8, 7, 1, 2, 7])\n[1, 2, 5, 7, 7, 8, 9]\n>>> iter_merge_sort([1])\n[1]\n>>> iter_merge_sort([2, 1])\n[1, 2]\n>>> iter_merge_sort([2, 1, 3])\n[1, 2, 3]\n>>> iter_merge_sort([4, 3, 2, 1])\n[1, 2, 3, 4]\n>>> iter_merge_sort([5, 4, 3, 2, 1])\n[1, 2, 3, 4, 5]\n>>> iter_merge_sort(['c', 'b', 'a'])\n['a', 'b', 'c']\n>>> iter_merge_sort([0.3, 0.2, 0.1])\n[0.1, 0.2, 0.3]\n>>> iter_merge_sort(['dep', 'dang', 'trai'])\n['dang', 'dep', 'trai']\n>>> iter_merge_sort([6])\n[6]\n>>> iter_merge_sort([])\n[]\n>>> iter_merge_sort([-2, -9, -1, -4])\n[-9, -4, -2, -1]\n>>> iter_merge_sort([1.1, 1, 0.0, -1, -1.1])\n[-1.1, -1, 0.0, 1, 1.1]\n>>> iter_merge_sort(['c', 'b', 'a'])\n['a', 'b', 'c']\n>>> iter_merge_sort('cba')\n['a', 'b', 'c']"
  },
  {
    "function": "binary_search_insertion",
    "code": "def binary_search_insertion(sorted_list, item):\n    \"\"\"\n    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)\n    [1, 2, 4, 7, 9, 10]\n    \"\"\"\n    left = 0\n    right = len(sorted_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if left == right:\n            if sorted_list[middle] < item:\n                left = middle + 1\n            break\n        elif sorted_list[middle] < item:\n            left = middle + 1\n        else:\n            right = middle - 1\n    sorted_list.insert(left, item)\n    return sorted_list",
    "docstring": ">>> binary_search_insertion([1, 2, 7, 9, 10], 4)\n[1, 2, 4, 7, 9, 10]"
  },
  {
    "function": "merge",
    "code": "def merge(left, right):\n    \"\"\"\n    >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0][0] < right[0][0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right",
    "docstring": ">>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])\n[[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]"
  },
  {
    "function": "sortlist_2d",
    "code": "def sortlist_2d(list_2d):\n    \"\"\"\n    >>> sortlist_2d([[9, 10], [1, 6], [7, 8], [2, 3], [4, 5]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    length = len(list_2d)\n    if length <= 1:\n        return list_2d\n    middle = length // 2\n    return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))",
    "docstring": ">>> sortlist_2d([[9, 10], [1, 6], [7, 8], [2, 3], [4, 5]])\n[[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]"
  },
  {
    "function": "merge_insertion_sort",
    "code": "def merge_insertion_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    Testing with all permutations on range(0,5):\n    >>> import itertools\n    >>> permutations = list(itertools.permutations([0, 1, 2, 3, 4]))\n    >>> all(merge_insertion_sort(p) == [0, 1, 2, 3, 4] for p in permutations)\n    True\n    \"\"\"\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-1] and has_last_odd_item:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result",
    "docstring": "Pure implementation of merge-insertion sort algorithm in Python\n\n:param collection: some mutable ordered collection with heterogeneous\ncomparable items inside\n:return: the same collection ordered by ascending\n\nExamples:\n>>> merge_insertion_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n\n>>> merge_insertion_sort([99])\n[99]\n\n>>> merge_insertion_sort([-2, -5, -45])\n[-45, -5, -2]\n\nTesting with all permutations on range(0,5):\n>>> import itertools\n>>> permutations = list(itertools.permutations([0, 1, 2, 3, 4]))\n>>> all(merge_insertion_sort(p) == [0, 1, 2, 3, 4] for p in permutations)\nTrue"
  },
  {
    "function": "merge_sort",
    "code": "def merge_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Time Complexity: O(n log n)\n    Space Complexity: O(n)\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def merge(left: list, right: list) -> list:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n\n        :param left: Left collection\n        :param right: Right collection\n        :return: Merged result\n        \"\"\"\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))",
    "docstring": "Sorts a list using the merge sort algorithm.\n\n:param collection: A mutable ordered collection with comparable items.\n:return: The same collection ordered in ascending order.\n\nTime Complexity: O(n log n)\nSpace Complexity: O(n)\n\nExamples:\n>>> merge_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n>>> merge_sort([])\n[]\n>>> merge_sort([-2, -5, -45])\n[-45, -5, -2]"
  },
  {
    "function": "msd_radix_sort",
    "code": "def msd_radix_sort(list_of_ints: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of the MSD radix sort algorithm. Only works\n    with positive integers\n    :param list_of_ints: A list of integers\n    :return: Returns the sorted list\n    >>> msd_radix_sort([40, 12, 1, 100, 4])\n    [1, 4, 12, 40, 100]\n    >>> msd_radix_sort([])\n    []\n    >>> msd_radix_sort([123, 345, 123, 80])\n    [80, 123, 123, 345]\n    >>> msd_radix_sort([1209, 834598, 1, 540402, 45])\n    [1, 45, 1209, 540402, 834598]\n    >>> msd_radix_sort([-1, 34, 45])\n    Traceback (most recent call last):\n        ...\n    ValueError: All numbers must be positive\n    \"\"\"\n    if not list_of_ints:\n        return []\n\n    if min(list_of_ints) < 0:\n        raise ValueError(\"All numbers must be positive\")\n\n    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)\n    return _msd_radix_sort(list_of_ints, most_bits)",
    "docstring": "Implementation of the MSD radix sort algorithm. Only works\nwith positive integers\n:param list_of_ints: A list of integers\n:return: Returns the sorted list\n>>> msd_radix_sort([40, 12, 1, 100, 4])\n[1, 4, 12, 40, 100]\n>>> msd_radix_sort([])\n[]\n>>> msd_radix_sort([123, 345, 123, 80])\n[80, 123, 123, 345]\n>>> msd_radix_sort([1209, 834598, 1, 540402, 45])\n[1, 45, 1209, 540402, 834598]\n>>> msd_radix_sort([-1, 34, 45])\nTraceback (most recent call last):\n    ...\nValueError: All numbers must be positive"
  },
  {
    "function": "_msd_radix_sort",
    "code": "def _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = []\n    ones = []\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res",
    "docstring": "Sort the given list based on the bit at bit_position. Numbers with a\n0 at that position will be at the start of the list, numbers with a\n1 at the end.\n:param list_of_ints: A list of integers\n:param bit_position: the position of the bit that gets compared\n:return: Returns a partially sorted list\n>>> _msd_radix_sort([45, 2, 32], 1)\n[2, 32, 45]\n>>> _msd_radix_sort([10, 4, 12], 2)\n[4, 12, 10]"
  },
  {
    "function": "msd_radix_sort_inplace",
    "code": "def msd_radix_sort_inplace(list_of_ints: list[int]):\n    \"\"\"\n    Inplace implementation of the MSD radix sort algorithm.\n    Sorts based on the binary representation of the integers.\n    >>> lst = [1, 345, 23, 89, 0, 3]\n    >>> msd_radix_sort_inplace(lst)\n    >>> lst == sorted(lst)\n    True\n    >>> lst = [1, 43, 0, 0, 0, 24, 3, 3]\n    >>> msd_radix_sort_inplace(lst)\n    >>> lst == sorted(lst)\n    True\n    >>> lst = []\n    >>> msd_radix_sort_inplace(lst)\n    >>> lst == []\n    True\n    >>> lst = [-1, 34, 23, 4, -42]\n    >>> msd_radix_sort_inplace(lst)\n    Traceback (most recent call last):\n        ...\n    ValueError: All numbers must be positive\n    \"\"\"\n\n    length = len(list_of_ints)\n    if not list_of_ints or length == 1:\n        return\n\n    if min(list_of_ints) < 0:\n        raise ValueError(\"All numbers must be positive\")\n\n    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)\n    _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)",
    "docstring": "Inplace implementation of the MSD radix sort algorithm.\nSorts based on the binary representation of the integers.\n>>> lst = [1, 345, 23, 89, 0, 3]\n>>> msd_radix_sort_inplace(lst)\n>>> lst == sorted(lst)\nTrue\n>>> lst = [1, 43, 0, 0, 0, 24, 3, 3]\n>>> msd_radix_sort_inplace(lst)\n>>> lst == sorted(lst)\nTrue\n>>> lst = []\n>>> msd_radix_sort_inplace(lst)\n>>> lst == []\nTrue\n>>> lst = [-1, 34, 23, 4, -42]\n>>> msd_radix_sort_inplace(lst)\nTraceback (most recent call last):\n    ...\nValueError: All numbers must be positive"
  },
  {
    "function": "_msd_radix_sort_inplace",
    "code": "def _msd_radix_sort_inplace(\n    list_of_ints: list[int], bit_position: int, begin_index: int, end_index: int\n):\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    >>> lst = [45, 2, 32, 24, 534, 2932]\n    >>> _msd_radix_sort_inplace(lst, 1, 0, 3)\n    >>> lst == [32, 2, 45, 24, 534, 2932]\n    True\n    >>> lst = [0, 2, 1, 3, 12, 10, 4, 90, 54, 2323, 756]\n    >>> _msd_radix_sort_inplace(lst, 2, 4, 7)\n    >>> lst == [0, 2, 1, 3, 12, 4, 10, 90, 54, 2323, 756]\n    True\n    \"\"\"\n    if bit_position == 0 or end_index - begin_index <= 1:\n        return\n\n    bit_position -= 1\n\n    i = begin_index\n    j = end_index - 1\n    while i <= j:\n        changed = False\n        if not (list_of_ints[i] >> bit_position) & 1:\n            # found zero at the beginning\n            i += 1\n            changed = True\n        if (list_of_ints[j] >> bit_position) & 1:\n            # found one at the end\n            j -= 1\n            changed = True\n\n        if changed:\n            continue\n\n        list_of_ints[i], list_of_ints[j] = list_of_ints[j], list_of_ints[i]\n        j -= 1\n        if j != i:\n            i += 1\n\n    _msd_radix_sort_inplace(list_of_ints, bit_position, begin_index, i)\n    _msd_radix_sort_inplace(list_of_ints, bit_position, i, end_index)",
    "docstring": "Sort the given list based on the bit at bit_position. Numbers with a\n0 at that position will be at the start of the list, numbers with a\n1 at the end.\n>>> lst = [45, 2, 32, 24, 534, 2932]\n>>> _msd_radix_sort_inplace(lst, 1, 0, 3)\n>>> lst == [32, 2, 45, 24, 534, 2932]\nTrue\n>>> lst = [0, 2, 1, 3, 12, 10, 4, 90, 54, 2323, 756]\n>>> _msd_radix_sort_inplace(lst, 2, 4, 7)\n>>> lst == [0, 2, 1, 3, 12, 4, 10, 90, 54, 2323, 756]\nTrue"
  },
  {
    "function": "natural_sort",
    "code": "def natural_sort(input_list: list[str]) -> list[str]:\n    \"\"\"\n    Sort the given list of strings in the way that humans expect.\n\n    The normal Python sort algorithm sorts lexicographically,\n    so you might not get the results that you expect...\n\n    >>> example1 = ['2 ft 7 in', '1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '7 ft 6 in']\n    >>> sorted(example1)\n    ['1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '2 ft 7 in', '7 ft 6 in']\n    >>> # The natural sort algorithm sort based on meaning and not computer code point.\n    >>> natural_sort(example1)\n    ['1 ft 5 in', '2 ft 7 in', '2 ft 11 in', '7 ft 6 in', '10 ft 2 in']\n\n    >>> example2 = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']\n    >>> sorted(example2)\n    ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']\n    >>> natural_sort(example2)\n    ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']\n    \"\"\"\n\n    def alphanum_key(key):\n        return [int(s) if s.isdigit() else s.lower() for s in re.split(\"([0-9]+)\", key)]\n\n    return sorted(input_list, key=alphanum_key)",
    "docstring": "Sort the given list of strings in the way that humans expect.\n\nThe normal Python sort algorithm sorts lexicographically,\nso you might not get the results that you expect...\n\n>>> example1 = ['2 ft 7 in', '1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '7 ft 6 in']\n>>> sorted(example1)\n['1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '2 ft 7 in', '7 ft 6 in']\n>>> # The natural sort algorithm sort based on meaning and not computer code point.\n>>> natural_sort(example1)\n['1 ft 5 in', '2 ft 7 in', '2 ft 11 in', '7 ft 6 in', '10 ft 2 in']\n\n>>> example2 = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']\n>>> sorted(example2)\n['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']\n>>> natural_sort(example2)\n['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']"
  },
  {
    "function": "odd_even_sort",
    "code": "def odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list",
    "docstring": "Sort input with odd even sort.\n\nThis algorithm uses the same idea of bubblesort,\nbut by first dividing in two phase (odd and even).\nOriginally developed for use on parallel processors\nwith local interconnections.\n:param collection: mutable ordered sequence of elements\n:return: same collection in ascending order\nExamples:\n>>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n[1, 2, 3, 4, 5]\n>>> odd_even_sort([])\n[]\n>>> odd_even_sort([-10 ,-1 ,10 ,2])\n[-10, -1, 2, 10]\n>>> odd_even_sort([1 ,2 ,3 ,4])\n[1, 2, 3, 4]"
  },
  {
    "function": "odd_even_transposition",
    "code": "def odd_even_transposition(arr):\n    \"\"\"\n    >>> odd_even_transposition(list(range(10)[::-1])) == sorted(list(range(10)[::-1]))\n    True\n    >>> odd_even_transposition([\"a\", \"x\", \"c\"]) == sorted([\"x\", \"a\", \"c\"])\n    True\n    >>> odd_even_transposition([1.9, 42.0, 2.8]) == sorted([1.9, 42.0, 2.8])\n    True\n    >>> odd_even_transposition([False, True, False]) == sorted([False, False, True])\n    True\n    >>> odd_even_transposition([1, 32.0, 9]) == sorted([False, False, True])\n    False\n    >>> odd_even_transposition([1, 32.0, 9]) == sorted([1.0, 32, 9.0])\n    True\n    >>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429]\n    >>> odd_even_transposition(unsorted_list) == sorted(unsorted_list)\n    True\n    >>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429]\n    >>> odd_even_transposition(unsorted_list) == sorted(unsorted_list + [1])\n    False\n    \"\"\"\n    # spawn method is considered safer than fork\n    multiprocessing_context = mp.get_context(\"spawn\")\n\n    process_array_ = []\n    result_pipe = []\n    # initialize the list of pipes where the values will be retrieved\n    for _ in arr:\n        result_pipe.append(multiprocessing_context.Pipe())\n    # creates the processes\n    # the first and last process only have one neighbor so they are made outside\n    # of the loop\n    temp_rs = multiprocessing_context.Pipe()\n    temp_rr = multiprocessing_context.Pipe()\n    process_array_.append(\n        multiprocessing_context.Process(\n            target=oe_process,\n            args=(\n                0,\n                arr[0],\n                None,\n                temp_rs,\n                None,\n                temp_rr,\n                result_pipe[0],\n                multiprocessing_context,\n            ),\n        )\n    )\n    temp_lr = temp_rs\n    temp_ls = temp_rr\n\n    for i in range(1, len(arr) - 1):\n        temp_rs = multiprocessing_context.Pipe()\n        temp_rr = multiprocessing_context.Pipe()\n        process_array_.append(\n            multiprocessing_context.Process(\n                target=oe_process,\n                args=(\n                    i,\n                    arr[i],\n                    temp_ls,\n                    temp_rs,\n                    temp_lr,\n                    temp_rr,\n                    result_pipe[i],\n                    multiprocessing_context,\n                ),\n            )\n        )\n        temp_lr = temp_rs\n        temp_ls = temp_rr\n\n    process_array_.append(\n        multiprocessing_context.Process(\n            target=oe_process,\n            args=(\n                len(arr) - 1,\n                arr[len(arr) - 1],\n                temp_ls,\n                None,\n                temp_lr,\n                None,\n                result_pipe[len(arr) - 1],\n                multiprocessing_context,\n            ),\n        )\n    )\n\n    # start the processes\n    for p in process_array_:\n        p.start()\n\n    # wait for the processes to end and write their values to the list\n    for p in range(len(result_pipe)):\n        arr[p] = result_pipe[p][0].recv()\n        process_array_[p].join()\n    return arr",
    "docstring": ">>> odd_even_transposition(list(range(10)[::-1])) == sorted(list(range(10)[::-1]))\nTrue\n>>> odd_even_transposition([\"a\", \"x\", \"c\"]) == sorted([\"x\", \"a\", \"c\"])\nTrue\n>>> odd_even_transposition([1.9, 42.0, 2.8]) == sorted([1.9, 42.0, 2.8])\nTrue\n>>> odd_even_transposition([False, True, False]) == sorted([False, False, True])\nTrue\n>>> odd_even_transposition([1, 32.0, 9]) == sorted([False, False, True])\nFalse\n>>> odd_even_transposition([1, 32.0, 9]) == sorted([1.0, 32, 9.0])\nTrue\n>>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429]\n>>> odd_even_transposition(unsorted_list) == sorted(unsorted_list)\nTrue\n>>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429]\n>>> odd_even_transposition(unsorted_list) == sorted(unsorted_list + [1])\nFalse"
  },
  {
    "function": "odd_even_transposition",
    "code": "def odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr",
    "docstring": ">>> odd_even_transposition([5, 4, 3, 2, 1])\n[1, 2, 3, 4, 5]\n\n>>> odd_even_transposition([13, 11, 18, 0, -1])\n[-1, 0, 11, 13, 18]\n\n>>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n[-2.9, -0.1, 0.1, 1.1]"
  },
  {
    "function": "pancake_sort",
    "code": "def pancake_sort(arr):\n    \"\"\"Sort Array with Pancake Sort.\n    :param arr: Collection containing comparable items\n    :return: Collection ordered in ascending order of items\n    Examples:\n    >>> pancake_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pancake_sort([])\n    []\n    >>> pancake_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    cur = len(arr)\n    while cur > 1:\n        # Find the maximum number in arr\n        mi = arr.index(max(arr[0:cur]))\n        # Reverse from 0 to mi\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\n        # Reverse whole list\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\n        cur -= 1\n    return arr",
    "docstring": "Sort Array with Pancake Sort.\n:param arr: Collection containing comparable items\n:return: Collection ordered in ascending order of items\nExamples:\n>>> pancake_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n>>> pancake_sort([])\n[]\n>>> pancake_sort([-2, -5, -45])\n[-45, -5, -2]"
  },
  {
    "function": "patience_sort",
    "code": "def patience_sort(collection: list) -> list:\n    \"\"\"A pure implementation of patience sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> patience_sort([1, 9, 5, 21, 17, 6])\n    [1, 5, 6, 9, 17, 21]\n\n    >>> patience_sort([])\n    []\n\n    >>> patience_sort([-3, -17, -48])\n    [-48, -17, -3]\n    \"\"\"\n    stacks: list[Stack] = []\n    # sort into stacks\n    for element in collection:\n        new_stacks = Stack([element])\n        i = bisect_left(stacks, new_stacks)\n        if i != len(stacks):\n            stacks[i].append(element)\n        else:\n            stacks.append(new_stacks)\n\n    # use a heap-based merge to merge stack efficiently\n    collection[:] = merge(*(reversed(stack) for stack in stacks))\n    return collection",
    "docstring": "A pure implementation of patience sort algorithm in Python\n\n:param collection: some mutable ordered collection with heterogeneous\ncomparable items inside\n:return: the same collection ordered by ascending\n\nExamples:\n>>> patience_sort([1, 9, 5, 21, 17, 6])\n[1, 5, 6, 9, 17, 21]\n\n>>> patience_sort([])\n[]\n\n>>> patience_sort([-3, -17, -48])\n[-48, -17, -3]"
  },
  {
    "function": "pigeonhole_sort",
    "code": "def pigeonhole_sort(a):\n    \"\"\"\n    >>> a = [8, 3, 2, 7, 4, 6, 8]\n    >>> b = sorted(a)  # a nondestructive sort\n    >>> pigeonhole_sort(a)  # a destructive sort\n    >>> a == b\n    True\n    \"\"\"\n    # size of range of values in the list (ie, number of pigeonholes we need)\n\n    min_val = min(a)  # min() finds the minimum value\n    max_val = max(a)  # max() finds the maximum value\n\n    size = max_val - min_val + 1  # size is difference of max and min values plus one\n\n    # list of pigeonholes of size equal to the variable size\n    holes = [0] * size\n\n    # Populate the pigeonholes.\n    for x in a:\n        assert isinstance(x, int), \"integers only please\"\n        holes[x - min_val] += 1\n\n    # Putting the elements back into the array in an order.\n    i = 0\n    for count in range(size):\n        while holes[count] > 0:\n            holes[count] -= 1\n            a[i] = count + min_val\n            i += 1",
    "docstring": ">>> a = [8, 3, 2, 7, 4, 6, 8]\n>>> b = sorted(a)  # a nondestructive sort\n>>> pigeonhole_sort(a)  # a destructive sort\n>>> a == b\nTrue"
  },
  {
    "function": "pigeon_sort",
    "code": "def pigeon_sort(array: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array",
    "docstring": "Implementation of pigeon hole sort algorithm\n:param array: Collection of comparable items\n:return: Collection sorted in ascending order\n>>> pigeon_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n>>> pigeon_sort([])\n[]\n>>> pigeon_sort([-2, -5, -45])\n[-45, -5, -2]"
  },
  {
    "function": "quick_sort",
    "code": "def quick_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of quicksort algorithm.\n\n    :param collection: a mutable collection of comparable items\n    :return: the same collection ordered in ascending order\n\n    Examples:\n    >>> quick_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> quick_sort([])\n    []\n    >>> quick_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    \"\"\"\n    # Base case: if the collection has 0 or 1 elements, it is already sorted\n    if len(collection) < 2:\n        return collection\n\n    # Randomly select a pivot index and remove the pivot element from the collection\n    pivot_index = randrange(len(collection))\n    pivot = collection.pop(pivot_index)\n\n    # Partition the remaining elements into two groups: lesser or equal, and greater\n    lesser = [item for item in collection if item <= pivot]\n    greater = [item for item in collection if item > pivot]\n\n    # Recursively sort the lesser and greater groups, and combine with the pivot\n    return [*quick_sort(lesser), pivot, *quick_sort(greater)]",
    "docstring": "A pure Python implementation of quicksort algorithm.\n\n:param collection: a mutable collection of comparable items\n:return: the same collection ordered in ascending order\n\nExamples:\n>>> quick_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n>>> quick_sort([])\n[]\n>>> quick_sort([-2, 5, 0, -45])\n[-45, -2, 0, 5]"
  },
  {
    "function": "quick_sort_3partition",
    "code": "def quick_sort_3partition(sorting: list, left: int, right: int) -> None:\n    \"\"\" \"\n    Python implementation of quick sort algorithm with 3-way partition.\n    The idea of 3-way quick sort is based on \"Dutch National Flag algorithm\".\n\n    :param sorting: sort list\n    :param left: left endpoint of sorting\n    :param right: right endpoint of sorting\n    :return: None\n\n    Examples:\n    >>> array1 = [5, -1, -1, 5, 5, 24, 0]\n    >>> quick_sort_3partition(array1, 0, 6)\n    >>> array1\n    [-1, -1, 0, 5, 5, 5, 24]\n    >>> array2 = [9, 0, 2, 6]\n    >>> quick_sort_3partition(array2, 0, 3)\n    >>> array2\n    [0, 2, 6, 9]\n    >>> array3 = []\n    >>> quick_sort_3partition(array3, 0, 0)\n    >>> array3\n    []\n    \"\"\"\n    if right <= left:\n        return\n    a = i = left\n    b = right\n    pivot = sorting[left]\n    while i <= b:\n        if sorting[i] < pivot:\n            sorting[a], sorting[i] = sorting[i], sorting[a]\n            a += 1\n            i += 1\n        elif sorting[i] > pivot:\n            sorting[b], sorting[i] = sorting[i], sorting[b]\n            b -= 1\n        else:\n            i += 1\n    quick_sort_3partition(sorting, left, a - 1)\n    quick_sort_3partition(sorting, b + 1, right)",
    "docstring": "\"\nPython implementation of quick sort algorithm with 3-way partition.\nThe idea of 3-way quick sort is based on \"Dutch National Flag algorithm\".\n\n:param sorting: sort list\n:param left: left endpoint of sorting\n:param right: right endpoint of sorting\n:return: None\n\nExamples:\n>>> array1 = [5, -1, -1, 5, 5, 24, 0]\n>>> quick_sort_3partition(array1, 0, 6)\n>>> array1\n[-1, -1, 0, 5, 5, 5, 24]\n>>> array2 = [9, 0, 2, 6]\n>>> quick_sort_3partition(array2, 0, 3)\n>>> array2\n[0, 2, 6, 9]\n>>> array3 = []\n>>> quick_sort_3partition(array3, 0, 0)\n>>> array3\n[]"
  },
  {
    "function": "quick_sort_lomuto_partition",
    "code": "def quick_sort_lomuto_partition(sorting: list, left: int, right: int) -> None:\n    \"\"\"\n    A pure Python implementation of quick sort algorithm(in-place)\n    with Lomuto partition scheme:\n    https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme\n\n    :param sorting: sort list\n    :param left: left endpoint of sorting\n    :param right: right endpoint of sorting\n    :return: None\n\n    Examples:\n    >>> nums1 = [0, 5, 3, 1, 2]\n    >>> quick_sort_lomuto_partition(nums1, 0, 4)\n    >>> nums1\n    [0, 1, 2, 3, 5]\n    >>> nums2 = []\n    >>> quick_sort_lomuto_partition(nums2, 0, 0)\n    >>> nums2\n    []\n    >>> nums3 = [-2, 5, 0, -4]\n    >>> quick_sort_lomuto_partition(nums3, 0, 3)\n    >>> nums3\n    [-4, -2, 0, 5]\n    \"\"\"\n    if left < right:\n        pivot_index = lomuto_partition(sorting, left, right)\n        quick_sort_lomuto_partition(sorting, left, pivot_index - 1)\n        quick_sort_lomuto_partition(sorting, pivot_index + 1, right)",
    "docstring": "A pure Python implementation of quick sort algorithm(in-place)\nwith Lomuto partition scheme:\nhttps://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme\n\n:param sorting: sort list\n:param left: left endpoint of sorting\n:param right: right endpoint of sorting\n:return: None\n\nExamples:\n>>> nums1 = [0, 5, 3, 1, 2]\n>>> quick_sort_lomuto_partition(nums1, 0, 4)\n>>> nums1\n[0, 1, 2, 3, 5]\n>>> nums2 = []\n>>> quick_sort_lomuto_partition(nums2, 0, 0)\n>>> nums2\n[]\n>>> nums3 = [-2, 5, 0, -4]\n>>> quick_sort_lomuto_partition(nums3, 0, 3)\n>>> nums3\n[-4, -2, 0, 5]"
  },
  {
    "function": "lomuto_partition",
    "code": "def lomuto_partition(sorting: list, left: int, right: int) -> int:\n    \"\"\"\n    Example:\n    >>> lomuto_partition([1,5,7,6], 0, 3)\n    2\n    \"\"\"\n    pivot = sorting[right]\n    store_index = left\n    for i in range(left, right):\n        if sorting[i] < pivot:\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\n            store_index += 1\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\n    return store_index",
    "docstring": "Example:\n>>> lomuto_partition([1,5,7,6], 0, 3)\n2"
  },
  {
    "function": "three_way_radix_quicksort",
    "code": "def three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )",
    "docstring": "Three-way radix quicksort:\nhttps://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\nFirst divide the list into three parts.\nThen recursively sort the \"less than\" and \"greater than\" partitions.\n\n>>> three_way_radix_quicksort([])\n[]\n>>> three_way_radix_quicksort([1])\n[1]\n>>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n[-5, -2, -2, 0, 1, 1]\n>>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n[-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]"
  },
  {
    "function": "radix_sort",
    "code": "def radix_sort(list_of_ints: list[int]) -> list[int]:\n    \"\"\"\n    Examples:\n    >>> radix_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> radix_sort(list(range(15))) == sorted(range(15))\n    True\n    >>> radix_sort(list(range(14,-1,-1))) == sorted(range(15))\n    True\n    >>> radix_sort([1,100,10,1000]) == sorted([1,100,10,1000])\n    True\n    \"\"\"\n    placement = 1\n    max_digit = max(list_of_ints)\n    while placement <= max_digit:\n        # declare and initialize empty buckets\n        buckets: list[list] = [[] for _ in range(RADIX)]\n        # split list_of_ints between the buckets\n        for i in list_of_ints:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n        # put each buckets' contents into list_of_ints\n        a = 0\n        for b in range(RADIX):\n            for i in buckets[b]:\n                list_of_ints[a] = i\n                a += 1\n        # move to next\n        placement *= RADIX\n    return list_of_ints",
    "docstring": "Examples:\n>>> radix_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n\n>>> radix_sort(list(range(15))) == sorted(range(15))\nTrue\n>>> radix_sort(list(range(14,-1,-1))) == sorted(range(15))\nTrue\n>>> radix_sort([1,100,10,1000]) == sorted([1,100,10,1000])\nTrue"
  },
  {
    "function": "rec_insertion_sort",
    "code": "def rec_insertion_sort(collection: list, n: int):\n    \"\"\"\n    Given a collection of numbers and its length, sorts the collections\n    in ascending order\n\n    :param collection: A mutable collection of comparable elements\n    :param n: The length of collections\n\n    >>> col = [1, 2, 1]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [1, 1, 2]\n\n    >>> col = [2, 1, 0, -1, -2]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [-2, -1, 0, 1, 2]\n\n    >>> col = [1]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [1]\n    \"\"\"\n    # Checks if the entire collection has been sorted\n    if len(collection) <= 1 or n <= 1:\n        return\n\n    insert_next(collection, n - 1)\n    rec_insertion_sort(collection, n - 1)",
    "docstring": "Given a collection of numbers and its length, sorts the collections\nin ascending order\n\n:param collection: A mutable collection of comparable elements\n:param n: The length of collections\n\n>>> col = [1, 2, 1]\n>>> rec_insertion_sort(col, len(col))\n>>> col\n[1, 1, 2]\n\n>>> col = [2, 1, 0, -1, -2]\n>>> rec_insertion_sort(col, len(col))\n>>> col\n[-2, -1, 0, 1, 2]\n\n>>> col = [1]\n>>> rec_insertion_sort(col, len(col))\n>>> col\n[1]"
  },
  {
    "function": "insert_next",
    "code": "def insert_next(collection: list, index: int):\n    \"\"\"\n    Inserts the '(index-1)th' element into place\n\n    >>> col = [3, 2, 4, 2]\n    >>> insert_next(col, 1)\n    >>> col\n    [2, 3, 4, 2]\n\n    >>> col = [3, 2, 3]\n    >>> insert_next(col, 2)\n    >>> col\n    [3, 2, 3]\n\n    >>> col = []\n    >>> insert_next(col, 1)\n    >>> col\n    []\n    \"\"\"\n    # Checks order between adjacent elements\n    if index >= len(collection) or collection[index - 1] <= collection[index]:\n        return\n\n    # Swaps adjacent elements since they are not in ascending order\n    collection[index - 1], collection[index] = (\n        collection[index],\n        collection[index - 1],\n    )\n\n    insert_next(collection, index + 1)",
    "docstring": "Inserts the '(index-1)th' element into place\n\n>>> col = [3, 2, 4, 2]\n>>> insert_next(col, 1)\n>>> col\n[2, 3, 4, 2]\n\n>>> col = [3, 2, 3]\n>>> insert_next(col, 2)\n>>> col\n[3, 2, 3]\n\n>>> col = []\n>>> insert_next(col, 1)\n>>> col\n[]"
  },
  {
    "function": "merge",
    "code": "def merge(arr: list[int]) -> list[int]:\n    \"\"\"Return a sorted array.\n    >>> merge([10,9,8,7,6,5,4,3,2,1])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> merge([1,2,3,4,5,6,7,8,9,10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> merge([10,22,1,2,3,9,15,23])\n    [1, 2, 3, 9, 10, 15, 22, 23]\n    >>> merge([100])\n    [100]\n    >>> merge([])\n    []\n    \"\"\"\n    if len(arr) > 1:\n        middle_length = len(arr) // 2  # Finds the middle of the array\n        left_array = arr[\n            :middle_length\n        ]  # Creates an array of the elements in the first half.\n        right_array = arr[\n            middle_length:\n        ]  # Creates an array of the elements in the second half.\n        left_size = len(left_array)\n        right_size = len(right_array)\n        merge(left_array)  # Starts sorting the left.\n        merge(right_array)  # Starts sorting the right\n        left_index = 0  # Left Counter\n        right_index = 0  # Right Counter\n        index = 0  # Position Counter\n        while (\n            left_index < left_size and right_index < right_size\n        ):  # Runs until the lowers size of the left and right are sorted.\n            if left_array[left_index] < right_array[right_index]:\n                arr[index] = left_array[left_index]\n                left_index += 1\n            else:\n                arr[index] = right_array[right_index]\n                right_index += 1\n            index += 1\n        while (\n            left_index < left_size\n        ):  # Adds the left over elements in the left half of the array\n            arr[index] = left_array[left_index]\n            left_index += 1\n            index += 1\n        while (\n            right_index < right_size\n        ):  # Adds the left over elements in the right half of the array\n            arr[index] = right_array[right_index]\n            right_index += 1\n            index += 1\n    return arr",
    "docstring": "Return a sorted array.\n>>> merge([10,9,8,7,6,5,4,3,2,1])\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> merge([1,2,3,4,5,6,7,8,9,10])\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> merge([10,22,1,2,3,9,15,23])\n[1, 2, 3, 9, 10, 15, 22, 23]\n>>> merge([100])\n[100]\n>>> merge([])\n[]"
  },
  {
    "function": "quick_sort",
    "code": "def quick_sort(data: list) -> list:\n    \"\"\"\n    >>> for data in ([2, 1, 0], [2.2, 1.1, 0], \"quick_sort\"):\n    ...     quick_sort(data) == sorted(data)\n    True\n    True\n    True\n    \"\"\"\n    if len(data) <= 1:\n        return data\n    else:\n        return [\n            *quick_sort([e for e in data[1:] if e <= data[0]]),\n            data[0],\n            *quick_sort([e for e in data[1:] if e > data[0]]),\n        ]",
    "docstring": ">>> for data in ([2, 1, 0], [2.2, 1.1, 0], \"quick_sort\"):\n...     quick_sort(data) == sorted(data)\nTrue\nTrue\nTrue"
  },
  {
    "function": "selection_sort",
    "code": "def selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection",
    "docstring": "Sorts a list in ascending order using the selection sort algorithm.\n\n:param collection: A list of integers to be sorted.\n:return: The sorted list.\n\nExamples:\n>>> selection_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n\n>>> selection_sort([])\n[]\n\n>>> selection_sort([-2, -5, -45])\n[-45, -5, -2]"
  },
  {
    "function": "shell_sort",
    "code": "def shell_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # Marcin Ciura's gap sequence\n\n    gaps = [701, 301, 132, 57, 23, 10, 4, 1]\n    for gap in gaps:\n        for i in range(gap, len(collection)):\n            insert_value = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > insert_value:\n                collection[j] = collection[j - gap]\n                j -= gap\n            if j != i:\n                collection[j] = insert_value\n    return collection",
    "docstring": "Pure implementation of shell sort algorithm in Python\n:param collection:  Some mutable ordered collection with heterogeneous\ncomparable items inside\n:return:  the same collection ordered by ascending\n\n>>> shell_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n>>> shell_sort([])\n[]\n>>> shell_sort([-2, -5, -45])\n[-45, -5, -2]"
  },
  {
    "function": "shell_sort",
    "code": "def shell_sort(collection: list) -> list:\n    \"\"\"Implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([3, 2, 1])\n    [1, 2, 3]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([1])\n    [1]\n    \"\"\"\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection",
    "docstring": "Implementation of shell sort algorithm in Python\n:param collection:  Some mutable ordered collection with heterogeneous\ncomparable items inside\n:return:  the same collection ordered by ascending\n\n>>> shell_sort([3, 2, 1])\n[1, 2, 3]\n>>> shell_sort([])\n[]\n>>> shell_sort([1])\n[1]"
  },
  {
    "function": "slowsort",
    "code": "def slowsort(sequence: list, start: int | None = None, end: int | None = None) -> None:\n    \"\"\"\n    Sorts sequence[start..end] (both inclusive) in-place.\n    start defaults to 0 if not given.\n    end defaults to len(sequence) - 1 if not given.\n    It returns None.\n    >>> seq = [1, 6, 2, 5, 3, 4, 4, 5]; slowsort(seq); seq\n    [1, 2, 3, 4, 4, 5, 5, 6]\n    >>> seq = []; slowsort(seq); seq\n    []\n    >>> seq = [2]; slowsort(seq); seq\n    [2]\n    >>> seq = [1, 2, 3, 4]; slowsort(seq); seq\n    [1, 2, 3, 4]\n    >>> seq = [4, 3, 2, 1]; slowsort(seq); seq\n    [1, 2, 3, 4]\n    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, 2, 7); seq\n    [9, 8, 2, 3, 4, 5, 6, 7, 1, 0]\n    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, end = 4); seq\n    [5, 6, 7, 8, 9, 4, 3, 2, 1, 0]\n    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, start = 5); seq\n    [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\n    \"\"\"\n    if start is None:\n        start = 0\n\n    if end is None:\n        end = len(sequence) - 1\n\n    if start >= end:\n        return\n\n    mid = (start + end) // 2\n\n    slowsort(sequence, start, mid)\n    slowsort(sequence, mid + 1, end)\n\n    if sequence[end] < sequence[mid]:\n        sequence[end], sequence[mid] = sequence[mid], sequence[end]\n\n    slowsort(sequence, start, end - 1)",
    "docstring": "Sorts sequence[start..end] (both inclusive) in-place.\nstart defaults to 0 if not given.\nend defaults to len(sequence) - 1 if not given.\nIt returns None.\n>>> seq = [1, 6, 2, 5, 3, 4, 4, 5]; slowsort(seq); seq\n[1, 2, 3, 4, 4, 5, 5, 6]\n>>> seq = []; slowsort(seq); seq\n[]\n>>> seq = [2]; slowsort(seq); seq\n[2]\n>>> seq = [1, 2, 3, 4]; slowsort(seq); seq\n[1, 2, 3, 4]\n>>> seq = [4, 3, 2, 1]; slowsort(seq); seq\n[1, 2, 3, 4]\n>>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, 2, 7); seq\n[9, 8, 2, 3, 4, 5, 6, 7, 1, 0]\n>>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, end = 4); seq\n[5, 6, 7, 8, 9, 4, 3, 2, 1, 0]\n>>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, start = 5); seq\n[9, 8, 7, 6, 5, 0, 1, 2, 3, 4]"
  },
  {
    "function": "stalin_sort",
    "code": "def stalin_sort(sequence: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Stalin sort algorithm.\n\n    >>> stalin_sort([4, 3, 5, 2, 1, 7])\n    [4, 5, 7]\n\n    >>> stalin_sort([1, 2, 3, 4])\n    [1, 2, 3, 4]\n\n    >>> stalin_sort([4, 5, 5, 2, 3])\n    [4, 5, 5]\n\n    >>> stalin_sort([6, 11, 12, 4, 1, 5])\n    [6, 11, 12]\n\n    >>> stalin_sort([5, 0, 4, 3])\n    [5]\n\n    >>> stalin_sort([5, 4, 3, 2, 1])\n    [5]\n\n    >>> stalin_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> stalin_sort([1, 2, 8, 7, 6])\n    [1, 2, 8]\n    \"\"\"\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result",
    "docstring": "Sorts a list using the Stalin sort algorithm.\n\n>>> stalin_sort([4, 3, 5, 2, 1, 7])\n[4, 5, 7]\n\n>>> stalin_sort([1, 2, 3, 4])\n[1, 2, 3, 4]\n\n>>> stalin_sort([4, 5, 5, 2, 3])\n[4, 5, 5]\n\n>>> stalin_sort([6, 11, 12, 4, 1, 5])\n[6, 11, 12]\n\n>>> stalin_sort([5, 0, 4, 3])\n[5]\n\n>>> stalin_sort([5, 4, 3, 2, 1])\n[5]\n\n>>> stalin_sort([1, 2, 3, 4, 5])\n[1, 2, 3, 4, 5]\n\n>>> stalin_sort([1, 2, 8, 7, 6])\n[1, 2, 8]"
  },
  {
    "function": "stooge_sort",
    "code": "def stooge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    Examples:\n    >>> stooge_sort([18.1, 0, -7.1, -1, 2, 2])\n    [-7.1, -1, 0, 2, 2, 18.1]\n\n    >>> stooge_sort([])\n    []\n    \"\"\"\n    stooge(arr, 0, len(arr) - 1)\n    return arr",
    "docstring": "Examples:\n>>> stooge_sort([18.1, 0, -7.1, -1, 2, 2])\n[-7.1, -1, 0, 2, 2, 18.1]\n\n>>> stooge_sort([])\n[]"
  },
  {
    "function": "strand_sort",
    "code": "def strand_sort(arr: list, reverse: bool = False, solution: list | None = None) -> list:\n    \"\"\"\n    Strand sort implementation\n    source: https://en.wikipedia.org/wiki/Strand_sort\n\n    :param arr: Unordered input list\n    :param reverse: Descent ordering flag\n    :param solution: Ordered items container\n\n    Examples:\n    >>> strand_sort([4, 2, 5, 3, 0, 1])\n    [0, 1, 2, 3, 4, 5]\n\n    >>> strand_sort([4, 2, 5, 3, 0, 1], reverse=True)\n    [5, 4, 3, 2, 1, 0]\n    \"\"\"\n    _operator = operator.lt if reverse else operator.gt\n    solution = solution or []\n\n    if not arr:\n        return solution\n\n    sublist = [arr.pop(0)]\n    for i, item in enumerate(arr):\n        if _operator(item, sublist[-1]):\n            sublist.append(item)\n            arr.pop(i)\n\n    #  merging sublist into solution list\n    if not solution:\n        solution.extend(sublist)\n    else:\n        while sublist:\n            item = sublist.pop(0)\n            for i, xx in enumerate(solution):\n                if not _operator(item, xx):\n                    solution.insert(i, item)\n                    break\n            else:\n                solution.append(item)\n\n    strand_sort(arr, reverse, solution)\n    return solution",
    "docstring": "Strand sort implementation\nsource: https://en.wikipedia.org/wiki/Strand_sort\n\n:param arr: Unordered input list\n:param reverse: Descent ordering flag\n:param solution: Ordered items container\n\nExamples:\n>>> strand_sort([4, 2, 5, 3, 0, 1])\n[0, 1, 2, 3, 4, 5]\n\n>>> strand_sort([4, 2, 5, 3, 0, 1], reverse=True)\n[5, 4, 3, 2, 1, 0]"
  },
  {
    "function": "tim_sort",
    "code": "def tim_sort(lst):\n    \"\"\"\n    >>> tim_sort(\"Python\")\n    ['P', 'h', 'n', 'o', 't', 'y']\n    >>> tim_sort((1.1, 1, 0, -1, -1.1))\n    [-1.1, -1, 0, 1, 1.1]\n    >>> tim_sort(list(reversed(list(range(7)))))\n    [0, 1, 2, 3, 4, 5, 6]\n    >>> tim_sort([3, 2, 1]) == insertion_sort([3, 2, 1])\n    True\n    >>> tim_sort([3, 2, 1]) == sorted([3, 2, 1])\n    True\n    \"\"\"\n    length = len(lst)\n    runs, sorted_runs = [], []\n    new_run = [lst[0]]\n    sorted_array = []\n    i = 1\n    while i < length:\n        if lst[i] < lst[i - 1]:\n            runs.append(new_run)\n            new_run = [lst[i]]\n        else:\n            new_run.append(lst[i])\n        i += 1\n    runs.append(new_run)\n\n    for run in runs:\n        sorted_runs.append(insertion_sort(run))\n    for run in sorted_runs:\n        sorted_array = merge(sorted_array, run)\n\n    return sorted_array",
    "docstring": ">>> tim_sort(\"Python\")\n['P', 'h', 'n', 'o', 't', 'y']\n>>> tim_sort((1.1, 1, 0, -1, -1.1))\n[-1.1, -1, 0, 1, 1.1]\n>>> tim_sort(list(reversed(list(range(7)))))\n[0, 1, 2, 3, 4, 5, 6]\n>>> tim_sort([3, 2, 1]) == insertion_sort([3, 2, 1])\nTrue\n>>> tim_sort([3, 2, 1]) == sorted([3, 2, 1])\nTrue"
  },
  {
    "function": "topological_sort",
    "code": "def topological_sort(start: str, visited: list[str], sort: list[str]) -> list[str]:\n    \"\"\"Perform topological sort on a directed acyclic graph.\"\"\"\n    current = start\n    # add current to visited\n    visited.append(current)\n    neighbors = edges[current]\n    for neighbor in neighbors:\n        # if neighbor not in visited, visit\n        if neighbor not in visited:\n            sort = topological_sort(neighbor, visited, sort)\n    # if all neighbors visited add current to sort\n    sort.append(current)\n    # if all vertices haven't been visited select a new one to visit\n    if len(visited) != len(vertices):\n        for vertice in vertices:\n            if vertice not in visited:\n                sort = topological_sort(vertice, visited, sort)\n    # return sort\n    return sort",
    "docstring": "Perform topological sort on a directed acyclic graph."
  },
  {
    "function": "tree_sort",
    "code": "def tree_sort(arr: list[int]) -> tuple[int, ...]:\n    \"\"\"\n    >>> tree_sort([])\n    ()\n    >>> tree_sort((1,))\n    (1,)\n    >>> tree_sort((1, 2))\n    (1, 2)\n    >>> tree_sort([5, 2, 7])\n    (2, 5, 7)\n    >>> tree_sort((5, -4, 9, 2, 7))\n    (-4, 2, 5, 7, 9)\n    >>> tree_sort([5, 6, 1, -1, 4, 37, 2, 7])\n    (-1, 1, 2, 4, 5, 6, 7, 37)\n\n    # >>> tree_sort(range(10, -10, -1)) == tuple(sorted(range(10, -10, -1)))\n    # True\n    \"\"\"\n    if len(arr) == 0:\n        return tuple(arr)\n    root = Node(arr[0])\n    for item in arr[1:]:\n        root.insert(item)\n    return tuple(root)",
    "docstring": ">>> tree_sort([])\n()\n>>> tree_sort((1,))\n(1,)\n>>> tree_sort((1, 2))\n(1, 2)\n>>> tree_sort([5, 2, 7])\n(2, 5, 7)\n>>> tree_sort((5, -4, 9, 2, 7))\n(-4, 2, 5, 7, 9)\n>>> tree_sort([5, 6, 1, -1, 4, 37, 2, 7])\n(-1, 1, 2, 4, 5, 6, 7, 37)\n\n# >>> tree_sort(range(10, -10, -1)) == tuple(sorted(range(10, -10, -1)))\n# True"
  },
  {
    "function": "merge_sort",
    "code": "def merge_sort(collection):\n    \"\"\"Pure implementation of the fastest merge sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: a collection ordered by ascending\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_sort([])\n    []\n\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    start, end = [], []\n    while len(collection) > 1:\n        min_one, max_one = min(collection), max(collection)\n        start.append(min_one)\n        end.append(max_one)\n        collection.remove(min_one)\n        collection.remove(max_one)\n    end.reverse()\n    return start + collection + end",
    "docstring": "Pure implementation of the fastest merge sort algorithm in Python\n\n:param collection: some mutable ordered collection with heterogeneous\ncomparable items inside\n:return: a collection ordered by ascending\n\nExamples:\n>>> merge_sort([0, 5, 3, 2, 2])\n[0, 2, 2, 3, 5]\n\n>>> merge_sort([])\n[]\n\n>>> merge_sort([-2, -5, -45])\n[-45, -5, -2]"
  },
  {
    "function": "wiggle_sort",
    "code": "def wiggle_sort(nums: list) -> list:\n    \"\"\"\n    Python implementation of wiggle.\n    Example:\n    >>> wiggle_sort([0, 5, 3, 2, 2])\n    [0, 5, 2, 3, 2]\n    >>> wiggle_sort([])\n    []\n    >>> wiggle_sort([-2, -5, -45])\n    [-45, -2, -5]\n    >>> wiggle_sort([-2.1, -5.68, -45.11])\n    [-45.11, -2.1, -5.68]\n    \"\"\"\n    for i, _ in enumerate(nums):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\n    return nums",
    "docstring": "Python implementation of wiggle.\nExample:\n>>> wiggle_sort([0, 5, 3, 2, 2])\n[0, 5, 2, 3, 2]\n>>> wiggle_sort([])\n[]\n>>> wiggle_sort([-2, -5, -45])\n[-45, -2, -5]\n>>> wiggle_sort([-2.1, -5.68, -45.11])\n[-45.11, -2.1, -5.68]"
  },
  {
    "function": "alternative_string_arrange",
    "code": "def alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)",
    "docstring": "Return the alternative arrangements of the two strings.\n:param first_str:\n:param second_str:\n:return: String\n>>> alternative_string_arrange(\"ABCD\", \"XY\")\n'AXBYCD'\n>>> alternative_string_arrange(\"XY\", \"ABCD\")\n'XAYBCD'\n>>> alternative_string_arrange(\"AB\", \"XYZ\")\n'AXBYZ'\n>>> alternative_string_arrange(\"ABC\", \"\")\n'ABC'"
  },
  {
    "function": "signature",
    "code": "def signature(word: str) -> str:\n    \"\"\"\n    Return a word's frequency-based signature.\n\n    >>> signature(\"test\")\n    'e1s1t2'\n    >>> signature(\"this is a test\")\n    ' 3a1e1h1i2s3t3'\n    >>> signature(\"finaltest\")\n    'a1e1f1i1l1n1s1t2'\n    \"\"\"\n    frequencies = collections.Counter(word)\n    return \"\".join(\n        f\"{char}{frequency}\" for char, frequency in sorted(frequencies.items())\n    )",
    "docstring": "Return a word's frequency-based signature.\n\n>>> signature(\"test\")\n'e1s1t2'\n>>> signature(\"this is a test\")\n' 3a1e1h1i2s3t3'\n>>> signature(\"finaltest\")\n'a1e1f1i1l1n1s1t2'"
  },
  {
    "function": "anagram",
    "code": "def anagram(my_word: str) -> list[str]:\n    \"\"\"\n    Return every anagram of the given word from the dictionary.\n\n    >>> anagram('test')\n    ['sett', 'stet', 'test']\n    >>> anagram('this is a test')\n    []\n    >>> anagram('final')\n    ['final']\n    \"\"\"\n    return word_by_signature[signature(my_word)]",
    "docstring": "Return every anagram of the given word from the dictionary.\n\n>>> anagram('test')\n['sett', 'stet', 'test']\n>>> anagram('this is a test')\n[]\n>>> anagram('final')\n['final']"
  },
  {
    "function": "autocomplete_using_trie",
    "code": "def autocomplete_using_trie(string: str) -> tuple:\n    \"\"\"\n    >>> trie = Trie()\n    >>> for word in words:\n    ...     trie.insert_word(word)\n    ...\n    >>> matches = autocomplete_using_trie(\"de\")\n    >>> \"detergent \" in matches\n    True\n    >>> \"dog \" in matches\n    False\n    \"\"\"\n    suffixes = trie.find_word(string)\n    return tuple(string + word for word in suffixes)",
    "docstring": ">>> trie = Trie()\n>>> for word in words:\n...     trie.insert_word(word)\n...\n>>> matches = autocomplete_using_trie(\"de\")\n>>> \"detergent \" in matches\nTrue\n>>> \"dog \" in matches\nFalse"
  },
  {
    "function": "get_check_digit",
    "code": "def get_check_digit(barcode: int) -> int:\n    \"\"\"\n    Returns the last digit of barcode by excluding the last digit first\n    and then computing to reach the actual last digit from the remaining\n    12 digits.\n\n    >>> get_check_digit(8718452538119)\n    9\n    >>> get_check_digit(87184523)\n    5\n    >>> get_check_digit(87193425381086)\n    9\n    >>> [get_check_digit(x) for x in range(0, 100, 10)]\n    [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]\n    \"\"\"\n    barcode //= 10  # exclude the last digit\n    checker = False\n    s = 0\n\n    # extract and check each digit\n    while barcode != 0:\n        mult = 1 if checker else 3\n        s += mult * (barcode % 10)\n        barcode //= 10\n        checker = not checker\n\n    return (10 - (s % 10)) % 10",
    "docstring": "Returns the last digit of barcode by excluding the last digit first\nand then computing to reach the actual last digit from the remaining\n12 digits.\n\n>>> get_check_digit(8718452538119)\n9\n>>> get_check_digit(87184523)\n5\n>>> get_check_digit(87193425381086)\n9\n>>> [get_check_digit(x) for x in range(0, 100, 10)]\n[0, 7, 4, 1, 8, 5, 2, 9, 6, 3]"
  },
  {
    "function": "is_valid",
    "code": "def is_valid(barcode: int) -> bool:\n    \"\"\"\n    Checks for length of barcode and last-digit\n    Returns boolean value of validity of barcode\n\n    >>> is_valid(8718452538119)\n    True\n    >>> is_valid(87184525)\n    False\n    >>> is_valid(87193425381089)\n    False\n    >>> is_valid(0)\n    False\n    >>> is_valid(dwefgiweuf)\n    Traceback (most recent call last):\n        ...\n    NameError: name 'dwefgiweuf' is not defined\n    \"\"\"\n    return len(str(barcode)) == 13 and get_check_digit(barcode) == barcode % 10",
    "docstring": "Checks for length of barcode and last-digit\nReturns boolean value of validity of barcode\n\n>>> is_valid(8718452538119)\nTrue\n>>> is_valid(87184525)\nFalse\n>>> is_valid(87193425381089)\nFalse\n>>> is_valid(0)\nFalse\n>>> is_valid(dwefgiweuf)\nTraceback (most recent call last):\n    ...\nNameError: name 'dwefgiweuf' is not defined"
  },
  {
    "function": "get_barcode",
    "code": "def get_barcode(barcode: str) -> int:\n    \"\"\"\n    Returns the barcode as an integer\n\n    >>> get_barcode(\"8718452538119\")\n    8718452538119\n    >>> get_barcode(\"dwefgiweuf\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Barcode 'dwefgiweuf' has alphabetic characters.\n    \"\"\"\n    if str(barcode).isalpha():\n        msg = f\"Barcode '{barcode}' has alphabetic characters.\"\n        raise ValueError(msg)\n    elif int(barcode) < 0:\n        raise ValueError(\"The entered barcode has a negative value. Try again.\")\n    else:\n        return int(barcode)",
    "docstring": "Returns the barcode as an integer\n\n>>> get_barcode(\"8718452538119\")\n8718452538119\n>>> get_barcode(\"dwefgiweuf\")\nTraceback (most recent call last):\n    ...\nValueError: Barcode 'dwefgiweuf' has alphabetic characters."
  },
  {
    "function": "bitap_string_match",
    "code": "def bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1",
    "docstring": "Retrieves the index of the first occurrence of pattern in text.\n\nArgs:\n    text: A string consisting only of lowercase alphabetical characters.\n    pattern: A string consisting only of lowercase alphabetical characters.\n\nReturns:\n    int: The index where pattern first occurs. Return -1  if not found.\n\n>>> bitap_string_match('abdabababc', 'ababc')\n5\n>>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n0\n>>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n0\n>>> bitap_string_match('abdabababc', '')\n0\n>>> bitap_string_match('abdabababc', 'c')\n9\n>>> bitap_string_match('abdabababc', 'fofosdfo')\n-1\n>>> bitap_string_match('abdab', 'fofosdfo')\n-1"
  },
  {
    "function": "camel_to_snake_case",
    "code": "def camel_to_snake_case(input_str: str) -> str:\n    \"\"\"\n    Transforms a camelCase (or PascalCase) string to snake_case\n\n    >>> camel_to_snake_case(\"someRandomString\")\n    'some_random_string'\n\n    >>> camel_to_snake_case(\"SomeRandomStr#ng\")\n    'some_random_str_ng'\n\n    >>> camel_to_snake_case(\"123someRandom123String123\")\n    '123_some_random_123_string_123'\n\n    >>> camel_to_snake_case(\"123SomeRandom123String123\")\n    '123_some_random_123_string_123'\n\n    >>> camel_to_snake_case(123)\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected string as input, found <class 'int'>\n\n    \"\"\"\n\n    # check for invalid input type\n    if not isinstance(input_str, str):\n        msg = f\"Expected string as input, found {type(input_str)}\"\n        raise ValueError(msg)\n\n    snake_str = \"\"\n\n    for index, char in enumerate(input_str):\n        if char.isupper():\n            snake_str += \"_\" + char.lower()\n\n        # if char is lowercase but proceeded by a digit:\n        elif input_str[index - 1].isdigit() and char.islower():\n            snake_str += \"_\" + char\n\n        # if char is a digit proceeded by a letter:\n        elif input_str[index - 1].isalpha() and char.isnumeric():\n            snake_str += \"_\" + char.lower()\n\n        # if char is not alphanumeric:\n        elif not char.isalnum():\n            snake_str += \"_\"\n\n        else:\n            snake_str += char\n\n    # remove leading underscore\n    if snake_str[0] == \"_\":\n        snake_str = snake_str[1:]\n\n    return snake_str",
    "docstring": "Transforms a camelCase (or PascalCase) string to snake_case\n\n>>> camel_to_snake_case(\"someRandomString\")\n'some_random_string'\n\n>>> camel_to_snake_case(\"SomeRandomStr#ng\")\n'some_random_str_ng'\n\n>>> camel_to_snake_case(\"123someRandom123String123\")\n'123_some_random_123_string_123'\n\n>>> camel_to_snake_case(\"123SomeRandom123String123\")\n'123_some_random_123_string_123'\n\n>>> camel_to_snake_case(123)\nTraceback (most recent call last):\n    ...\nValueError: Expected string as input, found <class 'int'>"
  },
  {
    "function": "can_string_be_rearranged_as_palindrome_counter",
    "code": "def can_string_be_rearranged_as_palindrome_counter(\n    input_str: str = \"\",\n) -> bool:\n    \"\"\"\n    A Palindrome is a String that reads the same forward as it does backwards.\n    Examples of Palindromes mom, dad, malayalam\n    >>> can_string_be_rearranged_as_palindrome_counter(\"Momo\")\n    True\n    >>> can_string_be_rearranged_as_palindrome_counter(\"Mother\")\n    False\n    >>> can_string_be_rearranged_as_palindrome_counter(\"Father\")\n    False\n    >>> can_string_be_rearranged_as_palindrome_counter(\"A man a plan a canal Panama\")\n    True\n    \"\"\"\n    return sum(c % 2 for c in Counter(input_str.replace(\" \", \"\").lower()).values()) < 2",
    "docstring": "A Palindrome is a String that reads the same forward as it does backwards.\nExamples of Palindromes mom, dad, malayalam\n>>> can_string_be_rearranged_as_palindrome_counter(\"Momo\")\nTrue\n>>> can_string_be_rearranged_as_palindrome_counter(\"Mother\")\nFalse\n>>> can_string_be_rearranged_as_palindrome_counter(\"Father\")\nFalse\n>>> can_string_be_rearranged_as_palindrome_counter(\"A man a plan a canal Panama\")\nTrue"
  },
  {
    "function": "can_string_be_rearranged_as_palindrome",
    "code": "def can_string_be_rearranged_as_palindrome(input_str: str = \"\") -> bool:\n    \"\"\"\n    A Palindrome is a String that reads the same forward as it does backwards.\n    Examples of Palindromes mom, dad, malayalam\n    >>> can_string_be_rearranged_as_palindrome(\"Momo\")\n    True\n    >>> can_string_be_rearranged_as_palindrome(\"Mother\")\n    False\n    >>> can_string_be_rearranged_as_palindrome(\"Father\")\n    False\n    >>> can_string_be_rearranged_as_palindrome_counter(\"A man a plan a canal Panama\")\n    True\n    \"\"\"\n    if len(input_str) == 0:\n        return True\n    lower_case_input_str = input_str.replace(\" \", \"\").lower()\n    # character_freq_dict: Stores the frequency of every character in the input string\n    character_freq_dict: dict[str, int] = {}\n\n    for character in lower_case_input_str:\n        character_freq_dict[character] = character_freq_dict.get(character, 0) + 1\n    \"\"\"\n    Above line of code is equivalent to:\n    1) Getting the frequency of current character till previous index\n    >>> character_freq =  character_freq_dict.get(character, 0)\n    2) Incrementing the frequency of current character by 1\n    >>> character_freq = character_freq + 1\n    3) Updating the frequency of current character\n    >>> character_freq_dict[character] = character_freq\n    \"\"\"\n    \"\"\"\n    OBSERVATIONS:\n    Even length palindrome\n    -> Every character appears even no.of times.\n    Odd length palindrome\n    -> Every character appears even no.of times except for one character.\n    LOGIC:\n    Step 1: We'll count number of characters that appear odd number of times i.e oddChar\n    Step 2:If we find more than 1 character that appears odd number of times,\n    It is not possible to rearrange as a palindrome\n    \"\"\"\n    odd_char = 0\n\n    for character_count in character_freq_dict.values():\n        if character_count % 2:\n            odd_char += 1\n    return not odd_char > 1",
    "docstring": "A Palindrome is a String that reads the same forward as it does backwards.\nExamples of Palindromes mom, dad, malayalam\n>>> can_string_be_rearranged_as_palindrome(\"Momo\")\nTrue\n>>> can_string_be_rearranged_as_palindrome(\"Mother\")\nFalse\n>>> can_string_be_rearranged_as_palindrome(\"Father\")\nFalse\n>>> can_string_be_rearranged_as_palindrome_counter(\"A man a plan a canal Panama\")\nTrue"
  },
  {
    "function": "benchmark",
    "code": "def benchmark(input_str: str = \"\") -> None:\n    \"\"\"\n    Benchmark code for comparing above 2 functions\n    \"\"\"\n    print(\"\\nFor string = \", input_str, \":\")\n    print(\n        \"> can_string_be_rearranged_as_palindrome_counter()\",\n        \"\\tans =\",\n        can_string_be_rearranged_as_palindrome_counter(input_str),\n        \"\\ttime =\",\n        timeit(\n            \"z.can_string_be_rearranged_as_palindrome_counter(z.check_str)\",\n            setup=\"import __main__ as z\",\n        ),\n        \"seconds\",\n    )\n    print(\n        \"> can_string_be_rearranged_as_palindrome()\",\n        \"\\tans =\",\n        can_string_be_rearranged_as_palindrome(input_str),\n        \"\\ttime =\",\n        timeit(\n            \"z.can_string_be_rearranged_as_palindrome(z.check_str)\",\n            setup=\"import __main__ as z\",\n        ),\n        \"seconds\",\n    )",
    "docstring": "Benchmark code for comparing above 2 functions"
  },
  {
    "function": "capitalize",
    "code": "def capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    return sentence[0].upper() + sentence[1:]",
    "docstring": "Capitalizes the first letter of a sentence or word.\n\n>>> capitalize(\"hello world\")\n'Hello world'\n>>> capitalize(\"123 hello world\")\n'123 hello world'\n>>> capitalize(\" hello world\")\n' hello world'\n>>> capitalize(\"a\")\n'A'\n>>> capitalize(\"\")\n''"
  },
  {
    "function": "check_anagrams",
    "code": "def check_anagrams(first_str: str, second_str: str) -> bool:\n    \"\"\"\n    Two strings are anagrams if they are made up of the same letters but are\n    arranged differently (ignoring the case).\n    >>> check_anagrams('Silent', 'Listen')\n    True\n    >>> check_anagrams('This is a string', 'Is this a string')\n    True\n    >>> check_anagrams('This is    a      string', 'Is     this a string')\n    True\n    >>> check_anagrams('There', 'Their')\n    False\n    \"\"\"\n    first_str = first_str.lower().strip()\n    second_str = second_str.lower().strip()\n\n    # Remove whitespace\n    first_str = first_str.replace(\" \", \"\")\n    second_str = second_str.replace(\" \", \"\")\n\n    # Strings of different lengths are not anagrams\n    if len(first_str) != len(second_str):\n        return False\n\n    # Default values for count should be 0\n    count: defaultdict[str, int] = defaultdict(int)\n\n    # For each character in input strings,\n    # increment count in the corresponding\n    for i in range(len(first_str)):\n        count[first_str[i]] += 1\n        count[second_str[i]] -= 1\n\n    return all(_count == 0 for _count in count.values())",
    "docstring": "Two strings are anagrams if they are made up of the same letters but are\narranged differently (ignoring the case).\n>>> check_anagrams('Silent', 'Listen')\nTrue\n>>> check_anagrams('This is a string', 'Is this a string')\nTrue\n>>> check_anagrams('This is    a      string', 'Is     this a string')\nTrue\n>>> check_anagrams('There', 'Their')\nFalse"
  },
  {
    "function": "count_vowels",
    "code": "def count_vowels(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a given string.\n\n    :param s: Input string to count vowels in.\n    :return: Number of vowels in the input string.\n\n    Examples:\n    >>> count_vowels(\"hello world\")\n    3\n    >>> count_vowels(\"HELLO WORLD\")\n    3\n    >>> count_vowels(\"123 hello world\")\n    3\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a quick brown fox\")\n    5\n    >>> count_vowels(\"the quick BROWN fox\")\n    5\n    >>> count_vowels(\"PYTHON\")\n    1\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)",
    "docstring": "Count the number of vowels in a given string.\n\n:param s: Input string to count vowels in.\n:return: Number of vowels in the input string.\n\nExamples:\n>>> count_vowels(\"hello world\")\n3\n>>> count_vowels(\"HELLO WORLD\")\n3\n>>> count_vowels(\"123 hello world\")\n3\n>>> count_vowels(\"\")\n0\n>>> count_vowels(\"a quick brown fox\")\n5\n>>> count_vowels(\"the quick BROWN fox\")\n5\n>>> count_vowels(\"PYTHON\")\n1"
  },
  {
    "function": "validate_initial_digits",
    "code": "def validate_initial_digits(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to validate initial digits of a given credit card number.\n    >>> valid = \"4111111111111111 41111111111111 34 35 37 412345 523456 634567\"\n    >>> all(validate_initial_digits(cc) for cc in valid.split())\n    True\n    >>> invalid = \"14 25 76 32323 36111111111111\"\n    >>> all(validate_initial_digits(cc) is False for cc in invalid.split())\n    True\n    \"\"\"\n    return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))",
    "docstring": "Function to validate initial digits of a given credit card number.\n>>> valid = \"4111111111111111 41111111111111 34 35 37 412345 523456 634567\"\n>>> all(validate_initial_digits(cc) for cc in valid.split())\nTrue\n>>> invalid = \"14 25 76 32323 36111111111111\"\n>>> all(validate_initial_digits(cc) is False for cc in invalid.split())\nTrue"
  },
  {
    "function": "luhn_validation",
    "code": "def luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0",
    "docstring": "Function to luhn algorithm validation for a given credit card number.\n>>> luhn_validation('4111111111111111')\nTrue\n>>> luhn_validation('36111111111111')\nTrue\n>>> luhn_validation('41111111111111')\nFalse"
  },
  {
    "function": "validate_credit_card_number",
    "code": "def validate_credit_card_number(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to validate the given credit card number.\n    >>> validate_credit_card_number('4111111111111111')\n    4111111111111111 is a valid credit card number.\n    True\n    >>> validate_credit_card_number('helloworld$')\n    helloworld$ is an invalid credit card number because it has nonnumerical characters.\n    False\n    >>> validate_credit_card_number('32323')\n    32323 is an invalid credit card number because of its length.\n    False\n    >>> validate_credit_card_number('32323323233232332323')\n    32323323233232332323 is an invalid credit card number because of its length.\n    False\n    >>> validate_credit_card_number('36111111111111')\n    36111111111111 is an invalid credit card number because of its first two digits.\n    False\n    >>> validate_credit_card_number('41111111111111')\n    41111111111111 is an invalid credit card number because it fails the Luhn check.\n    False\n    \"\"\"\n    error_message = f\"{credit_card_number} is an invalid credit card number because\"\n    if not credit_card_number.isdigit():\n        print(f\"{error_message} it has nonnumerical characters.\")\n        return False\n\n    if not 13 <= len(credit_card_number) <= 16:\n        print(f\"{error_message} of its length.\")\n        return False\n\n    if not validate_initial_digits(credit_card_number):\n        print(f\"{error_message} of its first two digits.\")\n        return False\n\n    if not luhn_validation(credit_card_number):\n        print(f\"{error_message} it fails the Luhn check.\")\n        return False\n\n    print(f\"{credit_card_number} is a valid credit card number.\")\n    return True",
    "docstring": "Function to validate the given credit card number.\n>>> validate_credit_card_number('4111111111111111')\n4111111111111111 is a valid credit card number.\nTrue\n>>> validate_credit_card_number('helloworld$')\nhelloworld$ is an invalid credit card number because it has nonnumerical characters.\nFalse\n>>> validate_credit_card_number('32323')\n32323 is an invalid credit card number because of its length.\nFalse\n>>> validate_credit_card_number('32323323233232332323')\n32323323233232332323 is an invalid credit card number because of its length.\nFalse\n>>> validate_credit_card_number('36111111111111')\n36111111111111 is an invalid credit card number because of its first two digits.\nFalse\n>>> validate_credit_card_number('41111111111111')\n41111111111111 is an invalid credit card number because it fails the Luhn check.\nFalse"
  },
  {
    "function": "damerau_levenshtein_distance",
    "code": "def damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    \"\"\"\n    Implements the Damerau-Levenshtein distance algorithm that measures\n    the edit distance between two strings.\n\n    Parameters:\n        first_string: The first string to compare\n        second_string: The second string to compare\n\n    Returns:\n        distance: The edit distance between the first and second strings\n\n    >>> damerau_levenshtein_distance(\"cat\", \"cut\")\n    1\n    >>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n    3\n    >>> damerau_levenshtein_distance(\"hello\", \"world\")\n    4\n    >>> damerau_levenshtein_distance(\"book\", \"back\")\n    2\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    \"\"\"\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]",
    "docstring": "Implements the Damerau-Levenshtein distance algorithm that measures\nthe edit distance between two strings.\n\nParameters:\n    first_string: The first string to compare\n    second_string: The second string to compare\n\nReturns:\n    distance: The edit distance between the first and second strings\n\n>>> damerau_levenshtein_distance(\"cat\", \"cut\")\n1\n>>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n3\n>>> damerau_levenshtein_distance(\"hello\", \"world\")\n4\n>>> damerau_levenshtein_distance(\"book\", \"back\")\n2\n>>> damerau_levenshtein_distance(\"container\", \"containment\")\n3\n>>> damerau_levenshtein_distance(\"container\", \"containment\")\n3"
  },
  {
    "function": "remove_non_letters",
    "code": "def remove_non_letters(message: str) -> str:\n    \"\"\"\n    >>> remove_non_letters(\"Hi! how are you?\")\n    'Hi how are you'\n    >>> remove_non_letters(\"P^y%t)h@o*n\")\n    'Python'\n    >>> remove_non_letters(\"1+1=2\")\n    ''\n    >>> remove_non_letters(\"www.google.com/\")\n    'wwwgooglecom'\n    >>> remove_non_letters(\"\")\n    ''\n    \"\"\"\n    return \"\".join(symbol for symbol in message if symbol in LETTERS_AND_SPACE)",
    "docstring": ">>> remove_non_letters(\"Hi! how are you?\")\n'Hi how are you'\n>>> remove_non_letters(\"P^y%t)h@o*n\")\n'Python'\n>>> remove_non_letters(\"1+1=2\")\n''\n>>> remove_non_letters(\"www.google.com/\")\n'wwwgooglecom'\n>>> remove_non_letters(\"\")\n''"
  },
  {
    "function": "is_english",
    "code": "def is_english(\n    message: str, word_percentage: int = 20, letter_percentage: int = 85\n) -> bool:\n    \"\"\"\n    >>> is_english('Hello World')\n    True\n    >>> is_english('llold HorWd')\n    False\n    \"\"\"\n    words_match = get_english_count(message) * 100 >= word_percentage\n    num_letters = len(remove_non_letters(message))\n    message_letters_percentage = (float(num_letters) / len(message)) * 100\n    letters_match = message_letters_percentage >= letter_percentage\n    return words_match and letters_match",
    "docstring": ">>> is_english('Hello World')\nTrue\n>>> is_english('llold HorWd')\nFalse"
  },
  {
    "function": "dna",
    "code": "def dna(dna: str) -> str:\n    \"\"\"\n    https://en.wikipedia.org/wiki/DNA\n    Returns the second side of a DNA strand\n\n    >>> dna(\"GCTA\")\n    'CGAT'\n    >>> dna(\"ATGC\")\n    'TACG'\n    >>> dna(\"CTGA\")\n    'GACT'\n    >>> dna(\"GFGG\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid Strand\n    \"\"\"\n\n    if len(re.findall(\"[ATCG]\", dna)) != len(dna):\n        raise ValueError(\"Invalid Strand\")\n\n    return dna.translate(dna.maketrans(\"ATCG\", \"TAGC\"))",
    "docstring": "https://en.wikipedia.org/wiki/DNA\nReturns the second side of a DNA strand\n\n>>> dna(\"GCTA\")\n'CGAT'\n>>> dna(\"ATGC\")\n'TACG'\n>>> dna(\"CTGA\")\n'GACT'\n>>> dna(\"GFGG\")\nTraceback (most recent call last):\n    ...\nValueError: Invalid Strand"
  },
  {
    "function": "edit_distance",
    "code": "def edit_distance(source: str, target: str) -> int:\n    \"\"\"\n    Edit distance algorithm is a string metric, i.e., it is a way of quantifying how\n    dissimilar two strings are to one another. It is measured by counting the minimum\n    number of operations required to transform one string into another.\n\n    This implementation assumes that the cost of operations (insertion, deletion and\n    substitution) is always 1\n\n    Args:\n    source: the initial string with respect to which we are calculating the edit\n        distance for the target\n    target: the target string, formed after performing n operations on the source string\n\n    >>> edit_distance(\"GATTIC\", \"GALTIC\")\n    1\n    >>> edit_distance(\"NUM3\", \"HUM2\")\n    2\n    >>> edit_distance(\"cap\", \"CAP\")\n    3\n    >>> edit_distance(\"Cat\", \"\")\n    3\n    >>> edit_distance(\"cat\", \"cat\")\n    0\n    >>> edit_distance(\"\", \"123456789\")\n    9\n    >>> edit_distance(\"Be@uty\", \"Beautyyyy!\")\n    5\n    >>> edit_distance(\"lstring\", \"lsstring\")\n    1\n    \"\"\"\n    if len(source) == 0:\n        return len(target)\n    elif len(target) == 0:\n        return len(source)\n\n    delta = int(source[-1] != target[-1])  # Substitution\n    return min(\n        edit_distance(source[:-1], target[:-1]) + delta,\n        edit_distance(source, target[:-1]) + 1,\n        edit_distance(source[:-1], target) + 1,\n    )",
    "docstring": "Edit distance algorithm is a string metric, i.e., it is a way of quantifying how\ndissimilar two strings are to one another. It is measured by counting the minimum\nnumber of operations required to transform one string into another.\n\nThis implementation assumes that the cost of operations (insertion, deletion and\nsubstitution) is always 1\n\nArgs:\nsource: the initial string with respect to which we are calculating the edit\n    distance for the target\ntarget: the target string, formed after performing n operations on the source string\n\n>>> edit_distance(\"GATTIC\", \"GALTIC\")\n1\n>>> edit_distance(\"NUM3\", \"HUM2\")\n2\n>>> edit_distance(\"cap\", \"CAP\")\n3\n>>> edit_distance(\"Cat\", \"\")\n3\n>>> edit_distance(\"cat\", \"cat\")\n0\n>>> edit_distance(\"\", \"123456789\")\n9\n>>> edit_distance(\"Be@uty\", \"Beautyyyy!\")\n5\n>>> edit_distance(\"lstring\", \"lsstring\")\n1"
  },
  {
    "function": "get_frequency_order",
    "code": "def get_frequency_order(message: str) -> str:\n    \"\"\"\n    Get the frequency order of the letters in the given string\n    >>> get_frequency_order('Hello World')\n    'LOWDRHEZQXJKVBPYGFMUCSNIAT'\n    >>> get_frequency_order('Hello@')\n    'LHOEZQXJKVBPYGFWMUCDRSNIAT'\n    >>> get_frequency_order('h')\n    'HZQXJKVBPYGFWMUCLDRSNIOATE'\n    \"\"\"\n    letter_to_freq = get_letter_count(message)\n    freq_to_letter: dict[int, list[str]] = {\n        freq: [] for letter, freq in letter_to_freq.items()\n    }\n    for letter in LETTERS:\n        freq_to_letter[letter_to_freq[letter]].append(letter)\n\n    freq_to_letter_str: dict[int, str] = {}\n\n    for freq in freq_to_letter:  # noqa: PLC0206\n        freq_to_letter[freq].sort(key=ETAOIN.find, reverse=True)\n        freq_to_letter_str[freq] = \"\".join(freq_to_letter[freq])\n\n    freq_pairs = list(freq_to_letter_str.items())\n    freq_pairs.sort(key=get_item_at_index_zero, reverse=True)\n\n    freq_order: list[str] = [freq_pair[1] for freq_pair in freq_pairs]\n\n    return \"\".join(freq_order)",
    "docstring": "Get the frequency order of the letters in the given string\n>>> get_frequency_order('Hello World')\n'LOWDRHEZQXJKVBPYGFMUCSNIAT'\n>>> get_frequency_order('Hello@')\n'LHOEZQXJKVBPYGFWMUCDRSNIAT'\n>>> get_frequency_order('h')\n'HZQXJKVBPYGFWMUCLDRSNIOATE'"
  },
  {
    "function": "english_freq_match_score",
    "code": "def english_freq_match_score(message: str) -> int:\n    \"\"\"\n    >>> english_freq_match_score('Hello World')\n    1\n    \"\"\"\n    freq_order = get_frequency_order(message)\n    match_score = 0\n    for common_letter in ETAOIN[:6]:\n        if common_letter in freq_order[:6]:\n            match_score += 1\n\n    for uncommon_letter in ETAOIN[-6:]:\n        if uncommon_letter in freq_order[-6:]:\n            match_score += 1\n\n    return match_score",
    "docstring": ">>> english_freq_match_score('Hello World')\n1"
  },
  {
    "function": "hamming_distance",
    "code": "def hamming_distance(string1: str, string2: str) -> int:\n    \"\"\"Calculate the Hamming distance between two equal length strings\n    In information theory, the Hamming distance between two strings of equal\n    length is the number of positions at which the corresponding symbols are\n    different. https://en.wikipedia.org/wiki/Hamming_distance\n\n    Args:\n        string1 (str): Sequence 1\n        string2 (str): Sequence 2\n\n    Returns:\n        int: Hamming distance\n\n    >>> hamming_distance(\"python\", \"python\")\n    0\n    >>> hamming_distance(\"karolin\", \"kathrin\")\n    3\n    >>> hamming_distance(\"00000\", \"11111\")\n    5\n    >>> hamming_distance(\"karolin\", \"kath\")\n    Traceback (most recent call last):\n      ...\n    ValueError: String lengths must match!\n    \"\"\"\n    if len(string1) != len(string2):\n        raise ValueError(\"String lengths must match!\")\n\n    count = 0\n\n    for char1, char2 in zip(string1, string2):\n        if char1 != char2:\n            count += 1\n\n    return count",
    "docstring": "Calculate the Hamming distance between two equal length strings\nIn information theory, the Hamming distance between two strings of equal\nlength is the number of positions at which the corresponding symbols are\ndifferent. https://en.wikipedia.org/wiki/Hamming_distance\n\nArgs:\n    string1 (str): Sequence 1\n    string2 (str): Sequence 2\n\nReturns:\n    int: Hamming distance\n\n>>> hamming_distance(\"python\", \"python\")\n0\n>>> hamming_distance(\"karolin\", \"kathrin\")\n3\n>>> hamming_distance(\"00000\", \"11111\")\n5\n>>> hamming_distance(\"karolin\", \"kath\")\nTraceback (most recent call last):\n  ...\nValueError: String lengths must match!"
  },
  {
    "function": "indian_phone_validator",
    "code": "def indian_phone_validator(phone: str) -> bool:\n    \"\"\"\n    Determine whether the string is a valid phone number or not\n    :param phone:\n    :return: Boolean\n    >>> indian_phone_validator(\"+91123456789\")\n    False\n    >>> indian_phone_validator(\"+919876543210\")\n    True\n    >>> indian_phone_validator(\"01234567896\")\n    False\n    >>> indian_phone_validator(\"919876543218\")\n    True\n    >>> indian_phone_validator(\"+91-1234567899\")\n    False\n    >>> indian_phone_validator(\"+91-9876543218\")\n    True\n    \"\"\"\n    pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")\n    if match := re.search(pat, phone):\n        return match.string == phone\n    return False",
    "docstring": "Determine whether the string is a valid phone number or not\n:param phone:\n:return: Boolean\n>>> indian_phone_validator(\"+91123456789\")\nFalse\n>>> indian_phone_validator(\"+919876543210\")\nTrue\n>>> indian_phone_validator(\"01234567896\")\nFalse\n>>> indian_phone_validator(\"919876543218\")\nTrue\n>>> indian_phone_validator(\"+91-1234567899\")\nFalse\n>>> indian_phone_validator(\"+91-9876543218\")\nTrue"
  },
  {
    "function": "is_contains_unique_chars",
    "code": "def is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True",
    "docstring": "Check if all characters in the string is unique or not.\n>>> is_contains_unique_chars(\"I_love.py\")\nTrue\n>>> is_contains_unique_chars(\"I don't love Python\")\nFalse\n\nTime complexity: O(n)\nSpace complexity: O(1) 19320 bytes as we are having 144697 characters in unicode"
  },
  {
    "function": "is_isogram",
    "code": "def is_isogram(string: str) -> bool:\n    \"\"\"\n    An isogram is a word in which no letter is repeated.\n    Examples of isograms are uncopyrightable and ambidextrously.\n    >>> is_isogram('Uncopyrightable')\n    True\n    >>> is_isogram('allowance')\n    False\n    >>> is_isogram('copy1')\n    Traceback (most recent call last):\n     ...\n    ValueError: String must only contain alphabetic characters.\n    \"\"\"\n    if not all(x.isalpha() for x in string):\n        raise ValueError(\"String must only contain alphabetic characters.\")\n\n    letters = sorted(string.lower())\n    return len(letters) == len(set(letters))",
    "docstring": "An isogram is a word in which no letter is repeated.\nExamples of isograms are uncopyrightable and ambidextrously.\n>>> is_isogram('Uncopyrightable')\nTrue\n>>> is_isogram('allowance')\nFalse\n>>> is_isogram('copy1')\nTraceback (most recent call last):\n ...\nValueError: String must only contain alphabetic characters."
  },
  {
    "function": "is_pangram",
    "code": "def is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    A Pangram String contains all the alphabets at least once.\n    >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram(\"My name is Unknown\")\n    False\n    >>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram()\n    True\n    \"\"\"\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26",
    "docstring": "A Pangram String contains all the alphabets at least once.\n>>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\nTrue\n>>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\nTrue\n>>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\nTrue\n>>> is_pangram(\"My name is Unknown\")\nFalse\n>>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\nFalse\n>>> is_pangram()\nTrue"
  },
  {
    "function": "is_pangram_faster",
    "code": "def is_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)",
    "docstring": ">>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\nTrue\n>>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\nTrue\n>>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\nTrue\n>>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\nFalse\n>>> is_pangram_faster()\nTrue"
  },
  {
    "function": "is_pangram_fastest",
    "code": "def is_pangram_fastest(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_fastest()\n    True\n    \"\"\"\n    return len({char for char in input_str.lower() if char.isalpha()}) == 26",
    "docstring": ">>> is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\")\nTrue\n>>> is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\")\nTrue\n>>> is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\")\nTrue\n>>> is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\")\nFalse\n>>> is_pangram_fastest()\nTrue"
  },
  {
    "function": "benchmark",
    "code": "def benchmark() -> None:\n    \"\"\"\n    Benchmark code comparing different version.\n    \"\"\"\n    from timeit import timeit\n\n    setup = \"from __main__ import is_pangram, is_pangram_faster, is_pangram_fastest\"\n    print(timeit(\"is_pangram()\", setup=setup))\n    print(timeit(\"is_pangram_faster()\", setup=setup))\n    print(timeit(\"is_pangram_fastest()\", setup=setup))",
    "docstring": "Benchmark code comparing different version."
  },
  {
    "function": "is_polish_national_id",
    "code": "def is_polish_national_id(input_str: str) -> bool:\n    \"\"\"\n    Verification of the correctness of the PESEL number.\n    www-gov-pl.translate.goog/web/gov/czym-jest-numer-pesel?_x_tr_sl=auto&_x_tr_tl=en\n\n    PESEL can start with 0, that's why we take str as input,\n    but convert it to int for some calculations.\n\n\n    >>> is_polish_national_id(123)\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected str as input, found <class 'int'>\n\n    >>> is_polish_national_id(\"abc\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected number as input\n\n    >>> is_polish_national_id(\"02070803628\") # correct PESEL\n    True\n\n    >>> is_polish_national_id(\"02150803629\") # wrong month\n    False\n\n    >>> is_polish_national_id(\"02075503622\") # wrong day\n    False\n\n    >>> is_polish_national_id(\"-99012212349\") # wrong range\n    False\n\n    >>> is_polish_national_id(\"990122123499999\") # wrong range\n    False\n\n    >>> is_polish_national_id(\"02070803621\") # wrong checksum\n    False\n    \"\"\"\n\n    # check for invalid input type\n    if not isinstance(input_str, str):\n        msg = f\"Expected str as input, found {type(input_str)}\"\n        raise ValueError(msg)\n\n    # check if input can be converted to int\n    try:\n        input_int = int(input_str)\n    except ValueError:\n        msg = \"Expected number as input\"\n        raise ValueError(msg)\n\n    # check number range\n    if not 10100000 <= input_int <= 99923199999:\n        return False\n\n    # check month correctness\n    month = int(input_str[2:4])\n\n    if (\n        month not in range(1, 13)  # year 1900-1999\n        and month not in range(21, 33)  # 2000-2099\n        and month not in range(41, 53)  # 2100-2199\n        and month not in range(61, 73)  # 2200-2299\n        and month not in range(81, 93)  # 1800-1899\n    ):\n        return False\n\n    # check day correctness\n    day = int(input_str[4:6])\n\n    if day not in range(1, 32):\n        return False\n\n    # check the checksum\n    multipliers = [1, 3, 7, 9, 1, 3, 7, 9, 1, 3]\n    subtotal = 0\n\n    digits_to_check = str(input_str)[:-1]  # cut off the checksum\n\n    for index, digit in enumerate(digits_to_check):\n        # Multiply corresponding digits and multipliers.\n        # In case of a double-digit result, add only the last digit.\n        subtotal += (int(digit) * multipliers[index]) % 10\n\n    checksum = 10 - subtotal % 10\n\n    return checksum == input_int % 10",
    "docstring": "Verification of the correctness of the PESEL number.\nwww-gov-pl.translate.goog/web/gov/czym-jest-numer-pesel?_x_tr_sl=auto&_x_tr_tl=en\n\nPESEL can start with 0, that's why we take str as input,\nbut convert it to int for some calculations.\n\n\n>>> is_polish_national_id(123)\nTraceback (most recent call last):\n    ...\nValueError: Expected str as input, found <class 'int'>\n\n>>> is_polish_national_id(\"abc\")\nTraceback (most recent call last):\n    ...\nValueError: Expected number as input\n\n>>> is_polish_national_id(\"02070803628\") # correct PESEL\nTrue\n\n>>> is_polish_national_id(\"02150803629\") # wrong month\nFalse\n\n>>> is_polish_national_id(\"02075503622\") # wrong day\nFalse\n\n>>> is_polish_national_id(\"-99012212349\") # wrong range\nFalse\n\n>>> is_polish_national_id(\"990122123499999\") # wrong range\nFalse\n\n>>> is_polish_national_id(\"02070803621\") # wrong checksum\nFalse"
  },
  {
    "function": "is_spain_national_id",
    "code": "def is_spain_national_id(spanish_id: str) -> bool:\n    \"\"\"\n    Spain National Id is a string composed by 8 numbers plus a letter\n    The letter in fact is not part of the ID, it acts as a validator,\n    checking you didn't do a mistake when entering it on a system or\n    are giving a fake one.\n\n    https://en.wikipedia.org/wiki/Documento_Nacional_de_Identidad_(Spain)#Number\n\n    >>> is_spain_national_id(\"12345678Z\")\n    True\n    >>> is_spain_national_id(\"12345678z\")  # It is case-insensitive\n    True\n    >>> is_spain_national_id(\"12345678x\")\n    False\n    >>> is_spain_national_id(\"12345678I\")\n    False\n    >>> is_spain_national_id(\"12345678-Z\")  # Some systems add a dash\n    True\n    >>> is_spain_national_id(\"12345678\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a string of 8 numbers plus letter\n    >>> is_spain_national_id(\"123456709\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a string of 8 numbers plus letter\n    >>> is_spain_national_id(\"1234567--Z\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a string of 8 numbers plus letter\n    >>> is_spain_national_id(\"1234Z\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a string of 8 numbers plus letter\n    >>> is_spain_national_id(\"1234ZzZZ\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a string of 8 numbers plus letter\n    >>> is_spain_national_id(12345678)\n    Traceback (most recent call last):\n        ...\n    TypeError: Expected string as input, found int\n    \"\"\"\n\n    if not isinstance(spanish_id, str):\n        msg = f\"Expected string as input, found {type(spanish_id).__name__}\"\n        raise TypeError(msg)\n\n    spanish_id_clean = spanish_id.replace(\"-\", \"\").upper()\n    if len(spanish_id_clean) != 9:\n        raise ValueError(NUMBERS_PLUS_LETTER)\n\n    try:\n        number = int(spanish_id_clean[0:8])\n        letter = spanish_id_clean[8]\n    except ValueError as ex:\n        raise ValueError(NUMBERS_PLUS_LETTER) from ex\n\n    if letter.isdigit():\n        raise ValueError(NUMBERS_PLUS_LETTER)\n\n    return letter == LOOKUP_LETTERS[number % 23]",
    "docstring": "Spain National Id is a string composed by 8 numbers plus a letter\nThe letter in fact is not part of the ID, it acts as a validator,\nchecking you didn't do a mistake when entering it on a system or\nare giving a fake one.\n\nhttps://en.wikipedia.org/wiki/Documento_Nacional_de_Identidad_(Spain)#Number\n\n>>> is_spain_national_id(\"12345678Z\")\nTrue\n>>> is_spain_national_id(\"12345678z\")  # It is case-insensitive\nTrue\n>>> is_spain_national_id(\"12345678x\")\nFalse\n>>> is_spain_national_id(\"12345678I\")\nFalse\n>>> is_spain_national_id(\"12345678-Z\")  # Some systems add a dash\nTrue\n>>> is_spain_national_id(\"12345678\")\nTraceback (most recent call last):\n    ...\nValueError: Input must be a string of 8 numbers plus letter\n>>> is_spain_national_id(\"123456709\")\nTraceback (most recent call last):\n    ...\nValueError: Input must be a string of 8 numbers plus letter\n>>> is_spain_national_id(\"1234567--Z\")\nTraceback (most recent call last):\n    ...\nValueError: Input must be a string of 8 numbers plus letter\n>>> is_spain_national_id(\"1234Z\")\nTraceback (most recent call last):\n    ...\nValueError: Input must be a string of 8 numbers plus letter\n>>> is_spain_national_id(\"1234ZzZZ\")\nTraceback (most recent call last):\n    ...\nValueError: Input must be a string of 8 numbers plus letter\n>>> is_spain_national_id(12345678)\nTraceback (most recent call last):\n    ...\nTypeError: Expected string as input, found int"
  },
  {
    "function": "is_sri_lankan_phone_number",
    "code": "def is_sri_lankan_phone_number(phone: str) -> bool:\n    \"\"\"\n    Determine whether the string is a valid sri lankan mobile phone number or not\n    References: https://aye.sh/blog/sri-lankan-phone-number-regex\n\n    >>> is_sri_lankan_phone_number(\"+94773283048\")\n    True\n    >>> is_sri_lankan_phone_number(\"+9477-3283048\")\n    True\n    >>> is_sri_lankan_phone_number(\"0718382399\")\n    True\n    >>> is_sri_lankan_phone_number(\"0094702343221\")\n    True\n    >>> is_sri_lankan_phone_number(\"075 3201568\")\n    True\n    >>> is_sri_lankan_phone_number(\"07779209245\")\n    False\n    >>> is_sri_lankan_phone_number(\"0957651234\")\n    False\n    \"\"\"\n\n    pattern = re.compile(r\"^(?:0|94|\\+94|0{2}94)7(0|1|2|4|5|6|7|8)(-| |)\\d{7}$\")\n\n    return bool(re.search(pattern, phone))",
    "docstring": "Determine whether the string is a valid sri lankan mobile phone number or not\nReferences: https://aye.sh/blog/sri-lankan-phone-number-regex\n\n>>> is_sri_lankan_phone_number(\"+94773283048\")\nTrue\n>>> is_sri_lankan_phone_number(\"+9477-3283048\")\nTrue\n>>> is_sri_lankan_phone_number(\"0718382399\")\nTrue\n>>> is_sri_lankan_phone_number(\"0094702343221\")\nTrue\n>>> is_sri_lankan_phone_number(\"075 3201568\")\nTrue\n>>> is_sri_lankan_phone_number(\"07779209245\")\nFalse\n>>> is_sri_lankan_phone_number(\"0957651234\")\nFalse"
  },
  {
    "function": "is_valid_email_address",
    "code": "def is_valid_email_address(email: str) -> bool:\n    \"\"\"\n    Returns True if the passed email address is valid.\n\n    The local part of the email precedes the singular @ symbol and\n    is associated with a display-name. For example, \"john.smith\"\n    The domain is stricter than the local part and follows the @ symbol.\n\n    Global email checks:\n     1. There can only be one @ symbol in the email address. Technically if the\n        @ symbol is quoted in the local-part, then it is valid, however this\n        implementation ignores \"\" for now.\n        (See https://en.wikipedia.org/wiki/Email_address#:~:text=If%20quoted,)\n     2. The local-part and the domain are limited to a certain number of octets. With\n        unicode storing a single character in one byte, each octet is equivalent to\n        a character. Hence, we can just check the length of the string.\n    Checks for the local-part:\n     3. The local-part may contain: upper and lowercase latin letters, digits 0 to 9,\n        and printable characters (!#$%&'*+-/=?^_`{|}~)\n     4. The local-part may also contain a \".\" in any place that is not the first or\n        last character, and may not have more than one \".\" consecutively.\n\n    Checks for the domain:\n     5. The domain may contain: upper and lowercase latin letters and digits 0 to 9\n     6. Hyphen \"-\", provided that it is not the first or last character\n     7. The domain may also contain a \".\" in any place that is not the first or\n        last character, and may not have more than one \".\" consecutively.\n\n    >>> for email, valid in email_tests:\n    ...     assert is_valid_email_address(email) == valid\n    \"\"\"\n\n    # (1.) Make sure that there is only one @ symbol in the email address\n    if email.count(\"@\") != 1:\n        return False\n\n    local_part, domain = email.split(\"@\")\n    # (2.) Check octet length of the local part and domain\n    if len(local_part) > MAX_LOCAL_PART_OCTETS or len(domain) > MAX_DOMAIN_OCTETS:\n        return False\n\n    # (3.) Validate the characters in the local-part\n    if any(\n        char not in string.ascii_letters + string.digits + \".(!#$%&'*+-/=?^_`{|}~)\"\n        for char in local_part\n    ):\n        return False\n\n    # (4.) Validate the placement of \".\" characters in the local-part\n    if local_part.startswith(\".\") or local_part.endswith(\".\") or \"..\" in local_part:\n        return False\n\n    # (5.) Validate the characters in the domain\n    if any(char not in string.ascii_letters + string.digits + \".-\" for char in domain):\n        return False\n\n    # (6.) Validate the placement of \"-\" characters\n    if domain.startswith(\"-\") or domain.endswith(\".\"):\n        return False\n\n    # (7.) Validate the placement of \".\" characters\n    return not (domain.startswith(\".\") or domain.endswith(\".\") or \"..\" in domain)",
    "docstring": "Returns True if the passed email address is valid.\n\nThe local part of the email precedes the singular @ symbol and\nis associated with a display-name. For example, \"john.smith\"\nThe domain is stricter than the local part and follows the @ symbol.\n\nGlobal email checks:\n 1. There can only be one @ symbol in the email address. Technically if the\n    @ symbol is quoted in the local-part, then it is valid, however this\n    implementation ignores \"\" for now.\n    (See https://en.wikipedia.org/wiki/Email_address#:~:text=If%20quoted,)\n 2. The local-part and the domain are limited to a certain number of octets. With\n    unicode storing a single character in one byte, each octet is equivalent to\n    a character. Hence, we can just check the length of the string.\nChecks for the local-part:\n 3. The local-part may contain: upper and lowercase latin letters, digits 0 to 9,\n    and printable characters (!#$%&'*+-/=?^_`{|}~)\n 4. The local-part may also contain a \".\" in any place that is not the first or\n    last character, and may not have more than one \".\" consecutively.\n\nChecks for the domain:\n 5. The domain may contain: upper and lowercase latin letters and digits 0 to 9\n 6. Hyphen \"-\", provided that it is not the first or last character\n 7. The domain may also contain a \".\" in any place that is not the first or\n    last character, and may not have more than one \".\" consecutively.\n\n>>> for email, valid in email_tests:\n...     assert is_valid_email_address(email) == valid"
  },
  {
    "function": "jaro_winkler",
    "code": "def jaro_winkler(str1: str, str2: str) -> float:\n    \"\"\"\n    Jaro-Winkler distance is a string metric measuring an edit distance between two\n    sequences.\n    Output value is between 0.0 and 1.0.\n\n    >>> jaro_winkler(\"martha\", \"marhta\")\n    0.9611111111111111\n    >>> jaro_winkler(\"CRATE\", \"TRACE\")\n    0.7333333333333334\n    >>> jaro_winkler(\"test\", \"dbdbdbdb\")\n    0.0\n    >>> jaro_winkler(\"test\", \"test\")\n    1.0\n    >>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n    0.6363636363636364\n    >>> jaro_winkler(\"test\", \"\")\n    0.0\n    >>> jaro_winkler(\"hello\", \"world\")\n    0.4666666666666666\n    >>> jaro_winkler(\"hell**o\", \"*world\")\n    0.4365079365079365\n    \"\"\"\n\n    def get_matched_characters(_str1: str, _str2: str) -> str:\n        matched = []\n        limit = min(len(_str1), len(_str2)) // 2\n        for i, char in enumerate(_str1):\n            left = int(max(0, i - limit))\n            right = int(min(i + limit + 1, len(_str2)))\n            if char in _str2[left:right]:\n                matched.append(char)\n                _str2 = (\n                    f\"{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}\"\n                )\n\n        return \"\".join(matched)\n\n    # matching characters\n    matching_1 = get_matched_characters(str1, str2)\n    matching_2 = get_matched_characters(str2, str1)\n    match_count = len(matching_1)\n\n    # transposition\n    transpositions = (\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\n    )\n\n    if not match_count:\n        jaro = 0.0\n    else:\n        jaro = (\n            1\n            / 3\n            * (\n                match_count / len(str1)\n                + match_count / len(str2)\n                + (match_count - transpositions) / match_count\n            )\n        )\n\n    # common prefix up to 4 characters\n    prefix_len = 0\n    for c1, c2 in zip(str1[:4], str2[:4]):\n        if c1 == c2:\n            prefix_len += 1\n        else:\n            break\n\n    return jaro + 0.1 * prefix_len * (1 - jaro)",
    "docstring": "Jaro-Winkler distance is a string metric measuring an edit distance between two\nsequences.\nOutput value is between 0.0 and 1.0.\n\n>>> jaro_winkler(\"martha\", \"marhta\")\n0.9611111111111111\n>>> jaro_winkler(\"CRATE\", \"TRACE\")\n0.7333333333333334\n>>> jaro_winkler(\"test\", \"dbdbdbdb\")\n0.0\n>>> jaro_winkler(\"test\", \"test\")\n1.0\n>>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n0.6363636363636364\n>>> jaro_winkler(\"test\", \"\")\n0.0\n>>> jaro_winkler(\"hello\", \"world\")\n0.4666666666666666\n>>> jaro_winkler(\"hell**o\", \"*world\")\n0.4365079365079365"
  },
  {
    "function": "join",
    "code": "def join(separator: str, separated: list[str]) -> str:\n    \"\"\"\n    Joins a list of strings using a separator\n    and returns the result.\n\n    :param separator: Separator to be used\n                for joining the strings.\n    :param separated: List of strings to be joined.\n\n    :return: Joined string with the specified separator.\n\n    Examples:\n\n    >>> join(\"\", [\"a\", \"b\", \"c\", \"d\"])\n    'abcd'\n    >>> join(\"#\", [\"a\", \"b\", \"c\", \"d\"])\n    'a#b#c#d'\n    >>> join(\"#\", \"a\")\n    'a'\n    >>> join(\" \", [\"You\", \"are\", \"amazing!\"])\n    'You are amazing!'\n    >>> join(\",\", [\"\", \"\", \"\"])\n    ',,'\n\n    This example should raise an\n    exception for non-string elements:\n    >>> join(\"#\", [\"a\", \"b\", \"c\", 1])\n    Traceback (most recent call last):\n        ...\n    Exception: join() accepts only strings\n\n    Additional test case with a different separator:\n    >>> join(\"-\", [\"apple\", \"banana\", \"cherry\"])\n    'apple-banana-cherry'\n    \"\"\"\n\n    # Check that all elements are strings\n    for word_or_phrase in separated:\n        # If the element is not a string, raise an exception\n        if not isinstance(word_or_phrase, str):\n            raise Exception(\"join() accepts only strings\")\n\n    joined: str = \"\"\n    \"\"\"\n    The last element of the list is not followed by the separator.\n    So, we need to iterate through the list and join each element\n    with the separator except the last element.\n    \"\"\"\n    last_index: int = len(separated) - 1\n    \"\"\"\n    Iterate through the list and join each element with the separator.\n    Except the last element, all other elements are followed by the separator.\n    \"\"\"\n    for word_or_phrase in separated[:last_index]:\n        # join the element with the separator.\n        joined += word_or_phrase + separator\n\n    # If the list is not empty, join the last element.\n    if separated != []:\n        joined += separated[last_index]\n\n    # Return the joined string.\n    return joined",
    "docstring": "Joins a list of strings using a separator\nand returns the result.\n\n:param separator: Separator to be used\n            for joining the strings.\n:param separated: List of strings to be joined.\n\n:return: Joined string with the specified separator.\n\nExamples:\n\n>>> join(\"\", [\"a\", \"b\", \"c\", \"d\"])\n'abcd'\n>>> join(\"#\", [\"a\", \"b\", \"c\", \"d\"])\n'a#b#c#d'\n>>> join(\"#\", \"a\")\n'a'\n>>> join(\" \", [\"You\", \"are\", \"amazing!\"])\n'You are amazing!'\n>>> join(\",\", [\"\", \"\", \"\"])\n',,'\n\nThis example should raise an\nexception for non-string elements:\n>>> join(\"#\", [\"a\", \"b\", \"c\", 1])\nTraceback (most recent call last):\n    ...\nException: join() accepts only strings\n\nAdditional test case with a different separator:\n>>> join(\"-\", [\"apple\", \"banana\", \"cherry\"])\n'apple-banana-cherry'"
  },
  {
    "function": "knuth_morris_pratt",
    "code": "def knuth_morris_pratt(text: str, pattern: str) -> int:\n    \"\"\"\n    The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text\n    with complexity O(n + m)\n\n    1) Preprocess pattern to identify any suffixes that are identical to prefixes\n\n        This tells us where to continue from if we get a mismatch between a character\n        in our pattern and the text.\n\n    2) Step through the text one character at a time and compare it to a character in\n        the pattern updating our location within the pattern if necessary\n\n    >>> kmp = \"knuth_morris_pratt\"\n    >>> all(\n    ...    knuth_morris_pratt(kmp, s) == kmp.find(s)\n    ...    for s in (\"kn\", \"h_m\", \"rr\", \"tt\", \"not there\")\n    ... )\n    True\n    \"\"\"\n\n    # 1) Construct the failure array\n    failure = get_failure_array(pattern)\n\n    # 2) Step through text searching for pattern\n    i, j = 0, 0  # index into text, pattern\n    while i < len(text):\n        if pattern[j] == text[i]:\n            if j == (len(pattern) - 1):\n                return i - j\n            j += 1\n\n        # if this is a prefix in our pattern\n        # just go back far enough to continue\n        elif j > 0:\n            j = failure[j - 1]\n            continue\n        i += 1\n    return -1",
    "docstring": "The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text\nwith complexity O(n + m)\n\n1) Preprocess pattern to identify any suffixes that are identical to prefixes\n\n    This tells us where to continue from if we get a mismatch between a character\n    in our pattern and the text.\n\n2) Step through the text one character at a time and compare it to a character in\n    the pattern updating our location within the pattern if necessary\n\n>>> kmp = \"knuth_morris_pratt\"\n>>> all(\n...    knuth_morris_pratt(kmp, s) == kmp.find(s)\n...    for s in (\"kn\", \"h_m\", \"rr\", \"tt\", \"not there\")\n... )\nTrue"
  },
  {
    "function": "get_failure_array",
    "code": "def get_failure_array(pattern: str) -> list[int]:\n    \"\"\"\n    Calculates the new index we should go to if we fail a comparison\n    :param pattern:\n    :return:\n    \"\"\"\n    failure = [0]\n    i = 0\n    j = 1\n    while j < len(pattern):\n        if pattern[i] == pattern[j]:\n            i += 1\n        elif i > 0:\n            i = failure[i - 1]\n            continue\n        j += 1\n        failure.append(i)\n    return failure",
    "docstring": "Calculates the new index we should go to if we fail a comparison\n:param pattern:\n:return:"
  },
  {
    "function": "levenshtein_distance",
    "code": "def levenshtein_distance(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Implementation of the Levenshtein distance in Python.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance(\"\", \"test\")\n    4\n    >>> levenshtein_distance(\"book\", \"back\")\n    2\n    >>> levenshtein_distance(\"book\", \"book\")\n    0\n    >>> levenshtein_distance(\"test\", \"\")\n    4\n    >>> levenshtein_distance(\"\", \"\")\n    0\n    >>> levenshtein_distance(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    # The longer word should come first\n    if len(first_word) < len(second_word):\n        return levenshtein_distance(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1]\n\n        for j, c2 in enumerate(second_word):\n            # Calculate insertions, deletions, and substitutions\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n\n            # Get the minimum to append to the current row\n            current_row.append(min(insertions, deletions, substitutions))\n\n        # Store the previous row\n        previous_row = current_row\n\n    # Returns the last element (distance)\n    return previous_row[-1]",
    "docstring": "Implementation of the Levenshtein distance in Python.\n:param first_word: the first word to measure the difference.\n:param second_word: the second word to measure the difference.\n:return: the levenshtein distance between the two words.\nExamples:\n>>> levenshtein_distance(\"planet\", \"planetary\")\n3\n>>> levenshtein_distance(\"\", \"test\")\n4\n>>> levenshtein_distance(\"book\", \"back\")\n2\n>>> levenshtein_distance(\"book\", \"book\")\n0\n>>> levenshtein_distance(\"test\", \"\")\n4\n>>> levenshtein_distance(\"\", \"\")\n0\n>>> levenshtein_distance(\"orchestration\", \"container\")\n10"
  },
  {
    "function": "levenshtein_distance_optimized",
    "code": "def levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]",
    "docstring": "Compute the Levenshtein distance between two words (strings).\nThe function is optimized for efficiency by modifying rows in place.\n:param first_word: the first word to measure the difference.\n:param second_word: the second word to measure the difference.\n:return: the Levenshtein distance between the two words.\nExamples:\n>>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n3\n>>> levenshtein_distance_optimized(\"\", \"test\")\n4\n>>> levenshtein_distance_optimized(\"book\", \"back\")\n2\n>>> levenshtein_distance_optimized(\"book\", \"book\")\n0\n>>> levenshtein_distance_optimized(\"test\", \"\")\n4\n>>> levenshtein_distance_optimized(\"\", \"\")\n0\n>>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n10"
  },
  {
    "function": "benchmark_levenshtein_distance",
    "code": "def benchmark_levenshtein_distance(func: Callable) -> None:\n    \"\"\"\n    Benchmark the Levenshtein distance function.\n    :param str: The name of the function being benchmarked.\n    :param func: The function to be benchmarked.\n    \"\"\"\n    from timeit import timeit\n\n    stmt = f\"{func.__name__}('sitting', 'kitten')\"\n    setup = f\"from __main__ import {func.__name__}\"\n    number = 25_000\n    result = timeit(stmt=stmt, setup=setup, number=number)\n    print(f\"{func.__name__:<30} finished {number:,} runs in {result:.5f} seconds\")",
    "docstring": "Benchmark the Levenshtein distance function.\n:param str: The name of the function being benchmarked.\n:param func: The function to be benchmarked."
  },
  {
    "function": "lower",
    "code": "def lower(word: str) -> str:\n    \"\"\"\n    Will convert the entire string to lowercase letters\n\n    >>> lower(\"wow\")\n    'wow'\n    >>> lower(\"HellZo\")\n    'hellzo'\n    >>> lower(\"WHAT\")\n    'what'\n    >>> lower(\"wh[]32\")\n    'wh[]32'\n    >>> lower(\"whAT\")\n    'what'\n    \"\"\"\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)",
    "docstring": "Will convert the entire string to lowercase letters\n\n>>> lower(\"wow\")\n'wow'\n>>> lower(\"HellZo\")\n'hellzo'\n>>> lower(\"WHAT\")\n'what'\n>>> lower(\"wh[]32\")\n'wh[]32'\n>>> lower(\"whAT\")\n'what'"
  },
  {
    "function": "palindromic_string",
    "code": "def palindromic_string(input_string: str) -> str:\n    \"\"\"\n    >>> palindromic_string('abbbaba')\n    'abbba'\n    >>> palindromic_string('ababa')\n    'ababa'\n\n    Manacher's algorithm which finds Longest palindromic Substring in linear time.\n\n    1. first this convert input_string(\"xyx\") into new_string(\"x|y|x\") where odd\n        positions are actual input characters.\n    2. for each character in new_string it find corresponding length and\n        store the length and left,right to store previously calculated info.\n        (please look the explanation for details)\n\n    3. return corresponding output_string by removing all \"|\"\n    \"\"\"\n    max_length = 0\n\n    # if input_string is \"aba\" than new_input_string become \"a|b|a\"\n    new_input_string = \"\"\n    output_string = \"\"\n\n    # append each character + \"|\" in new_string for range(0, length-1)\n    for i in input_string[: len(input_string) - 1]:\n        new_input_string += i + \"|\"\n    # append last character\n    new_input_string += input_string[-1]\n\n    # we will store the starting and ending of previous furthest ending palindromic\n    # substring\n    left, right = 0, 0\n\n    # length[i] shows the length of palindromic substring with center i\n    length = [1 for i in range(len(new_input_string))]\n\n    # for each character in new_string find corresponding palindromic string\n    start = 0\n    for j in range(len(new_input_string)):\n        k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)\n        while (\n            j - k >= 0\n            and j + k < len(new_input_string)\n            and new_input_string[k + j] == new_input_string[j - k]\n        ):\n            k += 1\n\n        length[j] = 2 * k - 1\n\n        # does this string is ending after the previously explored end (that is right) ?\n        # if yes the update the new right to the last index of this\n        if j + k - 1 > right:\n            left = j - k + 1\n            right = j + k - 1\n\n        # update max_length and start position\n        if max_length < length[j]:\n            max_length = length[j]\n            start = j\n\n    # create that string\n    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]\n    for i in s:\n        if i != \"|\":\n            output_string += i\n\n    return output_string",
    "docstring": ">>> palindromic_string('abbbaba')\n'abbba'\n>>> palindromic_string('ababa')\n'ababa'\n\nManacher's algorithm which finds Longest palindromic Substring in linear time.\n\n1. first this convert input_string(\"xyx\") into new_string(\"x|y|x\") where odd\n    positions are actual input characters.\n2. for each character in new_string it find corresponding length and\n    store the length and left,right to store previously calculated info.\n    (please look the explanation for details)\n\n3. return corresponding output_string by removing all \"|\""
  },
  {
    "function": "compute_transform_tables",
    "code": "def compute_transform_tables(\n    source_string: str,\n    destination_string: str,\n    copy_cost: int,\n    replace_cost: int,\n    delete_cost: int,\n    insert_cost: int,\n) -> tuple[list[list[int]], list[list[str]]]:\n    \"\"\"\n    Finds the most cost efficient sequence\n    for converting one string into another.\n\n    >>> costs, operations = compute_transform_tables(\"cat\", \"cut\", 1, 2, 3, 3)\n    >>> costs[0][:4]\n    [0, 3, 6, 9]\n    >>> costs[2][:4]\n    [6, 4, 3, 6]\n    >>> operations[0][:4]\n    ['0', 'Ic', 'Iu', 'It']\n    >>> operations[3][:4]\n    ['Dt', 'Dt', 'Rtu', 'Ct']\n\n    >>> compute_transform_tables(\"\", \"\", 1, 2, 3, 3)\n    ([[0]], [['0']])\n    \"\"\"\n    source_seq = list(source_string)\n    destination_seq = list(destination_string)\n    len_source_seq = len(source_seq)\n    len_destination_seq = len(destination_seq)\n    costs = [\n        [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n    ops = [\n        [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n\n    for i in range(1, len_source_seq + 1):\n        costs[i][0] = i * delete_cost\n        ops[i][0] = f\"D{source_seq[i - 1]}\"\n\n    for i in range(1, len_destination_seq + 1):\n        costs[0][i] = i * insert_cost\n        ops[0][i] = f\"I{destination_seq[i - 1]}\"\n\n    for i in range(1, len_source_seq + 1):\n        for j in range(1, len_destination_seq + 1):\n            if source_seq[i - 1] == destination_seq[j - 1]:\n                costs[i][j] = costs[i - 1][j - 1] + copy_cost\n                ops[i][j] = f\"C{source_seq[i - 1]}\"\n            else:\n                costs[i][j] = costs[i - 1][j - 1] + replace_cost\n                ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])\n\n            if costs[i - 1][j] + delete_cost < costs[i][j]:\n                costs[i][j] = costs[i - 1][j] + delete_cost\n                ops[i][j] = f\"D{source_seq[i - 1]}\"\n\n            if costs[i][j - 1] + insert_cost < costs[i][j]:\n                costs[i][j] = costs[i][j - 1] + insert_cost\n                ops[i][j] = f\"I{destination_seq[j - 1]}\"\n\n    return costs, ops",
    "docstring": "Finds the most cost efficient sequence\nfor converting one string into another.\n\n>>> costs, operations = compute_transform_tables(\"cat\", \"cut\", 1, 2, 3, 3)\n>>> costs[0][:4]\n[0, 3, 6, 9]\n>>> costs[2][:4]\n[6, 4, 3, 6]\n>>> operations[0][:4]\n['0', 'Ic', 'Iu', 'It']\n>>> operations[3][:4]\n['Dt', 'Dt', 'Rtu', 'Ct']\n\n>>> compute_transform_tables(\"\", \"\", 1, 2, 3, 3)\n([[0]], [['0']])"
  },
  {
    "function": "assemble_transformation",
    "code": "def assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:\n    \"\"\"\n    Assembles the transformations based on the ops table.\n\n    >>> ops = [['0', 'Ic', 'Iu', 'It'],\n    ...        ['Dc', 'Cc', 'Iu', 'It'],\n    ...        ['Da', 'Da', 'Rau', 'Rat'],\n    ...        ['Dt', 'Dt', 'Rtu', 'Ct']]\n    >>> x = len(ops) - 1\n    >>> y = len(ops[0]) - 1\n    >>> assemble_transformation(ops, x, y)\n    ['Cc', 'Rau', 'Ct']\n\n    >>> ops1 = [['0']]\n    >>> x1 = len(ops1) - 1\n    >>> y1 = len(ops1[0]) - 1\n    >>> assemble_transformation(ops1, x1, y1)\n    []\n\n    >>> ops2 = [['0', 'I1', 'I2', 'I3'],\n    ...         ['D1', 'C1', 'I2', 'I3'],\n    ...         ['D2', 'D2', 'R23', 'R23']]\n    >>> x2 = len(ops2) - 1\n    >>> y2 = len(ops2[0]) - 1\n    >>> assemble_transformation(ops2, x2, y2)\n    ['C1', 'I2', 'R23']\n    \"\"\"\n    if i == 0 and j == 0:\n        return []\n    elif ops[i][j][0] in {\"C\", \"R\"}:\n        seq = assemble_transformation(ops, i - 1, j - 1)\n        seq.append(ops[i][j])\n        return seq\n    elif ops[i][j][0] == \"D\":\n        seq = assemble_transformation(ops, i - 1, j)\n        seq.append(ops[i][j])\n        return seq\n    else:\n        seq = assemble_transformation(ops, i, j - 1)\n        seq.append(ops[i][j])\n        return seq",
    "docstring": "Assembles the transformations based on the ops table.\n\n>>> ops = [['0', 'Ic', 'Iu', 'It'],\n...        ['Dc', 'Cc', 'Iu', 'It'],\n...        ['Da', 'Da', 'Rau', 'Rat'],\n...        ['Dt', 'Dt', 'Rtu', 'Ct']]\n>>> x = len(ops) - 1\n>>> y = len(ops[0]) - 1\n>>> assemble_transformation(ops, x, y)\n['Cc', 'Rau', 'Ct']\n\n>>> ops1 = [['0']]\n>>> x1 = len(ops1) - 1\n>>> y1 = len(ops1[0]) - 1\n>>> assemble_transformation(ops1, x1, y1)\n[]\n\n>>> ops2 = [['0', 'I1', 'I2', 'I3'],\n...         ['D1', 'C1', 'I2', 'I3'],\n...         ['D2', 'D2', 'R23', 'R23']]\n>>> x2 = len(ops2) - 1\n>>> y2 = len(ops2[0]) - 1\n>>> assemble_transformation(ops2, x2, y2)\n['C1', 'I2', 'R23']"
  },
  {
    "function": "naive_pattern_search",
    "code": "def naive_pattern_search(s: str, pattern: str) -> list:\n    \"\"\"\n    >>> naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\")\n    [4, 10, 18]\n    >>> naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\")\n    []\n    >>> naive_pattern_search(\"\", \"ABC\")\n    []\n    >>> naive_pattern_search(\"TEST\", \"TEST\")\n    [0]\n    >>> naive_pattern_search(\"ABCDEGFTEST\", \"TEST\")\n    [7]\n    \"\"\"\n    pat_len = len(pattern)\n    position = []\n    for i in range(len(s) - pat_len + 1):\n        match_found = True\n        for j in range(pat_len):\n            if s[i + j] != pattern[j]:\n                match_found = False\n                break\n        if match_found:\n            position.append(i)\n    return position",
    "docstring": ">>> naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\")\n[4, 10, 18]\n>>> naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\")\n[]\n>>> naive_pattern_search(\"\", \"ABC\")\n[]\n>>> naive_pattern_search(\"TEST\", \"TEST\")\n[0]\n>>> naive_pattern_search(\"ABCDEGFTEST\", \"TEST\")\n[7]"
  },
  {
    "function": "create_ngram",
    "code": "def create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]",
    "docstring": "Create ngrams from a sentence\n\n>>> create_ngram(\"I am a sentence\", 2)\n['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n>>> create_ngram(\"I am an NLPer\", 2)\n['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n>>> create_ngram(\"This is short\", 50)\n[]"
  },
  {
    "function": "is_palindrome",
    "code": "def is_palindrome(s: str) -> bool:\n    \"\"\"\n    Return True if s is a palindrome otherwise return False.\n\n    >>> all(is_palindrome(key) is value for key, value in test_data.items())\n    True\n    \"\"\"\n\n    start_i = 0\n    end_i = len(s) - 1\n    while start_i < end_i:\n        if s[start_i] == s[end_i]:\n            start_i += 1\n            end_i -= 1\n        else:\n            return False\n    return True",
    "docstring": "Return True if s is a palindrome otherwise return False.\n\n>>> all(is_palindrome(key) is value for key, value in test_data.items())\nTrue"
  },
  {
    "function": "is_palindrome_traversal",
    "code": "def is_palindrome_traversal(s: str) -> bool:\n    \"\"\"\n    Return True if s is a palindrome otherwise return False.\n\n    >>> all(is_palindrome_traversal(key) is value for key, value in test_data.items())\n    True\n    \"\"\"\n    end = len(s) // 2\n    n = len(s)\n\n    # We need to traverse till half of the length of string\n    # as we can get access of the i'th last element from\n    # i'th index.\n    # eg: [0,1,2,3,4,5] => 4th index can be accessed\n    # with the help of 1st index (i==n-i-1)\n    # where n is length of string\n    return all(s[i] == s[n - i - 1] for i in range(end))",
    "docstring": "Return True if s is a palindrome otherwise return False.\n\n>>> all(is_palindrome_traversal(key) is value for key, value in test_data.items())\nTrue"
  },
  {
    "function": "is_palindrome_recursive",
    "code": "def is_palindrome_recursive(s: str) -> bool:\n    \"\"\"\n    Return True if s is a palindrome otherwise return False.\n\n    >>> all(is_palindrome_recursive(key) is value for key, value in test_data.items())\n    True\n    \"\"\"\n    if len(s) <= 1:\n        return True\n    if s[0] == s[len(s) - 1]:\n        return is_palindrome_recursive(s[1:-1])\n    else:\n        return False",
    "docstring": "Return True if s is a palindrome otherwise return False.\n\n>>> all(is_palindrome_recursive(key) is value for key, value in test_data.items())\nTrue"
  },
  {
    "function": "is_palindrome_slice",
    "code": "def is_palindrome_slice(s: str) -> bool:\n    \"\"\"\n    Return True if s is a palindrome otherwise return False.\n\n    >>> all(is_palindrome_slice(key) is value for key, value in test_data.items())\n    True\n    \"\"\"\n    return s == s[::-1]",
    "docstring": "Return True if s is a palindrome otherwise return False.\n\n>>> all(is_palindrome_slice(key) is value for key, value in test_data.items())\nTrue"
  },
  {
    "function": "pig_latin",
    "code": "def pig_latin(word: str) -> str:\n    \"\"\"Compute the piglatin of a given string.\n\n    https://en.wikipedia.org/wiki/Pig_Latin\n\n    Usage examples:\n    >>> pig_latin(\"pig\")\n    'igpay'\n    >>> pig_latin(\"latin\")\n    'atinlay'\n    >>> pig_latin(\"banana\")\n    'ananabay'\n    >>> pig_latin(\"friends\")\n    'iendsfray'\n    >>> pig_latin(\"smile\")\n    'ilesmay'\n    >>> pig_latin(\"string\")\n    'ingstray'\n    >>> pig_latin(\"eat\")\n    'eatway'\n    >>> pig_latin(\"omelet\")\n    'omeletway'\n    >>> pig_latin(\"are\")\n    'areway'\n    >>> pig_latin(\" \")\n    ''\n    >>> pig_latin(None)\n    ''\n    \"\"\"\n    if not (word or \"\").strip():\n        return \"\"\n    word = word.lower()\n    if word[0] in \"aeiou\":\n        return f\"{word}way\"\n    for i, char in enumerate(word):  # noqa: B007\n        if char in \"aeiou\":\n            break\n    return f\"{word[i:]}{word[:i]}ay\"",
    "docstring": "Compute the piglatin of a given string.\n\nhttps://en.wikipedia.org/wiki/Pig_Latin\n\nUsage examples:\n>>> pig_latin(\"pig\")\n'igpay'\n>>> pig_latin(\"latin\")\n'atinlay'\n>>> pig_latin(\"banana\")\n'ananabay'\n>>> pig_latin(\"friends\")\n'iendsfray'\n>>> pig_latin(\"smile\")\n'ilesmay'\n>>> pig_latin(\"string\")\n'ingstray'\n>>> pig_latin(\"eat\")\n'eatway'\n>>> pig_latin(\"omelet\")\n'omeletway'\n>>> pig_latin(\"are\")\n'areway'\n>>> pig_latin(\" \")\n''\n>>> pig_latin(None)\n''"
  },
  {
    "function": "prefix_function",
    "code": "def prefix_function(input_string: str) -> list:\n    \"\"\"\n    For the given string this function computes value for each index(i),\n    which represents the longest coincidence of prefix and suffix\n    for given substring (input_str[0...i])\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> prefix_function(\"aabcdaabc\")\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\n    >>> prefix_function(\"asdasdad\")\n    [0, 0, 0, 1, 2, 3, 4, 0]\n    \"\"\"\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result",
    "docstring": "For the given string this function computes value for each index(i),\nwhich represents the longest coincidence of prefix and suffix\nfor given substring (input_str[0...i])\n\nFor the value of the first element the algorithm always returns 0\n\n>>> prefix_function(\"aabcdaabc\")\n[0, 1, 0, 0, 0, 1, 2, 3, 4]\n>>> prefix_function(\"asdasdad\")\n[0, 0, 0, 1, 2, 3, 4, 0]"
  },
  {
    "function": "longest_prefix",
    "code": "def longest_prefix(input_str: str) -> int:\n    \"\"\"\n    Prefix-function use case\n    Finding longest prefix which is suffix as well\n\n    >>> longest_prefix(\"aabcdaabc\")\n    4\n    >>> longest_prefix(\"asdasdad\")\n    4\n    >>> longest_prefix(\"abcab\")\n    2\n    \"\"\"\n\n    # just returning maximum value of the array gives us answer\n    return max(prefix_function(input_str))",
    "docstring": "Prefix-function use case\nFinding longest prefix which is suffix as well\n\n>>> longest_prefix(\"aabcdaabc\")\n4\n>>> longest_prefix(\"asdasdad\")\n4\n>>> longest_prefix(\"abcab\")\n2"
  },
  {
    "function": "rabin_karp",
    "code": "def rabin_karp(pattern: str, text: str) -> bool:\n    \"\"\"\n    The Rabin-Karp Algorithm for finding a pattern within a piece of text\n    with complexity O(nm), most efficient when it is used with multiple patterns\n    as it is able to check if any of a set of patterns match a section of text in o(1)\n    given the precomputed hashes.\n\n    This will be the simple version which only assumes one pattern is being searched\n    for but it's not hard to modify\n\n    1) Calculate pattern hash\n\n    2) Step through the text one character at a time passing a window with the same\n        length as the pattern\n        calculating the hash of the text within the window compare it with the hash\n        of the pattern. Only testing equality if the hashes match\n    \"\"\"\n    p_len = len(pattern)\n    t_len = len(text)\n    if p_len > t_len:\n        return False\n\n    p_hash = 0\n    text_hash = 0\n    modulus_power = 1\n\n    # Calculating the hash of pattern and substring of text\n    for i in range(p_len):\n        p_hash = (ord(pattern[i]) + p_hash * alphabet_size) % modulus\n        text_hash = (ord(text[i]) + text_hash * alphabet_size) % modulus\n        if i == p_len - 1:\n            continue\n        modulus_power = (modulus_power * alphabet_size) % modulus\n\n    for i in range(t_len - p_len + 1):\n        if text_hash == p_hash and text[i : i + p_len] == pattern:\n            return True\n        if i == t_len - p_len:\n            continue\n        # Calculate the https://en.wikipedia.org/wiki/Rolling_hash\n        text_hash = (\n            (text_hash - ord(text[i]) * modulus_power) * alphabet_size\n            + ord(text[i + p_len])\n        ) % modulus\n    return False",
    "docstring": "The Rabin-Karp Algorithm for finding a pattern within a piece of text\nwith complexity O(nm), most efficient when it is used with multiple patterns\nas it is able to check if any of a set of patterns match a section of text in o(1)\ngiven the precomputed hashes.\n\nThis will be the simple version which only assumes one pattern is being searched\nfor but it's not hard to modify\n\n1) Calculate pattern hash\n\n2) Step through the text one character at a time passing a window with the same\n    length as the pattern\n    calculating the hash of the text within the window compare it with the hash\n    of the pattern. Only testing equality if the hashes match"
  },
  {
    "function": "test_rabin_karp",
    "code": "def test_rabin_karp() -> None:\n    \"\"\"\n    >>> test_rabin_karp()\n    Success.\n    \"\"\"\n    # Test 1)\n    pattern = \"abc1abc12\"\n    text1 = \"alskfjaldsabc1abc1abc12k23adsfabcabc\"\n    text2 = \"alskfjaldsk23adsfabcabc\"\n    assert rabin_karp(pattern, text1)\n    assert not rabin_karp(pattern, text2)\n\n    # Test 2)\n    pattern = \"ABABX\"\n    text = \"ABABZABABYABABX\"\n    assert rabin_karp(pattern, text)\n\n    # Test 3)\n    pattern = \"AAAB\"\n    text = \"ABAAAAAB\"\n    assert rabin_karp(pattern, text)\n\n    # Test 4)\n    pattern = \"abcdabcy\"\n    text = \"abcxabcdabxabcdabcdabcy\"\n    assert rabin_karp(pattern, text)\n\n    # Test 5)\n    pattern = \"L\u00fc\"\n    text = \"L\u00fcsai\"\n    assert rabin_karp(pattern, text)\n    pattern = \"Lue\"\n    assert not rabin_karp(pattern, text)\n    print(\"Success.\")",
    "docstring": ">>> test_rabin_karp()\nSuccess."
  },
  {
    "function": "remove_duplicates",
    "code": "def remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Remove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    >>> remove_duplicates(\"Python   is      great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split())))",
    "docstring": "Remove duplicates from sentence\n>>> remove_duplicates(\"Python is great and Java is also great\")\n'Java Python also and great is'\n>>> remove_duplicates(\"Python   is      great and Java is also great\")\n'Java Python also and great is'"
  },
  {
    "function": "reverse_letters",
    "code": "def reverse_letters(sentence: str, length: int = 0) -> str:\n    \"\"\"\n    Reverse all words that are longer than the given length of characters in a sentence.\n    If unspecified, length is taken as 0\n\n    >>> reverse_letters(\"Hey wollef sroirraw\", 3)\n    'Hey fellow warriors'\n    >>> reverse_letters(\"nohtyP is nohtyP\", 2)\n    'Python is Python'\n    >>> reverse_letters(\"1 12 123 1234 54321 654321\", 0)\n    '1 21 321 4321 12345 123456'\n    >>> reverse_letters(\"racecar\")\n    'racecar'\n    \"\"\"\n    return \" \".join(\n        \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()\n    )",
    "docstring": "Reverse all words that are longer than the given length of characters in a sentence.\nIf unspecified, length is taken as 0\n\n>>> reverse_letters(\"Hey wollef sroirraw\", 3)\n'Hey fellow warriors'\n>>> reverse_letters(\"nohtyP is nohtyP\", 2)\n'Python is Python'\n>>> reverse_letters(\"1 12 123 1234 54321 654321\", 0)\n'1 21 321 4321 12345 123456'\n>>> reverse_letters(\"racecar\")\n'racecar'"
  },
  {
    "function": "reverse_words",
    "code": "def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])",
    "docstring": "Reverses words in a given string\n>>> reverse_words(\"I love Python\")\n'Python love I'\n>>> reverse_words(\"I     Love          Python\")\n'Python Love I'"
  },
  {
    "function": "snake_to_camel_case",
    "code": "def snake_to_camel_case(input_str: str, use_pascal: bool = False) -> str:\n    \"\"\"\n    Transforms a snake_case given string to camelCase (or PascalCase if indicated)\n    (defaults to not use Pascal)\n\n    >>> snake_to_camel_case(\"some_random_string\")\n    'someRandomString'\n\n    >>> snake_to_camel_case(\"some_random_string\", use_pascal=True)\n    'SomeRandomString'\n\n    >>> snake_to_camel_case(\"some_random_string_with_numbers_123\")\n    'someRandomStringWithNumbers123'\n\n    >>> snake_to_camel_case(\"some_random_string_with_numbers_123\", use_pascal=True)\n    'SomeRandomStringWithNumbers123'\n\n    >>> snake_to_camel_case(123)\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected string as input, found <class 'int'>\n\n    >>> snake_to_camel_case(\"some_string\", use_pascal=\"True\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected boolean as use_pascal parameter, found <class 'str'>\n    \"\"\"\n\n    if not isinstance(input_str, str):\n        msg = f\"Expected string as input, found {type(input_str)}\"\n        raise ValueError(msg)\n    if not isinstance(use_pascal, bool):\n        msg = f\"Expected boolean as use_pascal parameter, found {type(use_pascal)}\"\n        raise ValueError(msg)\n\n    words = input_str.split(\"_\")\n\n    start_index = 0 if use_pascal else 1\n\n    words_to_capitalize = words[start_index:]\n\n    capitalized_words = [word[0].upper() + word[1:] for word in words_to_capitalize]\n\n    initial_word = \"\" if use_pascal else words[0]\n\n    return \"\".join([initial_word, *capitalized_words])",
    "docstring": "Transforms a snake_case given string to camelCase (or PascalCase if indicated)\n(defaults to not use Pascal)\n\n>>> snake_to_camel_case(\"some_random_string\")\n'someRandomString'\n\n>>> snake_to_camel_case(\"some_random_string\", use_pascal=True)\n'SomeRandomString'\n\n>>> snake_to_camel_case(\"some_random_string_with_numbers_123\")\n'someRandomStringWithNumbers123'\n\n>>> snake_to_camel_case(\"some_random_string_with_numbers_123\", use_pascal=True)\n'SomeRandomStringWithNumbers123'\n\n>>> snake_to_camel_case(123)\nTraceback (most recent call last):\n    ...\nValueError: Expected string as input, found <class 'int'>\n\n>>> snake_to_camel_case(\"some_string\", use_pascal=\"True\")\nTraceback (most recent call last):\n    ...\nValueError: Expected boolean as use_pascal parameter, found <class 'str'>"
  },
  {
    "function": "split",
    "code": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n\n    >>> split(\";abbb;;c;\", separator=';')\n    ['', 'abbb', '', 'c', '']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words",
    "docstring": "Will split the string up into all the values separated by the separator\n(defaults to spaces)\n\n>>> split(\"apple#banana#cherry#orange\",separator='#')\n['apple', 'banana', 'cherry', 'orange']\n\n>>> split(\"Hello there\")\n['Hello', 'there']\n\n>>> split(\"11/22/63\",separator = '/')\n['11', '22', '63']\n\n>>> split(\"12:43:39\",separator = \":\")\n['12', '43', '39']\n\n>>> split(\";abbb;;c;\", separator=';')\n['', 'abbb', '', 'c', '']"
  },
  {
    "function": "split_input",
    "code": "def split_input(str_: str) -> list:\n    \"\"\"\n    >>> split_input(\"one two 31235three4four\")\n    [['one', 'two', '31235three4four']]\n    \"\"\"\n    return [char.split() for char in re.split(r\"[^ a-z A-Z 0-9 \\s]\", str_)]",
    "docstring": ">>> split_input(\"one two 31235three4four\")\n[['one', 'two', '31235three4four']]"
  },
  {
    "function": "to_simple_case",
    "code": "def to_simple_case(str_: str) -> str:\n    \"\"\"\n    >>> to_simple_case(\"one two 31235three4four\")\n    'OneTwo31235three4four'\n    >>> to_simple_case(\"This should be combined\")\n    'ThisShouldBeCombined'\n    >>> to_simple_case(\"The first letters are capitalized, then string is merged\")\n    'TheFirstLettersAreCapitalizedThenStringIsMerged'\n    >>> to_simple_case(\"special characters :, ', %, ^, $, are ignored\")\n    'SpecialCharactersAreIgnored'\n    \"\"\"\n    string_split = split_input(str_)\n    return \"\".join(\n        [\"\".join([char.capitalize() for char in sub_str]) for sub_str in string_split]\n    )",
    "docstring": ">>> to_simple_case(\"one two 31235three4four\")\n'OneTwo31235three4four'\n>>> to_simple_case(\"This should be combined\")\n'ThisShouldBeCombined'\n>>> to_simple_case(\"The first letters are capitalized, then string is merged\")\n'TheFirstLettersAreCapitalizedThenStringIsMerged'\n>>> to_simple_case(\"special characters :, ', %, ^, $, are ignored\")\n'SpecialCharactersAreIgnored'"
  },
  {
    "function": "to_complex_case",
    "code": "def to_complex_case(text: str, upper: bool, separator: str) -> str:\n    \"\"\"\n    Returns the string concatenated with the delimiter we provide.\n\n    Parameters:\n    @text: The string on which we want to perform operation\n    @upper: Boolean value to determine whether we want capitalized result or not\n    @separator: The delimiter with which we want to concatenate words\n\n    Examples:\n    >>> to_complex_case(\"one two 31235three4four\", True, \"_\")\n    'ONE_TWO_31235THREE4FOUR'\n    >>> to_complex_case(\"one two 31235three4four\", False, \"-\")\n    'one-two-31235three4four'\n    \"\"\"\n    try:\n        string_split = split_input(text)\n        if upper:\n            res_str = \"\".join(\n                [\n                    separator.join([char.upper() for char in sub_str])\n                    for sub_str in string_split\n                ]\n            )\n        else:\n            res_str = \"\".join(\n                [\n                    separator.join([char.lower() for char in sub_str])\n                    for sub_str in string_split\n                ]\n            )\n        return res_str\n    except IndexError:\n        return \"not valid string\"",
    "docstring": "Returns the string concatenated with the delimiter we provide.\n\nParameters:\n@text: The string on which we want to perform operation\n@upper: Boolean value to determine whether we want capitalized result or not\n@separator: The delimiter with which we want to concatenate words\n\nExamples:\n>>> to_complex_case(\"one two 31235three4four\", True, \"_\")\n'ONE_TWO_31235THREE4FOUR'\n>>> to_complex_case(\"one two 31235three4four\", False, \"-\")\n'one-two-31235three4four'"
  },
  {
    "function": "to_pascal_case",
    "code": "def to_pascal_case(text: str) -> str:\n    \"\"\"\n    >>> to_pascal_case(\"one two 31235three4four\")\n    'OneTwo31235three4four'\n    \"\"\"\n    return to_simple_case(text)",
    "docstring": ">>> to_pascal_case(\"one two 31235three4four\")\n'OneTwo31235three4four'"
  },
  {
    "function": "to_camel_case",
    "code": "def to_camel_case(text: str) -> str:\n    \"\"\"\n    >>> to_camel_case(\"one two 31235three4four\")\n    'oneTwo31235three4four'\n    \"\"\"\n    try:\n        res_str = to_simple_case(text)\n        return res_str[0].lower() + res_str[1:]\n    except IndexError:\n        return \"not valid string\"",
    "docstring": ">>> to_camel_case(\"one two 31235three4four\")\n'oneTwo31235three4four'"
  },
  {
    "function": "to_snake_case",
    "code": "def to_snake_case(text: str, upper: bool) -> str:\n    \"\"\"\n    >>> to_snake_case(\"one two 31235three4four\", True)\n    'ONE_TWO_31235THREE4FOUR'\n    >>> to_snake_case(\"one two 31235three4four\", False)\n    'one_two_31235three4four'\n    \"\"\"\n    return to_complex_case(text, upper, \"_\")",
    "docstring": ">>> to_snake_case(\"one two 31235three4four\", True)\n'ONE_TWO_31235THREE4FOUR'\n>>> to_snake_case(\"one two 31235three4four\", False)\n'one_two_31235three4four'"
  },
  {
    "function": "to_kebab_case",
    "code": "def to_kebab_case(text: str, upper: bool) -> str:\n    \"\"\"\n    >>> to_kebab_case(\"one two 31235three4four\", True)\n    'ONE-TWO-31235THREE4FOUR'\n    >>> to_kebab_case(\"one two 31235three4four\", False)\n    'one-two-31235three4four'\n    \"\"\"\n    return to_complex_case(text, upper, \"-\")",
    "docstring": ">>> to_kebab_case(\"one two 31235three4four\", True)\n'ONE-TWO-31235THREE4FOUR'\n>>> to_kebab_case(\"one two 31235three4four\", False)\n'one-two-31235three4four'"
  },
  {
    "function": "strip",
    "code": "def strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]",
    "docstring": "Remove leading and trailing characters (whitespace by default) from a string.\n\nArgs:\n    user_string (str): The input string to be stripped.\n    characters (str, optional): Optional characters to be removed\n            (default is whitespace).\n\nReturns:\n    str: The stripped string.\n\nExamples:\n    >>> strip(\"   hello   \")\n    'hello'\n    >>> strip(\"...world...\", \".\")\n    'world'\n    >>> strip(\"123hello123\", \"123\")\n    'hello'\n    >>> strip(\"\")\n    ''"
  },
  {
    "function": "text_justification",
    "code": "def text_justification(word: str, max_width: int) -> list:\n    \"\"\"\n    Will format the string such that each line has exactly\n    (max_width) characters and is fully (left and right) justified,\n    and return the list of justified text.\n\n    example 1:\n    string = \"This is an example of text justification.\"\n    max_width = 16\n\n    output = ['This    is    an',\n              'example  of text',\n              'justification.  ']\n\n    >>> text_justification(\"This is an example of text justification.\", 16)\n    ['This    is    an', 'example  of text', 'justification.  ']\n\n    example 2:\n    string = \"Two roads diverged in a yellow wood\"\n    max_width = 16\n    output = ['Two        roads',\n              'diverged   in  a',\n              'yellow wood     ']\n\n    >>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n    ['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\n    Time complexity: O(m*n)\n    Space complexity: O(m*n)\n    \"\"\"\n\n    # Converting string into list of strings split by a space\n    words = word.split()\n\n    def justify(line: list, width: int, max_width: int) -> str:\n        overall_spaces_count = max_width - width\n        words_count = len(line)\n        if len(line) == 1:\n            # if there is only word in line\n            # just insert overall_spaces_count for the remainder of line\n            return line[0] + \" \" * overall_spaces_count\n        else:\n            spaces_to_insert_between_words = words_count - 1\n            # num_spaces_between_words_list[i] : tells you to insert\n            # num_spaces_between_words_list[i] spaces\n            # after word on line[i]\n            num_spaces_between_words_list = spaces_to_insert_between_words * [\n                overall_spaces_count // spaces_to_insert_between_words\n            ]\n            spaces_count_in_locations = (\n                overall_spaces_count % spaces_to_insert_between_words\n            )\n            # distribute spaces via round robin to the left words\n            for i in range(spaces_count_in_locations):\n                num_spaces_between_words_list[i] += 1\n            aligned_words_list = []\n            for i in range(spaces_to_insert_between_words):\n                # add the word\n                aligned_words_list.append(line[i])\n                # add the spaces to insert\n                aligned_words_list.append(num_spaces_between_words_list[i] * \" \")\n            # just add the last word to the sentence\n            aligned_words_list.append(line[-1])\n            # join the aligned words list to form a justified line\n            return \"\".join(aligned_words_list)\n\n    answer = []\n    line: list[str] = []\n    width = 0\n    for inner_word in words:\n        if width + len(inner_word) + len(line) <= max_width:\n            # keep adding words until we can fill out max_width\n            # width = sum of length of all words (without overall_spaces_count)\n            # len(inner_word) = length of current inner_word\n            # len(line) = number of overall_spaces_count to insert between words\n            line.append(inner_word)\n            width += len(inner_word)\n        else:\n            # justify the line and add it to result\n            answer.append(justify(line, width, max_width))\n            # reset new line and new width\n            line, width = [inner_word], len(inner_word)\n    remaining_spaces = max_width - width - len(line)\n    answer.append(\" \".join(line) + (remaining_spaces + 1) * \" \")\n    return answer",
    "docstring": "Will format the string such that each line has exactly\n(max_width) characters and is fully (left and right) justified,\nand return the list of justified text.\n\nexample 1:\nstring = \"This is an example of text justification.\"\nmax_width = 16\n\noutput = ['This    is    an',\n          'example  of text',\n          'justification.  ']\n\n>>> text_justification(\"This is an example of text justification.\", 16)\n['This    is    an', 'example  of text', 'justification.  ']\n\nexample 2:\nstring = \"Two roads diverged in a yellow wood\"\nmax_width = 16\noutput = ['Two        roads',\n          'diverged   in  a',\n          'yellow wood     ']\n\n>>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\nTime complexity: O(m*n)\nSpace complexity: O(m*n)"
  },
  {
    "function": "to_title_case",
    "code": "def to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word",
    "docstring": "Converts a string to capitalized case, preserving the input as is\n\n>>> to_title_case(\"Aakash\")\n'Aakash'\n\n>>> to_title_case(\"aakash\")\n'Aakash'\n\n>>> to_title_case(\"AAKASH\")\n'Aakash'\n\n>>> to_title_case(\"aAkAsH\")\n'Aakash'"
  },
  {
    "function": "sentence_to_title_case",
    "code": "def sentence_to_title_case(input_str: str) -> str:\n    \"\"\"\n    Converts a string to title case, preserving the input as is\n\n    >>> sentence_to_title_case(\"Aakash Giri\")\n    'Aakash Giri'\n\n    >>> sentence_to_title_case(\"aakash giri\")\n    'Aakash Giri'\n\n    >>> sentence_to_title_case(\"AAKASH GIRI\")\n    'Aakash Giri'\n\n    >>> sentence_to_title_case(\"aAkAsH gIrI\")\n    'Aakash Giri'\n    \"\"\"\n\n    return \" \".join(to_title_case(word) for word in input_str.split())",
    "docstring": "Converts a string to title case, preserving the input as is\n\n>>> sentence_to_title_case(\"Aakash Giri\")\n'Aakash Giri'\n\n>>> sentence_to_title_case(\"aakash giri\")\n'Aakash Giri'\n\n>>> sentence_to_title_case(\"AAKASH GIRI\")\n'Aakash Giri'\n\n>>> sentence_to_title_case(\"aAkAsH gIrI\")\n'Aakash Giri'"
  },
  {
    "function": "top_k_frequent_words",
    "code": "def top_k_frequent_words(words: list[str], k_value: int) -> list[str]:\n    \"\"\"\n    Returns the `k_value` most frequently occurring words,\n    in non-increasing order of occurrence.\n    In this context, a word is defined as an element in the provided list.\n\n    In case `k_value` is greater than the number of distinct words, a value of k equal\n    to the number of distinct words will be considered, instead.\n\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 3)\n    ['c', 'a', 'b']\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 2)\n    ['c', 'a']\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 1)\n    ['c']\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 0)\n    []\n    >>> top_k_frequent_words([], 1)\n    []\n    >>> top_k_frequent_words(['a', 'a'], 2)\n    ['a']\n    \"\"\"\n    heap: Heap[WordCount] = Heap()\n    count_by_word = Counter(words)\n    heap.build_max_heap(\n        [WordCount(word, count) for word, count in count_by_word.items()]\n    )\n    return [heap.extract_max().word for _ in range(min(k_value, len(count_by_word)))]",
    "docstring": "Returns the `k_value` most frequently occurring words,\nin non-increasing order of occurrence.\nIn this context, a word is defined as an element in the provided list.\n\nIn case `k_value` is greater than the number of distinct words, a value of k equal\nto the number of distinct words will be considered, instead.\n\n>>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 3)\n['c', 'a', 'b']\n>>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 2)\n['c', 'a']\n>>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 1)\n['c']\n>>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 0)\n[]\n>>> top_k_frequent_words([], 1)\n[]\n>>> top_k_frequent_words(['a', 'a'], 2)\n['a']"
  },
  {
    "function": "upper",
    "code": "def upper(word: str) -> str:\n    \"\"\"\n    Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII\n    letters and subtracting 32 from their integer representation to get the uppercase\n    letter.\n\n    >>> upper(\"wow\")\n    'WOW'\n    >>> upper(\"Hello\")\n    'HELLO'\n    >>> upper(\"WHAT\")\n    'WHAT'\n    >>> upper(\"wh[]32\")\n    'WH[]32'\n    \"\"\"\n    return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)",
    "docstring": "Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII\nletters and subtracting 32 from their integer representation to get the uppercase\nletter.\n\n>>> upper(\"wow\")\n'WOW'\n>>> upper(\"Hello\")\n'HELLO'\n>>> upper(\"WHAT\")\n'WHAT'\n>>> upper(\"wh[]32\")\n'WH[]32'"
  },
  {
    "function": "wave",
    "code": "def wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]",
    "docstring": "Returns a so called 'wave' of a given string\n>>> wave('cat')\n['Cat', 'cAt', 'caT']\n>>> wave('one')\n['One', 'oNe', 'onE']\n>>> wave('book')\n['Book', 'bOok', 'boOk', 'booK']"
  },
  {
    "function": "match_pattern",
    "code": "def match_pattern(input_string: str, pattern: str) -> bool:\n    \"\"\"\n    uses bottom-up dynamic programming solution for matching the input\n    string with a given pattern.\n\n    Runtime: O(len(input_string)*len(pattern))\n\n    Arguments\n    --------\n    input_string: str, any string which should be compared with the pattern\n    pattern: str, the string that represents a pattern and may contain\n    '.' for single character matches and '*' for zero or more of preceding character\n    matches\n\n    Note\n    ----\n    the pattern cannot start with a '*',\n    because there should be at least one character before *\n\n    Returns\n    -------\n    A Boolean denoting whether the given string follows the pattern\n\n    Examples\n    -------\n    >>> match_pattern(\"aab\", \"c*a*b\")\n    True\n    >>> match_pattern(\"dabc\", \"*abc\")\n    False\n    >>> match_pattern(\"aaa\", \"aa\")\n    False\n    >>> match_pattern(\"aaa\", \"a.a\")\n    True\n    >>> match_pattern(\"aaab\", \"aa*\")\n    False\n    >>> match_pattern(\"aaab\", \".*\")\n    True\n    >>> match_pattern(\"a\", \"bbbb\")\n    False\n    >>> match_pattern(\"\", \"bbbb\")\n    False\n    >>> match_pattern(\"a\", \"\")\n    False\n    >>> match_pattern(\"\", \"\")\n    True\n    \"\"\"\n\n    len_string = len(input_string) + 1\n    len_pattern = len(pattern) + 1\n\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\n    # length i of input_string matches with prefix string of length j of\n    # given pattern.\n    # \"dp\" stands for dynamic programming.\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\n\n    # since string of zero length match pattern of zero length\n    dp[0][0] = 1\n\n    # since pattern of zero length will never match with string of non-zero length\n    for i in range(1, len_string):\n        dp[i][0] = 0\n\n    # since string of zero length will match with pattern where there\n    # is at least one * alternatively\n    for j in range(1, len_pattern):\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \"*\" else 0\n\n    # now using bottom-up approach to find for all remaining lengths\n    for i in range(1, len_string):\n        for j in range(1, len_pattern):\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \".\":\n                dp[i][j] = dp[i - 1][j - 1]\n\n            elif pattern[j - 1] == \"*\":\n                if dp[i][j - 2] == 1:\n                    dp[i][j] = 1\n                elif pattern[j - 2] in (input_string[i - 1], \".\"):\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n\n    return bool(dp[-1][-1])",
    "docstring": "uses bottom-up dynamic programming solution for matching the input\nstring with a given pattern.\n\nRuntime: O(len(input_string)*len(pattern))\n\nArguments\n--------\ninput_string: str, any string which should be compared with the pattern\npattern: str, the string that represents a pattern and may contain\n'.' for single character matches and '*' for zero or more of preceding character\nmatches\n\nNote\n----\nthe pattern cannot start with a '*',\nbecause there should be at least one character before *\n\nReturns\n-------\nA Boolean denoting whether the given string follows the pattern\n\nExamples\n-------\n>>> match_pattern(\"aab\", \"c*a*b\")\nTrue\n>>> match_pattern(\"dabc\", \"*abc\")\nFalse\n>>> match_pattern(\"aaa\", \"aa\")\nFalse\n>>> match_pattern(\"aaa\", \"a.a\")\nTrue\n>>> match_pattern(\"aaab\", \"aa*\")\nFalse\n>>> match_pattern(\"aaab\", \".*\")\nTrue\n>>> match_pattern(\"a\", \"bbbb\")\nFalse\n>>> match_pattern(\"\", \"bbbb\")\nFalse\n>>> match_pattern(\"a\", \"\")\nFalse\n>>> match_pattern(\"\", \"\")\nTrue"
  },
  {
    "function": "word_occurrence",
    "code": "def word_occurrence(sentence: str) -> dict:\n    \"\"\"\n    >>> from collections import Counter\n    >>> SENTENCE = \"a b A b c b d b d e f e g e h e i e j e 0\"\n    >>> occurence_dict = word_occurrence(SENTENCE)\n    >>> all(occurence_dict[word] == count for word, count\n    ...     in Counter(SENTENCE.split()).items())\n    True\n    >>> dict(word_occurrence(\"Two  spaces\"))\n    {'Two': 1, 'spaces': 1}\n    \"\"\"\n    occurrence: defaultdict[str, int] = defaultdict(int)\n    # Creating a dictionary containing count of each word\n    for word in sentence.split():\n        occurrence[word] += 1\n    return occurrence",
    "docstring": ">>> from collections import Counter\n>>> SENTENCE = \"a b A b c b d b d e f e g e h e i e j e 0\"\n>>> occurence_dict = word_occurrence(SENTENCE)\n>>> all(occurence_dict[word] == count for word, count\n...     in Counter(SENTENCE.split()).items())\nTrue\n>>> dict(word_occurrence(\"Two  spaces\"))\n{'Two': 1, 'spaces': 1}"
  },
  {
    "function": "get_word_pattern",
    "code": "def get_word_pattern(word: str) -> str:\n    \"\"\"\n    Returns numerical pattern of character appearances in given word\n    >>> get_word_pattern(\"\")\n    ''\n    >>> get_word_pattern(\" \")\n    '0'\n    >>> get_word_pattern(\"pattern\")\n    '0.1.2.2.3.4.5'\n    >>> get_word_pattern(\"word pattern\")\n    '0.1.2.3.4.5.6.7.7.8.2.9'\n    >>> get_word_pattern(\"get word pattern\")\n    '0.1.2.3.4.5.6.7.3.8.9.2.2.1.6.10'\n    >>> get_word_pattern()\n    Traceback (most recent call last):\n    ...\n    TypeError: get_word_pattern() missing 1 required positional argument: 'word'\n    >>> get_word_pattern(1)\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'int' object has no attribute 'upper'\n    >>> get_word_pattern(1.1)\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'float' object has no attribute 'upper'\n    >>> get_word_pattern([])\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'list' object has no attribute 'upper'\n    \"\"\"\n    word = word.upper()\n    next_num = 0\n    letter_nums = {}\n    word_pattern = []\n\n    for letter in word:\n        if letter not in letter_nums:\n            letter_nums[letter] = str(next_num)\n            next_num += 1\n        word_pattern.append(letter_nums[letter])\n    return \".\".join(word_pattern)",
    "docstring": "Returns numerical pattern of character appearances in given word\n>>> get_word_pattern(\"\")\n''\n>>> get_word_pattern(\" \")\n'0'\n>>> get_word_pattern(\"pattern\")\n'0.1.2.2.3.4.5'\n>>> get_word_pattern(\"word pattern\")\n'0.1.2.3.4.5.6.7.7.8.2.9'\n>>> get_word_pattern(\"get word pattern\")\n'0.1.2.3.4.5.6.7.3.8.9.2.2.1.6.10'\n>>> get_word_pattern()\nTraceback (most recent call last):\n...\nTypeError: get_word_pattern() missing 1 required positional argument: 'word'\n>>> get_word_pattern(1)\nTraceback (most recent call last):\n...\nAttributeError: 'int' object has no attribute 'upper'\n>>> get_word_pattern(1.1)\nTraceback (most recent call last):\n...\nAttributeError: 'float' object has no attribute 'upper'\n>>> get_word_pattern([])\nTraceback (most recent call last):\n...\nAttributeError: 'list' object has no attribute 'upper'"
  },
  {
    "function": "z_function",
    "code": "def z_function(input_str: str) -> list[int]:\n    \"\"\"\n    For the given string this function computes value for each index,\n    which represents the maximal length substring starting from the index\n    and is the same as the prefix of the same size\n\n    e.x.  for string 'abab' for second index value would be 2\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> z_function(\"abracadabra\")\n    [0, 0, 0, 1, 0, 1, 0, 4, 0, 0, 1]\n    >>> z_function(\"aaaa\")\n    [0, 3, 2, 1]\n    >>> z_function(\"zxxzxxz\")\n    [0, 0, 0, 4, 0, 0, 1]\n    \"\"\"\n    z_result = [0 for i in range(len(input_str))]\n\n    # initialize interval's left pointer and right pointer\n    left_pointer, right_pointer = 0, 0\n\n    for i in range(1, len(input_str)):\n        # case when current index is inside the interval\n        if i <= right_pointer:\n            min_edge = min(right_pointer - i + 1, z_result[i - left_pointer])\n            z_result[i] = min_edge\n\n        while go_next(i, z_result, input_str):\n            z_result[i] += 1\n\n        # if new index's result gives us more right interval,\n        # we've to update left_pointer and right_pointer\n        if i + z_result[i] - 1 > right_pointer:\n            left_pointer, right_pointer = i, i + z_result[i] - 1\n\n    return z_result",
    "docstring": "For the given string this function computes value for each index,\nwhich represents the maximal length substring starting from the index\nand is the same as the prefix of the same size\n\ne.x.  for string 'abab' for second index value would be 2\n\nFor the value of the first element the algorithm always returns 0\n\n>>> z_function(\"abracadabra\")\n[0, 0, 0, 1, 0, 1, 0, 4, 0, 0, 1]\n>>> z_function(\"aaaa\")\n[0, 3, 2, 1]\n>>> z_function(\"zxxzxxz\")\n[0, 0, 0, 4, 0, 0, 1]"
  },
  {
    "function": "go_next",
    "code": "def go_next(i: int, z_result: list[int], s: str) -> bool:\n    \"\"\"\n    Check if we have to move forward to the next characters or not\n    \"\"\"\n    return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]",
    "docstring": "Check if we have to move forward to the next characters or not"
  },
  {
    "function": "find_pattern",
    "code": "def find_pattern(pattern: str, input_str: str) -> int:\n    \"\"\"\n    Example of using z-function for pattern occurrence\n    Given function returns the number of times 'pattern'\n    appears in 'input_str' as a substring\n\n    >>> find_pattern(\"abr\", \"abracadabra\")\n    2\n    >>> find_pattern(\"a\", \"aaaa\")\n    4\n    >>> find_pattern(\"xz\", \"zxxzxxz\")\n    2\n    \"\"\"\n    answer = 0\n    # concatenate 'pattern' and 'input_str' and call z_function\n    # with concatenated string\n    z_result = z_function(pattern + input_str)\n\n    for val in z_result:\n        # if value is greater then length of the pattern string\n        # that means this index is starting position of substring\n        # which is equal to pattern string\n        if val >= len(pattern):\n            answer += 1\n\n    return answer",
    "docstring": "Example of using z-function for pattern occurrence\nGiven function returns the number of times 'pattern'\nappears in 'input_str' as a substring\n\n>>> find_pattern(\"abr\", \"abracadabra\")\n2\n>>> find_pattern(\"a\", \"aaaa\")\n4\n>>> find_pattern(\"xz\", \"zxxzxxz\")\n2"
  },
  {
    "function": "get_citation",
    "code": "def get_citation(base_url: str, params: dict) -> str:\n    \"\"\"\n    Return the citation number.\n    \"\"\"\n    soup = BeautifulSoup(\n        httpx.get(base_url, params=params, timeout=10).content, \"html.parser\"\n    )\n    div = soup.find(\"div\", attrs={\"class\": \"gs_ri\"})\n    anchors = div.find(\"div\", attrs={\"class\": \"gs_fl\"}).find_all(\"a\")\n    return anchors[2].get_text()",
    "docstring": "Return the citation number."
  },
  {
    "function": "stock_price",
    "code": "def stock_price(symbol: str = \"AAPL\") -> str:\n    \"\"\"\n    >>> stock_price(\"EEEE\")\n    'No <fin-streamer> tag with the specified data-testid attribute found.'\n    >>> isinstance(float(stock_price(\"GOOG\")),float)\n    True\n    \"\"\"\n    url = f\"https://finance.yahoo.com/quote/{symbol}?p={symbol}\"\n    yahoo_finance_source = httpx.get(\n        url, headers={\"USER-AGENT\": \"Mozilla/5.0\"}, timeout=10, follow_redirects=True\n    ).text\n    soup = BeautifulSoup(yahoo_finance_source, \"html.parser\")\n\n    if specific_fin_streamer_tag := soup.find(\"span\", {\"data-testid\": \"qsp-price\"}):\n        return specific_fin_streamer_tag.get_text()\n    return \"No <fin-streamer> tag with the specified data-testid attribute found.\"",
    "docstring": ">>> stock_price(\"EEEE\")\n'No <fin-streamer> tag with the specified data-testid attribute found.'\n>>> isinstance(float(stock_price(\"GOOG\")),float)\nTrue"
  },
  {
    "function": "current_weather",
    "code": "def current_weather(location: str) -> list[dict]:\n    \"\"\"\n    >>> current_weather(\"location\")\n    Traceback (most recent call last):\n        ...\n    ValueError: No API keys provided or no valid data returned.\n    \"\"\"\n    weather_data = []\n    if OPENWEATHERMAP_API_KEY:\n        params_openweathermap = {\"q\": location, \"appid\": OPENWEATHERMAP_API_KEY}\n        response_openweathermap = httpx.get(\n            OPENWEATHERMAP_URL_BASE, params=params_openweathermap, timeout=10\n        )\n        weather_data.append({\"OpenWeatherMap\": response_openweathermap.json()})\n    if WEATHERSTACK_API_KEY:\n        params_weatherstack = {\"query\": location, \"access_key\": WEATHERSTACK_API_KEY}\n        response_weatherstack = httpx.get(\n            WEATHERSTACK_URL_BASE, params=params_weatherstack, timeout=10\n        )\n        weather_data.append({\"Weatherstack\": response_weatherstack.json()})\n    if not weather_data:\n        raise ValueError(\"No API keys provided or no valid data returned.\")\n    return weather_data",
    "docstring": ">>> current_weather(\"location\")\nTraceback (most recent call last):\n    ...\nValueError: No API keys provided or no valid data returned."
  },
  {
    "function": "download_images_from_google_query",
    "code": "def download_images_from_google_query(query: str = \"dhaka\", max_images: int = 5) -> int:\n    \"\"\"\n    Searches google using the provided query term and downloads the images in a folder.\n\n    Args:\n         query : The image search term to be provided by the user. Defaults to\n        \"dhaka\".\n        image_numbers : [description]. Defaults to 5.\n\n    Returns:\n        The number of images successfully downloaded.\n\n    # Comment out slow (4.20s call) doctests\n    # >>> download_images_from_google_query()\n    5\n    # >>> download_images_from_google_query(\"potato\")\n    5\n    \"\"\"\n    max_images = min(max_images, 50)  # Prevent abuse!\n    params = {\n        \"q\": query,\n        \"tbm\": \"isch\",\n        \"hl\": \"en\",\n        \"ijn\": \"0\",\n    }\n\n    html = httpx.get(\n        \"https://www.google.com/search\", params=params, headers=headers, timeout=10\n    )\n    soup = BeautifulSoup(html.text, \"html.parser\")\n    matched_images_data = \"\".join(\n        re.findall(r\"AF_initDataCallback\\(([^<]+)\\);\", str(soup.select(\"script\")))\n    )\n\n    matched_images_data_fix = json.dumps(matched_images_data)\n    matched_images_data_json = json.loads(matched_images_data_fix)\n\n    matched_google_image_data = re.findall(\n        r\"\\[\\\"GRID_STATE0\\\",null,\\[\\[1,\\[0,\\\".*?\\\",(.*),\\\"All\\\",\",\n        matched_images_data_json,\n    )\n    if not matched_google_image_data:\n        return 0\n\n    removed_matched_google_images_thumbnails = re.sub(\n        r\"\\[\\\"(https\\:\\/\\/encrypted-tbn0\\.gstatic\\.com\\/images\\?.*?)\\\",\\d+,\\d+\\]\",\n        \"\",\n        str(matched_google_image_data),\n    )\n\n    matched_google_full_resolution_images = re.findall(\n        r\"(?:'|,),\\[\\\"(https:|http.*?)\\\",\\d+,\\d+\\]\",\n        removed_matched_google_images_thumbnails,\n    )\n    for index, fixed_full_res_image in enumerate(matched_google_full_resolution_images):\n        if index >= max_images:\n            return index\n        original_size_img_not_fixed = bytes(fixed_full_res_image, \"ascii\").decode(\n            \"unicode-escape\"\n        )\n        original_size_img = bytes(original_size_img_not_fixed, \"ascii\").decode(\n            \"unicode-escape\"\n        )\n        opener = urllib.request.build_opener()\n        opener.addheaders = [\n            (\n                \"User-Agent\",\n                \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"\n                \" (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.19582\",\n            )\n        ]\n        urllib.request.install_opener(opener)\n        path_name = f\"query_{query.replace(' ', '_')}\"\n        if not os.path.exists(path_name):\n            os.makedirs(path_name)\n        urllib.request.urlretrieve(  # noqa: S310\n            original_size_img, f\"{path_name}/original_size_img_{index}.jpg\"\n        )\n    return index",
    "docstring": "Searches google using the provided query term and downloads the images in a folder.\n\nArgs:\n     query : The image search term to be provided by the user. Defaults to\n    \"dhaka\".\n    image_numbers : [description]. Defaults to 5.\n\nReturns:\n    The number of images successfully downloaded.\n\n# Comment out slow (4.20s call) doctests\n# >>> download_images_from_google_query()\n5\n# >>> download_images_from_google_query(\"potato\")\n5"
  },
  {
    "function": "get_domain_name",
    "code": "def get_domain_name(url: str) -> str:\n    \"\"\"\n    This function get the main domain name\n\n    >>> get_domain_name(\"https://a.b.c.d/e/f?g=h,i=j#k\")\n    'c.d'\n    >>> get_domain_name(\"Not a URL!\")\n    ''\n    \"\"\"\n    return \".\".join(get_sub_domain_name(url).split(\".\")[-2:])",
    "docstring": "This function get the main domain name\n\n>>> get_domain_name(\"https://a.b.c.d/e/f?g=h,i=j#k\")\n'c.d'\n>>> get_domain_name(\"Not a URL!\")\n''"
  },
  {
    "function": "get_sub_domain_name",
    "code": "def get_sub_domain_name(url: str) -> str:\n    \"\"\"\n    >>> get_sub_domain_name(\"https://a.b.c.d/e/f?g=h,i=j#k\")\n    'a.b.c.d'\n    >>> get_sub_domain_name(\"Not a URL!\")\n    ''\n    \"\"\"\n    return parse.urlparse(url).netloc",
    "docstring": ">>> get_sub_domain_name(\"https://a.b.c.d/e/f?g=h,i=j#k\")\n'a.b.c.d'\n>>> get_sub_domain_name(\"Not a URL!\")\n''"
  },
  {
    "function": "emails_from_url",
    "code": "def emails_from_url(url: str = \"https://github.com\") -> list[str]:\n    \"\"\"\n    This function takes url and return all valid urls\n    \"\"\"\n    # Get the base domain from the url\n    domain = get_domain_name(url)\n\n    # Initialize the parser\n    parser = Parser(domain)\n\n    try:\n        # Open URL\n        r = httpx.get(url, timeout=10, follow_redirects=True)\n\n        # pass the raw HTML to the parser to get links\n        parser.feed(r.text)\n\n        # Get links and loop through\n        valid_emails = set()\n        for link in parser.urls:\n            # open URL.\n            # Check if the link is already absolute\n            if not link.startswith(\"http://\") and not link.startswith(\"https://\"):\n                # Prepend protocol only if link starts with domain, normalize otherwise\n                if link.startswith(domain):\n                    link = f\"https://{link}\"\n                else:\n                    link = parse.urljoin(f\"https://{domain}\", link)\n            try:\n                read = httpx.get(link, timeout=10, follow_redirects=True)\n                # Get the valid email.\n                emails = re.findall(\"[a-zA-Z0-9]+@\" + domain, read.text)\n                # If not in list then append it.\n                for email in emails:\n                    valid_emails.add(email)\n            except ValueError:\n                pass\n    except ValueError:\n        raise SystemExit(1)\n\n    # Finally return a sorted list of email addresses with no duplicates.\n    return sorted(valid_emails)",
    "docstring": "This function takes url and return all valid urls"
  },
  {
    "function": "search_scraper",
    "code": "def search_scraper(anime_name: str) -> list:\n    \"\"\"[summary]\n\n    Take an url and\n    return list of anime after scraping the site.\n\n    >>> type(search_scraper(\"demon_slayer\"))\n    <class 'list'>\n\n    Args:\n        anime_name (str): [Name of anime]\n\n    Raises:\n        e: [Raises exception on failure]\n\n    Returns:\n        [list]: [List of animes]\n    \"\"\"\n\n    # concat the name to form the search url.\n    search_url = f\"{BASE_URL}/search?keyword={anime_name}\"\n\n    response = httpx.get(\n        search_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10\n    )  # request the url.\n\n    # Is the response ok?\n    response.raise_for_status()\n\n    # parse with soup.\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    # get list of anime\n    anime_ul = soup.find(\"ul\", {\"class\": \"items\"})\n    if anime_ul is None or isinstance(anime_ul, NavigableString):\n        msg = f\"Could not find and anime with name {anime_name}\"\n        raise ValueError(msg)\n    anime_li = anime_ul.children\n\n    # for each anime, insert to list. the name and url.\n    anime_list = []\n    for anime in anime_li:\n        if isinstance(anime, Tag):\n            anime_url = anime.find(\"a\")\n            if anime_url is None or isinstance(anime_url, NavigableString):\n                continue\n            anime_title = anime.find(\"a\")\n            if anime_title is None or isinstance(anime_title, NavigableString):\n                continue\n\n            anime_list.append({\"title\": anime_title[\"title\"], \"url\": anime_url[\"href\"]})\n\n    return anime_list",
    "docstring": "[summary]\n\nTake an url and\nreturn list of anime after scraping the site.\n\n>>> type(search_scraper(\"demon_slayer\"))\n<class 'list'>\n\nArgs:\n    anime_name (str): [Name of anime]\n\nRaises:\n    e: [Raises exception on failure]\n\nReturns:\n    [list]: [List of animes]"
  },
  {
    "function": "search_anime_episode_list",
    "code": "def search_anime_episode_list(episode_endpoint: str) -> list:\n    \"\"\"[summary]\n\n    Take an url and\n    return list of episodes after scraping the site\n    for an url.\n\n    >>> type(search_anime_episode_list(\"/anime/kimetsu-no-yaiba\"))\n    <class 'list'>\n\n    Args:\n        episode_endpoint (str): [Endpoint of episode]\n\n    Raises:\n        e: [description]\n\n    Returns:\n        [list]: [List of episodes]\n    \"\"\"\n\n    request_url = f\"{BASE_URL}{episode_endpoint}\"\n\n    response = httpx.get(\n        url=request_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10\n    )\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    # With this id. get the episode list.\n    episode_page_ul = soup.find(\"ul\", {\"id\": \"episode_related\"})\n    if episode_page_ul is None or isinstance(episode_page_ul, NavigableString):\n        msg = f\"Could not find any anime eposiodes with name {anime_name}\"\n        raise ValueError(msg)\n    episode_page_li = episode_page_ul.children\n\n    episode_list = []\n    for episode in episode_page_li:\n        if isinstance(episode, Tag):\n            url = episode.find(\"a\")\n            if url is None or isinstance(url, NavigableString):\n                continue\n            title = episode.find(\"div\", {\"class\": \"name\"})\n            if title is None or isinstance(title, NavigableString):\n                continue\n\n            episode_list.append(\n                {\"title\": title.text.replace(\" \", \"\"), \"url\": url[\"href\"]}\n            )\n\n    return episode_list",
    "docstring": "[summary]\n\nTake an url and\nreturn list of episodes after scraping the site\nfor an url.\n\n>>> type(search_anime_episode_list(\"/anime/kimetsu-no-yaiba\"))\n<class 'list'>\n\nArgs:\n    episode_endpoint (str): [Endpoint of episode]\n\nRaises:\n    e: [description]\n\nReturns:\n    [list]: [List of episodes]"
  },
  {
    "function": "get_anime_episode",
    "code": "def get_anime_episode(episode_endpoint: str) -> list:\n    \"\"\"[summary]\n\n    Get click url and download url from episode url\n\n    >>> type(get_anime_episode(\"/watch/kimetsu-no-yaiba/1\"))\n    <class 'list'>\n\n    Args:\n        episode_endpoint (str): [Endpoint of episode]\n\n    Raises:\n        e: [description]\n\n    Returns:\n        [list]: [List of download and watch url]\n    \"\"\"\n\n    episode_page_url = f\"{BASE_URL}{episode_endpoint}\"\n\n    response = httpx.get(\n        url=episode_page_url, headers={\"User-Agent\": UserAgent().chrome}, timeout=10\n    )\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    url = soup.find(\"iframe\", {\"id\": \"playerframe\"})\n    if url is None or isinstance(url, NavigableString):\n        msg = f\"Could not find url and download url from {episode_endpoint}\"\n        raise RuntimeError(msg)\n\n    episode_url = url[\"src\"]\n    if not isinstance(episode_url, str):\n        msg = f\"Could not find url and download url from {episode_endpoint}\"\n        raise RuntimeError(msg)\n    download_url = episode_url.replace(\"/embed/\", \"/playlist/\") + \".m3u8\"\n\n    return [f\"{BASE_URL}{episode_url}\", f\"{BASE_URL}{download_url}\"]",
    "docstring": "[summary]\n\nGet click url and download url from episode url\n\n>>> type(get_anime_episode(\"/watch/kimetsu-no-yaiba/1\"))\n<class 'list'>\n\nArgs:\n    episode_endpoint (str): [Endpoint of episode]\n\nRaises:\n    e: [description]\n\nReturns:\n    [list]: [List of download and watch url]"
  },
  {
    "function": "fetch_github_info",
    "code": "def fetch_github_info(auth_token: str) -> dict[Any, Any]:\n    \"\"\"\n    Fetch GitHub info of a user using the httpx module\n    \"\"\"\n    headers = {\n        \"Authorization\": f\"token {auth_token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    return httpx.get(AUTHENTICATED_USER_ENDPOINT, headers=headers, timeout=10).json()",
    "docstring": "Fetch GitHub info of a user using the httpx module"
  },
  {
    "function": "fetch_pharmacy_and_price_list",
    "code": "def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n    \"\"\"[summary]\n\n    This function will take input of drug name and zipcode,\n    then request to the BASE_URL site.\n    Get the page data and scrape it to generate the\n    list of the lowest prices for the prescription drug.\n\n    Args:\n        drug_name (str): [Drug name]\n        zip_code(str): [Zip code]\n\n    Returns:\n        list: [List of pharmacy name and price]\n\n    >>> print(fetch_pharmacy_and_price_list(None, None))\n    None\n    >>> print(fetch_pharmacy_and_price_list(None, 30303))\n    None\n    >>> print(fetch_pharmacy_and_price_list(\"eliquis\", None))\n    None\n    \"\"\"\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None",
    "docstring": "[summary]\n\nThis function will take input of drug name and zipcode,\nthen request to the BASE_URL site.\nGet the page data and scrape it to generate the\nlist of the lowest prices for the prescription drug.\n\nArgs:\n    drug_name (str): [Drug name]\n    zip_code(str): [Zip code]\n\nReturns:\n    list: [List of pharmacy name and price]\n\n>>> print(fetch_pharmacy_and_price_list(None, None))\nNone\n>>> print(fetch_pharmacy_and_price_list(None, 30303))\nNone\n>>> print(fetch_pharmacy_and_price_list(\"eliquis\", None))\nNone"
  },
  {
    "function": "get_amazon_product_data",
    "code": "def get_amazon_product_data(product: str = \"laptop\") -> DataFrame:\n    \"\"\"\n    Take a product name or category as input and return product information from Amazon\n    including title, URL, price, ratings, and the discount available.\n    \"\"\"\n    url = f\"https://www.amazon.in/laptop/s?k={product}\"\n    header = {\n        \"User-Agent\": (\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36\"\n            \"(KHTML, like Gecko)Chrome/44.0.2403.157 Safari/537.36\"\n        ),\n        \"Accept-Language\": \"en-US, en;q=0.5\",\n    }\n    soup = BeautifulSoup(\n        httpx.get(url, headers=header, timeout=10).text, features=\"lxml\"\n    )\n    # Initialize a Pandas dataframe with the column titles\n    data_frame = DataFrame(\n        columns=[\n            \"Product Title\",\n            \"Product Link\",\n            \"Current Price of the product\",\n            \"Product Rating\",\n            \"MRP of the product\",\n            \"Discount\",\n        ]\n    )\n    # Loop through each entry and store them in the dataframe\n    for item, _ in zip_longest(\n        soup.find_all(\n            \"div\",\n            attrs={\"class\": \"s-result-item\", \"data-component-type\": \"s-search-result\"},\n        ),\n        soup.find_all(\"div\", attrs={\"class\": \"a-row a-size-base a-color-base\"}),\n    ):\n        try:\n            product_title = item.h2.text\n            product_link = \"https://www.amazon.in/\" + item.h2.a[\"href\"]\n            product_price = item.find(\"span\", attrs={\"class\": \"a-offscreen\"}).text\n            try:\n                product_rating = item.find(\"span\", attrs={\"class\": \"a-icon-alt\"}).text\n            except AttributeError:\n                product_rating = \"Not available\"\n            try:\n                product_mrp = (\n                    \"\u20b9\"\n                    + item.find(\n                        \"span\", attrs={\"class\": \"a-price a-text-price\"}\n                    ).text.split(\"\u20b9\")[1]\n                )\n            except AttributeError:\n                product_mrp = \"\"\n            try:\n                discount = float(\n                    (\n                        (\n                            float(product_mrp.strip(\"\u20b9\").replace(\",\", \"\"))\n                            - float(product_price.strip(\"\u20b9\").replace(\",\", \"\"))\n                        )\n                        / float(product_mrp.strip(\"\u20b9\").replace(\",\", \"\"))\n                    )\n                    * 100\n                )\n            except ValueError:\n                discount = float(\"nan\")\n        except AttributeError:\n            continue\n        data_frame.loc[str(len(data_frame.index))] = [\n            product_title,\n            product_link,\n            product_price,\n            product_rating,\n            product_mrp,\n            discount,\n        ]\n    data_frame.loc[\n        data_frame[\"Current Price of the product\"] > data_frame[\"MRP of the product\"],\n        \"MRP of the product\",\n    ] = \" \"\n    data_frame.loc[\n        data_frame[\"Current Price of the product\"] > data_frame[\"MRP of the product\"],\n        \"Discount\",\n    ] = \" \"\n    data_frame.index += 1\n    return data_frame",
    "docstring": "Take a product name or category as input and return product information from Amazon\nincluding title, URL, price, ratings, and the discount available."
  },
  {
    "function": "years_old",
    "code": "def years_old(birth_timestamp: int, today: date | None = None) -> int:\n    \"\"\"\n    Calculate the age in years based on the given birth date.  Only the year, month,\n    and day are used in the calculation.  The time of day is ignored.\n\n    Args:\n        birth_timestamp: The date of birth.\n        today: (useful for writing tests) or if None then datetime.date.today().\n\n    Returns:\n        int: The age in years.\n\n    Examples:\n    >>> today = date(2024, 1, 12)\n    >>> years_old(birth_timestamp=datetime(1959, 11, 20).timestamp(), today=today)\n    64\n    >>> years_old(birth_timestamp=datetime(1970, 2, 13).timestamp(), today=today)\n    53\n    >>> all(\n    ...     years_old(datetime(today.year - i, 1, 12).timestamp(), today=today) == i\n    ...     for i in range(1, 111)\n    ... )\n    True\n    \"\"\"\n    today = today or TODAY.date()\n    birth_date = datetime.fromtimestamp(birth_timestamp, tz=UTC).date()\n    return (today.year - birth_date.year) - (\n        (today.month, today.day) < (birth_date.month, birth_date.day)\n    )",
    "docstring": "Calculate the age in years based on the given birth date.  Only the year, month,\nand day are used in the calculation.  The time of day is ignored.\n\nArgs:\n    birth_timestamp: The date of birth.\n    today: (useful for writing tests) or if None then datetime.date.today().\n\nReturns:\n    int: The age in years.\n\nExamples:\n>>> today = date(2024, 1, 12)\n>>> years_old(birth_timestamp=datetime(1959, 11, 20).timestamp(), today=today)\n64\n>>> years_old(birth_timestamp=datetime(1970, 2, 13).timestamp(), today=today)\n53\n>>> all(\n...     years_old(datetime(today.year - i, 1, 12).timestamp(), today=today) == i\n...     for i in range(1, 111)\n... )\nTrue"
  },
  {
    "function": "get_forbes_real_time_billionaires",
    "code": "def get_forbes_real_time_billionaires() -> list[dict[str, int | str]]:\n    \"\"\"\n    Get the top 10 real-time billionaires using Forbes API.\n\n    Returns:\n        List of top 10 realtime billionaires data.\n    \"\"\"\n    response_json = httpx.get(API_URL, timeout=10).json()\n    return [\n        {\n            \"Name\": person[\"personName\"],\n            \"Source\": person[\"source\"],\n            \"Country\": person[\"countryOfCitizenship\"],\n            \"Gender\": person[\"gender\"],\n            \"Worth ($)\": f\"{person['finalWorth'] / 1000:.1f} Billion\",\n            \"Age\": str(years_old(person[\"birthDate\"] / 1000)),\n        }\n        for person in response_json[\"personList\"][\"personsLists\"]\n    ]",
    "docstring": "Get the top 10 real-time billionaires using Forbes API.\n\nReturns:\n    List of top 10 realtime billionaires data."
  },
  {
    "function": "display_billionaires",
    "code": "def display_billionaires(forbes_billionaires: list[dict[str, int | str]]) -> None:\n    \"\"\"\n    Display Forbes real-time billionaires in a rich table.\n\n    Args:\n        forbes_billionaires (list): Forbes top 10 real-time billionaires\n    \"\"\"\n\n    table = rich_table.Table(\n        title=f\"Forbes Top {LIMIT} Real-Time Billionaires at {TODAY:%Y-%m-%d %H:%M}\",\n        style=\"green\",\n        highlight=True,\n        box=box.SQUARE,\n    )\n    for key in forbes_billionaires[0]:\n        table.add_column(key)\n\n    for billionaire in forbes_billionaires:\n        table.add_row(*billionaire.values())\n\n    rich_console.Console().print(table)",
    "docstring": "Display Forbes real-time billionaires in a rich table.\n\nArgs:\n    forbes_billionaires (list): Forbes top 10 real-time billionaires"
  },
  {
    "function": "hackernews_top_stories",
    "code": "def hackernews_top_stories(max_stories: int = 10) -> list[dict]:\n    \"\"\"\n    Get the top max_stories posts from HackerNews - https://news.ycombinator.com/\n    \"\"\"\n    url = \"https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty\"\n    story_ids = httpx.get(url, timeout=10).json()[:max_stories]\n    return [get_hackernews_story(story_id) for story_id in story_ids]",
    "docstring": "Get the top max_stories posts from HackerNews - https://news.ycombinator.com/"
  },
  {
    "function": "get_gifs",
    "code": "def get_gifs(query: str, api_key: str = giphy_api_key) -> list:\n    \"\"\"\n    Get a list of URLs of GIFs based on a given query..\n    \"\"\"\n    formatted_query = \"+\".join(query.split())\n    url = f\"https://api.giphy.com/v1/gifs/search?q={formatted_query}&api_key={api_key}\"\n    gifs = httpx.get(url, timeout=10).json()[\"data\"]\n    return [gif[\"url\"] for gif in gifs]",
    "docstring": "Get a list of URLs of GIFs based on a given query.."
  },
  {
    "function": "extract_user_profile",
    "code": "def extract_user_profile(script) -> dict:\n    \"\"\"\n    May raise json.decoder.JSONDecodeError\n    \"\"\"\n    data = script.contents[0]\n    info = json.loads(data[data.find('{\"config\"') : -1])\n    return info[\"entry_data\"][\"ProfilePage\"][0][\"graphql\"][\"user\"]",
    "docstring": "May raise json.decoder.JSONDecodeError"
  },
  {
    "function": "test_instagram_user",
    "code": "def test_instagram_user(username: str = \"github\") -> None:\n    \"\"\"\n    A self running doctest\n    >>> test_instagram_user()\n    \"\"\"\n    import os\n\n    if os.environ.get(\"CI\"):\n        return  # test failing on GitHub Actions\n    instagram_user = InstagramUser(username)\n    assert instagram_user.user_data\n    assert isinstance(instagram_user.user_data, dict)\n    assert instagram_user.username == username\n    if username != \"github\":\n        return\n    assert instagram_user.fullname == \"GitHub\"\n    assert instagram_user.biography == \"Built for developers.\"\n    assert instagram_user.number_of_posts > 150\n    assert instagram_user.number_of_followers > 120000\n    assert instagram_user.number_of_followings > 15\n    assert instagram_user.email == \"support@github.com\"\n    assert instagram_user.website == \"https://github.com/readme\"\n    assert instagram_user.profile_picture_url.startswith(\"https://instagram.\")\n    assert instagram_user.is_verified is True\n    assert instagram_user.is_private is False",
    "docstring": "A self running doctest\n>>> test_instagram_user()"
  },
  {
    "function": "download_image",
    "code": "def download_image(url: str) -> str:\n    \"\"\"\n    Download an image from a given URL by scraping the 'og:image' meta tag.\n\n    Parameters:\n        url: The URL to scrape.\n\n    Returns:\n        A message indicating the result of the operation.\n    \"\"\"\n    try:\n        response = httpx.get(url, timeout=10)\n        response.raise_for_status()\n    except httpx.RequestError as e:\n        return f\"An error occurred during the HTTP request to {url}: {e!r}\"\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n    image_meta_tag = soup.find(\"meta\", {\"property\": \"og:image\"})\n    if not image_meta_tag:\n        return \"No meta tag with property 'og:image' was found.\"\n\n    image_url = image_meta_tag.get(\"content\")\n    if not image_url:\n        return f\"Image URL not found in meta tag {image_meta_tag}.\"\n\n    try:\n        image_data = httpx.get(image_url, timeout=10).content\n    except httpx.RequestError as e:\n        return f\"An error occurred during the HTTP request to {image_url}: {e!r}\"\n    if not image_data:\n        return f\"Failed to download the image from {image_url}.\"\n\n    file_name = f\"{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H-%M-%S}.jpg\"\n    with open(file_name, \"wb\") as out_file:\n        out_file.write(image_data)\n    return f\"Image downloaded and saved in the file {file_name}\"",
    "docstring": "Download an image from a given URL by scraping the 'og:image' meta tag.\n\nParameters:\n    url: The URL to scrape.\n\nReturns:\n    A message indicating the result of the operation."
  },
  {
    "function": "get_apod_data",
    "code": "def get_apod_data(api_key: str) -> dict:\n    \"\"\"\n    Get the APOD(Astronomical Picture of the day) data\n    Get your API Key from: https://api.nasa.gov/\n    \"\"\"\n    url = \"https://api.nasa.gov/planetary/apod\"\n    return httpx.get(url, params={\"api_key\": api_key}, timeout=10).json()",
    "docstring": "Get the APOD(Astronomical Picture of the day) data\nGet your API Key from: https://api.nasa.gov/"
  },
  {
    "function": "get_archive_data",
    "code": "def get_archive_data(query: str) -> dict:\n    \"\"\"\n    Get the data of a particular query from NASA archives\n    \"\"\"\n    url = \"https://images-api.nasa.gov/search\"\n    return httpx.get(url, params={\"q\": query}, timeout=10).json()",
    "docstring": "Get the data of a particular query from NASA archives"
  },
  {
    "function": "save_image",
    "code": "def save_image(image_url: str, image_title: str) -> None:\n    \"\"\"\n    Saves the image of anime character\n    \"\"\"\n    image = httpx.get(image_url, headers=headers, timeout=10)\n    with open(image_title, \"wb\") as file:\n        file.write(image.content)",
    "docstring": "Saves the image of anime character"
  },
  {
    "function": "random_anime_character",
    "code": "def random_anime_character() -> tuple[str, str, str]:\n    \"\"\"\n    Returns the Title, Description, and Image Title of a random anime character .\n    \"\"\"\n    soup = BeautifulSoup(\n        httpx.get(URL, headers=headers, timeout=10).text, \"html.parser\"\n    )\n    title = soup.find(\"meta\", attrs={\"property\": \"og:title\"}).attrs[\"content\"]\n    image_url = soup.find(\"meta\", attrs={\"property\": \"og:image\"}).attrs[\"content\"]\n    description = soup.find(\"p\", id=\"description\").get_text()\n    _, image_extension = os.path.splitext(os.path.basename(image_url))\n    image_title = title.strip().replace(\" \", \"_\")\n    image_title = f\"{image_title}{image_extension}\"\n    save_image(image_url, image_title)\n    return (title, description, image_title)",
    "docstring": "Returns the Title, Description, and Image Title of a random anime character ."
  },
  {
    "function": "get_subreddit_data",
    "code": "def get_subreddit_data(\n    subreddit: str, limit: int = 1, age: str = \"new\", wanted_data: list | None = None\n) -> dict:\n    \"\"\"\n    subreddit : Subreddit to query\n    limit : Number of posts to fetch\n    age : [\"new\", \"top\", \"hot\"]\n    wanted_data : Get only the required data in the list\n    \"\"\"\n    wanted_data = wanted_data or []\n    if invalid_search_terms := \", \".join(sorted(set(wanted_data) - valid_terms)):\n        msg = f\"Invalid search term: {invalid_search_terms}\"\n        raise ValueError(msg)\n    response = httpx.get(\n        f\"https://www.reddit.com/r/{subreddit}/{age}.json?limit={limit}\",\n        headers={\"User-agent\": \"A random string\"},\n        timeout=10,\n    )\n    response.raise_for_status()\n    if response.status_code == 429:\n        raise httpx.HTTPError(response=response)\n\n    data = response.json()\n    if not wanted_data:\n        return {id_: data[\"data\"][\"children\"][id_] for id_ in range(limit)}\n\n    data_dict = {}\n    for id_ in range(limit):\n        data_dict[id_] = {\n            item: data[\"data\"][\"children\"][id_][\"data\"][item] for item in wanted_data\n        }\n    return data_dict",
    "docstring": "subreddit : Subreddit to query\nlimit : Number of posts to fetch\nage : [\"new\", \"top\", \"hot\"]\nwanted_data : Get only the required data in the list"
  },
  {
    "function": "get_openlibrary_data",
    "code": "def get_openlibrary_data(olid: str = \"isbn/0140328726\") -> dict:\n    \"\"\"\n    Given an 'isbn/0140328726', return book data from Open Library as a Python dict.\n    Given an '/authors/OL34184A', return authors data as a Python dict.\n    This code must work for olids with or without a leading slash ('/').\n\n    # Comment out doctests if they take too long or have results that may change\n    # >>> get_openlibrary_data(olid='isbn/0140328726')  # doctest: +ELLIPSIS\n    {'publishers': ['Puffin'], 'number_of_pages': 96, 'isbn_10': ['0140328726'], ...\n    # >>> get_openlibrary_data(olid='/authors/OL7353617A')  # doctest: +ELLIPSIS\n    {'name': 'Adrian Brisku', 'created': {'type': '/type/datetime', ...\n    \"\"\"\n    new_olid = olid.strip().strip(\"/\")  # Remove leading/trailing whitespace & slashes\n    if new_olid.count(\"/\") != 1:\n        msg = f\"{olid} is not a valid Open Library olid\"\n        raise ValueError(msg)\n    return httpx.get(\n        f\"https://openlibrary.org/{new_olid}.json\", timeout=10, follow_redirects=True\n    ).json()",
    "docstring": "Given an 'isbn/0140328726', return book data from Open Library as a Python dict.\nGiven an '/authors/OL34184A', return authors data as a Python dict.\nThis code must work for olids with or without a leading slash ('/').\n\n# Comment out doctests if they take too long or have results that may change\n# >>> get_openlibrary_data(olid='isbn/0140328726')  # doctest: +ELLIPSIS\n{'publishers': ['Puffin'], 'number_of_pages': 96, 'isbn_10': ['0140328726'], ...\n# >>> get_openlibrary_data(olid='/authors/OL7353617A')  # doctest: +ELLIPSIS\n{'name': 'Adrian Brisku', 'created': {'type': '/type/datetime', ..."
  },
  {
    "function": "summarize_book",
    "code": "def summarize_book(ol_book_data: dict) -> dict:\n    \"\"\"\n    Given Open Library book data, return a summary as a Python dict.\n    \"\"\"\n    desired_keys = {\n        \"title\": \"Title\",\n        \"publish_date\": \"Publish date\",\n        \"authors\": \"Authors\",\n        \"number_of_pages\": \"Number of pages\",\n        \"isbn_10\": \"ISBN (10)\",\n        \"isbn_13\": \"ISBN (13)\",\n    }\n    data = {better_key: ol_book_data[key] for key, better_key in desired_keys.items()}\n    data[\"Authors\"] = [\n        get_openlibrary_data(author[\"key\"])[\"name\"] for author in data[\"Authors\"]\n    ]\n    for key, value in data.items():\n        if isinstance(value, list):\n            data[key] = \", \".join(value)\n    return data",
    "docstring": "Given Open Library book data, return a summary as a Python dict."
  },
  {
    "function": "world_covid19_stats",
    "code": "def world_covid19_stats(\n    url: str = \"https://www.worldometers.info/coronavirus/\",\n) -> dict:\n    \"\"\"\n    Return a dict of current worldwide COVID-19 statistics\n    \"\"\"\n    soup = BeautifulSoup(\n        httpx.get(url, timeout=10, follow_redirects=True).text, \"html.parser\"\n    )\n    keys = soup.find_all(\"h1\")\n    values = soup.find_all(\"div\", {\"class\": \"maincounter-number\"})\n    keys += soup.find_all(\"span\", {\"class\": \"panel-title\"})\n    values += soup.find_all(\"div\", {\"class\": \"number-table-main\"})\n    return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}",
    "docstring": "Return a dict of current worldwide COVID-19 statistics"
  }
]