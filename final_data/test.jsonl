{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    return sum(e for e in range(3, n) if e % 3 == 0 or e % 5 == 0)", "output": "Returns the sum of all the multiples of 3 or 5 below n."}
{"task": "repair", "input": "fix bug:\ndef y_generator(class_count: int, instance_count: list) -> list:\n    \"\"\"\n    Generate y values for corresponding classes\n    :param class_count: Number of classes(data groupings) in dataset\n    :param instance_count: number of instances in class\n    :return: corresponding values for data groupings in dataset\n\n    >>> y_generator(1, [10])\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    >>> y_generator(2, [5, 10])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    return [k for k in range(class_count) for _ in range(instance_count[k])]", "output": "def y_generator(class_count: int, instance_count: list) -> list:\n    \"\"\"\n    Generate y values for corresponding classes\n    :param class_count: Number of classes(data groupings) in dataset\n    :param instance_count: number of instances in class\n    :return: corresponding values for data groupings in dataset\n\n    >>> y_generator(1, [10])\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    >>> y_generator(2, [5, 10])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    return [k for k in range(class_count) for _ in range(instance_count[k])]", "tests": ["assert y_generator(1, [10]) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]", "assert y_generator(2, [5, 10]) == [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]", "assert y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,"]}
{"task": "summary", "input": "summarize code:\ndef indian_phone_validator(phone: str) -> bool:\n    pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")\n    if match := re.search(pat, phone):\n        return match.string == phone\n    return False", "output": "Determine whether the string is a valid phone number or not"}
{"task": "detection", "input": "classify code:\ndef comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True", "output": "def is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True", "tests": ["assert is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9)) == False", "assert is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9)) == False", "assert is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9)) == True"]}
{"task": "search", "input": "search code:\nGenerate a random graph\n\nChoices:\n0: def horn_schunck(     image0: np.ndarray,     image1: np.ndarray,     num_iter: SupportsIndex,     alpha: float | None = None, ) -> tuple[np.ndarray, np.ndarray]:     if alpha is None:         alpha = 0.1      # Initialize flow     horizontal_flow = np.zeros_like(image0)     vertical_flow = np.zeros_like(image0)      # Prepare kernels for the calculation of the derivatives and the average velocity     kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25     kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25     kernel_t = np.array([[1, 1], [1, 1]]) * 0.25     kernel_laplacian = np.array(         [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]     )      # Iteratively refine the flow     for _ in range(num_iter):         warped_image = warp(image0, horizontal_flow, vertical_flow)         derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)         derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)         derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)          avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)         avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)          # This updates the flow as proposed in the paper (Step 12)         update = (             derivative_x * avg_horizontal_velocity             + derivative_y * avg_vertical_velocity             + derivative_t         )         update = update / (alpha**2 + derivative_x**2 + derivative_y**2)          horizontal_flow = avg_horizontal_velocity - derivative_x * update         vertical_flow = avg_vertical_velocity - derivative_y * update      return horizontal_flow, vertical_flow\n1: def random_graph(     vertices_number: int, probability: float, directed: bool = False ) -> dict:     graph: dict = {i: [] for i in range(vertices_number)}      # if probability is greater or equal than 1, then generate a complete graph     if probability >= 1:         return complete_graph(vertices_number)     # if probability is lower or equal than 0, then return a graph without edges     if probability <= 0:         return graph      # for each couple of nodes, add an edge from u to v     # if the number randomly generated is greater than probability probability     for i in range(vertices_number):         for j in range(i + 1, vertices_number):             if random.random() < probability:                 graph[i].append(j)                 if not directed:                     # if the graph is undirected, add an edge in from j to i, either                     graph[j].append(i)     return graph\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)", "output": "def alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)", "tests": ["assert alternative_string_arrange(\"ABCD\", \"XY\") == 'AXBYCD'", "assert alternative_string_arrange(\"XY\", \"ABCD\") == 'XAYBCD'", "assert alternative_string_arrange(\"AB\", \"XYZ\") == 'AXBYZ'", "assert alternative_string_arrange(\"ABC\", \"\") == 'ABC'"]}
{"task": "summary", "input": "summarize code:\ndef solution(num_terms: int = 60, max_start: int = 1000000) -> int:\n    return sum(1 for i in range(1, max_start) if chain_length(i) == num_terms)", "output": "Return the number of chains with a starting number below one million which"}
{"task": "search", "input": "search code:\nReturn the relative distance (= step/max_step) after which the complex number\n\nChoices:\n0: def always_iterable(obj, base_type=(str, bytes)):     if obj is None:         return iter(())      if (base_type is not None) and isinstance(obj, base_type):         return iter((obj,))      try:         return iter(obj)     except TypeError:         return iter((obj,))\n1: def solution(n: int = 4) -> int | None:     results = run(n)     return results[0] if len(results) else None\n2: def get_distance(x: float, y: float, max_step: int) -> float:     a = x     b = y     for step in range(max_step):  # noqa: B007         a_new = a * a - b * b + x         b = 2 * a * b + y         a = a_new          # divergence happens for all complex number with an absolute value         # greater than 4         if a * a + b * b > 4:             break     return step / (max_step - 1)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef kth_permutation(k, n):\n    \"\"\"\n    Finds k'th lexicographic permutation (in increasing order) of\n    0,1,2,...n-1 in O(n^2) time.\n\n    Examples:\n    First permutation is always 0,1,2,...n\n    >>> kth_permutation(0,5)\n    [0, 1, 2, 3, 4]\n\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n    [1,2,3,0], [1,3,0,2]\n    >>> kth_permutation(10,4)\n    [1, 3, 0, 2]\n    \"\"\"\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution(nth: int = 10001) -> int:\n    return next(itertools.islice(prime_generator(), nth - 1, nth))", "output": "Returns the n-th prime number."}
{"task": "search", "input": "search code:\nFunction calculates the total resistance of the resistor using the color codes.\n\nChoices:\n0: def calculate_resistance(number_of_bands: int, color_code_list: list) -> dict:     is_valid = check_validity(number_of_bands, color_code_list)     if is_valid:         number_of_significant_bands = get_band_type_count(             number_of_bands, \"significant\"         )         significant_colors = color_code_list[:number_of_significant_bands]         significant_digits = int(get_significant_digits(significant_colors))         multiplier_color = color_code_list[number_of_significant_bands]         multiplier = get_multiplier(multiplier_color)         if number_of_bands == 3:             tolerance_color = None         else:             tolerance_color = color_code_list[number_of_significant_bands + 1]         tolerance = (             20 if tolerance_color is None else get_tolerance(str(tolerance_color))         )         if number_of_bands != 6:             temperature_coeffecient_color = None         else:             temperature_coeffecient_color = color_code_list[                 number_of_significant_bands + 2             ]         temperature_coeffecient = (             0             if temperature_coeffecient_color is None             else get_temperature_coeffecient(str(temperature_coeffecient_color))         )         resisitance = significant_digits * multiplier         if temperature_coeffecient == 0:             answer = f\"{resisitance}Ω ±{tolerance}% \"         else:             answer = f\"{resisitance}Ω ±{tolerance}% {temperature_coeffecient} ppm/K\"         return {\"resistance\": answer}     else:         raise ValueError(\"Input is invalid\")\n1: def xnor_gate(input_1: int, input_2: int) -> int:     return 1 if input_1 == input_2 else 0\n2: def straight_line_depreciation(     useful_years: int,     purchase_value: float,     residual_value: float = 0.0, ) -> list[float]:      if not isinstance(useful_years, int):         raise TypeError(\"Useful years must be an integer\")      if useful_years < 1:         raise ValueError(\"Useful years cannot be less than 1\")      if not isinstance(purchase_value, (float, int)):         raise TypeError(\"Purchase value must be numeric\")      if not isinstance(residual_value, (float, int)):         raise TypeError(\"Residual value must be numeric\")      if purchase_value < 0.0:         raise ValueError(\"Purchase value cannot be less than zero\")      if purchase_value < residual_value:         raise ValueError(\"Purchase value cannot be less than residual value\")      # Calculate annual depreciation expense     depreciable_cost = purchase_value - residual_value     annual_depreciation_expense = depreciable_cost / useful_years      # List of annual depreciation expenses     list_of_depreciation_expenses = []     accumulated_depreciation_expense = 0.0     for period in range(useful_years):         if period != useful_years - 1:             accumulated_depreciation_expense += annual_depreciation_expense             list_of_depreciation_expenses.append(annual_depreciation_expense)         else:             depreciation_expense_in_end_year = (                 depreciable_cost - accumulated_depreciation_expense             )             list_of_depreciation_expenses.append(depreciation_expense_in_end_year)      return list_of_depreciation_expenses", "output": "0"}
{"task": "detection", "input": "classify code:\ndef solution(n):\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    [2, 8]\r\n    >>> solution(15)\r\n    [2, 8]\r\n    >>> solution(2)\r\n    [2]\r\n    >>> solution(1)\r\n    []\r\n    >>> solution(34)\r\n    [2, 8, 34]\r\n    \"\"\"\r\n    ls = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            ls.append(b)\r\n        a, b = b, a + b\r\n    return ls\r", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data", "output": "def comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data", "tests": ["assert comb_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]", "assert comb_sort([]) == []", "assert comb_sort([99, 45, -7, 8, 2, 0, -15, 3]) == [-15, -7, 0, 2, 3, 8, 45, 99]"]}
{"task": "search", "input": "search code:\nThis algorithm equalizes all elements of the input vector\n\nChoices:\n0: def array_equalization(vector: list[int], step_size: int) -> int:     if step_size <= 0:         raise ValueError(\"Step size must be positive and non-zero.\")     if not isinstance(step_size, int):         raise ValueError(\"Step size must be an integer.\")      unique_elements = set(vector)     min_updates = maxsize      for element in unique_elements:         elem_index = 0         updates = 0         while elem_index < len(vector):             if vector[elem_index] != element:                 updates += 1                 elem_index += step_size             else:                 elem_index += 1         min_updates = min(min_updates, updates)      return min_updates\n1: def is_safe_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return (number - 1) % 2 == 0 and is_prime(number) and is_prime((number - 1) // 2)\n2: def encode(word: str) -> str:     encoded = \"\"     for letter in word.lower():         if letter.isalpha() or letter == \" \":             encoded += encode_dict[letter]         else:             raise Exception(\"encode() accepts only letters of the alphabet and spaces\")     return encoded", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef get_squares(n: int) -> list[int]:\n    \"\"\"\n    >>> get_squares(0)\n    []\n    >>> get_squares(1)\n    [0]\n    >>> get_squares(2)\n    [0, 1]\n    >>> get_squares(3)\n    [0, 1, 4]\n    >>> get_squares(4)\n    [0, 1, 4, 9]\n    \"\"\"\n    return [number * number for number in range(n)]", "output": "def get_squares(n: int) -> list[int]:\n    \"\"\"\n    >>> get_squares(0)\n    []\n    >>> get_squares(1)\n    [0]\n    >>> get_squares(2)\n    [0, 1]\n    >>> get_squares(3)\n    [0, 1, 4]\n    >>> get_squares(4)\n    [0, 1, 4, 9]\n    \"\"\"\n    return [number * number for number in range(n)]", "tests": ["assert get_squares(0) == []", "assert get_squares(1) == [0]", "assert get_squares(2) == [0, 1]", "assert get_squares(3) == [0, 1, 4]", "assert get_squares(4) == [0, 1, 4, 9]"]}
{"task": "summary", "input": "summarize code:\ndef ordinal(value, gender=\"male\"):\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n    if gender == \"male\":\n        t = (\n            P_(\"0 (male)\", \"th\"),\n            P_(\"1 (male)\", \"st\"),\n            P_(\"2 (male)\", \"nd\"),\n            P_(\"3 (male)\", \"rd\"),\n            P_(\"4 (male)\", \"th\"),\n            P_(\"5 (male)\", \"th\"),\n            P_(\"6 (male)\", \"th\"),\n            P_(\"7 (male)\", \"th\"),\n            P_(\"8 (male)\", \"th\"),\n            P_(\"9 (male)\", \"th\"),\n        )\n    else:\n        t = (\n            P_(\"0 (female)\", \"th\"),\n            P_(\"1 (female)\", \"st\"),\n            P_(\"2 (female)\", \"nd\"),\n            P_(\"3 (female)\", \"rd\"),\n            P_(\"4 (female)\", \"th\"),\n            P_(\"5 (female)\", \"th\"),\n            P_(\"6 (female)\", \"th\"),\n            P_(\"7 (female)\", \"th\"),\n            P_(\"8 (female)\", \"th\"),\n            P_(\"9 (female)\", \"th\"),\n        )\n    if value % 100 in (11, 12, 13):  # special case\n        return f\"{value}{t[0]}\"\n    return f\"{value}{t[value % 10]}\"", "output": "Converts an integer to its ordinal as a string."}
{"task": "detection", "input": "classify code:\ndef largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef factorial(digit: int) -> int:\n    \"\"\"\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    >>> factorial(5)\n    120\n    \"\"\"\n\n    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))", "output": "def factorial(digit: int) -> int:\n    \"\"\"\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    >>> factorial(5)\n    120\n    \"\"\"\n\n    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))", "tests": ["assert factorial(3) == 6", "assert factorial(0) == 1", "assert factorial(5) == 120"]}
{"task": "detection", "input": "classify code:\ndef minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef binary_tree_bottom_side_view(root: TreeNode) -> list[int]:\n    from collections import defaultdict\n\n    def breadth_first_search(root: TreeNode, bottom_view: list[int]) -> None:\n        queue = [(root, 0)]\n        lookup = defaultdict(list)\n\n        while queue:\n            first = queue.pop(0)\n            node, hd = first\n            lookup[hd].append(node.val)\n\n            if node.left:\n                queue.append((node.left, hd - 1))\n            if node.right:\n                queue.append((node.right, hd + 1))\n\n        for pair in sorted(lookup.items(), key=lambda each: each[0]):\n            bottom_view.append(pair[1][-1])\n\n    bottom_view: list = []\n    if not root:\n        return bottom_view\n\n    breadth_first_search(root, bottom_view)\n    return bottom_view", "output": "Function returns the bottom side view of binary tree"}
{"task": "search", "input": "search code:\nReturns True if graph is cyclic else False\n\nChoices:\n0: def check_cycle(graph: dict) -> bool:     # Keep track of visited nodes     visited: set[int] = set()     # To detect a back edge, keep track of vertices currently in the recursion stack     rec_stk: set[int] = set()     return any(         node not in visited and depth_first_search(graph, node, visited, rec_stk)         for node in graph     )\n1: def solution(n: int = 1000) -> int:      total = 0     num = 0     while 1:         num += 3         if num >= n:             break         total += num         num += 2         if num >= n:             break         total += num         num += 1         if num >= n:             break         total += num         num += 3         if num >= n:             break         total += num         num += 1         if num >= n:             break         total += num         num += 2         if num >= n:             break         total += num         num += 3         if num >= n:             break         total += num     return total\n2: def convert_to_2d(     x: float, y: float, z: float, scale: float, distance: float ) -> tuple[float, float]:     if not all(isinstance(val, (float, int)) for val in locals().values()):         msg = f\"Input values must either be float or int: {list(locals().values())}\"         raise TypeError(msg)     projected_x = ((x * distance) / (z + distance)) * scale     projected_y = ((y * distance) / (z + distance)) * scale     return projected_x, projected_y", "output": "0"}
{"task": "search", "input": "search code:\nThe method arranges two lists as one list in alternative forms of the list elements.\n\nChoices:\n0: def loops(n):     return repeat(None, n)\n1: def trapezoidal_rule(boundary, steps):     h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 2.0) * f(a)     for i in x_i:         y += h * f(i)     y += (h / 2.0) * f(b)     return y\n2: def alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:     first_input_list_length: int = len(first_input_list)     second_input_list_length: int = len(second_input_list)     abs_length: int = (         first_input_list_length         if first_input_list_length > second_input_list_length         else second_input_list_length     )     output_result_list: list = []     for char_count in range(abs_length):         if char_count < first_input_list_length:             output_result_list.append(first_input_list[char_count])         if char_count < second_input_list_length:             output_result_list.append(second_input_list[char_count])      return output_result_list", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum([15, 2, 11, 7], 13)\n    [1, 2]\n    >>> two_sum([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum([7, 15, 11, 2], 18)\n    [0, 2]\n    >>> two_sum([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum([2, 7, 11, 15], 8)\n    []\n    >>> two_sum([3 * i for i in range(10)], 19)\n    []\n    \"\"\"\n    chk_map: dict[int, int] = {}\n    for index, val in enumerate(nums):\n        compl = target - val\n        if compl in chk_map:\n            return [chk_map[compl], index]\n        chk_map[val] = index\n    return []", "output": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum([15, 2, 11, 7], 13)\n    [1, 2]\n    >>> two_sum([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum([7, 15, 11, 2], 18)\n    [0, 2]\n    >>> two_sum([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum([2, 7, 11, 15], 8)\n    []\n    >>> two_sum([3 * i for i in range(10)], 19)\n    []\n    \"\"\"\n    chk_map: dict[int, int] = {}\n    for index, val in enumerate(nums):\n        compl = target - val\n        if compl in chk_map:\n            return [chk_map[compl], index]\n        chk_map[val] = index\n    return []", "tests": ["assert two_sum([2, 7, 11, 15], 9) == [0, 1]", "assert two_sum([15, 2, 11, 7], 13) == [1, 2]", "assert two_sum([2, 7, 11, 15], 17) == [0, 3]", "assert two_sum([7, 15, 11, 2], 18) == [0, 2]", "assert two_sum([2, 7, 11, 15], 26) == [2, 3]", "assert two_sum([2, 7, 11, 15], 8) == []", "assert two_sum([3 * i for i in range(10)], 19) == []"]}
{"task": "summary", "input": "summarize code:\ndef find_min_recursive(nums: list[int | float], left: int, right: int) -> int | float:\n    if len(nums) == 0:\n        raise ValueError(\"find_min_recursive() arg is an empty sequence\")\n    if (\n        left >= len(nums)\n        or left < -len(nums)\n        or right >= len(nums)\n        or right < -len(nums)\n    ):\n        raise IndexError(\"list index out of range\")\n    if left == right:\n        return nums[left]\n    mid = (left + right) >> 1  # the middle\n    left_min = find_min_recursive(nums, left, mid)  # find min in range[left, mid]\n    right_min = find_min_recursive(\n        nums, mid + 1, right\n    )  # find min in range[mid + 1, right]\n\n    return left_min if left_min <= right_min else right_min", "output": "find min value in list"}
{"task": "detection", "input": "classify code:\ndef calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef vol_spheres_intersect(\n    radius_1: float, radius_2: float, centers_distance: float\n) -> float:\n    if radius_1 < 0 or radius_2 < 0 or centers_distance < 0:\n        raise ValueError(\"vol_spheres_intersect() only accepts non-negative values\")\n    if centers_distance == 0:\n        return vol_sphere(min(radius_1, radius_2))\n\n    h1 = (\n        (radius_1 - radius_2 + centers_distance)\n        * (radius_1 + radius_2 - centers_distance)\n        / (2 * centers_distance)\n    )\n    h2 = (\n        (radius_2 - radius_1 + centers_distance)\n        * (radius_2 + radius_1 - centers_distance)\n        / (2 * centers_distance)\n    )\n\n    return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)", "output": "Calculate the volume of the intersection of two spheres."}
{"task": "repair", "input": "fix bug:\ndef approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value", "output": "def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value", "tests": ["assert approximately_equal_hsv([0, 0, 0], [0, 0, 0]) == True", "assert approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001]) == True", "assert approximately_equal_hsv([0, 0, 0], [1, 0, 0]) == False", "assert approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001]) == False"]}
{"task": "search", "input": "search code:\nReturns the minimal path sum from the top left to the bottom right of the matrix.\n\nChoices:\n0: def solution(filename: str = \"matrix.txt\") -> int:     with open(os.path.join(os.path.dirname(__file__), filename)) as in_file:         data = in_file.read()      grid = [[int(cell) for cell in row.split(\",\")] for row in data.strip().splitlines()]     dp = [[0 for cell in row] for row in grid]     n = len(grid[0])      dp = [[0 for i in range(n)] for j in range(n)]     dp[0][0] = grid[0][0]     for i in range(1, n):         dp[0][i] = grid[0][i] + dp[0][i - 1]     for i in range(1, n):         dp[i][0] = grid[i][0] + dp[i - 1][0]      for i in range(1, n):         for j in range(1, n):             dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])      return dp[-1][-1]\n1: def build_tree() -> TreeNode:     root = TreeNode(1)     root.left = TreeNode(2)     root.right = TreeNode(5)     root.left.left = TreeNode(3)     root.left.right = TreeNode(4)     root.right.right = TreeNode(6)     return root\n2: def is_pentagonal(n: int) -> bool:     root = (1 + 24 * n) ** 0.5     return ((1 + root) / 6) % 1 == 0", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef encrypt(plaintext: str, key: str) -> str:\n    if not isinstance(plaintext, str):\n        raise TypeError(\"plaintext must be a string\")\n    if not isinstance(key, str):\n        raise TypeError(\"key must be a string\")\n\n    if not plaintext:\n        raise ValueError(\"plaintext is empty\")\n    if not key:\n        raise ValueError(\"key is empty\")\n\n    key += plaintext\n    plaintext = plaintext.lower()\n    key = key.lower()\n    plaintext_iterator = 0\n    key_iterator = 0\n    ciphertext = \"\"\n    while plaintext_iterator < len(plaintext):\n        if (\n            ord(plaintext[plaintext_iterator]) < 97\n            or ord(plaintext[plaintext_iterator]) > 122\n        ):\n            ciphertext += plaintext[plaintext_iterator]\n            plaintext_iterator += 1\n        elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:\n            key_iterator += 1\n        else:\n            ciphertext += chr(\n                (\n                    (ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))\n                    - 97\n                )\n                % 26\n                + 97\n            )\n            key_iterator += 1\n            plaintext_iterator += 1\n    return ciphertext", "output": "Encrypt a given `plaintext` (string) and `key` (string), returning the"}
{"task": "search", "input": "search code:\nCalculate Euler's Phi Function.\n\nChoices:\n0: def right_rotation(node: MyNode) -> MyNode:     print(\"left rotation node:\", node.get_data())     ret = node.get_left()     assert ret is not None     node.set_left(ret.get_right())     ret.set_right(node)     h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1     node.set_height(h1)     h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1     ret.set_height(h2)     return ret\n1: def euler_phi(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = n     for x in set(prime_factors(n)):         s *= (x - 1) / x     return int(s)\n2: def solution(n: int = 1000000) -> int:     largest_number = 1     pre_counter = 1     counters = {1: 1}      for input1 in range(2, n):         counter = 0         number = input1          while True:             if number in counters:                 counter += counters[number]                 break             if number % 2 == 0:                 number //= 2                 counter += 1             else:                 number = (3 * number) + 1                 counter += 1          if input1 not in counters:             counters[input1] = counter          if counter > pre_counter:             largest_number = input1             pre_counter = counter     return largest_number", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2", "output": "def find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2", "tests": ["assert find_median(nums=([1, 2, 2, 3, 4])) == 2", "assert find_median(nums=([1, 2, 2, 3, 4, 4])) == 2.5", "assert find_median(nums=([-1, 2, 0, 3, 4, -4])) == 1.5", "assert find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4])) == 2.65"]}
{"task": "detection", "input": "classify code:\ndef gnome_sort(lst: list) -> list:\n    \"\"\"\n    Pure implementation of the gnome sort algorithm in Python\n\n    Take some mutable ordered collection with heterogeneous comparable items inside as\n    arguments, return the same collection ordered by ascending.\n\n    Examples:\n    >>> gnome_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> gnome_sort([])\n    []\n\n    >>> gnome_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    >>> \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\"))))\n    ' !Gadeimnoprstu'\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n\n    i = 1\n\n    while i < len(lst):\n        if lst[i - 1] <= lst[i]:\n            i += 1\n        else:\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1\n\n    return lst", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "tests": ["assert is_complete([[1]]) == True", "assert is_complete([[1, 2], [3, 0]]) == False"]}
{"task": "search", "input": "search code:\nImplements the Damerau-Levenshtein distance algorithm that measures\n\nChoices:\n0: def dp_match(text: str, pattern: str) -> bool:     m = len(text)     n = len(pattern)     dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]     dp[0][0] = True      for j in range(1, n + 1):         dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]      for i in range(1, m + 1):         for j in range(1, n + 1):             if pattern[j - 1] in {\".\", text[i - 1]}:                 dp[i][j] = dp[i - 1][j - 1]             elif pattern[j - 1] == \"*\":                 dp[i][j] = dp[i][j - 2]                 if pattern[j - 2] in {\".\", text[i - 1]}:                     dp[i][j] |= dp[i - 1][j]             else:                 dp[i][j] = False      return dp[m][n]\n1: def damerau_levenshtein_distance(first_string: str, second_string: str) -> int:     # Create a dynamic programming matrix to store the distances     dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]      # Initialize the matrix     for i in range(len(first_string) + 1):         dp_matrix[i][0] = i     for j in range(len(second_string) + 1):         dp_matrix[0][j] = j      # Fill the matrix     for i, first_char in enumerate(first_string, start=1):         for j, second_char in enumerate(second_string, start=1):             cost = int(first_char != second_char)              dp_matrix[i][j] = min(                 dp_matrix[i - 1][j] + 1,  # Deletion                 dp_matrix[i][j - 1] + 1,  # Insertion                 dp_matrix[i - 1][j - 1] + cost,  # Substitution             )              if (                 i > 1                 and j > 1                 and first_string[i - 1] == second_string[j - 2]                 and first_string[i - 2] == second_string[j - 1]             ):                 # Transposition                 dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)      return dp_matrix[-1][-1]\n2: def emitter_converter(size_par, data):     if size_par + len(data) <= 2**size_par - (len(data) - 1):         raise ValueError(\"size of parity don't match with size of data\")      data_out = []     parity = []     bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]      # sorted information data for the size of the output data     data_ord = []     # data position template + parity     data_out_gab = []     # parity bit counter     qtd_bp = 0     # counter position of data bits     cont_data = 0      for x in range(1, size_par + len(data) + 1):         # Performs a template of bit positions - who should be given,         # and who should be parity         if qtd_bp < size_par:             if (np.log(x) / np.log(2)).is_integer():                 data_out_gab.append(\"P\")                 qtd_bp = qtd_bp + 1             else:                 data_out_gab.append(\"D\")         else:             data_out_gab.append(\"D\")          # Sorts the data to the new output size         if data_out_gab[-1] == \"D\":             data_ord.append(data[cont_data])             cont_data += 1         else:             data_ord.append(None)      # Calculates parity     qtd_bp = 0  # parity bit counter     for bp in range(1, size_par + 1):         # Bit counter one for a given parity         cont_bo = 0         # counter to control the loop reading         for cont_loop, x in enumerate(data_ord):             if x is not None:                 try:                     aux = (bin_pos[cont_loop])[-1 * (bp)]                 except IndexError:                     aux = \"0\"                 if aux == \"1\" and x == \"1\":                     cont_bo += 1         parity.append(cont_bo % 2)          qtd_bp += 1      # Mount the message     cont_bp = 0  # parity bit counter     for x in range(size_par + len(data)):         if data_ord[x] is None:             data_out.append(str(parity[cont_bp]))             cont_bp += 1         else:             data_out.append(data_ord[x])      return data_out", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef parse_roman_numerals(numerals: str) -> int:\n\n    total_value = 0\n\n    index = 0\n    while index < len(numerals) - 1:\n        current_value = SYMBOLS[numerals[index]]\n        next_value = SYMBOLS[numerals[index + 1]]\n        if current_value < next_value:\n            total_value -= current_value\n        else:\n            total_value += current_value\n        index += 1\n    total_value += SYMBOLS[numerals[index]]\n\n    return total_value", "output": "Converts a string of roman numerals to an integer."}
{"task": "detection", "input": "classify code:\ndef get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))", "output": "BUGGY"}
{"task": "search", "input": "search code:\npostOrder (left, right, self)\n\nChoices:\n0: def interquartile_range(nums: list[int | float]) -> float:     if not nums:         raise ValueError(\"The list is empty. Provide a non-empty list.\")     nums.sort()     length = len(nums)     div, mod = divmod(length, 2)     q1 = find_median(nums[:div])     half_length = sum((div, mod))     q3 = find_median(nums[half_length:length])     return q3 - q1\n1: def _norm_args_notimplemented(other):     if type(other) in (set, frozenset):         inc, exc = other, None     elif type(other) is _ComplementSet:         inc, exc = other._included, other._excluded     else:         return NotImplemented, None     return inc, exc\n2: def postorder(curr_node: Node | None) -> list[Node]:     node_list = []     if curr_node is not None:         node_list = postorder(curr_node.left) + postorder(curr_node.right) + [curr_node]     return node_list", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef relu(vector: list[float]):\n\n    # compare two arrays and then return element-wise maxima.\n    return np.maximum(0, vector)", "output": "Implements the relu function"}
{"task": "detection", "input": "classify code:\ndef merge_insertion_sort(collection: List[int]) -> List[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [5, 7]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = array[i:]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "tests": ["assert longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == [10, 22, 33, 41, 60, 80]", "assert longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9]) == [1, 2, 3, 9]", "assert longest_subsequence([28, 26, 12, 23, 35, 39]) == [12, 23, 35, 39]", "assert longest_subsequence([9, 8, 7, 6, 5, 7]) == [5, 7]", "assert longest_subsequence([1, 1, 1]) == [1, 1, 1]", "assert longest_subsequence([]) == []"]}
{"task": "summary", "input": "summarize code:\ndef sigmoid_function(value: float, deriv: bool = False) -> float:\n    if deriv:\n        return value * (1 - value)\n    return 1 / (1 + math.exp(-value))", "output": "Return the sigmoid function of a float."}
{"task": "detection", "input": "classify code:\ndef rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr", "output": "def odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr", "tests": ["assert odd_even_transposition([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]", "assert odd_even_transposition([13, 11, 18, 0, -1]) == [-1, 0, 11, 13, 18]", "assert odd_even_transposition([-.1, 1.1, .1, -2.9]) == [-2.9, -0.1, 0.1, 1.1]"]}
{"task": "search", "input": "search code:\nAdds new strings (curr_string + \"0\", curr_string + \"1\") to the lexicon\n\nChoices:\n0: def mutate(child: str, genes: list[str]) -> str:     child_list = list(child)     if random.uniform(0, 1) < MUTATION_PROBABILITY:         child_list[random.randint(0, len(child)) - 1] = random.choice(genes)     return \"\".join(child_list)\n1: def next_point(     point_x: float, point_y: float, incoming_gradient: float ) -> tuple[float, float, float]:     # normal_gradient = gradient of line through which the beam is reflected     # outgoing_gradient = gradient of reflected line     normal_gradient = point_y / 4 / point_x     s2 = 2 * normal_gradient / (1 + normal_gradient * normal_gradient)     c2 = (1 - normal_gradient * normal_gradient) / (         1 + normal_gradient * normal_gradient     )     outgoing_gradient = (s2 - c2 * incoming_gradient) / (c2 + s2 * incoming_gradient)      # to find the next point, solve the simultaeneous equations:     # y^2 + 4x^2 = 100     # y - b = m * (x - a)     # ==> A x^2 + B x + C = 0     quadratic_term = outgoing_gradient**2 + 4     linear_term = 2 * outgoing_gradient * (point_y - outgoing_gradient * point_x)     constant_term = (point_y - outgoing_gradient * point_x) ** 2 - 100      x_minus = (         -linear_term - sqrt(linear_term**2 - 4 * quadratic_term * constant_term)     ) / (2 * quadratic_term)     x_plus = (         -linear_term + sqrt(linear_term**2 - 4 * quadratic_term * constant_term)     ) / (2 * quadratic_term)      # two solutions, one of which is our input point     next_x = x_minus if isclose(x_plus, point_x) else x_plus     next_y = point_y + outgoing_gradient * (next_x - point_x)      return next_x, next_y, outgoing_gradient\n2: def add_key_to_lexicon(     lexicon: dict[str, str], curr_string: str, index: int, last_match_id: str ) -> None:     lexicon.pop(curr_string)     lexicon[curr_string + \"0\"] = last_match_id      if math.log2(index).is_integer():         for curr_key, value in lexicon.items():             lexicon[curr_key] = f\"0{value}\"      lexicon[curr_string + \"1\"] = bin(index)[2:]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef n_input_and_gate(inputs: list[int]) -> int:\n    return int(all(inputs))", "output": "Calculate AND of a list of input values"}
{"task": "search", "input": "search code:\nTake in 1 integer, return a number that is\n\nChoices:\n0: def arithmetic_right_shift(number: int, shift_amount: int) -> str:     if number >= 0:  # Get binary representation of positive number         binary_number = \"0\" + str(bin(number)).strip(\"-\")[2:]     else:  # Get binary (2's complement) representation of negative number         binary_number_length = len(bin(number)[3:])  # Find 2's complement of number         binary_number = bin(abs(number) - (1 << binary_number_length))[3:]         binary_number = (             \"1\" + \"0\" * (binary_number_length - len(binary_number)) + binary_number         )      if shift_amount >= len(binary_number):         return \"0b\" + binary_number[0] * len(binary_number)     return (         \"0b\"         + binary_number[0] * shift_amount         + binary_number[: len(binary_number) - shift_amount]     )\n1: def is_palindrome(n: int) -> bool:     return str(n) == str(n)[::-1]\n2: def binary_count_setbits(a: int) -> int:     if a < 0:         raise ValueError(\"Input value must be a positive integer\")     elif isinstance(a, float):         raise TypeError(\"Input value must be a 'int' type\")     return bin(a).count(\"1\")", "output": "2"}
{"task": "detection", "input": "classify code:\ndef calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "tests": ["assert extended_euclid(10, 6) == (-1, 2)", "assert extended_euclid(7, 5) == (-2, 3)"]}
{"task": "search", "input": "search code:\nCalculate sum of |_ P_m _| for m from 2 to n.\n\nChoices:\n0: def interpolation_search(sorted_collection: list[int], item: int) -> int | None:     left = 0     right = len(sorted_collection) - 1      while left <= right:         # avoid divided by 0 during interpolation         if sorted_collection[left] == sorted_collection[right]:             if sorted_collection[left] == item:                 return left             return None          point = left + ((item - sorted_collection[left]) * (right - left)) // (             sorted_collection[right] - sorted_collection[left]         )          # out of range check         if point < 0 or point >= len(sorted_collection):             return None          current_item = sorted_collection[point]         if current_item == item:             return point         if point < left:             right = left             left = point         elif point > right:             left = right             right = point         elif item < current_item:             right = point - 1         else:             left = point + 1     return None\n1: def solution(n: int = 15) -> int:     total = 0     for m in range(2, n + 1):         x1 = 2 / (m + 1)         p = 1.0         for i in range(1, m + 1):             xi = i * x1             p *= xi**i         total += int(p)     return total\n2: def save_image(image_url: str, image_title: str) -> None:     image = httpx.get(image_url, headers=headers, timeout=10)     with open(image_title, \"wb\") as file:         file.write(image.content)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef median(items: list):\n    mid, rem = divmod(len(items), 2)\n    if rem != 0:\n        return quick_select(items=items, index=mid)\n    else:\n        low_mid = quick_select(items=items, index=mid - 1)\n        high_mid = quick_select(items=items, index=mid)\n        return (low_mid + high_mid) / 2", "output": "One common application of Quickselect is finding the median, which is"}
{"task": "detection", "input": "classify code:\ndef get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in xrange(m)] for _ in xrange(m + 1)]\n    for i in xrange(m + 1):\n        memo[i][0] = 1\n\n    for n in xrange(m + 1):\n        for k in xrange(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1", "output": "def partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1", "tests": ["assert partition(100) == 190569291", "assert partition(50) == 204225", "assert partition(30) == 5603", "assert partition(10) == 41", "assert partition(5) == 6", "assert partition(3) == 2", "assert partition(2) == 1", "assert partition(1) == 0"]}
{"task": "repair", "input": "fix bug:\ndef format_ruleset(ruleset: int) -> List[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]", "output": "def format_ruleset(ruleset: int) -> list[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]", "tests": ["assert format_ruleset(11100) == [0, 0, 0, 1, 1, 1, 0, 0]", "assert format_ruleset(0) == [0, 0, 0, 0, 0, 0, 0, 0]", "assert format_ruleset(11111111) == [1, 1, 1, 1, 1, 1, 1, 1]"]}
{"task": "summary", "input": "summarize code:\ndef largest_divisible_subset(items: list[int]) -> list[int]:\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result", "output": "Algorithm to find the biggest subset in the given array such that for any 2 elements"}
{"task": "detection", "input": "classify code:\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the number of numbers below number_limit that produce chains with exactly\n\nChoices:\n0: def radix_sort(list_of_ints: list[int]) -> list[int]:     placement = 1     max_digit = max(list_of_ints)     while placement <= max_digit:         # declare and initialize empty buckets         buckets: list[list] = [[] for _ in range(RADIX)]         # split list_of_ints between the buckets         for i in list_of_ints:             tmp = int((i / placement) % RADIX)             buckets[tmp].append(i)         # put each buckets' contents into list_of_ints         a = 0         for b in range(RADIX):             for i in buckets[b]:                 list_of_ints[a] = i                 a += 1         # move to next         placement *= RADIX     return list_of_ints\n1: def mobius(n: int) -> int:     factors = prime_factors(n)     if is_square_free(factors):         return -1 if len(factors) % 2 else 1     return 0\n2: def solution(chain_length: int = 60, number_limit: int = 1000000) -> int:      if not isinstance(chain_length, int) or not isinstance(number_limit, int):         raise TypeError(\"Parameters chain_length and number_limit must be int\")      if chain_length <= 0 or number_limit <= 0:         raise ValueError(             \"Parameters chain_length and number_limit must be greater than 0\"         )      # the counter for the chains with the exact desired length     chains_counter = 0     # the cached sizes of the previous chains     chain_sets_lengths: dict[int, int] = {}      for start_chain_element in range(1, number_limit):         # The temporary set will contain the elements of the chain         chain_set = set()         chain_set_length = 0          # Stop computing the chain when you find a cached size, a repeating item or the         # length is greater then the desired one.         chain_element = start_chain_element         while (             chain_element not in chain_sets_lengths             and chain_element not in chain_set             and chain_set_length <= chain_length         ):             chain_set.add(chain_element)             chain_set_length += 1             chain_element = digit_factorial_sum(chain_element)          if chain_element in chain_sets_lengths:             chain_set_length += chain_sets_lengths[chain_element]          chain_sets_lengths[start_chain_element] = chain_set_length          # If chain contains the exact amount of elements increase the counter         if chain_set_length == chain_length:             chains_counter += 1      return chains_counter", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:\n    for triplet in permutations(arr, 3):\n        if sum(triplet) == target:\n            return tuple(sorted(triplet))\n    return (0, 0, 0)", "output": "Returns a triplet in the array with sum equal to target,"}
{"task": "search", "input": "search code:\nThis function finds an empty location so that we can assign a number\n\nChoices:\n0: def compute_transform_tables(     source_string: str,     destination_string: str,     copy_cost: int,     replace_cost: int,     delete_cost: int,     insert_cost: int, ) -> tuple[list[list[int]], list[list[str]]]:     source_seq = list(source_string)     destination_seq = list(destination_string)     len_source_seq = len(source_seq)     len_destination_seq = len(destination_seq)     costs = [         [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]     ops = [         [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]      for i in range(1, len_source_seq + 1):         costs[i][0] = i * delete_cost         ops[i][0] = f\"D{source_seq[i - 1]}\"      for i in range(1, len_destination_seq + 1):         costs[0][i] = i * insert_cost         ops[0][i] = f\"I{destination_seq[i - 1]}\"      for i in range(1, len_source_seq + 1):         for j in range(1, len_destination_seq + 1):             if source_seq[i - 1] == destination_seq[j - 1]:                 costs[i][j] = costs[i - 1][j - 1] + copy_cost                 ops[i][j] = f\"C{source_seq[i - 1]}\"             else:                 costs[i][j] = costs[i - 1][j - 1] + replace_cost                 ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])              if costs[i - 1][j] + delete_cost < costs[i][j]:                 costs[i][j] = costs[i - 1][j] + delete_cost                 ops[i][j] = f\"D{source_seq[i - 1]}\"              if costs[i][j - 1] + insert_cost < costs[i][j]:                 costs[i][j] = costs[i][j - 1] + insert_cost                 ops[i][j] = f\"I{destination_seq[j - 1]}\"      return costs, ops\n1: def while_solution(max_number: int = 10**8) -> int:      prime_numbers = calculate_prime_numbers(max_number // 2)      semiprimes_count = 0     left = 0     right = len(prime_numbers) - 1     while left <= right:         while prime_numbers[left] * prime_numbers[right] >= max_number:             right -= 1         semiprimes_count += right - left + 1         left += 1      return semiprimes_count\n2: def find_empty_location(grid: Matrix) -> tuple[int, int] | None:     for i in range(9):         for j in range(9):             if grid[i][j] == 0:                 return i, j     return None", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef equilibrium_index(arr: list[int], size: int) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr : The input array of integers.\n        size : The size of the array.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0], 7)\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5], 5)\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1], 5)\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3], 6)\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i in range(size):\n        total_sum -= arr[i]\n        if left_sum == total_sum:\n            return i\n        left_sum += arr[i]\n\n    return -1", "output": "def equilibrium_index(arr: list[int]) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5])\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1])\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3])\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i, value in enumerate(arr):\n        total_sum -= value\n        if left_sum == total_sum:\n            return i\n        left_sum += value\n\n    return -1", "tests": ["assert equilibrium_index([-7, 1, 5, 2, -4, 3, 0]) == 3", "assert equilibrium_index([1, 2, 3, 4, 5]) == -1", "assert equilibrium_index([1, 1, 1, 1, 1]) == 2", "assert equilibrium_index([2, 4, 6, 8, 10, 3]) == -1"]}
{"task": "detection", "input": "classify code:\ndef p_series(nth_term: int, power: int) -> list:\n    \"\"\"Pure Python implementation of P-Series algorithm\n\n    :return: The P-Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> p_series(5, 2)\n    [1, '1/4', '1/9', '1/16', '1/25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    [1, '1/0.25', '1/0.1111111111111111', '1/0.0625', '1/0.04']\n    >>> p_series(\"\", 1000)\n    ''\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    [1]\n    \"\"\"\n    if nth_term == \"\":\n        return nth_term\n    nth_term = int(nth_term)\n    power = int(power)\n    series = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1/{pow(temp + 1, int(power))}\" if series else 1)\n    return series", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef show_results(\n    function_label: str,\n    function_params: Any,\n    escape_radius: float,\n    z_final: np.ndarray,\n) -> None:\n\n    abs_z_final = (abs(z_final)).transpose()\n    abs_z_final[:, :] = abs_z_final[::-1, :]\n    plt.matshow(abs_z_final < escape_radius)\n    plt.title(f\"Julia set of ${function_label}$, $c={function_params}$\")\n    plt.show()", "output": "Plots of whether the absolute value of z_final is greater than"}
{"task": "repair", "input": "fix bug:\ndef get_totients(max_one: int) -> List[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients", "output": "def get_totients(max_one: int) -> list[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients", "tests": ["assert get_totients(5) == [0, 1, 1, 2, 2]", "assert get_totients(10) == [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]"]}
{"task": "search", "input": "search code:\nThis function can calculate any one of the three (voltage, current, power),\n\nChoices:\n0: def electric_power(voltage: float, current: float, power: float) -> tuple:     if (voltage, current, power).count(0) != 1:         raise ValueError(\"Exactly one argument must be 0\")     elif power < 0:         raise ValueError(             \"Power cannot be negative in any electrical/electronics system\"         )     elif voltage == 0:         return Result(\"voltage\", power / current)     elif current == 0:         return Result(\"current\", power / voltage)     elif power == 0:         return Result(\"power\", float(round(abs(voltage * current), 2)))     else:         raise AssertionError\n1: def main() -> None:     lower = int(input(\"Enter lower value : \").strip())     higher = int(input(\"Enter high value : \").strip())     guess = int(input(\"Enter value to guess : \").strip())     guess_the_number(lower, higher, guess)\n2: def open_knight_tour(n: int) -> list[list[int]]:      board = [[0 for i in range(n)] for j in range(n)]      for i in range(n):         for j in range(n):             board[i][j] = 1             if open_knight_tour_helper(board, (i, j), 1):                 return board             board[i][j] = 0      msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"     raise ValueError(msg)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef n31(a: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)", "output": "def n31(a: int) -> tuple[list[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)", "tests": ["assert n31(4) == ([4, 2, 1], 3)"]}
{"task": "detection", "input": "classify code:\ndef is_palindrome(n: int | str) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef depth_first_search(graph: dict, start: str) -> set[str]:\n    explored, stack = set(start), [start]\n\n    while stack:\n        v = stack.pop()\n        explored.add(v)\n        # Differences from BFS:\n        # 1) pop last element instead of first one\n        # 2) add adjacent elements to stack without exploring them\n        for adj in reversed(graph[v]):\n            if adj not in explored:\n                stack.append(adj)\n    return explored", "output": "Depth First Search on Graph"}
{"task": "search", "input": "search code:\nZigZag traverse:\n\nChoices:\n0: def _gettext(message):     return get_translation().gettext(message)\n1: def _running_median_windowed(iterator, maxlen):     \"Yield median of values in a sliding window.\"      window = deque()     ordered = []      for x in iterator:         window.append(x)         insort(ordered, x)          if len(ordered) > maxlen:             i = bisect_left(ordered, window.popleft())             del ordered[i]          n = len(ordered)         m = n // 2         yield ordered[m] if n & 1 else (ordered[m - 1] + ordered[m]) / 2\n2: def zigzag(root: Node | None) -> Generator[int]:     if root is None:         return      flag = 0     height_tree = height(root)      for h in range(1, height_tree + 1):         if not flag:             yield from get_nodes_from_left_to_right(root, h)             flag = 1         else:             yield from get_nodes_from_right_to_left(root, h)             flag = 0", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 2) -> int:\n    result = 1.0\n    for fraction in fraction_list(n):\n        frac = Fraction(fraction)\n        result *= frac.denominator / frac.numerator\n    return int(result)", "output": "Return the solution to the problem"}
{"task": "search", "input": "search code:\nReturns the n-th prime number.\n\nChoices:\n0: def merge(arr: list[int]) -> list[int]:     if len(arr) > 1:         middle_length = len(arr) // 2  # Finds the middle of the array         left_array = arr[             :middle_length         ]  # Creates an array of the elements in the first half.         right_array = arr[             middle_length:         ]  # Creates an array of the elements in the second half.         left_size = len(left_array)         right_size = len(right_array)         merge(left_array)  # Starts sorting the left.         merge(right_array)  # Starts sorting the right         left_index = 0  # Left Counter         right_index = 0  # Right Counter         index = 0  # Position Counter         while (             left_index < left_size and right_index < right_size         ):  # Runs until the lowers size of the left and right are sorted.             if left_array[left_index] < right_array[right_index]:                 arr[index] = left_array[left_index]                 left_index += 1             else:                 arr[index] = right_array[right_index]                 right_index += 1             index += 1         while (             left_index < left_size         ):  # Adds the left over elements in the left half of the array             arr[index] = left_array[left_index]             left_index += 1             index += 1         while (             right_index < right_size         ):  # Adds the left over elements in the right half of the array             arr[index] = right_array[right_index]             right_index += 1             index += 1     return arr\n1: def create_vector(end_point1: Point3d, end_point2: Point3d) -> Vector3d:     x = end_point2[0] - end_point1[0]     y = end_point2[1] - end_point1[1]     z = end_point2[2] - end_point1[2]     return (x, y, z)\n2: def solution(nth: int = 10001) -> int:     return next(itertools.islice(prime_generator(), nth - 1, nth))", "output": "2"}
{"task": "detection", "input": "classify code:\ndef levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef double_linear_search(array: List[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r", "output": "def double_linear_search(array: list[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r", "tests": ["assert double_linear_search([1, 5, 5, 10], 1) == 0", "assert double_linear_search([1, 5, 5, 10], 5) == 1", "assert double_linear_search([1, 5, 5, 10], 100) == -1", "assert double_linear_search([1, 5, 5, 10], 10) == 3"]}
{"task": "repair", "input": "fix bug:\ndef harmonic_series(n_term: str) -> list:\n    \"\"\"Pure Python implementation of Harmonic Series algorithm\n\n    :param n_term: The last (nth) term of Harmonic Series\n    :return: The Harmonic Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> harmonic_series(5)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.0)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.1)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(-5)\n    []\n    >>> harmonic_series(0)\n    []\n    >>> harmonic_series(1)\n    ['1']\n    \"\"\"\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series", "output": "def harmonic_series(n_term: str) -> list:\n    \"\"\"Pure Python implementation of Harmonic Series algorithm\n\n    :param n_term: The last (nth) term of Harmonic Series\n    :return: The Harmonic Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> harmonic_series(5)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.0)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.1)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(-5)\n    []\n    >>> harmonic_series(0)\n    []\n    >>> harmonic_series(1)\n    ['1']\n    \"\"\"\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series", "tests": ["assert harmonic_series(5) == ['1', '1/2', '1/3', '1/4', '1/5']", "assert harmonic_series(5.0) == ['1', '1/2', '1/3', '1/4', '1/5']", "assert harmonic_series(5.1) == ['1', '1/2', '1/3', '1/4', '1/5']", "assert harmonic_series(-5) == []", "assert harmonic_series(0) == []", "assert harmonic_series(1) == ['1']"]}
{"task": "summary", "input": "summarize code:\ndef permute_recursive(nums: list[int]) -> list[list[int]]:\n    result: list[list[int]] = []\n    if len(nums) == 0:\n        return [[]]\n    for _ in range(len(nums)):\n        n = nums.pop(0)\n        permutations = permute_recursive(nums.copy())\n        for perm in permutations:\n            perm.append(n)\n        result.extend(permutations)\n        nums.append(n)\n    return result", "output": "Return all permutations."}
{"task": "detection", "input": "classify code:\ndef binary_multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply 'a' and 'b' using bitwise multiplication.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: a * b\n\n    Examples:\n    >>> binary_multiply(2, 3)\n    6\n    >>> binary_multiply(5, 0)\n    0\n    >>> binary_multiply(3, 4)\n    12\n    >>> binary_multiply(10, 5)\n    50\n    >>> binary_multiply(0, 5)\n    0\n    >>> binary_multiply(2, 1)\n    2\n    >>> binary_multiply(1, 10)\n    10\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn the direction toward to the line from via to target from starting\n\nChoices:\n0: def solution(n: int = 2) -> int:     result = 1.0     for fraction in fraction_list(n):         frac = Fraction(fraction)         result *= frac.denominator / frac.numerator     return int(result)\n1: def dotproduct(vec1, vec2):     return sum(map(mul, vec1, vec2))\n2: def check_direction(     starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int] ) -> Direction:     x0, y0 = starting     x1, y1 = via     x2, y2 = target     via_angle = degrees(atan2(y1 - y0, x1 - x0))     via_angle %= 360     target_angle = degrees(atan2(y2 - y0, x2 - x0))     target_angle %= 360     # t-     #  \\ \\     #   \\ v     #    \\|     #     s     # via_angle is always lower than target_angle, if direction is left.     # If they are same, it means they are on a same line of convex hull.     if target_angle > via_angle:         return Direction.left     elif target_angle == via_angle:         return Direction.straight     else:         return Direction.right", "output": "2"}
{"task": "detection", "input": "classify code:\ndef merge_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Time Complexity: O(n log n)\n    Space Complexity: O(n)\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def merge(left: list, right: list) -> list:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n\n        :param left: Left collection\n        :param right: Right collection\n        :return: Merged result\n        \"\"\"\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))", "output": "CORRECT"}
{"task": "search", "input": "search code:\nYield the elements from *iterable*, followed by *fillvalue*, such that\n\nChoices:\n0: def largest_rectangle_area(heights: list[int]) -> int:     stack: list[int] = []     max_area = 0     heights = [*heights, 0]  # make a new list by appending the sentinel 0     n = len(heights)      for i in range(n):         # make sure the stack remains in increasing order         while stack and heights[i] < heights[stack[-1]]:             h = heights[stack.pop()]  # height of the bar             # if stack is empty, it means entire width can be taken from index 0 to i-1             w = i if not stack else i - stack[-1] - 1  # calculate width             max_area = max(max_area, h * w)          stack.append(i)      return max_area\n1: def fibonacci_generator() -> Generator[int]:     a, b = 0, 1     while True:         a, b = b, a + b         yield b\n2: def padded(iterable, fillvalue=None, n=None, next_multiple=False):     iterator = iter(iterable)     iterator_with_repeat = chain(iterator, repeat(fillvalue))      if n is None:         return iterator_with_repeat     elif n < 1:         raise ValueError('n must be at least 1')     elif next_multiple:          def slice_generator():             for first in iterator:                 yield (first,)                 yield islice(iterator_with_repeat, n - 1)          # While elements exist produce slices of size n         return chain.from_iterable(slice_generator())     else:         # Ensure the first batch is at least size n then iterate         return chain(islice(iterator_with_repeat, n), iterator)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]", "output": "def levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]", "tests": ["assert levenshtein_distance_optimized(\"planet\", \"planetary\") == 3", "assert levenshtein_distance_optimized(\"\", \"test\") == 4", "assert levenshtein_distance_optimized(\"book\", \"back\") == 2", "assert levenshtein_distance_optimized(\"book\", \"book\") == 0", "assert levenshtein_distance_optimized(\"test\", \"\") == 4", "assert levenshtein_distance_optimized(\"\", \"\") == 0", "assert levenshtein_distance_optimized(\"orchestration\", \"container\") == 10"]}
{"task": "summary", "input": "summarize code:\ndef recursive_lucas_number(n_th_number: int) -> int:\n    if not isinstance(n_th_number, int):\n        raise TypeError(\"recursive_lucas_number accepts only integer arguments.\")\n    if n_th_number == 0:\n        return 2\n    if n_th_number == 1:\n        return 1\n\n    return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(\n        n_th_number - 2\n    )", "output": "Returns the nth lucas number"}
{"task": "detection", "input": "classify code:\ndef base16_encode(data: bytes) -> str:\n    \"\"\"\n    Encodes the given bytes into base16.\n\n    >>> base16_encode(b'Hello World!')\n    '48656C6C6F20576F726C6421'\n    >>> base16_encode(b'HELLO WORLD!')\n    '48454C4C4F20574F524C4421'\n    >>> base16_encode(b'')\n    ''\n    \"\"\"\n    # Turn the data into a list of integers (where each integer is a byte),\n    # Then turn each byte into its hexadecimal representation, make sure\n    # it is uppercase, and then join everything together and return it.\n    return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "tests": ["assert get_valid_pos((1, 3), 4) == [(2, 1), (0, 1), (3, 2)]"]}
{"task": "search", "input": "search code:\nGet a list of URLs of GIFs based on a given query..\n\nChoices:\n0: def _dense_to_one_hot(labels_dense, num_classes):     num_labels = labels_dense.shape[0]     index_offset = np.arange(num_labels) * num_classes     labels_one_hot = np.zeros((num_labels, num_classes))     labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1     return labels_one_hot\n1: def create_state_space_tree(     sequence: list[int | str],     current_sequence: list[int | str],     index: int,     index_used: list[int], ) -> None:      if index == len(sequence):         print(current_sequence)         return      for i in range(len(sequence)):         if not index_used[i]:             current_sequence.append(sequence[i])             index_used[i] = True             create_state_space_tree(sequence, current_sequence, index + 1, index_used)             current_sequence.pop()             index_used[i] = False\n2: def get_gifs(query: str, api_key: str = giphy_api_key) -> list:     formatted_query = \"+\".join(query.split())     url = f\"https://api.giphy.com/v1/gifs/search?q={formatted_query}&api_key={api_key}\"     gifs = httpx.get(url, timeout=10).json()[\"data\"]     return [gif[\"url\"] for gif in gifs]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]", "output": "Function updates the largest_square_area[0], if recursive call found"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    f1, f2 = 1, 1\n    index = 2\n    while True:\n        i = 0\n        f = f1 + f2\n        f1, f2 = f2, f\n        index += 1\n        for _ in str(f):\n            i += 1\n        if i == n:\n            break\n    return index", "output": "Returns the index of the first term in the Fibonacci sequence to contain"}
{"task": "repair", "input": "fix bug:\ndef decimal_to_binary(no_of_variable: int, minterms: List[float]) -> List[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp", "output": "def decimal_to_binary(no_of_variable: int, minterms: list[float]) -> list[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp", "tests": ["assert decimal_to_binary(3,[1.5]) == ['0.00.01.5']"]}
{"task": "detection", "input": "classify code:\ndef speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20°C: bulk_modulus= 2.15MPa, density=998kg/m³\n    Example 2 --> Mercury 20°C: bulk_modulus= 28.5MPa, density=13600kg/m³\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPrints the elements of the given Linked List in reverse order\n\nChoices:\n0: def can_string_be_rearranged_as_palindrome(input_str: str = \"\") -> bool:     if len(input_str) == 0:         return True     lower_case_input_str = input_str.replace(\" \", \"\").lower()     # character_freq_dict: Stores the frequency of every character in the input string     character_freq_dict: dict[str, int] = {}      for character in lower_case_input_str:         character_freq_dict[character] = character_freq_dict.get(character, 0) + 1     odd_char = 0      for character_count in character_freq_dict.values():         if character_count % 2:             odd_char += 1     return not odd_char > 1\n1: def example() -> int:     # Input values.     test_input = np.array(         (             [0, 0, 0],             [0, 0, 1],             [0, 1, 0],             [0, 1, 1],             [1, 0, 0],             [1, 0, 1],             [1, 1, 0],             [1, 1, 1],         ),         dtype=np.float64,     )      # True output values for the given input values.     output = np.array(([0], [1], [1], [0], [1], [0], [0], [1]), dtype=np.float64)      # Calling neural network class.     neural_network = TwoHiddenLayerNeuralNetwork(         input_array=test_input, output_array=output     )      # Calling training function.     # Set give_loss to True if you want to see loss in every iteration.     neural_network.train(output=output, iterations=10, give_loss=False)      return neural_network.predict(np.array(([1, 1, 1]), dtype=np.float64))\n2: def in_reverse(linked_list: LinkedList) -> str:     return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))", "output": "2"}
{"task": "search", "input": "search code:\nCalculate OR of the input values\n\nChoices:\n0: def sum_of_digits(n: int) -> int:     n = abs(n)     res = 0     while n > 0:         res += n % 10         n //= 10     return res\n1: def sumset(set_a: set, set_b: set) -> set:     assert isinstance(set_a, set), f\"The input value of [set_a={set_a}] is not a set\"     assert isinstance(set_b, set), f\"The input value of [set_b={set_b}] is not a set\"      return {a + b for a in set_a for b in set_b}\n2: def or_gate(input_1: int, input_2: int) -> int:     return int((input_1, input_2).count(1) != 0)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef chunked(src, size, count=None, **kw):\n    chunk_iter = chunked_iter(src, size, **kw)\n    if count is None:\n        return list(chunk_iter)\n    else:\n        return list(itertools.islice(chunk_iter, count))", "output": "Returns a list of *count* chunks, each with *size* elements,"}
{"task": "detection", "input": "classify code:\ndef exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef djb2(s: str) -> int:\n    \"\"\"\n    Implementation of djb2 hash algorithm that\n    is popular because of it's magic constants.\n\n    >>> djb2('Algorithms')\n    3782405311\n\n    >>> djb2('scramble bits')\n    1609059040\n    \"\"\"\n    hash_value = 5381\n    for x in s:\n        hash_value = ((hash_value << 5) + hash_value) + ord(x)\n    return hash_value & 0xFFFFFFFF", "output": "def djb2(s: str) -> int:\n    \"\"\"\n    Implementation of djb2 hash algorithm that\n    is popular because of it's magic constants.\n\n    >>> djb2('Algorithms')\n    3782405311\n\n    >>> djb2('scramble bits')\n    1609059040\n    \"\"\"\n    hash_value = 5381\n    for x in s:\n        hash_value = ((hash_value << 5) + hash_value) + ord(x)\n    return hash_value & 0xFFFFFFFF", "tests": ["assert djb2('Algorithms') == 3782405311", "assert djb2('scramble bits') == 1609059040"]}
{"task": "search", "input": "search code:\nTo evaluate the sum, Used decimal python module to calculate the decimal\n\nChoices:\n0: def main() -> None:     img_paths, annos = get_dataset(LABEL_DIR, IMAGE_DIR)     print(\"Processing...\")     new_images, new_annos, paths = update_image_and_anno(img_paths, annos, FLIP_TYPE)      for index, image in enumerate(new_images):         # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'         letter_code = random_chars(32)         file_name = paths[index].split(os.sep)[-1].rsplit(\".\", 1)[0]         file_root = f\"{OUTPUT_DIR}/{file_name}_FLIP_{letter_code}\"         cv2.imwrite(f\"{file_root}.jpg\", image, [cv2.IMWRITE_JPEG_QUALITY, 85])         print(f\"Success {index + 1}/{len(new_images)} with {file_name}\")         annos_list = []         for anno in new_annos[index]:             obj = f\"{anno[0]} {anno[1]} {anno[2]} {anno[3]} {anno[4]}\"             annos_list.append(obj)         with open(f\"{file_root}.txt\", \"w\") as outfile:             outfile.write(\"\\n\".join(line for line in annos_list))\n1: def solution() -> int:     answer = 0     decimal_context = decimal.Context(prec=105)     for i in range(2, 100):         number = decimal.Decimal(i)         sqrt_number = number.sqrt(decimal_context)         if len(str(sqrt_number)) > 1:             answer += int(str(sqrt_number)[0])             sqrt_number_str = str(sqrt_number)[2:101]             answer += sum(int(x) for x in sqrt_number_str)     return answer\n2: def evaluate(expression):     stack = []      # iterate over the string in reverse order     for c in expression.split()[::-1]:         # push operand to stack         if is_operand(c):             stack.append(int(c))          else:             # pop values from stack can calculate the result             # push the result onto the stack again             o1 = stack.pop()             o2 = stack.pop()             stack.append(operators[c](o1, o2))      return stack.pop()", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef krusk(e_and_n):\n    (e, n) = e_and_n\n    e.sort(reverse=True, key=lambda x: x[2])\n    s = [{i} for i in range(1, n + 1)]\n    while True:\n        if len(s) == 1:\n            break\n        print(s)\n        x = e.pop()\n        for i in range(len(s)):\n            if x[0] in s[i]:\n                break\n        for j in range(len(s)):\n            if x[1] in s[j]:\n                if i == j:\n                    break\n                s[j].update(s[i])\n                s.pop(i)\n                break", "output": "Sort edges on the basis of distance"}
{"task": "repair", "input": "fix bug:\ndef contains_an_even_digit(n: int) -> bool:\n    \"\"\"\n    Return True if n contains an even digit.\n    >>> contains_an_even_digit(0)\n    True\n    >>> contains_an_even_digit(975317933)\n    False\n    >>> contains_an_even_digit(-245679)\n    True\n    \"\"\"\n    return any(digit in \"02468\" for digit in str(n))", "output": "def contains_an_even_digit(n: int) -> bool:\n    \"\"\"\n    Return True if n contains an even digit.\n    >>> contains_an_even_digit(0)\n    True\n    >>> contains_an_even_digit(975317933)\n    False\n    >>> contains_an_even_digit(-245679)\n    True\n    \"\"\"\n    return any(digit in \"02468\" for digit in str(n))", "tests": ["assert contains_an_even_digit(0) == True", "assert contains_an_even_digit(975317933) == False", "assert contains_an_even_digit(-245679) == True"]}
{"task": "detection", "input": "classify code:\ndef get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef make_linked_list(elements_list: list | tuple) -> Node:\n\n    # if elements_list is empty\n    if not elements_list:\n        raise ValueError(\"The Elements List is empty\")\n\n    # Set first element as Head\n    head = Node(elements_list[0])\n    current = head\n    # Loop through elements from position 1\n    for data in elements_list[1:]:\n        current.next = Node(data)\n        current = current.next\n    return head", "output": "Creates a Linked List from the elements of the given sequence"}
{"task": "detection", "input": "classify code:\ndef gnome_sort(lst: list) -> list:\n    \"\"\"\n    Pure implementation of the gnome sort algorithm in Python\n\n    Take some mutable ordered collection with heterogeneous comparable items inside as\n    arguments, return the same collection ordered by ascending.\n\n    Examples:\n    >>> gnome_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> gnome_sort([])\n    []\n\n    >>> gnome_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    >>> \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\"))))\n    ' !Gadeimnoprstu'\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n\n    i = 1\n\n    while i < len(lst):\n        if lst[i - 1] <= lst[i]:\n            i += 1\n        else:\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1\n\n    return lst", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)", "output": "def encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)", "tests": ["assert encrypt_message(6, 'Harshil Darji') == 'Hlia rDsahrij'"]}
{"task": "search", "input": "search code:\nCompute the \"subdictionary\" of a dict, *d*.\n\nChoices:\n0: def gunzip_bytes(bytestring):     return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)\n1: def cardinalize(unit_noun, count):     if count == 1:         return unit_noun     return pluralize(unit_noun)\n2: def subdict(d, keep=None, drop=None):     if keep is None:         keep = d.keys()     if drop is None:         drop = []      keys = set(keep) - set(drop)      return type(d)([(k, v) for k, v in d.items() if k in keys])", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef mro_items(type_obj):\n    # TODO: handle slots?\n    return itertools.chain.from_iterable(ct.__dict__.items()\n                                         for ct in type_obj.__mro__)", "output": "Takes a type and returns an iterator over all class variables"}
{"task": "detection", "input": "classify code:\ndef longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "CORRECT"}
{"task": "search", "input": "search code:\nPure Python implementation of Geometric Series algorithm\n\nChoices:\n0: def geometric_series(     nth_term: float,     start_term_a: float,     common_ratio_r: float, ) -> list[float]:     if not all((nth_term, start_term_a, common_ratio_r)):         return []     series: list[float] = []     power = 1     multiple = common_ratio_r     for _ in range(int(nth_term)):         if not series:             series.append(start_term_a)         else:             power += 1             series.append(float(start_term_a * multiple))             multiple = pow(float(common_ratio_r), power)     return series\n1: def charging_inductor(     source_voltage: float,  # source_voltage should be in volts.     resistance: float,  # resistance should be in ohms.     inductance: float,  # inductance should be in henrys.     time: float,  # time should in seconds. ) -> float:      if source_voltage <= 0:         raise ValueError(\"Source voltage must be positive.\")     if resistance <= 0:         raise ValueError(\"Resistance must be positive.\")     if inductance <= 0:         raise ValueError(\"Inductance must be positive.\")     return round(         source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3     )\n2: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef prime_sieve(n: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "def prime_sieve(n: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "tests": ["assert prime_sieve(3) == [2]", "assert prime_sieve(50) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]"]}
{"task": "repair", "input": "fix bug:\ndef solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution(100)\n    25164150\n    \"\"\"\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)", "output": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)", "tests": ["assert solution(10) == 2640", "assert solution(15) == 13160", "assert solution(20) == 41230", "assert solution(50) == 1582700", "assert solution() == 25164150"]}
{"task": "summary", "input": "summarize code:\ndef perfect(number: int) -> bool:\n    if not isinstance(number, int):\n        raise ValueError(\"number must be an integer\")\n    if number <= 0:\n        return False\n    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number", "output": "Check if a number is a perfect number."}
{"task": "search", "input": "search code:\nCalculate Number of Divisors of an Integer.\n\nChoices:\n0: def number_of_divisors(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     div = 1     temp = 1     while n % 2 == 0:         temp += 1         n = int(n / 2)     div *= temp     for i in range(3, int(math.sqrt(n)) + 1, 2):         temp = 1         while n % i == 0:             temp += 1             n = int(n / i)         div *= temp     if n > 1:         div *= 2     return div\n1: def iter_index(iterable, value, start=0, stop=None):     seq_index = getattr(iterable, 'index', None)     if seq_index is None:         # Slow path for general iterables         iterator = islice(iterable, start, stop)         for i, element in enumerate(iterator, start):             if element is value or element == value:                 yield i     else:         # Fast path for sequences         stop = len(iterable) if stop is None else stop         i = start - 1         with suppress(ValueError):             while True:                 yield (i := seq_index(value, i + 1, stop))\n2: def solution():     script_dir = os.path.dirname(os.path.realpath(__file__))     words_file_path = os.path.join(script_dir, \"words.txt\")      words = \"\"     with open(words_file_path) as f:         words = f.readline()      words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]     words = [         word         for word in [sum(ord(x) - 64 for x in word) for word in words]         if word in TRIANGULAR_NUMBERS     ]     return len(words)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef cyclic_sort(nums: list[int]) -> list[int]:\n    \"\"\"\n    Sorts the input list of n integers from 1 to n in-place\n    using the Cyclic Sort algorithm.\n\n    :param nums: List of n integers from 1 to n to be sorted.\n    :return: The same list sorted in ascending order.\n\n    Time complexity: O(n), where n is the number of integers in the list.\n\n    Examples:\n    >>> cyclic_sort([])\n    []\n    >>> cyclic_sort([3, 5, 2, 1, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]", "output": "def fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]", "tests": ["assert fibonacci(2) == 1", "assert fibonacci(3) == 2", "assert fibonacci(5) == 5", "assert fibonacci(10) == 55", "assert fibonacci(12) == 144"]}
{"task": "search", "input": "search code:\nHandles I/O\n\nChoices:\n0: def quick_select(arr: list, target: int) -> int:      # Invalid Input     if target > len(arr):         return -1      # x is the estimated pivot by median of medians algorithm     x = median_of_medians(arr)     left = []     right = []     check = False     for i in range(len(arr)):         if arr[i] < x:             left.append(arr[i])         elif arr[i] > x:             right.append(arr[i])         elif arr[i] == x and not check:             check = True         else:             right.append(arr[i])     rank_x = len(left) + 1     if rank_x == target:         answer = x     elif rank_x > target:         answer = quick_select(left, target)     elif rank_x < target:         answer = quick_select(right, target - rank_x)     return answer\n1: def main() -> None:     message = input(\"Enter message to encode or decode: \").strip()     key = input(\"Enter keyword: \").strip()     option = input(\"Encipher or decipher? E/D:\").strip()[0].lower()     try:         func = {\"e\": encipher, \"d\": decipher}[option]     except KeyError:         raise KeyError(\"invalid input option\")     cipher_map = create_cipher_map(key)     print(func(message, cipher_map))\n2: def max_sum_in_array(array: list[int], k: int) -> int:     if len(array) < k or k < 0:         raise ValueError(\"Invalid Input\")     max_sum = current_sum = sum(array[:k])     for i in range(len(array) - k):         current_sum = current_sum - array[i] + array[i + k]         max_sum = max(max_sum, current_sum)     return max_sum", "output": "1"}
{"task": "detection", "input": "classify code:\ndef vernam_decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_decrypt(\"RIJVS\",\"KEY\")\n    'HELLO'\n    \"\"\"\n    decrypted_text = \"\"\n    for i in range(len(ciphertext)):\n        ct = ord(ciphertext[i]) - ord(key[i % len(key)])\n        while ct < 0:\n            ct = 26 + ct\n        decrypted_text += chr(65 + ct)\n    return decrypted_text", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef avg_speed_of_molecule(temperature: float, molar_mass: float) -> float:\n\n    if temperature < 0:\n        raise Exception(\"Absolute temperature cannot be less than 0 K\")\n    if molar_mass <= 0:\n        raise Exception(\"Molar mass should be greater than 0 kg/mol\")\n    return (8 * R * temperature / (pi * molar_mass)) ** 0.5", "output": "Takes the temperature (in K) and molar mass (in kg/mol) of a gas"}
{"task": "summary", "input": "summarize code:\ndef _suppress_lower_units(min_unit, suppress):\n    suppress = set(suppress)\n    for u in Unit:\n        if u == min_unit:\n            break\n        suppress.add(u)\n\n    return suppress", "output": "Extend suppressed units (if any) with all units lower than the minimum unit."}
{"task": "detection", "input": "classify code:\ndef actual_power(a: int, b: int) -> int:\n    \"\"\"\n    Function using divide and conquer to calculate a^b.\n    It only works for integer a,b.\n\n    :param a: The base of the power operation, an integer.\n    :param b: The exponent of the power operation, a non-negative integer.\n    :return: The result of a^b.\n\n    Examples:\n    >>> actual_power(3, 2)\n    9\n    >>> actual_power(5, 3)\n    125\n    >>> actual_power(2, 5)\n    32\n    >>> actual_power(7, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    half = actual_power(a, b // 2)\n\n    if (b % 2) == 0:\n        return half * half\n    else:\n        return a * half * half", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef lin_search(left: int, right: int, array: List[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1", "output": "def lin_search(left: int, right: int, array: list[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1", "tests": ["assert lin_search(0, 4, [4, 5, 6, 7], 7) == 3", "assert lin_search(0, 3, [4, 5, 6, 7], 7) == -1", "assert lin_search(0, 2, [-18, 2], -18) == 0", "assert lin_search(0, 1, [5], 5) == 0", "assert lin_search(0, 3, ['a', 'c', 'd'], 'c') == 1", "assert lin_search(0, 3, [.1, .4 , -.1], .1) == 0", "assert lin_search(0, 3, [.1, .4 , -.1], -.1) == 2"]}
{"task": "search", "input": "search code:\ninput: size (N) of the vector.\n\nChoices:\n0: def sigmoid_derivative(value: np.ndarray) -> np.ndarray:     return (value) * (1 - (value))\n1: def vol_cube(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"vol_cube() only accepts non-negative values\")     return pow(side_length, 3)\n2: def random_vector(n: int, a: int, b: int) -> Vector:     random.seed(None)     ans = [random.randint(a, b) for _ in range(n)]     return Vector(ans)", "output": "2"}
{"task": "search", "input": "search code:\nSolve for remaining 'digit' digits, with previous 'prev1' digit, and\n\nChoices:\n0: def solution(num_picks: int = 20) -> str:     total = math.comb(NUM_BALLS, num_picks)     missing_colour = math.comb(NUM_BALLS - BALLS_PER_COLOUR, num_picks)      result = NUM_COLOURS * (1 - missing_colour / total)      return f\"{result:.9f}\"\n1: def solve(     digit: int, prev1: int, prev2: int, sum_max: int, first: bool, cache: dict[str, int] ) -> int:     if digit == 0:         return 1      cache_str = f\"{digit},{prev1},{prev2}\"     if cache_str in cache:         return cache[cache_str]      comb = 0     for curr in range(sum_max - prev1 - prev2 + 1):         if first and curr == 0:             continue          comb += solve(             digit=digit - 1,             prev1=curr,             prev2=prev1,             sum_max=sum_max,             first=False,             cache=cache,         )      cache[cache_str] = comb     return comb\n2: def second_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef combination_lists(n: int, k: int) -> list[list[int]]:\n    return [list(x) for x in combinations(range(1, n + 1), k)]", "output": "Generates all possible combinations of k numbers out of 1 ... n using itertools."}
{"task": "detection", "input": "classify code:\ndef cyclic_sort(nums: list[int]) -> list[int]:\n    \"\"\"\n    Sorts the input list of n integers from 1 to n in-place\n    using the Cyclic Sort algorithm.\n\n    :param nums: List of n integers from 1 to n to be sorted.\n    :return: The same list sorted in ascending order.\n\n    Time complexity: O(n), where n is the number of integers in the list.\n\n    Examples:\n    >>> cyclic_sort([])\n    []\n    >>> cyclic_sort([3, 5, 2, 1, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]", "output": "def strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]", "tests": ["assert strip(\"   hello   \") == 'hello'", "assert strip(\"...world...\", \".\") == 'world'", "assert strip(\"123hello123\", \"123\") == 'hello'", "assert strip(\"\") == ''"]}
{"task": "summary", "input": "summarize code:\ndef crossover(parent_1: str, parent_2: str) -> tuple[str, str]:\n    random_slice = random.randint(0, len(parent_1) - 1)\n    child_1 = parent_1[:random_slice] + parent_2[random_slice:]\n    child_2 = parent_2[:random_slice] + parent_1[random_slice:]\n    return (child_1, child_2)", "output": "Slice and combine two strings at a random point."}
{"task": "search", "input": "search code:\nSorts the input list of n integers from 1 to n in-place\n\nChoices:\n0: def product_sum_array(array: list[int | list]) -> int:     return product_sum(array, 1)\n1: def cyclic_sort(nums: list[int]) -> list[int]:      # Perform cyclic sort     index = 0     while index < len(nums):         # Calculate the correct index for the current element         correct_index = nums[index] - 1         # If the current element is not at its correct position,         # swap it with the element at its correct index         if index != correct_index:             nums[index], nums[correct_index] = nums[correct_index], nums[index]         else:             # If the current element is already in its correct position,             # move to the next element             index += 1      return nums\n2: def comb_sort(data: list) -> list:     shrink_factor = 1.3     gap = len(data)     completed = False      while not completed:         # Update the gap value for a next comb         gap = int(gap / shrink_factor)         if gap <= 1:             completed = True          index = 0         while index + gap < len(data):             if data[index] > data[index + gap]:                 # Swap values                 data[index], data[index + gap] = data[index + gap], data[index]                 completed = False             index += 1      return data", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef exchange_sort(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Uses exchange sort to sort a list of numbers.\n    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    >>> exchange_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([-1, -2, -3])\n    [-3, -2, -1]\n    >>> exchange_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([0, 10, -2, 5, 3])\n    [-2, 0, 3, 5, 10]\n    >>> exchange_sort([])\n    []\n    \"\"\"\n    numbers_length = len(numbers)\n    for i in range(numbers_length):\n        for j in range(i + 1, numbers_length):\n            if numbers[j] < numbers[i]:\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n    return numbers", "output": "def exchange_sort(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Uses exchange sort to sort a list of numbers.\n    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    >>> exchange_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([-1, -2, -3])\n    [-3, -2, -1]\n    >>> exchange_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([0, 10, -2, 5, 3])\n    [-2, 0, 3, 5, 10]\n    >>> exchange_sort([])\n    []\n    \"\"\"\n    numbers_length = len(numbers)\n    for i in range(numbers_length):\n        for j in range(i + 1, numbers_length):\n            if numbers[j] < numbers[i]:\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n    return numbers", "tests": ["assert exchange_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]", "assert exchange_sort([-1, -2, -3]) == [-3, -2, -1]", "assert exchange_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]", "assert exchange_sort([0, 10, -2, 5, 3]) == [-2, 0, 3, 5, 10]", "assert exchange_sort([]) == []"]}
{"task": "detection", "input": "classify code:\ndef gnome_sort(unsorted):\n    \"\"\"Pure implementation of the gnome sort algorithm in Python.\"\"\"\n    if len(unsorted) <= 1:\n        return unsorted\n\n    i = 1\n\n    while i < len(unsorted):\n        if unsorted[i - 1] <= unsorted[i]:\n            i += 1\n        else:\n            unsorted[i - 1], unsorted[i] = unsorted[i], unsorted[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef _count_cross_inversions(p, q):\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion", "output": "Counts the inversions across two sorted arrays."}
{"task": "detection", "input": "classify code:\ndef _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )", "output": "def shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )", "tests": ["assert shear_stress(stress=25, tangential_force=100, area=0) == ('area', 4.0)", "assert shear_stress(stress=0, tangential_force=1600, area=200) == ('stress', 8.0)", "assert shear_stress(stress=1000, tangential_force=0, area=1200) == ('tangential_force', 1200000)"]}
{"task": "search", "input": "search code:\nDownload the data from source url, unless it's already here.\n\nChoices:\n0: def _date_and_delta(value, *, now=None):     if not now:         now = _now()     if isinstance(value, dt.datetime):         date = value         delta = now - value     elif isinstance(value, dt.timedelta):         date = now - value         delta = value     else:         try:             value = int(value)             delta = dt.timedelta(seconds=value)             date = now - delta         except (ValueError, TypeError):             return None, value     return date, _abs_timedelta(delta)\n1: def _maybe_download(filename, work_directory, source_url):     if not gfile.Exists(work_directory):         gfile.MakeDirs(work_directory)     filepath = os.path.join(work_directory, filename)     if not gfile.Exists(filepath):         urllib.request.urlretrieve(source_url, filepath)  # noqa: S310         with gfile.GFile(filepath) as f:             size = f.size()         print(\"Successfully downloaded\", filename, size, \"bytes.\")     return filepath\n2: def swap_odd_even_bits(num: int) -> int:     # Get all even bits - 0xAAAAAAAA is a 32-bit number with all even bits set to 1     even_bits = num & 0xAAAAAAAA      # Get all odd bits - 0x55555555 is a 32-bit number with all odd bits set to 1     odd_bits = num & 0x55555555      # Right shift even bits and left shift odd bits and swap them     return even_bits >> 1 | odd_bits << 1", "output": "1"}
{"task": "search", "input": "search code:\nCalculates the value of Gamma function of num\n\nChoices:\n0: def make_tree_nine() -> Node:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     tree.right.right = Node(6)     tree.left.left.left = Node(7)     tree.left.left.right = Node(8)     tree.left.right.right = Node(9)     return tree\n1: def gamma_iterative(num: float) -> float:     if num <= 0:         raise ValueError(\"math domain error\")      return quad(integrand, 0, inf, args=(num))[0]\n2: def indian_phone_validator(phone: str) -> bool:     pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")     if match := re.search(pat, phone):         return match.string == phone     return False", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef prime_sieve_eratosthenes(num: int) -> list[int]:\n\n    if num <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    primes = [True] * (num + 1)\n\n    p = 2\n    while p * p <= num:\n        if primes[p]:\n            for i in range(p * p, num + 1, p):\n                primes[i] = False\n        p += 1\n\n    return [prime for prime in range(2, num + 1) if primes[prime]]", "output": "Print the prime numbers up to n"}
{"task": "repair", "input": "fix bug:\ndef upper(word: str) -> str:\n    \"\"\"\n    Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII\n    letters and subtracting 32 from their integer representation to get the uppercase\n    letter.\n\n    >>> upper(\"wow\")\n    'WOW'\n    >>> upper(\"Hello\")\n    'HELLO'\n    >>> upper(\"WHAT\")\n    'WHAT'\n    >>> upper(\"wh[]32\")\n    'WH[]32'\n    \"\"\"\n    return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)", "output": "def upper(word: str) -> str:\n    \"\"\"\n    Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII\n    letters and subtracting 32 from their integer representation to get the uppercase\n    letter.\n\n    >>> upper(\"wow\")\n    'WOW'\n    >>> upper(\"Hello\")\n    'HELLO'\n    >>> upper(\"WHAT\")\n    'WHAT'\n    >>> upper(\"wh[]32\")\n    'WH[]32'\n    \"\"\"\n    return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)", "tests": ["assert upper(\"wow\") == 'WOW'", "assert upper(\"Hello\") == 'HELLO'", "assert upper(\"WHAT\") == 'WHAT'", "assert upper(\"wh[]32\") == 'WH[]32'"]}
{"task": "detection", "input": "classify code:\ndef solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in xrange(1, 1001):\n        total += i ** i\n    return str(total)[-10:]", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef str_eval(s: str) -> int:\n    \"\"\"\n    Returns product of digits in given string n\n\n    >>> str_eval(\"987654321\")\n    362880\n    >>> str_eval(\"22222222\")\n    256\n    \"\"\"\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFinds the value of n from 1 to max such that n/φ(n) produces a minimum.\n\nChoices:\n0: def left_rotate_32(i: int, shift: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")     if shift < 0:         raise ValueError(\"Shift must be non-negative\")     return ((i << shift) ^ (i >> (32 - shift))) % 2**32\n1: def solution(max_n: int = 10000000) -> int:      min_numerator = 1  # i     min_denominator = 0  # φ(i)     totients = get_totients(max_n + 1)      for i in range(2, max_n + 1):         t = totients[i]          if i * min_denominator < min_numerator * t and has_same_digits(i, t):             min_numerator = i             min_denominator = t      return min_numerator\n2: def lin_search(left: int, right: int, array: list[int], target: int) -> int:     for i in range(left, right):         if array[i] == target:             return i     return -1", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef is_ip_v4_address_valid(ip_v4_address: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.255.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"254.255.0.255\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n    \"\"\"\n    octets = [int(i) for i in ip_v4_address.split(\".\") if i.isdigit()]\n    return len(octets) == 4 and all(0 <= int(octet) <= 254 for octet in octets)", "output": "def is_ip_v4_address_valid(ip: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.256.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"255.256.0.256\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.05\")\n    False\n    \"\"\"\n    octets = ip.split(\".\")\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        if not octet.isdigit():\n            return False\n\n        number = int(octet)\n        if len(str(number)) != len(octet):\n            return False\n\n        if not 0 <= number <= 255:\n            return False\n\n    return True", "tests": ["assert is_ip_v4_address_valid(\"192.168.0.23\") == True", "assert is_ip_v4_address_valid(\"192.256.15.8\") == False", "assert is_ip_v4_address_valid(\"172.100.0.8\") == True", "assert is_ip_v4_address_valid(\"255.256.0.256\") == False", "assert is_ip_v4_address_valid(\"1.2.33333333.4\") == False", "assert is_ip_v4_address_valid(\"1.2.-3.4\") == False", "assert is_ip_v4_address_valid(\"1.2.3\") == False", "assert is_ip_v4_address_valid(\"1.2.3.4.5\") == False", "assert is_ip_v4_address_valid(\"1.2.A.4\") == False", "assert is_ip_v4_address_valid(\"0.0.0.0\") == True", "assert is_ip_v4_address_valid(\"1.2.3.\") == False", "assert is_ip_v4_address_valid(\"1.2.3.05\") == False"]}
{"task": "summary", "input": "summarize code:\ndef main():\n    print(\"Volumes:\")\n    print(f\"Cube: {vol_cube(2) = }\")  # = 8\n    print(f\"Cuboid: {vol_cuboid(2, 2, 2) = }\")  # = 8\n    print(f\"Cone: {vol_cone(2, 2) = }\")  # ~= 1.33\n    print(f\"Right Circular Cone: {vol_right_circ_cone(2, 2) = }\")  # ~= 8.38\n    print(f\"Prism: {vol_prism(2, 2) = }\")  # = 4\n    print(f\"Pyramid: {vol_pyramid(2, 2) = }\")  # ~= 1.33\n    print(f\"Sphere: {vol_sphere(2) = }\")  # ~= 33.5\n    print(f\"Hemisphere: {vol_hemisphere(2) = }\")  # ~= 16.75\n    print(f\"Circular Cylinder: {vol_circular_cylinder(2, 2) = }\")  # ~= 25.1\n    print(f\"Torus: {vol_torus(2, 2) = }\")  # ~= 157.9\n    print(f\"Conical Frustum: {vol_conical_frustum(2, 2, 4) = }\")  # ~= 58.6\n    print(f\"Spherical cap: {vol_spherical_cap(1, 2) = }\")  # ~= 5.24\n    print(f\"Spheres intersection: {vol_spheres_intersect(2, 2, 1) = }\")  # ~= 21.21\n    print(f\"Spheres union: {vol_spheres_union(2, 2, 1) = }\")  # ~= 45.81\n    print(\n        f\"Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }\"\n    )  # ~= 28.3\n    print(f\"Icosahedron: {vol_icosahedron(2.5) = }\")  # ~=34.09", "output": "Print the Results of Various Volume Calculations."}
{"task": "repair", "input": "fix bug:\ndef is_ip_v4_address_valid(ip_v4_address: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.255.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"254.255.0.255\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n    \"\"\"\n    octets = [int(i) for i in ip_v4_address.split(\".\") if i.isdigit()]\n    return len(octets) == 4 and all(0 <= int(octet) <= 254 for octet in octets)", "output": "def is_ip_v4_address_valid(ip: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.256.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"255.256.0.256\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.05\")\n    False\n    \"\"\"\n    octets = ip.split(\".\")\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        if not octet.isdigit():\n            return False\n\n        number = int(octet)\n        if len(str(number)) != len(octet):\n            return False\n\n        if not 0 <= number <= 255:\n            return False\n\n    return True", "tests": ["assert is_ip_v4_address_valid(\"192.168.0.23\") == True", "assert is_ip_v4_address_valid(\"192.256.15.8\") == False", "assert is_ip_v4_address_valid(\"172.100.0.8\") == True", "assert is_ip_v4_address_valid(\"255.256.0.256\") == False", "assert is_ip_v4_address_valid(\"1.2.33333333.4\") == False", "assert is_ip_v4_address_valid(\"1.2.-3.4\") == False", "assert is_ip_v4_address_valid(\"1.2.3\") == False", "assert is_ip_v4_address_valid(\"1.2.3.4.5\") == False", "assert is_ip_v4_address_valid(\"1.2.A.4\") == False", "assert is_ip_v4_address_valid(\"0.0.0.0\") == True", "assert is_ip_v4_address_valid(\"1.2.3.\") == False", "assert is_ip_v4_address_valid(\"1.2.3.05\") == False"]}
{"task": "summary", "input": "summarize code:\ndef solve(nums: list[int], goal: int, depth: int) -> bool:\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False", "output": "Checks if nums can have a sum equal to goal, given that length of nums does"}
{"task": "detection", "input": "classify code:\ndef calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r", "output": "CORRECT"}
{"task": "search", "input": "search code:\nBreak *iterable* into lists of length *n*:\n\nChoices:\n0: def solution() -> int:     return compute_nums(1)[0]\n1: def abs_val(num: float) -> float:     return -num if num < 0 else num\n2: def chunked(iterable, n, strict=False):     iterator = iter(partial(take, n, iter(iterable)), [])     if strict:         if n is None:             raise ValueError('n must not be None when using strict mode.')          def ret():             for chunk in iterator:                 if len(chunk) != n:                     raise ValueError('iterable is not divisible by n.')                 yield chunk          return ret()     else:         return iterator", "output": "2"}
{"task": "detection", "input": "classify code:\ndef geometric_series(\n    nth_term: float | int,\n    start_term_a: float | int,\n    common_ratio_r: float | int,\n) -> list[float | int]:\n    \"\"\"\n    Pure Python implementation of Geometric Series algorithm\n\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\n    >>> geometric_series(4, 2, -2)\n    [2, -4.0, 8.0, -16.0]\n    >>> geometric_series(4, -2, 2)\n    [-2, -4.0, -8.0, -16.0]\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float | int] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef circle_sort(collection: list) -> list:\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection", "output": "A pure Python implementation of circle sort algorithm"}
{"task": "search", "input": "search code:\nFinds the maclaurin approximation of cos\n\nChoices:\n0: def soboleva_modified_hyperbolic_tangent(     vector: np.ndarray, a_value: float, b_value: float, c_value: float, d_value: float ) -> np.ndarray:      # Separate the numerator and denominator for simplicity     # Calculate the numerator and denominator element-wise     numerator = np.exp(a_value * vector) - np.exp(-b_value * vector)     denominator = np.exp(c_value * vector) + np.exp(-d_value * vector)      # Calculate and return the final result element-wise     return numerator / denominator\n1: def maclaurin_cos(theta: float, accuracy: int = 30) -> float:      if not isinstance(theta, (int, float)):         raise ValueError(\"maclaurin_cos() requires either an int or float for theta\")      if not isinstance(accuracy, int) or accuracy <= 0:         raise ValueError(\"maclaurin_cos() requires a positive int for accuracy\")      theta = float(theta)     div = theta // (2 * pi)     theta -= 2 * div * pi     return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))\n2: def interact_treap(root: Node | None, args: str) -> Node | None:     for arg in args.split():         if arg[0] == \"+\":             root = insert(root, int(arg[1:]))          elif arg[0] == \"-\":             root = erase(root, int(arg[1:]))          else:             print(\"Unknown command\")      return root", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef count_vowels(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a given string.\n\n    :param s: Input string to count vowels in.\n    :return: Number of vowels in the input string.\n\n    Examples:\n    >>> count_vowels(\"hello world\")\n    3\n    >>> count_vowels(\"HELLO WORLD\")\n    3\n    >>> count_vowels(\"123 hello world\")\n    3\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a quick brown fox\")\n    5\n    >>> count_vowels(\"the quick BROWN fox\")\n    5\n    >>> count_vowels(\"PYTHON\")\n    1\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)", "output": "def count_vowels(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a given string.\n\n    :param s: Input string to count vowels in.\n    :return: Number of vowels in the input string.\n\n    Examples:\n    >>> count_vowels(\"hello world\")\n    3\n    >>> count_vowels(\"HELLO WORLD\")\n    3\n    >>> count_vowels(\"123 hello world\")\n    3\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a quick brown fox\")\n    5\n    >>> count_vowels(\"the quick BROWN fox\")\n    5\n    >>> count_vowels(\"PYTHON\")\n    1\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)", "tests": ["assert count_vowels(\"hello world\") == 3", "assert count_vowels(\"HELLO WORLD\") == 3", "assert count_vowels(\"123 hello world\") == 3", "assert count_vowels(\"\") == 0", "assert count_vowels(\"a quick brown fox\") == 5", "assert count_vowels(\"the quick BROWN fox\") == 5", "assert count_vowels(\"PYTHON\") == 1"]}
{"task": "repair", "input": "fix bug:\ndef is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True", "output": "def is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True", "tests": ["assert is_square_form(1) == False", "assert is_square_form(112233445566778899) == True", "assert is_square_form(123456789012345678) == False"]}
{"task": "detection", "input": "classify code:\ndef wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef gaussian_elimination(\n    coefficients: NDArray[float64], vector: NDArray[float64]\n) -> NDArray[float64]:\n    # coefficients must to be a square matrix so we need to check first\n    rows, columns = np.shape(coefficients)\n    if rows != columns:\n        return np.array((), dtype=float)\n\n    # augmented matrix\n    augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)\n    augmented_mat = augmented_mat.astype(\"float64\")\n\n    # scale the matrix leaving it triangular\n    for row in range(rows - 1):\n        pivot = augmented_mat[row, row]\n        for col in range(row + 1, columns):\n            factor = augmented_mat[col, row] / pivot\n            augmented_mat[col, :] -= factor * augmented_mat[row, :]\n\n    x = retroactive_resolution(\n        augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]\n    )\n\n    return x", "output": "This function performs Gaussian elimination method"}
{"task": "search", "input": "search code:\nExtract the labels into a 1D uint8 numpy array [index].\n\nChoices:\n0: def _extract_labels(f, one_hot=False, num_classes=10):     print(\"Extracting\", f.name)     with gzip.GzipFile(fileobj=f) as bytestream:         magic = _read32(bytestream)         if magic != 2049:             msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"             raise ValueError(msg)         num_items = _read32(bytestream)         buf = bytestream.read(num_items)         labels = np.frombuffer(buf, dtype=np.uint8)         if one_hot:             return _dense_to_one_hot(labels, num_classes)         return labels\n1: def _ngettext_noop(singular, plural):     return (singular, plural)\n2: def _complex_sumprod(v1, v2):      real = attrgetter('real')     imag = attrgetter('imag')     r1 = chain(map(real, v1), map(neg, map(imag, v1)))     r2 = chain(map(real, v2), map(imag, v2))     i1 = chain(map(real, v1), map(imag, v1))     i2 = chain(map(imag, v2), map(real, v2))     return complex(_fsumprod(r1, r2), _fsumprod(i1, i2))", "output": "0"}
{"task": "search", "input": "search code:\nCheck if a number is perfect square using binary search.\n\nChoices:\n0: def get_word_pattern(word: str) -> str:     word = word.upper()     next_num = 0     letter_nums = {}     word_pattern = []      for letter in word:         if letter not in letter_nums:             letter_nums[letter] = str(next_num)             next_num += 1         word_pattern.append(letter_nums[letter])     return \".\".join(word_pattern)\n1: def perfect_square_binary_search(n: int) -> bool:     left = 0     right = n     while left <= right:         mid = (left + right) // 2         if mid**2 == n:             return True         elif mid**2 > n:             right = mid - 1         else:             left = mid + 1     return False\n2: def solution() -> int:     return compute_nums(1)[0]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef backtrack(\n    candidates: list, path: list, answer: list, target: int, previous_index: int\n) -> None:\n    if target == 0:\n        answer.append(path.copy())\n    else:\n        for index in range(previous_index, len(candidates)):\n            if target >= candidates[index]:\n                path.append(candidates[index])\n                backtrack(candidates, path, answer, target - candidates[index], index)\n                path.pop(len(path) - 1)", "output": "A recursive function that searches for possible combinations. Backtracks in case"}
{"task": "detection", "input": "classify code:\ndef find_negative_index(array: list[int]) -> int:\n    \"\"\"\n    Find the smallest negative index\n\n    >>> find_negative_index([0,0,0,0])\n    4\n    >>> find_negative_index([4,3,2,-1])\n    3\n    >>> find_negative_index([1,0,-1,-10])\n    2\n    >>> find_negative_index([0,0,0,-1])\n    3\n    >>> find_negative_index([11,8,7,-3,-5,-9])\n    3\n    >>> find_negative_index([-1,-1,-2,-3])\n    0\n    >>> find_negative_index([5,1,0])\n    3\n    >>> find_negative_index([-5,-5,-5])\n    0\n    >>> find_negative_index([0])\n    1\n    >>> find_negative_index([])\n    0\n    \"\"\"\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef calculate_waiting_times(burst_times: List[int]) -> List[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r", "output": "def calculate_waiting_times(burst_times: list[int]) -> list[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r", "tests": ["assert calculate_waiting_times([10, 5, 8]) == [13, 10, 13]", "assert calculate_waiting_times([4, 6, 3, 1]) == [5, 8, 9, 6]", "assert calculate_waiting_times([12, 2, 10]) == [12, 2, 12]"]}
{"task": "detection", "input": "classify code:\ndef move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n    \"\"\"\n    Simulates gravity in a specific column.\n\n    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n    [['-', '-'], ['-', 'A'], ['-', 'C']]\n    \"\"\"\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))", "output": "def sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))", "tests": ["assert sum_of_digits_compact(12345) == 15", "assert sum_of_digits_compact(123) == 6", "assert sum_of_digits_compact(-123) == 6", "assert sum_of_digits_compact(0) == 0"]}
{"task": "summary", "input": "summarize code:\ndef slow_solution(max_number: int = 10**8) -> int:\n\n    prime_numbers = slow_calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left <= right:\n        while prime_numbers[left] * prime_numbers[right] >= max_number:\n            right -= 1\n        semiprimes_count += right - left + 1\n        left += 1\n\n    return semiprimes_count", "output": "Returns the number of composite integers below max_number have precisely two,"}
{"task": "search", "input": "search code:\nRecursively calculates the implication of a list.\n\nChoices:\n0: def recursive_imply_list(input_list: list[int]) -> int:     if len(input_list) < 2:         raise ValueError(\"Input list must contain at least two elements\")     first_implication = imply_gate(input_list[0], input_list[1])     if len(input_list) == 2:         return first_implication     new_list = [first_implication, *input_list[2:]]     return recursive_imply_list(new_list)\n1: def removeprefix(text: str, prefix: str) -> str:     if text.startswith(prefix):         return text[len(prefix):]     return text\n2: def parse_qsl(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):     pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]     ret = []     for pair in pairs:         if not pair:             continue         key, _, value = pair.partition('=')         if not value:             if keep_blank_values:                 value = None             else:                 continue         key = unquote(key.replace('+', ' '))         if value:             value = unquote(value.replace('+', ' '))         ret.append((key, value))     return ret", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef prime_sieve(limit: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "def prime_sieve(limit: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "tests": ["assert prime_sieve(3) == [2]", "assert prime_sieve(50) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]"]}
{"task": "search", "input": "search code:\nFunction checks the all possible combinations, and returns the count\n\nChoices:\n0: def combination_sum_iv(array: list[int], target: int) -> int:      def count_of_possible_combinations(target: int) -> int:         if target < 0:             return 0         if target == 0:             return 1         return sum(count_of_possible_combinations(target - item) for item in array)      return count_of_possible_combinations(target)\n1: def find_pattern(pattern: str, input_str: str) -> int:     answer = 0     # concatenate 'pattern' and 'input_str' and call z_function     # with concatenated string     z_result = z_function(pattern + input_str)      for val in z_result:         # if value is greater then length of the pattern string         # that means this index is starting position of substring         # which is equal to pattern string         if val >= len(pattern):             answer += 1      return answer\n2: def run_maze(     maze: list[list[int]],     i: int,     j: int,     destination_row: int,     destination_column: int,     solutions: list[list[int]], ) -> bool:     size = len(maze)     # Final check point.     if i == destination_row and j == destination_column and maze[i][j] == 0:         solutions[i][j] = 0         return True      lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds     upper_flag = (i < size) and (j < size)  # Check upper bounds      if lower_flag and upper_flag:         # check for already visited and block points.         block_flag = (solutions[i][j]) and (not maze[i][j])         if block_flag:             # check visited             solutions[i][j] = 0              # check for directions             if (                 run_maze(maze, i + 1, j, destination_row, destination_column, solutions)                 or run_maze(                     maze, i, j + 1, destination_row, destination_column, solutions                 )                 or run_maze(                     maze, i - 1, j, destination_row, destination_column, solutions                 )                 or run_maze(                     maze, i, j - 1, destination_row, destination_column, solutions                 )             ):                 return True              solutions[i][j] = 1             return False     return False", "output": "0"}
{"task": "detection", "input": "classify code:\ndef is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    A Pangram String contains all the alphabets at least once.\n    >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram(\"My name is Unknown\")\n    False\n    >>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram()\n    True\n    \"\"\"\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef take(n, iterable):\n    return list(islice(iterable, n))", "output": "Return first *n* items of the *iterable* as a list."}
{"task": "search", "input": "search code:\nCalculate real power from apparent power and power factor.\n\nChoices:\n0: def max_height(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(angle)     return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)\n1: def real_power(apparent_power: float, power_factor: float) -> float:     if (         not isinstance(power_factor, (int, float))         or power_factor < -1         or power_factor > 1     ):         raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")     return apparent_power * power_factor\n2: def area_under_line_estimator_check(     iterations: int, min_value: float = 0.0, max_value: float = 1.0 ) -> None:      def identity_function(x: float) -> float:         return x      estimated_value = area_under_curve_estimator(         iterations, identity_function, min_value, max_value     )     expected_value = (max_value * max_value - min_value * min_value) / 2      print(\"******************\")     print(f\"Estimating area under y=x where x varies from {min_value} to {max_value}\")     print(f\"Estimated value is {estimated_value}\")     print(f\"Expected value is {expected_value}\")     print(f\"Total error is {abs(estimated_value - expected_value)}\")     print(\"******************\")", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef double_linear_search(array: list[int], search_item: int) -> int:\n    # define the start and end index of the given array\n    start_ind, end_ind = 0, len(array) - 1\n    while start_ind <= end_ind:\n        if array[start_ind] == search_item:\n            return start_ind\n        elif array[end_ind] == search_item:\n            return end_ind\n        else:\n            start_ind += 1\n            end_ind -= 1\n    # returns -1 if search_item is not found in array\n    return -1", "output": "Iterate through the array from both sides to find the index of search_item."}
{"task": "repair", "input": "fix bug:\ndef scaling(scaling_factor: float) -> List[List[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]", "output": "def scaling(scaling_factor: float) -> list[list[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]", "tests": ["assert scaling(5) == [[5.0, 0.0], [0.0, 5.0]]"]}
{"task": "detection", "input": "classify code:\ndef extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef decode(coded: str) -> str:\n    if set(coded) - {\"A\", \"B\", \" \"} != set():\n        raise Exception(\"decode() accepts only 'A', 'B' and spaces\")\n    decoded = \"\"\n    for word in coded.split():\n        while len(word) != 0:\n            decoded += decode_dict[word[:5]]\n            word = word[5:]\n        decoded += \" \"\n    return decoded.strip()", "output": "Decodes from Baconian cipher"}
{"task": "search", "input": "search code:\nReturns the side length of the square spiral of odd length greater\n\nChoices:\n0: def carrier_concentration(     electron_conc: float,     hole_conc: float,     intrinsic_conc: float, ) -> tuple:     if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:         raise ValueError(\"You cannot supply more or less than 2 values\")     elif electron_conc < 0:         raise ValueError(\"Electron concentration cannot be negative in a semiconductor\")     elif hole_conc < 0:         raise ValueError(\"Hole concentration cannot be negative in a semiconductor\")     elif intrinsic_conc < 0:         raise ValueError(             \"Intrinsic concentration cannot be negative in a semiconductor\"         )     elif electron_conc == 0:         return (             \"electron_conc\",             intrinsic_conc**2 / hole_conc,         )     elif hole_conc == 0:         return (             \"hole_conc\",             intrinsic_conc**2 / electron_conc,         )     elif intrinsic_conc == 0:         return (             \"intrinsic_conc\",             (electron_conc * hole_conc) ** 0.5,         )     else:         return (-1, -1)\n1: def solution(ratio: float = 0.1) -> int:      j = 3     primes = 3      while primes / (2 * j - 1) >= ratio:         for i in range(j * j + j + 1, (j + 2) * (j + 2), j + 1):             primes += is_prime(i)         j += 2     return j\n2: def oct_to_decimal(oct_string: str) -> int:     oct_string = str(oct_string).strip()     if not oct_string:         raise ValueError(\"Empty string was passed to the function\")     is_negative = oct_string[0] == \"-\"     if is_negative:         oct_string = oct_string[1:]     if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):         raise ValueError(\"Non-octal value was passed to the function\")     decimal_number = 0     for char in oct_string:         decimal_number = 8 * decimal_number + int(char)     if is_negative:         decimal_number = -decimal_number     return decimal_number", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value", "output": "def sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value", "tests": ["assert sdbm('Algorithms') == 1462174910723540325254304520539387479031000036", "assert sdbm('scramble bits') == 730247649148944819640658295400555317318720608290373040936089"]}
{"task": "detection", "input": "classify code:\ndef calculate_average_turnaround_time(turnaround_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef base16_encode(inp: str) -> bytes:\n    \"\"\"\n    Encodes a given utf-8 string into base-16.\n\n    >>> base16_encode('Hello World!')\n    b'48656C6C6F20576F726C6421'\n    >>> base16_encode('HELLO WORLD!')\n    b'48454C4C4F20574F524C4421'\n    >>> base16_encode('')\n    b''\n    \"\"\"\n    # encode the input into a bytes-like object and then encode b16encode that\n    return base64.b16encode(inp.encode(\"utf-8\"))", "output": "def base16_encode(data: bytes) -> str:\n    \"\"\"\n    Encodes the given bytes into base16.\n\n    >>> base16_encode(b'Hello World!')\n    '48656C6C6F20576F726C6421'\n    >>> base16_encode(b'HELLO WORLD!')\n    '48454C4C4F20574F524C4421'\n    >>> base16_encode(b'')\n    ''\n    \"\"\"\n    # Turn the data into a list of integers (where each integer is a byte),\n    # Then turn each byte into its hexadecimal representation, make sure\n    # it is uppercase, and then join everything together and return it.\n    return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])", "tests": ["assert base16_encode(b'Hello World!') == '48656C6C6F20576F726C6421'", "assert base16_encode(b'HELLO WORLD!') == '48454C4C4F20574F524C4421'", "assert base16_encode(b'') == ''"]}
{"task": "search", "input": "search code:\nReturns the sum of the digits in the factorial of num\n\nChoices:\n0: def main() -> None:     data_x, _data_y = collect_dataset()      # Number of principal components to retain     n_components = 2      # Apply PCA     transformed_data, variance_ratio = apply_pca(data_x, n_components)      print(\"Transformed Dataset (First 5 rows):\")     print(transformed_data[:5])      print(\"\\nExplained Variance Ratio:\")     print(variance_ratio)\n1: def solution(num: int = 100) -> int:     fact = 1     result = 0     for i in range(1, num + 1):         fact *= i      for j in str(fact):         result += int(j)      return result\n2: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None", "output": "[summary]"}
{"task": "summary", "input": "summarize code:\ndef sum_digits(num: int) -> int:\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum", "output": "Returns the sum of every digit in num."}
{"task": "search", "input": "search code:\nRecursive Backtracking Depth First Search Algorithm\n\nChoices:\n0: def height(root: Node | None) -> int:     return (max(height(root.left), height(root.right)) + 1) if root else 0\n1: def depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:     row_length, col_length = len(grid), len(grid[0])     if (         min(row, col) < 0         or row == row_length         or col == col_length         or (row, col) in visit         or grid[row][col] == 1     ):         return 0     if row == row_length - 1 and col == col_length - 1:         return 1      visit.add((row, col))      count = 0     count += depth_first_search(grid, row + 1, col, visit)     count += depth_first_search(grid, row - 1, col, visit)     count += depth_first_search(grid, row, col + 1, visit)     count += depth_first_search(grid, row, col - 1, visit)      visit.remove((row, col))     return count\n2: def _partition(data: list, pivot) -> tuple:     less, equal, greater = [], [], []     for element in data:         if element < pivot:             less.append(element)         elif element > pivot:             greater.append(element)         else:             equal.append(element)     return less, equal, greater", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef str_eval(s: str) -> int:\n    \"\"\"\n    Returns product of digits in given string n\n\n    >>> str_eval(\"987654321\")\n    362880\n    >>> str_eval(\"22222222\")\n    256\n    \"\"\"\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product", "output": "def str_eval(s: str) -> int:\n    \"\"\"\n    Returns product of digits in given string n\n\n    >>> str_eval(\"987654321\")\n    362880\n    >>> str_eval(\"22222222\")\n    256\n    \"\"\"\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product", "tests": ["assert str_eval(\"987654321\") == 362880", "assert str_eval(\"22222222\") == 256"]}
{"task": "detection", "input": "classify code:\ndef calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\n    \"\"\"\n    Convert molarity to normality.\n      Volume is taken in litres.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n      >>> molarity_to_normality(2, 3.1, 0.31)\n      20\n      >>> molarity_to_normality(4, 11.4, 5.7)\n      8\n    \"\"\"\n    return round(float(moles / volume) * nfactor)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef surface_area_cube(side_length: Union[int, float]) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * pow(side_length, 2)\r", "output": "def surface_area_cube(side_length: float) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * side_length ** 2\r", "tests": ["assert surface_area_cube(1) == 6", "assert surface_area_cube(3) == 54"]}
{"task": "summary", "input": "summarize code:\ndef square_zero_matrix(n: int) -> Matrix:\n    ans: list[list[float]] = [[0] * n for _ in range(n)]\n    return Matrix(ans, n, n)", "output": "returns a square zero-matrix of dimension NxN"}
{"task": "search", "input": "search code:\nFind the path from top left to bottom right of array of numbers\n\nChoices:\n0: def is_bit_set(number: int, position: int) -> bool:     return ((number >> position) & 1) == 1\n1: def charging_inductor(     source_voltage: float,  # source_voltage should be in volts.     resistance: float,  # resistance should be in ohms.     inductance: float,  # inductance should be in henrys.     time: float,  # time should in seconds. ) -> float:      if source_voltage <= 0:         raise ValueError(\"Source voltage must be positive.\")     if resistance <= 0:         raise ValueError(\"Resistance must be positive.\")     if inductance <= 0:         raise ValueError(\"Inductance must be positive.\")     return round(         source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3     )\n2: def min_path_sum(grid: list) -> int:      if not grid or not grid[0]:         raise TypeError(\"The grid does not contain the appropriate information\")      for cell_n in range(1, len(grid[0])):         grid[0][cell_n] += grid[0][cell_n - 1]     row_above = grid[0]      for row_n in range(1, len(grid)):         current_row = grid[row_n]         grid[row_n] = fill_row(current_row, row_above)         row_above = grid[row_n]      return grid[-1][-1]", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef simple_fibonacci(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    fn_1 = f1\n    fn_2 = f2\n    n -= 2\n\n    while n > 0:\n        fn_1, fn_2 = fn_1 + fn_2, fn_1\n        n -= 1\n\n    return fn_1", "output": "def simple_fibonacci(n, f1, f2):\n    \"\"\"\n    Returns the nth number of the Fibonacci sequence that\n    starts with f1 and f2\n    Uses the definition\n    >>> simple_fibonacci(1, 5, 6)\n    5\n    >>> simple_fibonacci(2, 10, 11)\n    11\n    >>> simple_fibonacci(13, 0, 1)\n    144\n    >>> simple_fibonacci(10, 5, 9)\n    411\n    >>> simple_fibonacci(9, 2, 3)\n    89\n    \"\"\"\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    n -= 2\n\n    while n > 0:\n        f2, f1 = f1 + f2, f2\n        n -= 1\n\n    return f2", "tests": ["assert simple_fibonacci(1, 5, 6) == 5", "assert simple_fibonacci(2, 10, 11) == 11", "assert simple_fibonacci(13, 0, 1) == 144", "assert simple_fibonacci(10, 5, 9) == 411", "assert simple_fibonacci(9, 2, 3) == 89"]}
{"task": "summary", "input": "summarize code:\ndef new_generation(cells: list[list[int]]) -> list[list[int]]:\n    next_generation = []\n    for i in range(len(cells)):\n        next_generation_row = []\n        for j in range(len(cells[i])):\n            # Get the number of live neighbours\n            neighbour_count = 0\n            if i > 0 and j > 0:\n                neighbour_count += cells[i - 1][j - 1]\n            if i > 0:\n                neighbour_count += cells[i - 1][j]\n            if i > 0 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i - 1][j + 1]\n            if j > 0:\n                neighbour_count += cells[i][j - 1]\n            if j < len(cells[i]) - 1:\n                neighbour_count += cells[i][j + 1]\n            if i < len(cells) - 1 and j > 0:\n                neighbour_count += cells[i + 1][j - 1]\n            if i < len(cells) - 1:\n                neighbour_count += cells[i + 1][j]\n            if i < len(cells) - 1 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i + 1][j + 1]\n\n            # Rules of the game of life (excerpt from Wikipedia):\n            # 1. Any live cell with two or three live neighbours survives.\n            # 2. Any dead cell with three live neighbours becomes a live cell.\n            # 3. All other live cells die in the next generation.\n            #    Similarly, all other dead cells stay dead.\n            alive = cells[i][j] == 1\n            if (alive and 2 <= neighbour_count <= 3) or (\n                not alive and neighbour_count == 3\n            ):\n                next_generation_row.append(1)\n            else:\n                next_generation_row.append(0)\n\n        next_generation.append(next_generation_row)\n    return next_generation", "output": "Generates the next generation for a given state of Conway's Game of Life."}
{"task": "detection", "input": "classify code:\ndef reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCalculate the depreciation expenses over the given period\n\nChoices:\n0: def is_prime(n: int) -> bool:     return sieve[n]\n1: def triplewise(iterable):     # This deviates from the itertools documentation recipe - see     # https://github.com/more-itertools/more-itertools/issues/889     t1, t2, t3 = tee(iterable, 3)     next(t3, None)     next(t3, None)     next(t2, None)     return zip(t1, t2, t3)\n2: def straight_line_depreciation(     useful_years: int,     purchase_value: float,     residual_value: float = 0.0, ) -> list[float]:      if not isinstance(useful_years, int):         raise TypeError(\"Useful years must be an integer\")      if useful_years < 1:         raise ValueError(\"Useful years cannot be less than 1\")      if not isinstance(purchase_value, (float, int)):         raise TypeError(\"Purchase value must be numeric\")      if not isinstance(residual_value, (float, int)):         raise TypeError(\"Residual value must be numeric\")      if purchase_value < 0.0:         raise ValueError(\"Purchase value cannot be less than zero\")      if purchase_value < residual_value:         raise ValueError(\"Purchase value cannot be less than residual value\")      # Calculate annual depreciation expense     depreciable_cost = purchase_value - residual_value     annual_depreciation_expense = depreciable_cost / useful_years      # List of annual depreciation expenses     list_of_depreciation_expenses = []     accumulated_depreciation_expense = 0.0     for period in range(useful_years):         if period != useful_years - 1:             accumulated_depreciation_expense += annual_depreciation_expense             list_of_depreciation_expenses.append(annual_depreciation_expense)         else:             depreciation_expense_in_end_year = (                 depreciable_cost - accumulated_depreciation_expense             )             list_of_depreciation_expenses.append(depreciation_expense_in_end_year)      return list_of_depreciation_expenses", "output": "2"}
{"task": "search", "input": "search code:\nReturns the last 10 digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.\n\nChoices:\n0: def solution():     total = 0     for i in range(1, 1001):         total += i**i     return str(total)[-10:]\n1: def solution():     total = 0      for i in range(1, 101):         for j in range(1, i + 1):             if combinations(i, j) > 1e6:                 total += 1     return total\n2: def pythagorean_triple(max_perimeter: int) -> typing.Counter[int]:     triplets: typing.Counter[int] = Counter()     for base in range(1, max_perimeter + 1):         for perpendicular in range(base, max_perimeter + 1):             hypotenuse = (base * base + perpendicular * perpendicular) ** 0.5             if hypotenuse == int(hypotenuse):                 perimeter = int(base + perpendicular + hypotenuse)                 if perimeter > max_perimeter:                     continue                 triplets[perimeter] += 1     return triplets", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\n    Args:\n        total_elements (int): The total number of elements.\n        elements_to_choose (int): The number of elements to choose.\n\n    Returns:\n        int: The binomial coefficient C(total_elements, elements_to_choose).\n\n    Examples:\n    >>> _binomial_coefficient(5, 2)\n    10\n    >>> _binomial_coefficient(6, 3)\n    20\n    \"\"\"\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient", "output": "def _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\n    Args:\n        total_elements (int): The total number of elements.\n        elements_to_choose (int): The number of elements to choose.\n\n    Returns:\n        int: The binomial coefficient C(total_elements, elements_to_choose).\n\n    Examples:\n    >>> _binomial_coefficient(5, 2)\n    10\n    >>> _binomial_coefficient(6, 3)\n    20\n    \"\"\"\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient", "tests": ["assert _binomial_coefficient(5, 2) == 10", "assert _binomial_coefficient(6, 3) == 20"]}
{"task": "detection", "input": "classify code:\ndef is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef decimal_to_binary_recursive_helper(decimal: int) -> str:\n    decimal = int(decimal)\n    if decimal in (0, 1):  # Exit cases for the recursion\n        return str(decimal)\n    div, mod = divmod(decimal, 2)\n    return decimal_to_binary_recursive_helper(div) + str(mod)", "output": "Take a positive integer value and return its binary equivalent."}
{"task": "detection", "input": "classify code:\ndef _msd_radix_sort(list_of_ints: List[int], bit_position: int) -> List[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef quick_sort_3partition(sorting: list, left: int, right: int) -> None:\n    if right <= left:\n        return\n    a = i = left\n    b = right\n    pivot = sorting[left]\n    while i <= b:\n        if sorting[i] < pivot:\n            sorting[a], sorting[i] = sorting[i], sorting[a]\n            a += 1\n            i += 1\n        elif sorting[i] > pivot:\n            sorting[b], sorting[i] = sorting[i], sorting[b]\n            b -= 1\n        else:\n            i += 1\n    quick_sort_3partition(sorting, left, a - 1)\n    quick_sort_3partition(sorting, b + 1, right)", "output": "\""}
{"task": "repair", "input": "fix bug:\ndef combination_sum_iv_dp_array(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)", "output": "def combination_sum_iv_dp_array(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)", "tests": ["assert combination_sum_iv_dp_array([1,2,5], 5) == 9"]}
{"task": "search", "input": "search code:\nReturn the median of the input list\n\nChoices:\n0: def split_before(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         if pred(item) and buf:             yield buf             if maxsplit == 1:                 yield [item, *it]                 return             buf = []             maxsplit -= 1         buf.append(item)     if buf:         yield buf\n1: def median_of_five(arr: list) -> int:     arr = sorted(arr)     return arr[len(arr) // 2]\n2: def median_filter(gray_img, mask=3):     # set image borders     bd = int(mask / 2)     # copy image size     median_img = zeros_like(gray_img)     for i in range(bd, gray_img.shape[0] - bd):         for j in range(bd, gray_img.shape[1] - bd):             # get mask according with mask             kernel = ravel(gray_img[i - bd : i + bd + 1, j - bd : j + bd + 1])             # calculate mask median             median = sort(kernel)[int8(divide((multiply(mask, mask)), 2) + 1)]             median_img[i, j] = median     return median_img", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:\n    visited = [False] * len(graph)  # Mark all nodes as not visited\n    queue = []  # breadth-first search queue\n\n    # Source node\n    queue.append(source)\n    visited[source] = True\n\n    while queue:\n        u = queue.pop(0)  # Pop the front node\n        # Traverse all adjacent nodes of u\n        for ind, node in enumerate(graph[u]):\n            if visited[ind] is False and node > 0:\n                queue.append(ind)\n                visited[ind] = True\n                parents[ind] = u\n    return visited[sink]", "output": "This function returns True if there is a node that has not iterated."}
{"task": "search", "input": "search code:\nInput Param:\n\nChoices:\n0: def capture_area(capture_radius: float) -> float:      if capture_radius < 0:         raise ValueError(\"Cannot have a capture radius less than 0\")     sigma = pi * pow(capture_radius, 2)     return round(sigma, 0)\n1: def collapse(iterable, base_type=None, levels=None):     stack = deque()     # Add our first node group, treat the iterable as a single node     stack.appendleft((0, repeat(iterable, 1)))      while stack:         node_group = stack.popleft()         level, nodes = node_group          # Check if beyond max level         if levels is not None and level > levels:             yield from nodes             continue          for node in nodes:             # Check if done iterating             if isinstance(node, (str, bytes)) or (                 (base_type is not None) and isinstance(node, base_type)             ):                 yield node             # Otherwise try to create child nodes             else:                 try:                     tree = iter(node)                 except TypeError:                     yield node                 else:                     # Save our current location                     stack.appendleft(node_group)                     # Append the new child node                     stack.appendleft((level + 1, tree))                     # Break to process child node                     break\n2: def iteration_step(vectors: list[np.ndarray]) -> list[np.ndarray]:     new_vectors = []     for i, start_vector in enumerate(vectors[:-1]):         end_vector = vectors[i + 1]         new_vectors.append(start_vector)         difference_vector = end_vector - start_vector         new_vectors.append(start_vector + difference_vector / 3)         new_vectors.append(             start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)         )         new_vectors.append(start_vector + difference_vector * 2 / 3)     new_vectors.append(vectors[-1])     return new_vectors", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list", "output": "def odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list", "tests": ["assert odd_even_sort([5 , 4 ,3 ,2 ,1]) == [1, 2, 3, 4, 5]", "assert odd_even_sort([]) == []", "assert odd_even_sort([-10 ,-1 ,10 ,2]) == [-10, -1, 2, 10]", "assert odd_even_sort([1 ,2 ,3 ,4]) == [1, 2, 3, 4]"]}
{"task": "detection", "input": "classify code:\ndef find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef longest_prefix(input_str: str) -> int:\n\n    # just returning maximum value of the array gives us answer\n    return max(prefix_function(input_str))", "output": "Prefix-function use case"}
{"task": "search", "input": "search code:\nConversion between pressure units.\n\nChoices:\n0: def continuous_fraction_period(n: int) -> int:     numerator = 0.0     denominator = 1.0     root = int(sqrt(n))     integer_part = root     period = 0     while integer_part != 2 * root:         numerator = denominator * integer_part - numerator         denominator = (n - numerator**2) / denominator         integer_part = int((root + numerator) / denominator)         period += 1     return period\n1: def pressure_conversion(value: float, from_type: str, to_type: str) -> float:     if from_type not in PRESSURE_CONVERSION:         raise ValueError(             f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"             + \", \".join(PRESSURE_CONVERSION)         )     if to_type not in PRESSURE_CONVERSION:         raise ValueError(             f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"             + \", \".join(PRESSURE_CONVERSION)         )     return (         value         * PRESSURE_CONVERSION[from_type].from_factor         * PRESSURE_CONVERSION[to_type].to_factor     )\n2: def is_prime(number: int) -> bool:      # precondition     if not isinstance(number, int) or not number >= 0:         raise ValueError(\"is_prime() only accepts positive integers\")      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "detection", "input": "classify code:\ndef find_min(arr: list[int]) -> int:\n    \"\"\"\n    >>> find_min([1, 2, 3, 4, 5])\n    1\n    >>> find_min([5, 5, 5, 5, 5])\n    5\n    >>> find_min([5, 5, 5, 5])\n    0\n    >>> find_min([3])\n    3\n    >>> find_min([])\n    0\n    \"\"\"\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i - 1][j]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef digit_sum(n: int) -> int:\n    \"\"\"\n    Returns the sum of the digits of the number.\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(456)\n    15\n    >>> digit_sum(78910)\n    25\n    \"\"\"\n    return sum(int(digit) for digit in str(n))", "output": "def digit_sum(n: int) -> int:\n    \"\"\"\n    Returns the sum of the digits of the number.\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(456)\n    15\n    >>> digit_sum(78910)\n    25\n    \"\"\"\n    return sum(int(digit) for digit in str(n))", "tests": ["assert digit_sum(123) == 6", "assert digit_sum(456) == 15", "assert digit_sum(78910) == 25"]}
{"task": "summary", "input": "summarize code:\ndef binary_search(array: list, lower_bound: int, upper_bound: int, value: int) -> int:\n\n    r = int((lower_bound + upper_bound) // 2)\n    if array[r] == value:\n        return r\n    if lower_bound >= upper_bound:\n        return -1\n    if array[r] < value:\n        return binary_search(array, r + 1, upper_bound, value)\n    else:\n        return binary_search(array, lower_bound, r - 1, value)", "output": "This function carries out Binary search on a 1d array and"}
{"task": "detection", "input": "classify code:\ndef is_ip_v4_address_valid(ip: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.256.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"255.256.0.256\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.05\")\n    False\n    \"\"\"\n    octets = ip.split(\".\")\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        if not octet.isdigit():\n            return False\n\n        number = int(octet)\n        if len(str(number)) != len(octet):\n            return False\n\n        if not 0 <= number <= 255:\n            return False\n\n    return True", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef median(nums):\n    \"\"\"Find median of a list of numbers.\"\"\"\n    # Sort list\n    sorted_list = sorted(nums)\n    print(\"List of numbers:\")\n    print(sorted_list)\n\n    # Is number of items in list even?\n    if len(sorted_list) % 2 == 0:\n        # Find index for first middle value.\n        mid_index_1 = len(sorted_list) / 2\n        # Find index for second middle value.\n        mid_index_2 = -(len(sorted_list) / 2) - 1\n        # Divide middle values by 2 to get average (mean).\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n        return med  # Return makes `else:` unnecessary.\n    # Number of items is odd.\n    mid_index = (len(sorted_list) - 1) / 2\n    # Middle index is median.\n    med = sorted_list[mid_index]\n    return med", "output": "def median(nums):\n    \"\"\"\n    Find median of a list of numbers.\n\n    >>> median([0])\n    0\n    >>> median([4,1,3,2])\n    2.5\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    med = None\n    if len(sorted_list) % 2 == 0:\n        mid_index_1 = len(sorted_list) // 2\n        mid_index_2 = (len(sorted_list) // 2) - 1\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n    else:\n        mid_index = (len(sorted_list) - 1) // 2\n        med = sorted_list[mid_index]\n    return med", "tests": ["assert median([0]) == 0", "assert median([4,1,3,2]) == 2.5"]}
{"task": "search", "input": "search code:\nCompresses given data_bits using Lempel-Ziv-Welch compression algorithm\n\nChoices:\n0: def compress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         add_key_to_lexicon(lexicon, curr_string, index, last_match_id)         index += 1         curr_string = \"\"      while curr_string != \"\" and curr_string not in lexicon:         curr_string += \"0\"      if curr_string != \"\":         last_match_id = lexicon[curr_string]         result += last_match_id      return result\n1: def sum_of_digits(num: int, base: int) -> str:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      num_str = int_to_base(num, base)     res = sum(int(char, base) for char in num_str)     res_str = int_to_base(res, base)     return res_str\n2: def split_after(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         buf.append(item)         if pred(item) and buf:             yield buf             if maxsplit == 1:                 buf = list(it)                 if buf:                     yield buf                 return             buf = []             maxsplit -= 1     if buf:         yield buf", "output": "0"}
{"task": "detection", "input": "classify code:\ndef odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFetches a particular translation.\n\nChoices:\n0: def dis_between_closest_in_strip(points, points_counts, min_dis=float(\"inf\")):      for i in range(min(6, points_counts - 1), points_counts):         for j in range(max(0, i - 6), i):             current_dis = euclidean_distance_sqr(points[i], points[j])             min_dis = min(min_dis, current_dis)     return min_dis\n1: def get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:     coefficients = {1}     previous_coefficients = [1]     for _ in range(2, depth + 1):         coefficients_begins_one = [*previous_coefficients, 0]         coefficients_ends_one = [0, *previous_coefficients]         previous_coefficients = []         for x, y in zip(coefficients_begins_one, coefficients_ends_one):             coefficients.add(x + y)             previous_coefficients.append(x + y)     return coefficients\n2: def _pgettext(msgctxt, message):     # This GNU gettext function was added in Python 3.8, so for older versions we     # reimplement it. It works by joining `msgctx` and `message` by '4' byte.     try:         # Python 3.8+         return get_translation().pgettext(msgctxt, message)     except AttributeError:         # Python 3.7 and older         key = msgctxt + \"\\x04\" + message         translation = get_translation().gettext(key)         return message if translation == key else translation", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(n_digits: int = 20) -> int:\n    cache: dict[str, int] = {}\n    return solve(digit=n_digits, prev1=0, prev2=0, sum_max=9, first=True, cache=cache)", "output": "Solves the problem for n_digits number of digits."}
{"task": "repair", "input": "fix bug:\ndef largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We aren't using dp_array here, so the time complexity would be exponential.\n\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]", "output": "def largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We aren't using dp_array here, so the time complexity would be exponential.\n\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]", "tests": ["assert largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]]) == 2", "assert largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]]) == 0"]}
{"task": "search", "input": "search code:\nReturns an integer, the solution to the problem\n\nChoices:\n0: def solution(limit: int = 1_000_000) -> int:      # generating an array from -1 to limit     phi = np.arange(-1, limit)      for i in range(2, limit + 1):         if phi[i] == i - 1:             ind = np.arange(2 * i, limit + 1, i)  # indexes for selection             phi[ind] -= phi[ind] // i      return int(np.sum(phi[2 : limit + 1]))\n1: def odd_even_sort(input_list: list) -> list:     is_sorted = False     while is_sorted is False:  # Until all the indices are traversed keep looping         is_sorted = True         for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices             if input_list[i] > input_list[i + 1]:                 input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]                 # swapping if elements not in order                 is_sorted = False          for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices             if input_list[i] > input_list[i + 1]:                 input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]                 # swapping if elements not in order                 is_sorted = False     return input_list\n2: def decimal_relative_time(d, other=None, ndigits=0, cardinalize=True):     if other is None:         other = datetime.now(timezone.utc).replace(tzinfo=None)     diff = other - d     diff_seconds = timedelta.total_seconds(diff)     abs_diff = abs(diff)     b_idx = bisect.bisect(_BOUND_DELTAS, abs_diff) - 1     bbound, bunit, bname = _BOUNDS[b_idx]     f_diff = diff_seconds / timedelta.total_seconds(bunit)     rounded_diff = round(f_diff, ndigits)     if cardinalize:         return rounded_diff, _cardinalize_time_unit(bname, abs(rounded_diff))     return rounded_diff, bname", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef find_min(arr):\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i][j - 1]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff", "output": "def find_min(arr: list[int]) -> int:\n    \"\"\"\n    >>> find_min([1, 2, 3, 4, 5])\n    1\n    >>> find_min([5, 5, 5, 5, 5])\n    5\n    >>> find_min([5, 5, 5, 5])\n    0\n    >>> find_min([3])\n    3\n    >>> find_min([])\n    0\n    \"\"\"\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i - 1][j]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff", "tests": ["assert find_min([1, 2, 3, 4, 5]) == 1", "assert find_min([5, 5, 5, 5, 5]) == 5", "assert find_min([5, 5, 5, 5]) == 0", "assert find_min([3]) == 3", "assert find_min([]) == 0"]}
{"task": "summary", "input": "summarize code:\ndef is_palindrome(n: int) -> bool:\n    if n % 10 == 0:\n        return False\n    s = str(n)\n    return s == s[::-1]", "output": "Check if an integer is palindromic."}
{"task": "detection", "input": "classify code:\ndef check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nSwap the rows and columns of the input matrix.\n\nChoices:\n0: def transpose(it):     return zip(*it, strict=True)\n1: def analyze_text(text: str) -> tuple[dict, dict]:     single_char_strings = Counter()  # type: ignore[var-annotated]     two_char_strings = Counter()  # type: ignore[var-annotated]     single_char_strings[text[-1]] += 1      # first case when we have space at start.     two_char_strings[\" \" + text[0]] += 1     for i in range(len(text) - 1):         single_char_strings[text[i]] += 1         two_char_strings[text[i : i + 2]] += 1     return single_char_strings, two_char_strings\n2: def is_contains_unique_chars(input_str: str) -> bool:      # Each bit will represent each unicode character     # For example 65th bit representing 'A'     # https://stackoverflow.com/a/12811293     bitmap = 0     for ch in input_str:         ch_unicode = ord(ch)         ch_bit_index_on = pow(2, ch_unicode)          # If we already turned on bit for current character's unicode         if bitmap >> ch_unicode & 1 == 1:             return False         bitmap |= ch_bit_index_on     return True", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef combination_sum_iv(array: list[int], target: int) -> int:\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)", "output": "Function checks the all possible combinations, and returns the count"}
{"task": "repair", "input": "fix bug:\ndef bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1", "output": "def bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1", "tests": ["assert bitap_string_match('abdabababc', 'ababc') == 5", "assert bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a') == 0", "assert bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso') == 0", "assert bitap_string_match('abdabababc', '') == 0", "assert bitap_string_match('abdabababc', 'c') == 9", "assert bitap_string_match('abdabababc', 'fofosdfo') == -1", "assert bitap_string_match('abdab', 'fofosdfo') == -1"]}
{"task": "detection", "input": "classify code:\ndef check_anagrams(a: str, b: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return sorted(a.lower()) == sorted(b.lower())\r", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef generate_all_combinations(n: int, k: int) -> list[list[int]]:\n    if k < 0:\n        raise ValueError(\"k must not be negative\")\n    if n < 0:\n        raise ValueError(\"n must not be negative\")\n\n    result: list[list[int]] = []\n    create_all_state(1, n, k, [], result)\n    return result", "output": "Generates all possible combinations of k numbers out of 1 ... n using backtracking."}
{"task": "detection", "input": "classify code:\ndef solve(nums: list[int], goal: int, depth: int) -> bool:\n    \"\"\"\n    Checks if nums can have a sum equal to goal, given that length of nums does\n    not exceed depth.\n\n    >>> solve([1], 2, 2)\n    True\n    >>> solve([1], 2, 0)\n    False\n    \"\"\"\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "output": "def calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "tests": ["assert calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3]) == [1, 3, 6]", "assert calculate_turn_around_times([10, 3, 7], [10, 6, 11]) == [20, 9, 18]"]}
{"task": "search", "input": "search code:\nChecks for length of barcode and last-digit\n\nChoices:\n0: def dis_between_closest_in_strip(points, points_counts, min_dis=float(\"inf\")):      for i in range(min(6, points_counts - 1), points_counts):         for j in range(max(0, i - 6), i):             current_dis = euclidean_distance_sqr(points[i], points[j])             min_dis = min(min_dis, current_dis)     return min_dis\n1: def solution(length: int = 50) -> int:      ways_number = [1] * (length + 1)      for row_length in range(3, length + 1):         for block_length in range(3, row_length + 1):             for block_start in range(row_length - block_length):                 ways_number[row_length] += ways_number[                     row_length - block_start - block_length - 1                 ]              ways_number[row_length] += 1      return ways_number[length]\n2: def is_valid(barcode: int) -> bool:     return len(str(barcode)) == 13 and get_check_digit(barcode) == barcode % 10", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef find_set(x: Node) -> Node:\n    if x != x.parent:\n        x.parent = find_set(x.parent)\n    return x.parent", "output": "Return the parent of x"}
{"task": "search", "input": "search code:\nCheck if three points are collinear or not.\n\nChoices:\n0: def main() -> None:     kmap = [[0, 1], [1, 1]]      # Manually generate the product of [0, 1] and [0, 1]      for row in kmap:         print(row)      print(\"Simplified Expression:\")     print(simplify_kmap(kmap))\n1: def are_collinear(a: Point3d, b: Point3d, c: Point3d, accuracy: int = 10) -> bool:     ab = create_vector(a, b)     ac = create_vector(a, c)     return is_zero_vector(get_3d_vectors_cross(ab, ac), accuracy)\n2: def calculate_fft(audio_windowed: np.ndarray, ftt_size: int = 1024) -> np.ndarray:     # Transpose the audio data to have time in rows and channels in columns     audio_transposed = np.transpose(audio_windowed)      # Initialize an array to store the FFT results     audio_fft = np.empty(         (int(1 + ftt_size // 2), audio_transposed.shape[1]),         dtype=np.complex64,         order=\"F\",     )      # Compute FFT for each channel     for n in range(audio_fft.shape[1]):         audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]      # Transpose the FFT results back to the original shape     return np.transpose(audio_fft)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "tests": ["assert is_complete([[1]]) == True", "assert is_complete([[1, 2], [3, 0]]) == False"]}
{"task": "detection", "input": "classify code:\ndef n31(a: int) -> tuple[list[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the biggest prime, below the celing, that can be written as the sum\n\nChoices:\n0: def heaps(arr: list) -> list:      if len(arr) <= 1:         return [tuple(arr)]      res = []      def generate(n: int, arr: list):         c = [0] * n         res.append(tuple(arr))          i = 0         while i < n:             if c[i] < i:                 if i % 2 == 0:                     arr[0], arr[i] = arr[i], arr[0]                 else:                     arr[c[i]], arr[i] = arr[i], arr[c[i]]                 res.append(tuple(arr))                 c[i] += 1                 i = 0             else:                 c[i] = 0                 i += 1      generate(len(arr), arr)     return res\n1: def add_file_length(source_path: str, compressed: str) -> str:     file_length = os.path.getsize(source_path)     file_length_binary = bin(file_length)[2:]     length_length = len(file_length_binary)      return \"0\" * (length_length - 1) + file_length_binary + compressed\n2: def solution(ceiling: int = 1_000_000) -> int:     primes = prime_sieve(ceiling)     length = 0     largest = 0      for i in range(len(primes)):         for j in range(i + length, len(primes)):             sol = sum(primes[i:j])             if sol >= ceiling:                 break              if sol in primes:                 length = j - i                 largest = sol      return largest", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000000):\n    total = 0\n\n    for i in range(1, n):\n        if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):\n            total += i\n    return total", "output": "Return the sum of all numbers, less than n , which are palindromic in"}
{"task": "repair", "input": "fix bug:\ndef longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]", "output": "def longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]", "tests": ["assert longest_palindromic_subsequence(\"bbbab\") == 4", "assert longest_palindromic_subsequence(\"bbabcbcab\") == 7"]}
{"task": "summary", "input": "summarize code:\ndef freq_subgraphs_edge_list(paths):\n    freq_sub_el = []\n    for edges in paths:\n        el = []\n        for j in range(len(edges) - 1):\n            temp = list(edges[j])\n            for e in temp:\n                edge = (e[0], e[1])\n                el.append(edge)\n        freq_sub_el.append(el)\n    return freq_sub_el", "output": "returns Edge list for frequent subgraphs"}
{"task": "detection", "input": "classify code:\ndef evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nThis will check whether a given password is strong or not. The password must be at\n\nChoices:\n0: def is_strong_password(password: str, min_length: int = 8) -> bool:      if len(password) < min_length:         return False      upper = any(char in ascii_uppercase for char in password)     lower = any(char in ascii_lowercase for char in password)     num = any(char in digits for char in password)     spec_char = any(char in punctuation for char in password)      return upper and lower and num and spec_char\n1: def city_select(     pheromone: list[list[float]],     current_city: dict[int, list[int]],     unvisited_cities: dict[int, list[int]],     alpha: float,     beta: float, ) -> tuple[dict[int, list[int]], dict[int, list[int]]]:     probabilities = []     for city, value in unvisited_cities.items():         city_distance = distance(value, next(iter(current_city.values())))         probability = (pheromone[city][next(iter(current_city.keys()))] ** alpha) * (             (1 / city_distance) ** beta         )         probabilities.append(probability)      chosen_city_i = random.choices(         list(unvisited_cities.keys()), weights=probabilities     )[0]     chosen_city = {chosen_city_i: unvisited_cities[chosen_city_i]}     del unvisited_cities[next(iter(chosen_city.keys()))]     return chosen_city, unvisited_cities\n2: def kth_number(lst: list[int], k: int) -> int:     # pick a pivot and separate into list based on pivot.     pivot = random_pivot(lst)      # partition based on pivot     # linear time     small = [e for e in lst if e < pivot]     big = [e for e in lst if e > pivot]      # if we get lucky, pivot might be the element we want.     # we can easily see this:     # small (elements smaller than k)     # + pivot (kth element)     # + big (elements larger than k)     if len(small) == k - 1:         return pivot     # pivot is in elements bigger than k     elif len(small) < k - 1:         return kth_number(big, k - len(small) - 1)     # pivot is in elements smaller than k     else:         return kth_number(small, k)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef _msd_radix_sort(list_of_ints: List[int], bit_position: int) -> List[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res", "output": "def _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res", "tests": ["assert _msd_radix_sort([45, 2, 32], 1) == [2, 32, 45]", "assert _msd_radix_sort([10, 4, 12], 2) == [4, 12, 10]"]}
{"task": "repair", "input": "fix bug:\ndef is_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)", "output": "def is_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)", "tests": ["assert is_pangram_faster(\"The quick brown fox jumps over the lazy dog\") == True", "assert is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\") == True", "assert is_pangram_faster(\"Jived fox nymph grabs quick waltz.\") == True", "assert is_pangram_faster(\"The quick brown fox jumps over the la_y dog\") == False", "assert is_pangram_faster() == True"]}
{"task": "detection", "input": "classify code:\ndef is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef cardinalize(unit_noun, count):\n    if count == 1:\n        return unit_noun\n    return pluralize(unit_noun)", "output": "Conditionally pluralizes a singular word *unit_noun* if"}
{"task": "search", "input": "search code:\nPreprocess the edge array\n\nChoices:\n0: def preprocess(edge_array):     for i in range(len(edge_array)):         for j in range(len(edge_array[i])):             t = edge_array[i][j].split(\"-\")             edge_array[i][j] = t\n1: def tf_idf(tf: int, idf: int) -> float:     return round(tf * idf, 3)\n2: def maximum_non_adjacent_sum(nums: list[int]) -> int:     if not nums:         return 0     max_including = nums[0]     max_excluding = 0     for num in nums[1:]:         max_including, max_excluding = (             max_excluding + num,             max(max_including, max_excluding),         )     return max(max_excluding, max_including)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef concurrent_tee(iterable, n=2):\n\n    if n < 0:\n        raise ValueError\n    if n == 0:\n        return ()\n    iterator = _concurrent_tee(iterable)\n    result = [iterator]\n    for _ in range(n - 1):\n        result.append(_concurrent_tee(iterator))\n    return tuple(result)", "output": "Variant of itertools.tee() but with guaranteed threading semantics."}
{"task": "search", "input": "search code:\nInverse Discrete Fourier Transform. *Xarr* is a sequence of\n\nChoices:\n0: def is_valid(barcode: int) -> bool:     return len(str(barcode)) == 13 and get_check_digit(barcode) == barcode % 10\n1: def main():     if len(sys.argv) < 3:         print(\"2 integer arguments required\")         return 1     a = int(sys.argv[1])     b = int(sys.argv[2])     print(extended_euclidean_algorithm(a, b))     return 0\n2: def idft(Xarr):     N = len(Xarr)     roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]     for k in range(N):         coeffs = [roots_of_unity[k * n % N] for n in range(N)]         yield _complex_sumprod(Xarr, coeffs) / N", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef merge_insertion_sort(collection: List[int]) -> List[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result", "output": "def merge_insertion_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result", "tests": ["assert merge_insertion_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]", "assert merge_insertion_sort([99]) == [99]", "assert merge_insertion_sort([-2, -5, -45]) == [-45, -5, -2]"]}
{"task": "detection", "input": "classify code:\ndef abs_max(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j", "output": "CORRECT"}
