{"task": "summary", "input": "summarize code:\ndef newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force", "output": "Calculates force from `mass` and `acceleration`"}
{"task": "search", "input": "search code:\nReturn the how many times the predicate is true.\n\nChoices:\n0: def quantify(iterable, pred=bool):     return sum(map(pred, iterable))\n1: def find_repeat(     matrix_g: list[list[str]], row: int, column: int, size: int ) -> set[tuple[int, int]]:      column = size - 1 - column     visited = set()     repeated = set()      if (color := matrix_g[column][row]) != \"-\":          def dfs(row_n: int, column_n: int) -> None:             if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:                 return             if (row_n, column_n) in visited:                 return             visited.add((row_n, column_n))             if matrix_g[row_n][column_n] == color:                 repeated.add((row_n, column_n))                 dfs(row_n - 1, column_n)                 dfs(row_n + 1, column_n)                 dfs(row_n, column_n - 1)                 dfs(row_n, column_n + 1)          dfs(column, row)      return repeated\n2: def harshad_numbers_in_base(limit: int, base: int) -> list[str]:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      if limit < 0:         return []      numbers = [         int_to_base(i, base)         for i in range(1, limit)         if i % int(sum_of_digits(i, base), base) == 0     ]      return numbers", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef is_carmichael_number(n: int) -> bool:\n\n    if n <= 0 or not isinstance(n, int):\n        msg = f\"Number {n} must instead be a positive integer\"\n        raise ValueError(msg)\n\n    return all(\n        power(b, n - 1, n) == 1\n        for b in range(2, n)\n        if greatest_common_divisor(b, n) == 1\n    )", "output": "Examples:"}
{"task": "search", "input": "search code:\nChange the brightness of a PIL Image to a given level.\n\nChoices:\n0: def change_brightness(img: Image, level: float) -> Image:      def brightness(c: int) -> float:         return 128 + level + (c - 128)      if not -255.0 <= level <= 255.0:         raise ValueError(\"level must be between -255.0 (black) and 255.0 (white)\")     return img.point(brightness)\n1: def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:     arr.sort()     n = len(arr)     for i in range(n - 1):         left, right = i + 1, n - 1         while left < right:             if arr[i] + arr[left] + arr[right] == target:                 return (arr[i], arr[left], arr[right])             elif arr[i] + arr[left] + arr[right] < target:                 left += 1             elif arr[i] + arr[left] + arr[right] > target:                 right -= 1     return (0, 0, 0)\n2: def power(x: int, y: int, mod: int) -> int:      if y == 0:         return 1     temp = power(x, y // 2, mod) % mod     temp = (temp * temp) % mod     if y % 2 == 1:         temp = (temp * x) % mod     return temp", "output": "0"}
{"task": "search", "input": "search code:\nSolve the Fractional Cover Problem.\n\nChoices:\n0: def split_after(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         buf.append(item)         if pred(item) and buf:             yield buf             if maxsplit == 1:                 buf = list(it)                 if buf:                     yield buf                 return             buf = []             maxsplit -= 1     if buf:         yield buf\n1: def reverse_words(input_str: str) -> str:     return \" \".join(input_str.split()[::-1])\n2: def fractional_cover(items: list[Item], capacity: int) -> float:     if capacity < 0:         raise ValueError(\"Capacity cannot be negative\")      total_value = 0.0     remaining_capacity = capacity      # Sort the items by their value-to-weight ratio in descending order     for item in sorted(items, key=attrgetter(\"ratio\"), reverse=True):         if remaining_capacity == 0:             break          weight_taken = min(item.weight, remaining_capacity)         total_value += weight_taken * item.ratio         remaining_capacity -= weight_taken      return total_value", "output": "2"}
{"task": "search", "input": "search code:\nReturns the millionth lexicographic permutation of the digits 0, 1, 2,\n\nChoices:\n0: def solution():     result = list(map(\"\".join, permutations(\"0123456789\")))     return result[999999]\n1: def all_equal(iterable, key=None):     iterator = groupby(iterable, key)     for first in iterator:         for second in iterator:             return False         return True     return True\n2: def or_gate(input_1: int, input_2: int) -> int:     return int((input_1, input_2).count(1) != 0)", "output": "0"}
{"task": "search", "input": "search code:\nCopy formatargspec from python 3.7 standard library.\n\nChoices:\n0: def solution(length: int = 50) -> int:      different_colour_ways_number = [[0] * 3 for _ in range(length + 1)]      for row_length in range(length + 1):         for tile_length in range(2, 5):             for tile_start in range(row_length - tile_length + 1):                 different_colour_ways_number[row_length][tile_length - 2] += (                     different_colour_ways_number[row_length - tile_start - tile_length][                         tile_length - 2                     ]                     + 1                 )      return sum(different_colour_ways_number[length])\n1: def inspect_formatargspec(         args, varargs=None, varkw=None, defaults=None,         kwonlyargs=(), kwonlydefaults={}, annotations={},         formatarg=str,         formatvarargs=lambda name: '*' + name,         formatvarkw=lambda name: '**' + name,         formatvalue=lambda value: '=' + repr(value),         formatreturns=lambda text: ' -> ' + text,         formatannotation=formatannotation):      def formatargandannotation(arg):         result = formatarg(arg)         if arg in annotations:             result += ': ' + formatannotation(annotations[arg])         return result     specs = []     if defaults:         firstdefault = len(args) - len(defaults)     for i, arg in enumerate(args):         spec = formatargandannotation(arg)         if defaults and i >= firstdefault:             spec = spec + formatvalue(defaults[i - firstdefault])         specs.append(spec)     if varargs is not None:         specs.append(formatvarargs(formatargandannotation(varargs)))     else:         if kwonlyargs:             specs.append('*')     if kwonlyargs:         for kwonlyarg in kwonlyargs:             spec = formatargandannotation(kwonlyarg)             if kwonlydefaults and kwonlyarg in kwonlydefaults:                 spec += formatvalue(kwonlydefaults[kwonlyarg])             specs.append(spec)     if varkw is not None:         specs.append(formatvarkw(formatargandannotation(varkw)))     result = '(' + ', '.join(specs) + ')'     if 'return' in annotations:         result += formatreturns(formatannotation(annotations['return']))     return result\n2: def slow_solution(max_power: int = 9) -> int:     result = 0     for length in range(1, max_power + 1):         result += slow_reversible_numbers(length, 0, [0] * length, length)     return result", "output": "1"}
{"task": "detection", "input": "classify code:\ndef spiral_traversal(matrix: list[list]) -> list[int]:\n    \"\"\"\n    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n    Example:\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    Algorithm:\n        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n                output of [step 2])\n        Step 2. Now perform matrix's Transpose operation (Change rows to column\n                and vice versa) and reverse the resultant matrix.\n        Step 3. Pass the output of [2nd step], to same recursive function till\n                base case hits.\n    Dry Run:\n    Stage 1.\n    [1, 2, 3, 4] +   spiral_traversal([\n        [8, 12], [7, 11], [6, 10], [5, 9]]\n     ])\n    Stage 2.\n    [1, 2, 3, 4, 8, 12] + spiral_traversal([\n        [11, 10, 9], [7, 6, 5]\n    ])\n    Stage 3.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 4.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 5.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\n    Stage 6.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])\n    \"\"\"\n    if matrix:\n        return list(matrix.pop(0)) + spiral_traversal(\n            [list(row) for row in zip(*matrix)][::-1]\n        )\n    else:\n        return []", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef binary_exp_mod_iterative(base: float, exponent: int, modulus: int) -> float:\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer\")\n\n    res: int | float = 1\n    while exponent > 0:\n        if exponent & 1:\n            res = ((res % modulus) * (base % modulus)) % modulus\n\n        base *= base\n        exponent >>= 1\n\n    return res", "output": "Computes a^b % c iteratively, where a is the base, b is the exponent, and c is the"}
{"task": "search", "input": "search code:\nImplements the SquarePlus activation function.\n\nChoices:\n0: def squareplus(vector: np.ndarray, beta: float) -> np.ndarray:     return (vector + np.sqrt(vector**2 + beta)) / 2\n1: def binary_tree_count(node_count: int) -> int:     return catalan_number(node_count) * factorial(node_count)\n2: def solution():     script_dir = os.path.dirname(os.path.realpath(__file__))     words_file_path = os.path.join(script_dir, \"words.txt\")      words = \"\"     with open(words_file_path) as f:         words = f.readline()      words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]     words = [         word         for word in [sum(ord(x) - 64 for x in word) for word in words]         if word in TRIANGULAR_NUMBERS     ]     return len(words)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(chain_length: int = 60, number_limit: int = 1000000) -> int:\n\n    if not isinstance(chain_length, int) or not isinstance(number_limit, int):\n        raise TypeError(\"Parameters chain_length and number_limit must be int\")\n\n    if chain_length <= 0 or number_limit <= 0:\n        raise ValueError(\n            \"Parameters chain_length and number_limit must be greater than 0\"\n        )\n\n    # the counter for the chains with the exact desired length\n    chains_counter = 0\n    # the cached sizes of the previous chains\n    chain_sets_lengths: dict[int, int] = {}\n\n    for start_chain_element in range(1, number_limit):\n        # The temporary set will contain the elements of the chain\n        chain_set = set()\n        chain_set_length = 0\n\n        # Stop computing the chain when you find a cached size, a repeating item or the\n        # length is greater then the desired one.\n        chain_element = start_chain_element\n        while (\n            chain_element not in chain_sets_lengths\n            and chain_element not in chain_set\n            and chain_set_length <= chain_length\n        ):\n            chain_set.add(chain_element)\n            chain_set_length += 1\n            chain_element = digit_factorial_sum(chain_element)\n\n        if chain_element in chain_sets_lengths:\n            chain_set_length += chain_sets_lengths[chain_element]\n\n        chain_sets_lengths[start_chain_element] = chain_set_length\n\n        # If chain contains the exact amount of elements increase the counter\n        if chain_set_length == chain_length:\n            chains_counter += 1\n\n    return chains_counter", "output": "Returns the number of numbers below number_limit that produce chains with exactly"}
{"task": "summary", "input": "summarize code:\ndef _det(a: Point, b: Point, c: Point) -> float:\n\n    det = (a.x * b.y + b.x * c.y + c.x * a.y) - (a.y * b.x + b.y * c.x + c.y * a.x)\n    return det", "output": "Computes the sign perpendicular distance of a 2d point c from a line segment"}
{"task": "search", "input": "search code:\nAn isogram is a word in which no letter is repeated.\n\nChoices:\n0: def is_isogram(string: str) -> bool:     if not all(x.isalpha() for x in string):         raise ValueError(\"String must only contain alphabetic characters.\")      letters = sorted(string.lower())     return len(letters) == len(set(letters))\n1: def largest_rectangle_area(heights: list[int]) -> int:     stack: list[int] = []     max_area = 0     heights = [*heights, 0]  # make a new list by appending the sentinel 0     n = len(heights)      for i in range(n):         # make sure the stack remains in increasing order         while stack and heights[i] < heights[stack[-1]]:             h = heights[stack.pop()]  # height of the bar             # if stack is empty, it means entire width can be taken from index 0 to i-1             w = i if not stack else i - stack[-1] - 1  # calculate width             max_area = max(max_area, h * w)          stack.append(i)      return max_area\n2: def update(highway_now: list, probability: float, max_speed: int) -> list:      number_of_cells = len(highway_now)     # Beforce calculations, the highway is empty     next_highway = [-1] * number_of_cells      for car_index in range(number_of_cells):         if highway_now[car_index] != -1:             # Add 1 to the current speed of the car and cap the speed             next_highway[car_index] = min(highway_now[car_index] + 1, max_speed)             # Number of empty cell before the next car             dn = get_distance(highway_now, car_index) - 1             # We can't have the car causing an accident             next_highway[car_index] = min(next_highway[car_index], dn)             if random() < probability:                 # Randomly, a driver will slow down                 next_highway[car_index] = max(next_highway[car_index] - 1, 0)     return next_highway", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef loops(n):\n    return repeat(None, n)", "output": "Returns an iterable with *n* elements for efficient looping."}
{"task": "search", "input": "search code:\nPlots of whether the absolute value of z_final is greater than\n\nChoices:\n0: def show_results(     function_label: str,     function_params: Any,     escape_radius: float,     z_final: np.ndarray, ) -> None:      abs_z_final = (abs(z_final)).transpose()     abs_z_final[:, :] = abs_z_final[::-1, :]     plt.matshow(abs_z_final < escape_radius)     plt.title(f\"Julia set of ${function_label}$, $c={function_params}$\")     plt.show()\n1: def main():     print(\"Volumes:\")     print(f\"Cube: {vol_cube(2) = }\")  # = 8     print(f\"Cuboid: {vol_cuboid(2, 2, 2) = }\")  # = 8     print(f\"Cone: {vol_cone(2, 2) = }\")  # ~= 1.33     print(f\"Right Circular Cone: {vol_right_circ_cone(2, 2) = }\")  # ~= 8.38     print(f\"Prism: {vol_prism(2, 2) = }\")  # = 4     print(f\"Pyramid: {vol_pyramid(2, 2) = }\")  # ~= 1.33     print(f\"Sphere: {vol_sphere(2) = }\")  # ~= 33.5     print(f\"Hemisphere: {vol_hemisphere(2) = }\")  # ~= 16.75     print(f\"Circular Cylinder: {vol_circular_cylinder(2, 2) = }\")  # ~= 25.1     print(f\"Torus: {vol_torus(2, 2) = }\")  # ~= 157.9     print(f\"Conical Frustum: {vol_conical_frustum(2, 2, 4) = }\")  # ~= 58.6     print(f\"Spherical cap: {vol_spherical_cap(1, 2) = }\")  # ~= 5.24     print(f\"Spheres intersection: {vol_spheres_intersect(2, 2, 1) = }\")  # ~= 21.21     print(f\"Spheres union: {vol_spheres_union(2, 2, 1) = }\")  # ~= 45.81     print(         f\"Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }\"     )  # ~= 28.3     print(f\"Icosahedron: {vol_icosahedron(2.5) = }\")  # ~=34.09\n2: def hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:      # Initialize path with -1, indicating that we have not visited them yet     path = [-1] * (len(graph) + 1)     # initialize start and end of path with starting index     path[0] = path[-1] = start_index     # evaluate and if we find answer return path either return empty array     return path if util_hamilton_cycle(graph, path, 1) else []", "output": "0"}
{"task": "search", "input": "search code:\ninput: size (N) of the vector.\n\nChoices:\n0: def sigmoid_derivative(value: np.ndarray) -> np.ndarray:     return (value) * (1 - (value))\n1: def vol_cube(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"vol_cube() only accepts non-negative values\")     return pow(side_length, 3)\n2: def random_vector(n: int, a: int, b: int) -> Vector:     random.seed(None)     ans = [random.randint(a, b) for _ in range(n)]     return Vector(ans)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef twos_complement(number: int) -> str:\n    if number > 0:\n        raise ValueError(\"input must be a negative integer\")\n    binary_number_length = len(bin(number)[3:])\n    twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]\n    twos_complement_number = (\n        (\n            \"1\"\n            + \"0\" * (binary_number_length - len(twos_complement_number))\n            + twos_complement_number\n        )\n        if number < 0\n        else \"0\"\n    )\n    return \"0b\" + twos_complement_number", "output": "Take in a negative integer 'number'."}
{"task": "search", "input": "search code:\nRunning Markov Chain algorithm and calculating the number of times each node is\n\nChoices:\n0: def get_transitions(     start: str, transitions: list[tuple[str, str, float]], steps: int ) -> dict[str, int]:      graph = MarkovChainGraphUndirectedUnweighted()      for node1, node2, probability in transitions:         graph.add_transition_probability(node1, node2, probability)      visited = Counter(graph.get_nodes())     node = start      for _ in range(steps):         node = graph.transition(node)         visited[node] += 1      return visited\n1: def strip_iter(iterable, strip_value=None):     return rstrip_iter(lstrip_iter(iterable, strip_value), strip_value)\n2: def get_set_bits_count_using_modulo_operator(number: int) -> int:     if number < 0:         raise ValueError(\"the value of input must not be negative\")     result = 0     while number:         if number % 2 == 1:             result += 1         number >>= 1     return result", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef display(values):\n    width = 1 + max(len(values[s]) for s in squares)\n    line = \"+\".join([\"-\" * (width * 3)] * 3)\n    for r in rows:\n        print(\n            \"\".join(\n                values[r + c].center(width) + (\"|\" if c in \"36\" else \"\") for c in cols\n            )\n        )\n        if r in \"CF\":\n            print(line)\n    print()", "output": "Display these values as a 2-D grid."}
{"task": "search", "input": "search code:\nJust recursive print of a tree\n\nChoices:\n0: def inorder(root: Node | None) -> None:     if not root:  # None         return     else:         inorder(root.left)         print(root.value, end=\",\")         inorder(root.right)\n1: def simple_moving_average(     data: Sequence[float], window_size: int ) -> list[float | None]:     if window_size < 1:         raise ValueError(\"Window size must be a positive integer\")      sma: list[float | None] = []      for i in range(len(data)):         if i < window_size - 1:             sma.append(None)  # SMA not available for early data points         else:             window = data[i - window_size + 1 : i + 1]             sma_value = sum(window) / window_size             sma.append(sma_value)     return sma\n2: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")      for value in (262144, 1125899906842624, 1267650600228229401496703205376):         for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):             benchmark_a_function(func, value)         print()", "output": "0"}
{"task": "search", "input": "search code:\nLoop through every character in the data and add to two sums.\n\nChoices:\n0: def fib_iterative_yield(n: int) -> Iterator[int]:     if n < 0:         raise ValueError(\"n is negative\")     a, b = 0, 1     yield a     for _ in range(n):         yield b         a, b = b, a + b\n1: def fletcher16(text: str) -> int:     data = bytes(text, \"ascii\")     sum1 = 0     sum2 = 0     for character in data:         sum1 = (sum1 + character) % 255         sum2 = (sum1 + sum2) % 255     return (sum2 << 8) | sum1\n2: def mse(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     square_diff = np.square(difference)      score = square_diff.mean()     return score", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef singularize(word):\n    orig_word, word = word, word.strip().lower()\n    if not word or word in _IRR_S2P:\n        return orig_word\n\n    irr_singular = _IRR_P2S.get(word)\n    if irr_singular:\n        singular = irr_singular\n    elif not word.endswith('s'):\n        return orig_word\n    elif len(word) == 2:\n        singular = word[:-1]  # or just return word?\n    elif word.endswith('ies') and word[-4:-3] not in 'aeiou':\n        singular = word[:-3] + 'y'\n    elif word.endswith('es') and word[-3] == 's':\n        singular = word[:-2]\n    else:\n        singular = word[:-1]\n    return _match_case(orig_word, singular)", "output": "Semi-intelligently converts an English plural *word* to its"}
{"task": "search", "input": "search code:\nConstructs the tridiagonal matrix and orthonormal basis vectors using the\n\nChoices:\n0: def lanczos_iteration(     graph: list[list[int | None]], num_eigenvectors: int ) -> tuple[np.ndarray, np.ndarray]:     num_nodes: int = len(graph)     if not (1 <= num_eigenvectors <= num_nodes):         raise ValueError(             \"Number of eigenvectors must be between 1 and the number of \"             \"nodes in the graph.\"         )      orthonormal_basis: np.ndarray = np.zeros((num_nodes, num_eigenvectors))     tridiagonal_matrix: np.ndarray = np.zeros((num_eigenvectors, num_eigenvectors))      rng = np.random.default_rng()     initial_vector: np.ndarray = rng.random(num_nodes)     initial_vector /= np.sqrt(np.dot(initial_vector, initial_vector))     orthonormal_basis[:, 0] = initial_vector      prev_beta: float = 0.0     for iter_index in range(num_eigenvectors):         result_vector: np.ndarray = multiply_matrix_vector(             graph, orthonormal_basis[:, iter_index]         )         if iter_index > 0:             result_vector -= prev_beta * orthonormal_basis[:, iter_index - 1]         alpha_value: float = np.dot(orthonormal_basis[:, iter_index], result_vector)         result_vector -= alpha_value * orthonormal_basis[:, iter_index]          prev_beta = np.sqrt(np.dot(result_vector, result_vector))         if iter_index < num_eigenvectors - 1 and prev_beta > 1e-10:             orthonormal_basis[:, iter_index + 1] = result_vector / prev_beta         tridiagonal_matrix[iter_index, iter_index] = alpha_value         if iter_index < num_eigenvectors - 1:             tridiagonal_matrix[iter_index, iter_index + 1] = prev_beta             tridiagonal_matrix[iter_index + 1, iter_index] = prev_beta     return tridiagonal_matrix, orthonormal_basis\n1: def power(x: int, y: int, mod: int) -> int:      if y == 0:         return 1     temp = power(x, y // 2, mod) % mod     temp = (temp * temp) % mod     if y % 2 == 1:         temp = (temp * x) % mod     return temp\n2: def nth_prime(n, *, approximate=False):     lb, ub = _nth_prime_bounds(n + 1)      if not approximate or n <= 1_000_000:         return nth(sieve(ceil(ub)), n)      # Search from the midpoint and return the first odd prime     odd = floor((lb + ub) / 2) | 1     return first_true(count(odd, step=2), pred=is_prime)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n\n    return len_board * len_board_column * row + column", "output": "Returns the hash key of matrix indexes."}
{"task": "search", "input": "search code:\nPure implementation of counting sort algorithm in Python\n\nChoices:\n0: def evaluate(item: str, main_target: str) -> tuple[str, float]:     score = len([g for position, g in enumerate(item) if g == main_target[position]])     return (item, float(score))\n1: def stalin_sort(sequence: list[int]) -> list[int]:     result = [sequence[0]]     for element in sequence[1:]:         if element >= result[-1]:             result.append(element)      return result\n2: def counting_sort(collection):     # if the collection is empty, returns empty     if collection == []:         return []      # get some information about the collection     coll_len = len(collection)     coll_max = max(collection)     coll_min = min(collection)      # create the counting array     counting_arr_length = coll_max + 1 - coll_min     counting_arr = [0] * counting_arr_length      # count how much a number appears in the collection     for number in collection:         counting_arr[number - coll_min] += 1      # sum each position with it's predecessors. now, counting_arr[i] tells     # us how many elements <= i has in the collection     for i in range(1, counting_arr_length):         counting_arr[i] = counting_arr[i] + counting_arr[i - 1]      # create the output collection     ordered = [0] * coll_len      # place the elements in the output, respecting the original order (stable     # sort) from end to begin, updating counting_arr     for i in reversed(range(coll_len)):         ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]         counting_arr[collection[i] - coll_min] -= 1      return ordered", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef mutate(child: str, genes: list[str]) -> str:\n    child_list = list(child)\n    if random.uniform(0, 1) < MUTATION_PROBABILITY:\n        child_list[random.randint(0, len(child)) - 1] = random.choice(genes)\n    return \"\".join(child_list)", "output": "Mutate a random gene of a child with another one from the list."}
{"task": "search", "input": "search code:\nGenerates a string of roman numerals for a given integer.\n\nChoices:\n0: def solution(limit: int = 999_966_663_333) -> int:     primes_upper_bound = math.floor(math.sqrt(limit)) + 100     primes = prime_sieve(primes_upper_bound)      matches_sum = 0     prime_index = 0     last_prime = primes[prime_index]      while (last_prime**2) <= limit:         next_prime = primes[prime_index + 1]          lower_bound = last_prime**2         upper_bound = next_prime**2          # Get numbers divisible by lps(current)         current = lower_bound + last_prime         while upper_bound > current <= limit:             matches_sum += current             current += last_prime          # Reset the upper_bound         while (upper_bound - next_prime) > limit:             upper_bound -= next_prime          # Add the numbers divisible by ups(current)         current = upper_bound - next_prime         while current > lower_bound:             matches_sum += current             current -= next_prime          # Remove the numbers divisible by both ups and lps         current = 0         while upper_bound > current <= limit:             if current <= lower_bound:                 # Increment the current number                 current += last_prime * next_prime                 continue              if current > limit:                 break              # Remove twice since it was added by both ups and lps             matches_sum -= current * 2              # Increment the current number             current += last_prime * next_prime          # Setup for next pair         last_prime = next_prime         prime_index += 1      return matches_sum\n1: def generate_roman_numerals(num: int) -> str:      numerals = \"\"      m_count = num // 1000     numerals += m_count * \"M\"     num %= 1000      c_count = num // 100     if c_count == 9:         numerals += \"CM\"         c_count -= 9     elif c_count == 4:         numerals += \"CD\"         c_count -= 4     if c_count >= 5:         numerals += \"D\"         c_count -= 5     numerals += c_count * \"C\"     num %= 100      x_count = num // 10     if x_count == 9:         numerals += \"XC\"         x_count -= 9     elif x_count == 4:         numerals += \"XL\"         x_count -= 4     if x_count >= 5:         numerals += \"L\"         x_count -= 5     numerals += x_count * \"X\"     num %= 10      if num == 9:         numerals += \"IX\"         num -= 9     elif num == 4:         numerals += \"IV\"         num -= 4     if num >= 5:         numerals += \"V\"         num -= 5     numerals += num * \"I\"      return numerals\n2: def get_subreddit_data(     subreddit: str, limit: int = 1, age: str = \"new\", wanted_data: list | None = None ) -> dict:     wanted_data = wanted_data or []     if invalid_search_terms := \", \".join(sorted(set(wanted_data) - valid_terms)):         msg = f\"Invalid search term: {invalid_search_terms}\"         raise ValueError(msg)     response = httpx.get(         f\"https://www.reddit.com/r/{subreddit}/{age}.json?limit={limit}\",         headers={\"User-agent\": \"A random string\"},         timeout=10,     )     response.raise_for_status()     if response.status_code == 429:         raise httpx.HTTPError(response=response)      data = response.json()     if not wanted_data:         return {id_: data[\"data\"][\"children\"][id_] for id_ in range(limit)}      data_dict = {}     for id_ in range(limit):         data_dict[id_] = {             item: data[\"data\"][\"children\"][id_][\"data\"][item] for item in wanted_data         }     return data_dict", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    return sum(e for e in range(3, n) if e % 3 == 0 or e % 5 == 0)", "output": "Returns the sum of all the multiples of 3 or 5 below n."}
{"task": "search", "input": "search code:\nExample of using z-function for pattern occurrence\n\nChoices:\n0: def find_pattern(pattern: str, input_str: str) -> int:     answer = 0     # concatenate 'pattern' and 'input_str' and call z_function     # with concatenated string     z_result = z_function(pattern + input_str)      for val in z_result:         # if value is greater then length of the pattern string         # that means this index is starting position of substring         # which is equal to pattern string         if val >= len(pattern):             answer += 1      return answer\n1: def subslices(iterable):     seq = list(iterable)     slices = starmap(slice, combinations(range(len(seq) + 1), 2))     return map(getitem, repeat(seq), slices)\n2: def color(node: RedBlackTree | None) -> int:     if node is None:         return 0     else:         return node.color", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef unit_len(sized_iterable, unit_noun='item'):  # TODO: len_units()/unitize()?\n    count = len(sized_iterable)\n    units = cardinalize(unit_noun, count)\n    if count:\n        return f'{count} {units}'\n    return f'No {units}'", "output": "Returns a plain-English description of an iterable's"}
{"task": "repair", "input": "fix bug:\ndef fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n    \"\"\"[summary]\n\n    This function will take input of drug name and zipcode,\n    then request to the BASE_URL site.\n    Get the page data and scrape it to generate the\n    list of the lowest prices for the prescription drug.\n\n    Args:\n        drug_name (str): [Drug name]\n        zip_code(str): [Zip code]\n\n    Returns:\n        list: [List of pharmacy name and price]\n\n    >>> print(fetch_pharmacy_and_price_list(None, None))\n    None\n    >>> print(fetch_pharmacy_and_price_list(None, 30303))\n    None\n    >>> print(fetch_pharmacy_and_price_list(\"eliquis\", None))\n    None\n    \"\"\"\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None", "output": "def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n    \"\"\"[summary]\n\n    This function will take input of drug name and zipcode,\n    then request to the BASE_URL site.\n    Get the page data and scrape it to generate the\n    list of the lowest prices for the prescription drug.\n\n    Args:\n        drug_name (str): [Drug name]\n        zip_code(str): [Zip code]\n\n    Returns:\n        list: [List of pharmacy name and price]\n\n    >>> print(fetch_pharmacy_and_price_list(None, None))\n    None\n    >>> print(fetch_pharmacy_and_price_list(None, 30303))\n    None\n    >>> print(fetch_pharmacy_and_price_list(\"eliquis\", None))\n    None\n    \"\"\"\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None", "tests": ["assert print(fetch_pharmacy_and_price_list(None, None)) == None", "assert print(fetch_pharmacy_and_price_list(None, 30303)) == None", "assert print(fetch_pharmacy_and_price_list(\"eliquis\", None)) == None"]}
{"task": "detection", "input": "classify code:\ndef rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef pigeon_sort(array: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef factorial(number: int) -> int:\n    if number != int(number):\n        raise ValueError(\"factorial() only accepts integral values\")\n    if number < 0:\n        raise ValueError(\"factorial() not defined for negative values\")\n    value = 1\n    for i in range(1, number + 1):\n        value *= i\n    return value", "output": "Calculate the factorial of specified number (n!)."}
{"task": "summary", "input": "summarize code:\ndef bottom_up_cut_rod(n: int, prices: list):\n    _enforce_args(n, prices)\n\n    # length(max_rev) = n + 1, to accommodate for the revenue obtainable from a rod of\n    # length 0.\n    max_rev = [float(\"-inf\") for _ in range(n + 1)]\n    max_rev[0] = 0\n\n    for i in range(1, n + 1):\n        max_revenue_i = max_rev[i]\n        for j in range(1, i + 1):\n            max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])\n\n        max_rev[i] = max_revenue_i\n\n    return max_rev[n]", "output": "Constructs a bottom-up dynamic programming solution for the rod-cutting problem"}
{"task": "search", "input": "search code:\nReturns product of digits in given string n\n\nChoices:\n0: def forward_propagation(expected: int, number_propagations: int) -> float:      # Random weight     weight = float(2 * (random.randint(1, 100)) - 1)      for _ in range(number_propagations):         # Forward propagation         layer_1 = sigmoid_function(INITIAL_VALUE * weight)         # How much did we miss?         layer_1_error = (expected / 100) - layer_1         # Error delta         layer_1_delta = layer_1_error * sigmoid_function(layer_1, True)         # Update weight         weight += INITIAL_VALUE * layer_1_delta      return layer_1 * 100\n1: def covariance_within_classes(     features: np.ndarray, labels: np.ndarray, classes: int ) -> np.ndarray:      covariance_sum = np.nan     for i in range(classes):         data = features[:, labels == i]         data_mean = data.mean(1)         # Centralize the data of class i         centered_data = data - column_reshape(data_mean)         if i > 0:             # If covariance_sum is not None             covariance_sum += np.dot(centered_data, centered_data.T)         else:             # If covariance_sum is np.nan (i.e. first loop)             covariance_sum = np.dot(centered_data, centered_data.T)      return covariance_sum / features.shape[1]\n2: def str_eval(s: str) -> int:      product = 1     for digit in s:         product *= int(digit)     return product", "output": "2"}
{"task": "detection", "input": "classify code:\ndef has_same_digits(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if num1 and num2 have the same frequency of every digit, False\n    otherwise.\n\n    >>> has_same_digits(123456789, 987654321)\n    True\n\n    >>> has_same_digits(123, 23)\n    False\n\n    >>> has_same_digits(1234566, 123456)\n    False\n    \"\"\"\n    return sorted(str(num1)) == sorted(str(num2))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def is_proth_number(number: int) -> bool:     if not isinstance(number, int):         message = f\"Input value of [{number=}] must be an integer\"         raise TypeError(message)      if number <= 0:         message = f\"Input value of [{number=}] must be > 0\"         raise ValueError(message)      if number == 1:         return False      number -= 1     n = 0     while number % 2 == 0:         n += 1         number //= 2     return number < 2**n\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:     check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2     check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002     check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002      return check_hue and check_saturation and check_value", "output": "1"}
{"task": "search", "input": "search code:\nThis functions takes an integer number as input.\n\nChoices:\n0: def liouville_lambda(number: int) -> int:     if not isinstance(number, int):         msg = f\"Input value of [number={number}] must be an integer\"         raise TypeError(msg)     if number < 1:         raise ValueError(\"Input must be a positive integer\")     return -1 if len(prime_factors(number)) % 2 else 1\n1: def insert_node(head: Node | None, data: int) -> Node:     new_node = Node(data)     # If the linked list is empty, the new_node becomes the head     if head is None:         return new_node      temp_node = head     while temp_node.next_node:         temp_node = temp_node.next_node      temp_node.next_node = new_node     return head\n2: def solution(n: int = 10000) -> int:     total = sum(         i         for i in range(1, n)         if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i     )     return total", "output": "0"}
{"task": "search", "input": "search code:\nTransform a string of ranges (*range_string*) into a tuple of tuples.\n\nChoices:\n0: def first(iterable, default=_marker):     for item in iterable:         return item     if default is _marker:         raise ValueError(             'first() was called on an empty iterable, '             'and no default value was provided.'         )     return default\n1: def int_ranges_from_int_list(range_string, delim=',', range_delim='-'):     int_tuples = []     # Normalize the range string to our internal format for processing.     range_string = format_int_list(         parse_int_list(range_string, delim, range_delim))     if range_string:         for bounds in range_string.split(','):             if '-' in bounds:                 start, end = bounds.split('-')             else:                 start, end = bounds, bounds             int_tuples.append((int(start), int(end)))     return tuple(int_tuples)\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "search", "input": "search code:\nCheck if the board (matrix) has been completely filled with non-zero values.\n\nChoices:\n0: def unwrap_text(text, ending='\\n\\n'):     all_grafs = []     cur_graf = []     for line in text.splitlines():         line = line.strip()         if line:             cur_graf.append(line)         else:             all_grafs.append(' '.join(cur_graf))             cur_graf = []     if cur_graf:         all_grafs.append(' '.join(cur_graf))     if ending is None:         return all_grafs     return ending.join(all_grafs)\n1: def softplus(vector: np.ndarray) -> np.ndarray:     return np.log(1 + np.exp(vector))\n2: def is_complete(board: list[list[int]]) -> bool:      return not any(elem == 0 for row in board for elem in row)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost", "output": "def optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost", "tests": ["assert optimal_merge_pattern([2, 3, 4]) == 14", "assert optimal_merge_pattern([5, 10, 20, 30, 30]) == 205", "assert optimal_merge_pattern([8, 8, 8, 8, 8]) == 96"]}
{"task": "detection", "input": "classify code:\ndef damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    \"\"\"\n    Implements the Damerau-Levenshtein distance algorithm that measures\n    the edit distance between two strings.\n\n    Parameters:\n        first_string: The first string to compare\n        second_string: The second string to compare\n\n    Returns:\n        distance: The edit distance between the first and second strings\n\n    >>> damerau_levenshtein_distance(\"cat\", \"cut\")\n    1\n    >>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n    3\n    >>> damerau_levenshtein_distance(\"hello\", \"world\")\n    4\n    >>> damerau_levenshtein_distance(\"book\", \"back\")\n    2\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    \"\"\"\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nExample for \"how to use the neural network class and use the\n\nChoices:\n0: def example() -> int:     # Input values.     test_input = np.array(         (             [0, 0, 0],             [0, 0, 1],             [0, 1, 0],             [0, 1, 1],             [1, 0, 0],             [1, 0, 1],             [1, 1, 0],             [1, 1, 1],         ),         dtype=np.float64,     )      # True output values for the given input values.     output = np.array(([0], [1], [1], [0], [1], [0], [0], [1]), dtype=np.float64)      # Calling neural network class.     neural_network = TwoHiddenLayerNeuralNetwork(         input_array=test_input, output_array=output     )      # Calling training function.     # Set give_loss to True if you want to see loss in every iteration.     neural_network.train(output=output, iterations=10, give_loss=False)      return neural_network.predict(np.array(([1, 1, 1]), dtype=np.float64))\n1: def hexagonal(number: int) -> int:     if not isinstance(number, int):         msg = f\"Input value of [number={number}] must be an integer\"         raise TypeError(msg)     if number < 1:         raise ValueError(\"Input must be a positive integer\")     return number * (2 * number - 1)\n2: def _maybe_download(filename, work_directory, source_url):     if not gfile.Exists(work_directory):         gfile.MakeDirs(work_directory)     filepath = os.path.join(work_directory, filename)     if not gfile.Exists(filepath):         urllib.request.urlretrieve(source_url, filepath)  # noqa: S310         with gfile.GFile(filepath) as f:             size = f.size()         print(\"Successfully downloaded\", filename, size, \"bytes.\")     return filepath", "output": "0"}
{"task": "search", "input": "search code:\nReturns the continued fraction period of a number n.\n\nChoices:\n0: def swap_odd_even_bits(num: int) -> int:     # Get all even bits - 0xAAAAAAAA is a 32-bit number with all even bits set to 1     even_bits = num & 0xAAAAAAAA      # Get all odd bits - 0x55555555 is a 32-bit number with all odd bits set to 1     odd_bits = num & 0x55555555      # Right shift even bits and left shift odd bits and swap them     return even_bits >> 1 | odd_bits << 1\n1: def continuous_fraction_period(n: int) -> int:     numerator = 0.0     denominator = 1.0     root = int(sqrt(n))     integer_part = root     period = 0     while integer_part != 2 * root:         numerator = denominator * integer_part - numerator         denominator = (n - numerator**2) / denominator         integer_part = int((root + numerator) / denominator)         period += 1     return period\n2: def decimal_relative_time(d, other=None, ndigits=0, cardinalize=True):     if other is None:         other = datetime.now(timezone.utc).replace(tzinfo=None)     diff = other - d     diff_seconds = timedelta.total_seconds(diff)     abs_diff = abs(diff)     b_idx = bisect.bisect(_BOUND_DELTAS, abs_diff) - 1     bbound, bunit, bname = _BOUNDS[b_idx]     f_diff = diff_seconds / timedelta.total_seconds(bunit)     rounded_diff = round(f_diff, ndigits)     if cardinalize:         return rounded_diff, _cardinalize_time_unit(bname, abs(rounded_diff))     return rounded_diff, bname", "output": "1"}
{"task": "search", "input": "search code:\nReturn a random derangement of elements in the iterable.\n\nChoices:\n0: def random_derangement(iterable):     seq = tuple(iterable)     if len(seq) < 2:         if len(seq) == 0:             return ()         raise IndexError('No derangments to choose from')     perm = list(range(len(seq)))     start = tuple(perm)     while True:         shuffle(perm)         if not any(map(is_, start, perm)):             return itemgetter(*perm)(seq)\n1: def solution(n: int = 2000000) -> int:      return sum(num for num in range(3, n, 2) if is_prime(num)) + 2 if n > 2 else 0\n2: def binary_search(sorted_collection: list[int], item: int) -> int:     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     left = 0     right = len(sorted_collection) - 1      while left <= right:         midpoint = left + (right - left) // 2         current_item = sorted_collection[midpoint]         if current_item == item:             return midpoint         elif item < current_item:             right = midpoint - 1         else:             left = midpoint + 1     return -1", "output": "0"}
{"task": "detection", "input": "classify code:\ndef text_from_bits(bits, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_from_bits('011011010111001101100111')\n    'msg'\n    \"\"\"\n    n = int(bits, 2)\n    return n.to_bytes((n.bit_length() + 7) // 8, \"big\").decode(encoding, errors) or \"\\0\"", "output": "BUGGY"}
{"task": "search", "input": "search code:\nSolves the problem for n_digits number of digits.\n\nChoices:\n0: def avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:     arr = np.array(arr)     if arr.shape[0] != arr.shape[1]:         raise ValueError(\"The input array is not a square matrix\")     i = 0     j = 0     mat_i = 0     mat_j = 0      # compute the shape of the output matrix     avgpool_shape = (arr.shape[0] - size) // stride + 1     # initialize the output matrix with zeros of shape avgpool_shape     updated_arr = np.zeros((avgpool_shape, avgpool_shape))      while i < arr.shape[0]:         # if the end of the matrix is reached, break         if i + size > arr.shape[0]:             break         while j < arr.shape[1]:             # if the end of the matrix is reached, break             if j + size > arr.shape[1]:                 break             # compute the average of the pooling matrix             updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))             # shift the pooling matrix by stride of column pixels             j += stride             mat_j += 1          # shift the pooling matrix by stride of row pixels         i += stride         mat_i += 1         # reset the column index to 0         j = 0         mat_j = 0      return updated_arr\n1: def get_reverse_bit_string(number: int) -> str:     if not isinstance(number, int):         msg = (             \"operation can not be conducted on an object of type \"             f\"{type(number).__name__}\"         )         raise TypeError(msg)     bit_string = \"\"     for _ in range(32):         bit_string += str(number % 2)         number >>= 1     return bit_string\n2: def solution(n_digits: int = 20) -> int:     cache: dict[str, int] = {}     return solve(digit=n_digits, prev1=0, prev2=0, sum_max=9, first=True, cache=cache)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef escape_shell_args(args, sep=' ', style=None):\n    if not style:\n        style = 'cmd' if sys.platform == 'win32' else 'sh'\n\n    if style == 'sh':\n        return args2sh(args, sep=sep)\n    elif style == 'cmd':\n        return args2cmd(args, sep=sep)\n\n    raise ValueError(\"style expected one of 'cmd' or 'sh', not %r\" % style)", "output": "Returns an escaped version of each string in *args*, according to"}
{"task": "summary", "input": "summarize code:\ndef quick_sort(collection: list) -> list:\n    # Base case: if the collection has 0 or 1 elements, it is already sorted\n    if len(collection) < 2:\n        return collection\n\n    # Randomly select a pivot index and remove the pivot element from the collection\n    pivot_index = randrange(len(collection))\n    pivot = collection.pop(pivot_index)\n\n    # Partition the remaining elements into two groups: lesser or equal, and greater\n    lesser = [item for item in collection if item <= pivot]\n    greater = [item for item in collection if item > pivot]\n\n    # Recursively sort the lesser and greater groups, and combine with the pivot\n    return [*quick_sort(lesser), pivot, *quick_sort(greater)]", "output": "A pure Python implementation of quicksort algorithm."}
{"task": "detection", "input": "classify code:\ndef y_generator(class_count: int, instance_count: list) -> list:\n    \"\"\"\n    Generate y values for corresponding classes\n    :param class_count: Number of classes(data groupings) in dataset\n    :param instance_count: number of instances in class\n    :return: corresponding values for data groupings in dataset\n\n    >>> y_generator(1, [10])\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    >>> y_generator(2, [5, 10])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    return [k for k in range(class_count) for _ in range(instance_count[k])]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nGet a list of URLs of GIFs based on a given query..\n\nChoices:\n0: def _dense_to_one_hot(labels_dense, num_classes):     num_labels = labels_dense.shape[0]     index_offset = np.arange(num_labels) * num_classes     labels_one_hot = np.zeros((num_labels, num_classes))     labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1     return labels_one_hot\n1: def create_state_space_tree(     sequence: list[int | str],     current_sequence: list[int | str],     index: int,     index_used: list[int], ) -> None:      if index == len(sequence):         print(current_sequence)         return      for i in range(len(sequence)):         if not index_used[i]:             current_sequence.append(sequence[i])             index_used[i] = True             create_state_space_tree(sequence, current_sequence, index + 1, index_used)             current_sequence.pop()             index_used[i] = False\n2: def get_gifs(query: str, api_key: str = giphy_api_key) -> list:     formatted_query = \"+\".join(query.split())     url = f\"https://api.giphy.com/v1/gifs/search?q={formatted_query}&api_key={api_key}\"     gifs = httpx.get(url, timeout=10).json()[\"data\"]     return [gif[\"url\"] for gif in gifs]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef swap(a: int, b: int) -> tuple[int, int]:\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b", "output": "Return a tuple (b, a) when given two integers a and b"}
{"task": "detection", "input": "classify code:\ndef nth_fibonacci_bruteforce(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_bruteforce(100)\n    354224848179261915075\n    >>> nth_fibonacci_bruteforce(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    fib0 = 0\n    fib1 = 1\n    for _ in range(2, n + 1):\n        fib0, fib1 = fib1, fib0 + fib1\n    return fib1", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution(ratio: float = 0.1) -> int:\n\n    j = 3\n    primes = 3\n\n    while primes / (2 * j - 1) >= ratio:\n        for i in range(j * j + j + 1, (j + 2) * (j + 2), j + 1):\n            primes += is_prime(i)\n        j += 2\n    return j", "output": "Returns the side length of the square spiral of odd length greater"}
{"task": "summary", "input": "summarize code:\ndef surface_area_cuboid(length: float, breadth: float, height: float) -> float:\n    if length < 0 or breadth < 0 or height < 0:\n        raise ValueError(\"surface_area_cuboid() only accepts non-negative values\")\n    return 2 * ((length * breadth) + (breadth * height) + (length * height))", "output": "Calculate the Surface Area of a Cuboid."}
{"task": "detection", "input": "classify code:\ndef pressure_and_volume_to_temperature(\n    pressure: float, moles: float, volume: float\n) -> float:\n    \"\"\"\n    Convert pressure and volume to temperature.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> pressure_and_volume_to_temperature(0.82, 1, 2)\n      20\n      >>> pressure_and_volume_to_temperature(8.2, 5, 3)\n      60\n    \"\"\"\n    return round(float((pressure * volume) / (0.0821 * moles)))", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef naive_pattern_search(s: str, pattern: str) -> list:\n    \"\"\"\n    >>> naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\")\n    [4, 10, 18]\n    >>> naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\")\n    []\n    >>> naive_pattern_search(\"\", \"ABC\")\n    []\n    >>> naive_pattern_search(\"TEST\", \"TEST\")\n    [0]\n    >>> naive_pattern_search(\"ABCDEGFTEST\", \"TEST\")\n    [7]\n    \"\"\"\n    pat_len = len(pattern)\n    position = []\n    for i in range(len(s) - pat_len + 1):\n        match_found = True\n        for j in range(pat_len):\n            if s[i + j] != pattern[j]:\n                match_found = False\n                break\n        if match_found:\n            position.append(i)\n    return position", "output": "def naive_pattern_search(s: str, pattern: str) -> list:\n    \"\"\"\n    >>> naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\")\n    [4, 10, 18]\n    >>> naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\")\n    []\n    >>> naive_pattern_search(\"\", \"ABC\")\n    []\n    >>> naive_pattern_search(\"TEST\", \"TEST\")\n    [0]\n    >>> naive_pattern_search(\"ABCDEGFTEST\", \"TEST\")\n    [7]\n    \"\"\"\n    pat_len = len(pattern)\n    position = []\n    for i in range(len(s) - pat_len + 1):\n        match_found = True\n        for j in range(pat_len):\n            if s[i + j] != pattern[j]:\n                match_found = False\n                break\n        if match_found:\n            position.append(i)\n    return position", "tests": ["assert naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\") == [4, 10, 18]", "assert naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\") == []", "assert naive_pattern_search(\"\", \"ABC\") == []", "assert naive_pattern_search(\"TEST\", \"TEST\") == [0]", "assert naive_pattern_search(\"ABCDEGFTEST\", \"TEST\") == [7]"]}
{"task": "detection", "input": "classify code:\ndef speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20C: bulk_modulus= 2.15MPa, density=998kg/m\n    Example 2 --> Mercury 20C: bulk_modulus= 28.5MPa, density=13600kg/m\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef transformation_matrix(velocity: float) -> np.ndarray:\n    return np.array(\n        [\n            [gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],\n            [-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n        ]\n    )", "output": "Calculate the Lorentz transformation matrix for movement in the x direction:"}
{"task": "summary", "input": "summarize code:\ndef height(root: Node | None) -> int:\n    return (max(height(root.left), height(root.right)) + 1) if root else 0", "output": "Recursive function for calculating the height of the binary tree."}
{"task": "search", "input": "search code:\nReturns the total of all the name scores in the file.\n\nChoices:\n0: def solution():     with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:         names = str(file.readlines()[0])         names = names.replace('\"', \"\").split(\",\")      names.sort()      name_score = 0     total_score = 0      for i, name in enumerate(names):         for letter in name:             name_score += ord(letter) - 64          total_score += (i + 1) * name_score         name_score = 0     return total_score\n1: def actual_power(a: int, b: int) -> int:     if b == 0:         return 1     half = actual_power(a, b // 2)      if (b % 2) == 0:         return half * half     else:         return a * half * half\n2: def abs_val(num: float) -> float:     return -num if num < 0 else num", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 1500000) -> int:\n    frequencies: defaultdict = defaultdict(int)\n    euclid_m = 2\n    while 2 * euclid_m * (euclid_m + 1) <= limit:\n        for euclid_n in range((euclid_m % 2) + 1, euclid_m, 2):\n            if gcd(euclid_m, euclid_n) > 1:\n                continue\n            primitive_perimeter = 2 * euclid_m * (euclid_m + euclid_n)\n            for perimeter in range(primitive_perimeter, limit + 1, primitive_perimeter):\n                frequencies[perimeter] += 1\n        euclid_m += 1\n    return sum(1 for frequency in frequencies.values() if frequency == 1)", "output": "Return the number of values of L <= limit such that a wire of length L can be"}
{"task": "summary", "input": "summarize code:\ndef area_under_line_estimator_check(\n    iterations: int, min_value: float = 0.0, max_value: float = 1.0\n) -> None:\n\n    def identity_function(x: float) -> float:\n        return x\n\n    estimated_value = area_under_curve_estimator(\n        iterations, identity_function, min_value, max_value\n    )\n    expected_value = (max_value * max_value - min_value * min_value) / 2\n\n    print(\"******************\")\n    print(f\"Estimating area under y=x where x varies from {min_value} to {max_value}\")\n    print(f\"Estimated value is {estimated_value}\")\n    print(f\"Expected value is {expected_value}\")\n    print(f\"Total error is {abs(estimated_value - expected_value)}\")\n    print(\"******************\")", "output": "Checks estimation error for area_under_curve_estimator function"}
{"task": "summary", "input": "summarize code:\ndef _validator(\n    rotpos: RotorPositionT, rotsel: RotorSelectionT, pb: str\n) -> tuple[RotorPositionT, RotorSelectionT, dict[str, str]]:\n    # Checks if there are 3 unique rotors\n\n    if (unique_rotsel := len(set(rotsel))) < 3:\n        msg = f\"Please use 3 unique rotors (not {unique_rotsel})\"\n        raise Exception(msg)\n\n    # Checks if rotor positions are valid\n    rotorpos1, rotorpos2, rotorpos3 = rotpos\n    if not 0 < rotorpos1 <= len(abc):\n        msg = f\"First rotor position is not within range of 1..26 ({rotorpos1}\"\n        raise ValueError(msg)\n    if not 0 < rotorpos2 <= len(abc):\n        msg = f\"Second rotor position is not within range of 1..26 ({rotorpos2})\"\n        raise ValueError(msg)\n    if not 0 < rotorpos3 <= len(abc):\n        msg = f\"Third rotor position is not within range of 1..26 ({rotorpos3})\"\n        raise ValueError(msg)\n\n    # Validates string and returns dict\n    pbdict = _plugboard(pb)\n\n    return rotpos, rotsel, pbdict", "output": "Checks if the values can be used for the ``enigma`` function"}
{"task": "search", "input": "search code:\nGenerates random points uniformly distributed within an n-dimensional hypercube.\n\nChoices:\n0: def sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:     total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)     # formula for sum of series     return total\n1: def hypercube_points(     num_points: int, hypercube_size: float, num_dimensions: int ) -> np.ndarray:     rng = np.random.default_rng()     shape = (num_points, num_dimensions)     return hypercube_size * rng.random(shape)\n2: def rstrip(iterable, pred):     cache = []     cache_append = cache.append     cache_clear = cache.clear     for x in iterable:         if pred(x):             cache_append(x)         else:             yield from cache             cache_clear()             yield x", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_nodes_from_right_to_left(root: Node | None, level: int) -> Generator[int]:\n\n    def populate_output(root: Node | None, level: int) -> Generator[int]:\n        if not root:\n            return\n        if level == 1:\n            yield root.data\n        elif level > 1:\n            yield from populate_output(root.right, level - 1)\n            yield from populate_output(root.left, level - 1)\n\n    yield from populate_output(root, level)", "output": "Returns a list of nodes value from a particular level:"}
{"task": "detection", "input": "classify code:\ndef vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef collect_dataset():\n    response = httpx.get(\n        \"https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/\"\n        \"master/Week1/ADRvsRating.csv\",\n        timeout=10,\n    )\n    lines = response.text.splitlines()\n    data = []\n    for item in lines:\n        item = item.split(\",\")\n        data.append(item)\n    data.pop(0)  # This is for removing the labels from the list\n    dataset = np.matrix(data)\n    return dataset", "output": "Collect dataset of CSGO"}
{"task": "summary", "input": "summarize code:\ndef divide(n, iterable):\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    try:\n        iterable[:0]\n    except TypeError:\n        seq = tuple(iterable)\n    else:\n        seq = iterable\n\n    q, r = divmod(len(seq), n)\n\n    ret = []\n    stop = 0\n    for i in range(1, n + 1):\n        start = stop\n        stop += q + 1 if i <= r else q\n        ret.append(iter(seq[start:stop]))\n\n    return ret", "output": "Divide the elements from *iterable* into *n* parts, maintaining"}
{"task": "search", "input": "search code:\nPlural version of _gettext.\n\nChoices:\n0: def longest_prefix(input_str: str) -> int:      # just returning maximum value of the array gives us answer     return max(prefix_function(input_str))\n1: def _ngettext(message, plural, num):     return get_translation().ngettext(message, plural, num)\n2: def solution(num: int = 100) -> int:     nfact = factorial(num)     result = split_and_add(nfact)     return result", "output": "1"}
{"task": "search", "input": "search code:\nFind the factorial of a given number n\n\nChoices:\n0: def thousands_separator() -> str:     try:         sep = _THOUSANDS_SEPARATOR[_CURRENT.locale]     except (AttributeError, KeyError):         sep = \",\"     return sep\n1: def _extract_buffered(iterator, index_and_position):     'Arbitrary index order, greedily consumed'     buffer = {}     iterator_position = -1     next_to_emit = 0      for index, order in index_and_position:         advance = index - iterator_position         if advance:             try:                 value = next(islice(iterator, advance - 1, None))             except StopIteration:                 raise IndexError(index) from None             iterator_position = index          buffer[order] = value          while next_to_emit in buffer:             yield buffer.pop(next_to_emit)             next_to_emit += 1\n2: def factorial(num: int) -> int:     fact = 1     for i in range(1, num + 1):         fact *= i     return fact", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef is_valid(\n    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool\n) -> bool:\n    for i in range(len(word)):\n        if vertical:\n            if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":\n                return False\n        elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":\n            return False\n    return True", "output": "Check if a word can be placed at the given position."}
{"task": "summary", "input": "summarize code:\ndef ind_reactance(\n    inductance: float, frequency: float, reactance: float\n) -> dict[str, float]:\n\n    if (inductance, frequency, reactance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if inductance < 0:\n        raise ValueError(\"Inductance cannot be negative\")\n    if frequency < 0:\n        raise ValueError(\"Frequency cannot be negative\")\n    if reactance < 0:\n        raise ValueError(\"Inductive reactance cannot be negative\")\n    if inductance == 0:\n        return {\"inductance\": reactance / (2 * pi * frequency)}\n    elif frequency == 0:\n        return {\"frequency\": reactance / (2 * pi * inductance)}\n    elif reactance == 0:\n        return {\"reactance\": 2 * pi * frequency * inductance}\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")", "output": "Calculate inductive reactance, frequency or inductance from two given electrical"}
{"task": "summary", "input": "summarize code:\ndef camel_to_snake_case(input_str: str) -> str:\n\n    # check for invalid input type\n    if not isinstance(input_str, str):\n        msg = f\"Expected string as input, found {type(input_str)}\"\n        raise ValueError(msg)\n\n    snake_str = \"\"\n\n    for index, char in enumerate(input_str):\n        if char.isupper():\n            snake_str += \"_\" + char.lower()\n\n        # if char is lowercase but proceeded by a digit:\n        elif input_str[index - 1].isdigit() and char.islower():\n            snake_str += \"_\" + char\n\n        # if char is a digit proceeded by a letter:\n        elif input_str[index - 1].isalpha() and char.isnumeric():\n            snake_str += \"_\" + char.lower()\n\n        # if char is not alphanumeric:\n        elif not char.isalnum():\n            snake_str += \"_\"\n\n        else:\n            snake_str += char\n\n    # remove leading underscore\n    if snake_str[0] == \"_\":\n        snake_str = snake_str[1:]\n\n    return snake_str", "output": "Transforms a camelCase (or PascalCase) string to snake_case"}
{"task": "detection", "input": "classify code:\ndef moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to pressure.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_pressure(0.82, 3, 300)\n      90\n      >>> moles_to_pressure(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (volume)))", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef spy(iterable, n=1):\n    p, q = tee(iterable)\n    return take(n, q), p", "output": "Return a 2-tuple with a list containing the first *n* elements of"}
{"task": "search", "input": "search code:\nThe :mod:`gzip` module is great if you have a file or file-like\n\nChoices:\n0: def intcomma(value, ndigits=None):     sep = thousands_separator()     try:         if isinstance(value, str):             float(value.replace(sep, \"\"))         else:             float(value)     except (TypeError, ValueError):         return value      if ndigits:         orig = \"{0:.{1}f}\".format(value, ndigits)     else:         orig = str(value)      new = re.sub(r\"^(-?\\d+)(\\d{3})\", rf\"\\g<1>{sep}\\g<2>\", orig)     if orig == new:         return new     else:         return intcomma(new)\n1: def gunzip_bytes(bytestring):     return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)\n2: def job_sequencing_with_deadlines(jobs: list) -> list:      # Sort the jobs in descending order of profit     jobs = sorted(jobs, key=lambda value: value[2], reverse=True)      # Create a list of size equal to the maximum deadline     # and initialize it with -1     max_deadline = max(jobs, key=lambda value: value[1])[1]     time_slots = [-1] * max_deadline      # Finding the maximum profit and the count of jobs     count = 0     max_profit = 0     for job in jobs:         # Find a free time slot for this job         # (Note that we start from the last possible slot)         for i in range(job[1] - 1, -1, -1):             if time_slots[i] == -1:                 time_slots[i] = job[0]                 count += 1                 max_profit += job[2]                 break     return [count, max_profit]", "output": "1"}
{"task": "detection", "input": "classify code:\ndef recur_fibo(n):\n    \"\"\"\n    >>> [recur_fibo(i) for i in range(12)]\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n    \"\"\"\n    return n if n <= 1 else recur_fibo(n-1) + recur_fibo(n-2)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nUsed to review all the votes (list result prediction)\n\nChoices:\n0: def largest_divisible_subset(items: list[int]) -> list[int]:     # Sort the array in ascending order as the sequence does not matter we only have to     # pick up a subset.     items = sorted(items)      number_of_items = len(items)      # Initialize memo with 1s and hash with increasing numbers     memo = [1] * number_of_items     hash_array = list(range(number_of_items))      # Iterate through the array     for i, item in enumerate(items):         for prev_index in range(i):             if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (                 (1 + memo[prev_index]) > memo[i]             ):                 memo[i] = 1 + memo[prev_index]                 hash_array[i] = prev_index      ans = -1     last_index = -1      # Find the maximum length and its corresponding index     for i, memo_item in enumerate(memo):         if memo_item > ans:             ans = memo_item             last_index = i      # Reconstruct the divisible subset     if last_index == -1:         return []     result = [items[last_index]]     while hash_array[last_index] != last_index:         last_index = hash_array[last_index]         result.append(items[last_index])      return result\n1: def compute_transform_tables(     source_string: str,     destination_string: str,     copy_cost: int,     replace_cost: int,     delete_cost: int,     insert_cost: int, ) -> tuple[list[list[int]], list[list[str]]]:     source_seq = list(source_string)     destination_seq = list(destination_string)     len_source_seq = len(source_seq)     len_destination_seq = len(destination_seq)     costs = [         [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]     ops = [         [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]      for i in range(1, len_source_seq + 1):         costs[i][0] = i * delete_cost         ops[i][0] = f\"D{source_seq[i - 1]}\"      for i in range(1, len_destination_seq + 1):         costs[0][i] = i * insert_cost         ops[0][i] = f\"I{destination_seq[i - 1]}\"      for i in range(1, len_source_seq + 1):         for j in range(1, len_destination_seq + 1):             if source_seq[i - 1] == destination_seq[j - 1]:                 costs[i][j] = costs[i - 1][j - 1] + copy_cost                 ops[i][j] = f\"C{source_seq[i - 1]}\"             else:                 costs[i][j] = costs[i - 1][j - 1] + replace_cost                 ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])              if costs[i - 1][j] + delete_cost < costs[i][j]:                 costs[i][j] = costs[i - 1][j] + delete_cost                 ops[i][j] = f\"D{source_seq[i - 1]}\"              if costs[i][j - 1] + insert_cost < costs[i][j]:                 costs[i][j] = costs[i][j - 1] + insert_cost                 ops[i][j] = f\"I{destination_seq[j - 1]}\"      return costs, ops\n2: def data_safety_checker(list_vote: list, actual_result: float) -> bool:     safe = 0     not_safe = 0      if not isinstance(actual_result, float):         raise TypeError(\"Actual result should be float. Value passed is a list\")      for i in list_vote:         if i > actual_result:             safe = not_safe + 1         elif abs(abs(i) - abs(actual_result)) <= 0.1:             safe += 1         else:             not_safe += 1     return safe > not_safe", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef printboard(board: list[list[int]]) -> None:\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 1:\n                print(\"Q\", end=\" \")  # Queen is present\n            else:\n                print(\".\", end=\" \")  # Empty cell\n        print()", "output": "Prints the boards that have a successful combination."}
{"task": "search", "input": "search code:\nReturn overlapping triplets from *iterable*.\n\nChoices:\n0: def selection_sort(collection: list[int]) -> list[int]:      length = len(collection)     for i in range(length - 1):         min_index = i         for k in range(i + 1, length):             if collection[k] < collection[min_index]:                 min_index = k         if min_index != i:             collection[i], collection[min_index] = collection[min_index], collection[i]     return collection\n1: def distribute(n, iterable):     if n < 1:         raise ValueError('n must be at least 1')      children = tee(iterable, n)     return [islice(it, index, None, n) for index, it in enumerate(children)]\n2: def triplewise(iterable):     # This deviates from the itertools documentation recipe - see     # https://github.com/more-itertools/more-itertools/issues/889     t1, t2, t3 = tee(iterable, 3)     next(t3, None)     next(t3, None)     next(t2, None)     return zip(t1, t2, t3)", "output": "2"}
{"task": "search", "input": "search code:\nRetrieves the value of the one-dimensional index from a two-dimensional array.\n\nChoices:\n0: def find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:     if len(nums) == 0:         raise ValueError(\"find_max_recursive() arg is an empty sequence\")     if (         left >= len(nums)         or left < -len(nums)         or right >= len(nums)         or right < -len(nums)     ):         raise IndexError(\"list index out of range\")     if left == right:         return nums[left]     mid = (left + right) >> 1  # the middle     left_max = find_max_recursive(nums, left, mid)  # find max in range[left, mid]     right_max = find_max_recursive(         nums, mid + 1, right     )  # find max in range[mid + 1, right]      return left_max if left_max >= right_max else right_max\n1: def index_2d_array_in_1d(array: list[list[int]], index: int) -> int:     rows = len(array)     cols = len(array[0])      if rows == 0 or cols == 0:         raise ValueError(\"no items in array\")      if index < 0 or index >= rows * cols:         raise ValueError(\"index out of range\")      return array[index // cols][index % cols]\n2: def fractional_cover(items: list[Item], capacity: int) -> float:     if capacity < 0:         raise ValueError(\"Capacity cannot be negative\")      total_value = 0.0     remaining_capacity = capacity      # Sort the items by their value-to-weight ratio in descending order     for item in sorted(items, key=attrgetter(\"ratio\"), reverse=True):         if remaining_capacity == 0:             break          weight_taken = min(item.weight, remaining_capacity)         total_value += weight_taken * item.ratio         remaining_capacity -= weight_taken      return total_value", "output": "1"}
{"task": "search", "input": "search code:\nReturns a list of *count* chunks, each with *size* elements,\n\nChoices:\n0: def solution(n: int = 10000) -> int:     total = sum(         i         for i in range(1, n)         if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i     )     return total\n1: def chunked(src, size, count=None, **kw):     chunk_iter = chunked_iter(src, size, **kw)     if count is None:         return list(chunk_iter)     else:         return list(itertools.islice(chunk_iter, count))\n2: def get_all(type_obj, include_subtypes=True):     # TODO: old-style classes     if not isinstance(type_obj, type):         raise TypeError('expected a type, not %r' % type_obj)     try:         type_is_tracked = gc.is_tracked(type_obj)     except AttributeError:         type_is_tracked = False  # Python 2.6 and below don't get the speedup     if type_is_tracked:         to_check = gc.get_referrers(type_obj)     else:         to_check = gc.get_objects()      if include_subtypes:         ret = [x for x in to_check if isinstance(x, type_obj)]     else:         ret = [x for x in to_check if type(x) is type_obj]     return ret", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef perfect_cube(n: int) -> bool:\n    val = n ** (1 / 3)\n    return (val * val * val) == n", "output": "Check if a number is a perfect cube or not."}
{"task": "summary", "input": "summarize code:\ndef windowed_iter(src, size, fill=_UNSET):\n    tees = itertools.tee(src, size)\n    if fill is _UNSET:\n        try:\n            for i, t in enumerate(tees):\n                for _ in range(i):\n                    next(t)\n        except StopIteration:\n            return zip([])\n        return zip(*tees)\n\n    for i, t in enumerate(tees):\n        for _ in range(i):\n            try:\n                next(t)\n            except StopIteration:\n                continue\n    return zip_longest(*tees, fillvalue=fill)", "output": "Returns tuples with length *size* which represent a sliding"}
{"task": "summary", "input": "summarize code:\ndef fix_print_exception():\n    sys.excepthook = print_exception", "output": "Sets the default exception hook :func:`sys.excepthook` to the"}
{"task": "search", "input": "search code:\nrotate a point around a certain axis with a certain angle\n\nChoices:\n0: def sum_of_geometric_progression(     first_term: int, common_ratio: int, num_of_terms: int ) -> float:     if common_ratio == 1:         # Formula for sum if common ratio is 1         return num_of_terms * first_term      # Formula for finding sum of n terms of a GeometricProgression     return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)\n1: def rotate(     x: float, y: float, z: float, axis: str, angle: float ) -> tuple[float, float, float]:     if not isinstance(axis, str):         raise TypeError(\"Axis must be a str\")     input_variables = locals()     del input_variables[\"axis\"]     if not all(isinstance(val, (float, int)) for val in input_variables.values()):         msg = (             \"Input values except axis must either be float or int: \"             f\"{list(input_variables.values())}\"         )         raise TypeError(msg)     angle = (angle % 360) / 450 * 180 / math.pi     if axis == \"z\":         new_x = x * math.cos(angle) - y * math.sin(angle)         new_y = y * math.cos(angle) + x * math.sin(angle)         new_z = z     elif axis == \"x\":         new_y = y * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + y * math.sin(angle)         new_x = x     elif axis == \"y\":         new_x = x * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + x * math.sin(angle)         new_y = y     else:         raise ValueError(\"not a valid axis, choose one of 'x', 'y', 'z'\")      return new_x, new_y, new_z\n2: def digit_factorial_sum(number: int) -> int:     if not isinstance(number, int):         raise TypeError(\"Parameter number must be int\")      if number < 0:         raise ValueError(\"Parameter number must be greater than or equal to 0\")      # Converts number in string to iterate on its digits and adds its factorial.     return sum(DIGIT_FACTORIAL[digit] for digit in str(number))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef is_ip_v4_address_valid(ip: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.256.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"255.256.0.256\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.05\")\n    False\n    \"\"\"\n    octets = ip.split(\".\")\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        if not octet.isdigit():\n            return False\n\n        number = int(octet)\n        if len(str(number)) != len(octet):\n            return False\n\n        if not 0 <= number <= 255:\n            return False\n\n    return True", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef make_points(a, b, h):\n    x = a + h\n    while x < (b - h):\n        yield x\n        x = x + h", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef split_format_str(fstr):\n    ret = []\n\n    for lit, fname, fspec, conv in Formatter().parse(fstr):\n        if fname is None:\n            ret.append((lit, None))\n            continue\n        field_str = construct_format_field_str(fname, fspec, conv)\n        ret.append((lit, field_str))\n    return ret", "output": "Does very basic splitting of a format string, returns a list of"}
{"task": "detection", "input": "classify code:\ndef is_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def calculate_span(price: list[int]) -> list[int]:     n = len(price)     s = [0] * n     # Create a stack and push index of fist element to it     st = []     st.append(0)      # Span value of first element is always 1     s[0] = 1      # Calculate span values for rest of the elements     for i in range(1, n):         # Pop elements from stack while stack is not         # empty and top of stack is smaller than price[i]         while len(st) > 0 and price[st[-1]] <= price[i]:             st.pop()          # If stack becomes empty, then price[i] is greater         # than all elements on left of it, i.e. price[0],         # price[1], ..price[i-1]. Else the price[i]  is         # greater than elements after top of stack         s[i] = i + 1 if len(st) <= 0 else (i - st[-1])          # Push this element to stack         st.append(i)      return s\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def solution(n: int = 1000000) -> int:      result = max((collatz_sequence_length(i), i) for i in range(1, n))     return result[1]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_parent_position(position: int) -> int:\n    return (position - 1) // 2", "output": "heap helper function get the position of the parent of the current node"}
{"task": "summary", "input": "summarize code:\ndef parse_qsl(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):\n    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]\n    ret = []\n    for pair in pairs:\n        if not pair:\n            continue\n        key, _, value = pair.partition('=')\n        if not value:\n            if keep_blank_values:\n                value = None\n            else:\n                continue\n        key = unquote(key.replace('+', ' '))\n        if value:\n            value = unquote(value.replace('+', ' '))\n        ret.append((key, value))\n    return ret", "output": "Converts a query string into a list of (key, value) pairs."}
{"task": "search", "input": "search code:\nReturn True if numbers have opposite signs False otherwise.\n\nChoices:\n0: def different_signs(num1: int, num2: int) -> bool:     return num1 ^ num2 < 0\n1: def permutation_index(element, iterable):     index = 0     pool = list(iterable)     for i, x in zip(range(len(pool), -1, -1), element):         r = pool.index(x)         index = index * i + r         del pool[r]      return index\n2: def util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:      # Base Case     if curr_ind == len(graph):         # return whether path exists between current and starting vertices         return graph[path[curr_ind - 1]][path[0]] == 1      # Recursive Step     for next_ver in range(len(graph)):         if valid_connection(graph, next_ver, curr_ind, path):             # Insert current vertex  into path as next transition             path[curr_ind] = next_ver             # Validate created path             if util_hamilton_cycle(graph, path, curr_ind + 1):                 return True             # Backtrack             path[curr_ind] = -1     return False", "output": "0"}
{"task": "search", "input": "search code:\nYield the set partitions of *iterable* into *k* parts. Set partitions are\n\nChoices:\n0: def calculate_span(price: list[int]) -> list[int]:     n = len(price)     s = [0] * n     # Create a stack and push index of fist element to it     st = []     st.append(0)      # Span value of first element is always 1     s[0] = 1      # Calculate span values for rest of the elements     for i in range(1, n):         # Pop elements from stack while stack is not         # empty and top of stack is smaller than price[i]         while len(st) > 0 and price[st[-1]] <= price[i]:             st.pop()          # If stack becomes empty, then price[i] is greater         # than all elements on left of it, i.e. price[0],         # price[1], ..price[i-1]. Else the price[i]  is         # greater than elements after top of stack         s[i] = i + 1 if len(st) <= 0 else (i - st[-1])          # Push this element to stack         st.append(i)      return s\n1: def manhattan_distance_one_liner(point_a: list, point_b: list) -> float:      _validate_point(point_a)     _validate_point(point_b)     if len(point_a) != len(point_b):         raise ValueError(\"Both points must be in the same n-dimensional space\")      return float(sum(abs(x - y) for x, y in zip(point_a, point_b)))\n2: def set_partitions(iterable, k=None, min_size=None, max_size=None):     L = list(iterable)     n = len(L)     if k is not None:         if k < 1:             raise ValueError(                 \"Can't partition in a negative or zero number of groups\"             )         elif k > n:             return      min_size = min_size if min_size is not None else 0     max_size = max_size if max_size is not None else n     if min_size > max_size:         return      def set_partitions_helper(L, k):         n = len(L)         if k == 1:             yield [L]         elif n == k:             yield [[s] for s in L]         else:             e, *M = L             for p in set_partitions_helper(M, k - 1):                 yield [[e], *p]             for p in set_partitions_helper(M, k):                 for i in range(len(p)):                     yield p[:i] + [[e] + p[i]] + p[i + 1 :]      if k is None:         for k in range(1, n + 1):             yield from filter(                 lambda z: all(min_size <= len(bk) <= max_size for bk in z),                 set_partitions_helper(L, k),             )     else:         yield from filter(             lambda z: all(min_size <= len(bk) <= max_size for bk in z),             set_partitions_helper(L, k),         )", "output": "2"}
{"task": "search", "input": "search code:\nreturns n-th term of sequence\n\nChoices:\n0: def local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:     center = image[x_coordinate][y_coordinate]     powers = [1, 2, 4, 8, 16, 32, 64, 128]      # skip get_neighbors_pixel if center is null     if center is None:         return 0      # Starting from the top right, assigning value to pixels clockwise     binary_values = [         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),         get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),     ]      # Converting the binary value to decimal.     return sum(         binary_value * power for binary_value, power in zip(binary_values, powers)     )\n1: def decimal_to_binary_recursive_helper(decimal: int) -> str:     decimal = int(decimal)     if decimal in (0, 1):  # Exit cases for the recursion         return str(decimal)     div, mod = divmod(decimal, 2)     return decimal_to_binary_recursive_helper(div) + str(mod)\n2: def solution(n: int = 10**15) -> int:      digits = [1]     i = 1     dn = 0     while True:         _diff, terms_jumped = next_term(digits, 20, i + dn, n)         dn += terms_jumped         if dn == n - i:             break      a_n = 0     for j in range(len(digits)):         a_n += digits[j] * 10**j     return a_n", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef is_sum_subset(arr, arr_len, required_sum):\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 4, 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 4, 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    subset = [[False for i in range(required_sum + 1)] for i in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    # uncomment to print the subset\n    # for i in range(arrLen+1):\n    #     print(subset[i])\n    print(subset[arr_len][required_sum])", "output": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    return subset[arr_len][required_sum]", "tests": ["assert is_sum_subset([2, 4, 6, 8], 5) == False", "assert is_sum_subset([2, 4, 6, 8], 14) == True"]}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 10000) -> int:\n    count_odd_periods = 0\n    for i in range(2, n + 1):\n        sr = sqrt(i)\n        if sr - floor(sr) != 0 and continuous_fraction_period(i) % 2 == 1:\n            count_odd_periods += 1\n    return count_odd_periods", "output": "Returns the count of numbers <= 10000 with odd periods."}
{"task": "repair", "input": "fix bug:\ndef solution(n):\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    [2, 8]\r\n    >>> solution(15)\r\n    [2, 8]\r\n    >>> solution(2)\r\n    [2]\r\n    >>> solution(1)\r\n    []\r\n    >>> solution(34)\r\n    [2, 8, 34]\r\n    \"\"\"\r\n    ls = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            ls.append(b)\r\n        a, b = b, a + b\r\n    return ls\r", "output": "def solution(n: int = 4000000) -> int:\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    10\r\n    >>> solution(15)\r\n    10\r\n    >>> solution(2)\r\n    2\r\n    >>> solution(1)\r\n    0\r\n    >>> solution(34)\r\n    44\r\n    \"\"\"\r\n    even_fibs = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            even_fibs.append(b)\r\n        a, b = b, a + b\r\n    return sum(even_fibs)\r", "tests": ["assert solution(10) == 10", "assert solution(15) == 10", "assert solution(2) == 2", "assert solution(1) == 0", "assert solution(34) == 44"]}
{"task": "summary", "input": "summarize code:\ndef prepend(value, iterator):\n    return chain([value], iterator)", "output": "Yield *value*, followed by the elements in *iterator*."}
{"task": "repair", "input": "fix bug:\ndef is_ip_v4_address_valid(ip_v4_address: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.255.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"254.255.0.255\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n    \"\"\"\n    octets = [int(i) for i in ip_v4_address.split(\".\") if i.isdigit()]\n    return len(octets) == 4 and all(0 <= int(octet) <= 254 for octet in octets)", "output": "def is_ip_v4_address_valid(ip: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.256.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"255.256.0.256\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.05\")\n    False\n    \"\"\"\n    octets = ip.split(\".\")\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        if not octet.isdigit():\n            return False\n\n        number = int(octet)\n        if len(str(number)) != len(octet):\n            return False\n\n        if not 0 <= number <= 255:\n            return False\n\n    return True", "tests": ["assert is_ip_v4_address_valid(\"192.168.0.23\") == True", "assert is_ip_v4_address_valid(\"192.256.15.8\") == False", "assert is_ip_v4_address_valid(\"172.100.0.8\") == True", "assert is_ip_v4_address_valid(\"255.256.0.256\") == False", "assert is_ip_v4_address_valid(\"1.2.33333333.4\") == False", "assert is_ip_v4_address_valid(\"1.2.-3.4\") == False", "assert is_ip_v4_address_valid(\"1.2.3\") == False", "assert is_ip_v4_address_valid(\"1.2.3.4.5\") == False", "assert is_ip_v4_address_valid(\"1.2.A.4\") == False", "assert is_ip_v4_address_valid(\"0.0.0.0\") == True", "assert is_ip_v4_address_valid(\"1.2.3.\") == False", "assert is_ip_v4_address_valid(\"1.2.3.05\") == False"]}
{"task": "search", "input": "search code:\n[summary]\n\nChoices:\n0: def solution(max_d: int = 12_000) -> int:      fractions_number = 0     for d in range(max_d + 1):         n_start = d // 3 + 1         n_step = 1         if d % 2 == 0:             n_start += 1 - n_start % 2             n_step = 2         for n in range(n_start, (d + 1) // 2, n_step):             if gcd(n, d) == 1:                 fractions_number += 1     return fractions_number\n1: def shell_sort(collection: list[int]) -> list[int]:     # Marcin Ciura's gap sequence      gaps = [701, 301, 132, 57, 23, 10, 4, 1]     for gap in gaps:         for i in range(gap, len(collection)):             insert_value = collection[i]             j = i             while j >= gap and collection[j - gap] > insert_value:                 collection[j] = collection[j - gap]                 j -= gap             if j != i:                 collection[j] = insert_value     return collection\n2: def search_anime_episode_list(episode_endpoint: str) -> list:      request_url = f\"{BASE_URL}{episode_endpoint}\"      response = httpx.get(         url=request_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10     )     response.raise_for_status()      soup = BeautifulSoup(response.text, \"html.parser\")      # With this id. get the episode list.     episode_page_ul = soup.find(\"ul\", {\"id\": \"episode_related\"})     if episode_page_ul is None or isinstance(episode_page_ul, NavigableString):         msg = f\"Could not find any anime eposiodes with name {anime_name}\"         raise ValueError(msg)     episode_page_li = episode_page_ul.children      episode_list = []     for episode in episode_page_li:         if isinstance(episode, Tag):             url = episode.find(\"a\")             if url is None or isinstance(url, NavigableString):                 continue             title = episode.find(\"div\", {\"class\": \"name\"})             if title is None or isinstance(title, NavigableString):                 continue              episode_list.append(                 {\"title\": title.text.replace(\" \", \"\"), \"url\": url[\"href\"]}             )      return episode_list", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(m: int = 100) -> int:\n    memo = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1", "output": "Returns the number of different ways the number m can be written as a"}
{"task": "summary", "input": "summarize code:\ndef find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:\n    if not nums1 and not nums2:\n        raise ValueError(\"Both input arrays are empty.\")\n\n    # Merge the arrays into a single sorted array.\n    merged = sorted(nums1 + nums2)\n    total = len(merged)\n\n    if total % 2 == 1:  # If the total number of elements is odd\n        return float(merged[total // 2])  # then return the middle element\n\n    # If the total number of elements is even, calculate\n    # the average of the two middle elements as the median.\n    middle1 = merged[total // 2 - 1]\n    middle2 = merged[total // 2]\n    return (float(middle1) + float(middle2)) / 2.0", "output": "Find the median of two arrays."}
{"task": "summary", "input": "summarize code:\ndef generate_formula() -> Formula:\n    clauses: set[Clause] = set()\n    no_of_clauses = random.randint(1, 10)\n    while len(clauses) < no_of_clauses:\n        clauses.add(generate_clause())\n    return Formula(clauses)", "output": "Randomly generate a formula."}
{"task": "summary", "input": "summarize code:\ndef index_2d_array_in_1d(array: list[list[int]], index: int) -> int:\n    rows = len(array)\n    cols = len(array[0])\n\n    if rows == 0 or cols == 0:\n        raise ValueError(\"no items in array\")\n\n    if index < 0 or index >= rows * cols:\n        raise ValueError(\"index out of range\")\n\n    return array[index // cols][index % cols]", "output": "Retrieves the value of the one-dimensional index from a two-dimensional array."}
{"task": "search", "input": "search code:\nSemi-intelligently converts an English *word* from singular form to\n\nChoices:\n0: def longest_common_subsequence(x: str, y: str):     # find the length of strings      assert x is not None     assert y is not None      m = len(x)     n = len(y)      # declaring the array for storing the dp values     dp = [[0] * (n + 1) for _ in range(m + 1)]      for i in range(1, m + 1):         for j in range(1, n + 1):             match = 1 if x[i - 1] == y[j - 1] else 0              dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)      seq = \"\"     i, j = m, n     while i > 0 and j > 0:         match = 1 if x[i - 1] == y[j - 1] else 0          if dp[i][j] == dp[i - 1][j - 1] + match:             if match == 1:                 seq = x[i - 1] + seq             i -= 1             j -= 1         elif dp[i][j] == dp[i - 1][j]:             i -= 1         else:             j -= 1      return dp[m][n], seq\n1: def pluralize(word):     orig_word, word = word, word.strip().lower()     if not word or word in _IRR_P2S:         return orig_word     irr_plural = _IRR_S2P.get(word)     if irr_plural:         plural = irr_plural     elif word.endswith('y') and word[-2:-1] not in 'aeiou':         plural = word[:-1] + 'ies'     elif word[-1] == 's' or word.endswith('ch') or word.endswith('sh'):         plural = word if word.endswith('es') else word + 'es'     else:         plural = word + 's'     return _match_case(orig_word, plural)\n2: def horn_schunck(     image0: np.ndarray,     image1: np.ndarray,     num_iter: SupportsIndex,     alpha: float | None = None, ) -> tuple[np.ndarray, np.ndarray]:     if alpha is None:         alpha = 0.1      # Initialize flow     horizontal_flow = np.zeros_like(image0)     vertical_flow = np.zeros_like(image0)      # Prepare kernels for the calculation of the derivatives and the average velocity     kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25     kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25     kernel_t = np.array([[1, 1], [1, 1]]) * 0.25     kernel_laplacian = np.array(         [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]     )      # Iteratively refine the flow     for _ in range(num_iter):         warped_image = warp(image0, horizontal_flow, vertical_flow)         derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)         derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)         derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)          avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)         avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)          # This updates the flow as proposed in the paper (Step 12)         update = (             derivative_x * avg_horizontal_velocity             + derivative_y * avg_vertical_velocity             + derivative_t         )         update = update / (alpha**2 + derivative_x**2 + derivative_y**2)          horizontal_flow = avg_horizontal_velocity - derivative_x * update         vertical_flow = avg_vertical_velocity - derivative_y * update      return horizontal_flow, vertical_flow", "output": "1"}
{"task": "search", "input": "search code:\nReturn the interquartile range for a list of numeric values.\n\nChoices:\n0: def run_maze(     maze: list[list[int]],     i: int,     j: int,     destination_row: int,     destination_column: int,     solutions: list[list[int]], ) -> bool:     size = len(maze)     # Final check point.     if i == destination_row and j == destination_column and maze[i][j] == 0:         solutions[i][j] = 0         return True      lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds     upper_flag = (i < size) and (j < size)  # Check upper bounds      if lower_flag and upper_flag:         # check for already visited and block points.         block_flag = (solutions[i][j]) and (not maze[i][j])         if block_flag:             # check visited             solutions[i][j] = 0              # check for directions             if (                 run_maze(maze, i + 1, j, destination_row, destination_column, solutions)                 or run_maze(                     maze, i, j + 1, destination_row, destination_column, solutions                 )                 or run_maze(                     maze, i - 1, j, destination_row, destination_column, solutions                 )                 or run_maze(                     maze, i, j - 1, destination_row, destination_column, solutions                 )             ):                 return True              solutions[i][j] = 1             return False     return False\n1: def interquartile_range(nums: list[int | float]) -> float:     if not nums:         raise ValueError(\"The list is empty. Provide a non-empty list.\")     nums.sort()     length = len(nums)     div, mod = divmod(length, 2)     q1 = find_median(nums[:div])     half_length = sum((div, mod))     q3 = find_median(nums[half_length:length])     return q3 - q1\n2: def ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:     if (voltage, current, resistance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance < 0:         raise ValueError(\"Resistance cannot be negative\")     if voltage == 0:         return {\"voltage\": float(current * resistance)}     elif current == 0:         return {\"current\": voltage / resistance}     elif resistance == 0:         return {\"resistance\": voltage / current}     else:         raise ValueError(\"Exactly one argument must be 0\")", "output": "1"}
{"task": "search", "input": "search code:\nReturns the maximum pandigital prime number of length n.\n\nChoices:\n0: def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:     arr.sort()     n = len(arr)     for i in range(n - 1):         left, right = i + 1, n - 1         while left < right:             if arr[i] + arr[left] + arr[right] == target:                 return (arr[i], arr[left], arr[right])             elif arr[i] + arr[left] + arr[right] < target:                 left += 1             elif arr[i] + arr[left] + arr[right] > target:                 right -= 1     return (0, 0, 0)\n1: def solution(n: int = 7) -> int:     pandigital_str = \"\".join(str(i) for i in range(1, n + 1))     perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]     pandigitals = [num for num in perm_list if is_prime(num)]     return max(pandigitals) if pandigitals else 0\n2: def newton_raphson(     f: RealFunc,     x0: float = 0,     max_iter: int = 100,     step: float = 1e-6,     max_error: float = 1e-6,     log_steps: bool = False, ) -> tuple[float, float, list[float]]:      def f_derivative(x: float) -> float:         return calc_derivative(f, x, step)      a = x0  # Set initial guess     steps = []     for _ in range(max_iter):         if log_steps:  # Log intermediate steps             steps.append(a)          error = abs(f(a))         if error < max_error:             return a, error, steps          if f_derivative(a) == 0:             raise ZeroDivisionError(\"No converging solution found, zero derivative\")         a -= f(a) / f_derivative(a)  # Calculate next estimate     raise ArithmeticError(\"No converging solution found, iteration limit reached\")", "output": "1"}
{"task": "detection", "input": "classify code:\ndef list_truncated_nums(n: int) -> list[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r", "output": "CORRECT"}
{"task": "search", "input": "search code:\nPseudo-Code\n\nChoices:\n0: def util_color(     graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int ) -> bool:      # Base Case     if index == len(graph):         return True      # Recursive Step     for i in range(max_colors):         if valid_coloring(graph[index], colored_vertices, i):             # Color current vertex             colored_vertices[index] = i             # Validate coloring             if util_color(graph, max_colors, colored_vertices, index + 1):                 return True             # Backtrack             colored_vertices[index] = -1     return False\n1: def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:      try:         # Has user provided both inputs?         if not drug_name or not zip_code:             return None          request_url = BASE_URL.format(drug_name, zip_code)         response = httpx.get(request_url, timeout=10).raise_for_status()          # Scrape the data using bs4         soup = BeautifulSoup(response.text, \"html.parser\")          # This list will store the name and price.         pharmacy_price_list = []          # Fetch all the grids that contain the items.         grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})         if grid_list and len(grid_list) > 0:             for grid in grid_list:                 # Get the pharmacy price.                 pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text                  # Get the price of the drug.                 price = grid.find(\"span\", {\"p\", \"price price-large\"}).text                  pharmacy_price_list.append(                     {                         \"pharmacy_name\": pharmacy_name,                         \"price\": price,                     }                 )          return pharmacy_price_list      except (httpx.HTTPError, ValueError):         return None\n2: def generate_formula() -> Formula:     clauses: set[Clause] = set()     no_of_clauses = random.randint(1, 10)     while len(clauses) < no_of_clauses:         clauses.add(generate_clause())     return Formula(clauses)", "output": "0"}
{"task": "search", "input": "search code:\nReturn true if the input n is a palindrome.\n\nChoices:\n0: def is_combination_valid(combination):     return (         int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))         == int(\"\".join(combination[5:9]))     ) or (         int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))         == int(\"\".join(combination[5:9]))     )\n1: def archimedes_principle(     fluid_density: float, volume: float, gravity: float = g ) -> float:      if fluid_density <= 0:         raise ValueError(\"Impossible fluid density\")     if volume <= 0:         raise ValueError(\"Impossible object volume\")     if gravity < 0:         raise ValueError(\"Impossible gravity\")      return fluid_density * gravity * volume\n2: def is_palindrome(n: int | str) -> bool:     n = str(n)     return n == n[::-1]", "output": "2"}
{"task": "search", "input": "search code:\nImplements the Damerau-Levenshtein distance algorithm that measures\n\nChoices:\n0: def dp_match(text: str, pattern: str) -> bool:     m = len(text)     n = len(pattern)     dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]     dp[0][0] = True      for j in range(1, n + 1):         dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]      for i in range(1, m + 1):         for j in range(1, n + 1):             if pattern[j - 1] in {\".\", text[i - 1]}:                 dp[i][j] = dp[i - 1][j - 1]             elif pattern[j - 1] == \"*\":                 dp[i][j] = dp[i][j - 2]                 if pattern[j - 2] in {\".\", text[i - 1]}:                     dp[i][j] |= dp[i - 1][j]             else:                 dp[i][j] = False      return dp[m][n]\n1: def damerau_levenshtein_distance(first_string: str, second_string: str) -> int:     # Create a dynamic programming matrix to store the distances     dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]      # Initialize the matrix     for i in range(len(first_string) + 1):         dp_matrix[i][0] = i     for j in range(len(second_string) + 1):         dp_matrix[0][j] = j      # Fill the matrix     for i, first_char in enumerate(first_string, start=1):         for j, second_char in enumerate(second_string, start=1):             cost = int(first_char != second_char)              dp_matrix[i][j] = min(                 dp_matrix[i - 1][j] + 1,  # Deletion                 dp_matrix[i][j - 1] + 1,  # Insertion                 dp_matrix[i - 1][j - 1] + cost,  # Substitution             )              if (                 i > 1                 and j > 1                 and first_string[i - 1] == second_string[j - 2]                 and first_string[i - 2] == second_string[j - 1]             ):                 # Transposition                 dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)      return dp_matrix[-1][-1]\n2: def emitter_converter(size_par, data):     if size_par + len(data) <= 2**size_par - (len(data) - 1):         raise ValueError(\"size of parity don't match with size of data\")      data_out = []     parity = []     bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]      # sorted information data for the size of the output data     data_ord = []     # data position template + parity     data_out_gab = []     # parity bit counter     qtd_bp = 0     # counter position of data bits     cont_data = 0      for x in range(1, size_par + len(data) + 1):         # Performs a template of bit positions - who should be given,         # and who should be parity         if qtd_bp < size_par:             if (np.log(x) / np.log(2)).is_integer():                 data_out_gab.append(\"P\")                 qtd_bp = qtd_bp + 1             else:                 data_out_gab.append(\"D\")         else:             data_out_gab.append(\"D\")          # Sorts the data to the new output size         if data_out_gab[-1] == \"D\":             data_ord.append(data[cont_data])             cont_data += 1         else:             data_ord.append(None)      # Calculates parity     qtd_bp = 0  # parity bit counter     for bp in range(1, size_par + 1):         # Bit counter one for a given parity         cont_bo = 0         # counter to control the loop reading         for cont_loop, x in enumerate(data_ord):             if x is not None:                 try:                     aux = (bin_pos[cont_loop])[-1 * (bp)]                 except IndexError:                     aux = \"0\"                 if aux == \"1\" and x == \"1\":                     cont_bo += 1         parity.append(cont_bo % 2)          qtd_bp += 1      # Mount the message     cont_bp = 0  # parity bit counter     for x in range(size_par + len(data)):         if data_ord[x] is None:             data_out.append(str(parity[cont_bp]))             cont_bp += 1         else:             data_out.append(data_ord[x])      return data_out", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef dp_count(S, m, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 3, 4)\n    4\n    >>> dp_count([1, 2, 3], 3, 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 4, 10)\n    5\n    >>> dp_count([10], 1, 99)\n    0\n    >>> dp_count([4, 5, 6], 3, 0)\n    1\n    \"\"\"\n\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]", "output": "def dp_count(S, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 4)\n    4\n    >>> dp_count([1, 2, 3], 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 10)\n    5\n    >>> dp_count([10], 99)\n    0\n    >>> dp_count([4, 5, 6], 0)\n    1\n    >>> dp_count([1, 2, 3], -5)\n    0\n    \"\"\"\n    if n < 0:\n        return 0\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]", "tests": ["assert dp_count([1, 2, 3], 4) == 4", "assert dp_count([1, 2, 3], 7) == 8", "assert dp_count([2, 5, 3, 6], 10) == 5", "assert dp_count([10], 99) == 0", "assert dp_count([4, 5, 6], 0) == 1", "assert dp_count([1, 2, 3], -5) == 0"]}
{"task": "search", "input": "search code:\nFind the solution for the knight tour problem for a board of size n. Raises\n\nChoices:\n0: def binary_xor(a: int, b: int) -> str:     if a < 0 or b < 0:         raise ValueError(\"the value of both inputs must be positive\")      a_binary = str(bin(a))[2:]  # remove the leading \"0b\"     b_binary = str(bin(b))[2:]  # remove the leading \"0b\"      max_len = max(len(a_binary), len(b_binary))      return \"0b\" + \"\".join(         str(int(char_a != char_b))         for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))     )\n1: def open_knight_tour(n: int) -> list[list[int]]:      board = [[0 for i in range(n)] for j in range(n)]      for i in range(n):         for j in range(n):             board[i][j] = 1             if open_knight_tour_helper(board, (i, j), 1):                 return board             board[i][j] = 0      msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"     raise ValueError(msg)\n2: def rstrip_iter(iterable, strip_value=None):     iterator = iter(iterable)     for i in iterator:         if i == strip_value:             cache = list()             cache.append(i)             broken = False             for i in iterator:                 if i == strip_value:                     cache.append(i)                 else:                     broken = True                     break             if not broken:  # Return to caller here because the end of the                 return     # iterator has been reached             yield from cache         yield i", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef knapsack(\n    capacity: int,\n    weights: list[int],\n    values: list[int],\n    counter: int,\n    allow_repetition=False,\n) -> int:\n\n    @lru_cache\n    def knapsack_recur(capacity: int, counter: int) -> int:\n        # Base Case\n        if counter == 0 or capacity == 0:\n            return 0\n\n        # If weight of the nth item is more than Knapsack of capacity,\n        #   then this item cannot be included in the optimal solution,\n        # else return the maximum of two cases:\n        #   (1) nth item included only once (0-1), if allow_repetition is False\n        #       nth item included one or more times (0-N), if allow_repetition is True\n        #   (2) not included\n        if weights[counter - 1] > capacity:\n            return knapsack_recur(capacity, counter - 1)\n        else:\n            left_capacity = capacity - weights[counter - 1]\n            new_value_included = values[counter - 1] + knapsack_recur(\n                left_capacity, counter - 1 if not allow_repetition else counter\n            )\n            without_new_value = knapsack_recur(capacity, counter - 1)\n            return max(new_value_included, without_new_value)\n\n    return knapsack_recur(capacity, counter)", "output": "Returns the maximum value that can be put in a knapsack of a capacity cap,"}
{"task": "search", "input": "search code:\nConversion between volume units.\n\nChoices:\n0: def centripetal(mass: float, velocity: float, radius: float) -> float:     if mass < 0:         raise ValueError(\"The mass of the body cannot be negative\")     if radius <= 0:         raise ValueError(\"The radius is always a positive non zero integer\")     return (mass * (velocity) ** 2) / radius\n1: def slow_solution(max_number: int = 10**8) -> int:      prime_numbers = slow_calculate_prime_numbers(max_number // 2)      semiprimes_count = 0     left = 0     right = len(prime_numbers) - 1     while left <= right:         while prime_numbers[left] * prime_numbers[right] >= max_number:             right -= 1         semiprimes_count += right - left + 1         left += 1      return semiprimes_count\n2: def volume_conversion(value: float, from_type: str, to_type: str) -> float:     if from_type not in METRIC_CONVERSION:         raise ValueError(             f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"             + \", \".join(METRIC_CONVERSION)         )     if to_type not in METRIC_CONVERSION:         raise ValueError(             f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"             + \", \".join(METRIC_CONVERSION)         )     return (         value         * METRIC_CONVERSION[from_type].from_factor         * METRIC_CONVERSION[to_type].to_factor     )", "output": "2"}
{"task": "search", "input": "search code:\n:param number: nth catalan number to calculate\n\nChoices:\n0: def is_hermitian(matrix: np.ndarray) -> bool:     return np.array_equal(matrix, matrix.conjugate().T)\n1: def running_key_encrypt(key: str, plaintext: str) -> str:     plaintext = plaintext.replace(\" \", \"\").upper()     key = key.replace(\" \", \"\").upper()     key_length = len(key)     ciphertext = []     ord_a = ord(\"A\")      for i, char in enumerate(plaintext):         p = ord(char) - ord_a         k = ord(key[i % key_length]) - ord_a         c = (p + k) % 26         ciphertext.append(chr(c + ord_a))      return \"\".join(ciphertext)\n2: def catalan(number: int) -> int:      if not isinstance(number, int):         msg = f\"Input value of [number={number}] must be an integer\"         raise TypeError(msg)      if number < 1:         msg = f\"Input value of [number={number}] must be > 0\"         raise ValueError(msg)      current_number = 1      for i in range(1, number):         current_number *= 4 * i - 2         current_number //= i + 1      return current_number", "output": "2"}
{"task": "search", "input": "search code:\nReturns the number of values of nCr, for 1  n  100, are greater than\n\nChoices:\n0: def solution(n: int = 200) -> int:     return two_pound(n)\n1: def solution():     total = 0      for i in range(1, 101):         for j in range(1, i + 1):             if combinations(i, j) > 1e6:                 total += 1     return total\n2: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]", "output": "1"}
{"task": "search", "input": "search code:\nCalculate the sum of digit values in a positive integer\n\nChoices:\n0: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n1: def sum_of_digits(num: int, base: int) -> str:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      num_str = int_to_base(num, base)     res = sum(int(char, base) for char in num_str)     res_str = int_to_base(res, base)     return res_str\n2: def gaussian_error_linear_unit(vector: np.ndarray) -> np.ndarray:     return vector * sigmoid(1.702 * vector)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nRecursive matching algorithm.\n\nChoices:\n0: def recursive_match(text: str, pattern: str) -> bool:     if not pattern:         return not text      if not text:         return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])      if text[-1] == pattern[-1] or pattern[-1] == \".\":         return recursive_match(text[:-1], pattern[:-1])      if pattern[-1] == \"*\":         return recursive_match(text[:-1], pattern) or recursive_match(             text, pattern[:-2]         )      return False\n1: def create_ngram(sentence: str, ngram_size: int) -> list[str]:     return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]\n2: def topological_sort(start: str, visited: list[str], sort: list[str]) -> list[str]:     current = start     # add current to visited     visited.append(current)     neighbors = edges[current]     for neighbor in neighbors:         # if neighbor not in visited, visit         if neighbor not in visited:             sort = topological_sort(neighbor, visited, sort)     # if all neighbors visited add current to sort     sort.append(current)     # if all vertices haven't been visited select a new one to visit     if len(visited) != len(vertices):         for vertice in vertices:             if vertice not in visited:                 sort = topological_sort(vertice, visited, sort)     # return sort     return sort", "output": "0"}
{"task": "search", "input": "search code:\nThis function returns the longest palindromic subsequence in a string\n\nChoices:\n0: def longest_palindromic_subsequence(input_string: str) -> int:     n = len(input_string)     rev = input_string[::-1]     m = len(rev)     dp = [[-1] * (m + 1) for i in range(n + 1)]     for i in range(n + 1):         dp[i][0] = 0     for i in range(m + 1):         dp[0][i] = 0      # create and initialise dp array     for i in range(1, n + 1):         for j in range(1, m + 1):             # If characters at i and j are the same             # include them in the palindromic subsequence             if input_string[i - 1] == rev[j - 1]:                 dp[i][j] = 1 + dp[i - 1][j - 1]             else:                 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])      return dp[n][m]\n1: def prime_sieve(num: int) -> list[int]:      if num <= 0:         msg = f\"{num}: Invalid input, please enter a positive integer.\"         raise ValueError(msg)      sieve = [True] * (num + 1)     prime = []     start = 2     end = int(math.sqrt(num))      while start <= end:         # If start is a prime         if sieve[start] is True:             prime.append(start)              # Set multiples of start be False             for i in range(start * start, num + 1, start):                 if sieve[i] is True:                     sieve[i] = False          start += 1      for j in range(end + 1, num + 1):         if sieve[j] is True:             prime.append(j)      return prime\n2: def pairwise_iter(src, end=_UNSET):     return windowed_iter(src, 2, fill=end)", "output": "0"}
{"task": "search", "input": "search code:\nEnciphers a message given a cipher map.\n\nChoices:\n0: def encipher(message: str, cipher_map: dict[str, str]) -> str:     return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())\n1: def try_key(ciphertext: list[int], key: tuple[int, ...]) -> str | None:     decoded: str = \"\"     keychar: int     cipherchar: int     decodedchar: int      for keychar, cipherchar in zip(cycle(key), ciphertext):         decodedchar = cipherchar ^ keychar         if decodedchar not in VALID_INTS:             return None         decoded += chr(decodedchar)      return decoded\n2: def is_combination_valid(combination):     return (         int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))         == int(\"\".join(combination[5:9]))     ) or (         int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))         == int(\"\".join(combination[5:9]))     )", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    prime_list = [n for n in range(1001, 10000, 2) if is_prime(n)]\n    candidates = []\n\n    for number in prime_list:\n        tmp_numbers = []\n\n        for prime_member in permutations(list(str(number))):\n            prime = int(\"\".join(prime_member))\n\n            if prime % 2 == 0:\n                continue\n\n            if search(prime, prime_list):\n                tmp_numbers.append(prime)\n\n        tmp_numbers.sort()\n        if len(tmp_numbers) >= 3:\n            candidates.append(tmp_numbers)\n\n    passed = []\n    for candidate in candidates:\n        length = len(candidate)\n        found = False\n\n        for i in range(length):\n            for j in range(i + 1, length):\n                for k in range(j + 1, length):\n                    if (\n                        abs(candidate[i] - candidate[j])\n                        == abs(candidate[j] - candidate[k])\n                        and len({candidate[i], candidate[j], candidate[k]}) == 3\n                    ):\n                        passed.append(\n                            sorted([candidate[i], candidate[j], candidate[k]])\n                        )\n                        found = True\n\n                    if found:\n                        break\n                if found:\n                    break\n            if found:\n                break\n\n    answer = set()\n    for seq in passed:\n        answer.add(\"\".join([str(i) for i in seq]))\n\n    return max(int(x) for x in answer)", "output": "Return the solution of the problem."}
{"task": "search", "input": "search code:\nPrint the upper half of a diamond pattern with '*' characters.\n\nChoices:\n0: def sum_of_divisors(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = 1     temp = 1     while n % 2 == 0:         temp += 1         n = int(n / 2)     if temp > 1:         s *= (2**temp - 1) / (2 - 1)     for i in range(3, int(math.sqrt(n)) + 1, 2):         temp = 1         while n % i == 0:             temp += 1             n = int(n / i)         if temp > 1:             s *= (i**temp - 1) / (i - 1)     return int(s)\n1: def floyd(n):     result = \"\"     for i in range(n):         for _ in range(n - i - 1):  # printing spaces             result += \" \"         for _ in range(i + 1):  # printing stars             result += \"* \"         result += \"\\n\"     return result\n2: def fix_print_exception():     sys.excepthook = print_exception", "output": "1"}
{"task": "detection", "input": "classify code:\ndef column_based_sort(array, column=0):\n    \"\"\"\n    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\n    [(3, 0), (5, 1), (4, 2)]\n    \"\"\"\n    return sorted(array, key=lambda x: x[column])", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef levenshtein_distance(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Implementation of the Levenshtein distance in Python.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance(\"\", \"test\")\n    4\n    >>> levenshtein_distance(\"book\", \"back\")\n    2\n    >>> levenshtein_distance(\"book\", \"book\")\n    0\n    >>> levenshtein_distance(\"test\", \"\")\n    4\n    >>> levenshtein_distance(\"\", \"\")\n    0\n    >>> levenshtein_distance(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    # The longer word should come first\n    if len(first_word) < len(second_word):\n        return levenshtein_distance(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1]\n\n        for j, c2 in enumerate(second_word):\n            # Calculate insertions, deletions, and substitutions\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n\n            # Get the minimum to append to the current row\n            current_row.append(min(insertions, deletions, substitutions))\n\n        # Store the previous row\n        previous_row = current_row\n\n    # Returns the last element (distance)\n    return previous_row[-1]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef prime_sieve_eratosthenes(num: int) -> list[int]:\n\n    if num <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    primes = [True] * (num + 1)\n\n    p = 2\n    while p * p <= num:\n        if primes[p]:\n            for i in range(p * p, num + 1, p):\n                primes[i] = False\n        p += 1\n\n    return [prime for prime in range(2, num + 1) if primes[prime]]", "output": "Print the prime numbers up to n"}
{"task": "search", "input": "search code:\nThis function used the above inversion of a to find x = (b*a^(-1))mod n\n\nChoices:\n0: def modular_division2(a: int, b: int, n: int) -> int:     s = invert_modulo(a, n)     x = (b * s) % n     return x\n1: def consumer(func):      @wraps(func)     def wrapper(*args, **kwargs):         gen = func(*args, **kwargs)         next(gen)         return gen      return wrapper\n2: def binary_exp_mod_iterative(base: float, exponent: int, modulus: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")     if modulus <= 0:         raise ValueError(\"Modulus must be a positive integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res = ((res % modulus) * (base % modulus)) % modulus          base *= base         exponent >>= 1      return res", "output": "0"}
{"task": "search", "input": "search code:\nTransforms a camelCase (or PascalCase) string to snake_case\n\nChoices:\n0: def valid_connection(     graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int] ) -> bool:      # 1. Validate that path exists between current and next vertices     if graph[path[curr_ind - 1]][next_ver] == 0:         return False      # 2. Validate that next vertex is not already in path     return not any(vertex == next_ver for vertex in path)\n1: def solution(n: int = 1000) -> int:      a = 3     result = 0     while a < n:         if a % 3 == 0 or a % 5 == 0:             result += a         elif a % 15 == 0:             result -= a         a += 1     return result\n2: def camel_to_snake_case(input_str: str) -> str:      # check for invalid input type     if not isinstance(input_str, str):         msg = f\"Expected string as input, found {type(input_str)}\"         raise ValueError(msg)      snake_str = \"\"      for index, char in enumerate(input_str):         if char.isupper():             snake_str += \"_\" + char.lower()          # if char is lowercase but proceeded by a digit:         elif input_str[index - 1].isdigit() and char.islower():             snake_str += \"_\" + char          # if char is a digit proceeded by a letter:         elif input_str[index - 1].isalpha() and char.isnumeric():             snake_str += \"_\" + char.lower()          # if char is not alphanumeric:         elif not char.isalnum():             snake_str += \"_\"          else:             snake_str += char      # remove leading underscore     if snake_str[0] == \"_\":         snake_str = snake_str[1:]      return snake_str", "output": "2"}
{"task": "search", "input": "search code:\nCalculate the probability that a given instance will belong to which class\n\nChoices:\n0: def non_bouncy_upto(n: int) -> int:     return sum(non_bouncy_exact(i) for i in range(1, n + 1))\n1: def solution(max_n: int = 10000000) -> int:      min_numerator = 1  # i     min_denominator = 0  # (i)     totients = get_totients(max_n + 1)      for i in range(2, max_n + 1):         t = totients[i]          if i * min_denominator < min_numerator * t and has_same_digits(i, t):             min_numerator = i             min_denominator = t      return min_numerator\n2: def calculate_probabilities(instance_count: int, total_count: int) -> float:     # number of instances in specific class divided by number of all instances     return instance_count / total_count", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef get_frequency_order(message: str) -> str:\n    letter_to_freq = get_letter_count(message)\n    freq_to_letter: dict[int, list[str]] = {\n        freq: [] for letter, freq in letter_to_freq.items()\n    }\n    for letter in LETTERS:\n        freq_to_letter[letter_to_freq[letter]].append(letter)\n\n    freq_to_letter_str: dict[int, str] = {}\n\n    for freq in freq_to_letter:  # noqa: PLC0206\n        freq_to_letter[freq].sort(key=ETAOIN.find, reverse=True)\n        freq_to_letter_str[freq] = \"\".join(freq_to_letter[freq])\n\n    freq_pairs = list(freq_to_letter_str.items())\n    freq_pairs.sort(key=get_item_at_index_zero, reverse=True)\n\n    freq_order: list[str] = [freq_pair[1] for freq_pair in freq_pairs]\n\n    return \"\".join(freq_order)", "output": "Get the frequency order of the letters in the given string"}
{"task": "search", "input": "search code:\nEvaluate how similar the item is with the target by just\n\nChoices:\n0: def rotate_file(filename, *, keep: int = 5):     if keep < 1:         raise ValueError(f'expected \"keep\" to be >=1, not {keep}')     if not os.path.exists(filename):         return     if not os.path.isfile(filename):         raise ValueError(f'expected {filename} to be a file')      fn_root, fn_ext = os.path.splitext(filename)     kept_names = []     for i in range(1, keep + 1):         if fn_ext:             kept_names.append(f'{fn_root}.{i}{fn_ext}')         else:             kept_names.append(f'{fn_root}.{i}')      fns = [filename] + kept_names     for orig_name, kept_name in reversed(list(zip(fns, fns[1:]))):         if not os.path.exists(orig_name):             continue         os.rename(orig_name, kept_name)      if os.path.exists(kept_names[-1]):         os.remove(kept_names[-1])      return\n1: def reverse_inorder(root: Node | None) -> Generator[int]:     if not root:         return     yield from reverse_inorder(root.right)     yield root.data     yield from reverse_inorder(root.left)\n2: def evaluate(item: str, main_target: str) -> tuple[str, float]:     score = len([g for position, g in enumerate(item) if g == main_target[position]])     return (item, float(score))", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    constant = []\n    i = 1\n\n    while len(constant) < 1e6:\n        constant.append(str(i))\n        i += 1\n\n    constant = \"\".join(constant)\n\n    return (\n        int(constant[0])\n        * int(constant[9])\n        * int(constant[99])\n        * int(constant[999])\n        * int(constant[9999])\n        * int(constant[99999])\n        * int(constant[999999])\n    )", "output": "Returns"}
{"task": "summary", "input": "summarize code:\ndef calculate_average_times(\n    waiting_time: list[int], turn_around_time: list[int], no_of_processes: int\n) -> None:\n    total_waiting_time = 0\n    total_turn_around_time = 0\n    for i in range(no_of_processes):\n        total_waiting_time = total_waiting_time + waiting_time[i]\n        total_turn_around_time = total_turn_around_time + turn_around_time[i]\n    print(f\"Average waiting time = {total_waiting_time / no_of_processes:.5f}\")\n    print(\"Average turn around time =\", total_turn_around_time / no_of_processes)", "output": "This function calculates the average of the waiting & turnaround times"}
{"task": "detection", "input": "classify code:\ndef vernam_decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_decrypt(\"RIJVS\",\"KEY\")\n    'HELLO'\n    \"\"\"\n    decrypted_text = \"\"\n    for i in range(len(ciphertext)):\n        ct = ord(ciphertext[i]) - ord(key[i % len(key)])\n        while ct < 0:\n            ct = 26 + ct\n        decrypted_text += chr(65 + ct)\n    return decrypted_text", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef bwt_transform(s: str) -> BWTTransformDict:\n    if not isinstance(s, str):\n        raise TypeError(\"The parameter s type must be str.\")\n    if not s:\n        raise ValueError(\"The parameter s must not be empty.\")\n\n    rotations = all_rotations(s)\n    rotations.sort()  # sort the list of rotations in alphabetically order\n    # make a string composed of the last char of each rotation\n    response: BWTTransformDict = {\n        \"bwt_string\": \"\".join([word[-1] for word in rotations]),\n        \"idx_original_string\": rotations.index(s),\n    }\n    return response", "output": "rotations and the index of the original string at ordered rotations list"}
{"task": "search", "input": "search code:\nGenerates all possible combinations of k numbers out of 1 ... n using itertools.\n\nChoices:\n0: def combination_lists(n: int, k: int) -> list[list[int]]:     return [list(x) for x in combinations(range(1, n + 1), k)]\n1: def _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):     if max_rev[n] >= 0:         return max_rev[n]     elif n == 0:         return 0     else:         max_revenue = float(\"-inf\")         for i in range(1, n + 1):             max_revenue = max(                 max_revenue,                 prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),             )          max_rev[n] = max_revenue      return max_rev[n]\n2: def benchmark():     from timeit import timeit      setup = \"from __main__ import slow_primes, primes, fast_primes\"     print(timeit(\"slow_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))     print(timeit(\"primes(1_000_000_000_000)\", setup=setup, number=1_000_000))     print(timeit(\"fast_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)", "output": "def hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)", "tests": ["assert hexagonal_num(143) == 40755", "assert hexagonal_num(21) == 861", "assert hexagonal_num(10) == 190"]}
{"task": "summary", "input": "summarize code:\ndef all_solution_file_paths() -> list[pathlib.Path]:\n    solution_file_paths = []\n    for problem_dir_path in PROJECT_EULER_DIR_PATH.iterdir():\n        if problem_dir_path.is_file() or problem_dir_path.name.startswith(\"_\"):\n            continue\n        for file_path in problem_dir_path.iterdir():\n            if file_path.suffix != \".py\" or file_path.name.startswith((\"_\", \"test\")):\n                continue\n            solution_file_paths.append(file_path)\n    return solution_file_paths", "output": "Collects all the solution file path in the Project Euler directory"}
{"task": "search", "input": "search code:\nUpdate pheromones on the route and update the best route\n\nChoices:\n0: def guess_the_number(lower: int, higher: int, to_guess: int) -> None:     assert (         isinstance(lower, int) and isinstance(higher, int) and isinstance(to_guess, int)     ), 'argument values must be type of \"int\"'      if lower > higher:         raise ValueError(\"argument value for lower and higher must be(lower > higher)\")      if not lower < to_guess < higher:         raise ValueError(             \"guess value must be within the range of lower and higher value\"         )      def answer(number: int) -> str:         if number > to_guess:             return \"high\"         elif number < to_guess:             return \"low\"         else:             return \"same\"      print(\"started...\")      last_lowest = lower     last_highest = higher      last_numbers = []      while True:         number = get_avg(last_lowest, last_highest)         last_numbers.append(number)          if answer(number) == \"low\":             last_lowest = number         elif answer(number) == \"high\":             last_highest = number         else:             break      print(f\"guess the number : {last_numbers[-1]}\")     print(f\"details : {last_numbers!s}\")\n1: def pheromone_update(     pheromone: list[list[float]],     cities: dict[int, list[int]],     pheromone_evaporation: float,     ants_route: list[list[int]],     q: float,  # Pheromone system parameters Q, which is a constant     best_path: list[int],     best_distance: float, ) -> tuple[list[list[float]], list[int], float]:     for a in range(len(cities)):  # Update the volatilization of pheromone on all routes         for b in range(len(cities)):             pheromone[a][b] *= pheromone_evaporation     for ant_route in ants_route:         total_distance = 0.0         for i in range(len(ant_route) - 1):  # Calculate total distance             total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])         delta_pheromone = q / total_distance         for i in range(len(ant_route) - 1):  # Update pheromones             pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone             pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][                 ant_route[i + 1]             ]          if total_distance < best_distance:             best_path = ant_route             best_distance = total_distance      return pheromone, best_path, best_distance\n2: def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:      return len_board * len_board_column * row + column", "output": "1"}
{"task": "search", "input": "search code:\nReturn probability list of all possible sums when throwing dice.\n\nChoices:\n0: def hypercube_points(     num_points: int, hypercube_size: float, num_dimensions: int ) -> np.ndarray:     rng = np.random.default_rng()     shape = (num_points, num_dimensions)     return hypercube_size * rng.random(shape)\n1: def _suppress_lower_units(min_unit, suppress):     suppress = set(suppress)     for u in Unit:         if u == min_unit:             break         suppress.add(u)      return suppress\n2: def throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:     dices = [Dice() for i in range(num_dice)]     count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)     for _ in range(num_throws):         count_of_sum[sum(dice.roll() for dice in dices)] += 1     probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]     return probability[num_dice:]  # remove probability of sums that never appear", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection", "output": "def circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection", "tests": ["assert circle_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]", "assert circle_sort([]) == []", "assert circle_sort([-2, 5, 0, -45]) == [-45, -2, 0, 5]"]}
{"task": "search", "input": "search code:\nCalculate the length of the chain of non-repeating terms starting with n.\n\nChoices:\n0: def pheromone_update(     pheromone: list[list[float]],     cities: dict[int, list[int]],     pheromone_evaporation: float,     ants_route: list[list[int]],     q: float,  # Pheromone system parameters Q, which is a constant     best_path: list[int],     best_distance: float, ) -> tuple[list[list[float]], list[int], float]:     for a in range(len(cities)):  # Update the volatilization of pheromone on all routes         for b in range(len(cities)):             pheromone[a][b] *= pheromone_evaporation     for ant_route in ants_route:         total_distance = 0.0         for i in range(len(ant_route) - 1):  # Calculate total distance             total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])         delta_pheromone = q / total_distance         for i in range(len(ant_route) - 1):  # Update pheromones             pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone             pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][                 ant_route[i + 1]             ]          if total_distance < best_distance:             best_path = ant_route             best_distance = total_distance      return pheromone, best_path, best_distance\n1: def first_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )\n2: def chain_length(n: int, previous: set | None = None) -> int:     previous = previous or set()     if n in CHAIN_LENGTH_CACHE:         return CHAIN_LENGTH_CACHE[n]     next_number = sum_digit_factorials(n)     if next_number in previous:         CHAIN_LENGTH_CACHE[n] = 0         return 0     else:         previous.add(n)         ret = 1 + chain_length(next_number, previous)         CHAIN_LENGTH_CACHE[n] = ret         return ret", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int | None:\n    for base_num in range(9999, 4999, -1):\n        candidate = 100002 * base_num\n        if is_9_pandigital(candidate):\n            return candidate\n\n    for base_num in range(333, 99, -1):\n        candidate = 1002003 * base_num\n        if is_9_pandigital(candidate):\n            return candidate\n\n    return None", "output": "Return the largest 1 to 9 pandigital 9-digital number that can be formed as the"}
{"task": "search", "input": "search code:\nReturn an iterator over the last *n* items of *iterable*.\n\nChoices:\n0: def solution(n: int = 100) -> int:      sum_cubes = (n * (n + 1) // 2) ** 2     sum_squares = n * (n + 1) * (2 * n + 1) // 6     return sum_cubes - sum_squares\n1: def split(string: str, separator: str = \" \") -> list:      split_words = []      last_index = 0     for index, char in enumerate(string):         if char == separator:             split_words.append(string[last_index:index])             last_index = index + 1         if index + 1 == len(string):             split_words.append(string[last_index : index + 1])     return split_words\n2: def tail(n, iterable):     try:         size = len(iterable)     except TypeError:         return iter(deque(iterable, maxlen=n))     else:         return islice(iterable, max(0, size - n), None)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef levenshtein_distance(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Implementation of the Levenshtein distance in Python.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance(\"\", \"test\")\n    4\n    >>> levenshtein_distance(\"book\", \"back\")\n    2\n    >>> levenshtein_distance(\"book\", \"book\")\n    0\n    >>> levenshtein_distance(\"test\", \"\")\n    4\n    >>> levenshtein_distance(\"\", \"\")\n    0\n    >>> levenshtein_distance(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    # The longer word should come first\n    if len(first_word) < len(second_word):\n        return levenshtein_distance(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1]\n\n        for j, c2 in enumerate(second_word):\n            # Calculate insertions, deletions, and substitutions\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n\n            # Get the minimum to append to the current row\n            current_row.append(min(insertions, deletions, substitutions))\n\n        # Store the previous row\n        previous_row = current_row\n\n    # Returns the last element (distance)\n    return previous_row[-1]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef job_sequencing_with_deadlines(jobs: list) -> list:\n\n    # Sort the jobs in descending order of profit\n    jobs = sorted(jobs, key=lambda value: value[2], reverse=True)\n\n    # Create a list of size equal to the maximum deadline\n    # and initialize it with -1\n    max_deadline = max(jobs, key=lambda value: value[1])[1]\n    time_slots = [-1] * max_deadline\n\n    # Finding the maximum profit and the count of jobs\n    count = 0\n    max_profit = 0\n    for job in jobs:\n        # Find a free time slot for this job\n        # (Note that we start from the last possible slot)\n        for i in range(job[1] - 1, -1, -1):\n            if time_slots[i] == -1:\n                time_slots[i] = job[0]\n                count += 1\n                max_profit += job[2]\n                break\n    return [count, max_profit]", "output": "Function to find the maximum profit by doing jobs in a given time frame"}
{"task": "search", "input": "search code:\nGet the top 10 real-time billionaires using Forbes API.\n\nChoices:\n0: def nth_or_last(iterable, n, default=_marker):     return last(islice(iterable, n + 1), default=default)\n1: def solution(limit: int = 1000000) -> int:     divisor = limit - 1     if divisor % 2 == 0:         divisor += 1     while least_divisible_repunit(divisor) <= limit:         divisor += 2     return divisor\n2: def get_forbes_real_time_billionaires() -> list[dict[str, int | str]]:     response_json = httpx.get(API_URL, timeout=10).json()     return [         {             \"Name\": person[\"personName\"],             \"Source\": person[\"source\"],             \"Country\": person[\"countryOfCitizenship\"],             \"Gender\": person[\"gender\"],             \"Worth ($)\": f\"{person['finalWorth'] / 1000:.1f} Billion\",             \"Age\": str(years_old(person[\"birthDate\"] / 1000)),         }         for person in response_json[\"personList\"][\"personsLists\"]     ]", "output": "2"}
{"task": "search", "input": "search code:\nEvaluate a given expression in prefix notation.\n\nChoices:\n0: def hamming(n_element: int) -> list:     n_element = int(n_element)     if n_element < 1:         my_error = ValueError(\"n_element should be a positive number\")         raise my_error      hamming_list = [1]     i, j, k = (0, 0, 0)     index = 1     while index < n_element:         while hamming_list[i] * 2 <= hamming_list[-1]:             i += 1         while hamming_list[j] * 3 <= hamming_list[-1]:             j += 1         while hamming_list[k] * 5 <= hamming_list[-1]:             k += 1         hamming_list.append(             min(hamming_list[i] * 2, hamming_list[j] * 3, hamming_list[k] * 5)         )         index += 1     return hamming_list\n1: def solution(num: int = 100) -> int:     nfact = factorial(num)     result = split_and_add(nfact)     return result\n2: def evaluate(expression):     stack = []      # iterate over the string in reverse order     for c in expression.split()[::-1]:         # push operand to stack         if is_operand(c):             stack.append(int(c))          else:             # pop values from stack can calculate the result             # push the result onto the stack again             o1 = stack.pop()             o2 = stack.pop()             stack.append(operators[c](o1, o2))      return stack.pop()", "output": "2"}
{"task": "search", "input": "search code:\nReturns the sum of the digits of the number.\n\nChoices:\n0: def solution(n: int = 4) -> int | None:     results = run(n)     return results[0] if len(results) else None\n1: def digit_sum(n: int) -> int:     return sum(int(digit) for digit in str(n))\n2: def digit_replacements(number: int) -> list[list[int]]:     number_str = str(number)     replacements = []     digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]      for duplicate in Counter(number_str) - Counter(set(number_str)):         family = [int(number_str.replace(duplicate, digit)) for digit in digits]         replacements.append(family)      return replacements", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value", "output": "Returns the modular exponentiation, that is the value"}
{"task": "search", "input": "search code:\nConverts 3d point to a 2d drawable point\n\nChoices:\n0: def split_at(iterable, pred, maxsplit=-1, keep_separator=False):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         if pred(item):             yield buf             if keep_separator:                 yield [item]             if maxsplit == 1:                 yield list(it)                 return             buf = []             maxsplit -= 1         else:             buf.append(item)     yield buf\n1: def convert_to_2d(     x: float, y: float, z: float, scale: float, distance: float ) -> tuple[float, float]:     if not all(isinstance(val, (float, int)) for val in locals().values()):         msg = f\"Input values must either be float or int: {list(locals().values())}\"         raise TypeError(msg)     projected_x = ((x * distance) / (z + distance)) * scale     projected_y = ((y * distance) / (z + distance)) * scale     return projected_x, projected_y\n2: def concurrent_tee(iterable, n=2):      if n < 0:         raise ValueError     if n == 0:         return ()     iterator = _concurrent_tee(iterable)     result = [iterator]     for _ in range(n - 1):         result.append(_concurrent_tee(iterator))     return tuple(result)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef find_min(arr: list[int]) -> int:\n    \"\"\"\n    >>> find_min([1, 2, 3, 4, 5])\n    1\n    >>> find_min([5, 5, 5, 5, 5])\n    5\n    >>> find_min([5, 5, 5, 5])\n    0\n    >>> find_min([3])\n    3\n    >>> find_min([])\n    0\n    \"\"\"\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i - 1][j]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef proth(number: int) -> int:\n\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n\n    if number < 1:\n        msg = f\"Input value of [number={number}] must be > 0\"\n        raise ValueError(msg)\n    elif number == 1:\n        return 3\n    elif number == 2:\n        return 5\n    else:\n        block_index = int(math.log(number // 3, 2)) + 2\n\n        proth_list = [3, 5]\n        proth_index = 2\n        increment = 3\n        for block in range(1, block_index):\n            for _ in range(increment):\n                proth_list.append(2 ** (block + 1) + proth_list[proth_index - 1])\n                proth_index += 1\n            increment *= 2\n\n    return proth_list[number - 1]", "output": ":param number: nth number to calculate in the sequence"}
{"task": "search", "input": "search code:\nPure implementation of sentinel linear search algorithm in Python\n\nChoices:\n0: def solution():     with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:         names = str(file.readlines()[0])         names = names.replace('\"', \"\").split(\",\")      names.sort()      name_score = 0     total_score = 0      for i, name in enumerate(names):         for letter in name:             name_score += ord(letter) - 64          total_score += (i + 1) * name_score         name_score = 0     return total_score\n1: def longest_common_prefix(iterables):     return (c[0] for c in takewhile(all_equal, zip(*iterables)))\n2: def sentinel_linear_search(sequence, target):     sequence.append(target)      index = 0     while sequence[index] != target:         index += 1      sequence.pop()      if index == len(sequence):         return None      return index", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef get_totients(max_one: int) -> List[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients", "output": "def get_totients(max_one: int) -> list[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients", "tests": ["assert get_totients(5) == [0, 1, 1, 2, 2]", "assert get_totients(10) == [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]"]}
{"task": "search", "input": "search code:\nShow phase response of a filter\n\nChoices:\n0: def run_length_encode(text: str) -> list:     encoded = []     count = 1      for i in range(len(text)):         if i + 1 < len(text) and text[i] == text[i + 1]:             count += 1         else:             encoded.append((text[i], count))             count = 1      return encoded\n1: def show_phase_response(filter_type: FilterType, samplerate: int) -> None:      size = 512     inputs = [1] + [0] * (size - 1)     outputs = [filter_type.process(item) for item in inputs]      filler = [0] * (samplerate - size)  # zero-padding     outputs += filler     fft_out = np.angle(np.fft.fft(outputs))      # Frequencies on log scale from 24 to nyquist frequency     plt.xlim(24, samplerate / 2 - 1)     plt.xlabel(\"Frequency (Hz)\")     plt.xscale(\"log\")      plt.ylim(-2 * pi, 2 * pi)     plt.ylabel(\"Phase shift (Radians)\")     plt.plot(np.unwrap(fft_out, -2 * pi))     plt.show()\n2: def intword(value, format=\"%.1f\"):     try:         value = int(value)     except (TypeError, ValueError):         return value      if value < powers[0]:         return str(value)     for ordinal, power in enumerate(powers[1:], 1):         if value < power:             chopped = value / float(powers[ordinal - 1])             if float(format % chopped) == float(10**3):                 chopped = value / float(powers[ordinal])                 singular, plural = human_powers[ordinal]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped             else:                 singular, plural = human_powers[ordinal - 1]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped     return str(value)", "output": "1"}
{"task": "search", "input": "search code:\nCheck if a number is perfect square using binary search.\n\nChoices:\n0: def get_word_pattern(word: str) -> str:     word = word.upper()     next_num = 0     letter_nums = {}     word_pattern = []      for letter in word:         if letter not in letter_nums:             letter_nums[letter] = str(next_num)             next_num += 1         word_pattern.append(letter_nums[letter])     return \".\".join(word_pattern)\n1: def perfect_square_binary_search(n: int) -> bool:     left = 0     right = n     while left <= right:         mid = (left + right) // 2         if mid**2 == n:             return True         elif mid**2 > n:             right = mid - 1         else:             left = mid + 1     return False\n2: def solution() -> int:     return compute_nums(1)[0]", "output": "1"}
{"task": "search", "input": "search code:\nExtended Euclidean Algorithm.\n\nChoices:\n0: def extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:     # base cases     if abs(a) == 1:         return a, 0     elif abs(b) == 1:         return 0, b      old_remainder, remainder = a, b     old_coeff_a, coeff_a = 1, 0     old_coeff_b, coeff_b = 0, 1      while remainder != 0:         quotient = old_remainder // remainder         old_remainder, remainder = remainder, old_remainder - quotient * remainder         old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a         old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b      # sign correction for negative numbers     if a < 0:         old_coeff_a = -old_coeff_a     if b < 0:         old_coeff_b = -old_coeff_b      return old_coeff_a, old_coeff_b\n1: def max_height(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(angle)     return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)\n2: def _construct_solution(dp: list, wt: list, i: int, j: int, optimal_set: set):     # for the current item i at a maximum weight j to be part of an optimal subset,     # the optimal value at (i, j) must be greater than the optimal value at (i-1, j).     # where i - 1 means considering only the previous items at the given maximum weight     if i > 0 and j > 0:         if dp[i - 1][j] == dp[i][j]:             _construct_solution(dp, wt, i - 1, j, optimal_set)         else:             optimal_set.add(i)             _construct_solution(dp, wt, i - 1, j - wt[i - 1], optimal_set)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef pressure_conversion(value: float, from_type: str, to_type: str) -> float:\n    if from_type not in PRESSURE_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"\n            + \", \".join(PRESSURE_CONVERSION)\n        )\n    if to_type not in PRESSURE_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"\n            + \", \".join(PRESSURE_CONVERSION)\n        )\n    return (\n        value\n        * PRESSURE_CONVERSION[from_type].from_factor\n        * PRESSURE_CONVERSION[to_type].to_factor\n    )", "output": "Conversion between pressure units."}
{"task": "summary", "input": "summarize code:\ndef rmse(predict, actual):\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    square_diff = np.square(difference)\n    mean_square_diff = square_diff.mean()\n    score = np.sqrt(mean_square_diff)\n    return score", "output": "Examples(rounded for precision):"}
{"task": "search", "input": "search code:\nReturns the product of a,b,c which are Pythagorean Triplet that satisfies\n\nChoices:\n0: def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:     return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))\n1: def windowed(src, size, fill=_UNSET):     return list(windowed_iter(src, size, fill=fill))\n2: def solution() -> int:      for a in range(300):         for b in range(a + 1, 400):             for c in range(b + 1, 500):                 if (a + b + c) == 1000 and (a**2) + (b**2) == (c**2):                     return a * b * c      return -1", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef binary_tree_top_side_view(root: TreeNode) -> list[int]:\n\n    def breadth_first_search(root: TreeNode, top_view: list[int]) -> None:\n        queue = [(root, 0)]\n        lookup = defaultdict(list)\n\n        while queue:\n            first = queue.pop(0)\n            node, hd = first\n\n            lookup[hd].append(node.val)\n\n            if node.left:\n                queue.append((node.left, hd - 1))\n            if node.right:\n                queue.append((node.right, hd + 1))\n\n        for pair in sorted(lookup.items(), key=lambda each: each[0]):\n            top_view.append(pair[1][0])\n\n    top_view: list = []\n    if not root:\n        return top_view\n\n    breadth_first_search(root, top_view)\n    return top_view", "output": "Function returns the top side view of binary tree."}
{"task": "search", "input": "search code:\nCheck if a linked list is a palindrome using a dictionary.\n\nChoices:\n0: def is_palindrome_dict(head: ListNode | None) -> bool:     if not head or not head.next_node:         return True     d: dict[int, list[int]] = {}     pos = 0     while head:         if head.val in d:             d[head.val].append(pos)         else:             d[head.val] = [pos]         head = head.next_node         pos += 1     checksum = pos - 1     middle = 0     for v in d.values():         if len(v) % 2 != 0:             middle += 1         else:             for step, i in enumerate(range(len(v))):                 if v[i] + v[len(v) - 1 - step] != checksum:                     return False         if middle > 1:             return False     return True\n1: def factor(n):      # Corner case reduction     if n < 2:         return      # Trial division reduction     for prime in _primes_below_211:         while not n % prime:             yield prime             n //= prime      # Pollard's rho reduction     primes = []     todo = [n] if n > 1 else []     for n in todo:         if n < 211**2 or is_prime(n):             primes.append(n)         else:             fact = _factor_pollard(n)             todo += (fact, n // fact)     yield from sorted(primes)\n2: def is_combination_valid(combination):     return (         int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))         == int(\"\".join(combination[5:9]))     ) or (         int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))         == int(\"\".join(combination[5:9]))     )", "output": "0"}
{"task": "detection", "input": "classify code:\ndef counting_sort(collection):\n    \"\"\"Pure implementation of counting sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> counting_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> counting_sort([])\n    []\n    >>> counting_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered", "output": "BUGGY"}
{"task": "search", "input": "search code:\nTwo strings are anagrams if they are made up of the same letters but are\n\nChoices:\n0: def check_anagrams(first_str: str, second_str: str) -> bool:     first_str = first_str.lower().strip()     second_str = second_str.lower().strip()      # Remove whitespace     first_str = first_str.replace(\" \", \"\")     second_str = second_str.replace(\" \", \"\")      # Strings of different lengths are not anagrams     if len(first_str) != len(second_str):         return False      # Default values for count should be 0     count: defaultdict[str, int] = defaultdict(int)      # For each character in input strings,     # increment count in the corresponding     for i in range(len(first_str)):         count[first_str[i]] += 1         count[second_str[i]] -= 1      return all(_count == 0 for _count in count.values())\n1: def speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:      if density <= 0:         raise ValueError(\"Impossible fluid density\")     if bulk_modulus <= 0:         raise ValueError(\"Impossible bulk modulus\")      return (bulk_modulus / density) ** 0.5\n2: def is_square_form(num: int) -> bool:     digit = 9      while num > 0:         if num % 10 != digit:             return False         num //= 100         digit -= 1      return True", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef msd_radix_sort_inplace(list_of_ints: list[int]):\n\n    length = len(list_of_ints)\n    if not list_of_ints or length == 1:\n        return\n\n    if min(list_of_ints) < 0:\n        raise ValueError(\"All numbers must be positive\")\n\n    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)\n    _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)", "output": "Inplace implementation of the MSD radix sort algorithm."}
{"task": "search", "input": "search code:\nfind min value in list\n\nChoices:\n0: def set_partitions(iterable, k=None, min_size=None, max_size=None):     L = list(iterable)     n = len(L)     if k is not None:         if k < 1:             raise ValueError(                 \"Can't partition in a negative or zero number of groups\"             )         elif k > n:             return      min_size = min_size if min_size is not None else 0     max_size = max_size if max_size is not None else n     if min_size > max_size:         return      def set_partitions_helper(L, k):         n = len(L)         if k == 1:             yield [L]         elif n == k:             yield [[s] for s in L]         else:             e, *M = L             for p in set_partitions_helper(M, k - 1):                 yield [[e], *p]             for p in set_partitions_helper(M, k):                 for i in range(len(p)):                     yield p[:i] + [[e] + p[i]] + p[i + 1 :]      if k is None:         for k in range(1, n + 1):             yield from filter(                 lambda z: all(min_size <= len(bk) <= max_size for bk in z),                 set_partitions_helper(L, k),             )     else:         yield from filter(             lambda z: all(min_size <= len(bk) <= max_size for bk in z),             set_partitions_helper(L, k),         )\n1: def find_min_recursive(nums: list[int | float], left: int, right: int) -> int | float:     if len(nums) == 0:         raise ValueError(\"find_min_recursive() arg is an empty sequence\")     if (         left >= len(nums)         or left < -len(nums)         or right >= len(nums)         or right < -len(nums)     ):         raise IndexError(\"list index out of range\")     if left == right:         return nums[left]     mid = (left + right) >> 1  # the middle     left_min = find_min_recursive(nums, left, mid)  # find min in range[left, mid]     right_min = find_min_recursive(         nums, mid + 1, right     )  # find min in range[mid + 1, right]      return left_min if left_min <= right_min else right_min\n2: def lexical_order(max_number: int) -> Iterator[int]:      stack = [1]      while stack:         num = stack.pop()         if num > max_number:             continue          yield num         if (num % 10) != 9:             stack.append(num + 1)          stack.append(num * 10)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef even_tree():\n    dfs(1)", "output": "2 1"}
{"task": "detection", "input": "classify code:\ndef reverse_letters(sentence: str, length: int = 0) -> str:\n    \"\"\"\n    Reverse all words that are longer than the given length of characters in a sentence.\n    If unspecified, length is taken as 0\n\n    >>> reverse_letters(\"Hey wollef sroirraw\", 3)\n    'Hey fellow warriors'\n    >>> reverse_letters(\"nohtyP is nohtyP\", 2)\n    'Python is Python'\n    >>> reverse_letters(\"1 12 123 1234 54321 654321\", 0)\n    '1 21 321 4321 12345 123456'\n    >>> reverse_letters(\"racecar\")\n    'racecar'\n    \"\"\"\n    return \" \".join(\n        \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()\n    )", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef outer_product(func, xs, ys, *args, **kwargs):\n    ys = tuple(ys)\n    return batched(\n        starmap(lambda x, y: func(x, y, *args, **kwargs), product(xs, ys)),\n        n=len(ys),\n    )", "output": "A generalized outer product that applies a binary function to all"}
{"task": "summary", "input": "summarize code:\ndef power_iteration(\n    input_matrix: np.ndarray,\n    vector: np.ndarray,\n    error_tol: float = 1e-12,\n    max_iterations: int = 100,\n) -> tuple[float, np.ndarray]:\n\n    # Ensure matrix is square.\n    assert np.shape(input_matrix)[0] == np.shape(input_matrix)[1]\n    # Ensure proper dimensionality.\n    assert np.shape(input_matrix)[0] == np.shape(vector)[0]\n    # Ensure inputs are either both complex or both real\n    assert np.iscomplexobj(input_matrix) == np.iscomplexobj(vector)\n    is_complex = np.iscomplexobj(input_matrix)\n    if is_complex:\n        # Ensure complex input_matrix is Hermitian\n        assert np.array_equal(input_matrix, input_matrix.conj().T)\n\n    # Set convergence to False. Will define convergence when we exceed max_iterations\n    # or when we have small changes from one iteration to next.\n\n    convergence = False\n    lambda_previous = 0\n    iterations = 0\n    error = 1e12\n\n    while not convergence:\n        # Multiple matrix by the vector.\n        w = np.dot(input_matrix, vector)\n        # Normalize the resulting output vector.\n        vector = w / np.linalg.norm(w)\n        # Find rayleigh quotient\n        # (faster than usual b/c we know vector is normalized already)\n        vector_h = vector.conj().T if is_complex else vector.T\n        lambda_ = np.dot(vector_h, np.dot(input_matrix, vector))\n\n        # Check convergence.\n        error = np.abs(lambda_ - lambda_previous) / lambda_\n        iterations += 1\n\n        if error <= error_tol or iterations >= max_iterations:\n            convergence = True\n\n        lambda_previous = lambda_\n\n    if is_complex:\n        lambda_ = np.real(lambda_)\n\n    return float(lambda_), vector", "output": "Power Iteration."}
{"task": "search", "input": "search code:\nInput Parameters\n\nChoices:\n0: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]\n1: def hubble_parameter(     hubble_constant: float,     radiation_density: float,     matter_density: float,     dark_energy: float,     redshift: float, ) -> float:     parameters = [redshift, radiation_density, matter_density, dark_energy]     if any(p < 0 for p in parameters):         raise ValueError(\"All input parameters must be positive\")      if any(p > 1 for p in parameters[1:4]):         raise ValueError(\"Relative densities cannot be greater than one\")     else:         curvature = 1 - (matter_density + radiation_density + dark_energy)          e_2 = (             radiation_density * (redshift + 1) ** 4             + matter_density * (redshift + 1) ** 3             + curvature * (redshift + 1) ** 2             + dark_energy         )          hubble = hubble_constant * e_2 ** (1 / 2)         return hubble\n2: def rsafactor(d: int, e: int, n: int) -> list[int]:     k = d * e - 1     p = 0     q = 0     while p == 0:         g = random.randint(2, n - 1)         t = k         while True:             if t % 2 == 0:                 t = t // 2                 x = (g**t) % n                 y = math.gcd(x - 1, n)                 if x > 1 and y > 1:                     p = y                     q = n // y                     break  # find the correct factors             else:                 break  # t is not divisible by 2, break and choose another g     return sorted([p, q])", "output": "1"}
{"task": "search", "input": "search code:\nReturn the first value of the first four consecutive integers to have four\n\nChoices:\n0: def solution(n: int = 4) -> int | None:     results = run(n)     return results[0] if len(results) else None\n1: def transpose(it):     return zip(*it, strict=True)\n2: def sentence_to_title_case(input_str: str) -> str:      return \" \".join(to_title_case(word) for word in input_str.split())", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef area_trapezium(base1: float, base2: float, height: float) -> float:\n    if base1 < 0 or base2 < 0 or height < 0:\n        raise ValueError(\"area_trapezium() only accepts non-negative values\")\n    return 1 / 2 * (base1 + base2) * height", "output": "Calculate the area of a trapezium."}
{"task": "detection", "input": "classify code:\ndef least_divisible_repunit(divisor: int) -> int:\n    \"\"\"\n    Return the least value k such that the Repunit of length k is divisible by divisor.\n    >>> least_divisible_repunit(7)\n    6\n    >>> least_divisible_repunit(41)\n    5\n    >>> least_divisible_repunit(1234567)\n    34020\n    \"\"\"\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the closest numerator of the fraction immediately to the\n\nChoices:\n0: def solve(arr: NDArray, row: int, cols: set[int], cache: dict[str, int]) -> int:      cache_id = f\"{row}, {sorted(cols)}\"     if cache_id in cache:         return cache[cache_id]      if row == len(arr):         return 0      max_sum = 0     for col in cols:         new_cols = cols - {col}         max_sum = max(             max_sum,             int(arr[row, col])             + solve(arr=arr, row=row + 1, cols=new_cols, cache=cache),         )     cache[cache_id] = max_sum     return max_sum\n1: def solution(numerator: int = 3, denominator: int = 7, limit: int = 1000000) -> int:     max_numerator = 0     max_denominator = 1      for current_denominator in range(1, limit + 1):         current_numerator = current_denominator * numerator // denominator         if current_denominator % denominator == 0:             current_numerator -= 1         if current_numerator * max_denominator > current_denominator * max_numerator:             max_numerator = current_numerator             max_denominator = current_denominator     return max_numerator\n2: def solution() -> int:      a = 1     b = 1     c = 2     # temporary Fibonacci numbers      a1 = 1     b1 = 1     c1 = 2     # temporary Fibonacci numbers mod 1e9      # mod m=1e9, done for fast optimisation     tocheck = [0] * 1000000     m = 1000000000      for x in range(1000000):         c1 = (a1 + b1) % m         a1 = b1 % m         b1 = c1 % m         if check1(b1):             tocheck[x + 3] = 1      for x in range(1000000):         c = a + b         a = b         b = c         # perform check only if in tocheck         if tocheck[x + 3] and check(b):             return x + 3  # first 2 already done     return -1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    assert a >= 0\n    assert b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0\n    assert b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers"}
{"task": "summary", "input": "summarize code:\ndef merge(left: Node | None, right: Node | None) -> Node | None:\n    if (not left) or (not right):  # If one node is None, return the other\n        return left or right\n    elif left.prior < right.prior:\n        left.right = merge(left.right, right)\n        return left\n    else:\n        right.left = merge(left, right.left)\n        return right", "output": "We merge 2 trees into one."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)", "output": "Returns the sum of all the multiples of 3 or 5 below n."}
{"task": "summary", "input": "summarize code:\ndef depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:\n    row_length, col_length = len(grid), len(grid[0])\n    if (\n        min(row, col) < 0\n        or row == row_length\n        or col == col_length\n        or (row, col) in visit\n        or grid[row][col] == 1\n    ):\n        return 0\n    if row == row_length - 1 and col == col_length - 1:\n        return 1\n\n    visit.add((row, col))\n\n    count = 0\n    count += depth_first_search(grid, row + 1, col, visit)\n    count += depth_first_search(grid, row - 1, col, visit)\n    count += depth_first_search(grid, row, col + 1, visit)\n    count += depth_first_search(grid, row, col - 1, visit)\n\n    visit.remove((row, col))\n    return count", "output": "Recursive Backtracking Depth First Search Algorithm"}
{"task": "summary", "input": "summarize code:\ndef fractional_cover(items: list[Item], capacity: int) -> float:\n    if capacity < 0:\n        raise ValueError(\"Capacity cannot be negative\")\n\n    total_value = 0.0\n    remaining_capacity = capacity\n\n    # Sort the items by their value-to-weight ratio in descending order\n    for item in sorted(items, key=attrgetter(\"ratio\"), reverse=True):\n        if remaining_capacity == 0:\n            break\n\n        weight_taken = min(item.weight, remaining_capacity)\n        total_value += weight_taken * item.ratio\n        remaining_capacity -= weight_taken\n\n    return total_value", "output": "Solve the Fractional Cover Problem."}
{"task": "summary", "input": "summarize code:\ndef rstrip(iterable, strip_value=None):\n    return list(rstrip_iter(iterable, strip_value))", "output": "Strips values from the end of an iterable. Stripped items will"}
{"task": "search", "input": "search code:\nReturns a cipher map given a keyword.\n\nChoices:\n0: def mae(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = abs(predict - actual)     score = difference.mean()      return score\n1: def create_cipher_map(key: str) -> dict[str, str]:     # Create a list of the letters in the alphabet     alphabet = [chr(i + 65) for i in range(26)]     # Remove duplicate characters from key     key = remove_duplicates(key.upper())     offset = len(key)     # First fill cipher with key characters     cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}     # Then map remaining characters in alphabet to     # the alphabet from the beginning     for i in range(len(cipher_alphabet), 26):         char = alphabet[i - offset]         # Ensure we are not mapping letters to letters previously mapped         while char in key:             offset -= 1             char = alphabet[i - offset]         cipher_alphabet[alphabet[i]] = char     return cipher_alphabet\n2: def generate_parenthesis(n: int) -> list[str]:      result: list[str] = []     backtrack(\"\", 0, 0, n, result)     return result", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef search_anime_episode_list(episode_endpoint: str) -> list:\n\n    request_url = f\"{BASE_URL}{episode_endpoint}\"\n\n    response = httpx.get(\n        url=request_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10\n    )\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    # With this id. get the episode list.\n    episode_page_ul = soup.find(\"ul\", {\"id\": \"episode_related\"})\n    if episode_page_ul is None or isinstance(episode_page_ul, NavigableString):\n        msg = f\"Could not find any anime eposiodes with name {anime_name}\"\n        raise ValueError(msg)\n    episode_page_li = episode_page_ul.children\n\n    episode_list = []\n    for episode in episode_page_li:\n        if isinstance(episode, Tag):\n            url = episode.find(\"a\")\n            if url is None or isinstance(url, NavigableString):\n                continue\n            title = episode.find(\"div\", {\"class\": \"name\"})\n            if title is None or isinstance(title, NavigableString):\n                continue\n\n            episode_list.append(\n                {\"title\": title.text.replace(\" \", \"\"), \"url\": url[\"href\"]}\n            )\n\n    return episode_list", "output": "[summary]"}
{"task": "search", "input": "search code:\nFind the sum of digits of a number.\n\nChoices:\n0: def wave(txt: str) -> list:      return [         txt[:a] + txt[a].upper() + txt[a + 1 :]         for a in range(len(txt))         if txt[a].isalpha()     ]\n1: def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive     array_length = len(array)     # If the array contains only one element, we return it (it's the stop condition of     # recursion)     if array_length <= 1:         return array         # Else     pivot = array[0]     is_found = False     i = 1     longest_subseq: list[int] = []     while not is_found and i < array_length:         if array[i] < pivot:             is_found = True             temp_array = array[i:]             temp_array = longest_subsequence(temp_array)             if len(temp_array) > len(longest_subseq):                 longest_subseq = temp_array         else:             i += 1      temp_array = [element for element in array[1:] if element >= pivot]     temp_array = [pivot, *longest_subsequence(temp_array)]     if len(temp_array) > len(longest_subseq):         return temp_array     else:         return longest_subseq\n2: def sum_of_digits(n: int) -> int:     n = abs(n)     res = 0     while n > 0:         res += n % 10         n //= 10     return res", "output": "2"}
{"task": "detection", "input": "classify code:\ndef odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef iter_suppress(iterable, *exceptions):\n    try:\n        yield from iterable\n    except exceptions:\n        return", "output": "Yield each of the items from *iterable*. If the iteration raises one of"}
{"task": "search", "input": "search code:\nReturns the side length of the square spiral of odd length greater\n\nChoices:\n0: def carrier_concentration(     electron_conc: float,     hole_conc: float,     intrinsic_conc: float, ) -> tuple:     if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:         raise ValueError(\"You cannot supply more or less than 2 values\")     elif electron_conc < 0:         raise ValueError(\"Electron concentration cannot be negative in a semiconductor\")     elif hole_conc < 0:         raise ValueError(\"Hole concentration cannot be negative in a semiconductor\")     elif intrinsic_conc < 0:         raise ValueError(             \"Intrinsic concentration cannot be negative in a semiconductor\"         )     elif electron_conc == 0:         return (             \"electron_conc\",             intrinsic_conc**2 / hole_conc,         )     elif hole_conc == 0:         return (             \"hole_conc\",             intrinsic_conc**2 / electron_conc,         )     elif intrinsic_conc == 0:         return (             \"intrinsic_conc\",             (electron_conc * hole_conc) ** 0.5,         )     else:         return (-1, -1)\n1: def solution(ratio: float = 0.1) -> int:      j = 3     primes = 3      while primes / (2 * j - 1) >= ratio:         for i in range(j * j + j + 1, (j + 2) * (j + 2), j + 1):             primes += is_prime(i)         j += 2     return j\n2: def oct_to_decimal(oct_string: str) -> int:     oct_string = str(oct_string).strip()     if not oct_string:         raise ValueError(\"Empty string was passed to the function\")     is_negative = oct_string[0] == \"-\"     if is_negative:         oct_string = oct_string[1:]     if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):         raise ValueError(\"Non-octal value was passed to the function\")     decimal_number = 0     for char in oct_string:         decimal_number = 8 * decimal_number + int(char)     if is_negative:         decimal_number = -decimal_number     return decimal_number", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_files_url() -> str:\n    with open(os.environ[\"GITHUB_EVENT_PATH\"]) as file:\n        event = json.load(file)\n    return event[\"pull_request\"][\"url\"] + \"/files\"", "output": "Return the pull request number which triggered this action."}
{"task": "summary", "input": "summarize code:\ndef length_conversion(value: float, from_type: str, to_type: str) -> float:\n\n    from_sanitized = from_type.lower().strip(\"s\")\n    to_sanitized = to_type.lower().strip(\"s\")\n\n    from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)\n    to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)\n\n    if from_sanitized not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'from_type' value: {from_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    if to_sanitized not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'to_type' value: {to_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    from_exponent = METRIC_CONVERSION[from_sanitized]\n    to_exponent = METRIC_CONVERSION[to_sanitized]\n    exponent = 1\n\n    if from_exponent > to_exponent:\n        exponent = from_exponent - to_exponent\n    else:\n        exponent = -(to_exponent - from_exponent)\n\n    return value * pow(10, exponent)", "output": "Conversion between astronomical length units."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 20) -> int:\n\n    g = 1\n    for i in range(1, n + 1):\n        g = lcm(g, i)\n    return g", "output": "Returns the smallest positive number that is evenly divisible (divisible"}
{"task": "search", "input": "search code:\nReturns the sum of all the multiples of 3 or 5 below n.\n\nChoices:\n0: def solution(n: int = 1000) -> int:      xmulti = []     zmulti = []     z = 3     x = 5     temp = 1     while True:         result = z * temp         if result < n:             zmulti.append(result)             temp += 1         else:             temp = 1             break     while True:         result = x * temp         if result < n:             xmulti.append(result)             temp += 1         else:             break     collection = list(set(xmulti + zmulti))     return sum(collection)\n1: def bubble_sort_iterative(collection: list[Any]) -> list[Any]:     length = len(collection)     for i in reversed(range(length)):         swapped = False         for j in range(i):             if collection[j] > collection[j + 1]:                 swapped = True                 collection[j], collection[j + 1] = collection[j + 1], collection[j]         if not swapped:             break  # Stop iteration if the collection is sorted.     return collection\n2: def column_reshape(input_array: np.ndarray) -> np.ndarray:      return input_array.reshape((input_array.size, 1))", "output": "0"}
{"task": "search", "input": "search code:\nInput Parameters:\n\nChoices:\n0: def solution(n: int = 15) -> int:     total = 0     for m in range(2, n + 1):         x1 = 2 / (m + 1)         p = 1.0         for i in range(1, m + 1):             xi = i * x1             p *= xi**i         total += int(p)     return total\n1: def effusion_ratio(molar_mass_1: float, molar_mass_2: float) -> float | ValueError:     return (         round(sqrt(molar_mass_2 / molar_mass_1), 6)         if validate(molar_mass_1, molar_mass_2)         else ValueError(\"Input Error: Molar mass values must greater than 0.\")     )\n2: def show_phase_response(filter_type: FilterType, samplerate: int) -> None:      size = 512     inputs = [1] + [0] * (size - 1)     outputs = [filter_type.process(item) for item in inputs]      filler = [0] * (samplerate - size)  # zero-padding     outputs += filler     fft_out = np.angle(np.fft.fft(outputs))      # Frequencies on log scale from 24 to nyquist frequency     plt.xlim(24, samplerate / 2 - 1)     plt.xlabel(\"Frequency (Hz)\")     plt.xscale(\"log\")      plt.ylim(-2 * pi, 2 * pi)     plt.ylabel(\"Phase shift (Radians)\")     plt.plot(np.unwrap(fft_out, -2 * pi))     plt.show()", "output": "1"}
{"task": "detection", "input": "classify code:\ndef str_eval(s: str) -> int:\n    \"\"\"\n    Returns product of digits in given string n\n\n    >>> str_eval(\"987654321\")\n    362880\n    >>> str_eval(\"22222222\")\n    256\n    \"\"\"\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef covariance_within_classes(\n    features: np.ndarray, labels: np.ndarray, classes: int\n) -> np.ndarray:\n\n    covariance_sum = np.nan\n    for i in range(classes):\n        data = features[:, labels == i]\n        data_mean = data.mean(1)\n        # Centralize the data of class i\n        centered_data = data - column_reshape(data_mean)\n        if i > 0:\n            # If covariance_sum is not None\n            covariance_sum += np.dot(centered_data, centered_data.T)\n        else:\n            # If covariance_sum is np.nan (i.e. first loop)\n            covariance_sum = np.dot(centered_data, centered_data.T)\n\n    return covariance_sum / features.shape[1]", "output": "Function to compute the covariance matrix inside each class."}
{"task": "search", "input": "search code:\nRemoves duplicate alphabetic characters in a keyword (letter is ignored after its\n\nChoices:\n0: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)\n1: def remove_duplicates(key: str) -> str:      key_no_dups = \"\"     for ch in key:         if ch == \" \" or (ch not in key_no_dups and ch.isalpha()):             key_no_dups += ch     return key_no_dups\n2: def map_if(iterable, pred, func, func_else=None):      if func_else is None:         for item in iterable:             yield func(item) if pred(item) else item      else:         for item in iterable:             yield func(item) if pred(item) else func_else(item)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef median(nums):\n    \"\"\"\n    Find median of a list of numbers.\n\n    >>> median([0])\n    0\n    >>> median([4,1,3,2])\n    2.5\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    med = None\n    if len(sorted_list) % 2 == 0:\n        mid_index_1 = len(sorted_list) // 2\n        mid_index_2 = (len(sorted_list) // 2) - 1\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n    else:\n        mid_index = (len(sorted_list) - 1) // 2\n        med = sorted_list[mid_index]\n    return med", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    -1\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return -1\n    else:\n        return \"\".join(l1)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculate the electrostatic force of attraction or repulsion\n\nChoices:\n0: def create_ngram(sentence: str, ngram_size: int) -> list[str]:     return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]\n1: def summation_of_cost_derivative(index, end=m):     summation_value = 0     for i in range(end):         if index == -1:             summation_value += _error(i)         else:             summation_value += _error(i) * train_data[i][0][index]     return summation_value\n2: def coulombs_law(q1: float, q2: float, radius: float) -> float:     if radius <= 0:         raise ValueError(\"The radius is always a positive number\")     return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef fib_iterative(n: int) -> list[int]:\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    if n == 0:\n        return [0]\n    fib = [0, 1]\n    for _ in range(n - 1):\n        fib.append(fib[-1] + fib[-2])\n    return fib", "output": "Calculates the first n (0-indexed) Fibonacci numbers using iteration"}
{"task": "summary", "input": "summarize code:\ndef mf_knapsack(i, wt, val, j):\n    global f  # a global dp table for knapsack\n    if f[i][j] < 0:\n        if j < wt[i - 1]:\n            val = mf_knapsack(i - 1, wt, val, j)\n        else:\n            val = max(\n                mf_knapsack(i - 1, wt, val, j),\n                mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],\n            )\n        f[i][j] = val\n    return f[i][j]", "output": "This code involves the concept of memory functions. Here we solve the subproblems"}
{"task": "summary", "input": "summarize code:\ndef triplewise(iterable):\n    # This deviates from the itertools documentation recipe - see\n    # https://github.com/more-itertools/more-itertools/issues/889\n    t1, t2, t3 = tee(iterable, 3)\n    next(t3, None)\n    next(t3, None)\n    next(t2, None)\n    return zip(t1, t2, t3)", "output": "Return overlapping triplets from *iterable*."}
{"task": "summary", "input": "summarize code:\ndef non_bouncy_upto(n: int) -> int:\n    return sum(non_bouncy_exact(i) for i in range(1, n + 1))", "output": "Calculate the number of non-bouncy numbers with at most n digits."}
{"task": "detection", "input": "classify code:\ndef count_vowels(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a given string.\n\n    :param s: Input string to count vowels in.\n    :return: Number of vowels in the input string.\n\n    Examples:\n    >>> count_vowels(\"hello world\")\n    3\n    >>> count_vowels(\"HELLO WORLD\")\n    3\n    >>> count_vowels(\"123 hello world\")\n    3\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a quick brown fox\")\n    5\n    >>> count_vowels(\"the quick BROWN fox\")\n    5\n    >>> count_vowels(\"PYTHON\")\n    1\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch", "output": "Calculate the score for a character pair based on whether they match or mismatch."}
{"task": "search", "input": "search code:\nReturns the number of mondays that fall on the first of the month during\n\nChoices:\n0: def solution():     days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]      day = 6     month = 1     year = 1901      sundays = 0      while year < 2001:         day += 7          if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):             if day > days_per_month[month - 1] and month != 2:                 month += 1                 day = day - days_per_month[month - 2]             elif day > 29 and month == 2:                 month += 1                 day = day - 29         elif day > days_per_month[month - 1]:             month += 1             day = day - days_per_month[month - 2]          if month > 12:             year += 1             month = 1          if year < 2001 and day == 1:             sundays += 1     return sundays\n1: def electrical_impedance(     resistance: float, reactance: float, impedance: float ) -> dict[str, float]:     if (resistance, reactance, impedance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance == 0:         return {\"resistance\": sqrt(pow(impedance, 2) - pow(reactance, 2))}     elif reactance == 0:         return {\"reactance\": sqrt(pow(impedance, 2) - pow(resistance, 2))}     elif impedance == 0:         return {\"impedance\": sqrt(pow(resistance, 2) + pow(reactance, 2))}     else:         raise ValueError(\"Exactly one argument must be 0\")\n2: def calc_derivative(f: RealFunc, x: float, delta_x: float = 1e-3) -> float:     return (f(x + delta_x / 2) - f(x - delta_x / 2)) / delta_x", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef random_graph(\n    vertices_number: int, probability: float, directed: bool = False\n) -> dict:\n    graph: dict = {i: [] for i in range(vertices_number)}\n\n    # if probability is greater or equal than 1, then generate a complete graph\n    if probability >= 1:\n        return complete_graph(vertices_number)\n    # if probability is lower or equal than 0, then return a graph without edges\n    if probability <= 0:\n        return graph\n\n    # for each couple of nodes, add an edge from u to v\n    # if the number randomly generated is greater than probability probability\n    for i in range(vertices_number):\n        for j in range(i + 1, vertices_number):\n            if random.random() < probability:\n                graph[i].append(j)\n                if not directed:\n                    # if the graph is undirected, add an edge in from j to i, either\n                    graph[j].append(i)\n    return graph", "output": "Generate a random graph"}
{"task": "search", "input": "search code:\nThe main function. For list of numbers 'nums' find the subsets with sum\n\nChoices:\n0: def clone_graph(node: Node | None) -> Node | None:     if not node:         return None      originals_to_clones = {}  # map nodes to clones      stack = [node]      while stack:         original = stack.pop()          if original in originals_to_clones:             continue          originals_to_clones[original] = Node(original.value)          stack.extend(original.neighbors or [])      for original, clone in originals_to_clones.items():         for neighbor in original.neighbors or []:             cloned_neighbor = originals_to_clones[neighbor]              if not clone.neighbors:                 clone.neighbors = []              clone.neighbors.append(cloned_neighbor)      return originals_to_clones[node]\n1: def netstring_server_timeout_override(server_socket):      try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock, timeout=0.01)             while 1:                 request = client.read_ns(1)                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'ping':                     client.write_ns(b'pong')     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise\n2: def generate_sum_of_subsets_solutions(nums: list[int], max_sum: int) -> list[list[int]]:      result: list[list[int]] = []     path: list[int] = []     num_index = 0     remaining_nums_sum = sum(nums)     create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)     return result", "output": "2"}
{"task": "search", "input": "search code:\nReturns the sum of truncated primes\n\nChoices:\n0: def shear_stress(     stress: float,     tangential_force: float,     area: float, ) -> tuple[str, float]:     if (stress, tangential_force, area).count(0) != 1:         raise ValueError(\"You cannot supply more or less than 2 values\")     elif stress < 0:         raise ValueError(\"Stress cannot be negative\")     elif tangential_force < 0:         raise ValueError(\"Tangential Force cannot be negative\")     elif area < 0:         raise ValueError(\"Area cannot be negative\")     elif stress == 0:         return (             \"stress\",             tangential_force / area,         )     elif tangential_force == 0:         return (             \"tangential_force\",             stress * area,         )     else:         return (             \"area\",             tangential_force / stress,         )\n1: def solution() -> int:     return sum(compute_truncated_primes(11))\n2: def solution(n: int = 1000000) -> int:      result = max((collatz_sequence_length(i), i) for i in range(1, n))     return result[1]", "output": "1"}
{"task": "search", "input": "search code:\nFind the absolute value of a number.\n\nChoices:\n0: def abs_val(num: float) -> float:     return -num if num < 0 else num\n1: def chain_length(n: int, previous: set | None = None) -> int:     previous = previous or set()     if n in CHAIN_LENGTH_CACHE:         return CHAIN_LENGTH_CACHE[n]     next_number = sum_digit_factorials(n)     if next_number in previous:         CHAIN_LENGTH_CACHE[n] = 0         return 0     else:         previous.add(n)         ret = 1 + chain_length(next_number, previous)         CHAIN_LENGTH_CACHE[n] = ret         return ret\n2: def area_rectangle(length: float, width: float) -> float:     if length < 0 or width < 0:         raise ValueError(\"area_rectangle() only accepts non-negative values\")     return length * width", "output": "0"}
{"task": "detection", "input": "classify code:\ndef fletcher16(text: str) -> int:\n    \"\"\"\n    Loop through every character in the data and add to two sums.\n\n    >>> fletcher16('hello world')\n    6752\n    >>> fletcher16('onethousandfourhundredthirtyfour')\n    28347\n    >>> fletcher16('The quick brown fox jumps over the lazy dog.')\n    5655\n    \"\"\"\n    data = bytes(text, \"ascii\")\n    sum1 = 0\n    sum2 = 0\n    for character in data:\n        sum1 = (sum1 + character) % 255\n        sum2 = (sum1 + sum2) % 255\n    return (sum2 << 8) | sum1", "output": "CORRECT"}
{"task": "search", "input": "search code:\nColor-coding taking the relative distance into account. The Mandelbrot set\n\nChoices:\n0: def is_proth_number(number: int) -> bool:     if not isinstance(number, int):         message = f\"Input value of [{number=}] must be an integer\"         raise TypeError(message)      if number <= 0:         message = f\"Input value of [{number=}] must be > 0\"         raise ValueError(message)      if number == 1:         return False      number -= 1     n = 0     while number % 2 == 0:         n += 1         number //= 2     return number < 2**n\n1: def split_into(iterable, sizes):     # convert the iterable argument into an iterator so its contents can     # be consumed by islice in case it is a generator     it = iter(iterable)      for size in sizes:         if size is None:             yield list(it)             return         else:             yield list(islice(it, size))\n2: def get_color_coded_rgb(distance: float) -> tuple:     if distance == 1:         return (0, 0, 0)     else:         return tuple(round(i * 255) for i in colorsys.hsv_to_rgb(distance, 1, 1))", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef gray_to_binary(gray: np.ndarray) -> np.ndarray:\n    return (gray > 127) & (gray <= 255)", "output": "Return binary image from gray image"}
{"task": "detection", "input": "classify code:\ndef prime_sieve(n: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef minimum_cost_path(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the first integer whose square is of the form 1_2_3_4_5_6_7_8_9_0\n\nChoices:\n0: def power_of_4(number: int) -> bool:     if not isinstance(number, int):         raise TypeError(\"number must be an integer\")     if number <= 0:         raise ValueError(\"number must be positive\")     if number & (number - 1) == 0:         c = 0         while number:             c += 1             number >>= 1         return c % 2 == 1     else:         return False\n1: def chain(number: int) -> bool:      if CHAINS[number - 1] is not None:         return CHAINS[number - 1]  # type: ignore[return-value]      number_chain = chain(next_number(number))     CHAINS[number - 1] = number_chain      while number < 10000000:         CHAINS[number - 1] = number_chain         number *= 10      return number_chain\n2: def solution() -> int:     num = 138902663      while not is_square_form(num * num):         if num % 10 == 3:             num -= 6  # (3 - 6) % 10 = 7         else:             num -= 4  # (7 - 4) % 10 = 3      return num * 10", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef find_min_iterative(nums: list[int | float]) -> int | float:\n    if len(nums) == 0:\n        raise ValueError(\"find_min_iterative() arg is an empty sequence\")\n    min_num = nums[0]\n    for num in nums:\n        min_num = min(min_num, num)\n    return min_num", "output": "Find Minimum Number in a List"}
{"task": "summary", "input": "summarize code:\ndef map_if(iterable, pred, func, func_else=None):\n\n    if func_else is None:\n        for item in iterable:\n            yield func(item) if pred(item) else item\n\n    else:\n        for item in iterable:\n            yield func(item) if pred(item) else func_else(item)", "output": "Evaluate each item from *iterable* using *pred*. If the result is"}
{"task": "search", "input": "search code:\nReturns two maps of (*types*, *funcs*) from *mod*, optionally\n\nChoices:\n0: def assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:     if i == 0 and j == 0:         return []     elif ops[i][j][0] in {\"C\", \"R\"}:         seq = assemble_transformation(ops, i - 1, j - 1)         seq.append(ops[i][j])         return seq     elif ops[i][j][0] == \"D\":         seq = assemble_transformation(ops, i - 1, j)         seq.append(ops[i][j])         return seq     else:         seq = assemble_transformation(ops, i, j - 1)         seq.append(ops[i][j])         return seq\n1: def repeat_each(iterable, n=2):     return chain.from_iterable(map(repeat, iterable, repeat(n)))\n2: def get_module_callables(mod, ignore=None):     if isinstance(mod, str):         mod = sys.modules[mod]     types, funcs = {}, {}     for attr_name in dir(mod):         if ignore and ignore(attr_name):             continue         try:             attr = getattr(mod, attr_name)         except Exception:             continue         try:             attr_mod_name = attr.__module__         except AttributeError:             continue         if attr_mod_name != mod.__name__:             continue         if isinstance(attr, type):             types[attr_name] = attr         elif callable(attr):             funcs[attr_name] = attr     return types, funcs", "output": "2"}
{"task": "search", "input": "search code:\nArbitrary index order, greedily consumed\n\nChoices:\n0: def _shift_to_odd(n):     'Return s, d such that 2**s * d == n'     s = ((n - 1) ^ n).bit_length() - 1     d = n >> s     assert (1 << s) * d == n and d & 1 and s >= 0     return s, d\n1: def _extract_buffered(iterator, index_and_position):     'Arbitrary index order, greedily consumed'     buffer = {}     iterator_position = -1     next_to_emit = 0      for index, order in index_and_position:         advance = index - iterator_position         if advance:             try:                 value = next(islice(iterator, advance - 1, None))             except StopIteration:                 raise IndexError(index) from None             iterator_position = index          buffer[order] = value          while next_to_emit in buffer:             yield buffer.pop(next_to_emit)             next_to_emit += 1\n2: def solution(nth: int = 10001) -> int:      count = 0     number = 1     while count != nth and number < 3:         number += 1         if is_prime(number):             count += 1     while count != nth:         number += 2         if is_prime(number):             count += 1     return number", "output": "1"}
{"task": "search", "input": "search code:\nIterate through the array to find the index of key using recursion.\n\nChoices:\n0: def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:     right = right or len(list_data) - 1     if left > right:         return -1     elif list_data[left] == key:         return left     elif list_data[right] == key:         return right     else:         return search(list_data, key, left + 1, right - 1)\n1: def solution():     i = 1      while True:         if (             sorted(str(i))             == sorted(str(2 * i))             == sorted(str(3 * i))             == sorted(str(4 * i))             == sorted(str(5 * i))             == sorted(str(6 * i))         ):             return i          i += 1\n2: def solution(numerator: int = 1, digit: int = 1000) -> int:     the_digit = 1     longest_list_length = 0      for divide_by_number in range(numerator, digit + 1):         has_been_divided: list[int] = []         now_divide = numerator         for _ in range(1, digit + 1):             if now_divide in has_been_divided:                 if longest_list_length < len(has_been_divided):                     longest_list_length = len(has_been_divided)                     the_digit = divide_by_number             else:                 has_been_divided.append(now_divide)                 now_divide = now_divide * 10 % divide_by_number      return the_digit", "output": "0"}
{"task": "search", "input": "search code:\n- img_list <type: list>: list of all images\n\nChoices:\n0: def _batched(iterable, n, *, strict=False):  # pragma: no cover     if n < 1:         raise ValueError('n must be at least one')     iterator = iter(iterable)     while batch := tuple(islice(iterator, n)):         if strict and len(batch) != n:             raise ValueError('batched(): incomplete batch')         yield batch\n1: def update_image_and_anno(     img_list: list, anno_list: list, flip_type: int = 1 ) -> tuple[list, list, list]:     new_annos_lists = []     path_list = []     new_imgs_list = []     for idx in range(len(img_list)):         new_annos = []         path = img_list[idx]         path_list.append(path)         img_annos = anno_list[idx]         img = cv2.imread(path)         if flip_type == 1:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 x_center_new = 1 - bbox[1]                 new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])         elif flip_type == 0:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 y_center_new = 1 - bbox[2]                 new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])         new_annos_lists.append(new_annos)         new_imgs_list.append(new_img)     return new_imgs_list, new_annos_lists, path_list\n2: def longest_common_subsequence(x: str, y: str):     # find the length of strings      assert x is not None     assert y is not None      m = len(x)     n = len(y)      # declaring the array for storing the dp values     dp = [[0] * (n + 1) for _ in range(m + 1)]      for i in range(1, m + 1):         for j in range(1, n + 1):             match = 1 if x[i - 1] == y[j - 1] else 0              dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)      seq = \"\"     i, j = m, n     while i > 0 and j > 0:         match = 1 if x[i - 1] == y[j - 1] else 0          if dp[i][j] == dp[i - 1][j - 1] + match:             if match == 1:                 seq = x[i - 1] + seq             i -= 1             j -= 1         elif dp[i][j] == dp[i - 1][j]:             i -= 1         else:             j -= 1      return dp[m][n], seq", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef double_linear_search(array: list[int], search_item: int) -> int:\n    # define the start and end index of the given array\n    start_ind, end_ind = 0, len(array) - 1\n    while start_ind <= end_ind:\n        if array[start_ind] == search_item:\n            return start_ind\n        elif array[end_ind] == search_item:\n            return end_ind\n        else:\n            start_ind += 1\n            end_ind -= 1\n    # returns -1 if search_item is not found in array\n    return -1", "output": "Iterate through the array from both sides to find the index of search_item."}
{"task": "detection", "input": "classify code:\ndef pancake_sort(arr):\n    \"\"\"Sort Array with Pancake Sort.\n    :param arr: Collection containing comparable items\n    :return: Collection ordered in ascending order of items\n    Examples:\n    >>> pancake_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pancake_sort([])\n    []\n    >>> pancake_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    cur = len(arr)\n    while cur > 1:\n        # Find the maximum number in arr\n        mi = arr.index(max(arr[0:cur]))\n        # Reverse from 0 to mi\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\n        # Reverse whole list\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\n        cur -= 1\n    return arr", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCalculate NIMPLY of the input values\n\nChoices:\n0: def nimply_gate(input_1: int, input_2: int) -> int:     return int(input_1 == 1 and input_2 == 0)\n1: def choose(n: int, r: int) -> int:     ret = 1.0     for i in range(1, r + 1):         ret *= (n + 1 - i) / i     return round(ret)\n2: def forward_propagation(expected: int, number_propagations: int) -> float:      # Random weight     weight = float(2 * (random.randint(1, 100)) - 1)      for _ in range(number_propagations):         # Forward propagation         layer_1 = sigmoid_function(INITIAL_VALUE * weight)         # How much did we miss?         layer_1_error = (expected / 100) - layer_1         # Error delta         layer_1_delta = layer_1_error * sigmoid_function(layer_1, True)         # Update weight         weight += INITIAL_VALUE * layer_1_delta      return layer_1 * 100", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 998001) -> int:\n\n    answer = 0\n    for i in range(999, 99, -1):  # 3 digit numbers range from 999 down to 100\n        for j in range(999, 99, -1):\n            product_string = str(i * j)\n            if product_string == product_string[::-1] and i * j < n:\n                answer = max(answer, i * j)\n    return answer", "output": "Returns the largest palindrome made from the product of two 3-digit"}
{"task": "summary", "input": "summarize code:\ndef binary_and(a: int, b: int) -> str:\n    if a < 0 or b < 0:\n        raise ValueError(\"the value of both inputs must be positive\")\n\n    a_binary = format(a, \"b\")\n    b_binary = format(b, \"b\")\n\n    max_len = max(len(a_binary), len(b_binary))\n\n    return \"0b\" + \"\".join(\n        str(int(char_a == \"1\" and char_b == \"1\"))\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\n    )", "output": "Take in 2 integers, convert them to binary,"}
{"task": "summary", "input": "summarize code:\ndef perfect(number: int) -> bool:\n    if not isinstance(number, int):\n        raise ValueError(\"number must be an integer\")\n    if number <= 0:\n        return False\n    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number", "output": "Check if a number is a perfect number."}
{"task": "detection", "input": "classify code:\ndef generate_parentheses_iterative(length: int) -> list:\n    \"\"\"\n    Generate all valid combinations of parentheses (Iterative Approach).\n\n    The algorithm works as follows:\n    1. Initialize an empty list to store the combinations.\n    2. Initialize a stack to keep track of partial combinations.\n    3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n    4. While the stack is not empty:\n        a. Pop a partial combination and its open and close counts from the stack.\n        b. If the combination length is equal to 2*length, add it to the result.\n        c. If open count < length, push new combination with added '(' on stack.\n        d. If close count < open count, push new combination with added ')' on stack.\n    5. Return the result containing all valid combinations.\n\n    Args:\n        length: The desired length of the parentheses combinations\n\n    Returns:\n        A list of strings representing valid combinations of parentheses\n\n    Time Complexity:\n        O(2^(2*length))\n\n    Space Complexity:\n        O(2^(2*length))\n\n    >>> generate_parentheses_iterative(3)\n    ['()()()', '()(())', '(())()', '(()())', '((()))']\n    >>> generate_parentheses_iterative(2)\n    ['()()', '(())']\n    >>> generate_parentheses_iterative(1)\n    ['()']\n    >>> generate_parentheses_iterative(0)\n    ['']\n    \"\"\"\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef euclidean_distance_sqr(point1, point2):\n    \"\"\"\n    >>> euclidean_distance_sqr([1,2],[2,4])\n    5\n    \"\"\"\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCalculate the turnaround time of each process.\n\nChoices:\n0: def spy(iterable, n=1):     p, q = tee(iterable)     return take(n, q), p\n1: def calculate_turnaroundtime(     burst_time: list[int], no_of_processes: int, waiting_time: list[int] ) -> list[int]:      turn_around_time = [0] * no_of_processes     for i in range(no_of_processes):         turn_around_time[i] = burst_time[i] + waiting_time[i]     return turn_around_time\n2: def value_chain(*args):     scalar_types = (str, bytes)     for value in args:         if isinstance(value, scalar_types):             yield value             continue         try:             yield from value         except TypeError:             yield value", "output": "1"}
{"task": "detection", "input": "classify code:\ndef is_palindrome(n: Union[int, str]) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False", "output": "BUGGY"}
{"task": "search", "input": "search code:\nTakes the temperature (in K) and molar mass (in kg/mol) of a gas\n\nChoices:\n0: def msd_radix_sort_inplace(list_of_ints: list[int]):      length = len(list_of_ints)     if not list_of_ints or length == 1:         return      if min(list_of_ints) < 0:         raise ValueError(\"All numbers must be positive\")      most_bits = max(len(bin(x)[2:]) for x in list_of_ints)     _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)\n1: def mps_speed_of_molecule(temperature: float, molar_mass: float) -> float:      if temperature < 0:         raise Exception(\"Absolute temperature cannot be less than 0 K\")     if molar_mass <= 0:         raise Exception(\"Molar mass should be greater than 0 kg/mol\")     return (2 * R * temperature / molar_mass) ** 0.5\n2: def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:      return len_board * len_board_column * row + column", "output": "1"}
{"task": "search", "input": "search code:\nDecrypts the ciphertext using the Running Key Cipher.\n\nChoices:\n0: def merge(arr: list[int]) -> list[int]:     if len(arr) > 1:         middle_length = len(arr) // 2  # Finds the middle of the array         left_array = arr[             :middle_length         ]  # Creates an array of the elements in the first half.         right_array = arr[             middle_length:         ]  # Creates an array of the elements in the second half.         left_size = len(left_array)         right_size = len(right_array)         merge(left_array)  # Starts sorting the left.         merge(right_array)  # Starts sorting the right         left_index = 0  # Left Counter         right_index = 0  # Right Counter         index = 0  # Position Counter         while (             left_index < left_size and right_index < right_size         ):  # Runs until the lowers size of the left and right are sorted.             if left_array[left_index] < right_array[right_index]:                 arr[index] = left_array[left_index]                 left_index += 1             else:                 arr[index] = right_array[right_index]                 right_index += 1             index += 1         while (             left_index < left_size         ):  # Adds the left over elements in the left half of the array             arr[index] = left_array[left_index]             left_index += 1             index += 1         while (             right_index < right_size         ):  # Adds the left over elements in the right half of the array             arr[index] = right_array[right_index]             right_index += 1             index += 1     return arr\n1: def find_negative_index(array: list[int]) -> int:     left = 0     right = len(array) - 1      # Edge cases such as no values or all numbers are negative.     if not array or array[0] < 0:         return 0      while right + 1 > left:         mid = (left + right) // 2         num = array[mid]          # Num must be negative and the index must be greater than or equal to 0.         if num < 0 and array[mid - 1] >= 0:             return mid          if num >= 0:             left = mid + 1         else:             right = mid - 1     # No negative numbers so return the last index of the array + 1 which is the length.     return len(array)\n2: def running_key_decrypt(key: str, ciphertext: str) -> str:     ciphertext = ciphertext.replace(\" \", \"\").upper()     key = key.replace(\" \", \"\").upper()     key_length = len(key)     plaintext = []     ord_a = ord(\"A\")      for i, char in enumerate(ciphertext):         c = ord(char) - ord_a         k = ord(key[i % key_length]) - ord_a         p = (c - k) % 26         plaintext.append(chr(p + ord_a))      return \"\".join(plaintext)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 2) -> int:\n    result = 1.0\n    for fraction in fraction_list(n):\n        frac = Fraction(fraction)\n        result *= frac.denominator / frac.numerator\n    return int(result)", "output": "Return the solution to the problem"}
{"task": "summary", "input": "summarize code:\ndef multiply_matrix_vector(\n    graph: list[list[int | None]], vector: np.ndarray\n) -> np.ndarray:\n    num_nodes: int = len(graph)\n    if vector.shape[0] != num_nodes:\n        raise ValueError(\"Vector length must match the number of nodes in the graph.\")\n\n    result: np.ndarray = np.zeros(num_nodes)\n    for node_index, neighbors in enumerate(graph):\n        for neighbor_index in neighbors:\n            result[node_index] += vector[neighbor_index]\n    return result", "output": "Performs multiplication of a graph's adjacency list representation with a vector."}
{"task": "summary", "input": "summarize code:\ndef reversible_numbers(\n    remaining_length: int, remainder: int, digits: list[int], length: int\n) -> int:\n    # There exist no reversible 1, 5, 9, 13 (ie. 4k+1) digit numbers\n    if (length - 1) % 4 == 0:\n        return 0\n\n    return slow_reversible_numbers(remaining_length, remainder, digits, length)", "output": "Count the number of reversible numbers of given length."}
{"task": "summary", "input": "summarize code:\ndef parse_int_list(range_string, delim=',', range_delim='-'):\n    output = []\n\n    for x in range_string.strip().split(delim):\n\n        # Range\n        if range_delim in x:\n            range_limits = list(map(int, x.split(range_delim)))\n            output += list(range(min(range_limits), max(range_limits)+1))\n\n        # Empty String\n        elif not x:\n            continue\n\n        # Integer\n        else:\n            output.append(int(x))\n\n    return sorted(output)", "output": "Returns a sorted list of positive integers based on"}
{"task": "summary", "input": "summarize code:\ndef _extract_buffered(iterator, index_and_position):\n    'Arbitrary index order, greedily consumed'\n    buffer = {}\n    iterator_position = -1\n    next_to_emit = 0\n\n    for index, order in index_and_position:\n        advance = index - iterator_position\n        if advance:\n            try:\n                value = next(islice(iterator, advance - 1, None))\n            except StopIteration:\n                raise IndexError(index) from None\n            iterator_position = index\n\n        buffer[order] = value\n\n        while next_to_emit in buffer:\n            yield buffer.pop(next_to_emit)\n            next_to_emit += 1", "output": "Arbitrary index order, greedily consumed"}
{"task": "repair", "input": "fix bug:\ndef bisect_left(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "def bisect_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "tests": ["assert bisect_left([0, 5, 7, 10, 15], 0) == 0", "assert bisect_left([0, 5, 7, 10, 15], 6) == 2", "assert bisect_left([0, 5, 7, 10, 15], 20) == 5", "assert bisect_left([0, 5, 7, 10, 15], 15, 1, 3) == 3", "assert bisect_left([0, 5, 7, 10, 15], 6, 2) == 2"]}
{"task": "summary", "input": "summarize code:\ndef benchmark() -> None:\n    from timeit import timeit\n\n    setup = \"from __main__ import is_pangram, is_pangram_faster, is_pangram_fastest\"\n    print(timeit(\"is_pangram()\", setup=setup))\n    print(timeit(\"is_pangram_faster()\", setup=setup))\n    print(timeit(\"is_pangram_fastest()\", setup=setup))", "output": "Benchmark code comparing different version."}
{"task": "search", "input": "search code:\nAn implementation of the Monte Carlo method to find area under\n\nChoices:\n0: def compress(source_path: str, destination_path: str) -> None:     data_bits = read_file_binary(source_path)     data_bits = remove_prefix(data_bits)     decompressed = decompress_data(data_bits)     write_file_binary(destination_path, decompressed)\n1: def validate(*values: float) -> bool:     result = len(values) > 0 and all(value > 0.0 for value in values)     return result\n2: def area_under_curve_estimator(     iterations: int,     function_to_integrate: Callable[[float], float],     min_value: float = 0.0,     max_value: float = 1.0, ) -> float:      return mean(         function_to_integrate(uniform(min_value, max_value)) for _ in range(iterations)     ) * (max_value - min_value)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef create_vector(end_point1: Point3d, end_point2: Point3d) -> Vector3d:\n    x = end_point2[0] - end_point1[0]\n    y = end_point2[1] - end_point1[1]\n    z = end_point2[2] - end_point1[2]\n    return (x, y, z)", "output": "Pass two points to get the vector from them in the form (x, y, z)."}
{"task": "repair", "input": "fix bug:\ndef standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5", "output": "def standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5", "tests": ["assert standard_deviation(0.21) == 0.458257569495584"]}
{"task": "summary", "input": "summarize code:\ndef _date_and_delta(value, *, now=None):\n    if not now:\n        now = _now()\n    if isinstance(value, dt.datetime):\n        date = value\n        delta = now - value\n    elif isinstance(value, dt.timedelta):\n        date = now - value\n        delta = value\n    else:\n        try:\n            value = int(value)\n            delta = dt.timedelta(seconds=value)\n            date = now - delta\n        except (ValueError, TypeError):\n            return None, value\n    return date, _abs_timedelta(delta)", "output": "Turn a value into a date and a timedelta which represents how long ago it was."}
{"task": "search", "input": "search code:\nCalculate the Surface Area of a Cube.\n\nChoices:\n0: def check_bouncy(n: int) -> bool:     if not isinstance(n, int):         raise ValueError(\"check_bouncy() accepts only integer arguments\")     str_n = str(n)     sorted_str_n = \"\".join(sorted(str_n))     return str_n not in {sorted_str_n, sorted_str_n[::-1]}\n1: def sum_digits(num: int) -> int:     digit_sum = 0     while num > 0:         digit_sum += num % 10         num //= 10     return digit_sum\n2: def surface_area_cube(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"surface_area_cube() only accepts non-negative values\")     return 6 * side_length**2", "output": "2"}
{"task": "search", "input": "search code:\n| Randomly generate a clause.\n\nChoices:\n0: def build_sparse_table(number_list: list[int]) -> list[list[int]]:     if not number_list:         raise ValueError(\"empty number list not allowed\")      length = len(number_list)     # Initialise sparse_table -- sparse_table[j][i] represents the minimum value of the     # subset of length (2 ** j) of number_list, starting from index i.      # smallest power of 2 subset length that fully covers number_list     row = int(log2(length)) + 1     sparse_table = [[0 for i in range(length)] for j in range(row)]      # minimum of subset of length 1 is that value itself     for i, value in enumerate(number_list):         sparse_table[0][i] = value     j = 1      # compute the minimum value for all intervals with size (2 ** j)     while (1 << j) <= length:         i = 0         # while subset starting from i still have at least (2 ** j) elements         while (i + (1 << j) - 1) < length:             # split range [i, i + 2 ** j] and find minimum of 2 halves             sparse_table[j][i] = min(                 sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]             )             i += 1         j += 1     return sparse_table\n1: def length_conversion(value: float, from_type: str, to_type: str) -> float:     new_from = from_type.lower().rstrip(\"s\")     new_from = TYPE_CONVERSION.get(new_from, new_from)     new_to = to_type.lower().rstrip(\"s\")     new_to = TYPE_CONVERSION.get(new_to, new_to)     if new_from not in METRIC_CONVERSION:         msg = (             f\"Invalid 'from_type' value: {from_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     if new_to not in METRIC_CONVERSION:         msg = (             f\"Invalid 'to_type' value: {to_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     return (         value         * METRIC_CONVERSION[new_from].from_factor         * METRIC_CONVERSION[new_to].to_factor     )\n2: def generate_clause() -> Clause:     literals = []     no_of_literals = random.randint(1, 5)     base_var = \"A\"     i = 0     while i < no_of_literals:         var_no = random.randint(1, 5)         var_name = base_var + str(var_no)         var_complement = random.randint(0, 1)         if var_complement == 1:             var_name += \"'\"         if var_name in literals:             i -= 1         else:             literals.append(var_name)         i += 1     return Clause(literals)", "output": "2"}
{"task": "search", "input": "search code:\nwhich can be 1, 3, 5, or 7.\n\nChoices:\n0: def my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:     kernels = {         1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),         3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),         5: np.array(             [                 [0, 0, -1, 0, 0],                 [0, -1, -2, -1, 0],                 [-1, -2, 16, -2, -1],                 [0, -1, -2, -1, 0],                 [0, 0, -1, 0, 0],             ]         ),         7: np.array(             [                 [0, 0, 0, -1, 0, 0, 0],                 [0, 0, -2, -3, -2, 0, 0],                 [0, -2, -7, -10, -7, -2, 0],                 [-1, -3, -10, 68, -10, -3, -1],                 [0, -2, -7, -10, -7, -2, 0],                 [0, 0, -2, -3, -2, 0, 0],                 [0, 0, 0, -1, 0, 0, 0],             ]         ),     }     if ksize not in kernels:         msg = f\"ksize must be in {tuple(kernels)}\"         raise ValueError(msg)      # Apply the Laplacian kernel using convolution     return filter2D(         src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)     )\n1: def parse_token(token: str | float) -> float | str:     if token in OPERATORS:         return token     try:         return float(token)     except ValueError:         msg = f\"{token} is neither a number nor a valid operator\"         raise ValueError(msg)\n2: def parse_file(file_path: str) -> list[Letter]:     chars: dict[str, int] = {}     with open(file_path) as f:         while True:             c = f.read(1)             if not c:                 break             chars[c] = chars[c] + 1 if c in chars else 1     return sorted((Letter(c, f) for c, f in chars.items()), key=lambda x: x.freq)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef fletcher16(text: str) -> int:\n    \"\"\"\n    Loop through every character in the data and add to two sums.\n\n    >>> fletcher16('hello world')\n    6752\n    >>> fletcher16('onethousandfourhundredthirtyfour')\n    28347\n    >>> fletcher16('The quick brown fox jumps over the lazy dog.')\n    5655\n    \"\"\"\n    data = bytes(text, \"ascii\")\n    sum1 = 0\n    sum2 = 0\n    for character in data:\n        sum1 = (sum1 + character) % 255\n        sum2 = (sum1 + sum2) % 255\n    return (sum2 << 8) | sum1", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef rstrip_iter(iterable, strip_value=None):\n    iterator = iter(iterable)\n    for i in iterator:\n        if i == strip_value:\n            cache = list()\n            cache.append(i)\n            broken = False\n            for i in iterator:\n                if i == strip_value:\n                    cache.append(i)\n                else:\n                    broken = True\n                    break\n            if not broken:  # Return to caller here because the end of the\n                return     # iterator has been reached\n            yield from cache\n        yield i", "output": "Strips values from the end of an iterable. Stripped items will"}
{"task": "summary", "input": "summarize code:\ndef solution(filename: str = \"matrix.txt\") -> int:\n    with open(os.path.join(os.path.dirname(__file__), filename)) as in_file:\n        data = in_file.read()\n\n    grid = [[int(cell) for cell in row.split(\",\")] for row in data.strip().splitlines()]\n    dp = [[0 for cell in row] for row in grid]\n    n = len(grid[0])\n\n    dp = [[0 for i in range(n)] for j in range(n)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, n):\n        dp[0][i] = grid[0][i] + dp[0][i - 1]\n    for i in range(1, n):\n        dp[i][0] = grid[i][0] + dp[i - 1][0]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]", "output": "Returns the minimal path sum from the top left to the bottom right of the matrix."}
{"task": "summary", "input": "summarize code:\ndef doublestarmap(func, iterable):\n    for item in iterable:\n        yield func(**item)", "output": "Apply *func* to every item of *iterable* by dictionary unpacking"}
{"task": "summary", "input": "summarize code:\ndef tokenize_format_str(fstr, resolve_pos=True):\n    ret = []\n    if resolve_pos:\n        fstr = infer_positional_format_args(fstr)\n    formatter = Formatter()\n    for lit, fname, fspec, conv in formatter.parse(fstr):\n        if lit:\n            ret.append(lit)\n        if fname is None:\n            continue\n        ret.append(BaseFormatField(fname, fspec, conv))\n    return ret", "output": "Takes a format string, turns it into a list of alternating string"}
{"task": "search", "input": "search code:\nFunction returns the top side view of binary tree.\n\nChoices:\n0: def is_sq(number: int) -> bool:     sq: int = int(number**0.5)     return number == sq * sq\n1: def binary_tree_top_side_view(root: TreeNode) -> list[int]:      def breadth_first_search(root: TreeNode, top_view: list[int]) -> None:         queue = [(root, 0)]         lookup = defaultdict(list)          while queue:             first = queue.pop(0)             node, hd = first              lookup[hd].append(node.val)              if node.left:                 queue.append((node.left, hd - 1))             if node.right:                 queue.append((node.right, hd + 1))          for pair in sorted(lookup.items(), key=lambda each: each[0]):             top_view.append(pair[1][0])      top_view: list = []     if not root:         return top_view      breadth_first_search(root, top_view)     return top_view\n2: def max_height(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(angle)     return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef main():\n    print(\"Volumes:\")\n    print(f\"Cube: {vol_cube(2) = }\")  # = 8\n    print(f\"Cuboid: {vol_cuboid(2, 2, 2) = }\")  # = 8\n    print(f\"Cone: {vol_cone(2, 2) = }\")  # ~= 1.33\n    print(f\"Right Circular Cone: {vol_right_circ_cone(2, 2) = }\")  # ~= 8.38\n    print(f\"Prism: {vol_prism(2, 2) = }\")  # = 4\n    print(f\"Pyramid: {vol_pyramid(2, 2) = }\")  # ~= 1.33\n    print(f\"Sphere: {vol_sphere(2) = }\")  # ~= 33.5\n    print(f\"Hemisphere: {vol_hemisphere(2) = }\")  # ~= 16.75\n    print(f\"Circular Cylinder: {vol_circular_cylinder(2, 2) = }\")  # ~= 25.1\n    print(f\"Torus: {vol_torus(2, 2) = }\")  # ~= 157.9\n    print(f\"Conical Frustum: {vol_conical_frustum(2, 2, 4) = }\")  # ~= 58.6\n    print(f\"Spherical cap: {vol_spherical_cap(1, 2) = }\")  # ~= 5.24\n    print(f\"Spheres intersection: {vol_spheres_intersect(2, 2, 1) = }\")  # ~= 21.21\n    print(f\"Spheres union: {vol_spheres_union(2, 2, 1) = }\")  # ~= 45.81\n    print(\n        f\"Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }\"\n    )  # ~= 28.3\n    print(f\"Icosahedron: {vol_icosahedron(2.5) = }\")  # ~=34.09", "output": "Print the Results of Various Volume Calculations."}
{"task": "search", "input": "search code:\nDriver function to execute PCA and display results.\n\nChoices:\n0: def encode(word: str) -> str:     encoded = \"\"     for letter in word.lower():         if letter.isalpha() or letter == \" \":             encoded += encode_dict[letter]         else:             raise Exception(\"encode() accepts only letters of the alphabet and spaces\")     return encoded\n1: def main() -> None:     data_x, _data_y = collect_dataset()      # Number of principal components to retain     n_components = 2      # Apply PCA     transformed_data, variance_ratio = apply_pca(data_x, n_components)      print(\"Transformed Dataset (First 5 rows):\")     print(transformed_data[:5])      print(\"\\nExplained Variance Ratio:\")     print(variance_ratio)\n2: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]", "output": "1"}
{"task": "search", "input": "search code:\nSort the given list based on the bit at bit_position. Numbers with a\n\nChoices:\n0: def binary_exp_mod_iterative(base: float, exponent: int, modulus: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")     if modulus <= 0:         raise ValueError(\"Modulus must be a positive integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res = ((res % modulus) * (base % modulus)) % modulus          base *= base         exponent >>= 1      return res\n1: def _msd_radix_sort_inplace(     list_of_ints: list[int], bit_position: int, begin_index: int, end_index: int ):     if bit_position == 0 or end_index - begin_index <= 1:         return      bit_position -= 1      i = begin_index     j = end_index - 1     while i <= j:         changed = False         if not (list_of_ints[i] >> bit_position) & 1:             # found zero at the beginning             i += 1             changed = True         if (list_of_ints[j] >> bit_position) & 1:             # found one at the end             j -= 1             changed = True          if changed:             continue          list_of_ints[i], list_of_ints[j] = list_of_ints[j], list_of_ints[i]         j -= 1         if j != i:             i += 1      _msd_radix_sort_inplace(list_of_ints, bit_position, begin_index, i)     _msd_radix_sort_inplace(list_of_ints, bit_position, i, end_index)\n2: def argmax(iterable, *, key=None):     if key is not None:         iterable = map(key, iterable)     return max(enumerate(iterable), key=itemgetter(1))[0]", "output": "1"}
{"task": "search", "input": "search code:\nReturns the number of composite integers below max_number have precisely two,\n\nChoices:\n0: def reversible_numbers(     remaining_length: int, remainder: int, digits: list[int], length: int ) -> int:     # There exist no reversible 1, 5, 9, 13 (ie. 4k+1) digit numbers     if (length - 1) % 4 == 0:         return 0      return slow_reversible_numbers(remaining_length, remainder, digits, length)\n1: def effusion_ratio(molar_mass_1: float, molar_mass_2: float) -> float | ValueError:     return (         round(sqrt(molar_mass_2 / molar_mass_1), 6)         if validate(molar_mass_1, molar_mass_2)         else ValueError(\"Input Error: Molar mass values must greater than 0.\")     )\n2: def solution(max_number: int = 10**8) -> int:      prime_numbers = calculate_prime_numbers(max_number // 2)      semiprimes_count = 0     right = len(prime_numbers) - 1     for left in range(len(prime_numbers)):         if left > right:             break         for r in range(right, left - 2, -1):             if prime_numbers[left] * prime_numbers[r] < max_number:                 break         right = r         semiprimes_count += right - left + 1      return semiprimes_count", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef generate_sum_of_subsets_solutions(nums: list[int], max_sum: int) -> list[list[int]]:\n\n    result: list[list[int]] = []\n    path: list[int] = []\n    num_index = 0\n    remaining_nums_sum = sum(nums)\n    create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)\n    return result", "output": "The main function. For list of numbers 'nums' find the subsets with sum"}
{"task": "summary", "input": "summarize code:\ndef transpose(it):\n    return zip(*it, strict=True)", "output": "Swap the rows and columns of the input matrix."}
{"task": "summary", "input": "summarize code:\ndef sylvester(number: int) -> int:\n    assert isinstance(number, int), f\"The input value of [n={number}] is not an integer\"\n\n    if number == 1:\n        return 2\n    elif number < 1:\n        msg = f\"The input value of [n={number}] has to be > 0\"\n        raise ValueError(msg)\n    else:\n        num = sylvester(number - 1)\n        lower = num - 1\n        upper = num\n        return lower * upper + 1", "output": ":param number: nth number to calculate in the sequence"}
{"task": "search", "input": "search code:\nCalculate kinetic energy.\n\nChoices:\n0: def kinetic_energy(mass: float, velocity: float) -> float:     if mass < 0:         raise ValueError(\"The mass of a body cannot be negative\")     return 0.5 * mass * abs(velocity) * abs(velocity)\n1: def cosine_similarity(input_a: np.ndarray, input_b: np.ndarray) -> float:     return float(np.dot(input_a, input_b) / (norm(input_a) * norm(input_b)))\n2: def max_sum_in_array(array: list[int], k: int) -> int:     if len(array) < k or k < 0:         raise ValueError(\"Invalid Input\")     max_sum = current_sum = sum(array[:k])     for i in range(len(array) - k):         current_sum = current_sum - array[i] + array[i + k]         max_sum = max(max_sum, current_sum)     return max_sum", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef floor_ceiling(root: Node | None, key: int) -> tuple[int | None, int | None]:\n    floor_val = None\n    ceiling_val = None\n\n    while root:\n        if root.key == key:\n            floor_val = root.key\n            ceiling_val = root.key\n            break\n\n        if key < root.key:\n            ceiling_val = root.key\n            root = root.left\n        else:\n            floor_val = root.key\n            root = root.right\n\n    return floor_val, ceiling_val", "output": "Find the floor and ceiling values for a given key in a Binary Search Tree (BST)."}
{"task": "summary", "input": "summarize code:\ndef decimal_to_fraction(decimal: float | str) -> tuple[int, int]:\n    try:\n        decimal = float(decimal)\n    except ValueError:\n        raise ValueError(\"Please enter a valid number\")\n    fractional_part = decimal - int(decimal)\n    if fractional_part == 0:\n        return int(decimal), 1\n    else:\n        number_of_frac_digits = len(str(decimal).split(\".\")[1])\n        numerator = int(decimal * (10**number_of_frac_digits))\n        denominator = 10**number_of_frac_digits\n        divisor, dividend = denominator, numerator\n        while True:\n            remainder = dividend % divisor\n            if remainder == 0:\n                break\n            dividend, divisor = divisor, remainder\n        numerator, denominator = numerator // divisor, denominator // divisor\n        return numerator, denominator", "output": "Return a decimal number in its simplest fraction form"}
{"task": "repair", "input": "fix bug:\ndef increment_score(count: int) -> int:\n    \"\"\"\n    Calculates the score for a move based on the number of elements removed.\n\n    >>> increment_score(3)\n    6\n    >>> increment_score(0)\n    0\n    \"\"\"\n    return int(count * (count + 1) / 2)", "output": "def increment_score(count: int) -> int:\n    \"\"\"\n    Calculates the score for a move based on the number of elements removed.\n\n    >>> increment_score(3)\n    6\n    >>> increment_score(0)\n    0\n    \"\"\"\n    return int(count * (count + 1) / 2)", "tests": ["assert increment_score(3) == 6", "assert increment_score(0) == 0"]}
{"task": "search", "input": "search code:\nDecodes data according to RFC4648.\n\nChoices:\n0: def singularize(word):     orig_word, word = word, word.strip().lower()     if not word or word in _IRR_S2P:         return orig_word      irr_singular = _IRR_P2S.get(word)     if irr_singular:         singular = irr_singular     elif not word.endswith('s'):         return orig_word     elif len(word) == 2:         singular = word[:-1]  # or just return word?     elif word.endswith('ies') and word[-4:-3] not in 'aeiou':         singular = word[:-3] + 'y'     elif word.endswith('es') and word[-3] == 's':         singular = word[:-2]     else:         singular = word[:-1]     return _match_case(orig_word, singular)\n1: def solution(num_picks: int = 20) -> str:     total = math.comb(NUM_BALLS, num_picks)     missing_colour = math.comb(NUM_BALLS - BALLS_PER_COLOUR, num_picks)      result = NUM_COLOURS * (1 - missing_colour / total)      return f\"{result:.9f}\"\n2: def base64_decode(encoded_data: str) -> bytes:     # Make sure encoded_data is either a string or a bytes-like object     if not isinstance(encoded_data, bytes) and not isinstance(encoded_data, str):         msg = (             \"argument should be a bytes-like object or ASCII string, \"             f\"not '{encoded_data.__class__.__name__}'\"         )         raise TypeError(msg)      # In case encoded_data is a bytes-like object, make sure it contains only     # ASCII characters so we convert it to a string object     if isinstance(encoded_data, bytes):         try:             encoded_data = encoded_data.decode(\"utf-8\")         except UnicodeDecodeError:             raise ValueError(\"base64 encoded data should only contain ASCII characters\")      padding = encoded_data.count(\"=\")      # Check if the encoded string contains non base64 characters     if padding:         assert all(char in B64_CHARSET for char in encoded_data[:-padding]), (             \"Invalid base64 character(s) found.\"         )     else:         assert all(char in B64_CHARSET for char in encoded_data), (             \"Invalid base64 character(s) found.\"         )      # Check the padding     assert len(encoded_data) % 4 == 0 and padding < 3, \"Incorrect padding\"      if padding:         # Remove padding if there is one         encoded_data = encoded_data[:-padding]          binary_stream = \"\".join(             bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data         )[: -padding * 2]     else:         binary_stream = \"\".join(             bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data         )      data = [         int(binary_stream[index : index + 8], 2)         for index in range(0, len(binary_stream), 8)     ]      return bytes(data)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef update_image_and_anno(\n    img_list: list, anno_list: list, flip_type: int = 1\n) -> tuple[list, list, list]:\n    new_annos_lists = []\n    path_list = []\n    new_imgs_list = []\n    for idx in range(len(img_list)):\n        new_annos = []\n        path = img_list[idx]\n        path_list.append(path)\n        img_annos = anno_list[idx]\n        img = cv2.imread(path)\n        if flip_type == 1:\n            new_img = cv2.flip(img, flip_type)\n            for bbox in img_annos:\n                x_center_new = 1 - bbox[1]\n                new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])\n        elif flip_type == 0:\n            new_img = cv2.flip(img, flip_type)\n            for bbox in img_annos:\n                y_center_new = 1 - bbox[2]\n                new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])\n        new_annos_lists.append(new_annos)\n        new_imgs_list.append(new_img)\n    return new_imgs_list, new_annos_lists, path_list", "output": "- img_list <type: list>: list of all images"}
{"task": "search", "input": "search code:\nThis is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\nChoices:\n0: def solve(board: list[list[int]], row: int) -> bool:     if row >= len(board):         solution.append(board)         printboard(board)         print()         return True     for i in range(len(board)):         if is_safe(board, row, i):             board[row][i] = 1             solve(board, row + 1)             board[row][i] = 0     return False\n1: def solution(a: int = 100, b: int = 100) -> int:      # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of     # BASE raised to the POWER     return max(         sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)     )\n2: def f(x):     return x**2", "output": "2"}
{"task": "search", "input": "search code:\nFunction returns the digit associated with the color. Function takes a\n\nChoices:\n0: def largest_square_area_in_matrix_bottom_up(     rows: int, cols: int, mat: list[list[int]] ) -> int:     dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]     largest_square_area = 0     for row in range(rows - 1, -1, -1):         for col in range(cols - 1, -1, -1):             right = dp_array[row][col + 1]             diagonal = dp_array[row + 1][col + 1]             bottom = dp_array[row + 1][col]              if mat[row][col] == 1:                 dp_array[row][col] = 1 + min(right, diagonal, bottom)                 largest_square_area = max(dp_array[row][col], largest_square_area)             else:                 dp_array[row][col] = 0      return largest_square_area\n1: def get_significant_digits(colors: list) -> str:     digit = \"\"     for color in colors:         if color not in significant_figures_color_values:             msg = f\"{color} is not a valid color for significant figure bands\"             raise ValueError(msg)         digit = digit + str(significant_figures_color_values[color])     return str(digit)\n2: def exits_word(     board: list[list[str]],     word: str,     row: int,     column: int,     word_index: int,     visited_points_set: set[int], ) -> bool:      if board[row][column] != word[word_index]:         return False      if word_index == len(word) - 1:         return True      traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]     len_board = len(board)     len_board_column = len(board[0])     for direction in traverts_directions:         next_i = row + direction[0]         next_j = column + direction[1]         if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):             continue          key = get_point_key(len_board, len_board_column, next_i, next_j)         if key in visited_points_set:             continue          visited_points_set.add(key)         if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):             return True          visited_points_set.remove(key)      return False", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef crossover(parent_1: str, parent_2: str) -> tuple[str, str]:\n    random_slice = random.randint(0, len(parent_1) - 1)\n    child_1 = parent_1[:random_slice] + parent_2[random_slice:]\n    child_2 = parent_2[:random_slice] + parent_1[random_slice:]\n    return (child_1, child_2)", "output": "Slice and combine two strings at a random point."}
{"task": "summary", "input": "summarize code:\ndef continuous_fraction_period(n: int) -> int:\n    numerator = 0.0\n    denominator = 1.0\n    root = int(sqrt(n))\n    integer_part = root\n    period = 0\n    while integer_part != 2 * root:\n        numerator = denominator * integer_part - numerator\n        denominator = (n - numerator**2) / denominator\n        integer_part = int((root + numerator) / denominator)\n        period += 1\n    return period", "output": "Returns the continued fraction period of a number n."}
{"task": "search", "input": "search code:\nReturns the next number of the chain by adding the square of each digit\n\nChoices:\n0: def rec_insertion_sort(collection: list, n: int):     # Checks if the entire collection has been sorted     if len(collection) <= 1 or n <= 1:         return      insert_next(collection, n - 1)     rec_insertion_sort(collection, n - 1)\n1: def next_number(number: int) -> int:      sum_of_digits_squared = 0     while number:         # Increased Speed Slightly by checking every 5 digits together.         sum_of_digits_squared += DIGITS_SQUARED[number % 100000]         number //= 100000      return sum_of_digits_squared\n2: def get_tolerance(color: str) -> float:     if color not in tolerance_color_values:         msg = f\"{color} is not a valid color for tolerance band\"         raise ValueError(msg)     return tolerance_color_values[color]", "output": "1"}
{"task": "detection", "input": "classify code:\ndef get_pascal_triangle_unique_coefficients(depth: int) -> Set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReads source file, decompresses it and writes the result in destination file\n\nChoices:\n0: def chain(number: int) -> bool:      if CHAINS[number - 1] is not None:         return CHAINS[number - 1]  # type: ignore[return-value]      number_chain = chain(next_number(number))     CHAINS[number - 1] = number_chain      while number < 10000000:         CHAINS[number - 1] = number_chain         number *= 10      return number_chain\n1: def compress(source_path: str, destination_path: str) -> None:     data_bits = read_file_binary(source_path)     data_bits = remove_prefix(data_bits)     decompressed = decompress_data(data_bits)     write_file_binary(destination_path, decompressed)\n2: def krusk(e_and_n):     (e, n) = e_and_n     e.sort(reverse=True, key=lambda x: x[2])     s = [{i} for i in range(1, n + 1)]     while True:         if len(s) == 1:             break         print(s)         x = e.pop()         for i in range(len(s)):             if x[0] in s[i]:                 break         for j in range(len(s)):             if x[1] in s[j]:                 if i == j:                     break                 s[j].update(s[i])                 s.pop(i)                 break", "output": "1"}
{"task": "search", "input": "search code:\nParse the file, build the tree, then run through the file\n\nChoices:\n0: def huffman(file_path: str) -> None:     letters_list = parse_file(file_path)     root = build_tree(letters_list)     letters = {         k: v for letter in traverse_tree(root, \"\") for k, v in letter.bitstring.items()     }     print(f\"Huffman Coding  of {file_path}: \")     with open(file_path) as f:         while True:             c = f.read(1)             if not c:                 break             print(letters[c], end=\" \")     print()\n1: def narcissistic_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False     expo = len(str(n))  # the power that all digits will be raised to     # check if sum of each digit multiplied expo times is equal to number     return n == sum(int(i) ** expo for i in str(n))\n2: def solution() -> int:     limit = 7 * factorial(9) + 1     return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    A Pangram String contains all the alphabets at least once.\n    >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram(\"My name is Unknown\")\n    False\n    >>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram()\n    True\n    \"\"\"\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26", "output": "def is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    A Pangram String contains all the alphabets at least once.\n    >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram(\"My name is Unknown\")\n    False\n    >>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram()\n    True\n    \"\"\"\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26", "tests": ["assert is_pangram(\"The quick brown fox jumps over the lazy dog\") == True", "assert is_pangram(\"Waltz, bad nymph, for quick jigs vex.\") == True", "assert is_pangram(\"Jived fox nymph grabs quick waltz.\") == True", "assert is_pangram(\"My name is Unknown\") == False", "assert is_pangram(\"The quick brown fox jumps over the la_y dog\") == False", "assert is_pangram() == True"]}
{"task": "summary", "input": "summarize code:\ndef matrix_pow_np(m: ndarray, power: int) -> ndarray:\n    result = np.array([[1, 0], [0, 1]], dtype=int)  # Identity Matrix\n    base = m\n    if power < 0:  # Negative power is not allowed\n        raise ValueError(\"power is negative\")\n    while power:\n        if power % 2 == 1:\n            result = np.dot(result, base)\n        base = np.dot(base, base)\n        power //= 2\n    return result", "output": "Raises a matrix to the power of 'power' using binary exponentiation."}
{"task": "search", "input": "search code:\nThis function returns the factors of N, where p*q=N\n\nChoices:\n0: def rsafactor(d: int, e: int, n: int) -> list[int]:     k = d * e - 1     p = 0     q = 0     while p == 0:         g = random.randint(2, n - 1)         t = k         while True:             if t % 2 == 0:                 t = t // 2                 x = (g**t) % n                 y = math.gcd(x - 1, n)                 if x > 1 and y > 1:                     p = y                     q = n // y                     break  # find the correct factors             else:                 break  # t is not divisible by 2, break and choose another g     return sorted([p, q])\n1: def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:     return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2\n2: def filter_map(func, iterable):     for x in iterable:         y = func(x)         if y is not None:             yield y", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef cross(items_a, items_b):\n    return [a + b for a in items_a for b in items_b]", "output": "Cross product of elements in A and elements in B."}
{"task": "repair", "input": "fix bug:\ndef is_pangram_fastest(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_fastest()\n    True\n    \"\"\"\n    return len({char for char in input_str.lower() if char.isalpha()}) == 26", "output": "def is_pangram_fastest(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_fastest()\n    True\n    \"\"\"\n    return len({char for char in input_str.lower() if char.isalpha()}) == 26", "tests": ["assert is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\") == True", "assert is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\") == True", "assert is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\") == True", "assert is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\") == False", "assert is_pangram_fastest() == True"]}
{"task": "summary", "input": "summarize code:\ndef combination_sum_iv(array: list[int], target: int) -> int:\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)", "output": "Function checks the all possible combinations, and returns the count"}
{"task": "search", "input": "search code:\nFinds fibonacci number in index k.\n\nChoices:\n0: def simpson_integration(function, a: float, b: float, precision: int = 4) -> float:     assert callable(function), (         f\"the function(object) passed should be callable your input : {function}\"     )     assert isinstance(a, (float, int)), f\"a should be float or integer your input : {a}\"     assert isinstance(function(a), (float, int)), (         \"the function should return integer or float return type of your function, \"         f\"{type(a)}\"     )     assert isinstance(b, (float, int)), f\"b should be float or integer your input : {b}\"     assert isinstance(precision, int) and precision > 0, (         f\"precision should be positive integer your input : {precision}\"     )      # just applying the formula of simpson for approximate integration written in     # mentioned article in first comment of this file and above this function      h = (b - a) / N_STEPS     result = function(a) + function(b)      for i in range(1, N_STEPS):         a1 = a + h * i         result += function(a1) * (4 if i % 2 else 2)      result *= h / 3     return round(result, precision)\n1: def fibonacci(k: int) -> int:     if not isinstance(k, int):         raise TypeError(\"k must be an integer.\")     if k < 0:         raise ValueError(\"k integer must be greater or equal to zero.\")     if k == 0:         return 0     elif k == 1:         return 1     else:         return fibonacci(k - 1) + fibonacci(k - 2)\n2: def euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:     return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef fibonacci(k: int) -> int:\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer.\")\n    if k < 0:\n        raise ValueError(\"k integer must be greater or equal to zero.\")\n    if k == 0:\n        return 0\n    elif k == 1:\n        return 1\n    else:\n        return fibonacci(k - 1) + fibonacci(k - 2)", "output": "Finds fibonacci number in index k."}
{"task": "detection", "input": "classify code:\ndef merge_insertion_sort(collection: List[int]) -> List[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns integral of circle bottom arc y = 1 / 2 - sqrt(1 / 4 - (x - 1 / 2) ^ 2)\n\nChoices:\n0: def equality(iterable: list) -> bool:     return len(set(iterable)) in (0, 1)\n1: def avg_speed_of_molecule(temperature: float, molar_mass: float) -> float:      if temperature < 0:         raise Exception(\"Absolute temperature cannot be less than 0 K\")     if molar_mass <= 0:         raise Exception(\"Molar mass should be greater than 0 kg/mol\")     return (8 * R * temperature / (pi * molar_mass)) ** 0.5\n2: def circle_bottom_arc_integral(point: float) -> float:      return (         (1 - 2 * point) * sqrt(point - point**2) + 2 * point + asin(sqrt(1 - point))     ) / 4", "output": "2"}
{"task": "search", "input": "search code:\nReturns the sum of all the primes below n.\n\nChoices:\n0: def sumset(set_a: set, set_b: set) -> set:     assert isinstance(set_a, set), f\"The input value of [set_a={set_a}] is not a set\"     assert isinstance(set_b, set), f\"The input value of [set_b={set_b}] is not a set\"      return {a + b for a in set_a for b in set_b}\n1: def solution(n: int = 2000000) -> int:      return sum(num for num in range(3, n, 2) if is_prime(num)) + 2 if n > 2 else 0\n2: def josephus_recursive(num_people: int, step_size: int) -> int:     if (         not isinstance(num_people, int)         or not isinstance(step_size, int)         or num_people <= 0         or step_size <= 0     ):         raise ValueError(\"num_people or step_size is not a positive integer.\")      if num_people == 1:         return 0      return (josephus_recursive(num_people - 1, step_size) + step_size) % num_people", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef chunked(iterable, n, strict=False):\n    iterator = iter(partial(take, n, iter(iterable)), [])\n    if strict:\n        if n is None:\n            raise ValueError('n must not be None when using strict mode.')\n\n        def ret():\n            for chunk in iterator:\n                if len(chunk) != n:\n                    raise ValueError('iterable is not divisible by n.')\n                yield chunk\n\n        return ret()\n    else:\n        return iterator", "output": "Break *iterable* into lists of length *n*:"}
{"task": "search", "input": "search code:\nSimple function that should be used when no effect is desired.\n\nChoices:\n0: def quick_sort_3partition(sorting: list, left: int, right: int) -> None:     if right <= left:         return     a = i = left     b = right     pivot = sorting[left]     while i <= b:         if sorting[i] < pivot:             sorting[a], sorting[i] = sorting[i], sorting[a]             a += 1             i += 1         elif sorting[i] > pivot:             sorting[b], sorting[i] = sorting[i], sorting[b]             b -= 1         else:             i += 1     quick_sort_3partition(sorting, left, a - 1)     quick_sort_3partition(sorting, b + 1, right)\n1: def clone_graph(node: Node | None) -> Node | None:     if not node:         return None      originals_to_clones = {}  # map nodes to clones      stack = [node]      while stack:         original = stack.pop()          if original in originals_to_clones:             continue          originals_to_clones[original] = Node(original.value)          stack.extend(original.neighbors or [])      for original, clone in originals_to_clones.items():         for neighbor in original.neighbors or []:             cloned_neighbor = originals_to_clones[neighbor]              if not clone.neighbors:                 clone.neighbors = []              clone.neighbors.append(cloned_neighbor)      return originals_to_clones[node]\n2: def noop(*args, **kwargs):     return None", "output": "2"}
{"task": "detection", "input": "classify code:\ndef knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef left_shift(data):\n    \"\"\"\n    >>> left_shift(\"0123456789\")\n    '1234567890'\n    \"\"\"\n    return data[1:] + data[0]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef split_into(iterable, sizes):\n    # convert the iterable argument into an iterator so its contents can\n    # be consumed by islice in case it is a generator\n    it = iter(iterable)\n\n    for size in sizes:\n        if size is None:\n            yield list(it)\n            return\n        else:\n            yield list(islice(it, size))", "output": "Yield a list of sequential items from *iterable* of length 'n' for each"}
{"task": "search", "input": "search code:\nDecorator that automatically advances a PEP-342-style \"reverse iterator\"\n\nChoices:\n0: def is_palindrome(n: int) -> bool:     if n % 10 == 0:         return False     s = str(n)     return s == s[::-1]\n1: def consumer(func):      @wraps(func)     def wrapper(*args, **kwargs):         gen = func(*args, **kwargs)         next(gen)         return gen      return wrapper\n2: def draw_cross(x: float, y: float, length: float):     turtle.up()     turtle.goto(x - length / 2, y - length / 6)     turtle.down()     turtle.seth(0)     turtle.begin_fill()     for _ in range(4):         turtle.fd(length / 3)         turtle.right(90)         turtle.fd(length / 3)         turtle.left(90)         turtle.fd(length / 3)         turtle.left(90)     turtle.end_fill()", "output": "1"}
{"task": "detection", "input": "classify code:\ndef least_common_multiple_slow(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n\n    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple\n\n    >>> least_common_multiple_slow(5, 2)\n    10\n    >>> least_common_multiple_slow(12, 76)\n    228\n    \"\"\"\n    max_num = first_num if first_num >= second_num else second_num\n    common_mult = max_num\n    while (common_mult % first_num > 0) or (common_mult % second_num > 0):\n        common_mult += max_num\n    return common_mult", "output": "CORRECT"}
{"task": "search", "input": "search code:\nInterpolate and evaluate a polynomial using Neville's method.\n\nChoices:\n0: def insert_next(collection: list, index: int):     # Checks order between adjacent elements     if index >= len(collection) or collection[index - 1] <= collection[index]:         return      # Swaps adjacent elements since they are not in ascending order     collection[index - 1], collection[index] = (         collection[index],         collection[index - 1],     )      insert_next(collection, index + 1)\n1: def neville_interpolate(x_points: list, y_points: list, x0: int) -> list:     n = len(x_points)     q = [[0] * n for i in range(n)]     for i in range(n):         q[i][1] = y_points[i]      for i in range(2, n):         for j in range(i, n):             q[j][i] = (                 (x0 - x_points[j - i + 1]) * q[j][i - 1]                 - (x0 - x_points[j]) * q[j - 1][i - 1]             ) / (x_points[j] - x_points[j - i + 1])      return [q[n - 1][n - 1], q]\n2: def solve(     digit: int, prev1: int, prev2: int, sum_max: int, first: bool, cache: dict[str, int] ) -> int:     if digit == 0:         return 1      cache_str = f\"{digit},{prev1},{prev2}\"     if cache_str in cache:         return cache[cache_str]      comb = 0     for curr in range(sum_max - prev1 - prev2 + 1):         if first and curr == 0:             continue          comb += solve(             digit=digit - 1,             prev1=curr,             prev2=prev1,             sum_max=sum_max,             first=False,             cache=cache,         )      cache[cache_str] = comb     return comb", "output": "1"}
{"task": "search", "input": "search code:\nReturn True if n is an Armstrong number or False if it is not.\n\nChoices:\n0: def armstrong_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False      # Initialization of sum and number of digits.     total = 0     number_of_digits = 0     temp = n     # Calculation of digits of the number     number_of_digits = len(str(n))     # Dividing number into separate digits and find Armstrong number     temp = n     while temp > 0:         rem = temp % 10         total += rem**number_of_digits         temp //= 10     return n == total\n1: def covariance_within_classes(     features: np.ndarray, labels: np.ndarray, classes: int ) -> np.ndarray:      covariance_sum = np.nan     for i in range(classes):         data = features[:, labels == i]         data_mean = data.mean(1)         # Centralize the data of class i         centered_data = data - column_reshape(data_mean)         if i > 0:             # If covariance_sum is not None             covariance_sum += np.dot(centered_data, centered_data.T)         else:             # If covariance_sum is np.nan (i.e. first loop)             covariance_sum = np.dot(centered_data, centered_data.T)      return covariance_sum / features.shape[1]\n2: def go_next(i: int, z_result: list[int], s: str) -> bool:     return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:\n    return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))", "output": "Implements the ELU activation function."}
{"task": "search", "input": "search code:\nReturn probability of k successes out of n tries, with p probability for one\n\nChoices:\n0: def binomial_distribution(successes: int, trials: int, prob: float) -> float:     if successes > trials:     if trials < 0 or successes < 0:         raise ValueError(\"the function is defined for non-negative integers\")     if not isinstance(successes, int) or not isinstance(trials, int):         raise ValueError(\"the function is defined for non-negative integers\")     if not 0 < prob < 1:         raise ValueError(\"prob has to be in range of 1 - 0\")     probability = (prob**successes) * ((1 - prob) ** (trials - successes))     # Calculate the binomial coefficient: n! / k!(n-k)!     coefficient = float(factorial(trials))     coefficient /= factorial(successes) * factorial(trials - successes)     return probability * coefficient\n1: def compute_transform_tables(     source_string: str,     destination_string: str,     copy_cost: int,     replace_cost: int,     delete_cost: int,     insert_cost: int, ) -> tuple[list[list[int]], list[list[str]]]:     source_seq = list(source_string)     destination_seq = list(destination_string)     len_source_seq = len(source_seq)     len_destination_seq = len(destination_seq)     costs = [         [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]     ops = [         [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]      for i in range(1, len_source_seq + 1):         costs[i][0] = i * delete_cost         ops[i][0] = f\"D{source_seq[i - 1]}\"      for i in range(1, len_destination_seq + 1):         costs[0][i] = i * insert_cost         ops[0][i] = f\"I{destination_seq[i - 1]}\"      for i in range(1, len_source_seq + 1):         for j in range(1, len_destination_seq + 1):             if source_seq[i - 1] == destination_seq[j - 1]:                 costs[i][j] = costs[i - 1][j - 1] + copy_cost                 ops[i][j] = f\"C{source_seq[i - 1]}\"             else:                 costs[i][j] = costs[i - 1][j - 1] + replace_cost                 ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])              if costs[i - 1][j] + delete_cost < costs[i][j]:                 costs[i][j] = costs[i - 1][j] + delete_cost                 ops[i][j] = f\"D{source_seq[i - 1]}\"              if costs[i][j - 1] + insert_cost < costs[i][j]:                 costs[i][j] = costs[i][j - 1] + insert_cost                 ops[i][j] = f\"I{destination_seq[j - 1]}\"      return costs, ops\n2: def breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:     visited = {start}     result = [start]     queue = deque([start])     while queue:         v = queue.popleft()         for child in graph[v]:             if child not in visited:                 visited.add(child)                 result.append(child)                 queue.append(child)     return result", "output": "0"}
{"task": "search", "input": "search code:\nreturn F(n)\n\nChoices:\n0: def fibonacci(n: int) -> int:     if n < 0:         raise ValueError(\"Negative arguments are not supported\")     return _fib(n)[0]\n1: def mode(input_list: list) -> list[Any]:     if not input_list:         return []     result = [input_list.count(value) for value in input_list]     y = max(result)  # Gets the maximum count in the input list.     # Gets values of modes     return sorted({input_list[i] for i, value in enumerate(result) if value == y})\n2: def non_bouncy_upto(n: int) -> int:     return sum(non_bouncy_exact(i) for i in range(1, n + 1))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef infer_positional_format_args(fstr):\n    # TODO: memoize\n    ret, max_anon = '', 0\n    # look for {: or {! or {. or {[ or {}\n    start, end, prev_end = 0, 0, 0\n    for match in _pos_farg_re.finditer(fstr):\n        start, end, group = match.start(), match.end(), match.group()\n        if prev_end < start:\n            ret += fstr[prev_end:start]\n        prev_end = end\n        if group == '{{' or group == '}}':\n            ret += group\n            continue\n        ret += f'{{{max_anon}{group[1:]}'\n        max_anon += 1\n    ret += fstr[prev_end:]\n    return ret", "output": "Takes format strings with anonymous positional arguments, (e.g.,"}
{"task": "search", "input": "search code:\nReturns a sample transaction dataset.\n\nChoices:\n0: def mutate(child: str, genes: list[str]) -> str:     child_list = list(child)     if random.uniform(0, 1) < MUTATION_PROBABILITY:         child_list[random.randint(0, len(child)) - 1] = random.choice(genes)     return \"\".join(child_list)\n1: def load_data() -> list[list[str]]:     return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]\n2: def area_triangle(base: float, height: float) -> float:     if base < 0 or height < 0:         raise ValueError(\"area_triangle() only accepts non-negative values\")     return (base * height) / 2", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef is_zero_vector(vector: Vector3d, accuracy: int) -> bool:\n    return tuple(round(x, accuracy) for x in vector) == (0, 0, 0)", "output": "Check if vector is equal to (0, 0, 0) or not."}
{"task": "search", "input": "search code:\nFind the maximum non-adjacent sum of the integers in the nums input list\n\nChoices:\n0: def maximum_non_adjacent_sum(nums: list[int]) -> int:     if not nums:         return 0     max_including = nums[0]     max_excluding = 0     for num in nums[1:]:         max_including, max_excluding = (             max_excluding + num,             max(max_including, max_excluding),         )     return max(max_excluding, max_including)\n1: def solution(n: int = 200) -> int:     return two_pound(n)\n2: def depth_first_search(graph: dict, start: str) -> set[str]:     explored, stack = set(start), [start]      while stack:         v = stack.pop()         explored.add(v)         # Differences from BFS:         # 1) pop last element instead of first one         # 2) add adjacent elements to stack without exploring them         for adj in reversed(graph[v]):             if adj not in explored:                 stack.append(adj)     return explored", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef create_all_state(\n    increment: int,\n    total_number: int,\n    level: int,\n    current_list: list[int],\n    total_list: list[list[int]],\n) -> None:\n    if level == 0:\n        total_list.append(current_list[:])\n        return\n\n    for i in range(increment, total_number - level + 2):\n        current_list.append(i)\n        create_all_state(i + 1, total_number, level - 1, current_list, total_list)\n        current_list.pop()", "output": "Helper function to recursively build all combinations."}
{"task": "repair", "input": "fix bug:\ndef sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum", "output": "def sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum", "tests": ["assert sum_digits(1) == 1", "assert sum_digits(12345) == 15", "assert sum_digits(999001) == 28"]}
{"task": "repair", "input": "fix bug:\ndef get_squared_primes_to_use(\n    num_to_look: int, squared_primes: List[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx", "output": "def get_squared_primes_to_use(\n    num_to_look: int, squared_primes: list[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx", "tests": ["assert get_squared_primes_to_use(1, [4, 9, 16, 25], 0) == -1", "assert get_squared_primes_to_use(4, [4, 9, 16, 25], 0) == 1", "assert get_squared_primes_to_use(16, [4, 9, 16, 25], 1) == 3"]}
{"task": "summary", "input": "summarize code:\ndef get_citation(base_url: str, params: dict) -> str:\n    soup = BeautifulSoup(\n        httpx.get(base_url, params=params, timeout=10).content, \"html.parser\"\n    )\n    div = soup.find(\"div\", attrs={\"class\": \"gs_ri\"})\n    anchors = div.find(\"div\", attrs={\"class\": \"gs_fl\"}).find_all(\"a\")\n    return anchors[2].get_text()", "output": "Return the citation number."}
{"task": "search", "input": "search code:\nReturns the difference between the sum of the squares of the first n\n\nChoices:\n0: def solution(n: int = 100) -> int:      sum_of_squares = sum(i * i for i in range(1, n + 1))     square_of_sum = int(math.pow(sum(range(1, n + 1)), 2))     return square_of_sum - sum_of_squares\n1: def throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:     dices = [Dice() for i in range(num_dice)]     count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)     for _ in range(num_throws):         count_of_sum[sum(dice.roll() for dice in dices)] += 1     probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]     return probability[num_dice:]  # remove probability of sums that never appear\n2: def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:     return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))", "output": "0"}
{"task": "search", "input": "search code:\nA basic function that turns text full of scary characters\n\nChoices:\n0: def slugify(text, delim='_', lower=True, ascii=False):     ret = delim.join(split_punct_ws(text)) or delim if text else ''     if ascii:         ret = asciify(ret)     if lower:         ret = ret.lower()     return ret\n1: def filter_map(func, iterable):     for x in iterable:         y = func(x)         if y is not None:             yield y\n2: def doublestarmap(func, iterable):     for item in iterable:         yield func(**item)", "output": "0"}
{"task": "search", "input": "search code:\nReturns the number of different combinations of k length which can\n\nChoices:\n0: def gamma_recursive(num: float) -> float:     if num <= 0:         raise ValueError(\"math domain error\")     if num > 171.5:         raise OverflowError(\"math range error\")     elif num - int(num) not in (0, 0.5):         raise NotImplementedError(\"num must be an integer or a half-integer\")     elif num == 0.5:         return math.sqrt(math.pi)     else:         return 1.0 if num == 1 else (num - 1) * gamma_recursive(num - 1)\n1: def is_safe(board: list[list[int]], row: int, column: int) -> bool:      n = len(board)  # Size of the board      # Check if there is any queen in the same upper column,     # left upper diagonal and right upper diagonal     return (         all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))         )         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))         )     )\n2: def combinations(n: int, k: int) -> int:      # If either of the conditions are true, the function is being asked     # to calculate a factorial of a negative number, which is not possible     if n < k or k < 0:         raise ValueError(\"Please enter positive integers for n and k where n >= k\")     res = 1     for i in range(k):         res *= n - i         res //= i + 1     return res", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef bubble_sort_iterative(collection: list[Any]) -> list[Any]:\n    length = len(collection)\n    for i in reversed(range(length)):\n        swapped = False\n        for j in range(i):\n            if collection[j] > collection[j + 1]:\n                swapped = True\n                collection[j], collection[j + 1] = collection[j + 1], collection[j]\n        if not swapped:\n            break  # Stop iteration if the collection is sorted.\n    return collection", "output": "Pure implementation of bubble sort algorithm in Python"}
{"task": "search", "input": "search code:\nReturns True if input matrix is symmetric positive definite.\n\nChoices:\n0: def local_weight(     point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float ) -> np.ndarray:     weight_mat = weight_matrix(point, x_train, tau)     weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (         x_train.T @ weight_mat @ y_train.T     )      return weight\n1: def _is_matrix_spd(matrix: np.ndarray) -> bool:     # Ensure matrix is square.     assert np.shape(matrix)[0] == np.shape(matrix)[1]      # If matrix not symmetric, exit right away.     if np.allclose(matrix, matrix.T) is False:         return False      # Get eigenvalues and eignevectors for a symmetric matrix.     eigen_values, _ = np.linalg.eigh(matrix)      # Check sign of all eigenvalues.     # np.all returns a value of type np.bool_     return bool(np.all(eigen_values > 0))\n2: def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:      return len_board * len_board_column * row + column", "output": "1"}
{"task": "search", "input": "search code:\nEncrypts the plaintext using the Running Key Cipher.\n\nChoices:\n0: def track_edge(image_shape, destination, weak, strong):     for row in range(1, image_shape[0]):         for col in range(1, image_shape[1]):             if destination[row, col] == weak:                 if 255 in (                     destination[row, col + 1],                     destination[row, col - 1],                     destination[row - 1, col],                     destination[row + 1, col],                     destination[row - 1, col - 1],                     destination[row + 1, col - 1],                     destination[row - 1, col + 1],                     destination[row + 1, col + 1],                 ):                     destination[row, col] = strong                 else:                     destination[row, col] = 0\n1: def running_key_encrypt(key: str, plaintext: str) -> str:     plaintext = plaintext.replace(\" \", \"\").upper()     key = key.replace(\" \", \"\").upper()     key_length = len(key)     ciphertext = []     ord_a = ord(\"A\")      for i, char in enumerate(plaintext):         p = ord(char) - ord_a         k = ord(key[i % key_length]) - ord_a         c = (p + k) % 26         ciphertext.append(chr(c + ord_a))      return \"\".join(ciphertext)\n2: def quick_select(arr: list, target: int) -> int:      # Invalid Input     if target > len(arr):         return -1      # x is the estimated pivot by median of medians algorithm     x = median_of_medians(arr)     left = []     right = []     check = False     for i in range(len(arr)):         if arr[i] < x:             left.append(arr[i])         elif arr[i] > x:             right.append(arr[i])         elif arr[i] == x and not check:             check = True         else:             right.append(arr[i])     rank_x = len(left) + 1     if rank_x == target:         answer = x     elif rank_x > target:         answer = quick_select(left, target)     elif rank_x < target:         answer = quick_select(right, target - rank_x)     return answer", "output": "1"}
{"task": "search", "input": "search code:\nCount the number of vowels in a given string.\n\nChoices:\n0: def calc_profit(profit: list, weight: list, max_weight: int) -> int:     if len(profit) != len(weight):         raise ValueError(\"The length of profit and weight must be same.\")     if max_weight <= 0:         raise ValueError(\"max_weight must greater than zero.\")     if any(p < 0 for p in profit):         raise ValueError(\"Profit can not be negative.\")     if any(w < 0 for w in weight):         raise ValueError(\"Weight can not be negative.\")      # List created to store profit gained for the 1kg in case of each weight     # respectively.  Calculate and append profit/weight for each element.     profit_by_weight = [p / w for p, w in zip(profit, weight)]      # Creating a copy of the list and sorting profit/weight in ascending order     sorted_profit_by_weight = sorted(profit_by_weight)      # declaring useful variables     length = len(sorted_profit_by_weight)     limit = 0     gain = 0     i = 0      # loop till the total weight do not reach max limit e.g. 15 kg and till i<length     while limit <= max_weight and i < length:         # flag value for encountered greatest element in sorted_profit_by_weight         biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]         index = profit_by_weight.index(biggest_profit_by_weight)         profit_by_weight[index] = -1          # check if the weight encountered is less than the total weight         # encountered before.         if max_weight - limit >= weight[index]:             limit += weight[index]             # Adding profit gained for the given weight 1 ===             # weight[index]/weight[index]             gain += 1 * profit[index]         else:             # Since the weight encountered is greater than limit, therefore take the             # required number of remaining kgs and calculate profit for it.             # weight remaining / weight[index]             gain += (max_weight - limit) / weight[index] * profit[index]             break         i += 1     return gain\n1: def count_vowels(s: str) -> int:     if not isinstance(s, str):         raise ValueError(\"Input must be a string\")      vowels = \"aeiouAEIOU\"     return sum(1 for char in s if char in vowels)\n2: def process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:      game_matrix = [list(row) for row in matrix]     total_score = 0      for move in moves:         pos_x, pos_y = move         game_matrix, score = play(game_matrix, pos_x, pos_y, size)         total_score += score      return total_score", "output": "1"}
{"task": "detection", "input": "classify code:\ndef sum_reverse(n: int) -> int:\n    \"\"\"\n    Returns the sum of n and reverse of n.\n    >>> sum_reverse(123)\n    444\n    >>> sum_reverse(3478)\n    12221\n    >>> sum_reverse(12)\n    33\n    \"\"\"\n    return int(n) + int(str(n)[::-1])", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns ``True`` if all the elements of *iterable* are unique (no two\n\nChoices:\n0: def generate_image(cells: list[list[int]]) -> Image.Image:     # Create the output image     img = Image.new(\"RGB\", (len(cells[0]), len(cells)))     pixels = img.load()     # Generates image     for w in range(img.width):         for h in range(img.height):             color = 255 - int(255 * cells[h][w])             pixels[w, h] = (color, color, color)     return img\n1: def get_distance(x: float, y: float, max_step: int) -> float:     a = x     b = y     for step in range(max_step):  # noqa: B007         a_new = a * a - b * b + x         b = 2 * a * b + y         a = a_new          # divergence happens for all complex number with an absolute value         # greater than 4         if a * a + b * b > 4:             break     return step / (max_step - 1)\n2: def all_unique(iterable, key=None):     seenset = set()     seenset_add = seenset.add     seenlist = []     seenlist_add = seenlist.append     for element in map(key, iterable) if key else iterable:         try:             if element in seenset:                 return False             seenset_add(element)         except TypeError:             if element in seenlist:                 return False             seenlist_add(element)     return True", "output": "2"}
{"task": "search", "input": "search code:\nReturns a triplet in the array with sum equal to target,\n\nChoices:\n0: def fib_iterative_yield(n: int) -> Iterator[int]:     if n < 0:         raise ValueError(\"n is negative\")     a, b = 0, 1     yield a     for _ in range(n):         yield b         a, b = b, a + b\n1: def draw_cross(x: float, y: float, length: float):     turtle.up()     turtle.goto(x - length / 2, y - length / 6)     turtle.down()     turtle.seth(0)     turtle.begin_fill()     for _ in range(4):         turtle.fd(length / 3)         turtle.right(90)         turtle.fd(length / 3)         turtle.left(90)         turtle.fd(length / 3)         turtle.left(90)     turtle.end_fill()\n2: def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:     arr.sort()     n = len(arr)     for i in range(n - 1):         left, right = i + 1, n - 1         while left < right:             if arr[i] + arr[left] + arr[right] == target:                 return (arr[i], arr[left], arr[right])             elif arr[i] + arr[left] + arr[right] < target:                 left += 1             elif arr[i] + arr[left] + arr[right] > target:                 right -= 1     return (0, 0, 0)", "output": "2"}
{"task": "search", "input": "search code:\nChecks if nums can have a sum equal to goal, given that length of nums does\n\nChoices:\n0: def open_knight_tour(n: int) -> list[list[int]]:      board = [[0 for i in range(n)] for j in range(n)]      for i in range(n):         for j in range(n):             board[i][j] = 1             if open_knight_tour_helper(board, (i, j), 1):                 return board             board[i][j] = 0      msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"     raise ValueError(msg)\n1: def solve(nums: list[int], goal: int, depth: int) -> bool:     if len(nums) > depth:         return False     for el in nums:         if el + nums[-1] == goal:             return True         nums.append(el + nums[-1])         if solve(nums=nums, goal=goal, depth=depth):             return True         del nums[-1]     return False\n2: def narcissistic_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False     expo = len(str(n))  # the power that all digits will be raised to     # check if sum of each digit multiplied expo times is equal to number     return n == sum(int(i) ** expo for i in str(n))", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )", "output": "def shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )", "tests": ["assert shear_stress(stress=25, tangential_force=100, area=0) == ('area', 4.0)", "assert shear_stress(stress=0, tangential_force=1600, area=200) == ('stress', 8.0)", "assert shear_stress(stress=1000, tangential_force=0, area=1200) == ('tangential_force', 1200000)"]}
{"task": "detection", "input": "classify code:\ndef is_balanced(s: str) -> bool:\n    \"\"\"\n    >>> is_balanced(\"\")\n    True\n    >>> is_balanced(\"()\")\n    True\n    >>> is_balanced(\"[]\")\n    True\n    >>> is_balanced(\"{}\")\n    True\n    >>> is_balanced(\"()[]{}\")\n    True\n    >>> is_balanced(\"(())\")\n    True\n    >>> is_balanced(\"[[\")\n    False\n    >>> is_balanced(\"([{}])\")\n    True\n    >>> is_balanced(\"(()[)]\")\n    False\n    >>> is_balanced(\"([)]\")\n    False\n    >>> is_balanced(\"[[()]]\")\n    True\n    >>> is_balanced(\"(()(()))\")\n    True\n    >>> is_balanced(\"]\")\n    False\n    >>> is_balanced(\"Life is a bowl of cherries.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che{}ies.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che}{ies.\")\n    False\n    \"\"\"\n    open_to_closed = {\"{\": \"}\", \"[\": \"]\", \"(\": \")\"}\n    stack = []\n    for symbol in s:\n        if symbol in open_to_closed:\n            stack.append(symbol)\n        elif symbol in open_to_closed.values() and (\n            not stack or open_to_closed[stack.pop()] != symbol\n        ):\n            return False\n    return not stack  # stack should be empty", "output": "CORRECT"}
{"task": "search", "input": "search code:\nHigh precision sumprod() for complex numbers.\n\nChoices:\n0: def _complex_sumprod(v1, v2):      real = attrgetter('real')     imag = attrgetter('imag')     r1 = chain(map(real, v1), map(neg, map(imag, v1)))     r2 = chain(map(real, v2), map(imag, v2))     i1 = chain(map(real, v1), map(imag, v1))     i2 = chain(map(imag, v2), map(real, v2))     return complex(_fsumprod(r1, r2), _fsumprod(i1, i2))\n1: def wave(txt: str) -> list:      return [         txt[:a] + txt[a].upper() + txt[a + 1 :]         for a in range(len(txt))         if txt[a].isalpha()     ]\n2: def concave_triangle_area(circles_number: int) -> float:      intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (         2 * (circles_number**2 + 1)     )     intersection_x = circles_number * intersection_y      triangle_area = intersection_x * intersection_y / 2     concave_region_area = circle_bottom_arc_integral(         1 / 2     ) - circle_bottom_arc_integral(intersection_x)      return triangle_area + concave_region_area", "output": "0"}
{"task": "search", "input": "search code:\nBenchmark code comparing different version.\n\nChoices:\n0: def solution(limit: int = 1000000) -> int:     divisor = limit - 1     if divisor % 2 == 0:         divisor += 1     while least_divisible_repunit(divisor) <= limit:         divisor += 2     return divisor\n1: def manhattan_distance_one_liner(point_a: list, point_b: list) -> float:      _validate_point(point_a)     _validate_point(point_b)     if len(point_a) != len(point_b):         raise ValueError(\"Both points must be in the same n-dimensional space\")      return float(sum(abs(x - y) for x, y in zip(point_a, point_b)))\n2: def benchmark() -> None:     from timeit import timeit      setup = \"from __main__ import is_pangram, is_pangram_faster, is_pangram_fastest\"     print(timeit(\"is_pangram()\", setup=setup))     print(timeit(\"is_pangram_faster()\", setup=setup))     print(timeit(\"is_pangram_fastest()\", setup=setup))", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]", "output": "def fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]", "tests": ["assert fibonacci(2) == 1", "assert fibonacci(3) == 2", "assert fibonacci(5) == 5", "assert fibonacci(10) == 55", "assert fibonacci(12) == 144"]}
{"task": "summary", "input": "summarize code:\ndef solution():\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    words_file_path = os.path.join(script_dir, \"words.txt\")\n\n    words = \"\"\n    with open(words_file_path) as f:\n        words = f.readline()\n\n    words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]\n    words = [\n        word\n        for word in [sum(ord(x) - 64 for x in word) for word in words]\n        if word in TRIANGULAR_NUMBERS\n    ]\n    return len(words)", "output": "Finds the amount of triangular words in the words file."}
{"task": "detection", "input": "classify code:\ndef recursive_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Recursive matching algorithm.\n\n    | Time complexity: O(2^(\\|text\\| + \\|pattern\\|))\n    | Space complexity: Recursion depth is O(\\|text\\| + \\|pattern\\|).\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> recursive_match('abc', 'a.c')\n    True\n    >>> recursive_match('abc', 'af*.c')\n    True\n    >>> recursive_match('abc', 'a.c*')\n    True\n    >>> recursive_match('abc', 'a.c*d')\n    False\n    >>> recursive_match('aa', '.*')\n    True\n    \"\"\"\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False", "output": "BUGGY"}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def hypercube_points(     num_points: int, hypercube_size: float, num_dimensions: int ) -> np.ndarray:     rng = np.random.default_rng()     shape = (num_points, num_dimensions)     return hypercube_size * rng.random(shape)\n1: def is_collection(obj):     return is_iterable(obj) and not isinstance(obj, (str, bytes))\n2: def is_prime(number: int) -> bool:      # precondition     if not isinstance(number, int) or not number >= 0:         raise ValueError(\"is_prime() only accepts positive integers\")      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef dir_dict(obj, raise_exc=False):\n    # TODO: separate function for handling descriptors on types?\n    ret = {}\n    for k in dir(obj):\n        try:\n            ret[k] = getattr(obj, k)\n        except Exception:\n            if raise_exc:\n                raise\n    return ret", "output": "Return a dictionary of attribute names to values for a given"}
{"task": "search", "input": "search code:\nFind m for which the proportion of perfect partitions to total partitions is lower\n\nChoices:\n0: def solution(n: int = 600851475143) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     i = 2     ans = 0     if n == 2:         return 2     while n > 2:         while n % i != 0:             i += 1         ans = i         while n % i == 0:             n = n // i         i += 1     return int(ans)\n1: def graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:      if len(points) <= 2:         # There is no convex hull         raise ValueError(\"graham_scan: argument must contain more than 3 points.\")     if len(points) == 3:         return points     # find the lowest and the most left point     minidx = 0     miny, minx = maxsize, maxsize     for i, point in enumerate(points):         x = point[0]         y = point[1]         if y < miny:             miny = y             minx = x             minidx = i         if y == miny and x < minx:             minx = x             minidx = i      # remove the lowest and the most left point from points for preparing for sort     points.pop(minidx)      sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))     # This insert actually costs complexity,     # and you should instead add (minx, miny) into stack later.     # I'm using insert just for easy understanding.     sorted_points.insert(0, (minx, miny))      stack: deque[tuple[int, int]] = deque()     stack.append(sorted_points[0])     stack.append(sorted_points[1])     stack.append(sorted_points[2])     # The first 3 points lines are towards the left because we sort them by their angle     # from minx, miny.     current_direction = Direction.left      for i in range(3, len(sorted_points)):         while True:             starting = stack[-2]             via = stack[-1]             target = sorted_points[i]             next_direction = check_direction(starting, via, target)              if next_direction == Direction.left:                 current_direction = Direction.left                 break             if next_direction == Direction.straight:                 if current_direction == Direction.left:                     # We keep current_direction as left.                     # Because if the straight line keeps as straight,                     # we want to know if this straight line is towards left.                     break                 elif current_direction == Direction.right:                     # If the straight line is towards right,                     # every previous points on that straight line is not convex hull.                     stack.pop()             if next_direction == Direction.right:                 stack.pop()         stack.append(sorted_points[i])     return list(stack)\n2: def solution(max_proportion: float = 1 / 12345) -> int:      total_partitions = 0     perfect_partitions = 0      integer = 3     while True:         partition_candidate = (integer**2 - 1) / 4         # if candidate is an integer, then there is a partition for k         if partition_candidate == int(partition_candidate):             partition_candidate = int(partition_candidate)             total_partitions += 1             if check_partition_perfect(partition_candidate):                 perfect_partitions += 1         if (             perfect_partitions > 0             and perfect_partitions / total_partitions < max_proportion         ):             return int(partition_candidate)         integer += 1", "output": "2"}
{"task": "search", "input": "search code:\nGenerates a list of images of subsequent Game of Life states.\n\nChoices:\n0: def solution(exponent: int = 30) -> int:     # To find how many total games were lost for a given exponent x,     # we need to find the Fibonacci number F(x+2).     fibonacci_index = exponent + 2     phi = (1 + 5**0.5) / 2     fibonacci = (phi**fibonacci_index - (phi - 1) ** fibonacci_index) / 5**0.5      return int(fibonacci)\n1: def generate_images(cells: list[list[int]], frames: int) -> list[Image.Image]:     images = []     for _ in range(frames):         # Create output image         img = Image.new(\"RGB\", (len(cells[0]), len(cells)))         pixels = img.load()          # Save cells to image         for x in range(len(cells)):             for y in range(len(cells[0])):                 colour = 255 - cells[y][x] * 255                 pixels[x, y] = (colour, colour, colour)          # Save image         images.append(img)         cells = new_generation(cells)     return images\n2: def is_square_form(num: int) -> bool:     digit = 9      while num > 0:         if num % 10 != digit:             return False         num //= 100         digit -= 1      return True", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef maxpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:\n    arr = np.array(arr)\n    if arr.shape[0] != arr.shape[1]:\n        raise ValueError(\"The input array is not a square matrix\")\n    i = 0\n    j = 0\n    mat_i = 0\n    mat_j = 0\n\n    # compute the shape of the output matrix\n    maxpool_shape = (arr.shape[0] - size) // stride + 1\n    # initialize the output matrix with zeros of shape maxpool_shape\n    updated_arr = np.zeros((maxpool_shape, maxpool_shape))\n\n    while i < arr.shape[0]:\n        if i + size > arr.shape[0]:\n            # if the end of the matrix is reached, break\n            break\n        while j < arr.shape[1]:\n            # if the end of the matrix is reached, break\n            if j + size > arr.shape[1]:\n                break\n            # compute the maximum of the pooling matrix\n            updated_arr[mat_i][mat_j] = np.max(arr[i : i + size, j : j + size])\n            # shift the pooling matrix by stride of column pixels\n            j += stride\n            mat_j += 1\n\n        # shift the pooling matrix by stride of row pixels\n        i += stride\n        mat_i += 1\n\n        # reset the column index to 0\n        j = 0\n        mat_j = 0\n\n    return updated_arr", "output": "This function is used to perform maxpooling on the input array of 2D matrix(image)"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 1000000) -> int:\n    divisor = limit - 1\n    if divisor % 2 == 0:\n        divisor += 1\n    while least_divisible_repunit(divisor) <= limit:\n        divisor += 2\n    return divisor", "output": "Return the least value of n for which least_divisible_repunit(n)"}
{"task": "detection", "input": "classify code:\ndef bisect_left(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "BUGGY"}
{"task": "search", "input": "search code:\nEquivalent to ``list(product(*args))[index]``.\n\nChoices:\n0: def nth_product(index, *args):     pools = list(map(tuple, reversed(args)))     ns = list(map(len, pools))      c = reduce(mul, ns)      if index < 0:         index += c      if not 0 <= index < c:         raise IndexError      result = []     for pool, n in zip(pools, ns):         result.append(pool[index % n])         index //= n      return tuple(reversed(result))\n1: def get_black_and_white_rgb(distance: float) -> tuple:     if distance == 1:         return (0, 0, 0)     else:         return (255, 255, 255)\n2: def compute_nums(n: int) -> list[int]:     if not isinstance(n, int):         raise ValueError(\"n must be an integer\")     if n <= 0:         raise ValueError(\"n must be >= 0\")      list_nums = []     for num in range(len(odd_composites)):         i = 0         while 2 * i * i <= odd_composites[num]:             rem = odd_composites[num] - 2 * i * i             if is_prime(rem):                 break             i += 1         else:             list_nums.append(odd_composites[num])             if len(list_nums) == n:                 return list_nums      return []", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef f(x):\n    return x**2", "output": "This is the function to integrate, f(x) = (x - 0)^2 = x^2."}
{"task": "summary", "input": "summarize code:\ndef _suitable_minimum_unit(min_unit, suppress):\n    if min_unit in suppress:\n        for unit in Unit:\n            if unit > min_unit and unit not in suppress:\n                return unit\n\n        raise ValueError(\n            \"Minimum unit is suppressed and no suitable replacement was found\"\n        )\n\n    return min_unit", "output": "Return a minimum unit suitable that is not suppressed."}
{"task": "summary", "input": "summarize code:\ndef generate_image(cells: list[list[int]]) -> Image.Image:\n    # Create the output image\n    img = Image.new(\"RGB\", (len(cells[0]), len(cells)))\n    pixels = img.load()\n    # Generates image\n    for w in range(img.width):\n        for h in range(img.height):\n            color = 255 - int(255 * cells[h][w])\n            pixels[w, h] = (color, color, color)\n    return img", "output": "Convert the cells into a greyscale PIL.Image.Image and return it to the caller."}
{"task": "summary", "input": "summarize code:\ndef get_word_pattern(word: str) -> str:\n    word = word.upper()\n    next_num = 0\n    letter_nums = {}\n    word_pattern = []\n\n    for letter in word:\n        if letter not in letter_nums:\n            letter_nums[letter] = str(next_num)\n            next_num += 1\n        word_pattern.append(letter_nums[letter])\n    return \".\".join(word_pattern)", "output": "Returns numerical pattern of character appearances in given word"}
{"task": "search", "input": "search code:\nReturn an integer denoting the importance\n\nChoices:\n0: def inverse_document_frequency(df: int, n: int, smoothing=False) -> float:     if smoothing:         if n == 0:             raise ValueError(\"log10(0) is undefined.\")         return round(1 + log10(n / (1 + df)), 3)      if df == 0:         raise ZeroDivisionError(\"df must be > 0\")     elif n == 0:         raise ValueError(\"log10(0) is undefined.\")     return round(log10(n / df), 3)\n1: def solution(n: int = 1001) -> int:     total = 1      for i in range(1, ceil(n / 2.0)):         odd = 2 * i + 1         even = 2 * i         total = total + 4 * odd**2 - 6 * even      return total\n2: def freq_subgraphs_edge_list(paths):     freq_sub_el = []     for edges in paths:         el = []         for j in range(len(edges) - 1):             temp = list(edges[j])             for e in temp:                 edge = (e[0], e[1])                 el.append(edge)         freq_sub_el.append(el)     return freq_sub_el", "output": "0"}
{"task": "search", "input": "search code:\nFinds the amount of triangular words in the words file.\n\nChoices:\n0: def generate_formula() -> Formula:     clauses: set[Clause] = set()     no_of_clauses = random.randint(1, 10)     while len(clauses) < no_of_clauses:         clauses.add(generate_clause())     return Formula(clauses)\n1: def solution():     script_dir = os.path.dirname(os.path.realpath(__file__))     words_file_path = os.path.join(script_dir, \"words.txt\")      words = \"\"     with open(words_file_path) as f:         words = f.readline()      words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]     words = [         word         for word in [sum(ord(x) - 64 for x in word) for word in words]         if word in TRIANGULAR_NUMBERS     ]     return len(words)\n2: def construct_format_field_str(fname, fspec, conv):     if fname is None:         return ''     ret = '{' + fname     if conv:         ret += '!' + conv     if fspec:         ret += ':' + fspec     ret += '}'     return ret", "output": "1"}
{"task": "search", "input": "search code:\nRemove a word from the given position.\n\nChoices:\n0: def count_inversions_recursive(arr):     if len(arr) <= 1:         return arr, 0     mid = len(arr) // 2     p = arr[0:mid]     q = arr[mid:]      a, inversion_p = count_inversions_recursive(p)     b, inversions_q = count_inversions_recursive(q)     c, cross_inversions = _count_cross_inversions(a, b)      num_inversions = inversion_p + inversions_q + cross_inversions     return c, num_inversions\n1: def procentual_proximity(     source_data: list[list[float]], weights: list[int] ) -> list[list[float]]:      data_lists = get_data(source_data)     score_lists = calculate_each_score(data_lists, weights)     final_scores = generate_final_scores(score_lists)      # append scores to source data     for i, ele in enumerate(final_scores):         source_data[i].append(ele)      return source_data\n2: def remove_word(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> None:     for i in range(len(word)):         if vertical:             puzzle[row + i][col] = \"\"         else:             puzzle[row][col + i] = \"\"", "output": "2"}
{"task": "search", "input": "search code:\nReturn a normalized list of values.\n\nChoices:\n0: def normalization(data: list, ndigits: int = 3) -> list:     # variables for calculation     x_min = min(data)     x_max = max(data)     # normalize data     return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]\n1: def solution(n: int = 1000) -> int:     return fibonacci_digits_index(n)\n2: def solution(limit=28123):     sum_divs = [1] * (limit + 1)      for i in range(2, int(limit**0.5) + 1):         sum_divs[i * i] += i         for k in range(i + 1, limit // i + 1):             sum_divs[k * i] += k + i      abundants = set()     res = 0      for n in range(1, limit + 1):         if sum_divs[n] > n:             abundants.add(n)          if not any((n - a in abundants) for a in abundants):             res += n      return res", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef compute_pairwise_affinities(data_matrix: ndarray, sigma: float = 1.0) -> ndarray:\n    n_samples = data_matrix.shape[0]\n    squared_sum = np.sum(np.square(data_matrix), axis=1)\n    squared_distance = np.add(\n        np.add(-2 * np.dot(data_matrix, data_matrix.T), squared_sum).T, squared_sum\n    )\n\n    affinity_matrix = np.exp(-squared_distance / (2 * sigma**2))\n    np.fill_diagonal(affinity_matrix, 0)\n\n    affinity_matrix /= np.sum(affinity_matrix)\n    return (affinity_matrix + affinity_matrix.T) / (2 * n_samples)", "output": "Compute high-dimensional affinities (P matrix) using a Gaussian kernel."}
{"task": "summary", "input": "summarize code:\ndef combination_sum_iv_dp_array(array: list[int], target: int) -> int:\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)", "output": "Function checks the all possible combinations, and returns the count"}
{"task": "summary", "input": "summarize code:\ndef digit_factorial_sum(number: int) -> int:\n    if not isinstance(number, int):\n        raise TypeError(\"Parameter number must be int\")\n\n    if number < 0:\n        raise ValueError(\"Parameter number must be greater than or equal to 0\")\n\n    # Converts number in string to iterate on its digits and adds its factorial.\n    return sum(DIGIT_FACTORIAL[digit] for digit in str(number))", "output": "Function to perform the sum of the factorial of all the digits in number"}
{"task": "search", "input": "search code:\nYield lists of items from *iterable*, where each list ends with an\n\nChoices:\n0: def binomial_distribution(successes: int, trials: int, prob: float) -> float:     if successes > trials:     if trials < 0 or successes < 0:         raise ValueError(\"the function is defined for non-negative integers\")     if not isinstance(successes, int) or not isinstance(trials, int):         raise ValueError(\"the function is defined for non-negative integers\")     if not 0 < prob < 1:         raise ValueError(\"prob has to be in range of 1 - 0\")     probability = (prob**successes) * ((1 - prob) ** (trials - successes))     # Calculate the binomial coefficient: n! / k!(n-k)!     coefficient = float(factorial(trials))     coefficient /= factorial(successes) * factorial(trials - successes)     return probability * coefficient\n1: def hypercube_points(     num_points: int, hypercube_size: float, num_dimensions: int ) -> np.ndarray:     rng = np.random.default_rng()     shape = (num_points, num_dimensions)     return hypercube_size * rng.random(shape)\n2: def split_after(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         buf.append(item)         if pred(item) and buf:             yield buf             if maxsplit == 1:                 buf = list(it)                 if buf:                     yield buf                 return             buf = []             maxsplit -= 1     if buf:         yield buf", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef xnor_gate(input_1: int, input_2: int) -> int:\n    return 1 if input_1 == input_2 else 0", "output": "Calculate XOR of the input values"}
{"task": "search", "input": "search code:\nGet the bit at the given position\n\nChoices:\n0: def get_bit(number: int, position: int) -> int:     return int((number & (1 << position)) != 0)\n1: def intersection(function: Callable[[float], float], x0: float, x1: float) -> float:     x_n: float = x0     x_n1: float = x1     while True:         if x_n == x_n1 or function(x_n1) == function(x_n):             raise ZeroDivisionError(\"float division by zero, could not find root\")         x_n2: float = x_n1 - (             function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))         )         if abs(x_n2 - x_n1) < 10**-5:             return x_n2         x_n = x_n1         x_n1 = x_n2\n2: def freq_to_mel(freq: float) -> float:     # Use the formula to convert frequency to the mel scale     return 2595.0 * np.log10(1.0 + freq / 700.0)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef swap(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef is_prime(number: int) -> bool:\n\n    return all(number % divisor != 0 for divisor in range(2, isqrt(number) + 1))", "output": "Determines whether number is prime"}
{"task": "detection", "input": "classify code:\ndef format_ruleset(ruleset: int) -> list[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nComputes the largest eigenvalues and their corresponding eigenvectors using the\n\nChoices:\n0: def integer_square_root(num: int) -> int:     if not isinstance(num, int) or num < 0:         raise ValueError(\"num must be non-negative integer\")      if num < 2:         return num      left_bound = 0     right_bound = num // 2      while left_bound <= right_bound:         mid = left_bound + (right_bound - left_bound) // 2         mid_squared = mid * mid         if mid_squared == num:             return mid          if mid_squared < num:             left_bound = mid + 1         else:             right_bound = mid - 1      return right_bound\n1: def find_lanczos_eigenvectors(     graph: list[list[int | None]], num_eigenvectors: int ) -> tuple[np.ndarray, np.ndarray]:     validate_adjacency_list(graph)     tridiagonal_matrix, orthonormal_basis = lanczos_iteration(graph, num_eigenvectors)     eigenvalues, eigenvectors = np.linalg.eigh(tridiagonal_matrix)     return eigenvalues[::-1], np.dot(orthonormal_basis, eigenvectors[:, ::-1])\n2: def netstring_server(server_socket):     \"A basic netstring server loop, supporting a few operations\"     try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock)             while 1:                 request = client.read_ns()                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'reply4k':                     client.write_ns(b'a' * 4096)                 elif request == b'ping':                     client.write_ns(b'pong')                 elif request == b'reply128k':                     client.setmaxsize(128 * 1024)                     client.write_ns(b'huge' * 32 * 1024)  # 128kb                     client.setmaxsize(32768)  # back to default     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise", "output": "1"}
{"task": "detection", "input": "classify code:\ndef tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2", "output": "def find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2", "tests": ["assert find_median(nums=([1, 2, 2, 3, 4])) == 2", "assert find_median(nums=([1, 2, 2, 3, 4, 4])) == 2.5", "assert find_median(nums=([-1, 2, 0, 3, 4, -4])) == 1.5", "assert find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4])) == 2.65"]}
{"task": "detection", "input": "classify code:\ndef get_data(source_data: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])\n    [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]\n    \"\"\"\n    data_lists: list[list[float]] = []\n    for data in source_data:\n        for i, el in enumerate(data):\n            if len(data_lists) < i + 1:\n                data_lists.append([])\n            data_lists[i].append(float(el))\n    return data_lists", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn the direction toward to the line from via to target from starting\n\nChoices:\n0: def solution(n: int = 2) -> int:     result = 1.0     for fraction in fraction_list(n):         frac = Fraction(fraction)         result *= frac.denominator / frac.numerator     return int(result)\n1: def dotproduct(vec1, vec2):     return sum(map(mul, vec1, vec2))\n2: def check_direction(     starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int] ) -> Direction:     x0, y0 = starting     x1, y1 = via     x2, y2 = target     via_angle = degrees(atan2(y1 - y0, x1 - x0))     via_angle %= 360     target_angle = degrees(atan2(y2 - y0, x2 - x0))     target_angle %= 360     # t-     #  \\ \\     #   \\ v     #    \\|     #     s     # via_angle is always lower than target_angle, if direction is left.     # If they are same, it means they are on a same line of convex hull.     if target_angle > via_angle:         return Direction.left     elif target_angle == via_angle:         return Direction.straight     else:         return Direction.right", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef adjacent(predicate, iterable, distance=1):\n    # Allow distance=0 mainly for testing that it reproduces results with map()\n    if distance < 0:\n        raise ValueError('distance must be at least 0')\n\n    i1, i2 = tee(iterable)\n    padding = [False] * distance\n    selected = chain(padding, map(predicate, i1), padding)\n    adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))\n    return zip(adjacent_to_selected, i2)", "output": "Return an iterable over `(bool, item)` tuples where the `item` is"}
{"task": "summary", "input": "summarize code:\ndef weight_matrix(point: np.ndarray, x_train: np.ndarray, tau: float) -> np.ndarray:\n    m = len(x_train)  # Number of training samples\n    weights = np.eye(m)  # Initialize weights as identity matrix\n    for j in range(m):\n        diff = point - x_train[j]\n        weights[j, j] = np.exp(diff @ diff.T / (-2.0 * tau**2))\n\n    return weights", "output": "Calculate the weight of every point in the training data around a given"}
{"task": "search", "input": "search code:\nFinds all Harshad numbers smaller than num in base 'base'.\n\nChoices:\n0: def sigmoid_derivative(value: np.ndarray) -> np.ndarray:     return (value) * (1 - (value))\n1: def format_exception_only(etype, value):     # Gracefully handle (the way Python 2.4 and earlier did) the case of     # being called with (None, None).     if etype is None:         return [_format_final_exc_line(etype, value)]      stype = etype.__name__     smod = etype.__module__     if smod not in (\"__main__\", \"builtins\", \"exceptions\"):         stype = smod + '.' + stype      if not issubclass(etype, SyntaxError):         return [_format_final_exc_line(stype, value)]      # It was a syntax error; show exactly where the problem was found.     lines = []     filename = value.filename or \"<string>\"     lineno = str(value.lineno) or '?'     lines.append(f'  File \"{filename}\", line {lineno}\\n')     badline = value.text     offset = value.offset     if badline is not None:         lines.append('    %s\\n' % badline.strip())         if offset is not None:             caretspace = badline.rstrip('\\n')[:offset].lstrip()             # non-space whitespace (likes tabs) must be kept for alignment             caretspace = ((c.isspace() and c or ' ') for c in caretspace)             # only three spaces to account for offset1 == pos 0             lines.append('   %s^\\n' % ''.join(caretspace))     msg = value.msg or \"<no detail available>\"     lines.append(f\"{stype}: {msg}\\n\")     return lines\n2: def harshad_numbers_in_base(limit: int, base: int) -> list[str]:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      if limit < 0:         return []      numbers = [         int_to_base(i, base)         for i in range(1, limit)         if i % int(sum_of_digits(i, base), base) == 0     ]      return numbers", "output": "2"}
{"task": "search", "input": "search code:\nReturns\n\nChoices:\n0: def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:      try:         # Has user provided both inputs?         if not drug_name or not zip_code:             return None          request_url = BASE_URL.format(drug_name, zip_code)         response = httpx.get(request_url, timeout=10).raise_for_status()          # Scrape the data using bs4         soup = BeautifulSoup(response.text, \"html.parser\")          # This list will store the name and price.         pharmacy_price_list = []          # Fetch all the grids that contain the items.         grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})         if grid_list and len(grid_list) > 0:             for grid in grid_list:                 # Get the pharmacy price.                 pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text                  # Get the price of the drug.                 price = grid.find(\"span\", {\"p\", \"price price-large\"}).text                  pharmacy_price_list.append(                     {                         \"pharmacy_name\": pharmacy_name,                         \"price\": price,                     }                 )          return pharmacy_price_list      except (httpx.HTTPError, ValueError):         return None\n1: def solution():     constant = []     i = 1      while len(constant) < 1e6:         constant.append(str(i))         i += 1      constant = \"\".join(constant)      return (         int(constant[0])         * int(constant[9])         * int(constant[99])         * int(constant[999])         * int(constant[9999])         * int(constant[99999])         * int(constant[999999])     )\n2: def main() -> None:     print(\"\\n2 in octal is:\")     print(decimal_to_octal(2))  # = 2     print(\"\\n8 in octal is:\")     print(decimal_to_octal(8))  # = 10     print(\"\\n65 in octal is:\")     print(decimal_to_octal(65))  # = 101     print(\"\\n216 in octal is:\")     print(decimal_to_octal(216))  # = 330     print(\"\\n512 in octal is:\")     print(decimal_to_octal(512))  # = 1000     print(\"\\n\")", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef decode(coded: str) -> str:\n    if set(coded) - {\"A\", \"B\", \" \"} != set():\n        raise Exception(\"decode() accepts only 'A', 'B' and spaces\")\n    decoded = \"\"\n    for word in coded.split():\n        while len(word) != 0:\n            decoded += decode_dict[word[:5]]\n            word = word[5:]\n        decoded += \" \"\n    return decoded.strip()", "output": "Decodes from Baconian cipher"}
{"task": "summary", "input": "summarize code:\ndef find_min_recursive(nums: list[int | float], left: int, right: int) -> int | float:\n    if len(nums) == 0:\n        raise ValueError(\"find_min_recursive() arg is an empty sequence\")\n    if (\n        left >= len(nums)\n        or left < -len(nums)\n        or right >= len(nums)\n        or right < -len(nums)\n    ):\n        raise IndexError(\"list index out of range\")\n    if left == right:\n        return nums[left]\n    mid = (left + right) >> 1  # the middle\n    left_min = find_min_recursive(nums, left, mid)  # find min in range[left, mid]\n    right_min = find_min_recursive(\n        nums, mid + 1, right\n    )  # find min in range[mid + 1, right]\n\n    return left_min if left_min <= right_min else right_min", "output": "find min value in list"}
{"task": "search", "input": "search code:\nGiven an encrypted message and a possible 3-character key, decrypt the message.\n\nChoices:\n0: def pancake_sort(arr):     cur = len(arr)     while cur > 1:         # Find the maximum number in arr         mi = arr.index(max(arr[0:cur]))         # Reverse from 0 to mi         arr = arr[mi::-1] + arr[mi + 1 : len(arr)]         # Reverse whole list         arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]         cur -= 1     return arr\n1: def count_cycle(iterable, n=None):     if n is not None:         return product(range(n), iterable)     seq = tuple(iterable)     if not seq:         return iter(())     counter = count() if n is None else range(n)     return zip(repeat_each(counter, len(seq)), cycle(seq))\n2: def try_key(ciphertext: list[int], key: tuple[int, ...]) -> str | None:     decoded: str = \"\"     keychar: int     cipherchar: int     decodedchar: int      for keychar, cipherchar in zip(cycle(key), ciphertext):         decodedchar = cipherchar ^ keychar         if decodedchar not in VALID_INTS:             return None         decoded += chr(decodedchar)      return decoded", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef partition(pred, iterable):\n    if pred is None:\n        pred = bool\n\n    t1, t2, p = tee(iterable, 3)\n    p1, p2 = tee(map(pred, p))\n    return (compress(t1, map(not_, p1)), compress(t2, p2))", "output": "Returns a 2-tuple of iterables derived from the input iterable."}
{"task": "repair", "input": "fix bug:\ndef comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data", "output": "def comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data", "tests": ["assert comb_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]", "assert comb_sort([]) == []", "assert comb_sort([99, 45, -7, 8, 2, 0, -15, 3]) == [-15, -7, 0, 2, 3, 8, 45, 99]"]}
{"task": "search", "input": "search code:\nPure implementation of shell sort algorithm in Python\n\nChoices:\n0: def shell_sort(collection: list[int]) -> list[int]:     # Marcin Ciura's gap sequence      gaps = [701, 301, 132, 57, 23, 10, 4, 1]     for gap in gaps:         for i in range(gap, len(collection)):             insert_value = collection[i]             j = i             while j >= gap and collection[j - gap] > insert_value:                 collection[j] = collection[j - gap]                 j -= gap             if j != i:                 collection[j] = insert_value     return collection\n1: def sentence_to_title_case(input_str: str) -> str:      return \" \".join(to_title_case(word) for word in input_str.split())\n2: def count_inversions_bf(arr):      num_inversions = 0     n = len(arr)      for i in range(n - 1):         for j in range(i + 1, n):             if arr[i] > arr[j]:                 num_inversions += 1      return num_inversions", "output": "0"}
{"task": "search", "input": "search code:\nWrapper function to call subroutine called util_hamilton_cycle,\n\nChoices:\n0: def hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:      # Initialize path with -1, indicating that we have not visited them yet     path = [-1] * (len(graph) + 1)     # initialize start and end of path with starting index     path[0] = path[-1] = start_index     # evaluate and if we find answer return path either return empty array     return path if util_hamilton_cycle(graph, path, 1) else []\n1: def unquote(string, encoding='utf-8', errors='replace'):     if '%' not in string:         string.split         return string     if encoding is None:         encoding = 'utf-8'     if errors is None:         errors = 'replace'     bits = _ASCII_RE.split(string)     res = [bits[0]]     append = res.append     for i in range(1, len(bits), 2):         append(unquote_to_bytes(bits[i]).decode(encoding, errors))         append(bits[i + 1])     return ''.join(res)\n2: def convert_to_2d(     x: float, y: float, z: float, scale: float, distance: float ) -> tuple[float, float]:     if not all(isinstance(val, (float, int)) for val in locals().values()):         msg = f\"Input values must either be float or int: {list(locals().values())}\"         raise TypeError(msg)     projected_x = ((x * distance) / (z + distance)) * scale     projected_y = ((y * distance) / (z + distance)) * scale     return projected_x, projected_y", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 1000000) -> int:\n    limit = limit + 1\n    frequency = [0] * limit\n    for first_term in range(1, limit):\n        for n in range(first_term, limit, first_term):\n            common_difference = first_term + n / first_term\n            if common_difference % 4:  # d must be divisible by 4\n                continue\n            else:\n                common_difference /= 4\n                if (\n                    first_term > common_difference\n                    and first_term < 4 * common_difference\n                ):  # since x, y, z are positive integers\n                    frequency[n] += 1  # so z > 0, a > d and 4d < a\n\n    count = sum(1 for x in frequency[1:limit] if x == 10)\n\n    return count", "output": "returns the values of n less than or equal to the limit"}
{"task": "search", "input": "search code:\nConvert grid into a dict of {square: char} with '0' or '.' for empties.\n\nChoices:\n0: def interpolation_search(sorted_collection: list[int], item: int) -> int | None:     left = 0     right = len(sorted_collection) - 1      while left <= right:         # avoid divided by 0 during interpolation         if sorted_collection[left] == sorted_collection[right]:             if sorted_collection[left] == item:                 return left             return None          point = left + ((item - sorted_collection[left]) * (right - left)) // (             sorted_collection[right] - sorted_collection[left]         )          # out of range check         if point < 0 or point >= len(sorted_collection):             return None          current_item = sorted_collection[point]         if current_item == item:             return point         if point < left:             right = left             left = point         elif point > right:             left = right             right = point         elif item < current_item:             right = point - 1         else:             left = point + 1     return None\n1: def grid_values(grid):     chars = [c for c in grid if c in digits or c in \"0.\"]     assert len(chars) == 81     return dict(zip(squares, chars))\n2: def random_graph(     vertices_number: int, probability: float, directed: bool = False ) -> dict:     graph: dict = {i: [] for i in range(vertices_number)}      # if probability is greater or equal than 1, then generate a complete graph     if probability >= 1:         return complete_graph(vertices_number)     # if probability is lower or equal than 0, then return a graph without edges     if probability <= 0:         return graph      # for each couple of nodes, add an edge from u to v     # if the number randomly generated is greater than probability probability     for i in range(vertices_number):         for j in range(i + 1, vertices_number):             if random.random() < probability:                 graph[i].append(j)                 if not directed:                     # if the graph is undirected, add an edge in from j to i, either                     graph[j].append(i)     return graph", "output": "1"}
{"task": "search", "input": "search code:\nreturns a random matrix WxH with integer components\n\nChoices:\n0: def random_matrix(width: int, height: int, a: int, b: int) -> Matrix:     random.seed(None)     matrix: list[list[float]] = [         [random.randint(a, b) for _ in range(width)] for _ in range(height)     ]     return Matrix(matrix, width, height)\n1: def msd_radix_sort(list_of_ints: list[int]) -> list[int]:     if not list_of_ints:         return []      if min(list_of_ints) < 0:         raise ValueError(\"All numbers must be positive\")      most_bits = max(len(bin(x)[2:]) for x in list_of_ints)     return _msd_radix_sort(list_of_ints, most_bits)\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef generate_neighbours(path):\n\n    dict_of_neighbours = {}\n\n    with open(path) as f:\n        for line in f:\n            if line.split()[0] not in dict_of_neighbours:\n                _list = []\n                _list.append([line.split()[1], line.split()[2]])\n                dict_of_neighbours[line.split()[0]] = _list\n            else:\n                dict_of_neighbours[line.split()[0]].append(\n                    [line.split()[1], line.split()[2]]\n                )\n            if line.split()[1] not in dict_of_neighbours:\n                _list = []\n                _list.append([line.split()[0], line.split()[2]])\n                dict_of_neighbours[line.split()[1]] = _list\n            else:\n                dict_of_neighbours[line.split()[1]].append(\n                    [line.split()[0], line.split()[2]]\n                )\n\n    return dict_of_neighbours", "output": "Pure implementation of generating a dictionary of neighbors and the cost with each"}
{"task": "summary", "input": "summarize code:\ndef ugly_numbers(n: int) -> int:\n    ugly_nums = [1]\n\n    i2, i3, i5 = 0, 0, 0\n    next_2 = ugly_nums[i2] * 2\n    next_3 = ugly_nums[i3] * 3\n    next_5 = ugly_nums[i5] * 5\n\n    for _ in range(1, n):\n        next_num = min(next_2, next_3, next_5)\n        ugly_nums.append(next_num)\n        if next_num == next_2:\n            i2 += 1\n            next_2 = ugly_nums[i2] * 2\n        if next_num == next_3:\n            i3 += 1\n            next_3 = ugly_nums[i3] * 3\n        if next_num == next_5:\n            i5 += 1\n            next_5 = ugly_nums[i5] * 5\n    return ugly_nums[-1]", "output": "Returns the nth ugly number."}
{"task": "search", "input": "search code:\nImplements the Soboleva Modified Hyperbolic Tangent function\n\nChoices:\n0: def solution(n: int = 10000) -> int:     count_odd_periods = 0     for i in range(2, n + 1):         sr = sqrt(i)         if sr - floor(sr) != 0 and continuous_fraction_period(i) % 2 == 1:             count_odd_periods += 1     return count_odd_periods\n1: def soboleva_modified_hyperbolic_tangent(     vector: np.ndarray, a_value: float, b_value: float, c_value: float, d_value: float ) -> np.ndarray:      # Separate the numerator and denominator for simplicity     # Calculate the numerator and denominator element-wise     numerator = np.exp(a_value * vector) - np.exp(-b_value * vector)     denominator = np.exp(c_value * vector) + np.exp(-d_value * vector)      # Calculate and return the final result element-wise     return numerator / denominator\n2: def binary_tree_bottom_side_view(root: TreeNode) -> list[int]:     from collections import defaultdict      def breadth_first_search(root: TreeNode, bottom_view: list[int]) -> None:         queue = [(root, 0)]         lookup = defaultdict(list)          while queue:             first = queue.pop(0)             node, hd = first             lookup[hd].append(node.val)              if node.left:                 queue.append((node.left, hd - 1))             if node.right:                 queue.append((node.right, hd + 1))          for pair in sorted(lookup.items(), key=lambda each: each[0]):             bottom_view.append(pair[1][-1])      bottom_view: list = []     if not root:         return bottom_view      breadth_first_search(root, bottom_view)     return bottom_view", "output": "1"}
{"task": "search", "input": "search code:\nDraw a cross at the specified position and with the specified length.\n\nChoices:\n0: def euclidean(input_a: np.ndarray, input_b: np.ndarray) -> float:     return math.sqrt(sum(pow(a - b, 2) for a, b in zip(input_a, input_b)))\n1: def draw_cross(x: float, y: float, length: float):     turtle.up()     turtle.goto(x - length / 2, y - length / 6)     turtle.down()     turtle.seth(0)     turtle.begin_fill()     for _ in range(4):         turtle.fd(length / 3)         turtle.right(90)         turtle.fd(length / 3)         turtle.left(90)         turtle.fd(length / 3)         turtle.left(90)     turtle.end_fill()\n2: def map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):      ret = defaultdict(list)      if valuefunc is None:         for item in iterable:             key = keyfunc(item)             ret[key].append(item)      else:         for item in iterable:             key = keyfunc(item)             value = valuefunc(item)             ret[key].append(value)      if reducefunc is not None:         for key, value_list in ret.items():             ret[key] = reducefunc(value_list)      ret.default_factory = None     return ret", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef benchmark() -> None:\n    from timeit import timeit\n\n    print(\"Running performance benchmarks...\")\n    setup = \"from string import printable ; from __main__ import atbash, atbash_slow\"\n    print(f\"> atbash_slow(): {timeit('atbash_slow(printable)', setup=setup)} seconds\")\n    print(f\">      atbash(): {timeit('atbash(printable)', setup=setup)} seconds\")", "output": "Let's benchmark our functions side-by-side..."}
{"task": "summary", "input": "summarize code:\ndef replace(iterable, pred, substitutes, count=None, window_size=1):\n    if window_size < 1:\n        raise ValueError('window_size must be at least 1')\n\n    # Save the substitutes iterable, since it's used more than once\n    substitutes = tuple(substitutes)\n\n    # Add padding such that the number of windows matches the length of the\n    # iterable\n    it = chain(iterable, repeat(_marker, window_size - 1))\n    windows = windowed(it, window_size)\n\n    n = 0\n    for w in windows:\n        # If the current window matches our predicate (and we haven't hit\n        # our maximum number of replacements), splice in the substitutes\n        # and then consume the following windows that overlap with this one.\n        # For example, if the iterable is (0, 1, 2, 3, 4...)\n        # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...\n        # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)\n        if pred(*w):\n            if (count is None) or (n < count):\n                n += 1\n                yield from substitutes\n                consume(windows, window_size - 1)\n                continue\n\n        # If there was no match (or we've reached the replacement limit),\n        # yield the first item from the window.\n        if w and (w[0] is not _marker):\n            yield w[0]", "output": "Yield the items from *iterable*, replacing the items for which *pred*"}
{"task": "search", "input": "search code:\nReturns the least value of n for which the remainder first exceeds 10^10.\n\nChoices:\n0: def exits_word(     board: list[list[str]],     word: str,     row: int,     column: int,     word_index: int,     visited_points_set: set[int], ) -> bool:      if board[row][column] != word[word_index]:         return False      if word_index == len(word) - 1:         return True      traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]     len_board = len(board)     len_board_column = len(board[0])     for direction in traverts_directions:         next_i = row + direction[0]         next_j = column + direction[1]         if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):             continue          key = get_point_key(len_board, len_board_column, next_i, next_j)         if key in visited_points_set:             continue          visited_points_set.add(key)         if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):             return True          visited_points_set.remove(key)      return False\n1: def solution(limit: float = 1e10) -> int:     primes = sieve()      n = 1     while True:         prime = next(primes)         if (2 * prime * n) > limit:             return n         # Ignore the next prime as the reminder will be 2.         next(primes)         n += 2\n2: def first_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )", "output": "1"}
{"task": "search", "input": "search code:\nRender an expression-style repr of an object, based on attribute\n\nChoices:\n0: def solution(min_total: int = 10**12) -> int:      prev_numerator = 1     prev_denominator = 0      numerator = 1     denominator = 1      while numerator <= 2 * min_total - 1:         prev_numerator += 2 * numerator         numerator += 2 * prev_numerator          prev_denominator += 2 * denominator         denominator += 2 * prev_denominator      return (denominator + 1) // 2\n1: def solution(base: int = 1777, height: int = 1855, digits: int = 8) -> int:      # calculate baseheight by right-assiciative repeated modular     # exponentiation     result = base     for _ in range(1, height):         result = _modexpt(base, result, 10**digits)      return result\n2: def format_exp_repr(obj, pos_names, req_names=None, opt_names=None, opt_key=None):     cn = type(obj).__name__     req_names = req_names or []     opt_names = opt_names or []     uniq_names, all_names = set(), []     for name in req_names + opt_names:         if name in uniq_names:             continue         uniq_names.add(name)         all_names.append(name)      if opt_key is None:         opt_key = lambda v: v is None     assert callable(opt_key)      args = [getattr(obj, name, None) for name in pos_names]      kw_items = [(name, getattr(obj, name, None)) for name in all_names]     kw_items = [(name, val) for name, val in kw_items                 if not (name in opt_names and opt_key(val))]      return format_invocation(cn, args, kw_items)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef str_eval(s: str) -> int:\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product", "output": "Returns product of digits in given string n"}
{"task": "search", "input": "search code:\nBenchmark code for comparing 2 functions, with different length int values.\n\nChoices:\n0: def combination_sum_iv_dp_array(array: list[int], target: int) -> int:      def count_of_possible_combinations_with_dp_array(         target: int, dp_array: list[int]     ) -> int:         if target < 0:             return 0         if target == 0:             return 1         if dp_array[target] != -1:             return dp_array[target]         answer = sum(             count_of_possible_combinations_with_dp_array(target - item, dp_array)             for item in array         )         dp_array[target] = answer         return answer      dp_array = [-1] * (target + 1)     return count_of_possible_combinations_with_dp_array(target, dp_array)\n1: def benchmark() -> None:      def do_benchmark(number: int) -> None:         setup = \"import __main__ as z\"         print(f\"Benchmark when {number = }:\")         print(f\"{get_set_bits_count_using_modulo_operator(number) = }\")         timing = timeit(             f\"z.get_set_bits_count_using_modulo_operator({number})\", setup=setup         )         print(f\"timeit() runs in {timing} seconds\")         print(f\"{get_set_bits_count_using_brian_kernighans_algorithm(number) = }\")         timing = timeit(             f\"z.get_set_bits_count_using_brian_kernighans_algorithm({number})\",             setup=setup,         )         print(f\"timeit() runs in {timing} seconds\")      for number in (25, 37, 58, 0):         do_benchmark(number)         print()\n2: def dir_dict(obj, raise_exc=False):     # TODO: separate function for handling descriptors on types?     ret = {}     for k in dir(obj):         try:             ret[k] = getattr(obj, k)         except Exception:             if raise_exc:                 raise     return ret", "output": "1"}
{"task": "search", "input": "search code:\nSort edges on the basis of distance\n\nChoices:\n0: def get_significant_digits(colors: list) -> str:     digit = \"\"     for color in colors:         if color not in significant_figures_color_values:             msg = f\"{color} is not a valid color for significant figure bands\"             raise ValueError(msg)         digit = digit + str(significant_figures_color_values[color])     return str(digit)\n1: def krusk(e_and_n):     (e, n) = e_and_n     e.sort(reverse=True, key=lambda x: x[2])     s = [{i} for i in range(1, n + 1)]     while True:         if len(s) == 1:             break         print(s)         x = e.pop()         for i in range(len(s)):             if x[0] in s[i]:                 break         for j in range(len(s)):             if x[1] in s[j]:                 if i == j:                     break                 s[j].update(s[i])                 s.pop(i)                 break\n2: def is_safe_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return (number - 1) % 2 == 0 and is_prime(number) and is_prime((number - 1) // 2)", "output": "1"}
{"task": "search", "input": "search code:\nFraction of the number whose continued fractions to be found.\n\nChoices:\n0: def convert_path_to_module(file_path: pathlib.Path) -> ModuleType:     spec = importlib.util.spec_from_file_location(file_path.name, str(file_path))     module = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]     spec.loader.exec_module(module)  # type: ignore[union-attr]     return module\n1: def continued_fraction(num: Fraction) -> list[int]:     numerator, denominator = num.as_integer_ratio()     continued_fraction_list: list[int] = []     while True:         integer_part = floor(numerator / denominator)         continued_fraction_list.append(integer_part)         numerator -= integer_part * denominator         if numerator == 0:             break         numerator, denominator = denominator, numerator      return continued_fraction_list\n2: def util_color(     graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int ) -> bool:      # Base Case     if index == len(graph):         return True      # Recursive Step     for i in range(max_colors):         if valid_coloring(graph[index], colored_vertices, i):             # Color current vertex             colored_vertices[index] = i             # Validate coloring             if util_color(graph, max_colors, colored_vertices, index + 1):                 return True             # Backtrack             colored_vertices[index] = -1     return False", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef always_iterable(obj, base_type=(str, bytes)):\n    if obj is None:\n        return iter(())\n\n    if (base_type is not None) and isinstance(obj, base_type):\n        return iter((obj,))\n\n    try:\n        return iter(obj)\n    except TypeError:\n        return iter((obj,))", "output": "If *obj* is iterable, return an iterator over its items::"}
{"task": "repair", "input": "fix bug:\ndef perfect_cube(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not.\n\n    >>> perfect_cube(27)\n    True\n    >>> perfect_cube(4)\n    False\n    \"\"\"\n    val = n ** (1 / 3)\n    return (val * val * val) == n", "output": "def perfect_cube(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not.\n\n    >>> perfect_cube(27)\n    True\n    >>> perfect_cube(4)\n    False\n    \"\"\"\n    val = n ** (1 / 3)\n    return (val * val * val) == n", "tests": ["assert perfect_cube(27) == True", "assert perfect_cube(4) == False"]}
{"task": "search", "input": "search code:\nEquivalent to ``list(permutations(iterable, r)).index(element)```\n\nChoices:\n0: def permutation_index(element, iterable):     index = 0     pool = list(iterable)     for i, x in zip(range(len(pool), -1, -1), element):         r = pool.index(x)         index = index * i + r         del pool[r]      return index\n1: def create_vector(end_point1: Point3d, end_point2: Point3d) -> Vector3d:     x = end_point2[0] - end_point1[0]     y = end_point2[1] - end_point1[1]     z = end_point2[2] - end_point1[2]     return (x, y, z)\n2: def calculate_mean(instance_count: int, items: list) -> float:     # the sum of all items divided by number of instances     return sum(items) / instance_count", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef product_index(element, *args):\n    elements = tuple(element)\n    pools = tuple(map(tuple, args))\n    if len(elements) != len(pools):\n        raise ValueError('element is not a product of args')\n\n    index = 0\n    for elem, pool in zip(elements, pools):\n        index = index * len(pool) + pool.index(elem)\n    return index", "output": "Equivalent to ``list(product(*args)).index(element)``"}
{"task": "summary", "input": "summarize code:\ndef lr_rotation(node: MyNode) -> MyNode:\n    left_child = node.get_left()\n    assert left_child is not None\n    node.set_left(left_rotation(left_child))\n    return right_rotation(node)", "output": "A A Br"}
{"task": "repair", "input": "fix bug:\ndef speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20C: bulk_modulus= 2.15MPa, density=998kg/m\n    Example 2 --> Mercury 20C: bulk_modulus= 28.5MPa, density=13600kg/m\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5", "output": "def speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20C: bulk_modulus= 2.15MPa, density=998kg/m\n    Example 2 --> Mercury 20C: bulk_modulus= 28.5MPa, density=13600kg/m\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5", "tests": ["assert speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998) == 1467.7563207952705", "assert speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600) == 1447.614670861731"]}
{"task": "repair", "input": "fix bug:\ndef remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Reomove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split(\" \"))))", "output": "def remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Remove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    >>> remove_duplicates(\"Python   is      great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split())))", "tests": ["assert remove_duplicates(\"Python is great and Java is also great\") == 'Java Python also and great is'", "assert remove_duplicates(\"Python   is      great and Java is also great\") == 'Java Python also and great is'"]}
{"task": "summary", "input": "summarize code:\ndef combination_lists(n: int, k: int) -> list[list[int]]:\n    return [list(x) for x in combinations(range(1, n + 1), k)]", "output": "Generates all possible combinations of k numbers out of 1 ... n using itertools."}
{"task": "search", "input": "search code:\nCalculate (a * b) % c using binary multiplication and modular arithmetic.\n\nChoices:\n0: def binary_mod_multiply(a: int, b: int, modulus: int) -> int:     res = 0     while b > 0:         if b & 1:             res = ((res % modulus) + (a % modulus)) % modulus          a += a         b >>= 1      return res\n1: def partition(arr: list[int], low: int, high: int) -> int:     pivot = arr[high]     i = low - 1     for j in range(low, high):         if arr[j] >= pivot:             i += 1             arr[i], arr[j] = arr[j], arr[i]     arr[i + 1], arr[high] = arr[high], arr[i + 1]     return i + 1\n2: def last(iterable, default=_marker):     try:         if isinstance(iterable, Sequence):             return iterable[-1]         # Work around https://bugs.python.org/issue38525         if getattr(iterable, '__reversed__', None):             return next(reversed(iterable))         return deque(iterable, maxlen=1)[-1]     except (IndexError, TypeError, StopIteration):         if default is _marker:             raise ValueError(                 'last() was called on an empty iterable, '                 'and no default value was provided.'             )         return default", "output": "0"}
{"task": "search", "input": "search code:\nReturns a so called 'wave' of a given string\n\nChoices:\n0: def nimply_gate(input_1: int, input_2: int) -> int:     return int(input_1 == 1 and input_2 == 0)\n1: def wave(txt: str) -> list:      return [         txt[:a] + txt[a].upper() + txt[a + 1 :]         for a in range(len(txt))         if txt[a].isalpha()     ]\n2: def slow_solution(max_power: int = 9) -> int:     result = 0     for length in range(1, max_power + 1):         result += slow_reversible_numbers(length, 0, [0] * length, length)     return result", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef compress(source_path: str, destination_path: str) -> None:\n    data_bits = read_file_binary(source_path)\n    compressed = compress_data(data_bits)\n    compressed = add_file_length(source_path, compressed)\n    write_file_binary(destination_path, compressed)", "output": "Reads source file, compresses it and writes the compressed result in destination"}
{"task": "summary", "input": "summarize code:\ndef main():\n    num = int(input(\"Enter an integer to see if it is an Armstrong number: \").strip())\n    print(f\"{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number.\")\n    print(f\"{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number.\")\n    print(f\"{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number.\")", "output": "Request that user input an integer and tell them if it is Armstrong number."}
{"task": "summary", "input": "summarize code:\ndef softmax(vector):\n\n    # Calculate e^x for each x in your vector where e is Euler's\n    # number (approximately 2.718)\n    exponent_vector = np.exp(vector)\n\n    # Add up the all the exponentials\n    sum_of_exponents = np.sum(exponent_vector)\n\n    # Divide every exponent by the sum of all exponents\n    softmax_vector = exponent_vector / sum_of_exponents\n\n    return softmax_vector", "output": "Implements the softmax function"}
{"task": "search", "input": "search code:\nReturns the number of different ways to make X pence using any number of coins.\n\nChoices:\n0: def encrypt(plaintext: str, key: str) -> str:     if not isinstance(plaintext, str):         raise TypeError(\"plaintext must be a string\")     if not isinstance(key, str):         raise TypeError(\"key must be a string\")      if not plaintext:         raise ValueError(\"plaintext is empty\")     if not key:         raise ValueError(\"key is empty\")      key += plaintext     plaintext = plaintext.lower()     key = key.lower()     plaintext_iterator = 0     key_iterator = 0     ciphertext = \"\"     while plaintext_iterator < len(plaintext):         if (             ord(plaintext[plaintext_iterator]) < 97             or ord(plaintext[plaintext_iterator]) > 122         ):             ciphertext += plaintext[plaintext_iterator]             plaintext_iterator += 1         elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:             key_iterator += 1         else:             ciphertext += chr(                 (                     (ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))                     - 97                 )                 % 26                 + 97             )             key_iterator += 1             plaintext_iterator += 1     return ciphertext\n1: def softplus(vector: np.ndarray) -> np.ndarray:     return np.log(1 + np.exp(vector))\n2: def solution(pence: int = 200) -> int:     coins = [1, 2, 5, 10, 20, 50, 100, 200]     number_of_ways = [0] * (pence + 1)     number_of_ways[0] = 1  # base case: 1 way to make 0 pence      for coin in coins:         for i in range(coin, pence + 1, 1):             number_of_ways[i] += number_of_ways[i - coin]     return number_of_ways[pence]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef transform(\n    image: np.ndarray, kind: str, kernel: np.ndarray | None = None\n) -> np.ndarray:\n    if kernel is None:\n        kernel = np.ones((3, 3))\n\n    if kind == \"erosion\":\n        constant = 1\n        apply = np.max\n    else:\n        constant = 0\n        apply = np.min\n\n    center_x, center_y = (x // 2 for x in kernel.shape)\n\n    # Use padded image when applying convolution\n    # to not go out of bounds of the original the image\n    transformed = np.zeros(image.shape, dtype=np.uint8)\n    padded = np.pad(image, 1, \"constant\", constant_values=constant)\n\n    for x in range(center_x, padded.shape[0] - center_x):\n        for y in range(center_y, padded.shape[1] - center_y):\n            center = padded[\n                x - center_x : x + center_x + 1, y - center_y : y + center_y + 1\n            ]\n            # Apply transformation method to the centered section of the image\n            transformed[x - center_x, y - center_y] = apply(center[kernel == 1])\n\n    return transformed", "output": "Simple image transformation using one of two available filter functions:"}
{"task": "detection", "input": "classify code:\ndef perfect_cube(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not.\n\n    >>> perfect_cube(27)\n    True\n    >>> perfect_cube(4)\n    False\n    \"\"\"\n    val = n ** (1 / 3)\n    return (val * val * val) == n", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef get_squarefrees(unique_coefficients: set[int]) -> set[int]:\n    \"\"\"\n    Calculates the squarefree numbers inside unique_coefficients.\n\n    Based on the definition of a non-squarefree number, then any non-squarefree\n    n can be decomposed as n = p*p*r, where p is positive prime number and r\n    is a positive integer.\n\n    Under the previous formula, any coefficient that is lower than p*p is\n    squarefree as r cannot be negative. On the contrary, if any r exists such\n    that n = p*p*r, then the number is non-squarefree.\n\n    >>> get_squarefrees({1})\n    {1}\n    >>> get_squarefrees({1, 2})\n    {1, 2}\n    >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})\n    {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}\n    \"\"\"\n\n    non_squarefrees = set()\n    for number in unique_coefficients:\n        divisor = 2\n        copy_number = number\n        while divisor**2 <= copy_number:\n            multiplicity = 0\n            while copy_number % divisor == 0:\n                copy_number //= divisor\n                multiplicity += 1\n            if multiplicity >= 2:\n                non_squarefrees.add(number)\n                break\n            divisor += 1\n\n    return unique_coefficients.difference(non_squarefrees)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn True if n is a narcissistic number or False if it is not.\n\nChoices:\n0: def surface_area_conical_frustum(     radius_1: float, radius_2: float, height: float ) -> float:     if radius_1 < 0 or radius_2 < 0 or height < 0:         raise ValueError(             \"surface_area_conical_frustum() only accepts non-negative values\"         )     slant_height = (height**2 + (radius_1 - radius_2) ** 2) ** 0.5     return pi * ((slant_height * (radius_1 + radius_2)) + radius_1**2 + radius_2**2)\n1: def merge(left_half: list, right_half: list) -> list:     sorted_array = [None] * (len(right_half) + len(left_half))      pointer1 = 0  # pointer to current index for left Half     pointer2 = 0  # pointer to current index for the right Half     index = 0  # pointer to current index for the sorted array Half      while pointer1 < len(left_half) and pointer2 < len(right_half):         if left_half[pointer1] < right_half[pointer2]:             sorted_array[index] = left_half[pointer1]             pointer1 += 1             index += 1         else:             sorted_array[index] = right_half[pointer2]             pointer2 += 1             index += 1     while pointer1 < len(left_half):         sorted_array[index] = left_half[pointer1]         pointer1 += 1         index += 1      while pointer2 < len(right_half):         sorted_array[index] = right_half[pointer2]         pointer2 += 1         index += 1      return sorted_array\n2: def narcissistic_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False     expo = len(str(n))  # the power that all digits will be raised to     # check if sum of each digit multiplied expo times is equal to number     return n == sum(int(i) ** expo for i in str(n))", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef make_linked_list(elements_list: list | tuple) -> Node:\n\n    # if elements_list is empty\n    if not elements_list:\n        raise ValueError(\"The Elements List is empty\")\n\n    # Set first element as Head\n    head = Node(elements_list[0])\n    current = head\n    # Loop through elements from position 1\n    for data in elements_list[1:]:\n        current.next = Node(data)\n        current = current.next\n    return head", "output": "Creates a Linked List from the elements of the given sequence"}
{"task": "summary", "input": "summarize code:\ndef binary_tree_bottom_side_view(root: TreeNode) -> list[int]:\n    from collections import defaultdict\n\n    def breadth_first_search(root: TreeNode, bottom_view: list[int]) -> None:\n        queue = [(root, 0)]\n        lookup = defaultdict(list)\n\n        while queue:\n            first = queue.pop(0)\n            node, hd = first\n            lookup[hd].append(node.val)\n\n            if node.left:\n                queue.append((node.left, hd - 1))\n            if node.right:\n                queue.append((node.right, hd + 1))\n\n        for pair in sorted(lookup.items(), key=lambda each: each[0]):\n            bottom_view.append(pair[1][-1])\n\n    bottom_view: list = []\n    if not root:\n        return bottom_view\n\n    breadth_first_search(root, bottom_view)\n    return bottom_view", "output": "Function returns the bottom side view of binary tree"}
{"task": "detection", "input": "classify code:\ndef largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We aren't using dp_array here, so the time complexity would be exponential.\n\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the minimal path sum from the top left to the bottom right of the matrix.\n\nChoices:\n0: def solution(filename: str = \"matrix.txt\") -> int:     with open(os.path.join(os.path.dirname(__file__), filename)) as in_file:         data = in_file.read()      grid = [[int(cell) for cell in row.split(\",\")] for row in data.strip().splitlines()]     dp = [[0 for cell in row] for row in grid]     n = len(grid[0])      dp = [[0 for i in range(n)] for j in range(n)]     dp[0][0] = grid[0][0]     for i in range(1, n):         dp[0][i] = grid[0][i] + dp[0][i - 1]     for i in range(1, n):         dp[i][0] = grid[i][0] + dp[i - 1][0]      for i in range(1, n):         for j in range(1, n):             dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])      return dp[-1][-1]\n1: def build_tree() -> TreeNode:     root = TreeNode(1)     root.left = TreeNode(2)     root.right = TreeNode(5)     root.left.left = TreeNode(3)     root.left.right = TreeNode(4)     root.right.right = TreeNode(6)     return root\n2: def is_pentagonal(n: int) -> bool:     root = (1 + 24 * n) ** 0.5     return ((1 + root) / 6) % 1 == 0", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef removeprefix(text: str, prefix: str) -> str:\n    if text.startswith(prefix):\n        return text[len(prefix):]\n    return text", "output": "Remove `prefix` from start of `text` if present."}
{"task": "search", "input": "search code:\nA version of :func:`sorted` which will happily sort an iterable of\n\nChoices:\n0: def solution(max_base: int = 10, max_power: int = 22) -> int:     bases = range(1, max_base)     powers = range(1, max_power)     return sum(         1 for power in powers for base in bases if len(str(base**power)) == power     )\n1: def make_tree() -> Node | None:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     return tree\n2: def untyped_sorted(iterable, key=None, reverse=False):     class _Wrapper:         slots = ('obj',)          def __init__(self, obj):             self.obj = obj          def __lt__(self, other):             obj = key(self.obj) if key is not None else self.obj             other = key(other.obj) if key is not None else other.obj             try:                 ret = obj < other             except TypeError:                 ret = ((type(obj).__name__, id(type(obj)), obj)                        < (type(other).__name__, id(type(other)), other))             return ret      if key is not None and not callable(key):         raise TypeError('expected function or callable object for key, not: %r'                         % key)      return sorted(iterable, key=_Wrapper, reverse=reverse)", "output": "2"}
{"task": "search", "input": "search code:\nReturns the barcode as an integer\n\nChoices:\n0: def area_triangle(base: float, height: float) -> float:     if base < 0 or height < 0:         raise ValueError(\"area_triangle() only accepts non-negative values\")     return (base * height) / 2\n1: def get_barcode(barcode: str) -> int:     if str(barcode).isalpha():         msg = f\"Barcode '{barcode}' has alphabetic characters.\"         raise ValueError(msg)     elif int(barcode) < 0:         raise ValueError(\"The entered barcode has a negative value. Try again.\")     else:         return int(barcode)\n2: def calculate_turnaroundtime(     burst_time: list[int], no_of_processes: int, waiting_time: list[int] ) -> list[int]:     turn_around_time = [0] * no_of_processes     for i in range(no_of_processes):         turn_around_time[i] = burst_time[i] + waiting_time[i]     return turn_around_time", "output": "1"}
{"task": "detection", "input": "classify code:\ndef move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n    \"\"\"\n    Simulates gravity in a specific column.\n\n    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n    [['-', '-'], ['-', 'A'], ['-', 'C']]\n    \"\"\"\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the sum of all the multiples of 3 or 5 below n.\n\nChoices:\n0: def is_palindrome(n: int) -> bool:     return str(n) == str(n)[::-1]\n1: def solution(n: int = 1000) -> int:      total = 0     terms = (n - 1) // 3     total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.     terms = (n - 1) // 5     total += ((terms) * (10 + (terms - 1) * 5)) // 2     terms = (n - 1) // 15     total -= ((terms) * (30 + (terms - 1) * 15)) // 2     return total\n2: def split(string: str, separator: str = \" \") -> list:      split_words = []      last_index = 0     for index, char in enumerate(string):         if char == separator:             split_words.append(string[last_index:index])             last_index = index + 1         if index + 1 == len(string):             split_words.append(string[last_index : index + 1])     return split_words", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp", "output": "def tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp", "tests": ["assert tribonacci(5) == [0, 0, 1, 1, 2]", "assert tribonacci(8) == [0, 0, 1, 1, 2, 4, 7, 13]"]}
{"task": "summary", "input": "summarize code:\ndef product_sum_array(array: list[int | list]) -> int:\n    return product_sum(array, 1)", "output": "Calculates the product sum of an array."}
{"task": "search", "input": "search code:\nReturn the solution to the problem\n\nChoices:\n0: def catalan_number(node_count: int) -> int:     return binomial_coefficient(2 * node_count, node_count) // (node_count + 1)\n1: def analyze_text(text: str) -> tuple[dict, dict]:     single_char_strings = Counter()  # type: ignore[var-annotated]     two_char_strings = Counter()  # type: ignore[var-annotated]     single_char_strings[text[-1]] += 1      # first case when we have space at start.     two_char_strings[\" \" + text[0]] += 1     for i in range(len(text) - 1):         single_char_strings[text[i]] += 1         two_char_strings[text[i : i + 2]] += 1     return single_char_strings, two_char_strings\n2: def solution(n: int = 2) -> int:     result = 1.0     for fraction in fraction_list(n):         frac = Fraction(fraction)         result *= frac.denominator / frac.numerator     return int(result)", "output": "2"}
{"task": "search", "input": "search code:\nPrecompute range minimum queries with power of two length and store the precomputed\n\nChoices:\n0: def adler32(plain_text: str) -> int:     a = 1     b = 0     for plain_chr in plain_text:         a = (a + ord(plain_chr)) % MOD_ADLER         b = (b + a) % MOD_ADLER     return (b << 16) | a\n1: def build_sparse_table(number_list: list[int]) -> list[list[int]]:     if not number_list:         raise ValueError(\"empty number list not allowed\")      length = len(number_list)     # Initialise sparse_table -- sparse_table[j][i] represents the minimum value of the     # subset of length (2 ** j) of number_list, starting from index i.      # smallest power of 2 subset length that fully covers number_list     row = int(log2(length)) + 1     sparse_table = [[0 for i in range(length)] for j in range(row)]      # minimum of subset of length 1 is that value itself     for i, value in enumerate(number_list):         sparse_table[0][i] = value     j = 1      # compute the minimum value for all intervals with size (2 ** j)     while (1 << j) <= length:         i = 0         # while subset starting from i still have at least (2 ** j) elements         while (i + (1 << j) - 1) < length:             # split range [i, i + 2 ** j] and find minimum of 2 halves             sparse_table[j][i] = min(                 sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]             )             i += 1         j += 1     return sparse_table\n2: def display(values):     width = 1 + max(len(values[s]) for s in squares)     line = \"+\".join([\"-\" * (width * 3)] * 3)     for r in rows:         print(             \"\".join(                 values[r + c].center(width) + (\"|\" if c in \"36\" else \"\") for c in cols             )         )         if r in \"CF\":             print(line)     print()", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef linear_search(sequence: list, target: int) -> int:\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return -1", "output": "A pure Python implementation of a linear search algorithm"}
{"task": "summary", "input": "summarize code:\ndef filter_common_word(possibles: list[str], common_word: str) -> list[str]:\n    return [possible for possible in possibles if common_word in possible.lower()]", "output": "Given a list of possible decoded messages, narrow down the possibilities"}
{"task": "search", "input": "search code:\nSwap the rows and columns of the input matrix.\n\nChoices:\n0: def transpose(it):     return zip(*it, strict=True)\n1: def analyze_text(text: str) -> tuple[dict, dict]:     single_char_strings = Counter()  # type: ignore[var-annotated]     two_char_strings = Counter()  # type: ignore[var-annotated]     single_char_strings[text[-1]] += 1      # first case when we have space at start.     two_char_strings[\" \" + text[0]] += 1     for i in range(len(text) - 1):         single_char_strings[text[i]] += 1         two_char_strings[text[i : i + 2]] += 1     return single_char_strings, two_char_strings\n2: def is_contains_unique_chars(input_str: str) -> bool:      # Each bit will represent each unicode character     # For example 65th bit representing 'A'     # https://stackoverflow.com/a/12811293     bitmap = 0     for ch in input_str:         ch_unicode = ord(ch)         ch_bit_index_on = pow(2, ch_unicode)          # If we already turned on bit for current character's unicode         if bitmap >> ch_unicode & 1 == 1:             return False         bitmap |= ch_bit_index_on     return True", "output": "0"}
{"task": "search", "input": "search code:\nReturns the model if the formula is satisfiable, else ``None``\n\nChoices:\n0: def transform(velocity: float, event: np.ndarray | None = None) -> np.ndarray:     # Ensure event is not empty     if event is None:         event = np.array([ct, x, y, z])  # Symbolic four vector     else:         event[0] *= c  # x0 is ct (speed of light * time)      return transformation_matrix(velocity) @ event\n1: def dpll_algorithm(     clauses: list[Clause], symbols: list[str], model: dict[str, bool | None] ) -> tuple[bool | None, dict[str, bool | None] | None]:     check_clause_all_true = True     for clause in clauses:         clause_check = clause.evaluate(model)         if clause_check is False:             return False, None         elif clause_check is None:             check_clause_all_true = False             continue      if check_clause_all_true:         return True, model      try:         pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)     except RecursionError:         print(\"raises a RecursionError and is\")         return None, {}     p = None     if len(pure_symbols) > 0:         p, value = pure_symbols[0], assignment[pure_symbols[0]]      if p:         tmp_model = model         tmp_model[p] = value         tmp_symbols = list(symbols)         if p in tmp_symbols:             tmp_symbols.remove(p)         return dpll_algorithm(clauses, tmp_symbols, tmp_model)      unit_symbols, assignment = find_unit_clauses(clauses, model)     p = None     if len(unit_symbols) > 0:         p, value = unit_symbols[0], assignment[unit_symbols[0]]     if p:         tmp_model = model         tmp_model[p] = value         tmp_symbols = list(symbols)         if p in tmp_symbols:             tmp_symbols.remove(p)         return dpll_algorithm(clauses, tmp_symbols, tmp_model)     p = symbols[0]     rest = symbols[1:]     tmp1, tmp2 = model, model     tmp1[p], tmp2[p] = True, False      return dpll_algorithm(clauses, rest, tmp1) or dpll_algorithm(clauses, rest, tmp2)\n2: def fibonacci(n: int) -> int:     if n < 0:         raise ValueError(\"Negative arguments are not supported\")     return _fib(n)[0]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    img_paths, annos = get_dataset(LABEL_DIR, IMAGE_DIR)\n    print(\"Processing...\")\n    new_images, new_annos, paths = update_image_and_anno(img_paths, annos, FLIP_TYPE)\n\n    for index, image in enumerate(new_images):\n        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n        letter_code = random_chars(32)\n        file_name = paths[index].split(os.sep)[-1].rsplit(\".\", 1)[0]\n        file_root = f\"{OUTPUT_DIR}/{file_name}_FLIP_{letter_code}\"\n        cv2.imwrite(f\"{file_root}.jpg\", image, [cv2.IMWRITE_JPEG_QUALITY, 85])\n        print(f\"Success {index + 1}/{len(new_images)} with {file_name}\")\n        annos_list = []\n        for anno in new_annos[index]:\n            obj = f\"{anno[0]} {anno[1]} {anno[2]} {anno[3]} {anno[4]}\"\n            annos_list.append(obj)\n        with open(f\"{file_root}.txt\", \"w\") as outfile:\n            outfile.write(\"\\n\".join(line for line in annos_list))", "output": "Get images list and annotations list from input dir."}
{"task": "summary", "input": "summarize code:\ndef gaussian_error_linear_unit(vector: np.ndarray) -> np.ndarray:\n    return vector * sigmoid(1.702 * vector)", "output": "Implements the Gaussian Error Linear Unit (GELU) function"}
{"task": "detection", "input": "classify code:\ndef largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef shell_sort(collection: list) -> list:\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection", "output": "Implementation of shell sort algorithm in Python"}
{"task": "search", "input": "search code:\nSort the given list based on the bit at bit_position. Numbers with a\n\nChoices:\n0: def _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:     if bit_position == 0 or len(list_of_ints) in [0, 1]:         return list_of_ints      zeros = []     ones = []     # Split numbers based on bit at bit_position from the right     for number in list_of_ints:         if (number >> (bit_position - 1)) & 1:             # number has a one at bit bit_position             ones.append(number)         else:             # number has a zero at bit bit_position             zeros.append(number)      # recursively split both lists further     zeros = _msd_radix_sort(zeros, bit_position - 1)     ones = _msd_radix_sort(ones, bit_position - 1)      # recombine lists     res = zeros     res.extend(ones)      return res\n1: def solve(     digit: int, prev1: int, prev2: int, sum_max: int, first: bool, cache: dict[str, int] ) -> int:     if digit == 0:         return 1      cache_str = f\"{digit},{prev1},{prev2}\"     if cache_str in cache:         return cache[cache_str]      comb = 0     for curr in range(sum_max - prev1 - prev2 + 1):         if first and curr == 0:             continue          comb += solve(             digit=digit - 1,             prev1=curr,             prev2=prev1,             sum_max=sum_max,             first=False,             cache=cache,         )      cache[cache_str] = comb     return comb\n2: def hubble_parameter(     hubble_constant: float,     radiation_density: float,     matter_density: float,     dark_energy: float,     redshift: float, ) -> float:     parameters = [redshift, radiation_density, matter_density, dark_energy]     if any(p < 0 for p in parameters):         raise ValueError(\"All input parameters must be positive\")      if any(p > 1 for p in parameters[1:4]):         raise ValueError(\"Relative densities cannot be greater than one\")     else:         curvature = 1 - (matter_density + radiation_density + dark_energy)          e_2 = (             radiation_density * (redshift + 1) ** 4             + matter_density * (redshift + 1) ** 3             + curvature * (redshift + 1) ** 2             + dark_energy         )          hubble = hubble_constant * e_2 ** (1 / 2)         return hubble", "output": "0"}
{"task": "search", "input": "search code:\nReturn ``True`` if all given *iterables* are equal to each other,\n\nChoices:\n0: def get_nodes_from_right_to_left(root: Node | None, level: int) -> Generator[int]:      def populate_output(root: Node | None, level: int) -> Generator[int]:         if not root:             return         if level == 1:             yield root.data         elif level > 1:             yield from populate_output(root.right, level - 1)             yield from populate_output(root.left, level - 1)      yield from populate_output(root, level)\n1: def calculate_average_waiting_time(waiting_times: list[int]) -> float:     return sum(waiting_times) / len(waiting_times)\n2: def iequals(*iterables):     try:         return all(map(all_equal, zip(*iterables, strict=True)))     except ValueError:         return False", "output": "2"}
{"task": "search", "input": "search code:\nReturn the lowest common ancestor between u and v\n\nChoices:\n0: def lowest_common_ancestor(     u: int, v: int, level: list[int], parent: list[list[int]] ) -> int:     # u must be deeper in the tree than v     if level[u] < level[v]:         u, v = swap(u, v)     # making depth of u same as depth of v     for i in range(18, -1, -1):         if level[u] - (1 << i) >= level[v]:             u = parent[i][u]     # at the same depth if u==v that mean lca is found     if u == v:         return u     # moving both nodes upwards till lca in found     for i in range(18, -1, -1):         if parent[i][u] not in [0, parent[i][v]]:             u, v = parent[i][u], parent[i][v]     # returning longest common ancestor of u,v     return parent[0][u]\n1: def unquote_to_bytes(string):     # Note: strings are encoded as UTF-8. This is only an issue if it contains     # unescaped non-ASCII characters, which URIs should not.     if not string:         # Is it a string-like object?         string.split         return b''     if isinstance(string, str):         string = string.encode('utf-8')     bits = string.split(b'%')     if len(bits) == 1:         return string     # import pdb;pdb.set_trace()     res = [bits[0]]     append = res.append      for item in bits[1:]:         try:             append(_HEX_CHAR_MAP[item[:2]])             append(item[2:])         except KeyError:             append(b'%')             append(item)     return b''.join(res)\n2: def open_knight_tour_helper(     board: list[list[int]], pos: tuple[int, int], curr: int ) -> bool:      if is_complete(board):         return True      for position in get_valid_pos(pos, len(board)):         y, x = position          if board[y][x] == 0:             board[y][x] = curr + 1             if open_knight_tour_helper(board, position, curr + 1):                 return True             board[y][x] = 0      return False", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef pressure_and_volume_to_temperature(\n    pressure: float, moles: float, volume: float\n) -> float:\n    \"\"\"\n    Convert pressure and volume to temperature.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> pressure_and_volume_to_temperature(0.82, 1, 2)\n      20\n      >>> pressure_and_volume_to_temperature(8.2, 5, 3)\n      60\n    \"\"\"\n    return round(float((pressure * volume) / (0.0821 * moles)))", "output": "def pressure_and_volume_to_temperature(\n    pressure: float, moles: float, volume: float\n) -> float:\n    \"\"\"\n    Convert pressure and volume to temperature.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> pressure_and_volume_to_temperature(0.82, 1, 2)\n      20\n      >>> pressure_and_volume_to_temperature(8.2, 5, 3)\n      60\n    \"\"\"\n    return round(float((pressure * volume) / (0.0821 * moles)))", "tests": ["assert pressure_and_volume_to_temperature(0.82, 1, 2) == 20", "assert pressure_and_volume_to_temperature(8.2, 5, 3) == 60"]}
{"task": "search", "input": "search code:\nYields unique elements in sorted order.\n\nChoices:\n0: def solution(max_prime: int = 10**6) -> int:      primes_count = 0     cube_index = 1     prime_candidate = 7     while prime_candidate < max_prime:         primes_count += is_prime(prime_candidate)          cube_index += 1         prime_candidate += 6 * cube_index      return primes_count\n1: def is_monotonic(nums: list[int]) -> bool:     return all(nums[i] <= nums[i + 1] for i in range(len(nums) - 1)) or all(         nums[i] >= nums[i + 1] for i in range(len(nums) - 1)     )\n2: def unique(iterable, key=None, reverse=False):     sequenced = sorted(iterable, key=key, reverse=reverse)     return unique_justseen(sequenced, key=key)", "output": "2"}
{"task": "search", "input": "search code:\nFinds the area of all islands and returns the maximum area.\n\nChoices:\n0: def groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):     ret = groupby(iterable, keyfunc)     if valuefunc:         ret = ((k, map(valuefunc, g)) for k, g in ret)     if reducefunc:         ret = ((k, reducefunc(g)) for k, g in ret)      return ret\n1: def find_max_area(mat: list[list[int]]) -> int:     seen: set = set()      max_area = 0     for row, line in enumerate(mat):         for col, item in enumerate(line):             if item == 1 and (row, col) not in seen:                 # Maximizing the area                 max_area = max(max_area, depth_first_search(row, col, seen, mat))     return max_area\n2: def pad_none(iterable):     return chain(iterable, repeat(None))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef krusk(e_and_n):\n    (e, n) = e_and_n\n    e.sort(reverse=True, key=lambda x: x[2])\n    s = [{i} for i in range(1, n + 1)]\n    while True:\n        if len(s) == 1:\n            break\n        print(s)\n        x = e.pop()\n        for i in range(len(s)):\n            if x[0] in s[i]:\n                break\n        for j in range(len(s)):\n            if x[1] in s[j]:\n                if i == j:\n                    break\n                s[j].update(s[i])\n                s.pop(i)\n                break", "output": "Sort edges on the basis of distance"}
{"task": "repair", "input": "fix bug:\ndef vector_product(point1: Tuple[int, int], point2: Tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]", "output": "def vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]", "tests": ["assert vector_product((1, 2), (-5, 0)) == 10", "assert vector_product((3, 1), (6, 10)) == 24"]}
{"task": "search", "input": "search code:\nYield unique elements from the iterable, *src*, based on *key*,\n\nChoices:\n0: def unique_iter(src, key=None):     if not is_iterable(src):         raise TypeError('expected an iterable, not %r' % type(src))     if key is None:         def key_func(x): return x     elif callable(key):         key_func = key     elif isinstance(key, str):         def key_func(x): return getattr(x, key, x)     else:         raise TypeError('\"key\" expected a string or callable, not %r' % key)     seen = set()     for i in src:         k = key_func(i)         if k not in seen:             seen.add(k)             yield i     return\n1: def convex_hull_recursive(points: list[Point]) -> list[Point]:     points = sorted(_validate_input(points))     n = len(points)      # divide all the points into an upper hull and a lower hull     # the left most point and the right most point are definitely     # members of the convex hull by definition.     # use these two anchors to divide all the points into two hulls,     # an upper hull and a lower hull.      # all points to the left (above) the line joining the extreme points belong to the     # upper hull     # all points to the right (below) the line joining the extreme points below to the     # lower hull     # ignore all points on the line joining the extreme points since they cannot be     # part of the convex hull      left_most_point = points[0]     right_most_point = points[n - 1]      convex_set = {left_most_point, right_most_point}     upper_hull = []     lower_hull = []      for i in range(1, n - 1):         det = _det(left_most_point, right_most_point, points[i])          if det > 0:             upper_hull.append(points[i])         elif det < 0:             lower_hull.append(points[i])      _construct_hull(upper_hull, left_most_point, right_most_point, convex_set)     _construct_hull(lower_hull, right_most_point, left_most_point, convex_set)      return sorted(convex_set)\n2: def solution(n: int = 4000000) -> int:      even_fibs = []     a, b = 0, 1     while b <= n:         if b % 2 == 0:             even_fibs.append(b)         a, b = b, a + b     return sum(even_fibs)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef before_and_after(predicate, it):\n    trues, after = tee(it)\n    trues = compress(takewhile(predicate, trues), zip(after))\n    return trues, after", "output": "A variant of :func:`takewhile` that allows complete access to the"}
{"task": "summary", "input": "summarize code:\ndef quantify(iterable, pred=bool):\n    return sum(map(pred, iterable))", "output": "Return the how many times the predicate is true."}
{"task": "summary", "input": "summarize code:\ndef get_all_subclasses(cls):\n    try:\n        to_check = deque(cls.__subclasses__())\n    except (AttributeError, TypeError):\n        raise TypeError('expected type object, not %r' % cls)\n    seen, ret = set(), []\n    while to_check:\n        cur = to_check.popleft()\n        if cur in seen:\n            continue\n        ret.append(cur)\n        seen.add(cur)\n        to_check.extend(cur.__subclasses__())\n    return ret", "output": "Recursively finds and returns a :class:`list` of all types"}
{"task": "search", "input": "search code:\nReturn first *n* items of the *iterable* as a list.\n\nChoices:\n0: def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:     check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2     check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002     check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002      return check_hue and check_saturation and check_value\n1: def take(n, iterable):     return list(islice(iterable, n))\n2: def synchronized(func):      @wraps(func)     def inner(*args, **kwargs):         iterator = func(*args, **kwargs)         return serialize(iterator)      return inner", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef sentinel_linear_search(sequence, target):\n    sequence.append(target)\n\n    index = 0\n    while sequence[index] != target:\n        index += 1\n\n    sequence.pop()\n\n    if index == len(sequence):\n        return None\n\n    return index", "output": "Pure implementation of sentinel linear search algorithm in Python"}
{"task": "summary", "input": "summarize code:\ndef parse_roman_numerals(numerals: str) -> int:\n\n    total_value = 0\n\n    index = 0\n    while index < len(numerals) - 1:\n        current_value = SYMBOLS[numerals[index]]\n        next_value = SYMBOLS[numerals[index + 1]]\n        if current_value < next_value:\n            total_value -= current_value\n        else:\n            total_value += current_value\n        index += 1\n    total_value += SYMBOLS[numerals[index]]\n\n    return total_value", "output": "Converts a string of roman numerals to an integer."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 4000000) -> int:\n\n    even_fibs = []\n    a, b = 0, 1\n    while b <= n:\n        if b % 2 == 0:\n            even_fibs.append(b)\n        a, b = b, a + b\n    return sum(even_fibs)", "output": "Returns the sum of all even fibonacci sequence elements that are lower"}
{"task": "search", "input": "search code:\nRepeat each element in *iterable* *n* times.\n\nChoices:\n0: def repeat_each(iterable, n=2):     return chain.from_iterable(map(repeat, iterable, repeat(n)))\n1: def open_knight_tour(n: int) -> list[list[int]]:      board = [[0 for i in range(n)] for j in range(n)]      for i in range(n):         for j in range(n):             board[i][j] = 1             if open_knight_tour_helper(board, (i, j), 1):                 return board             board[i][j] = 0      msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"     raise ValueError(msg)\n2: def main():     num = int(input(\"Enter an integer to see if it is an Armstrong number: \").strip())     print(f\"{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number.\")     print(f\"{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number.\")     print(f\"{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number.\")", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef axpy(scalar: float, x: Vector, y: Vector) -> Vector:\n    # precondition\n    assert isinstance(x, Vector)\n    assert isinstance(y, Vector)\n    assert isinstance(scalar, (int, float))\n    return x * scalar + y", "output": "input: a 'scalar' and two vectors 'x' and 'y'"}
{"task": "search", "input": "search code:\nAssembles the transformations based on the ops table.\n\nChoices:\n0: def _ngettext_noop(singular, plural):     return (singular, plural)\n1: def solution(n: int = 100) -> int:      sum_of_squares = sum(i * i for i in range(1, n + 1))     square_of_sum = int(math.pow(sum(range(1, n + 1)), 2))     return square_of_sum - sum_of_squares\n2: def assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:     if i == 0 and j == 0:         return []     elif ops[i][j][0] in {\"C\", \"R\"}:         seq = assemble_transformation(ops, i - 1, j - 1)         seq.append(ops[i][j])         return seq     elif ops[i][j][0] == \"D\":         seq = assemble_transformation(ops, i - 1, j)         seq.append(ops[i][j])         return seq     else:         seq = assemble_transformation(ops, i, j - 1)         seq.append(ops[i][j])         return seq", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(n_digits: int = 20) -> int:\n    cache: dict[str, int] = {}\n    return solve(digit=n_digits, prev1=0, prev2=0, sum_max=9, first=True, cache=cache)", "output": "Solves the problem for n_digits number of digits."}
{"task": "search", "input": "search code:\nA pure Python implementation of the insertion sort algorithm\n\nChoices:\n0: def insertion_sort[T: Comparable](collection: MutableSequence[T]) -> MutableSequence[T]:      for insert_index in range(1, len(collection)):         insert_value = collection[insert_index]         while insert_index > 0 and insert_value < collection[insert_index - 1]:             collection[insert_index] = collection[insert_index - 1]             insert_index -= 1         collection[insert_index] = insert_value     return collection\n1: def ceil(x: float) -> int:     return int(x) if x - int(x) <= 0 else int(x) + 1\n2: def collect_dataset():     response = httpx.get(         \"https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/\"         \"master/Week1/ADRvsRating.csv\",         timeout=10,     )     lines = response.text.splitlines()     data = []     for item in lines:         item = item.split(\",\")         data.append(item)     data.pop(0)  # This is for removing the labels from the list     dataset = np.matrix(data)     return dataset", "output": "0"}
{"task": "search", "input": "search code:\nImplements the Sigmoid Linear Unit (SiLU) or swish function\n\nChoices:\n0: def difference(iterable, func=sub, *, initial=None):     a, b = tee(iterable)     try:         first = [next(b)]     except StopIteration:         return iter([])      if initial is not None:         first = []      return chain(first, map(func, b, a))\n1: def sigmoid_linear_unit(vector: np.ndarray) -> np.ndarray:     return vector * sigmoid(vector)\n2: def prime_factors(n: int) -> list:     if n <= 0:         raise ValueError(\"Only positive integers have prime factors\")     pf = []     while n % 2 == 0:         pf.append(2)         n = int(n / 2)     for i in range(3, int(math.sqrt(n)) + 1, 2):         while n % i == 0:             pf.append(i)             n = int(n / i)     if n > 2:         pf.append(n)     return pf", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:\n    center = image[x_coordinate][y_coordinate]\n    powers = [1, 2, 4, 8, 16, 32, 64, 128]\n\n    # skip get_neighbors_pixel if center is null\n    if center is None:\n        return 0\n\n    # Starting from the top right, assigning value to pixels clockwise\n    binary_values = [\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),\n        get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),\n    ]\n\n    # Converting the binary value to decimal.\n    return sum(\n        binary_value * power for binary_value, power in zip(binary_values, powers)\n    )", "output": "It takes an image, an x and y coordinate, and returns the"}
{"task": "summary", "input": "summarize code:\ndef modular_division2(a: int, b: int, n: int) -> int:\n    s = invert_modulo(a, n)\n    x = (b * s) % n\n    return x", "output": "This function used the above inversion of a to find x = (b*a^(-1))mod n"}
{"task": "summary", "input": "summarize code:\ndef p_series(nth_term: float | str, power: float | str) -> list[str]:\n    if nth_term == \"\":\n        return [\"\"]\n    nth_term = int(nth_term)\n    power = int(power)\n    series: list[str] = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")\n    return series", "output": "Pure Python implementation of P-Series algorithm"}
{"task": "summary", "input": "summarize code:\ndef find_empty_location(grid: Matrix) -> tuple[int, int] | None:\n    for i in range(9):\n        for j in range(9):\n            if grid[i][j] == 0:\n                return i, j\n    return None", "output": "This function finds an empty location so that we can assign a number"}
{"task": "detection", "input": "classify code:\ndef fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n    \"\"\"[summary]\n\n    This function will take input of drug name and zipcode,\n    then request to the BASE_URL site.\n    Get the page data and scrape it to generate the\n    list of the lowest prices for the prescription drug.\n\n    Args:\n        drug_name (str): [Drug name]\n        zip_code(str): [Zip code]\n\n    Returns:\n        list: [List of pharmacy name and price]\n\n    >>> print(fetch_pharmacy_and_price_list(None, None))\n    None\n    >>> print(fetch_pharmacy_and_price_list(None, 30303))\n    None\n    >>> print(fetch_pharmacy_and_price_list(\"eliquis\", None))\n    None\n    \"\"\"\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef sum_of_digits(num: int, base: int) -> str:\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    num_str = int_to_base(num, base)\n    res = sum(int(char, base) for char in num_str)\n    res_str = int_to_base(res, base)\n    return res_str", "output": "Calculate the sum of digit values in a positive integer"}
{"task": "summary", "input": "summarize code:\ndef max_height(init_velocity: float, angle: float) -> float:\n    check_args(init_velocity, angle)\n    radians = deg_to_rad(angle)\n    return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)", "output": "Returns the maximum height that the object reach"}
{"task": "summary", "input": "summarize code:\ndef calculate_waitingtime(\n    arrival_time: list[int], burst_time: list[int], no_of_processes: int\n) -> list[int]:\n\n    waiting_time = [0] * no_of_processes\n    remaining_time = [0] * no_of_processes\n\n    # Initialize remaining_time to waiting_time.\n\n    for i in range(no_of_processes):\n        remaining_time[i] = burst_time[i]\n    ready_process: list[int] = []\n\n    completed = 0\n    total_time = 0\n\n    # When processes are not completed,\n    # A process whose arrival time has passed \\\n    # and has remaining execution time is put into the ready_process.\n    # The shortest process in the ready_process, target_process is executed.\n\n    while completed != no_of_processes:\n        ready_process = []\n        target_process = -1\n\n        for i in range(no_of_processes):\n            if (arrival_time[i] <= total_time) and (remaining_time[i] > 0):\n                ready_process.append(i)\n\n        if len(ready_process) > 0:\n            target_process = ready_process[0]\n            for i in ready_process:\n                if remaining_time[i] < remaining_time[target_process]:\n                    target_process = i\n            total_time += burst_time[target_process]\n            completed += 1\n            remaining_time[target_process] = 0\n            waiting_time[target_process] = (\n                total_time - arrival_time[target_process] - burst_time[target_process]\n            )\n        else:\n            total_time += 1\n\n    return waiting_time", "output": "Calculate the waiting time of each processes"}
{"task": "summary", "input": "summarize code:\ndef circle_sort(collection: list) -> list:\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection", "output": "A pure Python implementation of circle sort algorithm"}
{"task": "summary", "input": "summarize code:\ndef ichunked(iterable, n):\n    iterator = iter(iterable)\n    while True:\n        # Create new chunk\n        chunk, materialize_next = _ichunk(iterator, n)\n\n        # Check to see whether we're at the end of the source iterable\n        if not materialize_next():\n            return\n\n        yield chunk\n\n        # Fill previous chunk's cache\n        materialize_next(None)", "output": "Break *iterable* into sub-iterables with *n* elements each."}
{"task": "search", "input": "search code:\nConvert text input into two dicts of counts.\n\nChoices:\n0: def analyze_text(text: str) -> tuple[dict, dict]:     single_char_strings = Counter()  # type: ignore[var-annotated]     two_char_strings = Counter()  # type: ignore[var-annotated]     single_char_strings[text[-1]] += 1      # first case when we have space at start.     two_char_strings[\" \" + text[0]] += 1     for i in range(len(text) - 1):         single_char_strings[text[i]] += 1         two_char_strings[text[i : i + 2]] += 1     return single_char_strings, two_char_strings\n1: def binary_or(a: int, b: int) -> str:     if a < 0 or b < 0:         raise ValueError(\"the value of both inputs must be positive\")     a_binary = str(bin(a))[2:]  # remove the leading \"0b\"     b_binary = str(bin(b))[2:]     max_len = max(len(a_binary), len(b_binary))     return \"0b\" + \"\".join(         str(int(\"1\" in (char_a, char_b)))         for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))     )\n2: def equality(iterable: list) -> bool:     return len(set(iterable)) in (0, 1)", "output": "0"}
{"task": "search", "input": "search code:\nCycle through the items from *iterable* up to *n* times, yielding\n\nChoices:\n0: def display(values):     width = 1 + max(len(values[s]) for s in squares)     line = \"+\".join([\"-\" * (width * 3)] * 3)     for r in rows:         print(             \"\".join(                 values[r + c].center(width) + (\"|\" if c in \"36\" else \"\") for c in cols             )         )         if r in \"CF\":             print(line)     print()\n1: def remove_duplicates(sentence: str) -> str:     return \" \".join(sorted(set(sentence.split())))\n2: def count_cycle(iterable, n=None):     if n is not None:         return product(range(n), iterable)     seq = tuple(iterable)     if not seq:         return iter(())     counter = count() if n is None else range(n)     return zip(repeat_each(counter, len(seq)), cycle(seq))", "output": "2"}
{"task": "detection", "input": "classify code:\ndef alt_ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    >>> alt_ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> alt_ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    \"\"\"\n    return int(\"0x\" + \"\".join(f\"{int(i):02x}\" for i in ipv4_address.split(\".\")), 16)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef longest_palindromic_subsequence(input_string: str) -> int:\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]", "output": "This function returns the longest palindromic subsequence in a string"}
{"task": "summary", "input": "summarize code:\ndef find_freq_subgraph_given_support(s, cluster, graph):\n    k = int(s / 100 * (len(cluster) - 1))\n    for i in cluster[k]:\n        my_dfs(graph, tuple(cluster[k][i]), ([\"Header\"],))", "output": "find edges of multiple frequent subgraphs"}
{"task": "summary", "input": "summarize code:\ndef split_punct_ws(text):\n    return [w for w in _punct_re.split(text) if w]", "output": "While :meth:`str.split` will split on whitespace,"}
{"task": "detection", "input": "classify code:\ndef is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef _partition(data: list, pivot) -> tuple:\n    less, equal, greater = [], [], []\n    for element in data:\n        if element < pivot:\n            less.append(element)\n        elif element > pivot:\n            greater.append(element)\n        else:\n            equal.append(element)\n    return less, equal, greater", "output": "Three way partition the data into smaller, equal and greater lists,"}
{"task": "search", "input": "search code:\nCheck if t = f(positive_integer) = log2(sqrt(4*positive_integer+1)/2 + 1/2) is a\n\nChoices:\n0: def depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:     row_length, col_length = len(grid), len(grid[0])     if (         min(row, col) < 0         or row == row_length         or col == col_length         or (row, col) in visit         or grid[row][col] == 1     ):         return 0     if row == row_length - 1 and col == col_length - 1:         return 1      visit.add((row, col))      count = 0     count += depth_first_search(grid, row + 1, col, visit)     count += depth_first_search(grid, row - 1, col, visit)     count += depth_first_search(grid, row, col + 1, visit)     count += depth_first_search(grid, row, col - 1, visit)      visit.remove((row, col))     return count\n1: def check_partition_perfect(positive_integer: int) -> bool:      exponent = math.log2(math.sqrt(4 * positive_integer + 1) / 2 + 1 / 2)      return exponent == int(exponent)\n2: def check_bouncy(n: int) -> bool:     if not isinstance(n, int):         raise ValueError(\"check_bouncy() accepts only integer arguments\")     str_n = str(n)     sorted_str_n = \"\".join(sorted(str_n))     return str_n not in {sorted_str_n, sorted_str_n[::-1]}", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef decipher(message: str, cipher_map: dict[str, str]) -> str:\n    # Reverse our cipher mappings\n    rev_cipher_map = {v: k for k, v in cipher_map.items()}\n    return \"\".join(rev_cipher_map.get(ch, ch) for ch in message.upper())", "output": "Deciphers a message given a cipher map"}
{"task": "search", "input": "search code:\nGenerates a template based on the key and fills it in with\n\nChoices:\n0: def vol_spheres_intersect(     radius_1: float, radius_2: float, centers_distance: float ) -> float:     if radius_1 < 0 or radius_2 < 0 or centers_distance < 0:         raise ValueError(\"vol_spheres_intersect() only accepts non-negative values\")     if centers_distance == 0:         return vol_sphere(min(radius_1, radius_2))      h1 = (         (radius_1 - radius_2 + centers_distance)         * (radius_1 + radius_2 - centers_distance)         / (2 * centers_distance)     )     h2 = (         (radius_2 - radius_1 + centers_distance)         * (radius_2 + radius_1 - centers_distance)         / (2 * centers_distance)     )      return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)\n1: def num_digits_faster(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      return len(str(abs(n)))\n2: def decrypt(input_string: str, key: int) -> str:     grid = []     lowest = key - 1      if key <= 0:         raise ValueError(\"Height of grid can't be 0 or negative\")     if key == 1:         return input_string      temp_grid: list[list[str]] = [[] for _ in range(key)]  # generates template     for position in range(len(input_string)):         num = position % (lowest * 2)  # puts it in bounds         num = min(num, lowest * 2 - num)  # creates zigzag pattern         temp_grid[num].append(\"*\")      counter = 0     for row in temp_grid:  # fills in the characters         splice = input_string[counter : counter + len(row)]         grid.append(list(splice))         counter += len(row)      output_string = \"\"  # reads as zigzag     for position in range(len(input_string)):         num = position % (lowest * 2)  # puts it in bounds         num = min(num, lowest * 2 - num)  # creates zigzag pattern         output_string += grid[num][0]         grid[num].pop(0)     return output_string", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef get_set_bits_count_using_modulo_operator(number: int) -> int:\n    if number < 0:\n        raise ValueError(\"the value of input must not be negative\")\n    result = 0\n    while number:\n        if number % 2 == 1:\n            result += 1\n        number >>= 1\n    return result", "output": "Count the number of set bits in a 32 bit integer"}
{"task": "summary", "input": "summarize code:\ndef decrypt(input_string: str, key: int) -> str:\n    grid = []\n    lowest = key - 1\n\n    if key <= 0:\n        raise ValueError(\"Height of grid can't be 0 or negative\")\n    if key == 1:\n        return input_string\n\n    temp_grid: list[list[str]] = [[] for _ in range(key)]  # generates template\n    for position in range(len(input_string)):\n        num = position % (lowest * 2)  # puts it in bounds\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\n        temp_grid[num].append(\"*\")\n\n    counter = 0\n    for row in temp_grid:  # fills in the characters\n        splice = input_string[counter : counter + len(row)]\n        grid.append(list(splice))\n        counter += len(row)\n\n    output_string = \"\"  # reads as zigzag\n    for position in range(len(input_string)):\n        num = position % (lowest * 2)  # puts it in bounds\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\n        output_string += grid[num][0]\n        grid[num].pop(0)\n    return output_string", "output": "Generates a template based on the key and fills it in with"}
{"task": "detection", "input": "classify code:\ndef solution_fast() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution_fast()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(400):\n            c = 1000 - a - b\n            if a < b < c and (a**2) + (b**2) == (c**2):\n                return a * b * c\n\n    return -1", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef get_cluster(nodes):\n    cluster = {}\n    for key, value in nodes.items():\n        cluster.setdefault(key.count(\"1\"), {})[key] = value\n    return cluster", "output": "Returns cluster"}
{"task": "search", "input": "search code:\nYield elements of the longest common prefix among given *iterables*.\n\nChoices:\n0: def area_triangle(base: float, height: float) -> float:     if base < 0 or height < 0:         raise ValueError(\"area_triangle() only accepts non-negative values\")     return (base * height) / 2\n1: def longest_common_prefix(iterables):     return (c[0] for c in takewhile(all_equal, zip(*iterables)))\n2: def solution(limit: int = 10000) -> int:     lychrel_nums = []     for num in range(1, limit):         iterations = 0         a = num         while iterations < 50:             num = sum_reverse(num)             iterations += 1             if is_palindrome(num):                 break         else:             lychrel_nums.append(a)     return len(lychrel_nums)", "output": "1"}
{"task": "search", "input": "search code:\nCompute n-element combinations from a given list using dynamic programming.\n\nChoices:\n0: def is_prime(number: int) -> bool:      # precondition     assert isinstance(number, int) and (number >= 0), (         \"'number' must been an int and positive\"     )      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or not number % 2:         # Negatives, 0, 1 and all even numbers are not primes         return False      odd_numbers = range(3, int(math.sqrt(number) + 1), 2)     return not any(not number % i for i in odd_numbers)\n1: def subset_combinations(elements: list[int], n: int) -> list:     r = len(elements)     if n > r:         return []      dp: list[list[tuple]] = [[] for _ in range(r + 1)]      dp[0].append(())      for i in range(1, r + 1):         for j in range(i, 0, -1):             for prev_combination in dp[j - 1]:                 dp[j].append((*prev_combination, elements[i - 1]))      try:         return sorted(dp[n])     except TypeError:         return dp[n]\n2: def ordinal(value, gender=\"male\"):     try:         value = int(value)     except (TypeError, ValueError):         return value     if gender == \"male\":         t = (             P_(\"0 (male)\", \"th\"),             P_(\"1 (male)\", \"st\"),             P_(\"2 (male)\", \"nd\"),             P_(\"3 (male)\", \"rd\"),             P_(\"4 (male)\", \"th\"),             P_(\"5 (male)\", \"th\"),             P_(\"6 (male)\", \"th\"),             P_(\"7 (male)\", \"th\"),             P_(\"8 (male)\", \"th\"),             P_(\"9 (male)\", \"th\"),         )     else:         t = (             P_(\"0 (female)\", \"th\"),             P_(\"1 (female)\", \"st\"),             P_(\"2 (female)\", \"nd\"),             P_(\"3 (female)\", \"rd\"),             P_(\"4 (female)\", \"th\"),             P_(\"5 (female)\", \"th\"),             P_(\"6 (female)\", \"th\"),             P_(\"7 (female)\", \"th\"),             P_(\"8 (female)\", \"th\"),             P_(\"9 (female)\", \"th\"),         )     if value % 100 in (11, 12, 13):  # special case         return f\"{value}{t[0]}\"     return f\"{value}{t[value % 10]}\"", "output": "1"}
{"task": "search", "input": "search code:\nCalculate the number of documents in a corpus that contain a\n\nChoices:\n0: def total_time(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(angle)     return round(2 * init_velocity * sin(radians) / g, 2)\n1: def document_frequency(term: str, corpus: str) -> tuple[int, int]:     corpus_without_punctuation = corpus.lower().translate(         str.maketrans(\"\", \"\", string.punctuation)     )  # strip all punctuation and replace it with ''     docs = corpus_without_punctuation.split(\"\\n\")     term = term.lower()     return (len([doc for doc in docs if term in doc]), len(docs))\n2: def remove_duplicates(key: str) -> str:      key_no_dups = \"\"     for ch in key:         if ch == \" \" or (ch not in key_no_dups and ch.isalpha()):             key_no_dups += ch     return key_no_dups", "output": "1"}
{"task": "search", "input": "search code:\nSorts a list using the Cocktail Shaker Sort algorithm.\n\nChoices:\n0: def calc_profit(profit: list, weight: list, max_weight: int) -> int:     if len(profit) != len(weight):         raise ValueError(\"The length of profit and weight must be same.\")     if max_weight <= 0:         raise ValueError(\"max_weight must greater than zero.\")     if any(p < 0 for p in profit):         raise ValueError(\"Profit can not be negative.\")     if any(w < 0 for w in weight):         raise ValueError(\"Weight can not be negative.\")      # List created to store profit gained for the 1kg in case of each weight     # respectively.  Calculate and append profit/weight for each element.     profit_by_weight = [p / w for p, w in zip(profit, weight)]      # Creating a copy of the list and sorting profit/weight in ascending order     sorted_profit_by_weight = sorted(profit_by_weight)      # declaring useful variables     length = len(sorted_profit_by_weight)     limit = 0     gain = 0     i = 0      # loop till the total weight do not reach max limit e.g. 15 kg and till i<length     while limit <= max_weight and i < length:         # flag value for encountered greatest element in sorted_profit_by_weight         biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]         index = profit_by_weight.index(biggest_profit_by_weight)         profit_by_weight[index] = -1          # check if the weight encountered is less than the total weight         # encountered before.         if max_weight - limit >= weight[index]:             limit += weight[index]             # Adding profit gained for the given weight 1 ===             # weight[index]/weight[index]             gain += 1 * profit[index]         else:             # Since the weight encountered is greater than limit, therefore take the             # required number of remaining kgs and calculate profit for it.             # weight remaining / weight[index]             gain += (max_weight - limit) / weight[index] * profit[index]             break         i += 1     return gain\n1: def cocktail_shaker_sort(arr: list[int]) -> list[int]:     start, end = 0, len(arr) - 1      while start < end:         swapped = False          # Pass from left to right         for i in range(start, end):             if arr[i] > arr[i + 1]:                 arr[i], arr[i + 1] = arr[i + 1], arr[i]                 swapped = True          if not swapped:             break          end -= 1  # Decrease the end pointer after each pass          # Pass from right to left         for i in range(end, start, -1):             if arr[i] < arr[i - 1]:                 arr[i], arr[i - 1] = arr[i - 1], arr[i]                 swapped = True          if not swapped:             break          start += 1  # Increase the start pointer after each pass      return arr\n2: def check_direction(     starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int] ) -> Direction:     x0, y0 = starting     x1, y1 = via     x2, y2 = target     via_angle = degrees(atan2(y1 - y0, x1 - x0))     via_angle %= 360     target_angle = degrees(atan2(y2 - y0, x2 - x0))     target_angle %= 360     # t-     #  \\ \\     #   \\ v     #    \\|     #     s     # via_angle is always lower than target_angle, if direction is left.     # If they are same, it means they are on a same line of convex hull.     if target_angle > via_angle:         return Direction.left     elif target_angle == via_angle:         return Direction.straight     else:         return Direction.right", "output": "1"}
{"task": "search", "input": "search code:\nFind the winner of the Josephus problem for num_people and a step_size.\n\nChoices:\n0: def find_winner(num_people: int, step_size: int) -> int:     return josephus_recursive(num_people, step_size) + 1\n1: def clear_bit(number: int, position: int) -> int:     return number & ~(1 << position)\n2: def slow_reversible_numbers(     remaining_length: int, remainder: int, digits: list[int], length: int ) -> int:     if remaining_length == 0:         if digits[0] == 0 or digits[-1] == 0:             return 0          for i in range(length // 2 - 1, -1, -1):             remainder += digits[i] + digits[length - i - 1]              if remainder % 2 == 0:                 return 0              remainder //= 10          return 1      if remaining_length == 1:         if remainder % 2 == 0:             return 0          result = 0         for digit in range(10):             digits[length // 2] = digit             result += slow_reversible_numbers(                 0, (remainder + 2 * digit) // 10, digits, length             )         return result      result = 0     for digit1 in range(10):         digits[(length + remaining_length) // 2 - 1] = digit1          if (remainder + digit1) % 2 == 0:             other_parity_digits = ODD_DIGITS         else:             other_parity_digits = EVEN_DIGITS          for digit2 in other_parity_digits:             digits[(length - remaining_length) // 2] = digit2             result += slow_reversible_numbers(                 remaining_length - 2,                 (remainder + digit1 + digit2) // 10,                 digits,                 length,             )     return result", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef split(string: str, seperator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values seperated by the seperator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",seperator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",seperator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",seperator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == seperator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "tests": ["assert split(\"apple#banana#cherry#orange\",separator='#') == ['apple', 'banana', 'cherry', 'orange']", "assert split(\"Hello there\") == ['Hello', 'there']", "assert split(\"11/22/63\",separator = '/') == ['11', '22', '63']", "assert split(\"12:43:39\",separator = \":\") == ['12', '43', '39']"]}
{"task": "summary", "input": "summarize code:\ndef padded(iterable, fillvalue=None, n=None, next_multiple=False):\n    iterator = iter(iterable)\n    iterator_with_repeat = chain(iterator, repeat(fillvalue))\n\n    if n is None:\n        return iterator_with_repeat\n    elif n < 1:\n        raise ValueError('n must be at least 1')\n    elif next_multiple:\n\n        def slice_generator():\n            for first in iterator:\n                yield (first,)\n                yield islice(iterator_with_repeat, n - 1)\n\n        # While elements exist produce slices of size n\n        return chain.from_iterable(slice_generator())\n    else:\n        # Ensure the first batch is at least size n then iterate\n        return chain(islice(iterator_with_repeat, n), iterator)", "output": "Yield the elements from *iterable*, followed by *fillvalue*, such that"}
{"task": "summary", "input": "summarize code:\ndef capacitor_parallel(capacitors: list[float]) -> float:\n    sum_c = 0.0\n    for index, capacitor in enumerate(capacitors):\n        if capacitor < 0:\n            msg = f\"Capacitor at index {index} has a negative value!\"\n            raise ValueError(msg)\n        sum_c += capacitor\n    return sum_c", "output": "Ceq = C1 + C2 + ... + Cn"}
{"task": "detection", "input": "classify code:\ndef least_common_multiple_slow(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n\n    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple\n\n    >>> least_common_multiple_slow(5, 2)\n    10\n    >>> least_common_multiple_slow(12, 76)\n    228\n    \"\"\"\n    max_num = first_num if first_num >= second_num else second_num\n    common_mult = max_num\n    while (common_mult % first_num > 0) or (common_mult % second_num > 0):\n        common_mult += max_num\n    return common_mult", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(num_digits: int = 100) -> int:\n    return non_bouncy_upto(num_digits)", "output": "Calculate the number of non-bouncy numbers less than a googol."}
{"task": "detection", "input": "classify code:\ndef excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer", "output": "BUGGY"}
{"task": "search", "input": "search code:\nShifts all columns leftward when an entire column becomes empty.\n\nChoices:\n0: def camel_to_snake_case(input_str: str) -> str:      # check for invalid input type     if not isinstance(input_str, str):         msg = f\"Expected string as input, found {type(input_str)}\"         raise ValueError(msg)      snake_str = \"\"      for index, char in enumerate(input_str):         if char.isupper():             snake_str += \"_\" + char.lower()          # if char is lowercase but proceeded by a digit:         elif input_str[index - 1].isdigit() and char.islower():             snake_str += \"_\" + char          # if char is a digit proceeded by a letter:         elif input_str[index - 1].isalpha() and char.isnumeric():             snake_str += \"_\" + char.lower()          # if char is not alphanumeric:         elif not char.isalnum():             snake_str += \"_\"          else:             snake_str += char      # remove leading underscore     if snake_str[0] == \"_\":         snake_str = snake_str[1:]      return snake_str\n1: def largest_rectangle_area(heights: list[int]) -> int:     stack: list[int] = []     max_area = 0     heights = [*heights, 0]  # make a new list by appending the sentinel 0     n = len(heights)      for i in range(n):         # make sure the stack remains in increasing order         while stack and heights[i] < heights[stack[-1]]:             h = heights[stack.pop()]  # height of the bar             # if stack is empty, it means entire width can be taken from index 0 to i-1             w = i if not stack else i - stack[-1] - 1  # calculate width             max_area = max(max_area, h * w)          stack.append(i)      return max_area\n2: def move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:      empty_columns = []      for column in range(size - 1, -1, -1):         if all(matrix_g[row][column] == \"-\" for row in range(size)):             empty_columns.append(column)      for column in empty_columns:         for col in range(column + 1, size):             for row in range(size):                 matrix_g[row][col - 1] = matrix_g[row][col]         for row in range(size):             matrix_g[row][-1] = \"-\"      return matrix_g", "output": "2"}
{"task": "search", "input": "search code:\nPure implementation of Tabu search algorithm for a Travelling Salesman Problem in\n\nChoices:\n0: def compress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         add_key_to_lexicon(lexicon, curr_string, index, last_match_id)         index += 1         curr_string = \"\"      while curr_string != \"\" and curr_string not in lexicon:         curr_string += \"0\"      if curr_string != \"\":         last_match_id = lexicon[curr_string]         result += last_match_id      return result\n1: def tabu_search(     first_solution, distance_of_first_solution, dict_of_neighbours, iters, size ):     count = 1     solution = first_solution     tabu_list = []     best_cost = distance_of_first_solution     best_solution_ever = solution      while count <= iters:         neighborhood = find_neighborhood(solution, dict_of_neighbours)         index_of_best_solution = 0         best_solution = neighborhood[index_of_best_solution]         best_cost_index = len(best_solution) - 1          found = False         while not found:             i = 0             while i < len(best_solution):                 if best_solution[i] != solution[i]:                     first_exchange_node = best_solution[i]                     second_exchange_node = solution[i]                     break                 i = i + 1              if [first_exchange_node, second_exchange_node] not in tabu_list and [                 second_exchange_node,                 first_exchange_node,             ] not in tabu_list:                 tabu_list.append([first_exchange_node, second_exchange_node])                 found = True                 solution = best_solution[:-1]                 cost = neighborhood[index_of_best_solution][best_cost_index]                 if cost < best_cost:                     best_cost = cost                     best_solution_ever = solution             else:                 index_of_best_solution = index_of_best_solution + 1                 best_solution = neighborhood[index_of_best_solution]          if len(tabu_list) >= size:             tabu_list.pop(0)          count = count + 1      return best_solution_ever, best_cost\n2: def main() -> None:     trees = {\"zero\": Node(0), \"seven\": make_tree_seven(), \"nine\": make_tree_nine()}     for name, tree in trees.items():         print(f\"      The {name} tree: {tuple(tree)}\")         # (0,)         # (4, 2, 5, 1, 6, 3, 7)         # (7, 4, 8, 2, 5, 9, 1, 3, 6)         print(f\"Mirror of {name} tree: {tuple(tree.mirror())}\")", "output": "1"}
{"task": "search", "input": "search code:\nPerform linear search in list. Returns -1 if element is not found.\n\nChoices:\n0: def convex_hull_recursive(points: list[Point]) -> list[Point]:     points = sorted(_validate_input(points))     n = len(points)      # divide all the points into an upper hull and a lower hull     # the left most point and the right most point are definitely     # members of the convex hull by definition.     # use these two anchors to divide all the points into two hulls,     # an upper hull and a lower hull.      # all points to the left (above) the line joining the extreme points belong to the     # upper hull     # all points to the right (below) the line joining the extreme points below to the     # lower hull     # ignore all points on the line joining the extreme points since they cannot be     # part of the convex hull      left_most_point = points[0]     right_most_point = points[n - 1]      convex_set = {left_most_point, right_most_point}     upper_hull = []     lower_hull = []      for i in range(1, n - 1):         det = _det(left_most_point, right_most_point, points[i])          if det > 0:             upper_hull.append(points[i])         elif det < 0:             lower_hull.append(points[i])      _construct_hull(upper_hull, left_most_point, right_most_point, convex_set)     _construct_hull(lower_hull, right_most_point, left_most_point, convex_set)      return sorted(convex_set)\n1: def partition(arr: list[int], low: int, high: int) -> int:     pivot = arr[high]     i = low - 1     for j in range(low, high):         if arr[j] >= pivot:             i += 1             arr[i], arr[j] = arr[j], arr[i]     arr[i + 1], arr[high] = arr[high], arr[i + 1]     return i + 1\n2: def lin_search(left: int, right: int, array: list[int], target: int) -> int:     for i in range(left, right):         if array[i] == target:             return i     return -1", "output": "2"}
{"task": "search", "input": "search code:\nExtend suppressed units (if any) with all units lower than the minimum unit.\n\nChoices:\n0: def draw_cross(x: float, y: float, length: float):     turtle.up()     turtle.goto(x - length / 2, y - length / 6)     turtle.down()     turtle.seth(0)     turtle.begin_fill()     for _ in range(4):         turtle.fd(length / 3)         turtle.right(90)         turtle.fd(length / 3)         turtle.left(90)         turtle.fd(length / 3)         turtle.left(90)     turtle.end_fill()\n1: def _suppress_lower_units(min_unit, suppress):     suppress = set(suppress)     for u in Unit:         if u == min_unit:             break         suppress.add(u)      return suppress\n2: def left_rotate_32(i: int, shift: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")     if shift < 0:         raise ValueError(\"Shift must be non-negative\")     return ((i << shift) ^ (i >> (32 - shift))) % 2**32", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    result = list(map(\"\".join, permutations(\"0123456789\")))\n    return result[999999]", "output": "Returns the millionth lexicographic permutation of the digits 0, 1, 2,"}
{"task": "search", "input": "search code:\nReturns the number of paths possible in a n x n grid starting at top left\n\nChoices:\n0: def solution(n: int = 20) -> int:     n = 2 * n  # middle entry of odd rows starting at row 3 is the solution for n = 1,     # 2, 3,...     k = n // 2      return int(factorial(n) / (factorial(k) * factorial(n - k)))\n1: def shell_sort(collection: list) -> list:      # Choose an initial gap value     gap = len(collection)      # Set the gap value to be decreased by a factor of 1.3     # after each iteration     shrink = 1.3      # Continue sorting until the gap is 1     while gap > 1:         # Decrease the gap value         gap = int(gap / shrink)          # Sort the elements using insertion sort         for i in range(gap, len(collection)):             temp = collection[i]             j = i             while j >= gap and collection[j - gap] > temp:                 collection[j] = collection[j - gap]                 j -= gap             collection[j] = temp      return collection\n2: def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:     if not nums1 and not nums2:         raise ValueError(\"Both input arrays are empty.\")      # Merge the arrays into a single sorted array.     merged = sorted(nums1 + nums2)     total = len(merged)      if total % 2 == 1:  # If the total number of elements is odd         return float(merged[total // 2])  # then return the middle element      # If the total number of elements is even, calculate     # the average of the two middle elements as the median.     middle1 = merged[total // 2 - 1]     middle2 = merged[total // 2]     return (float(middle1) + float(middle2)) / 2.0", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef check(binary: List[str]) -> List[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))", "output": "def check(binary: list[str]) -> list[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))", "tests": ["assert check(['0.00.01.5']) == ['0.00.01.5']"]}
{"task": "search", "input": "search code:\nGenerate a gon_side-gon ring from a permutation state\n\nChoices:\n0: def duplicates_everseen(iterable, key=None):     seen_set = set()     seen_list = []     use_key = key is not None      for element in iterable:         k = key(element) if use_key else element         try:             if k not in seen_set:                 seen_set.add(k)             else:                 yield element         except TypeError:             if k not in seen_list:                 seen_list.append(k)             else:                 yield element\n1: def gaussian_elimination(     coefficients: NDArray[float64], vector: NDArray[float64] ) -> NDArray[float64]:     # coefficients must to be a square matrix so we need to check first     rows, columns = np.shape(coefficients)     if rows != columns:         return np.array((), dtype=float)      # augmented matrix     augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)     augmented_mat = augmented_mat.astype(\"float64\")      # scale the matrix leaving it triangular     for row in range(rows - 1):         pivot = augmented_mat[row, row]         for col in range(row + 1, columns):             factor = augmented_mat[col, row] / pivot             augmented_mat[col, :] -= factor * augmented_mat[row, :]      x = retroactive_resolution(         augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]     )      return x\n2: def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:     result = [0] * (gon_side * 3)     result[0:3] = perm[0:3]     perm.append(perm[1])      magic_number = 1 if gon_side < 5 else 2      for i in range(1, len(perm) // 3 + magic_number):         result[3 * i] = perm[2 * i + 1]         result[3 * i + 1] = result[3 * i - 1]         result[3 * i + 2] = perm[2 * i + 2]      return result", "output": "2"}
{"task": "detection", "input": "classify code:\ndef stalin_sort(sequence: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Stalin sort algorithm.\n\n    >>> stalin_sort([4, 3, 5, 2, 1, 7])\n    [4, 5, 7]\n\n    >>> stalin_sort([1, 2, 3, 4])\n    [1, 2, 3, 4]\n\n    >>> stalin_sort([4, 5, 5, 2, 3])\n    [4, 5, 5]\n\n    >>> stalin_sort([6, 11, 12, 4, 1, 5])\n    [6, 11, 12]\n\n    >>> stalin_sort([5, 0, 4, 3])\n    [5]\n\n    >>> stalin_sort([5, 4, 3, 2, 1])\n    [5]\n\n    >>> stalin_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> stalin_sort([1, 2, 8, 7, 6])\n    [1, 2, 8]\n    \"\"\"\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef lower(word: str) -> str:\n    \"\"\"\n    Will convert the entire string to lowercase letters\n\n    >>> lower(\"wow\")\n    'wow'\n    >>> lower(\"HellZo\")\n    'hellzo'\n    >>> lower(\"WHAT\")\n    'what'\n    >>> lower(\"wh[]32\")\n    'wh[]32'\n    >>> lower(\"whAT\")\n    'what'\n    \"\"\"\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)", "output": "def lower(word: str) -> str:\n    \"\"\"\n    Will convert the entire string to lowercase letters\n\n    >>> lower(\"wow\")\n    'wow'\n    >>> lower(\"HellZo\")\n    'hellzo'\n    >>> lower(\"WHAT\")\n    'what'\n    >>> lower(\"wh[]32\")\n    'wh[]32'\n    >>> lower(\"whAT\")\n    'what'\n    \"\"\"\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)", "tests": ["assert lower(\"wow\") == 'wow'", "assert lower(\"HellZo\") == 'hellzo'", "assert lower(\"WHAT\") == 'what'", "assert lower(\"wh[]32\") == 'wh[]32'", "assert lower(\"whAT\") == 'what'"]}
{"task": "detection", "input": "classify code:\ndef is_palindrome(s):\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    \"\"\"\n    return s == s[::-1]", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef lomuto_partition(sorting: list, left: int, right: int) -> int:\n    \"\"\"\n    Example:\n    >>> lomuto_partition([1,5,7,6], 0, 3)\n    2\n    \"\"\"\n    pivot = sorting[right]\n    store_index = left\n    for i in range(left, right):\n        if sorting[i] < pivot:\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\n            store_index += 1\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\n    return store_index", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the difference between the sum of the squares of the first n\n\nChoices:\n0: def split_format_str(fstr):     ret = []      for lit, fname, fspec, conv in Formatter().parse(fstr):         if fname is None:             ret.append((lit, None))             continue         field_str = construct_format_field_str(fname, fspec, conv)         ret.append((lit, field_str))     return ret\n1: def solution(n: int = 100) -> int:      sum_of_squares = n * (n + 1) * (2 * n + 1) / 6     square_of_sum = (n * (n + 1) / 2) ** 2     return int(square_of_sum - sum_of_squares)\n2: def format_exception_only(etype, value):     # Gracefully handle (the way Python 2.4 and earlier did) the case of     # being called with (None, None).     if etype is None:         return [_format_final_exc_line(etype, value)]      stype = etype.__name__     smod = etype.__module__     if smod not in (\"__main__\", \"builtins\", \"exceptions\"):         stype = smod + '.' + stype      if not issubclass(etype, SyntaxError):         return [_format_final_exc_line(stype, value)]      # It was a syntax error; show exactly where the problem was found.     lines = []     filename = value.filename or \"<string>\"     lineno = str(value.lineno) or '?'     lines.append(f'  File \"{filename}\", line {lineno}\\n')     badline = value.text     offset = value.offset     if badline is not None:         lines.append('    %s\\n' % badline.strip())         if offset is not None:             caretspace = badline.rstrip('\\n')[:offset].lstrip()             # non-space whitespace (likes tabs) must be kept for alignment             caretspace = ((c.isspace() and c or ' ') for c in caretspace)             # only three spaces to account for offset1 == pos 0             lines.append('   %s^\\n' % ''.join(caretspace))     msg = value.msg or \"<no detail available>\"     lines.append(f\"{stype}: {msg}\\n\")     return lines", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef save_image(image_url: str, image_title: str) -> None:\n    image = httpx.get(image_url, headers=headers, timeout=10)\n    with open(image_title, \"wb\") as file:\n        file.write(image.content)", "output": "Saves the image of anime character"}
{"task": "repair", "input": "fix bug:\ndef peak(lst: List[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])", "output": "def peak(lst: list[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])", "tests": ["assert peak([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5", "assert peak([1, 10, 9, 8, 7, 6, 5, 4]) == 10", "assert peak([1, 9, 8, 7]) == 9", "assert peak([1, 2, 3, 4, 5, 6, 7, 0]) == 7", "assert peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2]) == 4"]}
{"task": "summary", "input": "summarize code:\ndef split_and_add(number: int) -> int:\n    sum_of_digits = 0\n    while number > 0:\n        last_digit = number % 10\n        sum_of_digits += last_digit\n        number = number // 10  # Removing the last_digit from the given number\n    return sum_of_digits", "output": "Split number digits and add them."}
{"task": "summary", "input": "summarize code:\ndef base64_decode(encoded_data: str) -> bytes:\n    # Make sure encoded_data is either a string or a bytes-like object\n    if not isinstance(encoded_data, bytes) and not isinstance(encoded_data, str):\n        msg = (\n            \"argument should be a bytes-like object or ASCII string, \"\n            f\"not '{encoded_data.__class__.__name__}'\"\n        )\n        raise TypeError(msg)\n\n    # In case encoded_data is a bytes-like object, make sure it contains only\n    # ASCII characters so we convert it to a string object\n    if isinstance(encoded_data, bytes):\n        try:\n            encoded_data = encoded_data.decode(\"utf-8\")\n        except UnicodeDecodeError:\n            raise ValueError(\"base64 encoded data should only contain ASCII characters\")\n\n    padding = encoded_data.count(\"=\")\n\n    # Check if the encoded string contains non base64 characters\n    if padding:\n        assert all(char in B64_CHARSET for char in encoded_data[:-padding]), (\n            \"Invalid base64 character(s) found.\"\n        )\n    else:\n        assert all(char in B64_CHARSET for char in encoded_data), (\n            \"Invalid base64 character(s) found.\"\n        )\n\n    # Check the padding\n    assert len(encoded_data) % 4 == 0 and padding < 3, \"Incorrect padding\"\n\n    if padding:\n        # Remove padding if there is one\n        encoded_data = encoded_data[:-padding]\n\n        binary_stream = \"\".join(\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\n        )[: -padding * 2]\n    else:\n        binary_stream = \"\".join(\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\n        )\n\n    data = [\n        int(binary_stream[index : index + 8], 2)\n        for index in range(0, len(binary_stream), 8)\n    ]\n\n    return bytes(data)", "output": "Decodes data according to RFC4648."}
{"task": "search", "input": "search code:\nTo evaluate the sum, Used decimal python module to calculate the decimal\n\nChoices:\n0: def main() -> None:     img_paths, annos = get_dataset(LABEL_DIR, IMAGE_DIR)     print(\"Processing...\")     new_images, new_annos, paths = update_image_and_anno(img_paths, annos, FLIP_TYPE)      for index, image in enumerate(new_images):         # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'         letter_code = random_chars(32)         file_name = paths[index].split(os.sep)[-1].rsplit(\".\", 1)[0]         file_root = f\"{OUTPUT_DIR}/{file_name}_FLIP_{letter_code}\"         cv2.imwrite(f\"{file_root}.jpg\", image, [cv2.IMWRITE_JPEG_QUALITY, 85])         print(f\"Success {index + 1}/{len(new_images)} with {file_name}\")         annos_list = []         for anno in new_annos[index]:             obj = f\"{anno[0]} {anno[1]} {anno[2]} {anno[3]} {anno[4]}\"             annos_list.append(obj)         with open(f\"{file_root}.txt\", \"w\") as outfile:             outfile.write(\"\\n\".join(line for line in annos_list))\n1: def solution() -> int:     answer = 0     decimal_context = decimal.Context(prec=105)     for i in range(2, 100):         number = decimal.Decimal(i)         sqrt_number = number.sqrt(decimal_context)         if len(str(sqrt_number)) > 1:             answer += int(str(sqrt_number)[0])             sqrt_number_str = str(sqrt_number)[2:101]             answer += sum(int(x) for x in sqrt_number_str)     return answer\n2: def evaluate(expression):     stack = []      # iterate over the string in reverse order     for c in expression.split()[::-1]:         # push operand to stack         if is_operand(c):             stack.append(int(c))          else:             # pop values from stack can calculate the result             # push the result onto the stack again             o1 = stack.pop()             o2 = stack.pop()             stack.append(operators[c](o1, o2))      return stack.pop()", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 100) -> int:\n    singles: list[int] = [*list(range(1, 21)), 25]\n    doubles: list[int] = [2 * x for x in range(1, 21)] + [50]\n    triples: list[int] = [3 * x for x in range(1, 21)]\n    all_values: list[int] = singles + doubles + triples + [0]\n\n    num_checkouts: int = 0\n    double: int\n    throw1: int\n    throw2: int\n    checkout_total: int\n\n    for double in doubles:\n        for throw1, throw2 in combinations_with_replacement(all_values, 2):\n            checkout_total = double + throw1 + throw2\n            if checkout_total < limit:\n                num_checkouts += 1\n\n    return num_checkouts", "output": "Count the number of distinct ways a player can checkout with a score"}
{"task": "summary", "input": "summarize code:\ndef minimum_cost_path(matrix: list[list[int]]) -> int:\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]", "output": "Find the minimum cost traced by all possible paths from top left to bottom right in"}
{"task": "search", "input": "search code:\nReverses words in a given string\n\nChoices:\n0: def pluralize(word):     orig_word, word = word, word.strip().lower()     if not word or word in _IRR_P2S:         return orig_word     irr_plural = _IRR_S2P.get(word)     if irr_plural:         plural = irr_plural     elif word.endswith('y') and word[-2:-1] not in 'aeiou':         plural = word[:-1] + 'ies'     elif word[-1] == 's' or word.endswith('ch') or word.endswith('sh'):         plural = word if word.endswith('es') else word + 'es'     else:         plural = word + 's'     return _match_case(orig_word, plural)\n1: def reverse_words(input_str: str) -> str:     return \" \".join(input_str.split()[::-1])\n2: def validate_initial_digits(credit_card_number: str) -> bool:     return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_filter_points(\n    sample_rate: int,\n    freq_min: int,\n    freq_high: int,\n    mel_filter_num: int = 10,\n    ftt_size: int = 1024,\n) -> tuple[np.ndarray, np.ndarray]:\n    # Convert minimum and maximum frequencies to mel scale\n    fmin_mel = freq_to_mel(freq_min)\n    fmax_mel = freq_to_mel(freq_high)\n\n    logging.info(f\"MEL min: {fmin_mel}\")\n    logging.info(f\"MEL max: {fmax_mel}\")\n\n    # Generate equally spaced mel frequencies\n    mels = np.linspace(fmin_mel, fmax_mel, num=mel_filter_num + 2)\n\n    # Convert mel frequencies back to Hertz\n    freqs = mel_to_freq(mels)\n\n    # Calculate filter points as integer values\n    filter_points = np.floor((ftt_size + 1) / sample_rate * freqs).astype(int)\n\n    return filter_points, freqs", "output": "Calculate the filter points and frequencies for mel frequency filters."}
{"task": "repair", "input": "fix bug:\ndef max_sub_array(nums: List[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best", "output": "def max_sub_array(nums: list[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best", "tests": ["assert max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6", "assert max_sub_array([]) == 0", "assert max_sub_array([-1, -2, -3]) == 0", "assert max_sub_array([5, -2, -3]) == 5", "assert max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84]) == 187"]}
{"task": "summary", "input": "summarize code:\ndef unique(iterable, key=None, reverse=False):\n    sequenced = sorted(iterable, key=key, reverse=reverse)\n    return unique_justseen(sequenced, key=key)", "output": "Yields unique elements in sorted order."}
{"task": "summary", "input": "summarize code:\ndef generate_images(cells: list[list[int]], frames: int) -> list[Image.Image]:\n    images = []\n    for _ in range(frames):\n        # Create output image\n        img = Image.new(\"RGB\", (len(cells[0]), len(cells)))\n        pixels = img.load()\n\n        # Save cells to image\n        for x in range(len(cells)):\n            for y in range(len(cells[0])):\n                colour = 255 - cells[y][x] * 255\n                pixels[x, y] = (colour, colour, colour)\n\n        # Save image\n        images.append(img)\n        cells = new_generation(cells)\n    return images", "output": "Generates a list of images of subsequent Game of Life states."}
{"task": "summary", "input": "summarize code:\ndef binomial_coefficient(n: int, r: int) -> int:\n    if n < 0 or r < 0:\n        raise ValueError(\"n and r must be non-negative integers\")\n    if 0 in (n, r):\n        return 1\n    c = [0 for i in range(r + 1)]\n    # nc0 = 1\n    c[0] = 1\n    for i in range(1, n + 1):\n        # to compute current row from previous row.\n        j = min(i, r)\n        while j > 0:\n            c[j] += c[j - 1]\n            j -= 1\n    return c[r]", "output": "Find binomial coefficient using Pascal's triangle."}
{"task": "search", "input": "search code:\nOpening filter, defined as the sequence of\n\nChoices:\n0: def solution(n: int = 600851475143) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     prime = 1     i = 2     while i * i <= n:         while n % i == 0:             prime = i             n //= i         i += 1     if n > 1:         prime = n     return int(prime)\n1: def unique_in_window(iterable, n, key=None):     if n <= 0:         raise ValueError('n must be greater than 0')      window = deque(maxlen=n)     counts = Counter()     use_key = key is not None      for item in iterable:         if len(window) == n:             to_discard = window[0]             if counts[to_discard] == 1:                 del counts[to_discard]             else:                 counts[to_discard] -= 1          k = key(item) if use_key else item         if k not in counts:             yield item         counts[k] += 1         window.append(k)\n2: def opening_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:     if kernel is None:         np.ones((3, 3))      return transform(transform(image, \"dilation\", kernel), \"erosion\", kernel)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef decrypt(ciphertext: str, key: str) -> str:\n    if not isinstance(ciphertext, str):\n        raise TypeError(\"ciphertext must be a string\")\n    if not isinstance(key, str):\n        raise TypeError(\"key must be a string\")\n\n    if not ciphertext:\n        raise ValueError(\"ciphertext is empty\")\n    if not key:\n        raise ValueError(\"key is empty\")\n\n    key = key.lower()\n    ciphertext_iterator = 0\n    key_iterator = 0\n    plaintext = \"\"\n    while ciphertext_iterator < len(ciphertext):\n        if (\n            ord(ciphertext[ciphertext_iterator]) < 97\n            or ord(ciphertext[ciphertext_iterator]) > 122\n        ):\n            plaintext += ciphertext[ciphertext_iterator]\n        else:\n            plaintext += chr(\n                (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26\n                + 97\n            )\n            key += chr(\n                (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26\n                + 97\n            )\n            key_iterator += 1\n        ciphertext_iterator += 1\n    return plaintext", "output": "Decrypt a given `ciphertext` (string) and `key` (string), returning the decrypted"}
{"task": "summary", "input": "summarize code:\ndef run_length_encode(text: str) -> list:\n    encoded = []\n    count = 1\n\n    for i in range(len(text)):\n        if i + 1 < len(text) and text[i] == text[i + 1]:\n            count += 1\n        else:\n            encoded.append((text[i], count))\n            count = 1\n\n    return encoded", "output": "Performs Run Length Encoding"}
{"task": "repair", "input": "fix bug:\ndef sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32", "output": "def sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32", "tests": ["assert sum_32(1, 1) == 2", "assert sum_32(2, 3) == 5", "assert sum_32(0, 0) == 0", "assert sum_32(-1, -1) == 4294967294", "assert sum_32(4294967295, 1) == 0"]}
{"task": "search", "input": "search code:\nChecks if a combination (a tuple of 9 digits)\n\nChoices:\n0: def is_combination_valid(combination):     return (         int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))         == int(\"\".join(combination[5:9]))     ) or (         int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))         == int(\"\".join(combination[5:9]))     )\n1: def union_set(x: Node, y: Node) -> None:     x, y = find_set(x), find_set(y)     if x == y:         return      elif x.rank > y.rank:         y.parent = x     else:         x.parent = y         if x.rank == y.rank:             y.rank += 1\n2: def pheromone_update(     pheromone: list[list[float]],     cities: dict[int, list[int]],     pheromone_evaporation: float,     ants_route: list[list[int]],     q: float,  # Pheromone system parameters Q, which is a constant     best_path: list[int],     best_distance: float, ) -> tuple[list[list[float]], list[int], float]:     for a in range(len(cities)):  # Update the volatilization of pheromone on all routes         for b in range(len(cities)):             pheromone[a][b] *= pheromone_evaporation     for ant_route in ants_route:         total_distance = 0.0         for i in range(len(ant_route) - 1):  # Calculate total distance             total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])         delta_pheromone = q / total_distance         for i in range(len(ant_route) - 1):  # Update pheromones             pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone             pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][                 ant_route[i + 1]             ]          if total_distance < best_distance:             best_path = ant_route             best_distance = total_distance      return pheromone, best_path, best_distance", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef data_safety_checker(list_vote: list, actual_result: float) -> None:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2,3,4],5.0)\n    Today's data is not safe.\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe = safe + 1\n            else:\n                not_safe = not_safe + 1\n    print(f\"Today's data is {'not ' if safe <= not_safe else ''}safe.\")", "output": "def data_safety_checker(list_vote: list, actual_result: float) -> bool:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2, 3, 4], 5.0)\n    False\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe += 1\n            else:\n                not_safe += 1\n    return safe > not_safe", "tests": ["assert data_safety_checker([2, 3, 4], 5.0) == False"]}
{"task": "detection", "input": "classify code:\ndef kth_permutation(k, n):\n    \"\"\"\n    Finds k'th lexicographic permutation (in increasing order) of\n    0,1,2,...n-1 in O(n^2) time.\n\n    Examples:\n    First permutation is always 0,1,2,...n\n    >>> kth_permutation(0,5)\n    [0, 1, 2, 3, 4]\n\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n    [1,2,3,0], [1,3,0,2]\n    >>> kth_permutation(10,4)\n    [1, 3, 0, 2]\n    \"\"\"\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef lowest_common_ancestor(\n    u: int, v: int, level: list[int], parent: list[list[int]]\n) -> int:\n    # u must be deeper in the tree than v\n    if level[u] < level[v]:\n        u, v = swap(u, v)\n    # making depth of u same as depth of v\n    for i in range(18, -1, -1):\n        if level[u] - (1 << i) >= level[v]:\n            u = parent[i][u]\n    # at the same depth if u==v that mean lca is found\n    if u == v:\n        return u\n    # moving both nodes upwards till lca in found\n    for i in range(18, -1, -1):\n        if parent[i][u] not in [0, parent[i][v]]:\n            u, v = parent[i][u], parent[i][v]\n    # returning longest common ancestor of u,v\n    return parent[0][u]", "output": "Return the lowest common ancestor between u and v"}
{"task": "repair", "input": "fix bug:\ndef is_palindrome(n: Union[int, str]) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False", "output": "def is_palindrome(n: int | str) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False", "tests": ["assert is_palindrome(909) == True", "assert is_palindrome(908) == False", "assert is_palindrome('10101') == True", "assert is_palindrome('10111') == False"]}
{"task": "search", "input": "search code:\nYield the items from *iterable* for which the *validator* function does\n\nChoices:\n0: def solve(nums: list[int], goal: int, depth: int) -> bool:     if len(nums) > depth:         return False     for el in nums:         if el + nums[-1] == goal:             return True         nums.append(el + nums[-1])         if solve(nums=nums, goal=goal, depth=depth):             return True         del nums[-1]     return False\n1: def get_bit(number: int, position: int) -> int:     return int((number & (1 << position)) != 0)\n2: def filter_except(validator, iterable, *exceptions):     for item in iterable:         try:             validator(item)         except exceptions:             pass         else:             yield item", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef trapezoidal_rule(boundary, steps):\n    h = (boundary[1] - boundary[0]) / steps\n    a = boundary[0]\n    b = boundary[1]\n    x_i = make_points(a, b, h)\n    y = 0.0\n    y += (h / 2.0) * f(a)\n    for i in x_i:\n        y += h * f(i)\n    y += (h / 2.0) * f(b)\n    return y", "output": "Implements the extended trapezoidal rule for numerical integration."}
{"task": "repair", "input": "fix bug:\ndef get_pascal_triangle_unique_coefficients(depth: int) -> Set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients", "output": "def get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients", "tests": ["assert get_pascal_triangle_unique_coefficients(1) == {1}", "assert get_pascal_triangle_unique_coefficients(2) == {1}", "assert get_pascal_triangle_unique_coefficients(3) == {1, 2}", "assert get_pascal_triangle_unique_coefficients(8) == {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}"]}
{"task": "search", "input": "search code:\nReturns a list with all prime numbers up to n.\n\nChoices:\n0: def prime_sieve(num: int) -> list[int]:      if num <= 0:         msg = f\"{num}: Invalid input, please enter a positive integer.\"         raise ValueError(msg)      sieve = [True] * (num + 1)     prime = []     start = 2     end = int(math.sqrt(num))      while start <= end:         # If start is a prime         if sieve[start] is True:             prime.append(start)              # Set multiples of start be False             for i in range(start * start, num + 1, start):                 if sieve[i] is True:                     sieve[i] = False          start += 1      for j in range(end + 1, num + 1):         if sieve[j] is True:             prime.append(j)      return prime\n1: def narcissistic_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False     expo = len(str(n))  # the power that all digits will be raised to     # check if sum of each digit multiplied expo times is equal to number     return n == sum(int(i) ** expo for i in str(n))\n2: def calculate_signal_power(audio_fft: np.ndarray) -> np.ndarray:     # Calculate the power by squaring the absolute values of the FFT coefficients     return np.square(np.abs(audio_fft))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef bell_numbers(max_set_length: int) -> list[int]:\n    if max_set_length < 0:\n        raise ValueError(\"max_set_length must be non-negative\")\n\n    bell = [0] * (max_set_length + 1)\n    bell[0] = 1\n\n    for i in range(1, max_set_length + 1):\n        for j in range(i):\n            bell[i] += _binomial_coefficient(i - 1, j) * bell[j]\n\n    return bell", "output": "Calculate Bell numbers for the sets of lengths from 0 to max_set_length."}
{"task": "detection", "input": "classify code:\ndef find_repeat(\n    matrix_g: list[list[str]], row: int, column: int, size: int\n) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all connected elements of the same type from a given position.\n\n    >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)\n    {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}\n    >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)\n    set()\n    \"\"\"\n\n    column = size - 1 - column\n    visited = set()\n    repeated = set()\n\n    if (color := matrix_g[column][row]) != \"-\":\n\n        def dfs(row_n: int, column_n: int) -> None:\n            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:\n                return\n            if (row_n, column_n) in visited:\n                return\n            visited.add((row_n, column_n))\n            if matrix_g[row_n][column_n] == color:\n                repeated.add((row_n, column_n))\n                dfs(row_n - 1, column_n)\n                dfs(row_n + 1, column_n)\n                dfs(row_n, column_n - 1)\n                dfs(row_n, column_n + 1)\n\n        dfs(column, row)\n\n    return repeated", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef power(base: int, exponent: int) -> float:\n    return base * power(base, (exponent - 1)) if exponent else 1", "output": "Calculate the power of a base raised to an exponent."}
{"task": "search", "input": "search code:\nThe `guess_the_number` function that guess the number by some operations\n\nChoices:\n0: def guess_the_number(lower: int, higher: int, to_guess: int) -> None:     assert (         isinstance(lower, int) and isinstance(higher, int) and isinstance(to_guess, int)     ), 'argument values must be type of \"int\"'      if lower > higher:         raise ValueError(\"argument value for lower and higher must be(lower > higher)\")      if not lower < to_guess < higher:         raise ValueError(             \"guess value must be within the range of lower and higher value\"         )      def answer(number: int) -> str:         if number > to_guess:             return \"high\"         elif number < to_guess:             return \"low\"         else:             return \"same\"      print(\"started...\")      last_lowest = lower     last_highest = higher      last_numbers = []      while True:         number = get_avg(last_lowest, last_highest)         last_numbers.append(number)          if answer(number) == \"low\":             last_lowest = number         elif answer(number) == \"high\":             last_highest = number         else:             break      print(f\"guess the number : {last_numbers[-1]}\")     print(f\"details : {last_numbers!s}\")\n1: def decrypt(input_string: str, key: int) -> str:     grid = []     lowest = key - 1      if key <= 0:         raise ValueError(\"Height of grid can't be 0 or negative\")     if key == 1:         return input_string      temp_grid: list[list[str]] = [[] for _ in range(key)]  # generates template     for position in range(len(input_string)):         num = position % (lowest * 2)  # puts it in bounds         num = min(num, lowest * 2 - num)  # creates zigzag pattern         temp_grid[num].append(\"*\")      counter = 0     for row in temp_grid:  # fills in the characters         splice = input_string[counter : counter + len(row)]         grid.append(list(splice))         counter += len(row)      output_string = \"\"  # reads as zigzag     for position in range(len(input_string)):         num = position % (lowest * 2)  # puts it in bounds         num = min(num, lowest * 2 - num)  # creates zigzag pattern         output_string += grid[num][0]         grid[num].pop(0)     return output_string\n2: def removeprefix(text: str, prefix: str) -> str:     if text.startswith(prefix):         return text[len(prefix):]     return text", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)", "output": "def sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)", "tests": ["assert sum_of_geometric_progression(1, 2, 10) == 1023.0", "assert sum_of_geometric_progression(1, 10, 5) == 11111.0", "assert sum_of_geometric_progression(0, 2, 10) == 0.0", "assert sum_of_geometric_progression(1, 0, 10) == 1.0", "assert sum_of_geometric_progression(1, 2, 0) == -0.0", "assert sum_of_geometric_progression(-1, 2, 10) == -1023.0", "assert sum_of_geometric_progression(1, -2, 10) == -341.0", "assert sum_of_geometric_progression(1, 2, -10) == -0.9990234375"]}
{"task": "summary", "input": "summarize code:\ndef under2camel(under_string):\n    return ''.join(w.capitalize() or '_' for w in under_string.split('_'))", "output": "Converts an underscored string to camelcased. Useful for turning a"}
{"task": "detection", "input": "classify code:\ndef real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor", "output": "BUGGY"}
{"task": "search", "input": "search code:\n:param a: The base (integer).\n\nChoices:\n0: def is_palindrome(n: int) -> bool:     if n % 10 == 0:         return False     s = str(n)     return s == s[::-1]\n1: def power(a: int, b: int) -> float:     if b < 0:         return 1 / actual_power(a, -b)     return actual_power(a, b)\n2: def _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:     if bit_position == 0 or len(list_of_ints) in [0, 1]:         return list_of_ints      zeros = []     ones = []     # Split numbers based on bit at bit_position from the right     for number in list_of_ints:         if (number >> (bit_position - 1)) & 1:             # number has a one at bit bit_position             ones.append(number)         else:             # number has a zero at bit bit_position             zeros.append(number)      # recursively split both lists further     zeros = _msd_radix_sort(zeros, bit_position - 1)     ones = _msd_radix_sort(ones, bit_position - 1)      # recombine lists     res = zeros     res.extend(ones)      return res", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef get_valid_pos(position: Tuple[int], n: int) -> List[Tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "def get_valid_pos(position: tuple[int], n: int) -> list[tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "tests": ["assert get_valid_pos((1, 3), 4) == [(2, 1), (0, 1), (3, 2)]"]}
{"task": "detection", "input": "classify code:\ndef median(nums):\n    \"\"\"Find median of a list of numbers.\"\"\"\n    # Sort list\n    sorted_list = sorted(nums)\n    print(\"List of numbers:\")\n    print(sorted_list)\n\n    # Is number of items in list even?\n    if len(sorted_list) % 2 == 0:\n        # Find index for first middle value.\n        mid_index_1 = len(sorted_list) / 2\n        # Find index for second middle value.\n        mid_index_2 = -(len(sorted_list) / 2) - 1\n        # Divide middle values by 2 to get average (mean).\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n        return med  # Return makes `else:` unnecessary.\n    # Number of items is odd.\n    mid_index = (len(sorted_list) - 1) / 2\n    # Middle index is median.\n    med = sorted_list[mid_index]\n    return med", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCheck if all characters in the string is unique or not.\n\nChoices:\n0: def is_contains_unique_chars(input_str: str) -> bool:      # Each bit will represent each unicode character     # For example 65th bit representing 'A'     # https://stackoverflow.com/a/12811293     bitmap = 0     for ch in input_str:         ch_unicode = ord(ch)         ch_bit_index_on = pow(2, ch_unicode)          # If we already turned on bit for current character's unicode         if bitmap >> ch_unicode & 1 == 1:             return False         bitmap |= ch_bit_index_on     return True\n1: def solution(n: int = 100) -> int:     collect_powers = set()      current_pow = 0      n = n + 1  # maximum limit      for a in range(2, n):         for b in range(2, n):             current_pow = a**b  # calculates the current power             collect_powers.add(current_pow)  # adds the result to the set     return len(collect_powers)\n2: def gamma_recursive(num: float) -> float:     if num <= 0:         raise ValueError(\"math domain error\")     if num > 171.5:         raise OverflowError(\"math range error\")     elif num - int(num) not in (0, 0.5):         raise NotImplementedError(\"num must be an integer or a half-integer\")     elif num == 0.5:         return math.sqrt(math.pi)     else:         return 1.0 if num == 1 else (num - 1) * gamma_recursive(num - 1)", "output": "0"}
{"task": "search", "input": "search code:\nGiven that a laser beam hits the interior of the white cell at point\n\nChoices:\n0: def next_point(     point_x: float, point_y: float, incoming_gradient: float ) -> tuple[float, float, float]:     # normal_gradient = gradient of line through which the beam is reflected     # outgoing_gradient = gradient of reflected line     normal_gradient = point_y / 4 / point_x     s2 = 2 * normal_gradient / (1 + normal_gradient * normal_gradient)     c2 = (1 - normal_gradient * normal_gradient) / (         1 + normal_gradient * normal_gradient     )     outgoing_gradient = (s2 - c2 * incoming_gradient) / (c2 + s2 * incoming_gradient)      # to find the next point, solve the simultaeneous equations:     # y^2 + 4x^2 = 100     # y - b = m * (x - a)     # ==> A x^2 + B x + C = 0     quadratic_term = outgoing_gradient**2 + 4     linear_term = 2 * outgoing_gradient * (point_y - outgoing_gradient * point_x)     constant_term = (point_y - outgoing_gradient * point_x) ** 2 - 100      x_minus = (         -linear_term - sqrt(linear_term**2 - 4 * quadratic_term * constant_term)     ) / (2 * quadratic_term)     x_plus = (         -linear_term + sqrt(linear_term**2 - 4 * quadratic_term * constant_term)     ) / (2 * quadratic_term)      # two solutions, one of which is our input point     next_x = x_minus if isclose(x_plus, point_x) else x_plus     next_y = point_y + outgoing_gradient * (next_x - point_x)      return next_x, next_y, outgoing_gradient\n1: def calculate_waiting_times(burst_times: list[int]) -> list[int]:     quantum = 2     rem_burst_times = list(burst_times)     waiting_times = [0] * len(burst_times)     t = 0     while True:         done = True         for i, burst_time in enumerate(burst_times):             if rem_burst_times[i] > 0:                 done = False                 if rem_burst_times[i] > quantum:                     t += quantum                     rem_burst_times[i] -= quantum                 else:                     t += rem_burst_times[i]                     waiting_times[i] = t - burst_time                     rem_burst_times[i] = 0         if done is True:             return waiting_times\n2: def cosine_similarity(input_a: np.ndarray, input_b: np.ndarray) -> float:     return float(np.dot(input_a, input_b) / (norm(input_a) * norm(input_b)))", "output": "0"}
{"task": "search", "input": "search code:\nReturn a tuple with two values.\n\nChoices:\n0: def get_rotation(     img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int ) -> np.ndarray:     matrix = cv2.getAffineTransform(pt1, pt2)     return cv2.warpAffine(img, matrix, (rows, cols))\n1: def _is_scalar(value, stringlike=(str, bytes)):     \"Scalars are bytes, strings, and non-iterables.\"     try:         iter(value)     except TypeError:         return True     return isinstance(value, stringlike)\n2: def _carry(value1, value2, ratio, unit, min_unit, suppress):     if unit == min_unit:         return (value1 + value2 / ratio, 0)     elif unit in suppress:         return (0, value2 + value1 * ratio)     else:         return (value1, value2)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column", "output": "def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column", "tests": ["assert get_point_key(10, 20, 1, 0) == 200"]}
{"task": "summary", "input": "summarize code:\ndef benchmark() -> None:\n    from timeit import timeit\n\n    print(\"Running benchmarks\")\n    setup = (\n        \"from __main__ import count_negatives_binary_search, \"\n        \"count_negatives_brute_force, count_negatives_brute_force_with_break, grid\"\n    )\n    for func in (\n        \"count_negatives_binary_search\",  # took 0.7727 seconds\n        \"count_negatives_brute_force_with_break\",  # took 4.6505 seconds\n        \"count_negatives_brute_force\",  # took 12.8160 seconds\n    ):\n        time = timeit(f\"{func}(grid=grid)\", setup=setup, number=500)\n        print(f\"{func}() took {time:0.4f} seconds\")", "output": "Benchmark our functions next to each other"}
{"task": "search", "input": "search code:\nFind Prime Factors.\n\nChoices:\n0: def is_palindrome(n: int | str) -> bool:     n = str(n)     return n == n[::-1]\n1: def prime_factors(n: int) -> list:     if n <= 0:         raise ValueError(\"Only positive integers have prime factors\")     pf = []     while n % 2 == 0:         pf.append(2)         n = int(n / 2)     for i in range(3, int(math.sqrt(n)) + 1, 2):         while n % i == 0:             pf.append(i)             n = int(n / i)     if n > 2:         pf.append(n)     return pf\n2: def softplus(vector: np.ndarray) -> np.ndarray:     return np.log(1 + np.exp(vector))", "output": "1"}
{"task": "search", "input": "search code:\nReturns the sum of n and reverse of n.\n\nChoices:\n0: def sum_reverse(n: int) -> int:     return int(n) + int(str(n)[::-1])\n1: def surface_area_cuboid(length: float, breadth: float, height: float) -> float:     if length < 0 or breadth < 0 or height < 0:         raise ValueError(\"surface_area_cuboid() only accepts non-negative values\")     return 2 * ((length * breadth) + (breadth * height) + (length * height))\n2: def linear_regression_prediction(     train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list ) -> float:     x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])     y = np.array(train_usr)     beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)     return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef effusion_ratio(molar_mass_1: float, molar_mass_2: float) -> float | ValueError:\n    return (\n        round(sqrt(molar_mass_2 / molar_mass_1), 6)\n        if validate(molar_mass_1, molar_mass_2)\n        else ValueError(\"Input Error: Molar mass values must greater than 0.\")\n    )", "output": "Input Parameters:"}
{"task": "search", "input": "search code:\nApproximates the arc length of a line segment by treating the curve as a\n\nChoices:\n0: def print_linked_list(head: Node | None) -> None:     if head is None:         return     while head.next_node is not None:         print(head.data, end=\"->\")         head = head.next_node     print(head.data)\n1: def line_length(     fnc: Callable[[float], float],     x_start: float,     x_end: float,     steps: int = 100, ) -> float:      x1 = x_start     fx1 = fnc(x_start)     length = 0.0      for _ in range(steps):         # Approximates curve as a sequence of linear lines and sums their length         x2 = (x_end - x_start) / steps + x1         fx2 = fnc(x2)         length += math.hypot(x2 - x1, fx2 - fx1)          # Increment step         x1 = x2         fx1 = fx2      return length\n2: def mf_knapsack(i, wt, val, j):     global f  # a global dp table for knapsack     if f[i][j] < 0:         if j < wt[i - 1]:             val = mf_knapsack(i - 1, wt, val, j)         else:             val = max(                 mf_knapsack(i - 1, wt, val, j),                 mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],             )         f[i][j] = val     return f[i][j]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef trapezoidal_area(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    x1 = x_start\n    fx1 = fnc(x_start)\n    area = 0.0\n\n    for _ in range(steps):\n        # Approximates small segments of curve as linear and solve\n        # for trapezoidal area\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\n\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n    return area", "output": "Treats curve as a collection of linear lines and sums the area of the"}
{"task": "summary", "input": "summarize code:\ndef depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:\n    # Mark current node as visited and add to recursion stack\n    visited.add(vertex)\n    rec_stk.add(vertex)\n\n    for node in graph[vertex]:\n        if node not in visited:\n            if depth_first_search(graph, node, visited, rec_stk):\n                return True\n        elif node in rec_stk:\n            return True\n\n    # The node needs to be removed from recursion stack before function ends\n    rec_stk.remove(vertex)\n    return False", "output": "Recur for all neighbours."}
{"task": "summary", "input": "summarize code:\ndef time_func(func, *args, **kwargs):\n    start = time()\n    output = func(*args, **kwargs)\n    end = time()\n    if int(end - start) > 0:\n        print(f\"{func.__name__} runtime: {(end - start):0.4f} s\")\n    else:\n        print(f\"{func.__name__} runtime: {(end - start) * 1000:0.4f} ms\")\n    return output", "output": "Times the execution of a function with parameters"}
{"task": "detection", "input": "classify code:\ndef tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans", "output": "def three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans", "tests": ["assert three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]]", "assert three_sum([1, 2, 3, 4]) == []"]}
{"task": "search", "input": "search code:\nReturn a natural representation of a time in a resolution that makes sense.\n\nChoices:\n0: def flatten(root: TreeNode | None) -> None:     if not root:         return      # Flatten the left subtree     flatten(root.left)      # Save the right subtree     right_subtree = root.right      # Make the left subtree the new right subtree     root.right = root.left     root.left = None      # Find the end of the new right subtree     current = root     while current.right:         current = current.right      # Append the original right subtree to the end     current.right = right_subtree      # Flatten the updated right subtree     flatten(right_subtree)\n1: def height(root: Node | None) -> int:     return (max(height(root.left), height(root.right)) + 1) if root else 0\n2: def naturaltime(     value,     future=False,     months=True,     minimum_unit=\"seconds\",     when=None, ) -> str:     now = when or _now()     date, delta = _date_and_delta(value, now=now)     if date is None:         return value     # determine tense by value only if datetime/timedelta were passed     if isinstance(value, (dt.datetime, dt.timedelta)):         future = date > now      ago = _(\"%s from now\") if future else _(\"%s ago\")     delta = naturaldelta(delta, months, minimum_unit)      if delta == _(\"a moment\"):         return _(\"now\")      return ago % delta", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef is_valid(barcode: int) -> bool:\n    return len(str(barcode)) == 13 and get_check_digit(barcode) == barcode % 10", "output": "Checks for length of barcode and last-digit"}
{"task": "search", "input": "search code:\nCalculate Sum of Divisors.\n\nChoices:\n0: def sum_of_divisors(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = 1     temp = 1     while n % 2 == 0:         temp += 1         n = int(n / 2)     if temp > 1:         s *= (2**temp - 1) / (2 - 1)     for i in range(3, int(math.sqrt(n)) + 1, 2):         temp = 1         while n % i == 0:             temp += 1             n = int(n / i)         if temp > 1:             s *= (i**temp - 1) / (i - 1)     return int(s)\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def quote_path_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])     return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t                      for t in text])", "output": "0"}
{"task": "detection", "input": "classify code:\ndef vector_product(point1: Tuple[int, int], point2: Tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculates the new index we should go to if we fail a comparison\n\nChoices:\n0: def compute_geometric_mean(*args: int) -> float:     product = 1     for number in args:         if not isinstance(number, int) and not isinstance(number, float):             raise TypeError(\"Not a Number\")         product *= number     # Cannot calculate the even root for negative product.     # Frequently they are restricted to being positive.     if product < 0 and len(args) % 2 == 0:         raise ArithmeticError(\"Cannot Compute Geometric Mean for these numbers.\")     mean = abs(product) ** (1 / len(args))     # Since python calculates complex roots for negative products with odd roots.     if product < 0:         mean = -mean     # Since it does floating point arithmetic, it gives 64**(1/3) as 3.99999996     possible_mean = float(round(mean))     # To check if the rounded number is actually the mean.     if possible_mean ** len(args) == product:         mean = possible_mean     return mean\n1: def bin_to_hexadecimal(binary_str: str) -> str:     # Sanitising parameter     binary_str = str(binary_str).strip()      # Exceptions     if not binary_str:         raise ValueError(\"Empty string was passed to the function\")     is_negative = binary_str[0] == \"-\"     binary_str = binary_str[1:] if is_negative else binary_str     if not all(char in \"01\" for char in binary_str):         raise ValueError(\"Non-binary value was passed to the function\")      binary_str = (         \"0\" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str     )      hexadecimal = []     for x in range(0, len(binary_str), 4):         hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])     hexadecimal_str = \"0x\" + \"\".join(hexadecimal)      return \"-\" + hexadecimal_str if is_negative else hexadecimal_str\n2: def get_failure_array(pattern: str) -> list[int]:     failure = [0]     i = 0     j = 1     while j < len(pattern):         if pattern[i] == pattern[j]:             i += 1         elif i > 0:             i = failure[i - 1]             continue         j += 1         failure.append(i)     return failure", "output": "2"}
{"task": "search", "input": "search code:\nReturns the number of blue discs for the first arrangement to contain\n\nChoices:\n0: def emitter_converter(size_par, data):     if size_par + len(data) <= 2**size_par - (len(data) - 1):         raise ValueError(\"size of parity don't match with size of data\")      data_out = []     parity = []     bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]      # sorted information data for the size of the output data     data_ord = []     # data position template + parity     data_out_gab = []     # parity bit counter     qtd_bp = 0     # counter position of data bits     cont_data = 0      for x in range(1, size_par + len(data) + 1):         # Performs a template of bit positions - who should be given,         # and who should be parity         if qtd_bp < size_par:             if (np.log(x) / np.log(2)).is_integer():                 data_out_gab.append(\"P\")                 qtd_bp = qtd_bp + 1             else:                 data_out_gab.append(\"D\")         else:             data_out_gab.append(\"D\")          # Sorts the data to the new output size         if data_out_gab[-1] == \"D\":             data_ord.append(data[cont_data])             cont_data += 1         else:             data_ord.append(None)      # Calculates parity     qtd_bp = 0  # parity bit counter     for bp in range(1, size_par + 1):         # Bit counter one for a given parity         cont_bo = 0         # counter to control the loop reading         for cont_loop, x in enumerate(data_ord):             if x is not None:                 try:                     aux = (bin_pos[cont_loop])[-1 * (bp)]                 except IndexError:                     aux = \"0\"                 if aux == \"1\" and x == \"1\":                     cont_bo += 1         parity.append(cont_bo % 2)          qtd_bp += 1      # Mount the message     cont_bp = 0  # parity bit counter     for x in range(size_par + len(data)):         if data_ord[x] is None:             data_out.append(str(parity[cont_bp]))             cont_bp += 1         else:             data_out.append(data_ord[x])      return data_out\n1: def product_sum(arr: list[int | list], depth: int) -> int:     total_sum = 0     for ele in arr:         total_sum += product_sum(ele, depth + 1) if isinstance(ele, list) else ele     return total_sum * depth\n2: def solution(min_total: int = 10**12) -> int:      prev_numerator = 1     prev_denominator = 0      numerator = 1     denominator = 1      while numerator <= 2 * min_total - 1:         prev_numerator += 2 * numerator         numerator += 2 * prev_numerator          prev_denominator += 2 * denominator         denominator += 2 * prev_denominator      return (denominator + 1) // 2", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef mean_threshold(image: Image) -> Image:\n    height, width = image.size\n    mean = 0\n    pixels = image.load()\n    for i in range(width):\n        for j in range(height):\n            pixel = pixels[j, i]\n            mean += pixel\n    mean //= width * height\n\n    for j in range(width):\n        for i in range(height):\n            pixels[i, j] = 255 if pixels[i, j] > mean else 0\n    return image", "output": "image: is a grayscale PIL image object"}
{"task": "search", "input": "search code:\nCreates a Linked List from the elements of the given sequence\n\nChoices:\n0: def make_linked_list(elements_list: list | tuple) -> Node:      # if elements_list is empty     if not elements_list:         raise ValueError(\"The Elements List is empty\")      # Set first element as Head     head = Node(elements_list[0])     current = head     # Loop through elements from position 1     for data in elements_list[1:]:         current.next = Node(data)         current = current.next     return head\n1: def audio_frames(     audio: np.ndarray,     sample_rate: int,     hop_length: int = 20,     ftt_size: int = 1024, ) -> np.ndarray:      hop_size = np.round(sample_rate * hop_length / 1000).astype(int)      # Pad the audio signal to handle edge cases     audio = np.pad(audio, int(ftt_size / 2), mode=\"reflect\")      # Calculate the number of frames     frame_count = int((len(audio) - ftt_size) / hop_size) + 1      # Initialize an array to store the frames     frames = np.zeros((frame_count, ftt_size))      # Split the audio signal into frames     for n in range(frame_count):         frames[n] = audio[n * hop_size : n * hop_size + ftt_size]      return frames\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef binary_search_std_lib(sorted_collection: list[int], item: int) -> int:\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    index = bisect.bisect_left(sorted_collection, item)\n    if index != len(sorted_collection) and sorted_collection[index] == item:\n        return index\n    return -1", "output": "Pure implementation of a binary search algorithm in Python using stdlib"}
{"task": "search", "input": "search code:\nA recursive function that searches for possible combinations. Backtracks in case\n\nChoices:\n0: def split_and_add(number: int) -> int:     sum_of_digits = 0     while number > 0:         last_digit = number % 10         sum_of_digits += last_digit         number = number // 10  # Removing the last_digit from the given number     return sum_of_digits\n1: def newton_raphson(     f: RealFunc,     x0: float = 0,     max_iter: int = 100,     step: float = 1e-6,     max_error: float = 1e-6,     log_steps: bool = False, ) -> tuple[float, float, list[float]]:      def f_derivative(x: float) -> float:         return calc_derivative(f, x, step)      a = x0  # Set initial guess     steps = []     for _ in range(max_iter):         if log_steps:  # Log intermediate steps             steps.append(a)          error = abs(f(a))         if error < max_error:             return a, error, steps          if f_derivative(a) == 0:             raise ZeroDivisionError(\"No converging solution found, zero derivative\")         a -= f(a) / f_derivative(a)  # Calculate next estimate     raise ArithmeticError(\"No converging solution found, iteration limit reached\")\n2: def backtrack(     candidates: list, path: list, answer: list, target: int, previous_index: int ) -> None:     if target == 0:         answer.append(path.copy())     else:         for index in range(previous_index, len(candidates)):             if target >= candidates[index]:                 path.append(candidates[index])                 backtrack(candidates, path, answer, target - candidates[index], index)                 path.pop(len(path) - 1)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef upper(word: str) -> str:\n    \"\"\"\n    Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII\n    letters and subtracting 32 from their integer representation to get the uppercase\n    letter.\n\n    >>> upper(\"wow\")\n    'WOW'\n    >>> upper(\"Hello\")\n    'HELLO'\n    >>> upper(\"WHAT\")\n    'WHAT'\n    >>> upper(\"wh[]32\")\n    'WH[]32'\n    \"\"\"\n    return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nMark a string as a translation string without translating it.\n\nChoices:\n0: def sliding_window(iterable, n):     if n > 20:         return _sliding_window_deque(iterable, n)     elif n > 2:         return _sliding_window_islice(iterable, n)     elif n == 2:         return pairwise(iterable)     elif n == 1:         return zip(iterable)     else:         raise ValueError(f'n should be at least one, not {n}')\n1: def _gettext_noop(message):     return message\n2: def longest_common_prefix(iterables):     return (c[0] for c in takewhile(all_equal, zip(*iterables)))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef linear_search(sequence, target):\n    \"\"\"Pure implementation of linear search algorithm in Python\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return None", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn the solution to the problem\n\nChoices:\n0: def solution(n: int = 1000000) -> int:      result = max((collatz_sequence_length(i), i) for i in range(1, n))     return result[1]\n1: def solution() -> int:     return compute_nums(1)[0]\n2: def benchmark() -> None:     from timeit import timeit      setup = \"from __main__ import is_pangram, is_pangram_faster, is_pangram_fastest\"     print(timeit(\"is_pangram()\", setup=setup))     print(timeit(\"is_pangram_faster()\", setup=setup))     print(timeit(\"is_pangram_fastest()\", setup=setup))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef hill_climbing(\n    search_prob,\n    find_max: bool = True,\n    max_x: float = math.inf,\n    min_x: float = -math.inf,\n    max_y: float = math.inf,\n    min_y: float = -math.inf,\n    visualization: bool = False,\n    max_iter: int = 10000,\n) -> SearchProblem:\n    current_state = search_prob\n    scores = []  # list to store the current score at each iteration\n    iterations = 0\n    solution_found = False\n    visited = set()\n    while not solution_found and iterations < max_iter:\n        visited.add(current_state)\n        iterations += 1\n        current_score = current_state.score()\n        scores.append(current_score)\n        neighbors = current_state.get_neighbors()\n        max_change = -math.inf\n        min_change = math.inf\n        next_state = None  # to hold the next best neighbor\n        for neighbor in neighbors:\n            if neighbor in visited:\n                continue  # do not want to visit the same state again\n            if (\n                neighbor.x > max_x\n                or neighbor.x < min_x\n                or neighbor.y > max_y\n                or neighbor.y < min_y\n            ):\n                continue  # neighbor outside our bounds\n            change = neighbor.score() - current_score\n            if find_max:  # finding max\n                # going to direction with greatest ascent\n                if change > max_change and change > 0:\n                    max_change = change\n                    next_state = neighbor\n            elif change < min_change and change < 0:  # finding min\n                # to direction with greatest descent\n                min_change = change\n                next_state = neighbor\n        if next_state is not None:\n            # we found at least one neighbor which improved the current state\n            current_state = next_state\n        else:\n            # since we have no neighbor that improves the solution we stop the search\n            solution_found = True\n\n    if visualization:\n        from matplotlib import pyplot as plt\n\n        plt.plot(range(iterations), scores)\n        plt.xlabel(\"Iterations\")\n        plt.ylabel(\"Function values\")\n        plt.show()\n\n    return current_state", "output": "Implementation of the hill climbling algorithm."}
{"task": "repair", "input": "fix bug:\ndef is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True", "output": "def is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True", "tests": ["assert is_square_form(1) == False", "assert is_square_form(112233445566778899) == True", "assert is_square_form(123456789012345678) == False"]}
