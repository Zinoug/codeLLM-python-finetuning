{"task": "repair", "input": "fix bug:\ndef make_points(a, b, h):\n    x = a + h\n    while x < (b - h):\n        yield x\n        x = x + h", "output": "def make_points(a, b, h):\n    \"\"\"\n    Generates points between 'a' and 'b' with step size 'h', excluding the end points.\n    Args:\n        a (float): Start value\n        b (float): End value\n        h (float): Step size\n    Examples:\n    >>> list(make_points(0, 10, 2.5))\n    [2.5, 5.0, 7.5]\n\n    >>> list(make_points(0, 10, 2))\n    [2, 4, 6, 8]\n\n    >>> list(make_points(1, 21, 5))\n    [6, 11, 16]\n\n    >>> list(make_points(1, 5, 2))\n    [3]\n\n    >>> list(make_points(1, 4, 3))\n    []\n    \"\"\"\n    x = a + h\n    while x <= (b - h):\n        yield x\n        x = x + h"}
{"task": "summary", "input": "summarize code:\ndef split(root: Node | None, value: int) -> tuple[Node | None, Node | None]:\n    if root is None or root.value is None:  # None tree is split into 2 Nones\n        return None, None\n    elif value < root.value:\n        left, root.left = split(root.left, value)\n        return left, root\n    else:\n        root.right, right = split(root.right, value)\n        return root, right", "output": "We split current tree into 2 trees with value:"}
{"task": "search", "input": "search code:\nYields serially-duplicate elements after their first appearance.\n\nChoices:\n0: def duplicates_justseen(iterable, key=None):     return flatten(g for _, g in groupby(iterable, key) for _ in g)\n1: def hypercube_points(     num_points: int, hypercube_size: float, num_dimensions: int ) -> np.ndarray:     rng = np.random.default_rng()     shape = (num_points, num_dimensions)     return hypercube_size * rng.random(shape)\n2: def vol_spherical_cap(height: float, radius: float) -> float:     if height < 0 or radius < 0:         raise ValueError(\"vol_spherical_cap() only accepts non-negative values\")     # Volume is 1/3 pi * height squared * (3 * radius - height)     return 1 / 3 * pi * pow(height, 2) * (3 * radius - height)", "output": "0"}
{"task": "search", "input": "search code:\nCalculate the Fast Fourier Transform (FFT) of windowed audio data.\n\nChoices:\n0: def solution() -> int:     limit = 7 * factorial(9) + 1     return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)\n1: def calculate_fft(audio_windowed: np.ndarray, ftt_size: int = 1024) -> np.ndarray:     # Transpose the audio data to have time in rows and channels in columns     audio_transposed = np.transpose(audio_windowed)      # Initialize an array to store the FFT results     audio_fft = np.empty(         (int(1 + ftt_size // 2), audio_transposed.shape[1]),         dtype=np.complex64,         order=\"F\",     )      # Compute FFT for each channel     for n in range(audio_fft.shape[1]):         audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]      # Transpose the FFT results back to the original shape     return np.transpose(audio_fft)\n2: def add_file_length(source_path: str, compressed: str) -> str:     file_length = os.path.getsize(source_path)     file_length_binary = bin(file_length)[2:]     length_length = len(file_length_binary)      return \"0\" * (length_length - 1) + file_length_binary + compressed", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef can_string_be_rearranged_as_palindrome(input_str: str = \"\") -> bool:\n    if len(input_str) == 0:\n        return True\n    lower_case_input_str = input_str.replace(\" \", \"\").lower()\n    # character_freq_dict: Stores the frequency of every character in the input string\n    character_freq_dict: dict[str, int] = {}\n\n    for character in lower_case_input_str:\n        character_freq_dict[character] = character_freq_dict.get(character, 0) + 1\n    odd_char = 0\n\n    for character_count in character_freq_dict.values():\n        if character_count % 2:\n            odd_char += 1\n    return not odd_char > 1", "output": "A Palindrome is a String that reads the same forward as it does backwards."}
{"task": "repair", "input": "fix bug:\ndef modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result", "output": "def modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result"}
{"task": "repair", "input": "fix bug:\ndef sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value", "output": "def sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value"}
{"task": "detection", "input": "classify code:\ndef is_match(string: str, pattern: str) -> bool:\n    \"\"\"\n    >>> is_match(\"\", \"\")\n    True\n    >>> is_match(\"aa\", \"a\")\n    False\n    >>> is_match(\"abc\", \"abc\")\n    True\n    >>> is_match(\"abc\", \"*c\")\n    True\n    >>> is_match(\"abc\", \"a*\")\n    True\n    >>> is_match(\"abc\", \"*a*\")\n    True\n    >>> is_match(\"abc\", \"?b?\")\n    True\n    >>> is_match(\"abc\", \"*?\")\n    True\n    >>> is_match(\"abc\", \"a*d\")\n    False\n    >>> is_match(\"abc\", \"a*c?\")\n    False\n    >>> is_match('baaabab','*****ba*****ba')\n    False\n    >>> is_match('baaabab','*****ba*****ab')\n    True\n    >>> is_match('aa','*')\n    True\n    \"\"\"\n    dp = [[False] * (len(pattern) + 1) for _ in string + \"1\"]\n    dp[0][0] = True\n    # Fill in the first row\n    for j, char in enumerate(pattern, 1):\n        if char == \"*\":\n            dp[0][j] = dp[0][j - 1]\n    # Fill in the rest of the DP table\n    for i, s_char in enumerate(string, 1):\n        for j, p_char in enumerate(pattern, 1):\n            if p_char in (s_char, \"?\"):\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[len(string)][len(pattern)]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculate the binomial coefficient c(n,r) using the multiplicative formula.\n\nChoices:\n0: def is_palindrome_dict(head: ListNode | None) -> bool:     if not head or not head.next_node:         return True     d: dict[int, list[int]] = {}     pos = 0     while head:         if head.val in d:             d[head.val].append(pos)         else:             d[head.val] = [pos]         head = head.next_node         pos += 1     checksum = pos - 1     middle = 0     for v in d.values():         if len(v) % 2 != 0:             middle += 1         else:             for step, i in enumerate(range(len(v))):                 if v[i] + v[len(v) - 1 - step] != checksum:                     return False         if middle > 1:             return False     return True\n1: def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:     return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2\n2: def choose(n: int, r: int) -> int:     ret = 1.0     for i in range(1, r + 1):         ret *= (n + 1 - i) / i     return round(ret)", "output": "2"}
{"task": "search", "input": "search code:\nImplements the sigmoid function\n\nChoices:\n0: def volume_conversion(value: float, from_type: str, to_type: str) -> float:     if from_type not in METRIC_CONVERSION:         raise ValueError(             f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"             + \", \".join(METRIC_CONVERSION)         )     if to_type not in METRIC_CONVERSION:         raise ValueError(             f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"             + \", \".join(METRIC_CONVERSION)         )     return (         value         * METRIC_CONVERSION[from_type].from_factor         * METRIC_CONVERSION[to_type].to_factor     )\n1: def collatz_sequence_length(n: int) -> int:     if n in COLLATZ_SEQUENCE_LENGTHS:         return COLLATZ_SEQUENCE_LENGTHS[n]     next_n = n // 2 if n % 2 == 0 else 3 * n + 1     sequence_length = collatz_sequence_length(next_n) + 1     COLLATZ_SEQUENCE_LENGTHS[n] = sequence_length     return sequence_length\n2: def sigmoid(vector: np.ndarray) -> np.ndarray:     return 1 / (1 + np.exp(-vector))", "output": "2"}
{"task": "search", "input": "search code:\nRecursive function to print a BST from a root table.\n\nChoices:\n0: def solution(n: int = 1000) -> int:     answer = 1     gen = fibonacci_generator()     while len(str(next(gen))) < n:         answer += 1     return answer + 1\n1: def print_binary_search_tree(root, key, i, j, parent, is_left):     if i > j or i < 0 or j > len(root) - 1:         return      node = root[i][j]     if parent == -1:  # root does not have a parent         print(f\"{key[node]} is the root of the binary search tree.\")     elif is_left:         print(f\"{key[node]} is the left child of key {parent}.\")     else:         print(f\"{key[node]} is the right child of key {parent}.\")      print_binary_search_tree(root, key, i, node - 1, key[node], True)     print_binary_search_tree(root, key, node + 1, j, key[node], False)\n2: def longest_common_subsequence(x: str, y: str):     # find the length of strings      assert x is not None     assert y is not None      m = len(x)     n = len(y)      # declaring the array for storing the dp values     dp = [[0] * (n + 1) for _ in range(m + 1)]      for i in range(1, m + 1):         for j in range(1, n + 1):             match = 1 if x[i - 1] == y[j - 1] else 0              dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)      seq = \"\"     i, j = m, n     while i > 0 and j > 0:         match = 1 if x[i - 1] == y[j - 1] else 0          if dp[i][j] == dp[i - 1][j - 1] + match:             if match == 1:                 seq = x[i - 1] + seq             i -= 1             j -= 1         elif dp[i][j] == dp[i - 1][j]:             i -= 1         else:             j -= 1      return dp[m][n], seq", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n    \"\"\"\n    Simulates gravity in a specific column.\n\n    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n    [['-', '-'], ['-', 'A'], ['-', 'C']]\n    \"\"\"\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g", "output": "def move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n    \"\"\"\n    Simulates gravity in a specific column.\n\n    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n    [['-', '-'], ['-', 'A'], ['-', 'C']]\n    \"\"\"\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g"}
{"task": "search", "input": "search code:\nsorting left-half and right-half individually\n\nChoices:\n0: def summarize_book(ol_book_data: dict) -> dict:     desired_keys = {         \"title\": \"Title\",         \"publish_date\": \"Publish date\",         \"authors\": \"Authors\",         \"number_of_pages\": \"Number of pages\",         \"isbn_10\": \"ISBN (10)\",         \"isbn_13\": \"ISBN (13)\",     }     data = {better_key: ol_book_data[key] for key, better_key in desired_keys.items()}     data[\"Authors\"] = [         get_openlibrary_data(author[\"key\"])[\"name\"] for author in data[\"Authors\"]     ]     for key, value in data.items():         if isinstance(value, list):             data[key] = \", \".join(value)     return data\n1: def merge(input_list: list, low: int, mid: int, high: int) -> list:     result = []     left, right = input_list[low:mid], input_list[mid : high + 1]     while left and right:         result.append((left if left[0] <= right[0] else right).pop(0))     input_list[low : high + 1] = result + left + right     return input_list\n2: def _extract_buffered(iterator, index_and_position):     'Arbitrary index order, greedily consumed'     buffer = {}     iterator_position = -1     next_to_emit = 0      for index, order in index_and_position:         advance = index - iterator_position         if advance:             try:                 value = next(islice(iterator, advance - 1, None))             except StopIteration:                 raise IndexError(index) from None             iterator_position = index          buffer[order] = value          while next_to_emit in buffer:             yield buffer.pop(next_to_emit)             next_to_emit += 1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef encrypt(input_string: str, key: int) -> str:\n    temp_grid: list[list[str]] = [[] for _ in range(key)]\n    lowest = key - 1\n\n    if key <= 0:\n        raise ValueError(\"Height of grid can't be 0 or negative\")\n    if key == 1 or len(input_string) <= key:\n        return input_string\n\n    for position, character in enumerate(input_string):\n        num = position % (lowest * 2)  # puts it in bounds\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\n        temp_grid[num].append(character)\n    grid = [\"\".join(row) for row in temp_grid]\n    output_string = \"\".join(grid)\n\n    return output_string", "output": "Shuffles the character of a string by placing each of them"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    total_sum = 0\n    temp_sum = 0\n    with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:\n        name = str(file.readlines()[0])\n        name = name.replace('\"', \"\").split(\",\")\n\n    name.sort()\n    for i in range(len(name)):\n        for j in name[i]:\n            temp_sum += ord(j) - ord(\"A\") + 1\n        total_sum += (i + 1) * temp_sum\n        temp_sum = 0\n    return total_sum", "output": "Returns the total of all the name scores in the file."}
{"task": "detection", "input": "classify code:\ndef calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\n\n    word_bank = word_bank or []\n    # create a table\n    table_size: int = len(target) + 1\n\n    table: list[list[list[str]]] = []\n    for _ in range(table_size):\n        table.append([])\n    # seed value\n    table[0] = [[]]  # because empty string has empty combination\n\n    # iterate through the indices\n    for i in range(table_size):\n        # condition\n        if table[i] != []:\n            for word in word_bank:\n                # slice condition\n                if target[i : i + len(word)] == word:\n                    new_combinations: list[list[str]] = [\n                        [word, *way] for way in table[i]\n                    ]\n                    # adds the word to every combination the current position holds\n                    # now,push that combination to the table[i+len(word)]\n                    table[i + len(word)] += new_combinations\n\n    # combinations are in reverse order so reverse for better output\n    for combination in table[len(target)]:\n        combination.reverse()\n\n    return table[len(target)]", "output": "returns the list containing all the possible"}
{"task": "detection", "input": "classify code:\ndef prefix_function(input_string: str) -> list:\n    \"\"\"\n    For the given string this function computes value for each index(i),\n    which represents the longest coincidence of prefix and suffix\n    for given substring (input_str[0...i])\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> prefix_function(\"aabcdaabc\")\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\n    >>> prefix_function(\"asdasdad\")\n    [0, 0, 0, 1, 2, 3, 4, 0]\n    \"\"\"\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)", "output": "def rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)"}
{"task": "search", "input": "search code:\nFunction to find the maximum profit by doing jobs in a given time frame\n\nChoices:\n0: def new_generation(cells: list[list[int]]) -> list[list[int]]:     next_generation = []     for i in range(len(cells)):         next_generation_row = []         for j in range(len(cells[i])):             # Get the number of live neighbours             neighbour_count = 0             if i > 0 and j > 0:                 neighbour_count += cells[i - 1][j - 1]             if i > 0:                 neighbour_count += cells[i - 1][j]             if i > 0 and j < len(cells[i]) - 1:                 neighbour_count += cells[i - 1][j + 1]             if j > 0:                 neighbour_count += cells[i][j - 1]             if j < len(cells[i]) - 1:                 neighbour_count += cells[i][j + 1]             if i < len(cells) - 1 and j > 0:                 neighbour_count += cells[i + 1][j - 1]             if i < len(cells) - 1:                 neighbour_count += cells[i + 1][j]             if i < len(cells) - 1 and j < len(cells[i]) - 1:                 neighbour_count += cells[i + 1][j + 1]              # Rules of the game of life (excerpt from Wikipedia):             # 1. Any live cell with two or three live neighbours survives.             # 2. Any dead cell with three live neighbours becomes a live cell.             # 3. All other live cells die in the next generation.             #    Similarly, all other dead cells stay dead.             alive = cells[i][j] == 1             if (alive and 2 <= neighbour_count <= 3) or (                 not alive and neighbour_count == 3             ):                 next_generation_row.append(1)             else:                 next_generation_row.append(0)          next_generation.append(next_generation_row)     return next_generation\n1: def job_sequencing_with_deadlines(jobs: list) -> list:      # Sort the jobs in descending order of profit     jobs = sorted(jobs, key=lambda value: value[2], reverse=True)      # Create a list of size equal to the maximum deadline     # and initialize it with -1     max_deadline = max(jobs, key=lambda value: value[1])[1]     time_slots = [-1] * max_deadline      # Finding the maximum profit and the count of jobs     count = 0     max_profit = 0     for job in jobs:         # Find a free time slot for this job         # (Note that we start from the last possible slot)         for i in range(job[1] - 1, -1, -1):             if time_slots[i] == -1:                 time_slots[i] = job[0]                 count += 1                 max_profit += job[2]                 break     return [count, max_profit]\n2: def area_rectangle(length: float, width: float) -> float:     if length < 0 or width < 0:         raise ValueError(\"area_rectangle() only accepts non-negative values\")     return length * width", "output": "1"}
{"task": "search", "input": "search code:\nFinds the sum of all the positive integers which cannot be written as\n\nChoices:\n0: def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:      y, x = position     positions = [         (y + 1, x + 2),         (y - 1, x + 2),         (y + 1, x - 2),         (y - 1, x - 2),         (y + 2, x + 1),         (y + 2, x - 1),         (y - 2, x + 1),         (y - 2, x - 1),     ]     permissible_positions = []      for inner_position in positions:         y_test, x_test = inner_position         if 0 <= y_test < n and 0 <= x_test < n:             permissible_positions.append(inner_position)      return permissible_positions\n1: def solution(limit=28123):     sum_divs = [1] * (limit + 1)      for i in range(2, int(limit**0.5) + 1):         sum_divs[i * i] += i         for k in range(i + 1, limit // i + 1):             sum_divs[k * i] += k + i      abundants = set()     res = 0      for n in range(1, limit + 1):         if sum_divs[n] > n:             abundants.add(n)          if not any((n - a in abundants) for a in abundants):             res += n      return res\n2: def count_vowels(s: str) -> int:     if not isinstance(s, str):         raise ValueError(\"Input must be a string\")      vowels = \"aeiouAEIOU\"     return sum(1 for char in s if char in vowels)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(fraction: float = 1 / 1000) -> int:\n\n    l_section_area = (1 - pi / 4) / 4\n\n    for n in count(1):\n        if concave_triangle_area(n) / l_section_area < fraction:\n            return n\n\n    return -1", "output": "Returns least value of n"}
{"task": "repair", "input": "fix bug:\ndef text_from_bits(bits, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_from_bits('011011010111001101100111')\n    'msg'\n    \"\"\"\n    n = int(bits, 2)\n    return n.to_bytes((n.bit_length() + 7) // 8, \"big\").decode(encoding, errors) or \"\\0\"", "output": "def text_from_bits(bits, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_from_bits('011011010111001101100111')\n    'msg'\n    \"\"\"\n    n = int(bits, 2)\n    return n.to_bytes((n.bit_length() + 7) // 8, \"big\").decode(encoding, errors) or \"\\0\""}
{"task": "search", "input": "search code:\nCheck if a word can be placed at the given position.\n\nChoices:\n0: def excel_title_to_column(column_title: str) -> int:     assert column_title.isupper()     answer = 0     index = len(column_title) - 1     power = 0      while index >= 0:         value = (ord(column_title[index]) - 64) * pow(26, power)         answer += value         power += 1         index -= 1      return answer\n1: def is_valid(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> bool:     for i in range(len(word)):         if vertical:             if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":                 return False         elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":             return False     return True\n2: def solution(m: int = 100) -> int:     memo = [[0 for _ in range(m)] for _ in range(m + 1)]     for i in range(m + 1):         memo[i][0] = 1      for n in range(m + 1):         for k in range(1, m):             memo[n][k] += memo[n][k - 1]             if n > k:                 memo[n][k] += memo[n - k - 1][k]      return memo[m][m - 1] - 1", "output": "1"}
{"task": "search", "input": "search code:\nReturns perimeter with maximum solutions.\n\nChoices:\n0: def trapezoidal_area(     fnc: Callable[[float], float],     x_start: float,     x_end: float,     steps: int = 100, ) -> float:     x1 = x_start     fx1 = fnc(x_start)     area = 0.0     for _ in range(steps):         # Approximates small segments of curve as linear and solve         # for trapezoidal area         x2 = (x_end - x_start) / steps + x1         fx2 = fnc(x2)         area += abs(fx2 + fx1) * (x2 - x1) / 2         # Increment step         x1 = x2         fx1 = fx2     return area\n1: def _running_median_minheap_and_maxheap(iterator):  # pragma: no cover     \"Non-windowed running_median() for Python 3.14+\"      read = iterator.__next__     lo = []  # max-heap     hi = []  # min-heap (same size as or one smaller than lo)      with suppress(StopIteration):         while True:             heappush_max(lo, heappushpop(hi, read()))             yield lo[0]              heappush(hi, heappushpop_max(lo, read()))             yield (lo[0] + hi[0]) / 2\n2: def solution(n: int = 1000) -> int:     triplets = pythagorean_triple(n)     return triplets.most_common(1)[0][0]", "output": "2"}
{"task": "detection", "input": "classify code:\ndef compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    'X'\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return \"X\"\n    else:\n        return \"\".join(l1)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef convert_path_to_module(file_path: pathlib.Path) -> ModuleType:\n    spec = importlib.util.spec_from_file_location(file_path.name, str(file_path))\n    module = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]\n    spec.loader.exec_module(module)  # type: ignore[union-attr]\n    return module", "output": "Converts a file path to a Python module"}
{"task": "search", "input": "search code:\nDraws a line between two points using the DDA algorithm.\n\nChoices:\n0: def solution(percent: float = 99) -> int:     if not 0 < percent < 100:         raise ValueError(\"solution() only accepts values from 0 to 100\")     bouncy_num = 0     num = 1      while True:         if check_bouncy(num):             bouncy_num += 1         if (bouncy_num / num) * 100 >= percent:             return num         num += 1\n1: def strip(iterable, strip_value=None):     return list(strip_iter(iterable, strip_value))\n2: def digital_differential_analyzer_line(     p1: tuple[int, int], p2: tuple[int, int] ) -> list[tuple[int, int]]:     x1, y1 = p1     x2, y2 = p2     dx = x2 - x1     dy = y2 - y1     steps = max(abs(dx), abs(dy))     x_increment = dx / float(steps)     y_increment = dy / float(steps)     coordinates = []     x: float = x1     y: float = y1     for _ in range(steps):         x += x_increment         y += y_increment         coordinates.append((round(x), round(y)))     return coordinates", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef unique(src, key=None):\n    return list(unique_iter(src, key))", "output": "``unique()`` returns a list of unique values, as determined by"}
{"task": "search", "input": "search code:\nConverts the given string to little-endian in groups of 8 chars.\n\nChoices:\n0: def calculate_waiting_times(burst_times: list[int]) -> list[int]:     quantum = 2     rem_burst_times = list(burst_times)     waiting_times = [0] * len(burst_times)     t = 0     while True:         done = True         for i, burst_time in enumerate(burst_times):             if rem_burst_times[i] > 0:                 done = False                 if rem_burst_times[i] > quantum:                     t += quantum                     rem_burst_times[i] -= quantum                 else:                     t += rem_burst_times[i]                     waiting_times[i] = t - burst_time                     rem_burst_times[i] = 0         if done is True:             return waiting_times\n1: def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:     return sum(turnaround_times) / len(turnaround_times)\n2: def to_little_endian(string_32: bytes) -> bytes:     if len(string_32) != 32:         raise ValueError(\"Input must be of length 32\")      little_endian = b\"\"     for i in [3, 2, 1, 0]:         little_endian += string_32[8 * i : 8 * i + 8]     return little_endian", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef interact_treap(root: Node | None, args: str) -> Node | None:\n    for arg in args.split():\n        if arg[0] == \"+\":\n            root = insert(root, int(arg[1:]))\n\n        elif arg[0] == \"-\":\n            root = erase(root, int(arg[1:]))\n\n        else:\n            print(\"Unknown command\")\n\n    return root", "output": "Commands:"}
{"task": "summary", "input": "summarize code:\ndef prune(itemset: list, candidates: list, length: int) -> list:\n    itemset_counter = Counter(tuple(item) for item in itemset)\n    pruned = []\n    for candidate in candidates:\n        is_subsequence = True\n        for item in candidate:\n            item_tuple = tuple(item)\n            if (\n                item_tuple not in itemset_counter\n                or itemset_counter[item_tuple] < length - 1\n            ):\n                is_subsequence = False\n                break\n        if is_subsequence:\n            pruned.append(candidate)\n    return pruned", "output": "Prune candidate itemsets that are not frequent."}
{"task": "detection", "input": "classify code:\ndef get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFunction to validate the given credit card number.\n\nChoices:\n0: def wraps(func, injected=None, expected=None, **kw):     return partial(update_wrapper, func=func, build_from=None,                    injected=injected, expected=expected, **kw)\n1: def validate_credit_card_number(credit_card_number: str) -> bool:     error_message = f\"{credit_card_number} is an invalid credit card number because\"     if not credit_card_number.isdigit():         print(f\"{error_message} it has nonnumerical characters.\")         return False      if not 13 <= len(credit_card_number) <= 16:         print(f\"{error_message} of its length.\")         return False      if not validate_initial_digits(credit_card_number):         print(f\"{error_message} of its first two digits.\")         return False      if not luhn_validation(credit_card_number):         print(f\"{error_message} it fails the Luhn check.\")         return False      print(f\"{credit_card_number} is a valid credit card number.\")     return True\n2: def cachedmethod(cache, scoped=True, typed=False, key=None):     def cached_method_decorator(func):         return CachedMethod(func, cache, scoped=scoped, typed=typed, key=key)     return cached_method_decorator", "output": "1"}
{"task": "detection", "input": "classify code:\ndef _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\n    Args:\n        total_elements (int): The total number of elements.\n        elements_to_choose (int): The number of elements to choose.\n\n    Returns:\n        int: The binomial coefficient C(total_elements, elements_to_choose).\n\n    Examples:\n    >>> _binomial_coefficient(5, 2)\n    10\n    >>> _binomial_coefficient(6, 3)\n    20\n    \"\"\"\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient", "output": "CORRECT"}
{"task": "search", "input": "search code:\nWrites given to_write string (should only consist of 0's and 1's) as bytes in the\n\nChoices:\n0: def p_series(nth_term: float | str, power: float | str) -> list[str]:     if nth_term == \"\":         return [\"\"]     nth_term = int(nth_term)     power = int(power)     series: list[str] = []     for temp in range(int(nth_term)):         series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")     return series\n1: def write_file_binary(file_path: str, to_write: str) -> None:     byte_length = 8     try:         with open(file_path, \"wb\") as opened_file:             result_byte_array = [                 to_write[i : i + byte_length]                 for i in range(0, len(to_write), byte_length)             ]              if len(result_byte_array[-1]) % byte_length == 0:                 result_byte_array.append(\"10000000\")             else:                 result_byte_array[-1] += \"1\" + \"0\" * (                     byte_length - len(result_byte_array[-1]) - 1                 )              for elem in result_byte_array[:-1]:                 opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))     except OSError:         print(\"File not accessible\")         sys.exit()\n2: def solution():     prime_list = [n for n in range(1001, 10000, 2) if is_prime(n)]     candidates = []      for number in prime_list:         tmp_numbers = []          for prime_member in permutations(list(str(number))):             prime = int(\"\".join(prime_member))              if prime % 2 == 0:                 continue              if search(prime, prime_list):                 tmp_numbers.append(prime)          tmp_numbers.sort()         if len(tmp_numbers) >= 3:             candidates.append(tmp_numbers)      passed = []     for candidate in candidates:         length = len(candidate)         found = False          for i in range(length):             for j in range(i + 1, length):                 for k in range(j + 1, length):                     if (                         abs(candidate[i] - candidate[j])                         == abs(candidate[j] - candidate[k])                         and len({candidate[i], candidate[j], candidate[k]}) == 3                     ):                         passed.append(                             sorted([candidate[i], candidate[j], candidate[k]])                         )                         found = True                      if found:                         break                 if found:                     break             if found:                 break      answer = set()     for seq in passed:         answer.add(\"\".join([str(i) for i in seq]))      return max(int(x) for x in answer)", "output": "1"}
{"task": "search", "input": "search code:\nExtended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n\nChoices:\n0: def extended_gcd(a: int, b: int) -> tuple[int, int, int]:     assert a >= 0     assert b >= 0      if b == 0:         d, x, y = a, 1, 0     else:         (d, p, q) = extended_gcd(b, a % b)         x = q         y = p - q * (a // b)      assert a % d == 0     assert b % d == 0     assert d == a * x + b * y      return (d, x, y)\n1: def soft_sorted(iterable, first=None, last=None, key=None, reverse=False):     first = first or []     last = last or []     key = key or (lambda x: x)     seq = list(iterable)     other = [x for x in seq if not (         (first and key(x) in first) or (last and key(x) in last))]     other.sort(key=key, reverse=reverse)      if first:         first = sorted([x for x in seq if key(x) in first],                        key=lambda x: first.index(key(x)))     if last:         last = sorted([x for x in seq if key(x) in last],                       key=lambda x: last.index(key(x)))     return first + other + last\n2: def digit_sum(n: int) -> int:     return sum(int(digit) for digit in str(n))", "output": "0"}
{"task": "search", "input": "search code:\nTurns an integer value of *nbytes* into a human readable format. Set\n\nChoices:\n0: def longest_common_prefix(iterables):     return (c[0] for c in takewhile(all_equal, zip(*iterables)))\n1: def bytes2human(nbytes, ndigits=0):     abs_bytes = abs(nbytes)     for (size, symbol), (next_size, next_symbol) in _SIZE_RANGES:         if abs_bytes <= next_size:             break     hnbytes = float(nbytes) / size     return '{hnbytes:.{ndigits}f}{symbol}'.format(hnbytes=hnbytes,                                                   ndigits=ndigits,                                                   symbol=symbol)\n2: def calculate_spearman_rank_correlation(     variable_1: Sequence[float], variable_2: Sequence[float] ) -> float:     n = len(variable_1)     rank_var1 = assign_ranks(variable_1)     rank_var2 = assign_ranks(variable_2)      # Calculate differences of ranks     d = [rx - ry for rx, ry in zip(rank_var1, rank_var2)]      # Calculate the sum of squared differences     d_squared = sum(di**2 for di in d)      # Calculate the Spearman's rank correlation coefficient     rho = 1 - (6 * d_squared) / (n * (n**2 - 1))      return rho", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef linear_regression_prediction(\n    train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list\n) -> float:\n    x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])\n    y = np.array(train_usr)\n    beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)\n    return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])", "output": "First method: linear regression"}
{"task": "detection", "input": "classify code:\ndef shell_sort(collection: list) -> list:\n    \"\"\"Implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([3, 2, 1])\n    [1, 2, 3]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([1])\n    [1]\n    \"\"\"\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef vernam_decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_decrypt(\"RIJVS\",\"KEY\")\n    'HELLO'\n    \"\"\"\n    decrypted_text = \"\"\n    for i in range(len(ciphertext)):\n        ct = ord(ciphertext[i]) - ord(key[i % len(key)])\n        while ct < 0:\n            ct = 26 + ct\n        decrypted_text += chr(65 + ct)\n    return decrypted_text", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We aren't using dp_array here, so the time complexity would be exponential.\n\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef random_pivot(lst):\n    return choice(lst)", "output": "Choose a random pivot for the list."}
{"task": "summary", "input": "summarize code:\ndef _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient", "output": "Calculate the binomial coefficient C(total_elements, elements_to_choose)"}
{"task": "summary", "input": "summarize code:\ndef subset_combinations(elements: list[int], n: int) -> list:\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]", "output": "Compute n-element combinations from a given list using dynamic programming."}
{"task": "search", "input": "search code:\nReturns the nth number of the Fibonacci sequence that\n\nChoices:\n0: def fibonacci_with_matrix_exponentiation(n, f1, f2):     # Trivial Cases     if n == 1:         return f1     elif n == 2:         return f2     matrix = Matrix([[1, 1], [1, 0]])     matrix = modular_exponentiation(matrix, n - 2)     return f2 * matrix.t[0][0] + f1 * matrix.t[0][1]\n1: def is_scalar(obj):     return not is_iterable(obj) or isinstance(obj, (str, bytes))\n2: def solution(n: int = 4000000) -> int:      if n <= 1:         return 0     a = 0     b = 2     count = 0     while 4 * b + a <= n:         a, b = b, 4 * b + a         count += a     return count + b", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef is_germain_prime(number: int) -> bool:\n    if not isinstance(number, int) or number < 1:\n        msg = f\"Input value must be a positive integer. Input value: {number}\"\n        raise TypeError(msg)\n\n    return is_prime(number) and is_prime(2 * number + 1)", "output": "Checks if input number and 2*number + 1 are prime."}
{"task": "detection", "input": "classify code:\ndef add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution() -> float:\n\n    peter_totals_frequencies = total_frequency_distribution(\n        sides_number=4, dice_number=9\n    )\n    colin_totals_frequencies = total_frequency_distribution(\n        sides_number=6, dice_number=6\n    )\n\n    peter_wins_count = 0\n    min_peter_total = 9\n    max_peter_total = 4 * 9\n    min_colin_total = 6\n    for peter_total in range(min_peter_total, max_peter_total + 1):\n        peter_wins_count += peter_totals_frequencies[peter_total] * sum(\n            colin_totals_frequencies[min_colin_total:peter_total]\n        )\n\n    total_games_number = (4**9) * (6**6)\n    peter_win_probability = peter_wins_count / total_games_number\n\n    rounded_peter_win_probability = round(peter_win_probability, ndigits=7)\n\n    return rounded_peter_win_probability", "output": "Returns probability that Pyramidal Peter beats Cubic Colin"}
{"task": "search", "input": "search code:\nReturns the sum of all even fibonacci sequence elements that are lower\n\nChoices:\n0: def factor(n):      # Corner case reduction     if n < 2:         return      # Trial division reduction     for prime in _primes_below_211:         while not n % prime:             yield prime             n //= prime      # Pollard's rho reduction     primes = []     todo = [n] if n > 1 else []     for n in todo:         if n < 211**2 or is_prime(n):             primes.append(n)         else:             fact = _factor_pollard(n)             todo += (fact, n // fact)     yield from sorted(primes)\n1: def solution(n: int = 4000000) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     getcontext().prec = 100     phi = (Decimal(5) ** Decimal(\"0.5\") + 1) / Decimal(2)      index = (math.floor(math.log(n * (phi + 2), phi) - 1) // 3) * 3 + 2     num = Decimal(round(phi ** Decimal(index + 1))) / (phi + 2)     total = num // 2     return int(total)\n2: def armstrong_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False      # Initialization of sum and number of digits.     total = 0     number_of_digits = 0     temp = n     # Calculation of digits of the number     number_of_digits = len(str(n))     # Dividing number into separate digits and find Armstrong number     temp = n     while temp > 0:         rem = temp % 10         total += rem**number_of_digits         temp //= 10     return n == total", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef generate_first_solution(path, dict_of_neighbours):\n\n    with open(path) as f:\n        start_node = f.read(1)\n    end_node = start_node\n\n    first_solution = []\n\n    visiting = start_node\n\n    distance_of_first_solution = 0\n    while visiting not in first_solution:\n        minim = 10000\n        for k in dict_of_neighbours[visiting]:\n            if int(k[1]) < int(minim) and k[0] not in first_solution:\n                minim = k[1]\n                best_node = k[0]\n\n        first_solution.append(visiting)\n        distance_of_first_solution = distance_of_first_solution + int(minim)\n        visiting = best_node\n\n    first_solution.append(end_node)\n\n    position = 0\n    for k in dict_of_neighbours[first_solution[-2]]:\n        if k[0] == start_node:\n            break\n        position += 1\n\n    distance_of_first_solution = (\n        distance_of_first_solution\n        + int(dict_of_neighbours[first_solution[-2]][position][1])\n        - 10000\n    )\n    return first_solution, distance_of_first_solution", "output": "Pure implementation of generating the first solution for the Tabu search to start,"}
{"task": "summary", "input": "summarize code:\ndef copy_tree(src, dst, symlinks=False, ignore=None):\n    names = os.listdir(src)\n    if ignore is not None:\n        ignored_names = ignore(src, names)\n    else:\n        ignored_names = set()\n\n    mkdir_p(dst)\n    errors = []\n    for name in names:\n        if name in ignored_names:\n            continue\n        srcname = os.path.join(src, name)\n        dstname = os.path.join(dst, name)\n        try:\n            if symlinks and os.path.islink(srcname):\n                linkto = os.readlink(srcname)\n                os.symlink(linkto, dstname)\n            elif os.path.isdir(srcname):\n                copytree(srcname, dstname, symlinks, ignore)\n            else:\n                # Will raise a SpecialFileError for unsupported file types\n                copy2(srcname, dstname)\n        # catch the Error from the recursive copytree so that we can\n        # continue with other files\n        except Error as e:\n            errors.extend(e.args[0])\n        except OSError as why:\n            errors.append((srcname, dstname, str(why)))\n    try:\n        copystat(src, dst)\n    except OSError as why:\n        errors.append((src, dst, str(why)))\n    if errors:\n        raise Error(errors)", "output": "The ``copy_tree`` function is an exact copy of the built-in"}
{"task": "search", "input": "search code:\nApply t-SNE for dimensionality reduction.\n\nChoices:\n0: def unique_iter(src, key=None):     if not is_iterable(src):         raise TypeError('expected an iterable, not %r' % type(src))     if key is None:         def key_func(x): return x     elif callable(key):         key_func = key     elif isinstance(key, str):         def key_func(x): return getattr(x, key, x)     else:         raise TypeError('\"key\" expected a string or callable, not %r' % key)     seen = set()     for i in src:         k = key_func(i)         if k not in seen:             seen.add(k)             yield i     return\n1: def apply_tsne(     data_matrix: ndarray,     n_components: int = 2,     learning_rate: float = 200.0,     n_iter: int = 500, ) -> ndarray:     if n_components < 1 or n_iter < 1:         raise ValueError(\"n_components and n_iter must be >= 1\")      n_samples = data_matrix.shape[0]     rng = np.random.default_rng()     embedding = rng.standard_normal((n_samples, n_components)) * 1e-4      high_dim_affinities = compute_pairwise_affinities(data_matrix)     high_dim_affinities = np.maximum(high_dim_affinities, 1e-12)      embedding_increment = np.zeros_like(embedding)     momentum = 0.5      for iteration in range(n_iter):         low_dim_affinities, numerator_matrix = compute_low_dim_affinities(embedding)         low_dim_affinities = np.maximum(low_dim_affinities, 1e-12)          affinity_diff = high_dim_affinities - low_dim_affinities          gradient = 4 * (             np.dot((affinity_diff * numerator_matrix), embedding)             - np.multiply(                 np.sum(affinity_diff * numerator_matrix, axis=1)[:, np.newaxis],                 embedding,             )         )          embedding_increment = momentum * embedding_increment - learning_rate * gradient         embedding += embedding_increment          if iteration == int(n_iter / 4):             momentum = 0.8      return embedding\n2: def elf_hash(data: str) -> int:     hash_ = x = 0     for letter in data:         hash_ = (hash_ << 4) + ord(letter)         x = hash_ & 0xF0000000         if x != 0:             hash_ ^= x >> 24         hash_ &= ~x     return hash_", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef contains_origin(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> bool:\n    point_a: tuple[int, int] = (x1, y1)\n    point_a_to_b: tuple[int, int] = (x2 - x1, y2 - y1)\n    point_a_to_c: tuple[int, int] = (x3 - x1, y3 - y1)\n    a: float = -vector_product(point_a, point_a_to_b) / vector_product(\n        point_a_to_c, point_a_to_b\n    )\n    b: float = +vector_product(point_a, point_a_to_c) / vector_product(\n        point_a_to_c, point_a_to_b\n    )\n\n    return a > 0 and b > 0 and a + b < 1", "output": "Check if the triangle given by the points A(x1, y1), B(x2, y2), C(x3, y3)"}
{"task": "summary", "input": "summarize code:\ndef compress(source_path: str, destination_path: str) -> None:\n    data_bits = read_file_binary(source_path)\n    data_bits = remove_prefix(data_bits)\n    decompressed = decompress_data(data_bits)\n    write_file_binary(destination_path, decompressed)", "output": "Reads source file, decompresses it and writes the result in destination file"}
{"task": "search", "input": "search code:\nBenchmark multiple functions, with three different length int values.\n\nChoices:\n0: def take(n, iterable):     return list(islice(iterable, n))\n1: def preprocess(edge_array):     for i in range(len(edge_array)):         for j in range(len(edge_array[i])):             t = edge_array[i][j].split(\"-\")             edge_array[i][j] = t\n2: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         # print(f\"{call:38} = {func(value)} -- {timing:.4f} seconds\")         print(f\"{call:38} -- {timing:.4f} seconds\")      for value in range(15):  # (1, 7, 14):         for func in (generate_pascal_triangle, generate_pascal_triangle_optimized):             benchmark_a_function(func, value)         print()", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef find_components(\n    reversed_graph: dict[int, list[int]], vert: int, visited: list[bool]\n) -> list[int]:\n\n    visited[vert] = True\n    component = [vert]\n\n    for neighbour in reversed_graph[vert]:\n        if not visited[neighbour]:\n            component += find_components(reversed_graph, neighbour, visited)\n\n    return component", "output": "Use depth first search to find strongly connected"}
{"task": "summary", "input": "summarize code:\ndef assign(values, s, d):\n    other_values = values[s].replace(d, \"\")\n    if all(eliminate(values, s, d2) for d2 in other_values):\n        return values\n    else:\n        return False", "output": "Eliminate all the other values (except d) from values[s] and propagate."}
{"task": "search", "input": "search code:\n[summary]\n\nChoices:\n0: def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:      try:         # Has user provided both inputs?         if not drug_name or not zip_code:             return None          request_url = BASE_URL.format(drug_name, zip_code)         response = httpx.get(request_url, timeout=10).raise_for_status()          # Scrape the data using bs4         soup = BeautifulSoup(response.text, \"html.parser\")          # This list will store the name and price.         pharmacy_price_list = []          # Fetch all the grids that contain the items.         grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})         if grid_list and len(grid_list) > 0:             for grid in grid_list:                 # Get the pharmacy price.                 pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text                  # Get the price of the drug.                 price = grid.find(\"span\", {\"p\", \"price price-large\"}).text                  pharmacy_price_list.append(                     {                         \"pharmacy_name\": pharmacy_name,                         \"price\": price,                     }                 )          return pharmacy_price_list      except (httpx.HTTPError, ValueError):         return None\n1: def unique_in_window(iterable, n, key=None):     if n <= 0:         raise ValueError('n must be greater than 0')      window = deque(maxlen=n)     counts = Counter()     use_key = key is not None      for item in iterable:         if len(window) == n:             to_discard = window[0]             if counts[to_discard] == 1:                 del counts[to_discard]             else:                 counts[to_discard] -= 1          k = key(item) if use_key else item         if k not in counts:             yield item         counts[k] += 1         window.append(k)\n2: def radix_sort(list_of_ints: list[int]) -> list[int]:     placement = 1     max_digit = max(list_of_ints)     while placement <= max_digit:         # declare and initialize empty buckets         buckets: list[list] = [[] for _ in range(RADIX)]         # split list_of_ints between the buckets         for i in list_of_ints:             tmp = int((i / placement) % RADIX)             buckets[tmp].append(i)         # put each buckets' contents into list_of_ints         a = 0         for b in range(RADIX):             for i in buckets[b]:                 list_of_ints[a] = i                 a += 1         # move to next         placement *= RADIX     return list_of_ints", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result", "output": "def prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result"}
{"task": "summary", "input": "summarize code:\ndef take(n, iterable):\n    return list(islice(iterable, n))", "output": "Return first *n* items of the *iterable* as a list."}
{"task": "search", "input": "search code:\nTo evaluate the solution, use solution()\n\nChoices:\n0: def multiplication_table(number: int, number_of_terms: int) -> str:     return \"\\n\".join(         f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)     )\n1: def decrypt(ciphertext: str, key: str) -> str:     if not isinstance(ciphertext, str):         raise TypeError(\"ciphertext must be a string\")     if not isinstance(key, str):         raise TypeError(\"key must be a string\")      if not ciphertext:         raise ValueError(\"ciphertext is empty\")     if not key:         raise ValueError(\"key is empty\")      key = key.lower()     ciphertext_iterator = 0     key_iterator = 0     plaintext = \"\"     while ciphertext_iterator < len(ciphertext):         if (             ord(ciphertext[ciphertext_iterator]) < 97             or ord(ciphertext[ciphertext_iterator]) > 122         ):             plaintext += ciphertext[ciphertext_iterator]         else:             plaintext += chr(                 (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26                 + 97             )             key += chr(                 (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26                 + 97             )             key_iterator += 1         ciphertext_iterator += 1     return plaintext\n2: def solution(max_power: int = 9) -> int:     result = 0     for length in range(1, max_power + 1):         result += reversible_numbers(length, 0, [0] * length, length)     return result", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:\n    coefficients = {1}\n    previous_coefficients = [1]\n    for _ in range(2, depth + 1):\n        coefficients_begins_one = [*previous_coefficients, 0]\n        coefficients_ends_one = [0, *previous_coefficients]\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients", "output": "Returns the unique coefficients of a Pascal's triangle of depth \"depth\"."}
{"task": "search", "input": "search code:\nCalculates the value of Gamma function of num\n\nChoices:\n0: def make_tree_nine() -> Node:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     tree.right.right = Node(6)     tree.left.left.left = Node(7)     tree.left.left.right = Node(8)     tree.left.right.right = Node(9)     return tree\n1: def gamma_iterative(num: float) -> float:     if num <= 0:         raise ValueError(\"math domain error\")      return quad(integrand, 0, inf, args=(num))[0]\n2: def indian_phone_validator(phone: str) -> bool:     pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")     if match := re.search(pat, phone):         return match.string == phone     return False", "output": "1"}
{"task": "detection", "input": "classify code:\ndef split(string: str, seperator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values seperated by the seperator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",seperator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",seperator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",seperator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == seperator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "BUGGY"}
{"task": "search", "input": "search code:\nOne common application of Quickselect is finding the median, which is\n\nChoices:\n0: def median(items: list):     mid, rem = divmod(len(items), 2)     if rem != 0:         return quick_select(items=items, index=mid)     else:         low_mid = quick_select(items=items, index=mid - 1)         high_mid = quick_select(items=items, index=mid)         return (low_mid + high_mid) / 2\n1: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)\n2: def binary_mod_multiply(a: int, b: int, modulus: int) -> int:     res = 0     while b > 0:         if b & 1:             res = ((res % modulus) + (a % modulus)) % modulus          a += a         b >>= 1      return res", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef array_equalization(vector: list[int], step_size: int) -> int:\n    if step_size <= 0:\n        raise ValueError(\"Step size must be positive and non-zero.\")\n    if not isinstance(step_size, int):\n        raise ValueError(\"Step size must be an integer.\")\n\n    unique_elements = set(vector)\n    min_updates = maxsize\n\n    for element in unique_elements:\n        elem_index = 0\n        updates = 0\n        while elem_index < len(vector):\n            if vector[elem_index] != element:\n                updates += 1\n                elem_index += step_size\n            else:\n                elem_index += 1\n        min_updates = min(min_updates, updates)\n\n    return min_updates", "output": "This algorithm equalizes all elements of the input vector"}
{"task": "summary", "input": "summarize code:\ndef unwrap_text(text, ending='\\n\\n'):\n    all_grafs = []\n    cur_graf = []\n    for line in text.splitlines():\n        line = line.strip()\n        if line:\n            cur_graf.append(line)\n        else:\n            all_grafs.append(' '.join(cur_graf))\n            cur_graf = []\n    if cur_graf:\n        all_grafs.append(' '.join(cur_graf))\n    if ending is None:\n        return all_grafs\n    return ending.join(all_grafs)", "output": "Unwrap text, the natural complement to :func:`textwrap.wrap`."}
{"task": "detection", "input": "classify code:\ndef binary_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef resistor_parallel(resistors: list[float]) -> float:\n\n    first_sum = 0.00\n    for index, resistor in enumerate(resistors):\n        if resistor <= 0:\n            msg = f\"Resistor at index {index} has a negative or zero value!\"\n            raise ValueError(msg)\n        first_sum += 1 / float(resistor)\n    return 1 / first_sum", "output": "Req = 1/ (1/R1 + 1/R2 + ... + 1/Rn)"}
{"task": "search", "input": "search code:\nPlace a word at the given position.\n\nChoices:\n0: def place_word(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> None:     for i, char in enumerate(word):         if vertical:             puzzle[row + i][col] = char         else:             puzzle[row][col + i] = char\n1: def fizz_buzz(number: int, iterations: int) -> str:     if not isinstance(iterations, int):         raise ValueError(\"iterations must be defined as integers\")     if not isinstance(number, int) or not number >= 1:         raise ValueError(         )     if not iterations >= 1:         raise ValueError(\"Iterations must be done more than 0 times to play FizzBuzz\")      out = \"\"     while number <= iterations:         if number % 3 == 0:             out += \"Fizz\"         if number % 5 == 0:             out += \"Buzz\"         if 0 not in (number % 3, number % 5):             out += str(number)          # print(out)         number += 1         out += \" \"     return out\n2: def padded(iterable, fillvalue=None, n=None, next_multiple=False):     iterator = iter(iterable)     iterator_with_repeat = chain(iterator, repeat(fillvalue))      if n is None:         return iterator_with_repeat     elif n < 1:         raise ValueError('n must be at least 1')     elif next_multiple:          def slice_generator():             for first in iterator:                 yield (first,)                 yield islice(iterator_with_repeat, n - 1)          # While elements exist produce slices of size n         return chain.from_iterable(slice_generator())     else:         # Ensure the first batch is at least size n then iterate         return chain(islice(iterator_with_repeat, n), iterator)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef guess_the_number(lower: int, higher: int, to_guess: int) -> None:\n    assert (\n        isinstance(lower, int) and isinstance(higher, int) and isinstance(to_guess, int)\n    ), 'argument values must be type of \"int\"'\n\n    if lower > higher:\n        raise ValueError(\"argument value for lower and higher must be(lower > higher)\")\n\n    if not lower < to_guess < higher:\n        raise ValueError(\n            \"guess value must be within the range of lower and higher value\"\n        )\n\n    def answer(number: int) -> str:\n        if number > to_guess:\n            return \"high\"\n        elif number < to_guess:\n            return \"low\"\n        else:\n            return \"same\"\n\n    print(\"started...\")\n\n    last_lowest = lower\n    last_highest = higher\n\n    last_numbers = []\n\n    while True:\n        number = get_avg(last_lowest, last_highest)\n        last_numbers.append(number)\n\n        if answer(number) == \"low\":\n            last_lowest = number\n        elif answer(number) == \"high\":\n            last_highest = number\n        else:\n            break\n\n    print(f\"guess the number : {last_numbers[-1]}\")\n    print(f\"details : {last_numbers!s}\")", "output": "The `guess_the_number` function that guess the number by some operations"}
{"task": "search", "input": "search code:\nLike `naturalday`, but append a year for dates more than ~five months away.\n\nChoices:\n0: def naturaldate(value) -> str:     try:         value = dt.date(value.year, value.month, value.day)     except AttributeError:         # Passed value wasn't date-ish         return value     except (OverflowError, ValueError):         # Date arguments out of range         return value     delta = _abs_timedelta(value - dt.date.today())     if delta.days >= 5 * 365 / 12:         return naturalday(value, \"%b %d %Y\")     return naturalday(value)\n1: def longest_common_substring(text1: str, text2: str) -> str:      if not (isinstance(text1, str) and isinstance(text2, str)):         raise ValueError(\"longest_common_substring() takes two strings for inputs\")      if not text1 or not text2:         return \"\"      text1_length = len(text1)     text2_length = len(text2)      dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]     end_pos = 0     max_length = 0      for i in range(1, text1_length + 1):         for j in range(1, text2_length + 1):             if text1[i - 1] == text2[j - 1]:                 dp[i][j] = 1 + dp[i - 1][j - 1]                 if dp[i][j] > max_length:                     end_pos = i                     max_length = dp[i][j]      return text1[end_pos - max_length : end_pos]\n2: def unit_basis_vector(dimension: int, pos: int) -> Vector:     # precondition     assert isinstance(dimension, int)     assert isinstance(pos, int)     ans = [0] * dimension     ans[pos] = 1     return Vector(ans)", "output": "0"}
{"task": "search", "input": "search code:\nCreates a Linked List from the elements of the given sequence\n\nChoices:\n0: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")      for value in (262144, 1125899906842624, 1267650600228229401496703205376):         for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):             benchmark_a_function(func, value)         print()\n1: def compute_transform_tables(     source_string: str,     destination_string: str,     copy_cost: int,     replace_cost: int,     delete_cost: int,     insert_cost: int, ) -> tuple[list[list[int]], list[list[str]]]:     source_seq = list(source_string)     destination_seq = list(destination_string)     len_source_seq = len(source_seq)     len_destination_seq = len(destination_seq)     costs = [         [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]     ops = [         [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]      for i in range(1, len_source_seq + 1):         costs[i][0] = i * delete_cost         ops[i][0] = f\"D{source_seq[i - 1]}\"      for i in range(1, len_destination_seq + 1):         costs[0][i] = i * insert_cost         ops[0][i] = f\"I{destination_seq[i - 1]}\"      for i in range(1, len_source_seq + 1):         for j in range(1, len_destination_seq + 1):             if source_seq[i - 1] == destination_seq[j - 1]:                 costs[i][j] = costs[i - 1][j - 1] + copy_cost                 ops[i][j] = f\"C{source_seq[i - 1]}\"             else:                 costs[i][j] = costs[i - 1][j - 1] + replace_cost                 ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])              if costs[i - 1][j] + delete_cost < costs[i][j]:                 costs[i][j] = costs[i - 1][j] + delete_cost                 ops[i][j] = f\"D{source_seq[i - 1]}\"              if costs[i][j - 1] + insert_cost < costs[i][j]:                 costs[i][j] = costs[i][j - 1] + insert_cost                 ops[i][j] = f\"I{destination_seq[j - 1]}\"      return costs, ops\n2: def make_linked_list(elements_list: Iterable[int]) -> LinkedList:     if not elements_list:         raise Exception(\"The Elements List is empty\")      linked_list = LinkedList()     linked_list.extend(elements_list)     return linked_list", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n\n    for a in range(300):\n        for b in range(a + 1, 400):\n            for c in range(b + 1, 500):\n                if (a + b + c) == 1000 and (a**2) + (b**2) == (c**2):\n                    return a * b * c\n\n    return -1", "output": "Returns the product of a,b,c which are Pythagorean Triplet that satisfies"}
{"task": "search", "input": "search code:\nFind capacitor voltage at any nth second after initiating its charging.\n\nChoices:\n0: def removeprefix(text: str, prefix: str) -> str:     if text.startswith(prefix):         return text[len(prefix):]     return text\n1: def solution(n: int = 100) -> int:      sum_of_squares = n * (n + 1) * (2 * n + 1) / 6     square_of_sum = (n * (n + 1) / 2) ** 2     return int(square_of_sum - sum_of_squares)\n2: def charging_capacitor(     source_voltage: float,  # voltage in volts.     resistance: float,  # resistance in ohms.     capacitance: float,  # capacitance in farads.     time_sec: float,  # time in seconds after charging initiation of capacitor. ) -> float:      if source_voltage <= 0:         raise ValueError(\"Source voltage must be positive.\")     if resistance <= 0:         raise ValueError(\"Resistance must be positive.\")     if capacitance <= 0:         raise ValueError(\"Capacitance must be positive.\")     return round(source_voltage * (1 - exp(-time_sec / (resistance * capacitance))), 3)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef bin_to_decimal(bin_string: str) -> int:\n    bin_string = str(bin_string).strip()\n    if not bin_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = bin_string[0] == \"-\"\n    if is_negative:\n        bin_string = bin_string[1:]\n    if not all(char in \"01\" for char in bin_string):\n        raise ValueError(\"Non-binary value was passed to the function\")\n    decimal_number = 0\n    for char in bin_string:\n        decimal_number = 2 * decimal_number + int(char)\n    return -decimal_number if is_negative else decimal_number", "output": "Convert a binary value to its decimal equivalent"}
{"task": "detection", "input": "classify code:\ndef str_eval(s: str) -> int:\n    \"\"\"\n    Returns product of digits in given string n\n\n    >>> str_eval(\"987654321\")\n    362880\n    >>> str_eval(\"22222222\")\n    256\n    \"\"\"\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef binary_step(vector: np.ndarray) -> np.ndarray:\n\n    return np.where(vector >= 0, 1, 0)", "output": "Implements the binary step function"}
{"task": "search", "input": "search code:\nReturns the n-th prime number.\n\nChoices:\n0: def solution(nth: int = 10001) -> int:      try:         nth = int(nth)     except (TypeError, ValueError):         raise TypeError(\"Parameter nth must be int or castable to int.\") from None     if nth <= 0:         raise ValueError(\"Parameter nth must be greater than or equal to one.\")     primes: list[int] = []     num = 2     while len(primes) < nth:         if is_prime(num):             primes.append(num)             num += 1         else:             num += 1     return primes[len(primes) - 1]\n1: def consume(iterator, n=None):     # Use functions that consume iterators at C speed.     if n is None:         # feed the entire iterator into a zero-length deque         deque(iterator, maxlen=0)     else:         # advance to the empty slice starting at position n         next(islice(iterator, n, n), None)\n2: def remove_word(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> None:     for i in range(len(word)):         if vertical:             puzzle[row + i][col] = \"\"         else:             puzzle[row][col + i] = \"\"", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef mel_to_freq(mels: float) -> float:\n    \"\"\"\n    Convert a frequency in the mel scale to Hertz.\n\n    Args:\n        mels: The frequency in mel scale.\n\n    Returns:\n        The frequency in Hertz.\n\n    Examples:\n    >>> round(mel_to_freq(999.99), 2)\n    1000.01\n    \"\"\"\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)", "output": "def mel_to_freq(mels: float) -> float:\n    \"\"\"\n    Convert a frequency in the mel scale to Hertz.\n\n    Args:\n        mels: The frequency in mel scale.\n\n    Returns:\n        The frequency in Hertz.\n\n    Examples:\n    >>> round(mel_to_freq(999.99), 2)\n    1000.01\n    \"\"\"\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)"}
{"task": "repair", "input": "fix bug:\ndef reverse_letters(input_str: str) -> str:\n    \"\"\"\n    Reverses letters in a given string without adjusting the position of the words\n    >>> reverse_letters('The cat in the hat')\n    'ehT tac ni eht tah'\n    >>> reverse_letters('The quick brown fox jumped over the lazy dog.')\n    'ehT kciuq nworb xof depmuj revo eht yzal .god'\n    >>> reverse_letters('Is this true?')\n    'sI siht ?eurt'\n    >>> reverse_letters(\"I   love       Python\")\n    'I evol nohtyP'\n    \"\"\"\n    return \" \".join([word[::-1] for word in input_str.split()])", "output": "def reverse_letters(sentence: str, length: int = 0) -> str:\n    \"\"\"\n    Reverse all words that are longer than the given length of characters in a sentence.\n    If unspecified, length is taken as 0\n\n    >>> reverse_letters(\"Hey wollef sroirraw\", 3)\n    'Hey fellow warriors'\n    >>> reverse_letters(\"nohtyP is nohtyP\", 2)\n    'Python is Python'\n    >>> reverse_letters(\"1 12 123 1234 54321 654321\", 0)\n    '1 21 321 4321 12345 123456'\n    >>> reverse_letters(\"racecar\")\n    'racecar'\n    \"\"\"\n    return \" \".join(\n        \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()\n    )"}
{"task": "search", "input": "search code:\nTake a positive integer value and return its binary equivalent.\n\nChoices:\n0: def decimal_to_binary_recursive_helper(decimal: int) -> str:     decimal = int(decimal)     if decimal in (0, 1):  # Exit cases for the recursion         return str(decimal)     div, mod = divmod(decimal, 2)     return decimal_to_binary_recursive_helper(div) + str(mod)\n1: def mro_items(type_obj):     # TODO: handle slots?     return itertools.chain.from_iterable(ct.__dict__.items()                                          for ct in type_obj.__mro__)\n2: def _shift_to_odd(n):     'Return s, d such that 2**s * d == n'     s = ((n - 1) ^ n).bit_length() - 1     d = n >> s     assert (1 << s) * d == n and d & 1 and s >= 0     return s, d", "output": "0"}
{"task": "search", "input": "search code:\ncomparable items inside\n\nChoices:\n0: def root_mean_square_error(original: np.ndarray, reference: np.ndarray) -> float:     return float(np.sqrt(((original - reference) ** 2).mean()))\n1: def solution():     constant = []     i = 1      while len(constant) < 1e6:         constant.append(str(i))         i += 1      constant = \"\".join(constant)      return (         int(constant[0])         * int(constant[9])         * int(constant[99])         * int(constant[999])         * int(constant[9999])         * int(constant[99999])         * int(constant[999999])     )\n2: def sort(array: list) -> list:     if len(array) == 0:         return array     max_depth = 2 * math.ceil(math.log2(len(array)))     size_threshold = 16     return intro_sort(array, 0, len(array), size_threshold, max_depth)", "output": "2"}
{"task": "search", "input": "search code:\nhours_worked = The total hours worked\n\nChoices:\n0: def solution():     script_dir = os.path.dirname(os.path.realpath(__file__))     words_file_path = os.path.join(script_dir, \"words.txt\")      words = \"\"     with open(words_file_path) as f:         words = f.readline()      words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]     words = [         word         for word in [sum(ord(x) - 64 for x in word) for word in words]         if word in TRIANGULAR_NUMBERS     ]     return len(words)\n1: def solution(nth: int = 10001) -> int:      try:         nth = int(nth)     except (TypeError, ValueError):         raise TypeError(\"Parameter nth must be int or castable to int.\") from None     if nth <= 0:         raise ValueError(\"Parameter nth must be greater than or equal to one.\")     primes: list[int] = []     num = 2     while len(primes) < nth:         if is_prime(num):             primes.append(num)             num += 1         else:             num += 1     return primes[len(primes) - 1]\n2: def pay(hours_worked: float, pay_rate: float, hours: float = 40) -> float:     # Check that all input parameters are float or integer     assert isinstance(hours_worked, (float, int)), (         \"Parameter 'hours_worked' must be of type 'int' or 'float'\"     )     assert isinstance(pay_rate, (float, int)), (         \"Parameter 'pay_rate' must be of type 'int' or 'float'\"     )     assert isinstance(hours, (float, int)), (         \"Parameter 'hours' must be of type 'int' or 'float'\"     )      normal_pay = hours_worked * pay_rate     over_time = max(0, hours_worked - hours)     over_time_pay = over_time * pay_rate / 2     return normal_pay + over_time_pay", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))", "output": "def num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))"}
{"task": "summary", "input": "summarize code:\ndef main(\n    cities: dict[int, list[int]],\n    ants_num: int,\n    iterations_num: int,\n    pheromone_evaporation: float,\n    alpha: float,\n    beta: float,\n    q: float,  # Pheromone system parameters Q, which is a constant\n) -> tuple[list[int], float]:\n    # Initialize the pheromone matrix\n    cities_num = len(cities)\n    pheromone = [[1.0] * cities_num] * cities_num\n\n    best_path: list[int] = []\n    best_distance = float(\"inf\")\n    for _ in range(iterations_num):\n        ants_route = []\n        for _ in range(ants_num):\n            unvisited_cities = copy.deepcopy(cities)\n            current_city = {next(iter(cities.keys())): next(iter(cities.values()))}\n            del unvisited_cities[next(iter(current_city.keys()))]\n            ant_route = [next(iter(current_city.keys()))]\n            while unvisited_cities:\n                current_city, unvisited_cities = city_select(\n                    pheromone, current_city, unvisited_cities, alpha, beta\n                )\n                ant_route.append(next(iter(current_city.keys())))\n            ant_route.append(0)\n            ants_route.append(ant_route)\n\n        pheromone, best_path, best_distance = pheromone_update(\n            pheromone,\n            cities,\n            pheromone_evaporation,\n            ants_route,\n            q,\n            best_path,\n            best_distance,\n        )\n    return best_path, best_distance", "output": "Ant colony algorithm main function"}
{"task": "detection", "input": "classify code:\ndef merge_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Time Complexity: O(n log n)\n    Space Complexity: O(n)\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def merge(left: list, right: list) -> list:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n\n        :param left: Left collection\n        :param right: Right collection\n        :return: Merged result\n        \"\"\"\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef interleave_longest(*iterables):\n    for xs in zip_longest(*iterables, fillvalue=_marker):\n        for x in xs:\n            if x is not _marker:\n                yield x", "output": "Return a new iterable yielding from each iterable in turn,"}
{"task": "summary", "input": "summarize code:\ndef gravitational_law(\n    force: float, mass_1: float, mass_2: float, distance: float\n) -> dict[str, float]:\n\n    product_of_mass = mass_1 * mass_2\n\n    if (force, mass_1, mass_2, distance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if force < 0:\n        raise ValueError(\"Gravitational force can not be negative\")\n    if distance < 0:\n        raise ValueError(\"Distance can not be negative\")\n    if mass_1 < 0 or mass_2 < 0:\n        raise ValueError(\"Mass can not be negative\")\n    if force == 0:\n        force = GRAVITATIONAL_CONSTANT * product_of_mass / (distance**2)\n        return {\"force\": force}\n    elif mass_1 == 0:\n        mass_1 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_2)\n        return {\"mass_1\": mass_1}\n    elif mass_2 == 0:\n        mass_2 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_1)\n        return {\"mass_2\": mass_2}\n    elif distance == 0:\n        distance = (GRAVITATIONAL_CONSTANT * product_of_mass / (force)) ** 0.5\n        return {\"distance\": distance}\n    raise ValueError(\"One and only one argument must be 0\")", "output": "Input Parameters"}
{"task": "summary", "input": "summarize code:\ndef _abs_timedelta(delta):\n    if delta.days < 0:\n        now = _now()\n        return now - (now + delta)\n    return delta", "output": "Return an \"absolute\" value for a timedelta, always representing a time distance."}
{"task": "summary", "input": "summarize code:\ndef support_vector_regressor(x_train: list, x_test: list, train_user: list) -> float:\n    regressor = SVR(kernel=\"rbf\", C=1, gamma=0.1, epsilon=0.1)\n    regressor.fit(x_train, train_user)\n    y_pred = regressor.predict(x_test)\n    return float(y_pred[0])", "output": "Third method: Support vector regressor"}
{"task": "search", "input": "search code:\nReturns the next number which is triangular, pentagonal and hexagonal.\n\nChoices:\n0: def solution(start: int = 144) -> int:     n = start     num = hexagonal_num(n)     while not is_pentagonal(num):         n += 1         num = hexagonal_num(n)     return num\n1: def binary_exp_mod_recursive(base: float, exponent: int, modulus: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")     if modulus <= 0:         raise ValueError(\"Modulus must be a positive integer\")      if exponent == 0:         return 1      if exponent % 2 == 1:         return (binary_exp_mod_recursive(base, exponent - 1, modulus) * base) % modulus      r = binary_exp_mod_recursive(base, exponent // 2, modulus)     return (r * r) % modulus\n2: def all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:      word_bank = word_bank or []     # create a table     table_size: int = len(target) + 1      table: list[list[list[str]]] = []     for _ in range(table_size):         table.append([])     # seed value     table[0] = [[]]  # because empty string has empty combination      # iterate through the indices     for i in range(table_size):         # condition         if table[i] != []:             for word in word_bank:                 # slice condition                 if target[i : i + len(word)] == word:                     new_combinations: list[list[str]] = [                         [word, *way] for way in table[i]                     ]                     # adds the word to every combination the current position holds                     # now,push that combination to the table[i+len(word)]                     table[i + len(word)] += new_combinations      # combinations are in reverse order so reverse for better output     for combination in table[len(target)]:         combination.reverse()      return table[len(target)]", "output": "0"}
{"task": "detection", "input": "classify code:\ndef geometric_series(\n    nth_term: float | int,\n    start_term_a: float | int,\n    common_ratio_r: float | int,\n) -> list[float | int]:\n    \"\"\"\n    Pure Python implementation of Geometric Series algorithm\n\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\n    >>> geometric_series(4, 2, -2)\n    [2, -4.0, 8.0, -16.0]\n    >>> geometric_series(4, -2, 2)\n    [-2, -4.0, -8.0, -16.0]\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float | int] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the nth lucas number\n\nChoices:\n0: def find_triplets_with_0_sum(nums: list[int]) -> list[list[int]]:     return [         list(x)         for x in sorted({abc for abc in combinations(sorted(nums), 3) if not sum(abc)})     ]\n1: def dynamic_lucas_number(n_th_number: int) -> int:     if not isinstance(n_th_number, int):         raise TypeError(\"dynamic_lucas_number accepts only integer arguments.\")     a, b = 2, 1     for _ in range(n_th_number):         a, b = b, a + b     return a\n2: def kinetic_energy(mass: float, velocity: float) -> float:     if mass < 0:         raise ValueError(\"The mass of a body cannot be negative\")     return 0.5 * mass * abs(velocity) * abs(velocity)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef base16_encode(inp: str) -> bytes:\n    \"\"\"\n    Encodes a given utf-8 string into base-16.\n\n    >>> base16_encode('Hello World!')\n    b'48656C6C6F20576F726C6421'\n    >>> base16_encode('HELLO WORLD!')\n    b'48454C4C4F20574F524C4421'\n    >>> base16_encode('')\n    b''\n    \"\"\"\n    # encode the input into a bytes-like object and then encode b16encode that\n    return base64.b16encode(inp.encode(\"utf-8\"))", "output": "def base16_encode(data: bytes) -> str:\n    \"\"\"\n    Encodes the given bytes into base16.\n\n    >>> base16_encode(b'Hello World!')\n    '48656C6C6F20576F726C6421'\n    >>> base16_encode(b'HELLO WORLD!')\n    '48454C4C4F20574F524C4421'\n    >>> base16_encode(b'')\n    ''\n    \"\"\"\n    # Turn the data into a list of integers (where each integer is a byte),\n    # Then turn each byte into its hexadecimal representation, make sure\n    # it is uppercase, and then join everything together and return it.\n    return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])"}
{"task": "summary", "input": "summarize code:\ndef powerset(iterable):\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))", "output": "Yields all possible subsets of the iterable."}
{"task": "summary", "input": "summarize code:\ndef electrical_impedance(\n    resistance: float, reactance: float, impedance: float\n) -> dict[str, float]:\n    if (resistance, reactance, impedance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if resistance == 0:\n        return {\"resistance\": sqrt(pow(impedance, 2) - pow(reactance, 2))}\n    elif reactance == 0:\n        return {\"reactance\": sqrt(pow(impedance, 2) - pow(resistance, 2))}\n    elif impedance == 0:\n        return {\"impedance\": sqrt(pow(resistance, 2) + pow(reactance, 2))}\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")", "output": "Apply Electrical Impedance formula, on any two given electrical values,"}
{"task": "search", "input": "search code:\nReturn the largest power of two less than or equal to a number.\n\nChoices:\n0: def sieve(n: int) -> list[int]:      if n <= 0 or isinstance(n, float):         msg = f\"Number {n} must instead be a positive integer\"         raise ValueError(msg)      in_prime = []     start = 2     end = int(math.sqrt(n))  # Size of every segment     temp = [True] * (end + 1)     prime = []      while start <= end:         if temp[start] is True:             in_prime.append(start)             for i in range(start * start, end + 1, start):                 temp[i] = False         start += 1     prime += in_prime      low = end + 1     high = min(2 * end, n)      while low <= n:         temp = [True] * (high - low + 1)         for each in in_prime:             t = math.floor(low / each) * each             if t < low:                 t += each              for j in range(t, high + 1, each):                 temp[j - low] = False          for j in range(len(temp)):             if temp[j] is True:                 prime.append(j + low)          low = high + 1         high = min(high + end, n)      return prime\n1: def iterate_function(     eval_function: Callable[[Any, np.ndarray], np.ndarray],     function_params: Any,     nb_iterations: int,     z_0: np.ndarray,     infinity: float | None = None, ) -> np.ndarray:      z_n = z_0.astype(\"complex64\")     for _ in range(nb_iterations):         z_n = eval_function(function_params, z_n)         if infinity is not None:             np.nan_to_num(z_n, copy=False, nan=infinity)             z_n[abs(z_n) == np.inf] = infinity     return z_n\n2: def largest_pow_of_two_le_num(number: int) -> int:     if isinstance(number, float):         raise TypeError(\"Input value must be a 'int' type\")     if number <= 0:         return 0     res = 1     while (res << 1) <= number:         res <<= 1     return res", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef ncycles(iterable, n):\n    return chain.from_iterable(repeat(tuple(iterable), n))", "output": "Returns the sequence elements *n* times"}
{"task": "detection", "input": "classify code:\ndef equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef lin_search(left: int, right: int, array: list[int], target: int) -> int:\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1", "output": "Perform linear search in list. Returns -1 if element is not found."}
{"task": "search", "input": "search code:\nComputes the sorted sequence of digits of the cube of num.\n\nChoices:\n0: def get_digits(num: int) -> str:     return \"\".join(sorted(str(num**3)))\n1: def generate_parenthesis(n: int) -> list[str]:      result: list[str] = []     backtrack(\"\", 0, 0, n, result)     return result\n2: def new_generation(cells: list[list[int]]) -> list[list[int]]:     next_generation = []     for i in range(len(cells)):         next_generation_row = []         for j in range(len(cells[i])):             # Get the number of live neighbours             neighbour_count = 0             if i > 0 and j > 0:                 neighbour_count += cells[i - 1][j - 1]             if i > 0:                 neighbour_count += cells[i - 1][j]             if i > 0 and j < len(cells[i]) - 1:                 neighbour_count += cells[i - 1][j + 1]             if j > 0:                 neighbour_count += cells[i][j - 1]             if j < len(cells[i]) - 1:                 neighbour_count += cells[i][j + 1]             if i < len(cells) - 1 and j > 0:                 neighbour_count += cells[i + 1][j - 1]             if i < len(cells) - 1:                 neighbour_count += cells[i + 1][j]             if i < len(cells) - 1 and j < len(cells[i]) - 1:                 neighbour_count += cells[i + 1][j + 1]              # Rules of the game of life (excerpt from Wikipedia):             # 1. Any live cell with two or three live neighbours survives.             # 2. Any dead cell with three live neighbours becomes a live cell.             # 3. All other live cells die in the next generation.             #    Similarly, all other dead cells stay dead.             alive = cells[i][j] == 1             if (alive and 2 <= neighbour_count <= 3) or (                 not alive and neighbour_count == 3             ):                 next_generation_row.append(1)             else:                 next_generation_row.append(0)          next_generation.append(next_generation_row)     return next_generation", "output": "0"}
{"task": "search", "input": "search code:\n:param n: dimension for nxn matrix\n\nChoices:\n0: def find_repeat(     matrix_g: list[list[str]], row: int, column: int, size: int ) -> set[tuple[int, int]]:      column = size - 1 - column     visited = set()     repeated = set()      if (color := matrix_g[column][row]) != \"-\":          def dfs(row_n: int, column_n: int) -> None:             if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:                 return             if (row_n, column_n) in visited:                 return             visited.add((row_n, column_n))             if matrix_g[row_n][column_n] == color:                 repeated.add((row_n, column_n))                 dfs(row_n - 1, column_n)                 dfs(row_n + 1, column_n)                 dfs(row_n, column_n - 1)                 dfs(row_n, column_n + 1)          dfs(column, row)      return repeated\n1: def identity(n: int) -> list[list[int]]:     n = int(n)     return [[int(row == column) for column in range(n)] for row in range(n)]\n2: def run(n: int) -> list[int]:      # Incrementor variable for our group list comprehension.     # This is the first number in each list of values     # to test.     base = 2      while True:         # Increment each value of a generated range         group = [base + i for i in range(n)]          # Run elements through the unique_prime_factors function         # Append our target number to the end.         checker = [upf_len(x) for x in group]         checker.append(n)          # If all numbers in the list are equal, return the group variable.         if equality(checker):             return group          # Increment our base variable by 1         base += 1", "output": "1"}
{"task": "search", "input": "search code:\nConvert a Decimal Number to an Octal Number.\n\nChoices:\n0: def decimal_to_octal(num: int) -> str:     octal = 0     counter = 0     while num > 0:         remainder = num % 8         octal = octal + (remainder * math.floor(math.pow(10, counter)))         counter += 1         num = math.floor(num / 8)  # basically /= 8 without remainder if any         # This formatting removes trailing '.0' from `octal`.     return f\"0o{int(octal)}\"\n1: def dpll_algorithm(     clauses: list[Clause], symbols: list[str], model: dict[str, bool | None] ) -> tuple[bool | None, dict[str, bool | None] | None]:     check_clause_all_true = True     for clause in clauses:         clause_check = clause.evaluate(model)         if clause_check is False:             return False, None         elif clause_check is None:             check_clause_all_true = False             continue      if check_clause_all_true:         return True, model      try:         pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)     except RecursionError:         print(\"raises a RecursionError and is\")         return None, {}     p = None     if len(pure_symbols) > 0:         p, value = pure_symbols[0], assignment[pure_symbols[0]]      if p:         tmp_model = model         tmp_model[p] = value         tmp_symbols = list(symbols)         if p in tmp_symbols:             tmp_symbols.remove(p)         return dpll_algorithm(clauses, tmp_symbols, tmp_model)      unit_symbols, assignment = find_unit_clauses(clauses, model)     p = None     if len(unit_symbols) > 0:         p, value = unit_symbols[0], assignment[unit_symbols[0]]     if p:         tmp_model = model         tmp_model[p] = value         tmp_symbols = list(symbols)         if p in tmp_symbols:             tmp_symbols.remove(p)         return dpll_algorithm(clauses, tmp_symbols, tmp_model)     p = symbols[0]     rest = symbols[1:]     tmp1, tmp2 = model, model     tmp1[p], tmp2[p] = True, False      return dpll_algorithm(clauses, rest, tmp1) or dpll_algorithm(clauses, rest, tmp2)\n2: def solution(numerator: int = 1, digit: int = 1000) -> int:     the_digit = 1     longest_list_length = 0      for divide_by_number in range(numerator, digit + 1):         has_been_divided: list[int] = []         now_divide = numerator         for _ in range(1, digit + 1):             if now_divide in has_been_divided:                 if longest_list_length < len(has_been_divided):                     longest_list_length = len(has_been_divided)                     the_digit = divide_by_number             else:                 has_been_divided.append(now_divide)                 now_divide = now_divide * 10 % divide_by_number      return the_digit", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef floor(x: float) -> int:\n    return int(x) if x - int(x) >= 0 else int(x) - 1", "output": "Return the floor of x as an Integral."}
{"task": "search", "input": "search code:\nCalculates the list of primes up to and including `max_num`.\n\nChoices:\n0: def solution():     return next(i for i in triangle_number_generator() if count_divisors(i) > 500)\n1: def generate_primes(max_num: int) -> list[int]:     are_primes = [True] * (max_num + 1)     are_primes[0] = are_primes[1] = False     for i in range(2, isqrt(max_num) + 1):         if are_primes[i]:             for j in range(i * i, max_num + 1, i):                 are_primes[j] = False      return [prime for prime, is_prime in enumerate(are_primes) if is_prime]\n2: def charging_inductor(     source_voltage: float,  # source_voltage should be in volts.     resistance: float,  # resistance should be in ohms.     inductance: float,  # inductance should be in henrys.     time: float,  # time should in seconds. ) -> float:      if source_voltage <= 0:         raise ValueError(\"Source voltage must be positive.\")     if resistance <= 0:         raise ValueError(\"Resistance must be positive.\")     if inductance <= 0:         raise ValueError(\"Inductance must be positive.\")     return round(         source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3     )", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef dp_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Dynamic programming matching algorithm.\n\n    | Time complexity: O(\\|text\\| * \\|pattern\\|)\n    | Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]", "output": "def dp_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Dynamic programming matching algorithm.\n\n    | Time complexity: O(\\|text\\| * \\|pattern\\|)\n    | Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]"}
{"task": "search", "input": "search code:\nUse a stack to check if a string of parentheses is balanced.\n\nChoices:\n0: def balanced_parentheses(parentheses: str) -> bool:     stack: Stack[str] = Stack()     bracket_pairs = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}     for bracket in parentheses:         if bracket in bracket_pairs:             stack.push(bracket)         elif bracket in (\")\", \"]\", \"}\") and (             stack.is_empty() or bracket_pairs[stack.pop()] != bracket         ):             return False     return stack.is_empty()\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def solution():     days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]      day = 6     month = 1     year = 1901      sundays = 0      while year < 2001:         day += 7          if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):             if day > days_per_month[month - 1] and month != 2:                 month += 1                 day = day - days_per_month[month - 2]             elif day > 29 and month == 2:                 month += 1                 day = day - 29         elif day > days_per_month[month - 1]:             month += 1             day = day - days_per_month[month - 2]          if month > 12:             year += 1             month = 1          if year < 2001 and day == 1:             sundays += 1     return sundays", "output": "0"}
{"task": "detection", "input": "classify code:\ndef increment_score(count: int) -> int:\n    \"\"\"\n    Calculates the score for a move based on the number of elements removed.\n\n    >>> increment_score(3)\n    6\n    >>> increment_score(0)\n    0\n    \"\"\"\n    return int(count * (count + 1) / 2)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef decimal_to_ipv4(decimal_ipv4: int) -> str:\n\n    if not (0 <= decimal_ipv4 <= 4294967295):\n        raise ValueError(\"Invalid decimal IPv4 address\")\n\n    ip_parts = []\n    for _ in range(4):\n        ip_parts.append(str(decimal_ipv4 & 255))\n        decimal_ipv4 >>= 8\n\n    return \".\".join(reversed(ip_parts))", "output": "Convert a decimal representation of an IP address to its IPv4 format."}
{"task": "repair", "input": "fix bug:\ndef prime_sieve(n: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "def prime_sieve(n: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes"}
{"task": "search", "input": "search code:\nReturn the nth prime (counting from 0).\n\nChoices:\n0: def nth_prime(n, *, approximate=False):     lb, ub = _nth_prime_bounds(n + 1)      if not approximate or n <= 1_000_000:         return nth(sieve(ceil(ub)), n)      # Search from the midpoint and return the first odd prime     odd = floor((lb + ub) / 2) | 1     return first_true(count(odd, step=2), pred=is_prime)\n1: def preprocess(edge_array):     for i in range(len(edge_array)):         for j in range(len(edge_array[i])):             t = edge_array[i][j].split(\"-\")             edge_array[i][j] = t\n2: def factorial(num: int) -> int:     fact = 1     for i in range(1, num + 1):         fact *= i     return fact", "output": "0"}
{"task": "detection", "input": "classify code:\ndef calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef topological_sort(start: str, visited: list[str], sort: list[str]) -> list[str]:\n    current = start\n    # add current to visited\n    visited.append(current)\n    neighbors = edges[current]\n    for neighbor in neighbors:\n        # if neighbor not in visited, visit\n        if neighbor not in visited:\n            sort = topological_sort(neighbor, visited, sort)\n    # if all neighbors visited add current to sort\n    sort.append(current)\n    # if all vertices haven't been visited select a new one to visit\n    if len(visited) != len(vertices):\n        for vertice in vertices:\n            if vertice not in visited:\n                sort = topological_sort(vertice, visited, sort)\n    # return sort\n    return sort", "output": "Perform topological sort on a directed acyclic graph."}
{"task": "repair", "input": "fix bug:\ndef linear_search(sequence, target):\n    \"\"\"Pure implementation of linear search algorithm in Python\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return None", "output": "def linear_search(sequence: list, target: int) -> int:\n    \"\"\"A pure Python implementation of a linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return -1"}
{"task": "detection", "input": "classify code:\ndef scaling(scaling_factor: float) -> List[List[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef get_squarefrees(unique_coefficients: set[int]) -> set[int]:\n    \"\"\"\n    Calculates the squarefree numbers inside unique_coefficients.\n\n    Based on the definition of a non-squarefree number, then any non-squarefree\n    n can be decomposed as n = p*p*r, where p is positive prime number and r\n    is a positive integer.\n\n    Under the previous formula, any coefficient that is lower than p*p is\n    squarefree as r cannot be negative. On the contrary, if any r exists such\n    that n = p*p*r, then the number is non-squarefree.\n\n    >>> get_squarefrees({1})\n    {1}\n    >>> get_squarefrees({1, 2})\n    {1, 2}\n    >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})\n    {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}\n    \"\"\"\n\n    non_squarefrees = set()\n    for number in unique_coefficients:\n        divisor = 2\n        copy_number = number\n        while divisor**2 <= copy_number:\n            multiplicity = 0\n            while copy_number % divisor == 0:\n                copy_number //= divisor\n                multiplicity += 1\n            if multiplicity >= 2:\n                non_squarefrees.add(number)\n                break\n            divisor += 1\n\n    return unique_coefficients.difference(non_squarefrees)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nLoad the Iris dataset and return features and labels.\n\nChoices:\n0: def largest_square_area_in_matrix_top_down_approch(     rows: int, cols: int, mat: list[list[int]] ) -> int:      def update_area_of_max_square(row: int, col: int) -> int:         # BASE CASE         if row >= rows or col >= cols:             return 0          right = update_area_of_max_square(row, col + 1)         diagonal = update_area_of_max_square(row + 1, col + 1)         down = update_area_of_max_square(row + 1, col)          if mat[row][col]:             sub_problem_sol = 1 + min([right, diagonal, down])             largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)             return sub_problem_sol         else:             return 0      largest_square_area = [0]     update_area_of_max_square(0, 0)     return largest_square_area[0]\n1: def knapsack(     weights: list, values: list, number_of_items: int, max_weight: int, index: int ) -> int:     if index == number_of_items:         return 0     ans1 = 0     ans2 = 0     ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)     if weights[index] <= max_weight:         ans2 = values[index] + knapsack(             weights, values, number_of_items, max_weight - weights[index], index + 1         )     return max(ans1, ans2)\n2: def collect_dataset() -> tuple[ndarray, ndarray]:     iris_dataset = load_iris()     return np.array(iris_dataset.data), np.array(iris_dataset.target)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n\n    return next(\n        iter(\n            [\n                a * b * (1000 - a - b)\n                for a in range(1, 999)\n                for b in range(a, 999)\n                if (a * a + b * b == (1000 - a - b) ** 2)\n            ]\n        )\n    )", "output": "Returns the product of a,b,c which are Pythagorean Triplet that satisfies"}
{"task": "summary", "input": "summarize code:\ndef median_of_five(arr: list) -> int:\n    arr = sorted(arr)\n    return arr[len(arr) // 2]", "output": "Return the median of the input list"}
{"task": "detection", "input": "classify code:\ndef is_ip_v4_address_valid(ip_v4_address: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.255.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"254.255.0.255\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n    \"\"\"\n    octets = [int(i) for i in ip_v4_address.split(\".\") if i.isdigit()]\n    return len(octets) == 4 and all(0 <= int(octet) <= 254 for octet in octets)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef fib_memoization(n: int) -> list[int]:\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]", "output": "Calculates the first n (0-indexed) Fibonacci numbers using memoization"}
{"task": "summary", "input": "summarize code:\ndef excel_title_to_column(column_title: str) -> int:\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer", "output": "Given a string column_title that represents"}
{"task": "summary", "input": "summarize code:\ndef print_pascal_triangle(num_rows: int) -> None:\n    triangle = generate_pascal_triangle(num_rows)\n    for row_idx in range(num_rows):\n        # Print left spaces\n        for _ in range(num_rows - row_idx - 1):\n            print(end=\" \")\n        # Print row values\n        for col_idx in range(row_idx + 1):\n            if col_idx != row_idx:\n                print(triangle[row_idx][col_idx], end=\" \")\n            else:\n                print(triangle[row_idx][col_idx], end=\"\")\n        print()", "output": "Print Pascal's triangle for different number of rows"}
{"task": "detection", "input": "classify code:\ndef longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef power(x: int, y: int, mod: int) -> int:\n    \"\"\"\n    Examples:\n    >>> power(2, 15, 3)\n    2\n    >>> power(5, 1, 30)\n    5\n    \"\"\"\n\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, mod) % mod\n    temp = (temp * temp) % mod\n    if y % 2 == 1:\n        temp = (temp * x) % mod\n    return temp", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef lower(word: str) -> str:\n    \"\"\"\n    Will convert the entire string to lowercase letters\n\n    >>> lower(\"wow\")\n    'wow'\n    >>> lower(\"HellZo\")\n    'hellzo'\n    >>> lower(\"WHAT\")\n    'what'\n    >>> lower(\"wh[]32\")\n    'wh[]32'\n    >>> lower(\"whAT\")\n    'what'\n    \"\"\"\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFunction returns the tolerance value associated with the color.\n\nChoices:\n0: def get_tolerance(color: str) -> float:     if color not in tolerance_color_values:         msg = f\"{color} is not a valid color for tolerance band\"         raise ValueError(msg)     return tolerance_color_values[color]\n1: def heaps(arr: list) -> list:      if len(arr) <= 1:         return [tuple(arr)]      res = []      def generate(n: int, arr: list):         c = [0] * n         res.append(tuple(arr))          i = 0         while i < n:             if c[i] < i:                 if i % 2 == 0:                     arr[0], arr[i] = arr[i], arr[0]                 else:                     arr[c[i]], arr[i] = arr[i], arr[c[i]]                 res.append(tuple(arr))                 c[i] += 1                 i = 0             else:                 c[i] = 0                 i += 1      generate(len(arr), arr)     return res\n2: def sum_of_geometric_progression(     first_term: int, common_ratio: int, num_of_terms: int ) -> float:     if common_ratio == 1:         # Formula for sum if common ratio is 1         return num_of_terms * first_term      # Formula for finding sum of n terms of a GeometricProgression     return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)", "output": "0"}
{"task": "search", "input": "search code:\nYield all possible order-preserving partitions of *iterable*.\n\nChoices:\n0: def partitions(iterable):     sequence = list(iterable)     n = len(sequence)     for i in powerset(range(1, n)):         yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]\n1: def tarjan(g: list[list[int]]) -> list[list[int]]:      n = len(g)     stack: deque[int] = deque()     on_stack = [False for _ in range(n)]     index_of = [-1 for _ in range(n)]     lowlink_of = index_of[:]      def strong_connect(v: int, index: int, components: list[list[int]]) -> int:         index_of[v] = index  # the number when this node is seen         lowlink_of[v] = index  # lowest rank node reachable from here         index += 1         stack.append(v)         on_stack[v] = True          for w in g[v]:             if index_of[w] == -1:                 index = strong_connect(w, index, components)                 lowlink_of[v] = (                     lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]                 )             elif on_stack[w]:                 lowlink_of[v] = (                     lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]                 )          if lowlink_of[v] == index_of[v]:             component = []             w = stack.pop()             on_stack[w] = False             component.append(w)             while w != v:                 w = stack.pop()                 on_stack[w] = False                 component.append(w)             components.append(component)         return index      components: list[list[int]] = []     for v in range(n):         if index_of[v] == -1:             strong_connect(v, 0, components)      return components\n2: def get_bitcode(edge_array, distinct_edge):     bitcode = [\"0\"] * len(edge_array)     for i, row in enumerate(edge_array):         for item in row:             if distinct_edge in item[0]:                 bitcode[i] = \"1\"                 break     return \"\".join(bitcode)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef surface_area_cube(side_length: Union[int, float]) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * pow(side_length, 2)\r", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))", "output": "def minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))"}
{"task": "summary", "input": "summarize code:\ndef reverse_inorder(root: Node | None) -> Generator[int]:\n    if not root:\n        return\n    yield from reverse_inorder(root.right)\n    yield root.data\n    yield from reverse_inorder(root.left)", "output": "Reverse in-order traversal visits right subtree, root node, left subtree."}
{"task": "repair", "input": "fix bug:\ndef damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    \"\"\"\n    Implements the Damerau-Levenshtein distance algorithm that measures\n    the edit distance between two strings.\n\n    Parameters:\n        first_string: The first string to compare\n        second_string: The second string to compare\n\n    Returns:\n        distance: The edit distance between the first and second strings\n\n    >>> damerau_levenshtein_distance(\"cat\", \"cut\")\n    1\n    >>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n    3\n    >>> damerau_levenshtein_distance(\"hello\", \"world\")\n    4\n    >>> damerau_levenshtein_distance(\"book\", \"back\")\n    2\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    \"\"\"\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]", "output": "def damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    \"\"\"\n    Implements the Damerau-Levenshtein distance algorithm that measures\n    the edit distance between two strings.\n\n    Parameters:\n        first_string: The first string to compare\n        second_string: The second string to compare\n\n    Returns:\n        distance: The edit distance between the first and second strings\n\n    >>> damerau_levenshtein_distance(\"cat\", \"cut\")\n    1\n    >>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n    3\n    >>> damerau_levenshtein_distance(\"hello\", \"world\")\n    4\n    >>> damerau_levenshtein_distance(\"book\", \"back\")\n    2\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    \"\"\"\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]"}
{"task": "repair", "input": "fix bug:\ndef find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n    \"\"\"\n    n = len(nums)\n    missing_number = n\n\n    for i in range(n):\n        missing_number ^= i ^ nums[i]\n\n    return missing_number", "output": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n\n    for i in range(low, high):\n        missing_number ^= i ^ nums[i - low]\n\n    return missing_number"}
{"task": "summary", "input": "summarize code:\ndef rgb_to_gray(rgb: np.ndarray) -> np.ndarray:\n    r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]\n    return 0.2989 * r + 0.5870 * g + 0.1140 * b", "output": "Return gray image from rgb image"}
{"task": "search", "input": "search code:\ndivide and conquer approach\n\nChoices:\n0: def closest_pair_of_points_sqr(points_sorted_on_x, points_sorted_on_y, points_counts):      # base case     if points_counts <= 3:         return dis_between_closest_pair(points_sorted_on_x, points_counts)      # recursion     mid = points_counts // 2     closest_in_left = closest_pair_of_points_sqr(         points_sorted_on_x, points_sorted_on_y[:mid], mid     )     closest_in_right = closest_pair_of_points_sqr(         points_sorted_on_y, points_sorted_on_y[mid:], points_counts - mid     )     closest_pair_dis = min(closest_in_left, closest_in_right)       cross_strip = []     for point in points_sorted_on_x:         if abs(point[0] - points_sorted_on_x[mid][0]) < closest_pair_dis:             cross_strip.append(point)      closest_in_strip = dis_between_closest_in_strip(         cross_strip, len(cross_strip), closest_pair_dis     )     return min(closest_pair_dis, closest_in_strip)\n1: def download_image(url: str) -> str:     try:         response = httpx.get(url, timeout=10)         response.raise_for_status()     except httpx.RequestError as e:         return f\"An error occurred during the HTTP request to {url}: {e!r}\"      soup = BeautifulSoup(response.text, \"html.parser\")     image_meta_tag = soup.find(\"meta\", {\"property\": \"og:image\"})     if not image_meta_tag:         return \"No meta tag with property 'og:image' was found.\"      image_url = image_meta_tag.get(\"content\")     if not image_url:         return f\"Image URL not found in meta tag {image_meta_tag}.\"      try:         image_data = httpx.get(image_url, timeout=10).content     except httpx.RequestError as e:         return f\"An error occurred during the HTTP request to {image_url}: {e!r}\"     if not image_data:         return f\"Failed to download the image from {image_url}.\"      file_name = f\"{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H-%M-%S}.jpg\"     with open(file_name, \"wb\") as out_file:         out_file.write(image_data)     return f\"Image downloaded and saved in the file {file_name}\"\n2: def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:     return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef cardinalize(unit_noun, count):\n    if count == 1:\n        return unit_noun\n    return pluralize(unit_noun)", "output": "Conditionally pluralizes a singular word *unit_noun* if"}
{"task": "summary", "input": "summarize code:\ndef change_brightness(img: Image, level: float) -> Image:\n\n    def brightness(c: int) -> float:\n        return 128 + level + (c - 128)\n\n    if not -255.0 <= level <= 255.0:\n        raise ValueError(\"level must be between -255.0 (black) and 255.0 (white)\")\n    return img.point(brightness)", "output": "Change the brightness of a PIL Image to a given level."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 51) -> int:\n    unique_coefficients = get_pascal_triangle_unique_coefficients(n)\n    squarefrees = get_squarefrees(unique_coefficients)\n    return sum(squarefrees)", "output": "Returns the sum of squarefrees for a given Pascal's Triangle of depth n."}
{"task": "search", "input": "search code:\nSorts a list using the binary insertion sort algorithm.\n\nChoices:\n0: def solution(min_block_length: int = 50) -> int:      fill_count_functions = [1] * min_block_length      for n in count(min_block_length):         fill_count_functions.append(1)          for block_length in range(min_block_length, n + 1):             for block_start in range(n - block_length):                 fill_count_functions[n] += fill_count_functions[                     n - block_start - block_length - 1                 ]              fill_count_functions[n] += 1          if fill_count_functions[n] > 1_000_000:             break      return n\n1: def binary_insertion_sort(collection: list) -> list:      n = len(collection)     for i in range(1, n):         value_to_insert = collection[i]         low = 0         high = i - 1          while low <= high:             mid = (low + high) // 2             if value_to_insert < collection[mid]:                 high = mid - 1             else:                 low = mid + 1         for j in range(i, low, -1):             collection[j] = collection[j - 1]         collection[low] = value_to_insert     return collection\n2: def largest_rectangle_area(heights: list[int]) -> int:     stack: list[int] = []     max_area = 0     heights = [*heights, 0]  # make a new list by appending the sentinel 0     n = len(heights)      for i in range(n):         # make sure the stack remains in increasing order         while stack and heights[i] < heights[stack[-1]]:             h = heights[stack.pop()]  # height of the bar             # if stack is empty, it means entire width can be taken from index 0 to i-1             w = i if not stack else i - stack[-1] - 1  # calculate width             max_area = max(max_area, h * w)          stack.append(i)      return max_area", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef rsafactor(d: int, e: int, n: int) -> list[int]:\n    k = d * e - 1\n    p = 0\n    q = 0\n    while p == 0:\n        g = random.randint(2, n - 1)\n        t = k\n        while True:\n            if t % 2 == 0:\n                t = t // 2\n                x = (g**t) % n\n                y = math.gcd(x - 1, n)\n                if x > 1 and y > 1:\n                    p = y\n                    q = n // y\n                    break  # find the correct factors\n            else:\n                break  # t is not divisible by 2, break and choose another g\n    return sorted([p, q])", "output": "This function returns the factors of N, where p*q=N"}
{"task": "summary", "input": "summarize code:\ndef ignore_overflow_warnings() -> None:\n    warnings.filterwarnings(\n        \"ignore\", category=RuntimeWarning, message=\"overflow encountered in multiply\"\n    )\n    warnings.filterwarnings(\n        \"ignore\",\n        category=RuntimeWarning,\n        message=\"invalid value encountered in multiply\",\n    )\n    warnings.filterwarnings(\n        \"ignore\", category=RuntimeWarning, message=\"overflow encountered in absolute\"\n    )\n    warnings.filterwarnings(\n        \"ignore\", category=RuntimeWarning, message=\"overflow encountered in exp\"\n    )", "output": "Ignore some overflow and invalid value warnings."}
{"task": "search", "input": "search code:\nFormula for amortization amount per month:\n\nChoices:\n0: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n1: def median_of_five(arr: list) -> int:     arr = sorted(arr)     return arr[len(arr) // 2]\n2: def equated_monthly_installments(     principal: float, rate_per_annum: float, years_to_repay: int ) -> float:     if principal <= 0:         raise Exception(\"Principal borrowed must be > 0\")     if rate_per_annum < 0:         raise Exception(\"Rate of interest must be >= 0\")     if years_to_repay <= 0 or not isinstance(years_to_repay, int):         raise Exception(\"Years to repay must be an integer > 0\")      # Yearly rate is divided by 12 to get monthly rate     rate_per_month = rate_per_annum / 12      # Years to repay is multiplied by 12 to get number of payments as payment is monthly     number_of_payments = years_to_repay * 12      return (         principal         * rate_per_month         * (1 + rate_per_month) ** number_of_payments         / ((1 + rate_per_month) ** number_of_payments - 1)     )", "output": "2"}
{"task": "search", "input": "search code:\nThis function can calculate any one of the three -\n\nChoices:\n0: def electric_conductivity(     conductivity: float,     electron_conc: float,     mobility: float, ) -> tuple[str, float]:     if (conductivity, electron_conc, mobility).count(0) != 1:         raise ValueError(\"You cannot supply more or less than 2 values\")     elif conductivity < 0:         raise ValueError(\"Conductivity cannot be negative\")     elif electron_conc < 0:         raise ValueError(\"Electron concentration cannot be negative\")     elif mobility < 0:         raise ValueError(\"mobility cannot be negative\")     elif conductivity == 0:         return (             \"conductivity\",             mobility * electron_conc * ELECTRON_CHARGE,         )     elif electron_conc == 0:         return (             \"electron_conc\",             conductivity / (mobility * ELECTRON_CHARGE),         )     else:         return (             \"mobility\",             conductivity / (electron_conc * ELECTRON_CHARGE),         )\n1: def minimum_squares_to_represent_a_number(number: int) -> int:     if number != int(number):         raise ValueError(\"the value of input must be a natural number\")     if number < 0:         raise ValueError(\"the value of input must not be a negative number\")     if number == 0:         return 1     answers = [-1] * (number + 1)     answers[0] = 0     for i in range(1, number + 1):         answer = sys.maxsize         root = int(math.sqrt(i))         for j in range(1, root + 1):             current_answer = 1 + answers[i - (j**2)]             answer = min(answer, current_answer)         answers[i] = answer     return answers[number]\n2: def get_child_right_position(position: int) -> int:     return (2 * position) + 2", "output": "0"}
{"task": "search", "input": "search code:\nBenchmark code comparing two different version function.\n\nChoices:\n0: def solution(n: int = 10000) -> int:     count_odd_periods = 0     for i in range(2, n + 1):         sr = sqrt(i)         if sr - floor(sr) != 0 and continuous_fraction_period(i) % 2 == 1:             count_odd_periods += 1     return count_odd_periods\n1: def main() -> None:     lower = int(input(\"Enter lower value : \").strip())     higher = int(input(\"Enter high value : \").strip())     guess = int(input(\"Enter value to guess : \").strip())     guess_the_number(lower, higher, guess)\n2: def benchmark() -> None:     import timeit      print(         timeit.timeit(\"solution()\", setup=\"from __main__ import solution\", number=1000)     )     print(         timeit.timeit(             \"solution_fast()\", setup=\"from __main__ import solution_fast\", number=1000         )     )", "output": "2"}
{"task": "search", "input": "search code:\nEncodes the given bytes into base16.\n\nChoices:\n0: def vol_spheres_union(     radius_1: float, radius_2: float, centers_distance: float ) -> float:      if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:         raise ValueError(             \"vol_spheres_union() only accepts non-negative values, non-zero radius\"         )      if centers_distance == 0:         return vol_sphere(max(radius_1, radius_2))      return (         vol_sphere(radius_1)         + vol_sphere(radius_2)         - vol_spheres_intersect(radius_1, radius_2, centers_distance)     )\n1: def guess_the_number(lower: int, higher: int, to_guess: int) -> None:     assert (         isinstance(lower, int) and isinstance(higher, int) and isinstance(to_guess, int)     ), 'argument values must be type of \"int\"'      if lower > higher:         raise ValueError(\"argument value for lower and higher must be(lower > higher)\")      if not lower < to_guess < higher:         raise ValueError(             \"guess value must be within the range of lower and higher value\"         )      def answer(number: int) -> str:         if number > to_guess:             return \"high\"         elif number < to_guess:             return \"low\"         else:             return \"same\"      print(\"started...\")      last_lowest = lower     last_highest = higher      last_numbers = []      while True:         number = get_avg(last_lowest, last_highest)         last_numbers.append(number)          if answer(number) == \"low\":             last_lowest = number         elif answer(number) == \"high\":             last_highest = number         else:             break      print(f\"guess the number : {last_numbers[-1]}\")     print(f\"details : {last_numbers!s}\")\n2: def base16_encode(data: bytes) -> str:     # Turn the data into a list of integers (where each integer is a byte),     # Then turn each byte into its hexadecimal representation, make sure     # it is uppercase, and then join everything together and return it.     return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef count_vowels(s: str) -> int:\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)", "output": "Count the number of vowels in a given string."}
{"task": "search", "input": "search code:\nReturns the dot product of the two iterables.\n\nChoices:\n0: def groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):     ret = groupby(iterable, keyfunc)     if valuefunc:         ret = ((k, map(valuefunc, g)) for k, g in ret)     if reducefunc:         ret = ((k, reducefunc(g)) for k, g in ret)      return ret\n1: def dotproduct(vec1, vec2):     return sum(map(mul, vec1, vec2))\n2: def upf_len(num: int) -> int:     return len(unique_prime_factors(num))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef sigmoid(vector: np.ndarray) -> np.ndarray:\n    return 1 / (1 + np.exp(-vector))", "output": "Implements the sigmoid function"}
{"task": "search", "input": "search code:\nUnwrap text, the natural complement to :func:`textwrap.wrap`.\n\nChoices:\n0: def graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:      if len(points) <= 2:         # There is no convex hull         raise ValueError(\"graham_scan: argument must contain more than 3 points.\")     if len(points) == 3:         return points     # find the lowest and the most left point     minidx = 0     miny, minx = maxsize, maxsize     for i, point in enumerate(points):         x = point[0]         y = point[1]         if y < miny:             miny = y             minx = x             minidx = i         if y == miny and x < minx:             minx = x             minidx = i      # remove the lowest and the most left point from points for preparing for sort     points.pop(minidx)      sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))     # This insert actually costs complexity,     # and you should instead add (minx, miny) into stack later.     # I'm using insert just for easy understanding.     sorted_points.insert(0, (minx, miny))      stack: deque[tuple[int, int]] = deque()     stack.append(sorted_points[0])     stack.append(sorted_points[1])     stack.append(sorted_points[2])     # The first 3 points lines are towards the left because we sort them by their angle     # from minx, miny.     current_direction = Direction.left      for i in range(3, len(sorted_points)):         while True:             starting = stack[-2]             via = stack[-1]             target = sorted_points[i]             next_direction = check_direction(starting, via, target)              if next_direction == Direction.left:                 current_direction = Direction.left                 break             if next_direction == Direction.straight:                 if current_direction == Direction.left:                     # We keep current_direction as left.                     # Because if the straight line keeps as straight,                     # we want to know if this straight line is towards left.                     break                 elif current_direction == Direction.right:                     # If the straight line is towards right,                     # every previous points on that straight line is not convex hull.                     stack.pop()             if next_direction == Direction.right:                 stack.pop()         stack.append(sorted_points[i])     return list(stack)\n1: def solution(n: int = 600851475143) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     i = 2     ans = 0     if n == 2:         return 2     while n > 2:         while n % i != 0:             i += 1         ans = i         while n % i == 0:             n = n // i         i += 1     return int(ans)\n2: def unwrap_text(text, ending='\\n\\n'):     all_grafs = []     cur_graf = []     for line in text.splitlines():         line = line.strip()         if line:             cur_graf.append(line)         else:             all_grafs.append(' '.join(cur_graf))             cur_graf = []     if cur_graf:         all_grafs.append(' '.join(cur_graf))     if ending is None:         return all_grafs     return ending.join(all_grafs)", "output": "2"}
{"task": "search", "input": "search code:\nreturns number of fractions containing a numerator with more digits than\n\nChoices:\n0: def solution(n: int = 1000) -> int:     prev_numerator, prev_denominator = 1, 1     result = []     for i in range(1, n + 1):         numerator = prev_numerator + 2 * prev_denominator         denominator = prev_numerator + prev_denominator         if len(str(numerator)) > len(str(denominator)):             result.append(i)         prev_numerator = numerator         prev_denominator = denominator      return len(result)\n1: def while_solution(max_number: int = 10**8) -> int:      prime_numbers = calculate_prime_numbers(max_number // 2)      semiprimes_count = 0     left = 0     right = len(prime_numbers) - 1     while left <= right:         while prime_numbers[left] * prime_numbers[right] >= max_number:             right -= 1         semiprimes_count += right - left + 1         left += 1      return semiprimes_count\n2: def create_ngram(sentence: str, ngram_size: int) -> list[str]:     return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]", "output": "0"}
{"task": "search", "input": "search code:\nQuote special characters in either the username or password\n\nChoices:\n0: def print_binary_search_tree(root, key, i, j, parent, is_left):     if i > j or i < 0 or j > len(root) - 1:         return      node = root[i][j]     if parent == -1:  # root does not have a parent         print(f\"{key[node]} is the root of the binary search tree.\")     elif is_left:         print(f\"{key[node]} is the left child of key {parent}.\")     else:         print(f\"{key[node]} is the right child of key {parent}.\")      print_binary_search_tree(root, key, i, node - 1, key[node], True)     print_binary_search_tree(root, key, node + 1, j, key[node], False)\n1: def mel_spaced_filterbank(     sample_rate: int, mel_filter_num: int = 10, ftt_size: int = 1024 ) -> np.ndarray:     freq_min = 0     freq_high = sample_rate // 2      logging.info(f\"Minimum frequency: {freq_min}\")     logging.info(f\"Maximum frequency: {freq_high}\")      # Calculate filter points and mel frequencies     filter_points, mel_freqs = get_filter_points(         sample_rate,         freq_min,         freq_high,         mel_filter_num,         ftt_size,     )      filters = get_filters(filter_points, ftt_size)      # normalize filters     # taken from the librosa library     enorm = 2.0 / (mel_freqs[2 : mel_filter_num + 2] - mel_freqs[:mel_filter_num])     return filters * enorm[:, np.newaxis]\n2: def quote_userinfo_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])     return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS                      else t for t in text])", "output": "2"}
{"task": "search", "input": "search code:\nMultiply 'a' and 'b' using bitwise multiplication.\n\nChoices:\n0: def decrypt(ciphertext: str, key: str) -> str:     if not isinstance(ciphertext, str):         raise TypeError(\"ciphertext must be a string\")     if not isinstance(key, str):         raise TypeError(\"key must be a string\")      if not ciphertext:         raise ValueError(\"ciphertext is empty\")     if not key:         raise ValueError(\"key is empty\")      key = key.lower()     ciphertext_iterator = 0     key_iterator = 0     plaintext = \"\"     while ciphertext_iterator < len(ciphertext):         if (             ord(ciphertext[ciphertext_iterator]) < 97             or ord(ciphertext[ciphertext_iterator]) > 122         ):             plaintext += ciphertext[ciphertext_iterator]         else:             plaintext += chr(                 (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26                 + 97             )             key += chr(                 (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26                 + 97             )             key_iterator += 1         ciphertext_iterator += 1     return plaintext\n1: def non_bouncy_exact(n: int) -> int:     return choose(8 + n, n) + choose(9 + n, n) - 10\n2: def binary_multiply(a: int, b: int) -> int:     res = 0     while b > 0:         if b & 1:             res += a          a += a         b >>= 1      return res", "output": "2"}
{"task": "search", "input": "search code:\nSearches for an item in a sorted collection by interpolation search algorithm.\n\nChoices:\n0: def interpolation_search(sorted_collection: list[int], item: int) -> int | None:     left = 0     right = len(sorted_collection) - 1      while left <= right:         # avoid divided by 0 during interpolation         if sorted_collection[left] == sorted_collection[right]:             if sorted_collection[left] == item:                 return left             return None          point = left + ((item - sorted_collection[left]) * (right - left)) // (             sorted_collection[right] - sorted_collection[left]         )          # out of range check         if point < 0 or point >= len(sorted_collection):             return None          current_item = sorted_collection[point]         if current_item == item:             return point         if point < left:             right = left             left = point         elif point > right:             left = right             right = point         elif item < current_item:             right = point - 1         else:             left = point + 1     return None\n1: def find_minimum_change(denominations: list[int], value: str) -> list[int]:     total_value = int(value)      # Initialize Result     answer = []      # Traverse through all denomination     for denomination in reversed(denominations):         # Find denominations         while int(total_value) >= int(denomination):             total_value -= int(denomination)             answer.append(denomination)  # Append the \"answers\" array      return answer\n2: def reshape(matrix, shape):     if isinstance(shape, int):         return batched(chain.from_iterable(matrix), shape)     first_dim, *dims = shape     scalar_stream = _flatten_tensor(matrix)     reshaped = reduce(batched, reversed(dims), scalar_stream)     return islice(reshaped, first_dim)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]", "output": "def strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]"}
{"task": "summary", "input": "summarize code:\ndef is_prime(n: int) -> bool:\n    return sieve[n]", "output": "For 2 <= n <= 1000000, return True if n is prime."}
{"task": "detection", "input": "classify code:\ndef binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef median(nums: list) -> Union[int, float]:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )", "output": "def median(nums: list) -> int | float:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )"}
{"task": "summary", "input": "summarize code:\ndef longest_common_subsequence(x: str, y: str):\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq", "output": "Finds the longest common subsequence between two strings. Also returns the"}
{"task": "search", "input": "search code:\nReturn True if n is a pluperfect number or False if it is not\n\nChoices:\n0: def pluperfect_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False      # Init a \"histogram\" of the digits     digit_histogram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]     digit_total = 0     total = 0     temp = n     while temp > 0:         temp, rem = divmod(temp, 10)         digit_histogram[rem] += 1         digit_total += 1      for cnt, i in zip(digit_histogram, range(len(digit_histogram))):         total += cnt * i**digit_total      return n == total\n1: def emitter_converter(size_par, data):     if size_par + len(data) <= 2**size_par - (len(data) - 1):         raise ValueError(\"size of parity don't match with size of data\")      data_out = []     parity = []     bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]      # sorted information data for the size of the output data     data_ord = []     # data position template + parity     data_out_gab = []     # parity bit counter     qtd_bp = 0     # counter position of data bits     cont_data = 0      for x in range(1, size_par + len(data) + 1):         # Performs a template of bit positions - who should be given,         # and who should be parity         if qtd_bp < size_par:             if (np.log(x) / np.log(2)).is_integer():                 data_out_gab.append(\"P\")                 qtd_bp = qtd_bp + 1             else:                 data_out_gab.append(\"D\")         else:             data_out_gab.append(\"D\")          # Sorts the data to the new output size         if data_out_gab[-1] == \"D\":             data_ord.append(data[cont_data])             cont_data += 1         else:             data_ord.append(None)      # Calculates parity     qtd_bp = 0  # parity bit counter     for bp in range(1, size_par + 1):         # Bit counter one for a given parity         cont_bo = 0         # counter to control the loop reading         for cont_loop, x in enumerate(data_ord):             if x is not None:                 try:                     aux = (bin_pos[cont_loop])[-1 * (bp)]                 except IndexError:                     aux = \"0\"                 if aux == \"1\" and x == \"1\":                     cont_bo += 1         parity.append(cont_bo % 2)          qtd_bp += 1      # Mount the message     cont_bp = 0  # parity bit counter     for x in range(size_par + len(data)):         if data_ord[x] is None:             data_out.append(str(parity[cont_bp]))             cont_bp += 1         else:             data_out.append(data_ord[x])      return data_out\n2: def is_palindrome(n: int | str) -> bool:     n = str(n)     return n == n[::-1]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef josephus_iterative(num_people: int, step_size: int) -> int:\n    circle = list(range(1, num_people + 1))\n    current = 0\n\n    while len(circle) > 1:\n        current = (current + step_size - 1) % len(circle)\n        circle.pop(current)\n\n    return circle[0]", "output": "Solve the Josephus problem for num_people and a step_size iteratively."}
{"task": "repair", "input": "fix bug:\ndef odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list", "output": "def odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list"}
{"task": "summary", "input": "summarize code:\ndef pdb_on_signal(signalnum=None):\n    import pdb\n    import signal\n    if not signalnum:\n        signalnum = signal.SIGINT\n\n    old_handler = signal.getsignal(signalnum)\n\n    def pdb_int_handler(sig, frame):\n        signal.signal(signalnum, old_handler)\n        pdb.set_trace()\n        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help\n\n    signal.signal(signalnum, pdb_int_handler)\n    return", "output": "Installs a signal handler for *signalnum*, which defaults to"}
{"task": "search", "input": "search code:\nSame as :func:`frange`, but generator-based instead of returning a\n\nChoices:\n0: def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:     # Mark current node as visited and add to recursion stack     visited.add(vertex)     rec_stk.add(vertex)      for node in graph[vertex]:         if node not in visited:             if depth_first_search(graph, node, visited, rec_stk):                 return True         elif node in rec_stk:             return True      # The node needs to be removed from recursion stack before function ends     rec_stk.remove(vertex)     return False\n1: def xfrange(stop, start=None, step=1.0):     if not step:         raise ValueError('step must be non-zero')     if start is None:         start, stop = 0.0, stop * 1.0     else:         # swap when all args are used         stop, start = start * 1.0, stop * 1.0     cur = start     while cur < stop:         yield cur         cur += step\n2: def solution(limit: int = 1500000) -> int:     frequencies: defaultdict = defaultdict(int)     euclid_m = 2     while 2 * euclid_m * (euclid_m + 1) <= limit:         for euclid_n in range((euclid_m % 2) + 1, euclid_m, 2):             if gcd(euclid_m, euclid_n) > 1:                 continue             primitive_perimeter = 2 * euclid_m * (euclid_m + euclid_n)             for perimeter in range(primitive_perimeter, limit + 1, primitive_perimeter):                 frequencies[perimeter] += 1         euclid_m += 1     return sum(1 for frequency in frequencies.values() if frequency == 1)", "output": "1"}
{"task": "search", "input": "search code:\nConverts an integer to Associated Press style.\n\nChoices:\n0: def get_distance(highway_now: list, car_index: int) -> int:      distance = 0     cells = highway_now[car_index + 1 :]     for cell in range(len(cells)):  # May need a better name for this         if cells[cell] != -1:  # If the cell is not empty then             return distance  # we have the distance we wanted         distance += 1     # Here if the car is near the end of the highway     return distance + get_distance(highway_now, -1)\n1: def split(root: Node | None, value: int) -> tuple[Node | None, Node | None]:     if root is None or root.value is None:  # None tree is split into 2 Nones         return None, None     elif value < root.value:         left, root.left = split(root.left, value)         return left, root     else:         root.right, right = split(root.right, value)         return root, right\n2: def apnumber(value):     try:         value = int(value)     except (TypeError, ValueError):         return value     if not 0 <= value < 10:         return str(value)     return (         _(\"zero\"),         _(\"one\"),         _(\"two\"),         _(\"three\"),         _(\"four\"),         _(\"five\"),         _(\"six\"),         _(\"seven\"),         _(\"eight\"),         _(\"nine\"),     )[value]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef print_linked_list(head: Node | None) -> None:\n    if head is None:\n        return\n    while head.next_node is not None:\n        print(head.data, end=\"->\")\n        head = head.next_node\n    print(head.data)", "output": "Print the entire linked list iteratively."}
{"task": "repair", "input": "fix bug:\ndef apply_table(inp, table):\n    \"\"\"\n    >>> apply_table(\"0123456789\", list(range(10)))\n    '9012345678'\n    >>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n    '8765432109'\n    \"\"\"\n    res = \"\"\n    for i in table:\n        res += inp[i - 1]\n    return res", "output": "def apply_table(inp, table):\n    \"\"\"\n    >>> apply_table(\"0123456789\", list(range(10)))\n    '9012345678'\n    >>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n    '8765432109'\n    \"\"\"\n    res = \"\"\n    for i in table:\n        res += inp[i - 1]\n    return res"}
{"task": "summary", "input": "summarize code:\ndef shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )", "output": "This function can calculate any one of the three -"}
{"task": "search", "input": "search code:\nYield the items from *iterable*, replacing the items for which *pred*\n\nChoices:\n0: def get_nodes(frequency_table):     nodes = {}     for _, item in enumerate(frequency_table):         nodes.setdefault(item[2], []).append(item[0])     return nodes\n1: def term_frequency(term: str, document: str) -> int:     # strip all punctuation and newlines and replace it with ''     document_without_punctuation = document.translate(         str.maketrans(\"\", \"\", string.punctuation)     ).replace(\"\\n\", \"\")     tokenize_document = document_without_punctuation.split(\" \")  # word tokenization     return len([word for word in tokenize_document if word.lower() == term.lower()])\n2: def replace(iterable, pred, substitutes, count=None, window_size=1):     if window_size < 1:         raise ValueError('window_size must be at least 1')      # Save the substitutes iterable, since it's used more than once     substitutes = tuple(substitutes)      # Add padding such that the number of windows matches the length of the     # iterable     it = chain(iterable, repeat(_marker, window_size - 1))     windows = windowed(it, window_size)      n = 0     for w in windows:         # If the current window matches our predicate (and we haven't hit         # our maximum number of replacements), splice in the substitutes         # and then consume the following windows that overlap with this one.         # For example, if the iterable is (0, 1, 2, 3, 4...)         # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...         # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)         if pred(*w):             if (count is None) or (n < count):                 n += 1                 yield from substitutes                 consume(windows, window_size - 1)                 continue          # If there was no match (or we've reached the replacement limit),         # yield the first item from the window.         if w and (w[0] is not _marker):             yield w[0]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef line_length(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n\n    x1 = x_start\n    fx1 = fnc(x_start)\n    length = 0.0\n\n    for _ in range(steps):\n        # Approximates curve as a sequence of linear lines and sums their length\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        length += math.hypot(x2 - x1, fx2 - fx1)\n\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n\n    return length", "output": "Approximates the arc length of a line segment by treating the curve as a"}
{"task": "search", "input": "search code:\nYield the items from *iterable*, but strip any from the end\n\nChoices:\n0: def rstrip(iterable, pred):     cache = []     cache_append = cache.append     cache_clear = cache.clear     for x in iterable:         if pred(x):             cache_append(x)         else:             yield from cache             cache_clear()             yield x\n1: def ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:     if (voltage, current, resistance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance < 0:         raise ValueError(\"Resistance cannot be negative\")     if voltage == 0:         return {\"voltage\": float(current * resistance)}     elif current == 0:         return {\"current\": voltage / resistance}     elif resistance == 0:         return {\"resistance\": voltage / current}     else:         raise ValueError(\"Exactly one argument must be 0\")\n2: def axpy(scalar: float, x: Vector, y: Vector) -> Vector:     # precondition     assert isinstance(x, Vector)     assert isinstance(y, Vector)     assert isinstance(scalar, (int, float))     return x * scalar + y", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef _create_spd_matrix(dimension: int) -> Any:\n    rng = np.random.default_rng()\n    random_matrix = rng.normal(size=(dimension, dimension))\n    spd_matrix = np.dot(random_matrix, random_matrix.T)\n    assert _is_matrix_spd(spd_matrix)\n    return spd_matrix", "output": "Returns a symmetric positive definite matrix given a dimension."}
{"task": "summary", "input": "summarize code:\ndef cachedmethod(cache, scoped=True, typed=False, key=None):\n    def cached_method_decorator(func):\n        return CachedMethod(func, cache, scoped=scoped, typed=typed, key=key)\n    return cached_method_decorator", "output": "Similar to :func:`cached`, ``cachedmethod`` is used to cache"}
{"task": "summary", "input": "summarize code:\ndef to_little_endian(string_32: bytes) -> bytes:\n    if len(string_32) != 32:\n        raise ValueError(\"Input must be of length 32\")\n\n    little_endian = b\"\"\n    for i in [3, 2, 1, 0]:\n        little_endian += string_32[8 * i : 8 * i + 8]\n    return little_endian", "output": "Converts the given string to little-endian in groups of 8 chars."}
{"task": "search", "input": "search code:\nBatch data into tuples of length *n*. If the number of items in\n\nChoices:\n0: def _batched(iterable, n, *, strict=False):  # pragma: no cover     if n < 1:         raise ValueError('n must be at least one')     iterator = iter(iterable)     while batch := tuple(islice(iterator, n)):         if strict and len(batch) != n:             raise ValueError('batched(): incomplete batch')         yield batch\n1: def generate_all_combinations(n: int, k: int) -> list[list[int]]:     if k < 0:         raise ValueError(\"k must not be negative\")     if n < 0:         raise ValueError(\"n must not be negative\")      result: list[list[int]] = []     create_all_state(1, n, k, [], result)     return result\n2: def int_to_base(number: int, base: int) -> str:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"     result = \"\"      if number < 0:         raise ValueError(\"number must be a positive integer\")      while number > 0:         number, remainder = divmod(number, base)         result = digits[remainder] + result      if result == \"\":         result = \"0\"      return result", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef collapse(iterable, base_type=None, levels=None):\n    stack = deque()\n    # Add our first node group, treat the iterable as a single node\n    stack.appendleft((0, repeat(iterable, 1)))\n\n    while stack:\n        node_group = stack.popleft()\n        level, nodes = node_group\n\n        # Check if beyond max level\n        if levels is not None and level > levels:\n            yield from nodes\n            continue\n\n        for node in nodes:\n            # Check if done iterating\n            if isinstance(node, (str, bytes)) or (\n                (base_type is not None) and isinstance(node, base_type)\n            ):\n                yield node\n            # Otherwise try to create child nodes\n            else:\n                try:\n                    tree = iter(node)\n                except TypeError:\n                    yield node\n                else:\n                    # Save our current location\n                    stack.appendleft(node_group)\n                    # Append the new child node\n                    stack.appendleft((level + 1, tree))\n                    # Break to process child node\n                    break", "output": "Flatten an iterable with multiple levels of nesting (e.g., a list of"}
{"task": "detection", "input": "classify code:\ndef find_min(arr):\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i][j - 1]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef get_archive_data(query: str) -> dict:\n    url = \"https://images-api.nasa.gov/search\"\n    return httpx.get(url, params={\"q\": query}, timeout=10).json()", "output": "Get the data of a particular query from NASA archives"}
{"task": "summary", "input": "summarize code:\ndef equality(iterable: list) -> bool:\n    return len(set(iterable)) in (0, 1)", "output": "Check the equality of ALL elements in an iterable"}
{"task": "summary", "input": "summarize code:\ndef combinations(n: int, k: int) -> int:\n\n    # If either of the conditions are true, the function is being asked\n    # to calculate a factorial of a negative number, which is not possible\n    if n < k or k < 0:\n        raise ValueError(\"Please enter positive integers for n and k where n >= k\")\n    res = 1\n    for i in range(k):\n        res *= n - i\n        res //= i + 1\n    return res", "output": "Returns the number of different combinations of k length which can"}
{"task": "detection", "input": "classify code:\ndef longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n\n    Args:\n        * `elements`: The list of elements from which combinations will be generated.\n        * `n`: The number of elements in each combination.\n\n    Returns:\n        A list of tuples, each representing a combination of `n` elements.\n\n    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n    >>> subset_combinations(elements=[1, 2, 3], n=1)\n    [(1,), (2,), (3,)]\n    >>> subset_combinations(elements=[1, 2, 3], n=3)\n    [(1, 2, 3)]\n    >>> subset_combinations(elements=[42], n=1)\n    [(42,)]\n    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n    [(6, 7, 8, 9)]\n    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n    [()]\n    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n    >>> subset_combinations(elements=['single'], n=0)\n    [()]\n    >>> subset_combinations(elements=[], n=9)\n    []\n    >>> from itertools import combinations\n    >>> all(subset_combinations(items, n) == list(combinations(items, n))\n    ...     for items, n in (\n    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n    True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nYield all arguments passed to the function in the same order in which\n\nChoices:\n0: def luhn_validation(credit_card_number: str) -> bool:     cc_number = credit_card_number     total = 0     half_len = len(cc_number) - 2     for i in range(half_len, -1, -2):         #  double the value of every second digit         digit = int(cc_number[i])         digit *= 2         # If doubling of a number results in a two digit number         # i.e greater than 9(e.g., 6 x 2 = 12),         # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),         # to get a single digit number.         if digit > 9:             digit %= 10             digit += 1         cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]         total += digit      # Sum up the remaining digits     for i in range(len(cc_number) - 1, -1, -2):         total += int(cc_number[i])      return total % 10 == 0\n1: def value_chain(*args):     scalar_types = (str, bytes)     for value in args:         if isinstance(value, scalar_types):             yield value             continue         try:             yield from value         except TypeError:             yield value\n2: def tail(n, iterable):     try:         size = len(iterable)     except TypeError:         return iter(deque(iterable, maxlen=n))     else:         return islice(iterable, max(0, size - n), None)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef normalization(data: list, ndigits: int = 3) -> list:\n    \"\"\"\n    Return a normalized list of values.\n\n    @params: data, a list of values to normalize\n    @returns: a list of normalized values (rounded to ndigits decimal places)\n    @examples:\n    >>> normalization([2, 7, 10, 20, 30, 50])\n    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\n    >>> normalization([5, 10, 15, 20, 25])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # variables for calculation\n    x_min = min(data)\n    x_max = max(data)\n    # normalize data\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times", "output": "BUGGY"}
{"task": "search", "input": "search code:\nSelect the second parent and generate new population\n\nChoices:\n0: def sdbm(plain_text: str) -> int:     hash_value = 0     for plain_chr in plain_text:         hash_value = (             ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value         )     return hash_value\n1: def geometric_series(     nth_term: float,     start_term_a: float,     common_ratio_r: float, ) -> list[float]:     if not all((nth_term, start_term_a, common_ratio_r)):         return []     series: list[float] = []     power = 1     multiple = common_ratio_r     for _ in range(int(nth_term)):         if not series:             series.append(start_term_a)         else:             power += 1             series.append(float(start_term_a * multiple))             multiple = pow(float(common_ratio_r), power)     return series\n2: def select(     parent_1: tuple[str, float],     population_score: list[tuple[str, float]],     genes: list[str], ) -> list[str]:     pop = []     # Generate more children proportionally to the fitness score.     child_n = int(parent_1[1] * 100) + 1     child_n = 10 if child_n >= 10 else child_n     for _ in range(child_n):         parent_2 = population_score[random.randint(0, N_SELECTED)][0]          child_1, child_2 = crossover(parent_1[0], parent_2)         # Append new string to the population list.         pop.append(mutate(child_1, genes))         pop.append(mutate(child_2, genes))     return pop", "output": "2"}
{"task": "search", "input": "search code:\nreturns the values of n less than or equal to the limit\n\nChoices:\n0: def solution(limit: int = 1000000) -> int:     limit = limit + 1     frequency = [0] * limit     for first_term in range(1, limit):         for n in range(first_term, limit, first_term):             common_difference = first_term + n / first_term             if common_difference % 4:  # d must be divisible by 4                 continue             else:                 common_difference /= 4                 if (                     first_term > common_difference                     and first_term < 4 * common_difference                 ):  # since x, y, z are positive integers                     frequency[n] += 1  # so z > 0, a > d and 4d < a      count = sum(1 for x in frequency[1:limit] if x == 10)      return count\n1: def nth(iterable, n, default=None):     return next(islice(iterable, n, None), default)\n2: def compute_transform_tables(     source_string: str,     destination_string: str,     copy_cost: int,     replace_cost: int,     delete_cost: int,     insert_cost: int, ) -> tuple[list[list[int]], list[list[str]]]:     source_seq = list(source_string)     destination_seq = list(destination_string)     len_source_seq = len(source_seq)     len_destination_seq = len(destination_seq)     costs = [         [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]     ops = [         [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]      for i in range(1, len_source_seq + 1):         costs[i][0] = i * delete_cost         ops[i][0] = f\"D{source_seq[i - 1]}\"      for i in range(1, len_destination_seq + 1):         costs[0][i] = i * insert_cost         ops[0][i] = f\"I{destination_seq[i - 1]}\"      for i in range(1, len_source_seq + 1):         for j in range(1, len_destination_seq + 1):             if source_seq[i - 1] == destination_seq[j - 1]:                 costs[i][j] = costs[i - 1][j - 1] + copy_cost                 ops[i][j] = f\"C{source_seq[i - 1]}\"             else:                 costs[i][j] = costs[i - 1][j - 1] + replace_cost                 ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])              if costs[i - 1][j] + delete_cost < costs[i][j]:                 costs[i][j] = costs[i - 1][j] + delete_cost                 ops[i][j] = f\"D{source_seq[i - 1]}\"              if costs[i][j - 1] + insert_cost < costs[i][j]:                 costs[i][j] = costs[i][j - 1] + insert_cost                 ops[i][j] = f\"I{destination_seq[j - 1]}\"      return costs, ops", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef split_iter(src, sep=None, maxsplit=None):\n    if not is_iterable(src):\n        raise TypeError('expected an iterable')\n\n    if maxsplit is not None:\n        maxsplit = int(maxsplit)\n        if maxsplit == 0:\n            yield [src]\n            return\n\n    if callable(sep):\n        sep_func = sep\n    elif not is_scalar(sep):\n        sep = frozenset(sep)\n        def sep_func(x): return x in sep\n    else:\n        def sep_func(x): return x == sep\n\n    cur_group = []\n    split_count = 0\n    for s in src:\n        if maxsplit is not None and split_count >= maxsplit:\n            def sep_func(x): return False\n        if sep_func(s):\n            if sep is None and not cur_group:\n                # If sep is none, str.split() \"groups\" separators\n                # check the str.split() docs for more info\n                continue\n            split_count += 1\n            yield cur_group\n            cur_group = []\n        else:\n            cur_group.append(s)\n\n    if cur_group or sep is not None:\n        yield cur_group\n    return", "output": "Splits an iterable based on a separator, *sep*, a max of"}
{"task": "search", "input": "search code:\nCalculate Bell numbers for the sets of lengths from 0 to max_set_length.\n\nChoices:\n0: def bell_numbers(max_set_length: int) -> list[int]:     if max_set_length < 0:         raise ValueError(\"max_set_length must be non-negative\")      bell = [0] * (max_set_length + 1)     bell[0] = 1      for i in range(1, max_set_length + 1):         for j in range(i):             bell[i] += _binomial_coefficient(i - 1, j) * bell[j]      return bell\n1: def chunked(iterable, n, strict=False):     iterator = iter(partial(take, n, iter(iterable)), [])     if strict:         if n is None:             raise ValueError('n must not be None when using strict mode.')          def ret():             for chunk in iterator:                 if len(chunk) != n:                     raise ValueError('iterable is not divisible by n.')                 yield chunk          return ret()     else:         return iterator\n2: def longest_palindromic_subsequence(input_string: str) -> int:     n = len(input_string)     rev = input_string[::-1]     m = len(rev)     dp = [[-1] * (m + 1) for i in range(n + 1)]     for i in range(n + 1):         dp[i][0] = 0     for i in range(m + 1):         dp[0][i] = 0      # create and initialise dp array     for i in range(1, n + 1):         for j in range(1, m + 1):             # If characters at i and j are the same             # include them in the palindromic subsequence             if input_string[i - 1] == rev[j - 1]:                 dp[i][j] = 1 + dp[i - 1][j - 1]             else:                 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])      return dp[n][m]", "output": "0"}
{"task": "detection", "input": "classify code:\ndef sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn a set of integers corresponding to unique prime partitions of n.\n\nChoices:\n0: def partition(number_to_partition: int) -> set[int]:     if number_to_partition < 0:         return set()     elif number_to_partition == 0:         return {1}      ret: set[int] = set()     prime: int     sub: int      for prime in primes:         if prime > number_to_partition:             continue         for sub in partition(number_to_partition - prime):             ret.add(sub * prime)      return ret\n1: def flatten_iter(iterable):     for item in iterable:         if isinstance(item, Iterable) and not isinstance(item, (str, bytes)):             yield from flatten_iter(item)         else:             yield item\n2: def is_arithmetic_series(series: list) -> bool:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     if len(series) == 1:         return True     common_diff = series[1] - series[0]     for index in range(len(series) - 1):         if series[index + 1] - series[index] != common_diff:             return False     return True", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef recur_fibo(n):\n    if n <= 1:\n        return n\n    else:\n        (recur_fibo(n - 1) + recur_fibo(n - 2))", "output": "def recur_fibo(n):\n    \"\"\"\n    >>> [recur_fibo(i) for i in range(12)]\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n    \"\"\"\n    return n if n <= 1 else recur_fibo(n-1) + recur_fibo(n-2)"}
{"task": "summary", "input": "summarize code:\ndef _subsum(\n    digit_pos_to_extract: int, denominator_addend: int, precision: int\n) -> float:\n    # only care about first digit of fractional part; don't need decimal\n    total = 0.0\n    for sum_index in range(digit_pos_to_extract + precision):\n        denominator = 8 * sum_index + denominator_addend\n        if sum_index < digit_pos_to_extract:\n            # if the exponential term is an integer and we mod it by the denominator\n            # before dividing, only the integer part of the sum will change;\n            # the fractional part will not\n            exponential_term = pow(\n                16, digit_pos_to_extract - 1 - sum_index, denominator\n            )\n        else:\n            exponential_term = pow(16, digit_pos_to_extract - 1 - sum_index)\n        total += exponential_term / denominator\n    return total", "output": "Private helper function to implement the summation"}
{"task": "summary", "input": "summarize code:\ndef solution(numerator: int = 1, digit: int = 1000) -> int:\n    the_digit = 1\n    longest_list_length = 0\n\n    for divide_by_number in range(numerator, digit + 1):\n        has_been_divided: list[int] = []\n        now_divide = numerator\n        for _ in range(1, digit + 1):\n            if now_divide in has_been_divided:\n                if longest_list_length < len(has_been_divided):\n                    longest_list_length = len(has_been_divided)\n                    the_digit = divide_by_number\n            else:\n                has_been_divided.append(now_divide)\n                now_divide = now_divide * 10 % divide_by_number\n\n    return the_digit", "output": "Considering any range can be provided,"}
{"task": "summary", "input": "summarize code:\ndef tarjan(g: list[list[int]]) -> list[list[int]]:\n\n    n = len(g)\n    stack: deque[int] = deque()\n    on_stack = [False for _ in range(n)]\n    index_of = [-1 for _ in range(n)]\n    lowlink_of = index_of[:]\n\n    def strong_connect(v: int, index: int, components: list[list[int]]) -> int:\n        index_of[v] = index  # the number when this node is seen\n        lowlink_of[v] = index  # lowest rank node reachable from here\n        index += 1\n        stack.append(v)\n        on_stack[v] = True\n\n        for w in g[v]:\n            if index_of[w] == -1:\n                index = strong_connect(w, index, components)\n                lowlink_of[v] = (\n                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]\n                )\n            elif on_stack[w]:\n                lowlink_of[v] = (\n                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]\n                )\n\n        if lowlink_of[v] == index_of[v]:\n            component = []\n            w = stack.pop()\n            on_stack[w] = False\n            component.append(w)\n            while w != v:\n                w = stack.pop()\n                on_stack[w] = False\n                component.append(w)\n            components.append(component)\n        return index\n\n    components: list[list[int]] = []\n    for v in range(n):\n        if index_of[v] == -1:\n            strong_connect(v, 0, components)\n\n    return components", "output": "Tarjan's algo for finding strongly connected components in a directed graph"}
{"task": "search", "input": "search code:\nEvaluate a polynomial at a specific value.\n\nChoices:\n0: def polynomial_eval(coefficients, x):     n = len(coefficients)     if n == 0:         return type(x)(0)     powers = map(pow, repeat(x), reversed(range(n)))     return _sumprod(coefficients, powers)\n1: def largest_divisible_subset(items: list[int]) -> list[int]:     # Sort the array in ascending order as the sequence does not matter we only have to     # pick up a subset.     items = sorted(items)      number_of_items = len(items)      # Initialize memo with 1s and hash with increasing numbers     memo = [1] * number_of_items     hash_array = list(range(number_of_items))      # Iterate through the array     for i, item in enumerate(items):         for prev_index in range(i):             if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (                 (1 + memo[prev_index]) > memo[i]             ):                 memo[i] = 1 + memo[prev_index]                 hash_array[i] = prev_index      ans = -1     last_index = -1      # Find the maximum length and its corresponding index     for i, memo_item in enumerate(memo):         if memo_item > ans:             ans = memo_item             last_index = i      # Reconstruct the divisible subset     if last_index == -1:         return []     result = [items[last_index]]     while hash_array[last_index] != last_index:         last_index = hash_array[last_index]         result.append(items[last_index])      return result\n2: def transform(     image: np.ndarray, kind: str, kernel: np.ndarray | None = None ) -> np.ndarray:     if kernel is None:         kernel = np.ones((3, 3))      if kind == \"erosion\":         constant = 1         apply = np.max     else:         constant = 0         apply = np.min      center_x, center_y = (x // 2 for x in kernel.shape)      # Use padded image when applying convolution     # to not go out of bounds of the original the image     transformed = np.zeros(image.shape, dtype=np.uint8)     padded = np.pad(image, 1, \"constant\", constant_values=constant)      for x in range(center_x, padded.shape[0] - center_x):         for y in range(center_y, padded.shape[1] - center_y):             center = padded[                 x - center_x : x + center_x + 1, y - center_y : y + center_y + 1             ]             # Apply transformation method to the centered section of the image             transformed[x - center_x, y - center_y] = apply(center[kernel == 1])      return transformed", "output": "0"}
{"task": "search", "input": "search code:\nThis function returns the index from which to start the journey\n\nChoices:\n0: def can_complete_journey(gas_stations: tuple[GasStation, ...]) -> int:     total_gas = sum(gas_station.gas_quantity for gas_station in gas_stations)     total_cost = sum(gas_station.cost for gas_station in gas_stations)     if total_gas < total_cost:         return -1      start = 0     net = 0     for i, gas_station in enumerate(gas_stations):         net += gas_station.gas_quantity - gas_station.cost         if net < 0:             start = i + 1             net = 0     return start\n1: def consumer(func):      @wraps(func)     def wrapper(*args, **kwargs):         gen = func(*args, **kwargs)         next(gen)         return gen      return wrapper\n2: def solution(min_block_length: int = 50) -> int:      fill_count_functions = [1] * min_block_length      for n in count(min_block_length):         fill_count_functions.append(1)          for block_length in range(min_block_length, n + 1):             for block_start in range(n - block_length):                 fill_count_functions[n] += fill_count_functions[                     n - block_start - block_length - 1                 ]              fill_count_functions[n] += 1          if fill_count_functions[n] > 1_000_000:             break      return n", "output": "0"}
{"task": "detection", "input": "classify code:\ndef odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef pig_latin(word: str) -> str:\n    \"\"\"Compute the piglatin of a given string.\n\n    https://en.wikipedia.org/wiki/Pig_Latin\n\n    Usage examples:\n    >>> pig_latin(\"pig\")\n    'igpay'\n    >>> pig_latin(\"latin\")\n    'atinlay'\n    >>> pig_latin(\"banana\")\n    'ananabay'\n    >>> pig_latin(\"friends\")\n    'iendsfray'\n    >>> pig_latin(\"smile\")\n    'ilesmay'\n    >>> pig_latin(\"string\")\n    'ingstray'\n    >>> pig_latin(\"eat\")\n    'eatway'\n    >>> pig_latin(\"omelet\")\n    'omeletway'\n    >>> pig_latin(\"are\")\n    'areway'\n    >>> pig_latin(\" \")\n    ''\n    >>> pig_latin(None)\n    ''\n    \"\"\"\n    if not (word or \"\").strip():\n        return \"\"\n    word = word.lower()\n    if word[0] in \"aeiou\":\n        return f\"{word}way\"\n    for i, char in enumerate(word):  # noqa: B007\n        if char in \"aeiou\":\n            break\n    return f\"{word[i:]}{word[:i]}ay\"", "output": "def pig_latin(word: str) -> str:\n    \"\"\"Compute the piglatin of a given string.\n\n    https://en.wikipedia.org/wiki/Pig_Latin\n\n    Usage examples:\n    >>> pig_latin(\"pig\")\n    'igpay'\n    >>> pig_latin(\"latin\")\n    'atinlay'\n    >>> pig_latin(\"banana\")\n    'ananabay'\n    >>> pig_latin(\"friends\")\n    'iendsfray'\n    >>> pig_latin(\"smile\")\n    'ilesmay'\n    >>> pig_latin(\"string\")\n    'ingstray'\n    >>> pig_latin(\"eat\")\n    'eatway'\n    >>> pig_latin(\"omelet\")\n    'omeletway'\n    >>> pig_latin(\"are\")\n    'areway'\n    >>> pig_latin(\" \")\n    ''\n    >>> pig_latin(None)\n    ''\n    \"\"\"\n    if not (word or \"\").strip():\n        return \"\"\n    word = word.lower()\n    if word[0] in \"aeiou\":\n        return f\"{word}way\"\n    for i, char in enumerate(word):  # noqa: B007\n        if char in \"aeiou\":\n            break\n    return f\"{word[i:]}{word[:i]}ay\""}
{"task": "summary", "input": "summarize code:\ndef is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:\n    for i in range(9):\n        if n in {grid[row][i], grid[i][column]}:\n            return False\n\n    for i in range(3):\n        for j in range(3):\n            if grid[(row - row % 3) + i][(column - column % 3) + j] == n:\n                return False\n\n    return True", "output": "This function checks the grid to see if each row,"}
{"task": "detection", "input": "classify code:\ndef vol_cube(side_length: Union[int, float]) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nnormalize args and return NotImplemented (for overloaded operators)\n\nChoices:\n0: def bytes2human(nbytes, ndigits=0):     abs_bytes = abs(nbytes)     for (size, symbol), (next_size, next_symbol) in _SIZE_RANGES:         if abs_bytes <= next_size:             break     hnbytes = float(nbytes) / size     return '{hnbytes:.{ndigits}f}{symbol}'.format(hnbytes=hnbytes,                                                   ndigits=ndigits,                                                   symbol=symbol)\n1: def _norm_args_notimplemented(other):     if type(other) in (set, frozenset):         inc, exc = other, None     elif type(other) is _ComplementSet:         inc, exc = other._included, other._excluded     else:         return NotImplemented, None     return inc, exc\n2: def split_after(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         buf.append(item)         if pred(item) and buf:             yield buf             if maxsplit == 1:                 buf = list(it)                 if buf:                     yield buf                 return             buf = []             maxsplit -= 1     if buf:         yield buf", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef noop(*args, **kwargs):\n    return None", "output": "Simple function that should be used when no effect is desired."}
{"task": "summary", "input": "summarize code:\ndef swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:\n    return vector * sigmoid(trainable_parameter * vector)", "output": "Parameters:"}
{"task": "detection", "input": "classify code:\ndef find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]", "output": "CORRECT"}
{"task": "search", "input": "search code:\n[summary]\n\nChoices:\n0: def search_scraper(anime_name: str) -> list:      # concat the name to form the search url.     search_url = f\"{BASE_URL}/search?keyword={anime_name}\"      response = httpx.get(         search_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10     )  # request the url.      # Is the response ok?     response.raise_for_status()      # parse with soup.     soup = BeautifulSoup(response.text, \"html.parser\")      # get list of anime     anime_ul = soup.find(\"ul\", {\"class\": \"items\"})     if anime_ul is None or isinstance(anime_ul, NavigableString):         msg = f\"Could not find and anime with name {anime_name}\"         raise ValueError(msg)     anime_li = anime_ul.children      # for each anime, insert to list. the name and url.     anime_list = []     for anime in anime_li:         if isinstance(anime, Tag):             anime_url = anime.find(\"a\")             if anime_url is None or isinstance(anime_url, NavigableString):                 continue             anime_title = anime.find(\"a\")             if anime_title is None or isinstance(anime_title, NavigableString):                 continue              anime_list.append({\"title\": anime_title[\"title\"], \"url\": anime_url[\"href\"]})      return anime_list\n1: def format_invocation(name='', args=(), kwargs=None, **kw):     _repr = kw.pop('repr', repr)     if kw:         raise TypeError('unexpected keyword args: %r' % ', '.join(kw.keys()))     kwargs = kwargs or {}     a_text = ', '.join([_repr(a) for a in args])     if isinstance(kwargs, dict):         kwarg_items = [(k, kwargs[k]) for k in sorted(kwargs)]     else:         kwarg_items = kwargs     kw_text = ', '.join([f'{k}={_repr(v)}' for k, v in kwarg_items])      all_args_text = a_text     if all_args_text and kw_text:         all_args_text += ', '     all_args_text += kw_text      return f'{name}({all_args_text})'\n2: def quote_query_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])     return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t                      for t in text])", "output": "0"}
{"task": "search", "input": "search code:\nCalculates sum of smallest number of multiplactions for each number up to\n\nChoices:\n0: def binary_exp_recursive(base: float, exponent: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")      if exponent == 0:         return 1      if exponent % 2 == 1:         return binary_exp_recursive(base, exponent - 1) * base      b = binary_exp_recursive(base, exponent // 2)     return b * b\n1: def solution(n: int = 200) -> int:     total = 0     for i in range(2, n + 1):         max_length = 0         while True:             nums = [1]             max_length += 1             if solve(nums=nums, goal=i, depth=max_length):                 break         total += max_length     return total\n2: def accuracy(actual_y: list, predicted_y: list) -> float:     # iterate over one element of each list at a time (zip mode)     # prediction is correct if actual Y value equals to predicted Y value     correct = sum(1 for i, j in zip(actual_y, predicted_y) if i == j)     # percentage of accuracy equals to number of correct predictions divided by number     # of all data and multiplied by 100     return (correct / len(actual_y)) * 100", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef fibonacci_generator() -> Generator[int]:\n    a, b = 0, 1\n    while True:\n        a, b = b, a + b\n        yield b", "output": "A generator that produces numbers in the Fibonacci sequence"}
{"task": "search", "input": "search code:\nTake in 2 integers, convert them to binary,\n\nChoices:\n0: def roundrobin(*iterables):     # Algorithm credited to George Sakkis     iterators = map(iter, iterables)     for num_active in range(len(iterables), 0, -1):         iterators = cycle(islice(iterators, num_active))         yield from map(next, iterators)\n1: def is_safe(row: int, col: int, rows: int, cols: int) -> bool:     return 0 <= row < rows and 0 <= col < cols\n2: def binary_xor(a: int, b: int) -> str:     if a < 0 or b < 0:         raise ValueError(\"the value of both inputs must be positive\")      a_binary = str(bin(a))[2:]  # remove the leading \"0b\"     b_binary = str(bin(b))[2:]  # remove the leading \"0b\"      max_len = max(len(a_binary), len(b_binary))      return \"0b\" + \"\".join(         str(int(char_a != char_b))         for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))     )", "output": "2"}
{"task": "search", "input": "search code:\nRandomly generate a formula.\n\nChoices:\n0: def generate_formula() -> Formula:     clauses: set[Clause] = set()     no_of_clauses = random.randint(1, 10)     while len(clauses) < no_of_clauses:         clauses.add(generate_clause())     return Formula(clauses)\n1: def max_sum_in_array(array: list[int], k: int) -> int:     if len(array) < k or k < 0:         raise ValueError(\"Invalid Input\")     max_sum = current_sum = sum(array[:k])     for i in range(len(array) - k):         current_sum = current_sum - array[i] + array[i + k]         max_sum = max(max_sum, current_sum)     return max_sum\n2: def consecutive_groups(iterable, ordering=None):     if ordering is None:         key = lambda x: x[0] - x[1]     else:         key = lambda x: x[0] - ordering(x[1])      for k, g in groupby(enumerate(iterable), key=key):         yield map(itemgetter(1), g)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef find_negative_index(array: list[int]) -> int:\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)", "output": "Find the smallest negative index"}
{"task": "summary", "input": "summarize code:\ndef harshad_numbers_in_base(limit: int, base: int) -> list[str]:\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    if limit < 0:\n        return []\n\n    numbers = [\n        int_to_base(i, base)\n        for i in range(1, limit)\n        if i % int(sum_of_digits(i, base), base) == 0\n    ]\n\n    return numbers", "output": "Finds all Harshad numbers smaller than num in base 'base'."}
{"task": "summary", "input": "summarize code:\ndef nth_permutation(iterable, r, index):\n    pool = list(iterable)\n    n = len(pool)\n\n    if r is None or r == n:\n        r, c = n, factorial(n)\n    elif not 0 <= r < n:\n        raise ValueError\n    else:\n        c = perm(n, r)\n    assert c > 0  # factorial(n)>0, and r<n so perm(n,r) is never zero\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = [0] * r\n    q = index * factorial(n) // c if r < n else index\n    for d in range(1, n + 1):\n        q, i = divmod(q, d)\n        if 0 <= n - d < r:\n            result[n - d] = i\n        if q == 0:\n            break\n\n    return tuple(map(pool.pop, result))", "output": "Equivalent to ``list(permutations(iterable, r))[index]```"}
{"task": "search", "input": "search code:\nReturn binary image from gray image\n\nChoices:\n0: def gray_to_binary(gray: np.ndarray) -> np.ndarray:     return (gray > 127) & (gray <= 255)\n1: def netstring_server(server_socket):     \"A basic netstring server loop, supporting a few operations\"     try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock)             while 1:                 request = client.read_ns()                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'reply4k':                     client.write_ns(b'a' * 4096)                 elif request == b'ping':                     client.write_ns(b'pong')                 elif request == b'reply128k':                     client.setmaxsize(128 * 1024)                     client.write_ns(b'huge' * 32 * 1024)  # 128kb                     client.setmaxsize(32768)  # back to default     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise\n2: def solution(limit: int = 999_966_663_333) -> int:     primes_upper_bound = math.floor(math.sqrt(limit)) + 100     primes = prime_sieve(primes_upper_bound)      matches_sum = 0     prime_index = 0     last_prime = primes[prime_index]      while (last_prime**2) <= limit:         next_prime = primes[prime_index + 1]          lower_bound = last_prime**2         upper_bound = next_prime**2          # Get numbers divisible by lps(current)         current = lower_bound + last_prime         while upper_bound > current <= limit:             matches_sum += current             current += last_prime          # Reset the upper_bound         while (upper_bound - next_prime) > limit:             upper_bound -= next_prime          # Add the numbers divisible by ups(current)         current = upper_bound - next_prime         while current > lower_bound:             matches_sum += current             current -= next_prime          # Remove the numbers divisible by both ups and lps         current = 0         while upper_bound > current <= limit:             if current <= lower_bound:                 # Increment the current number                 current += last_prime * next_prime                 continue              if current > limit:                 break              # Remove twice since it was added by both ups and lps             matches_sum -= current * 2              # Increment the current number             current += last_prime * next_prime          # Setup for next pair         last_prime = next_prime         prime_index += 1      return matches_sum", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef decimal_isolate(number: float, digit_amount: int) -> float:\n    \"\"\"\n    Isolates the decimal part of a number.\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\n    >>> decimal_isolate(1.53, 0)\n    0.53\n    >>> decimal_isolate(35.345, 1)\n    0.3\n    >>> decimal_isolate(35.345, 2)\n    0.34\n    >>> decimal_isolate(35.345, 3)\n    0.345\n    >>> decimal_isolate(-14.789, 3)\n    -0.789\n    >>> decimal_isolate(0, 2)\n    0\n    >>> decimal_isolate(-14.123, 1)\n    -0.1\n    >>> decimal_isolate(-14.123, 2)\n    -0.12\n    >>> decimal_isolate(-14.123, 3)\n    -0.123\n    \"\"\"\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)", "output": "def decimal_isolate(number: float, digit_amount: int) -> float:\n    \"\"\"\n    Isolates the decimal part of a number.\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\n    >>> decimal_isolate(1.53, 0)\n    0.53\n    >>> decimal_isolate(35.345, 1)\n    0.3\n    >>> decimal_isolate(35.345, 2)\n    0.34\n    >>> decimal_isolate(35.345, 3)\n    0.345\n    >>> decimal_isolate(-14.789, 3)\n    -0.789\n    >>> decimal_isolate(0, 2)\n    0\n    >>> decimal_isolate(-14.123, 1)\n    -0.1\n    >>> decimal_isolate(-14.123, 2)\n    -0.12\n    >>> decimal_isolate(-14.123, 3)\n    -0.123\n    \"\"\"\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)"}
{"task": "search", "input": "search code:\nFunction for finding the triplets with a given sum in the array using hashing.\n\nChoices:\n0: def find_triplets_with_0_sum_hashing(arr: list[int]) -> list[list[int]]:     target_sum = 0      # Initialize the final output array with blank.     output_arr = []      # Set the initial element as arr[i].     for index, item in enumerate(arr[:-2]):         # to store second elements that can complement the final sum.         set_initialize = set()          # current sum needed for reaching the target sum         current_sum = target_sum - item          # Traverse the subarray arr[i+1:].         for other_item in arr[index + 1 :]:             # required value for the second element             required_value = current_sum - other_item              # Verify if the desired value exists in the set.             if required_value in set_initialize:                 # finding triplet elements combination.                 combination_array = sorted([item, other_item, required_value])                 if combination_array not in output_arr:                     output_arr.append(combination_array)              # Include the current element in the set             # for subsequent complement verification.             set_initialize.add(other_item)      # Return all the triplet combinations.     return output_arr\n1: def mae(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = abs(predict - actual)     score = difference.mean()      return score\n2: def valid_input(     input_type: Callable[[object], num],  # Usually float or int     input_msg: str,     err_msg: str,     condition: Callable[[num], bool] = lambda _: True,     default: str | None = None, ) -> num:     while True:         try:             user_input = input_type(input(input_msg).strip() or default)             if condition(user_input):                 return user_input             else:                 print(f\"{user_input}: {err_msg}\")                 continue         except ValueError:             print(                 f\"{user_input}: Incorrect input type, expected {input_type.__name__!r}\"             )", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef get_nodes_from_left_to_right(root: Node | None, level: int) -> Generator[int]:\n\n    def populate_output(root: Node | None, level: int) -> Generator[int]:\n        if not root:\n            return\n        if level == 1:\n            yield root.data\n        elif level > 1:\n            yield from populate_output(root.left, level - 1)\n            yield from populate_output(root.right, level - 1)\n\n    yield from populate_output(root, level)", "output": "Returns a list of nodes value from a particular level:"}
{"task": "summary", "input": "summarize code:\ndef contains_an_even_digit(n: int) -> bool:\n    return any(digit in \"02468\" for digit in str(n))", "output": "Return True if n contains an even digit."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 2000000) -> int:\n\n    return sum(takewhile(lambda x: x < n, prime_generator()))", "output": "Returns the sum of all the primes below n."}
{"task": "search", "input": "search code:\nConverts a string to capitalized case, preserving the input as is\n\nChoices:\n0: def softmax(vector):      # Calculate e^x for each x in your vector where e is Euler's     # number (approximately 2.718)     exponent_vector = np.exp(vector)      # Add up the all the exponentials     sum_of_exponents = np.sum(exponent_vector)      # Divide every exponent by the sum of all exponents     softmax_vector = exponent_vector / sum_of_exponents      return softmax_vector\n1: def to_title_case(word: str) -> str:      if \"a\" <= word[0] <= \"z\":         word = chr(ord(word[0]) - 32) + word[1:]      for i in range(1, len(word)):         if \"A\" <= word[i] <= \"Z\":             word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]      return word\n2: def in_reverse(linked_list: LinkedList) -> str:     return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))", "output": "1"}
{"task": "search", "input": "search code:\nIt recursively sorts a bitonic sequence in ascending order, if direction = 1, and in\n\nChoices:\n0: def solution() -> int:      a = 1     b = 1     c = 2     # temporary Fibonacci numbers      a1 = 1     b1 = 1     c1 = 2     # temporary Fibonacci numbers mod 1e9      # mod m=1e9, done for fast optimisation     tocheck = [0] * 1000000     m = 1000000000      for x in range(1000000):         c1 = (a1 + b1) % m         a1 = b1 % m         b1 = c1 % m         if check1(b1):             tocheck[x + 3] = 1      for x in range(1000000):         c = a + b         a = b         b = c         # perform check only if in tocheck         if tocheck[x + 3] and check(b):             return x + 3  # first 2 already done     return -1\n1: def bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:     if length > 1:         middle = int(length / 2)         for i in range(low, low + middle):             comp_and_swap(array, i, i + middle, direction)         bitonic_merge(array, low, middle, direction)         bitonic_merge(array, low + middle, middle, direction)\n2: def inspect_formatargspec(         args, varargs=None, varkw=None, defaults=None,         kwonlyargs=(), kwonlydefaults={}, annotations={},         formatarg=str,         formatvarargs=lambda name: '*' + name,         formatvarkw=lambda name: '**' + name,         formatvalue=lambda value: '=' + repr(value),         formatreturns=lambda text: ' -> ' + text,         formatannotation=formatannotation):      def formatargandannotation(arg):         result = formatarg(arg)         if arg in annotations:             result += ': ' + formatannotation(annotations[arg])         return result     specs = []     if defaults:         firstdefault = len(args) - len(defaults)     for i, arg in enumerate(args):         spec = formatargandannotation(arg)         if defaults and i >= firstdefault:             spec = spec + formatvalue(defaults[i - firstdefault])         specs.append(spec)     if varargs is not None:         specs.append(formatvarargs(formatargandannotation(varargs)))     else:         if kwonlyargs:             specs.append('*')     if kwonlyargs:         for kwonlyarg in kwonlyargs:             spec = formatargandannotation(kwonlyarg)             if kwonlydefaults and kwonlyarg in kwonlydefaults:                 spec += formatvalue(kwonlydefaults[kwonlyarg])             specs.append(spec)     if varkw is not None:         specs.append(formatvarkw(formatargandannotation(varkw)))     result = '(' + ', '.join(specs) + ')'     if 'return' in annotations:         result += formatreturns(formatannotation(annotations['return']))     return result", "output": "1"}
{"task": "search", "input": "search code:\nCalculate the median of a sorted matrix.\n\nChoices:\n0: def mbd(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     numerator = np.sum(difference) / len(predict)     denumerator = np.sum(actual) / len(predict)     # print(numerator, denumerator)     score = float(numerator) / denumerator * 100      return score\n1: def median(matrix: list[list[int]]) -> int:     # Flatten the matrix into a sorted 1D list     linear = sorted(num for row in matrix for num in row)      # Calculate the middle index     mid = (len(linear) - 1) // 2      # Return the median     return linear[mid]\n2: def new_generation(cells: list[list[int]]) -> list[list[int]]:     next_generation = []     for i in range(len(cells)):         next_generation_row = []         for j in range(len(cells[i])):             # Get the number of live neighbours             neighbour_count = 0             if i > 0 and j > 0:                 neighbour_count += cells[i - 1][j - 1]             if i > 0:                 neighbour_count += cells[i - 1][j]             if i > 0 and j < len(cells[i]) - 1:                 neighbour_count += cells[i - 1][j + 1]             if j > 0:                 neighbour_count += cells[i][j - 1]             if j < len(cells[i]) - 1:                 neighbour_count += cells[i][j + 1]             if i < len(cells) - 1 and j > 0:                 neighbour_count += cells[i + 1][j - 1]             if i < len(cells) - 1:                 neighbour_count += cells[i + 1][j]             if i < len(cells) - 1 and j < len(cells[i]) - 1:                 neighbour_count += cells[i + 1][j + 1]              # Rules of the game of life (excerpt from Wikipedia):             # 1. Any live cell with two or three live neighbours survives.             # 2. Any dead cell with three live neighbours becomes a live cell.             # 3. All other live cells die in the next generation.             #    Similarly, all other dead cells stay dead.             alive = cells[i][j] == 1             if (alive and 2 <= neighbour_count <= 3) or (                 not alive and neighbour_count == 3             ):                 next_generation_row.append(1)             else:                 next_generation_row.append(0)          next_generation.append(next_generation_row)     return next_generation", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(max_perimeter: int = 10**9) -> int:\n\n    prev_value = 1\n    value = 2\n\n    perimeters_sum = 0\n    i = 0\n    perimeter = 0\n    while perimeter <= max_perimeter:\n        perimeters_sum += perimeter\n\n        prev_value += 2 * value\n        value += prev_value\n\n        perimeter = 2 * value + 2 if i % 2 == 0 else 2 * value - 2\n        i += 1\n\n    return perimeters_sum", "output": "Returns the sum of the perimeters of all almost equilateral triangles with integral"}
{"task": "summary", "input": "summarize code:\ndef reactive_power(apparent_power: float, power_factor: float) -> float:\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * math.sqrt(1 - power_factor**2)", "output": "Calculate reactive power from apparent power and power factor."}
{"task": "summary", "input": "summarize code:\ndef solution(pence: int = 200) -> int:\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    number_of_ways = [0] * (pence + 1)\n    number_of_ways[0] = 1  # base case: 1 way to make 0 pence\n\n    for coin in coins:\n        for i in range(coin, pence + 1, 1):\n            number_of_ways[i] += number_of_ways[i - coin]\n    return number_of_ways[pence]", "output": "Returns the number of different ways to make X pence using any number of coins."}
{"task": "search", "input": "search code:\nCompute the Discrete Cosine Transform (DCT) basis matrix.\n\nChoices:\n0: def discrete_cosine_transform(dct_filter_num: int, filter_num: int) -> np.ndarray:     basis = np.empty((dct_filter_num, filter_num))     basis[0, :] = 1.0 / np.sqrt(filter_num)      samples = np.arange(1, 2 * filter_num, 2) * np.pi / (2.0 * filter_num)      for i in range(1, dct_filter_num):         basis[i, :] = np.cos(i * samples) * np.sqrt(2.0 / filter_num)      return basis\n1: def solution():     i = 1      while True:         if (             sorted(str(i))             == sorted(str(2 * i))             == sorted(str(3 * i))             == sorted(str(4 * i))             == sorted(str(5 * i))             == sorted(str(6 * i))         ):             return i          i += 1\n2: def combinations(n: int, k: int) -> int:      # If either of the conditions are true, the function is being asked     # to calculate a factorial of a negative number, which is not possible     if n < k or k < 0:         raise ValueError(\"Please enter positive integers for n and k where n >= k\")     res = 1     for i in range(k):         res *= n - i         res //= i + 1     return res", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef area_rhombus(diagonal_1: float, diagonal_2: float) -> float:\n    if diagonal_1 < 0 or diagonal_2 < 0:\n        raise ValueError(\"area_rhombus() only accepts non-negative values\")\n    return 1 / 2 * diagonal_1 * diagonal_2", "output": "Calculate the area of a rhombus."}
{"task": "summary", "input": "summarize code:\ndef play(\n    matrix_g: list[list[str]], pos_x: int, pos_y: int, size: int\n) -> tuple[list[list[str]], int]:\n\n    same_colors = find_repeat(matrix_g, pos_x, pos_y, size)\n\n    if len(same_colors) != 0:\n        for pos in same_colors:\n            matrix_g[pos[0]][pos[1]] = \"-\"\n        for column in range(size):\n            matrix_g = move_x(matrix_g, column, size)\n\n        matrix_g = move_y(matrix_g, size)\n\n    return (matrix_g, increment_score(len(same_colors)))", "output": "Processes a single move, updating the matrix and calculating the score."}
{"task": "summary", "input": "summarize code:\ndef find_unit_clauses(\n    clauses: list[Clause],\n    model: dict[str, bool | None],  # noqa: ARG001\n) -> tuple[list[str], dict[str, bool | None]]:\n    unit_symbols = []\n    for clause in clauses:\n        if len(clause) == 1:\n            unit_symbols.append(next(iter(clause.literals.keys())))\n        else:\n            f_count, n_count = 0, 0\n            for literal, value in clause.literals.items():\n                if value is False:\n                    f_count += 1\n                elif value is None:\n                    sym = literal\n                    n_count += 1\n            if f_count == len(clause) - 1 and n_count == 1:\n                unit_symbols.append(sym)\n    assignment: dict[str, bool | None] = {}\n    for i in unit_symbols:\n        symbol = i[:2]\n        assignment[symbol] = len(i) == 2\n    unit_symbols = [i[:2] for i in unit_symbols]\n\n    return unit_symbols, assignment", "output": "Returns the unit symbols and their values to satisfy clause."}
{"task": "detection", "input": "classify code:\ndef num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n    \"\"\"\n    Simulates gravity in a specific column.\n\n    >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2)\n    [['-', '-'], ['-', 'A'], ['-', 'C']]\n    \"\"\"\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef match_pattern(input_string: str, pattern: str) -> bool:\n    \"\"\"\n    uses bottom-up dynamic programming solution for matching the input\n    string with a given pattern.\n\n    Runtime: O(len(input_string)*len(pattern))\n\n    Arguments\n    --------\n    input_string: str, any string which should be compared with the pattern\n    pattern: str, the string that represents a pattern and may contain\n    '.' for single character matches and '*' for zero or more of preceding character\n    matches\n\n    Note\n    ----\n    the pattern cannot start with a '*',\n    because there should be at least one character before *\n\n    Returns\n    -------\n    A Boolean denoting whether the given string follows the pattern\n\n    Examples\n    -------\n    >>> match_pattern(\"aab\", \"c*a*b\")\n    True\n    >>> match_pattern(\"dabc\", \"*abc\")\n    False\n    >>> match_pattern(\"aaa\", \"aa\")\n    False\n    >>> match_pattern(\"aaa\", \"a.a\")\n    True\n    >>> match_pattern(\"aaab\", \"aa*\")\n    False\n    >>> match_pattern(\"aaab\", \".*\")\n    True\n    >>> match_pattern(\"a\", \"bbbb\")\n    False\n    >>> match_pattern(\"\", \"bbbb\")\n    False\n    >>> match_pattern(\"a\", \"\")\n    False\n    >>> match_pattern(\"\", \"\")\n    True\n    \"\"\"\n\n    len_string = len(input_string) + 1\n    len_pattern = len(pattern) + 1\n\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\n    # length i of input_string matches with prefix string of length j of\n    # given pattern.\n    # \"dp\" stands for dynamic programming.\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\n\n    # since string of zero length match pattern of zero length\n    dp[0][0] = 1\n\n    # since pattern of zero length will never match with string of non-zero length\n    for i in range(1, len_string):\n        dp[i][0] = 0\n\n    # since string of zero length will match with pattern where there\n    # is at least one * alternatively\n    for j in range(1, len_pattern):\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \"*\" else 0\n\n    # now using bottom-up approach to find for all remaining lengths\n    for i in range(1, len_string):\n        for j in range(1, len_pattern):\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \".\":\n                dp[i][j] = dp[i - 1][j - 1]\n\n            elif pattern[j - 1] == \"*\":\n                if dp[i][j - 2] == 1:\n                    dp[i][j] = 1\n                elif pattern[j - 2] in (input_string[i - 1], \".\"):\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n\n    return bool(dp[-1][-1])", "output": "def match_pattern(input_string: str, pattern: str) -> bool:\n    \"\"\"\n    uses bottom-up dynamic programming solution for matching the input\n    string with a given pattern.\n\n    Runtime: O(len(input_string)*len(pattern))\n\n    Arguments\n    --------\n    input_string: str, any string which should be compared with the pattern\n    pattern: str, the string that represents a pattern and may contain\n    '.' for single character matches and '*' for zero or more of preceding character\n    matches\n\n    Note\n    ----\n    the pattern cannot start with a '*',\n    because there should be at least one character before *\n\n    Returns\n    -------\n    A Boolean denoting whether the given string follows the pattern\n\n    Examples\n    -------\n    >>> match_pattern(\"aab\", \"c*a*b\")\n    True\n    >>> match_pattern(\"dabc\", \"*abc\")\n    False\n    >>> match_pattern(\"aaa\", \"aa\")\n    False\n    >>> match_pattern(\"aaa\", \"a.a\")\n    True\n    >>> match_pattern(\"aaab\", \"aa*\")\n    False\n    >>> match_pattern(\"aaab\", \".*\")\n    True\n    >>> match_pattern(\"a\", \"bbbb\")\n    False\n    >>> match_pattern(\"\", \"bbbb\")\n    False\n    >>> match_pattern(\"a\", \"\")\n    False\n    >>> match_pattern(\"\", \"\")\n    True\n    \"\"\"\n\n    len_string = len(input_string) + 1\n    len_pattern = len(pattern) + 1\n\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\n    # length i of input_string matches with prefix string of length j of\n    # given pattern.\n    # \"dp\" stands for dynamic programming.\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\n\n    # since string of zero length match pattern of zero length\n    dp[0][0] = 1\n\n    # since pattern of zero length will never match with string of non-zero length\n    for i in range(1, len_string):\n        dp[i][0] = 0\n\n    # since string of zero length will match with pattern where there\n    # is at least one * alternatively\n    for j in range(1, len_pattern):\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \"*\" else 0\n\n    # now using bottom-up approach to find for all remaining lengths\n    for i in range(1, len_string):\n        for j in range(1, len_pattern):\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \".\":\n                dp[i][j] = dp[i - 1][j - 1]\n\n            elif pattern[j - 1] == \"*\":\n                if dp[i][j - 2] == 1:\n                    dp[i][j] = 1\n                elif pattern[j - 2] in (input_string[i - 1], \".\"):\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n\n    return bool(dp[-1][-1])"}
{"task": "summary", "input": "summarize code:\ndef josephus_recursive(num_people: int, step_size: int) -> int:\n    if (\n        not isinstance(num_people, int)\n        or not isinstance(step_size, int)\n        or num_people <= 0\n        or step_size <= 0\n    ):\n        raise ValueError(\"num_people or step_size is not a positive integer.\")\n\n    if num_people == 1:\n        return 0\n\n    return (josephus_recursive(num_people - 1, step_size) + step_size) % num_people", "output": "Solve the Josephus problem for num_people and a step_size recursively."}
{"task": "summary", "input": "summarize code:\ndef pigeon_sort(array: list[int]) -> list[int]:\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "Implementation of pigeon hole sort algorithm"}
{"task": "detection", "input": "classify code:\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid's Algorithm\n\n    >>> greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    >>> greatest_common_divisor(121, 11)\n    11\n\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while a % b != 0:\n        a, b = b, a % b\n\n    return b", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef find_longest_chain(chain: list[int], max_num: int) -> int:\n    \"\"\"\n    Finds the smallest element of longest chain\n\n    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n    6\n    \"\"\"\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem", "output": "def find_longest_chain(chain: list[int], max_num: int) -> int:\n    \"\"\"\n    Finds the smallest element of longest chain\n\n    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n    6\n    \"\"\"\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem"}
{"task": "search", "input": "search code:\nConditionally pluralizes a singular word *unit_noun* if\n\nChoices:\n0: def iter_except(func, exception, first=None):     with suppress(exception):         if first is not None:             yield first()         while True:             yield func()\n1: def balanced_parentheses(parentheses: str) -> bool:     stack: Stack[str] = Stack()     bracket_pairs = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}     for bracket in parentheses:         if bracket in bracket_pairs:             stack.push(bracket)         elif bracket in (\")\", \"]\", \"}\") and (             stack.is_empty() or bracket_pairs[stack.pop()] != bracket         ):             return False     return stack.is_empty()\n2: def cardinalize(unit_noun, count):     if count == 1:         return unit_noun     return pluralize(unit_noun)", "output": "2"}
{"task": "search", "input": "search code:\nFunction to validate initial digits of a given credit card number.\n\nChoices:\n0: def validate_initial_digits(credit_card_number: str) -> bool:     return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))\n1: def prime_sieve(num: int) -> list[int]:      if num <= 0:         msg = f\"{num}: Invalid input, please enter a positive integer.\"         raise ValueError(msg)      sieve = [True] * (num + 1)     prime = []     start = 2     end = int(math.sqrt(num))      while start <= end:         # If start is a prime         if sieve[start] is True:             prime.append(start)              # Set multiples of start be False             for i in range(start * start, num + 1, start):                 if sieve[i] is True:                     sieve[i] = False          start += 1      for j in range(end + 1, num + 1):         if sieve[j] is True:             prime.append(j)      return prime\n2: def combination_with_replacement_index(element, iterable):     element = tuple(element)     l = len(element)     element = enumerate(element)      k, y = next(element, (None, None))     if k is None:         return 0      indexes = []     pool = tuple(iterable)     for n, x in enumerate(pool):         while x == y:             indexes.append(n)             tmp, y = next(element, (None, None))             if tmp is None:                 break             else:                 k = tmp         if y is None:             break     else:         raise ValueError(             'element is not a combination with replacement of iterable'         )      n = len(pool)     occupations = [0] * n     for p in indexes:         occupations[p] += 1      index = 0     cumulative_sum = 0     for k in range(1, n):         cumulative_sum += occupations[k - 1]         j = l + n - 1 - k - cumulative_sum         i = n - k         if i <= j:             index += comb(j, i)      return index", "output": "0"}
{"task": "search", "input": "search code:\nStrips values from the end of an iterable. Stripped items will\n\nChoices:\n0: def rstrip_iter(iterable, strip_value=None):     iterator = iter(iterable)     for i in iterator:         if i == strip_value:             cache = list()             cache.append(i)             broken = False             for i in iterator:                 if i == strip_value:                     cache.append(i)                 else:                     broken = True                     break             if not broken:  # Return to caller here because the end of the                 return     # iterator has been reached             yield from cache         yield i\n1: def solution(first_x_coord: float = 1.4, first_y_coord: float = -9.6) -> int:     num_reflections: int = 0     point_x: float = first_x_coord     point_y: float = first_y_coord     gradient: float = (10.1 - point_y) / (0.0 - point_x)      while not (-0.01 <= point_x <= 0.01 and point_y > 0):         point_x, point_y, gradient = next_point(point_x, point_y, gradient)         num_reflections += 1      return num_reflections\n2: def xor_gate(input_1: int, input_2: int) -> int:     return (input_1, input_2).count(0) % 2", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef generate_roman_numerals(num: int) -> str:\n    \"\"\"\n    Generates a string of roman numerals for a given integer.\n    e.g.\n    >>> generate_roman_numerals(89)\n    'LXXXIX'\n    >>> generate_roman_numerals(4)\n    'IV'\n    \"\"\"\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals", "output": "def generate_roman_numerals(num: int) -> str:\n    \"\"\"\n    Generates a string of roman numerals for a given integer.\n    e.g.\n    >>> generate_roman_numerals(89)\n    'LXXXIX'\n    >>> generate_roman_numerals(4)\n    'IV'\n    \"\"\"\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals"}
{"task": "detection", "input": "classify code:\ndef _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns a prime number generator using sieve method.\n\nChoices:\n0: def jump_search(arr: Sequence[T], item: T) -> int:      arr_size = len(arr)     block_size = int(math.sqrt(arr_size))      prev = 0     step = block_size     while arr[min(step, arr_size) - 1] < item:         prev = step         step += block_size         if prev >= arr_size:             return -1      while arr[prev] < item:         prev += 1         if prev == min(step, arr_size):             return -1     if arr[prev] == item:         return prev     return -1\n1: def sieve() -> Generator[int]:     factor_map: dict[int, int] = {}     prime = 2     while True:         factor = factor_map.pop(prime, None)         if factor:             x = factor + prime             while x in factor_map:                 x += factor             factor_map[x] = factor         else:             factor_map[prime * prime] = prime             yield prime         prime += 1\n2: def inorder(root: Node | None) -> None:     if not root:  # None         return     else:         inorder(root.left)         print(root.value, end=\",\")         inorder(root.right)", "output": "1"}
{"task": "search", "input": "search code:\nA near-mirror of :func:`is_iterable`. Returns ``False`` if an\n\nChoices:\n0: def is_scalar(obj):     return not is_iterable(obj) or isinstance(obj, (str, bytes))\n1: def sliced(seq, n, strict=False):     iterator = takewhile(len, (seq[i : i + n] for i in count(0, n)))     if strict:          def ret():             for _slice in iterator:                 if len(_slice) != n:                     raise ValueError(\"seq is not divisible by n.\")                 yield _slice          return ret()     else:         return iterator\n2: def build_sparse_table(number_list: list[int]) -> list[list[int]]:     if not number_list:         raise ValueError(\"empty number list not allowed\")      length = len(number_list)     # Initialise sparse_table -- sparse_table[j][i] represents the minimum value of the     # subset of length (2 ** j) of number_list, starting from index i.      # smallest power of 2 subset length that fully covers number_list     row = int(log2(length)) + 1     sparse_table = [[0 for i in range(length)] for j in range(row)]      # minimum of subset of length 1 is that value itself     for i, value in enumerate(number_list):         sparse_table[0][i] = value     j = 1      # compute the minimum value for all intervals with size (2 ** j)     while (1 << j) <= length:         i = 0         # while subset starting from i still have at least (2 ** j) elements         while (i + (1 << j) - 1) < length:             # split range [i, i + 2 ** j] and find minimum of 2 halves             sparse_table[j][i] = min(                 sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]             )             i += 1         j += 1     return sparse_table", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef running_key_decrypt(key: str, ciphertext: str) -> str:\n    ciphertext = ciphertext.replace(\" \", \"\").upper()\n    key = key.replace(\" \", \"\").upper()\n    key_length = len(key)\n    plaintext = []\n    ord_a = ord(\"A\")\n\n    for i, char in enumerate(ciphertext):\n        c = ord(char) - ord_a\n        k = ord(key[i % key_length]) - ord_a\n        p = (c - k) % 26\n        plaintext.append(chr(p + ord_a))\n\n    return \"\".join(plaintext)", "output": "Decrypts the ciphertext using the Running Key Cipher."}
{"task": "summary", "input": "summarize code:\ndef identity(n: int) -> list[list[int]]:\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]", "output": ":param n: dimension for nxn matrix"}
{"task": "repair", "input": "fix bug:\ndef validate(*values: float) -> bool:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> validate(2.016, 4.002)\n    True\n    >>> validate(-2.016, 4.002)\n    False\n    >>> validate()\n    False\n    \"\"\"\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result", "output": "def validate(*values: float) -> bool:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> validate(2.016, 4.002)\n    True\n    >>> validate(-2.016, 4.002)\n    False\n    >>> validate()\n    False\n    \"\"\"\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result"}
{"task": "search", "input": "search code:\nReturns the `k_value` most frequently occurring words,\n\nChoices:\n0: def quick_select(arr: list, target: int) -> int:      # Invalid Input     if target > len(arr):         return -1      # x is the estimated pivot by median of medians algorithm     x = median_of_medians(arr)     left = []     right = []     check = False     for i in range(len(arr)):         if arr[i] < x:             left.append(arr[i])         elif arr[i] > x:             right.append(arr[i])         elif arr[i] == x and not check:             check = True         else:             right.append(arr[i])     rank_x = len(left) + 1     if rank_x == target:         answer = x     elif rank_x > target:         answer = quick_select(left, target)     elif rank_x < target:         answer = quick_select(right, target - rank_x)     return answer\n1: def newtons_second_law_of_motion(mass: float, acceleration: float) -> float:     force = 0.0     try:         force = mass * acceleration     except Exception:         return -0.0     return force\n2: def top_k_frequent_words(words: list[str], k_value: int) -> list[str]:     heap: Heap[WordCount] = Heap()     count_by_word = Counter(words)     heap.build_max_heap(         [WordCount(word, count) for word, count in count_by_word.items()]     )     return [heap.extract_max().word for _ in range(min(k_value, len(count_by_word)))]", "output": "2"}
{"task": "search", "input": "search code:\nFind the maximum prize fund that should be allocated to a single game in which\n\nChoices:\n0: def solution(num_turns: int = 15) -> int:     total_prob: float = 0.0     prob: float     num_blue: int     num_red: int     ind: int     col: int     series: tuple[int, ...]      for series in product(range(2), repeat=num_turns):         num_blue = series.count(1)         num_red = num_turns - num_blue         if num_red >= num_blue:             continue         prob = 1.0         for ind, col in enumerate(series, 2):             if col == 0:                 prob *= (ind - 1) / ind             else:                 prob *= 1 / ind          total_prob += prob      return int(1 / total_prob)\n1: def height(root: Node | None) -> int:     return (max(height(root.left), height(root.right)) + 1) if root else 0\n2: def continuous_fraction_period(n: int) -> int:     numerator = 0.0     denominator = 1.0     root = int(sqrt(n))     integer_part = root     period = 0     while integer_part != 2 * root:         numerator = denominator * integer_part - numerator         denominator = (n - numerator**2) / denominator         integer_part = int((root + numerator) / denominator)         period += 1     return period", "output": "0"}
{"task": "search", "input": "search code:\nReturns the minimum difference of two pentagonal numbers P1 and P2 such that\n\nChoices:\n0: def archimedes_principle(     fluid_density: float, volume: float, gravity: float = g ) -> float:      if fluid_density <= 0:         raise ValueError(\"Impossible fluid density\")     if volume <= 0:         raise ValueError(\"Impossible object volume\")     if gravity < 0:         raise ValueError(\"Impossible gravity\")      return fluid_density * gravity * volume\n1: def solution(limit: int = 5000) -> int:     pentagonal_nums = [(i * (3 * i - 1)) // 2 for i in range(1, limit)]     for i, pentagonal_i in enumerate(pentagonal_nums):         for j in range(i, len(pentagonal_nums)):             pentagonal_j = pentagonal_nums[j]             a = pentagonal_i + pentagonal_j             b = pentagonal_j - pentagonal_i             if is_pentagonal(a) and is_pentagonal(b):                 return b      return -1\n2: def encrypt_message(     message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5 ) -> str:     message, alphabet, character_to_number, number_to_character = __prepare(         message, alphabet     )      encrypted_numeric = \"\"     for i in range(0, len(message) + 1, period):         encrypted_numeric += __encrypt_part(             message[i : i + period], character_to_number         )      encrypted = \"\"     for i in range(0, len(encrypted_numeric), 3):         encrypted += number_to_character[encrypted_numeric[i : i + 3]]     return encrypted", "output": "1"}
{"task": "search", "input": "search code:\nNetstring socket has an unreasonably low timeout,\n\nChoices:\n0: def netstring_server_timeout_override(server_socket):      try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock, timeout=0.01)             while 1:                 request = client.read_ns(1)                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'ping':                     client.write_ns(b'pong')     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise\n1: def run_length_encode(text: str) -> list:     encoded = []     count = 1      for i in range(len(text)):         if i + 1 < len(text) and text[i] == text[i + 1]:             count += 1         else:             encoded.append((text[i], count))             count = 1      return encoded\n2: def selection_sort(collection: list[int]) -> list[int]:      length = len(collection)     for i in range(length - 1):         min_index = i         for k in range(i + 1, length):             if collection[k] < collection[min_index]:                 min_index = k         if min_index != i:             collection[i], collection[min_index] = collection[min_index], collection[i]     return collection", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None", "output": "[summary]"}
{"task": "search", "input": "search code:\nStrips values from the beginning and end of an iterable. Stripped items\n\nChoices:\n0: def strip(iterable, strip_value=None):     return list(strip_iter(iterable, strip_value))\n1: def spy(iterable, n=1):     p, q = tee(iterable)     return take(n, q), p\n2: def sum_digit_factorials(n: int) -> int:     if n in CACHE_SUM_DIGIT_FACTORIALS:         return CACHE_SUM_DIGIT_FACTORIALS[n]     ret = sum(DIGIT_FACTORIALS[let] for let in str(n))     CACHE_SUM_DIGIT_FACTORIALS[n] = ret     return ret", "output": "0"}
{"task": "search", "input": "search code:\nSolve for remaining 'digit' digits, with previous 'prev1' digit, and\n\nChoices:\n0: def solution(num_picks: int = 20) -> str:     total = math.comb(NUM_BALLS, num_picks)     missing_colour = math.comb(NUM_BALLS - BALLS_PER_COLOUR, num_picks)      result = NUM_COLOURS * (1 - missing_colour / total)      return f\"{result:.9f}\"\n1: def solve(     digit: int, prev1: int, prev2: int, sum_max: int, first: bool, cache: dict[str, int] ) -> int:     if digit == 0:         return 1      cache_str = f\"{digit},{prev1},{prev2}\"     if cache_str in cache:         return cache[cache_str]      comb = 0     for curr in range(sum_max - prev1 - prev2 + 1):         if first and curr == 0:             continue          comb += solve(             digit=digit - 1,             prev1=curr,             prev2=prev1,             sum_max=sum_max,             first=False,             cache=cache,         )      cache[cache_str] = comb     return comb\n2: def second_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )", "output": "1"}
{"task": "detection", "input": "classify code:\ndef solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in range(1, 1001):\n        total += i ** i\n    return str(total)[-10:]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn a natural day.\n\nChoices:\n0: def get_support(cluster):     return [i * 100 / len(cluster) for i in cluster]\n1: def naturalday(value, format=\"%b %d\") -> str:     try:         value = dt.date(value.year, value.month, value.day)     except AttributeError:         # Passed value wasn't date-ish         return value     except (OverflowError, ValueError):         # Date arguments out of range         return value     delta = value - dt.date.today()     if delta.days == 0:         return _(\"today\")     elif delta.days == 1:         return _(\"tomorrow\")     elif delta.days == -1:         return _(\"yesterday\")     return value.strftime(format)\n2: def binary_mod_multiply(a: int, b: int, modulus: int) -> int:     res = 0     while b > 0:         if b & 1:             res = ((res % modulus) + (a % modulus)) % modulus          a += a         b >>= 1      return res", "output": "1"}
{"task": "search", "input": "search code:\nThis function carries out Binary search on a 1d array and\n\nChoices:\n0: def binary_search(array: list, lower_bound: int, upper_bound: int, value: int) -> int:      r = int((lower_bound + upper_bound) // 2)     if array[r] == value:         return r     if lower_bound >= upper_bound:         return -1     if array[r] < value:         return binary_search(array, r + 1, upper_bound, value)     else:         return binary_search(array, lower_bound, r - 1, value)\n1: def concurrent_tee(iterable, n=2):      if n < 0:         raise ValueError     if n == 0:         return ()     iterator = _concurrent_tee(iterable)     result = [iterator]     for _ in range(n - 1):         result.append(_concurrent_tee(iterator))     return tuple(result)\n2: def solution(ratio: float = 0.1) -> int:      j = 3     primes = 3      while primes / (2 * j - 1) >= ratio:         for i in range(j * j + j + 1, (j + 2) * (j + 2), j + 1):             primes += is_prime(i)         j += 2     return j", "output": "0"}
{"task": "detection", "input": "classify code:\ndef max_sub_array(nums: List[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef draw_cross(x: float, y: float, length: float):\n    turtle.up()\n    turtle.goto(x - length / 2, y - length / 6)\n    turtle.down()\n    turtle.seth(0)\n    turtle.begin_fill()\n    for _ in range(4):\n        turtle.fd(length / 3)\n        turtle.right(90)\n        turtle.fd(length / 3)\n        turtle.left(90)\n        turtle.fd(length / 3)\n        turtle.left(90)\n    turtle.end_fill()", "output": "Draw a cross at the specified position and with the specified length."}
{"task": "search", "input": "search code:\nChecking whether coordinate (row, col) is valid or not.\n\nChoices:\n0: def get_distance(highway_now: list, car_index: int) -> int:      distance = 0     cells = highway_now[car_index + 1 :]     for cell in range(len(cells)):  # May need a better name for this         if cells[cell] != -1:  # If the cell is not empty then             return distance  # we have the distance we wanted         distance += 1     # Here if the car is near the end of the highway     return distance + get_distance(highway_now, -1)\n1: def vol_spherical_cap(height: float, radius: float) -> float:     if height < 0 or radius < 0:         raise ValueError(\"vol_spherical_cap() only accepts non-negative values\")     # Volume is 1/3 pi * height squared * (3 * radius - height)     return 1 / 3 * pi * pow(height, 2) * (3 * radius - height)\n2: def is_safe(row: int, col: int, rows: int, cols: int) -> bool:     return 0 <= row < rows and 0 <= col < cols", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef difference(iterable, func=sub, *, initial=None):\n    a, b = tee(iterable)\n    try:\n        first = [next(b)]\n    except StopIteration:\n        return iter([])\n\n    if initial is not None:\n        first = []\n\n    return chain(first, map(func, b, a))", "output": "This function is the inverse of :func:`itertools.accumulate`. By default"}
{"task": "summary", "input": "summarize code:\ndef place_word(\n    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool\n) -> None:\n    for i, char in enumerate(word):\n        if vertical:\n            puzzle[row + i][col] = char\n        else:\n            puzzle[row][col + i] = char", "output": "Place a word at the given position."}
{"task": "search", "input": "search code:\nCalculate the area of a rectangle.\n\nChoices:\n0: def data_safety_checker(list_vote: list, actual_result: float) -> bool:     safe = 0     not_safe = 0      if not isinstance(actual_result, float):         raise TypeError(\"Actual result should be float. Value passed is a list\")      for i in list_vote:         if i > actual_result:             safe = not_safe + 1         elif abs(abs(i) - abs(actual_result)) <= 0.1:             safe += 1         else:             not_safe += 1     return safe > not_safe\n1: def area_rectangle(length: float, width: float) -> float:     if length < 0 or width < 0:         raise ValueError(\"area_rectangle() only accepts non-negative values\")     return length * width\n2: def solution(start: int = 144) -> int:     n = start     num = hexagonal_num(n)     while not is_pentagonal(num):         n += 1         num = hexagonal_num(n)     return num", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef levenshtein_distance(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Implementation of the Levenshtein distance in Python.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance(\"\", \"test\")\n    4\n    >>> levenshtein_distance(\"book\", \"back\")\n    2\n    >>> levenshtein_distance(\"book\", \"book\")\n    0\n    >>> levenshtein_distance(\"test\", \"\")\n    4\n    >>> levenshtein_distance(\"\", \"\")\n    0\n    >>> levenshtein_distance(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    # The longer word should come first\n    if len(first_word) < len(second_word):\n        return levenshtein_distance(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1]\n\n        for j, c2 in enumerate(second_word):\n            # Calculate insertions, deletions, and substitutions\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n\n            # Get the minimum to append to the current row\n            current_row.append(min(insertions, deletions, substitutions))\n\n        # Store the previous row\n        previous_row = current_row\n\n    # Returns the last element (distance)\n    return previous_row[-1]", "output": "def levenshtein_distance(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Implementation of the Levenshtein distance in Python.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance(\"\", \"test\")\n    4\n    >>> levenshtein_distance(\"book\", \"back\")\n    2\n    >>> levenshtein_distance(\"book\", \"book\")\n    0\n    >>> levenshtein_distance(\"test\", \"\")\n    4\n    >>> levenshtein_distance(\"\", \"\")\n    0\n    >>> levenshtein_distance(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    # The longer word should come first\n    if len(first_word) < len(second_word):\n        return levenshtein_distance(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1]\n\n        for j, c2 in enumerate(second_word):\n            # Calculate insertions, deletions, and substitutions\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n\n            # Get the minimum to append to the current row\n            current_row.append(min(insertions, deletions, substitutions))\n\n        # Store the previous row\n        previous_row = current_row\n\n    # Returns the last element (distance)\n    return previous_row[-1]"}
{"task": "search", "input": "search code:\nReturns the color of a node, allowing for None leaves.\n\nChoices:\n0: def color(node: RedBlackTree | None) -> int:     if node is None:         return 0     else:         return node.color\n1: def quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:      if a == 0:         raise ValueError(\"Coefficient 'a' must not be zero.\")     delta = b * b - 4 * a * c      root_1 = (-b + sqrt(delta)) / (2 * a)     root_2 = (-b - sqrt(delta)) / (2 * a)      return (         root_1.real if not root_1.imag else root_1,         root_2.real if not root_2.imag else root_2,     )\n2: def ceil(x: float) -> int:     return int(x) if x - int(x) <= 0 else int(x) + 1", "output": "0"}
{"task": "detection", "input": "classify code:\ndef split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator (defaults to spaces)\n    \n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n    \n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n    \n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n    \n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef is_happy_number(number: int) -> bool:\n    if not isinstance(number, int) or number <= 0:\n        msg = f\"{number=} must be a positive integer\"\n        raise ValueError(msg)\n\n    seen = set()\n    while number != 1 and number not in seen:\n        seen.add(number)\n        number = sum(int(digit) ** 2 for digit in str(number))\n    return number == 1", "output": "A happy number is a number which eventually reaches 1 when replaced by the sum of"}
{"task": "search", "input": "search code:\nReturn the geometric mean of the argument numbers.\n\nChoices:\n0: def msd_radix_sort(list_of_ints: list[int]) -> list[int]:     if not list_of_ints:         return []      if min(list_of_ints) < 0:         raise ValueError(\"All numbers must be positive\")      most_bits = max(len(bin(x)[2:]) for x in list_of_ints)     return _msd_radix_sort(list_of_ints, most_bits)\n1: def compute_geometric_mean(*args: int) -> float:     product = 1     for number in args:         if not isinstance(number, int) and not isinstance(number, float):             raise TypeError(\"Not a Number\")         product *= number     # Cannot calculate the even root for negative product.     # Frequently they are restricted to being positive.     if product < 0 and len(args) % 2 == 0:         raise ArithmeticError(\"Cannot Compute Geometric Mean for these numbers.\")     mean = abs(product) ** (1 / len(args))     # Since python calculates complex roots for negative products with odd roots.     if product < 0:         mean = -mean     # Since it does floating point arithmetic, it gives 64**(1/3) as 3.99999996     possible_mean = float(round(mean))     # To check if the rounded number is actually the mean.     if possible_mean ** len(args) == product:         mean = possible_mean     return mean\n2: def transformation_matrix(velocity: float) -> np.ndarray:     return np.array(         [             [gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],             [-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],             [0, 0, 1, 0],             [0, 0, 0, 1],         ]     )", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef generate_pascal_triangle(num_rows: int) -> list[list[int]]:\n\n    if not isinstance(num_rows, int):\n        raise TypeError(\"The input value of 'num_rows' should be 'int'\")\n\n    if num_rows == 0:\n        return []\n    elif num_rows < 0:\n        raise ValueError(\n            \"The input value of 'num_rows' should be greater than or equal to 0\"\n        )\n\n    triangle: list[list[int]] = []\n    for current_row_idx in range(num_rows):\n        current_row = populate_current_row(triangle, current_row_idx)\n        triangle.append(current_row)\n    return triangle", "output": "Create Pascal's triangle for different number of rows"}
{"task": "detection", "input": "classify code:\ndef minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))", "output": "CORRECT"}
{"task": "search", "input": "search code:\nPrim's Algorithm with min heap.\n\nChoices:\n0: def prim_heap(graph: list, root: Vertex) -> Iterator[tuple]:     for u in graph:         u.key = math.inf         u.pi = None     root.key = 0      h = list(graph)     hq.heapify(h)      while h:         u = hq.heappop(h)         for v in u.neighbors:             if (v in h) and (u.edges[v.id] < v.key):                 v.pi = u                 v.key = u.edges[v.id]                 hq.heapify(h)      for i in range(1, len(graph)):         yield (int(graph[i].id) + 1, int(graph[i].pi.id) + 1)\n1: def _validator(     rotpos: RotorPositionT, rotsel: RotorSelectionT, pb: str ) -> tuple[RotorPositionT, RotorSelectionT, dict[str, str]]:     # Checks if there are 3 unique rotors      if (unique_rotsel := len(set(rotsel))) < 3:         msg = f\"Please use 3 unique rotors (not {unique_rotsel})\"         raise Exception(msg)      # Checks if rotor positions are valid     rotorpos1, rotorpos2, rotorpos3 = rotpos     if not 0 < rotorpos1 <= len(abc):         msg = f\"First rotor position is not within range of 1..26 ({rotorpos1}\"         raise ValueError(msg)     if not 0 < rotorpos2 <= len(abc):         msg = f\"Second rotor position is not within range of 1..26 ({rotorpos2})\"         raise ValueError(msg)     if not 0 < rotorpos3 <= len(abc):         msg = f\"Third rotor position is not within range of 1..26 ({rotorpos3})\"         raise ValueError(msg)      # Validates string and returns dict     pbdict = _plugboard(pb)      return rotpos, rotsel, pbdict\n2: def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:      return len_board * len_board_column * row + column", "output": "0"}
{"task": "search", "input": "search code:\nFind the minimum number of multiplcations required to multiply the chain of matrices\n\nChoices:\n0: def clear_bit(number: int, position: int) -> int:     return number & ~(1 << position)\n1: def matrix_chain_multiply(arr: list[int]) -> int:     if len(arr) < 2:         return 0     # initialising 2D dp matrix     n = len(arr)     dp = [[maxsize for j in range(n)] for i in range(n)]     # we want minimum cost of multiplication of matrices     # of dimension (i*k) and (k*j). This cost is arr[i-1]*arr[k]*arr[j].     for i in range(n - 1, 0, -1):         for j in range(i, n):             if i == j:                 dp[i][j] = 0                 continue             for k in range(i, j):                 dp[i][j] = min(                     dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]                 )      return dp[1][n - 1]\n2: def is_germain_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return is_prime(number) and is_prime(2 * number + 1)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef sliced(seq, n, strict=False):\n    iterator = takewhile(len, (seq[i : i + n] for i in count(0, n)))\n    if strict:\n\n        def ret():\n            for _slice in iterator:\n                if len(_slice) != n:\n                    raise ValueError(\"seq is not divisible by n.\")\n                yield _slice\n\n        return ret()\n    else:\n        return iterator", "output": "Yield slices of length *n* from the sequence *seq*."}
{"task": "search", "input": "search code:\nRun through the list of Letters and build the min heap\n\nChoices:\n0: def huffman(file_path: str) -> None:     letters_list = parse_file(file_path)     root = build_tree(letters_list)     letters = {         k: v for letter in traverse_tree(root, \"\") for k, v in letter.bitstring.items()     }     print(f\"Huffman Coding  of {file_path}: \")     with open(file_path) as f:         while True:             c = f.read(1)             if not c:                 break             print(letters[c], end=\" \")     print()\n1: def build_tree(letters: list[Letter]) -> Letter | TreeNode:     response: list[Letter | TreeNode] = list(letters)     while len(response) > 1:         left = response.pop(0)         right = response.pop(0)         total_freq = left.freq + right.freq         node = TreeNode(total_freq, left, right)         response.append(node)         response.sort(key=lambda x: x.freq)     return response[0]\n2: def running_key_encrypt(key: str, plaintext: str) -> str:     plaintext = plaintext.replace(\" \", \"\").upper()     key = key.replace(\" \", \"\").upper()     key_length = len(key)     ciphertext = []     ord_a = ord(\"A\")      for i, char in enumerate(plaintext):         p = ord(char) - ord_a         k = ord(key[i % key_length]) - ord_a         c = (p + k) % 26         ciphertext.append(chr(c + ord_a))      return \"\".join(ciphertext)", "output": "1"}
{"task": "search", "input": "search code:\nPure implementation of binary search algorithm in Python using recursion\n\nChoices:\n0: def fizz_buzz(number: int, iterations: int) -> str:     if not isinstance(iterations, int):         raise ValueError(\"iterations must be defined as integers\")     if not isinstance(number, int) or not number >= 1:         raise ValueError(         )     if not iterations >= 1:         raise ValueError(\"Iterations must be done more than 0 times to play FizzBuzz\")      out = \"\"     while number <= iterations:         if number % 3 == 0:             out += \"Fizz\"         if number % 5 == 0:             out += \"Buzz\"         if 0 not in (number % 3, number % 5):             out += str(number)          # print(out)         number += 1         out += \" \"     return out\n1: def binary_search_by_recursion(     sorted_collection: list[int], item: int, left: int = 0, right: int = -1 ) -> int:     if right < 0:         right = len(sorted_collection) - 1     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     if right < left:         return -1      midpoint = left + (right - left) // 2      if sorted_collection[midpoint] == item:         return midpoint     elif sorted_collection[midpoint] > item:         return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)     else:         return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)\n2: def binary_tree_left_side_view(root: TreeNode) -> list[int]:      def depth_first_search(         root: TreeNode | None, depth: int, left_view: list[int]     ) -> None:         if not root:             return          if depth == len(left_view):             left_view.append(root.val)          depth_first_search(root.left, depth + 1, left_view)         depth_first_search(root.right, depth + 1, left_view)      left_view: list = []     if not root:         return left_view      depth_first_search(root, 0, left_view)     return left_view", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef unique_prime_factors(n: int) -> list[int]:\n    i = 2\n    factors = []\n    while i * i <= n:\n        if not n % i:\n            while not n % i:\n                n //= i\n            factors.append(i)\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors", "output": "Returns unique prime factors of n as a list."}
{"task": "search", "input": "search code:\nEncrypt plaintext with the Gronsfeld cipher\n\nChoices:\n0: def rlocate(iterable, pred=bool, window_size=None):     if window_size is None:         try:             len_iter = len(iterable)             return (len_iter - i - 1 for i in locate(reversed(iterable), pred))         except TypeError:             pass      return reversed(list(locate(iterable, pred, window_size)))\n1: def gronsfeld(text: str, key: str) -> str:     ascii_len = len(ascii_uppercase)     key_len = len(key)     encrypted_text = \"\"     keys = [int(char) for char in key]     upper_case_text = text.upper()      for i, char in enumerate(upper_case_text):         if char in ascii_uppercase:             new_position = (ascii_uppercase.index(char) + keys[i % key_len]) % ascii_len             shifted_letter = ascii_uppercase[new_position]             encrypted_text += shifted_letter         else:             encrypted_text += char      return encrypted_text\n2: def find_isolated_nodes(graph):     isolated = []     for node in graph:         if not graph[node]:             isolated.append(node)     return isolated", "output": "1"}
{"task": "search", "input": "search code:\nShow frequency response of a filter\n\nChoices:\n0: def show_frequency_response(filter_type: FilterType, samplerate: int) -> None:      size = 512     inputs = [1] + [0] * (size - 1)     outputs = [filter_type.process(item) for item in inputs]      filler = [0] * (samplerate - size)  # zero-padding     outputs += filler     fft_out = np.abs(np.fft.fft(outputs))     fft_db = 20 * np.log10(fft_out)      # Frequencies on log scale from 24 to nyquist frequency     plt.xlim(24, samplerate / 2 - 1)     plt.xlabel(\"Frequency (Hz)\")     plt.xscale(\"log\")      # Display within reasonable bounds     bounds = get_bounds(fft_db, samplerate)     plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))     plt.ylabel(\"Gain (dB)\")      plt.plot(fft_db)     plt.show()\n1: def solution(limit: float = 1e10) -> int:     primes = sieve()      n = 1     while True:         prime = next(primes)         if (2 * prime * n) > limit:             return n         # Ignore the next prime as the reminder will be 2.         next(primes)         n += 2\n2: def generate_formula() -> Formula:     clauses: set[Clause] = set()     no_of_clauses = random.randint(1, 10)     while len(clauses) < no_of_clauses:         clauses.add(generate_clause())     return Formula(clauses)", "output": "0"}
{"task": "search", "input": "search code:\nSet the bit at position to 0.\n\nChoices:\n0: def clear_bit(number: int, position: int) -> int:     return number & ~(1 << position)\n1: def binary_and(a: int, b: int) -> str:     if a < 0 or b < 0:         raise ValueError(\"the value of both inputs must be positive\")      a_binary = format(a, \"b\")     b_binary = format(b, \"b\")      max_len = max(len(a_binary), len(b_binary))      return \"0b\" + \"\".join(         str(int(char_a == \"1\" and char_b == \"1\"))         for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))     )\n2: def binary_tree_left_side_view(root: TreeNode) -> list[int]:      def depth_first_search(         root: TreeNode | None, depth: int, left_view: list[int]     ) -> None:         if not root:             return          if depth == len(left_view):             left_view.append(root.val)          depth_first_search(root.left, depth + 1, left_view)         depth_first_search(root.right, depth + 1, left_view)      left_view: list = []     if not root:         return left_view      depth_first_search(root, 0, left_view)     return left_view", "output": "0"}
{"task": "search", "input": "search code:\nEncodes to Baconian cipher\n\nChoices:\n0: def solution(n: int = 1000) -> int:      a = 3     result = 0     while a < n:         if a % 3 == 0 or a % 5 == 0:             result += a         elif a % 15 == 0:             result -= a         a += 1     return result\n1: def encode(word: str) -> str:     encoded = \"\"     for letter in word.lower():         if letter.isalpha() or letter == \" \":             encoded += encode_dict[letter]         else:             raise Exception(\"encode() accepts only letters of the alphabet and spaces\")     return encoded\n2: def polynomial_from_roots(roots):      # This recipe differs from the one in itertools docs in that it     # applies list() after each call to convolve().  This avoids     # hitting stack limits with nested generators.      poly = [1]     for root in roots:         poly = list(convolve(poly, (1, -root)))     return poly", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef largest_pow_of_two_le_num(number: int) -> int:\n    if isinstance(number, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    if number <= 0:\n        return 0\n    res = 1\n    while (res << 1) <= number:\n        res <<= 1\n    return res", "output": "Return the largest power of two less than or equal to a number."}
{"task": "repair", "input": "fix bug:\ndef cyclic_sort(nums: list[int]) -> list[int]:\n    \"\"\"\n    Sorts the input list of n integers from 1 to n in-place\n    using the Cyclic Sort algorithm.\n\n    :param nums: List of n integers from 1 to n to be sorted.\n    :return: The same list sorted in ascending order.\n\n    Time complexity: O(n), where n is the number of integers in the list.\n\n    Examples:\n    >>> cyclic_sort([])\n    []\n    >>> cyclic_sort([3, 5, 2, 1, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums", "output": "def cyclic_sort(nums: list[int]) -> list[int]:\n    \"\"\"\n    Sorts the input list of n integers from 1 to n in-place\n    using the Cyclic Sort algorithm.\n\n    :param nums: List of n integers from 1 to n to be sorted.\n    :return: The same list sorted in ascending order.\n\n    Time complexity: O(n), where n is the number of integers in the list.\n\n    Examples:\n    >>> cyclic_sort([])\n    []\n    >>> cyclic_sort([3, 5, 2, 1, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums"}
{"task": "detection", "input": "classify code:\ndef generate_roman_numerals(num: int) -> str:\n    \"\"\"\n    Generates a string of roman numerals for a given integer.\n    e.g.\n    >>> generate_roman_numerals(89)\n    'LXXXIX'\n    >>> generate_roman_numerals(4)\n    'IV'\n    \"\"\"\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef write_file_binary(file_path: str, to_write: str) -> None:\n    byte_length = 8\n    try:\n        with open(file_path, \"wb\") as opened_file:\n            result_byte_array = [\n                to_write[i : i + byte_length]\n                for i in range(0, len(to_write), byte_length)\n            ]\n\n            if len(result_byte_array[-1]) % byte_length == 0:\n                result_byte_array.append(\"10000000\")\n            else:\n                result_byte_array[-1] += \"1\" + \"0\" * (\n                    byte_length - len(result_byte_array[-1]) - 1\n                )\n\n            for elem in result_byte_array[:-1]:\n                opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()", "output": "Writes given to_write string (should only consist of 0's and 1's) as bytes in the"}
{"task": "repair", "input": "fix bug:\ndef sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    \"\"\"\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res", "output": "def sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(-123)\n    6\n    >>> sum_of_digits(0)\n    0\n    \"\"\"\n    n = -n if n < 0 else n\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res"}
{"task": "search", "input": "search code:\nImplementation of breadth first search using queue.Queue.\n\nChoices:\n0: def breadth_first_search(graph: dict, start: str) -> list[str]:     explored = {start}     result = [start]     queue: Queue = Queue()     queue.put(start)     while not queue.empty():         v = queue.get()         for w in graph[v]:             if w not in explored:                 explored.add(w)                 result.append(w)                 queue.put(w)     return result\n1: def iter_merge_sort(input_list: list) -> list:     if len(input_list) <= 1:         return input_list     input_list = list(input_list)      # iteration for two-way merging     p = 2     while p <= len(input_list):         # getting low, high and middle value for merge-sort of single list         for i in range(0, len(input_list), p):             low = i             high = i + p - 1             mid = (low + high + 1) // 2             input_list = merge(input_list, low, mid, high)         # final merge of last two parts         if p * 2 >= len(input_list):             mid = i             input_list = merge(input_list, 0, mid, len(input_list) - 1)             break         p *= 2      return input_list\n2: def solution(limit: int = 1000000) -> int:     limit = limit + 1     frequency = [0] * limit     for first_term in range(1, limit):         for n in range(first_term, limit, first_term):             common_difference = first_term + n / first_term             if common_difference % 4:  # d must be divisible by 4                 continue             else:                 common_difference /= 4                 if (                     first_term > common_difference                     and first_term < 4 * common_difference                 ):  # since x, y, z are positive integers                     frequency[n] += 1  # so z > 0, a > d and 4d < a      count = sum(1 for x in frequency[1:limit] if x == 10)      return count", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 999_966_663_333) -> int:\n    primes_upper_bound = math.floor(math.sqrt(limit)) + 100\n    primes = prime_sieve(primes_upper_bound)\n\n    matches_sum = 0\n    prime_index = 0\n    last_prime = primes[prime_index]\n\n    while (last_prime**2) <= limit:\n        next_prime = primes[prime_index + 1]\n\n        lower_bound = last_prime**2\n        upper_bound = next_prime**2\n\n        # Get numbers divisible by lps(current)\n        current = lower_bound + last_prime\n        while upper_bound > current <= limit:\n            matches_sum += current\n            current += last_prime\n\n        # Reset the upper_bound\n        while (upper_bound - next_prime) > limit:\n            upper_bound -= next_prime\n\n        # Add the numbers divisible by ups(current)\n        current = upper_bound - next_prime\n        while current > lower_bound:\n            matches_sum += current\n            current -= next_prime\n\n        # Remove the numbers divisible by both ups and lps\n        current = 0\n        while upper_bound > current <= limit:\n            if current <= lower_bound:\n                # Increment the current number\n                current += last_prime * next_prime\n                continue\n\n            if current > limit:\n                break\n\n            # Remove twice since it was added by both ups and lps\n            matches_sum -= current * 2\n\n            # Increment the current number\n            current += last_prime * next_prime\n\n        # Setup for next pair\n        last_prime = next_prime\n        prime_index += 1\n\n    return matches_sum", "output": "Computes the solution to the problem up to the specified limit"}
{"task": "search", "input": "search code:\nChecks if input number and 2*number + 1 are prime.\n\nChoices:\n0: def check_anagrams(first_str: str, second_str: str) -> bool:     first_str = first_str.lower().strip()     second_str = second_str.lower().strip()      # Remove whitespace     first_str = first_str.replace(\" \", \"\")     second_str = second_str.replace(\" \", \"\")      # Strings of different lengths are not anagrams     if len(first_str) != len(second_str):         return False      # Default values for count should be 0     count: defaultdict[str, int] = defaultdict(int)      # For each character in input strings,     # increment count in the corresponding     for i in range(len(first_str)):         count[first_str[i]] += 1         count[second_str[i]] -= 1      return all(_count == 0 for _count in count.values())\n1: def is_germain_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return is_prime(number) and is_prime(2 * number + 1)\n2: def dir_dict(obj, raise_exc=False):     # TODO: separate function for handling descriptors on types?     ret = {}     for k in dir(obj):         try:             ret[k] = getattr(obj, k)         except Exception:             if raise_exc:                 raise     return ret", "output": "1"}
{"task": "detection", "input": "classify code:\ndef bisect_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef gunzip_bytes(bytestring):\n    return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)", "output": "The :mod:`gzip` module is great if you have a file or file-like"}
{"task": "summary", "input": "summarize code:\ndef random_chars(number_char: int) -> str:\n    assert number_char > 1, \"The number of character should greater than 1\"\n    letter_code = ascii_lowercase + digits\n    return \"\".join(random.choice(letter_code) for _ in range(number_char))", "output": "Automatic generate random 32 characters."}
{"task": "summary", "input": "summarize code:\ndef decimal_isolate(number: float, digit_amount: int) -> float:\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)", "output": "Isolates the decimal part of a number."}
{"task": "search", "input": "search code:\nHandles I/O\n\nChoices:\n0: def quick_select(arr: list, target: int) -> int:      # Invalid Input     if target > len(arr):         return -1      # x is the estimated pivot by median of medians algorithm     x = median_of_medians(arr)     left = []     right = []     check = False     for i in range(len(arr)):         if arr[i] < x:             left.append(arr[i])         elif arr[i] > x:             right.append(arr[i])         elif arr[i] == x and not check:             check = True         else:             right.append(arr[i])     rank_x = len(left) + 1     if rank_x == target:         answer = x     elif rank_x > target:         answer = quick_select(left, target)     elif rank_x < target:         answer = quick_select(right, target - rank_x)     return answer\n1: def main() -> None:     message = input(\"Enter message to encode or decode: \").strip()     key = input(\"Enter keyword: \").strip()     option = input(\"Encipher or decipher? E/D:\").strip()[0].lower()     try:         func = {\"e\": encipher, \"d\": decipher}[option]     except KeyError:         raise KeyError(\"invalid input option\")     cipher_map = create_cipher_map(key)     print(func(message, cipher_map))\n2: def max_sum_in_array(array: list[int], k: int) -> int:     if len(array) < k or k < 0:         raise ValueError(\"Invalid Input\")     max_sum = current_sum = sum(array[:k])     for i in range(len(array) - k):         current_sum = current_sum - array[i] + array[i + k]         max_sum = max(max_sum, current_sum)     return max_sum", "output": "1"}
{"task": "search", "input": "search code:\nReturns the sum of the digits in the factorial of num\n\nChoices:\n0: def format_exp_repr(obj, pos_names, req_names=None, opt_names=None, opt_key=None):     cn = type(obj).__name__     req_names = req_names or []     opt_names = opt_names or []     uniq_names, all_names = set(), []     for name in req_names + opt_names:         if name in uniq_names:             continue         uniq_names.add(name)         all_names.append(name)      if opt_key is None:         opt_key = lambda v: v is None     assert callable(opt_key)      args = [getattr(obj, name, None) for name in pos_names]      kw_items = [(name, getattr(obj, name, None)) for name in all_names]     kw_items = [(name, val) for name, val in kw_items                 if not (name in opt_names and opt_key(val))]      return format_invocation(cn, args, kw_items)\n1: def solution(num: int = 100) -> int:     return sum(int(x) for x in str(factorial(num)))\n2: def print_solution(grid: Matrix) -> None:     for row in grid:         for cell in row:             print(cell, end=\" \")         print()", "output": "1"}
{"task": "detection", "input": "classify code:\ndef orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    \"\"\"\n    Calculates the work required to move an object from one orbit to another in a\n    gravitational field based on the change in total mechanical energy.\n\n    The formula used is:\n        W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\n    where:\n        W = work done (Joules)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the central body (kg)\n        m = mass of the orbiting object (kg)\n        r_initial = initial orbit radius (m)\n        r_final = final orbit radius (m)\n\n    Args:\n        mass_central (float): Mass of the central body (kg)\n        mass_object (float): Mass of the object being moved (kg)\n        r_initial (float): Initial orbital radius (m)\n        r_final (float): Final orbital radius (m)\n\n    Returns:\n        str: Work done in Joules as a string in scientific notation (3 decimals)\n\n    Examples:\n        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n        '2.811e+09'\n        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n        '-1.405e+09'\n        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n        '1.514e+11'\n    \"\"\"\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\"", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef factorial(num: int) -> int:\n    fact = 1\n    for i in range(1, num + 1):\n        fact *= i\n    return fact", "output": "Find the factorial of a given number n"}
{"task": "detection", "input": "classify code:\ndef match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef generate_parenthesis(n: int) -> list[str]:\n\n    result: list[str] = []\n    backtrack(\"\", 0, 0, n, result)\n    return result", "output": "Generate valid combinations of balanced parentheses for a given n."}
{"task": "search", "input": "search code:\nReturns a plain-English description of an iterable's\n\nChoices:\n0: def _date_and_delta(value, *, now=None):     if not now:         now = _now()     if isinstance(value, dt.datetime):         date = value         delta = now - value     elif isinstance(value, dt.timedelta):         date = now - value         delta = value     else:         try:             value = int(value)             delta = dt.timedelta(seconds=value)             date = now - delta         except (ValueError, TypeError):             return None, value     return date, _abs_timedelta(delta)\n1: def unit_len(sized_iterable, unit_noun='item'):  # TODO: len_units()/unitize()?     count = len(sized_iterable)     units = cardinalize(unit_noun, count)     if count:         return f'{count} {units}'     return f'No {units}'\n2: def comb_sort(data: list) -> list:     shrink_factor = 1.3     gap = len(data)     completed = False      while not completed:         # Update the gap value for a next comb         gap = int(gap / shrink_factor)         if gap <= 1:             completed = True          index = 0         while index + gap < len(data):             if data[index] > data[index + gap]:                 # Swap values                 data[index], data[index + gap] = data[index + gap], data[index]                 completed = False             index += 1      return data", "output": "1"}
{"task": "search", "input": "search code:\nReturns the largest prime factor of a given number n.\n\nChoices:\n0: def is_germain_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return is_prime(number) and is_prime(2 * number + 1)\n1: def _abs_timedelta(delta):     if delta.days < 0:         now = _now()         return now - (now + delta)     return delta\n2: def solution(n: int = 600851475143) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     prime = 1     i = 2     while i * i <= n:         while n % i == 0:             prime = i             n //= i         i += 1     if n > 1:         prime = n     return int(prime)", "output": "2"}
{"task": "search", "input": "search code:\nReturns the last n digits of NUMBER.\n\nChoices:\n0: def solution(n: int = 1000000) -> int:      result = max((collatz_sequence_length(i), i) for i in range(1, n))     return result[1]\n1: def solution(nth: int = 10001) -> int:      try:         nth = int(nth)     except (TypeError, ValueError):         raise TypeError(\"Parameter nth must be int or castable to int.\") from None     if nth <= 0:         raise ValueError(\"Parameter nth must be greater than or equal to one.\")     primes: list[int] = []     num = 2     while len(primes) < nth:         if is_prime(num):             primes.append(num)             num += 1         else:             num += 1     return primes[len(primes) - 1]\n2: def solution(n: int = 10) -> str:     if not isinstance(n, int) or n < 0:         raise ValueError(\"Invalid input\")     modulus = 10**n     number = 28433 * (pow(2, 7830457, modulus)) + 1     return str(number % modulus)", "output": "2"}
{"task": "search", "input": "search code:\n:param unsorted: unsorted list containing integers numbers\n\nChoices:\n0: def heapify(unsorted: list[int], index: int, heap_size: int) -> None:     largest = index     left_index = 2 * index + 1     right_index = 2 * index + 2     if left_index < heap_size and unsorted[left_index] > unsorted[largest]:         largest = left_index      if right_index < heap_size and unsorted[right_index] > unsorted[largest]:         largest = right_index      if largest != index:         unsorted[largest], unsorted[index] = (unsorted[index], unsorted[largest])         heapify(unsorted, largest, heap_size)\n1: def horn_schunck(     image0: np.ndarray,     image1: np.ndarray,     num_iter: SupportsIndex,     alpha: float | None = None, ) -> tuple[np.ndarray, np.ndarray]:     if alpha is None:         alpha = 0.1      # Initialize flow     horizontal_flow = np.zeros_like(image0)     vertical_flow = np.zeros_like(image0)      # Prepare kernels for the calculation of the derivatives and the average velocity     kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25     kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25     kernel_t = np.array([[1, 1], [1, 1]]) * 0.25     kernel_laplacian = np.array(         [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]     )      # Iteratively refine the flow     for _ in range(num_iter):         warped_image = warp(image0, horizontal_flow, vertical_flow)         derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)         derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)         derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)          avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)         avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)          # This updates the flow as proposed in the paper (Step 12)         update = (             derivative_x * avg_horizontal_velocity             + derivative_y * avg_vertical_velocity             + derivative_t         )         update = update / (alpha**2 + derivative_x**2 + derivative_y**2)          horizontal_flow = avg_horizontal_velocity - derivative_x * update         vertical_flow = avg_vertical_velocity - derivative_y * update      return horizontal_flow, vertical_flow\n2: def run_linear_regression(data_x, data_y):     iterations = 100000     alpha = 0.0001550      no_features = data_x.shape[1]     len_data = data_x.shape[0] - 1      theta = np.zeros((1, no_features))      for i in range(iterations):         theta = run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)         error = sum_of_square_error(data_x, data_y, len_data, theta)         print(f\"At Iteration {i + 1} - Error is {error:.5f}\")      return theta", "output": "0"}
{"task": "detection", "input": "classify code:\ndef power(x: int, y: int, mod: int) -> int:\n    \"\"\"\n    Examples:\n    >>> power(2, 15, 3)\n    2\n    >>> power(5, 1, 30)\n    5\n    \"\"\"\n\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, mod) % mod\n    temp = (temp * temp) % mod\n    if y % 2 == 1:\n        temp = (temp * x) % mod\n    return temp", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef interleave_evenly(iterables, lengths=None):\n    if lengths is None:\n        try:\n            lengths = [len(it) for it in iterables]\n        except TypeError:\n            raise ValueError(\n                'Iterable lengths could not be determined automatically. '\n                'Specify them with the lengths keyword.'\n            )\n    elif len(iterables) != len(lengths):\n        raise ValueError('Mismatching number of iterables and lengths.')\n\n    dims = len(lengths)\n\n    # sort iterables by length, descending\n    lengths_permute = sorted(\n        range(dims), key=lambda i: lengths[i], reverse=True\n    )\n    lengths_desc = [lengths[i] for i in lengths_permute]\n    iters_desc = [iter(iterables[i]) for i in lengths_permute]\n\n    # the longest iterable is the primary one (Bresenham: the longest\n    # distance along an axis)\n    delta_primary, deltas_secondary = lengths_desc[0], lengths_desc[1:]\n    iter_primary, iters_secondary = iters_desc[0], iters_desc[1:]\n    errors = [delta_primary // dims] * len(deltas_secondary)\n\n    to_yield = sum(lengths)\n    while to_yield:\n        yield next(iter_primary)\n        to_yield -= 1\n        # update errors for each secondary iterable\n        errors = [e - delta for e, delta in zip(errors, deltas_secondary)]\n\n        # those iterables for which the error is negative are yielded\n        # (\"diagonal step\" in Bresenham)\n        for i, e_ in enumerate(errors):\n            if e_ < 0:\n                yield next(iters_secondary[i])\n                to_yield -= 1\n                errors[i] += delta_primary", "output": "Interleave multiple iterables so that their elements are evenly distributed"}
{"task": "detection", "input": "classify code:\ndef ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp", "output": "BUGGY"}
{"task": "search", "input": "search code:\nDetermines whether n in base 'base' is a harshad number.\n\nChoices:\n0: def merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:     if tree1 is None:         return tree2     if tree2 is None:         return tree1      tree1.value = tree1.value + tree2.value     tree1.left = merge_two_binary_trees(tree1.left, tree2.left)     tree1.right = merge_two_binary_trees(tree1.right, tree2.right)     return tree1\n1: def solution(target: int = 2000000) -> int:     triangle_numbers: list[int] = [0]     idx: int      for idx in range(1, ceil(sqrt(target * 2) * 1.1)):         triangle_numbers.append(triangle_numbers[-1] + idx)      # we want this to be as close as possible to target     best_product: int = 0     # the area corresponding to the grid that gives the product closest to target     area: int = 0     # an estimate of b, using the quadratic formula     b_estimate: float     # the largest integer less than b_estimate     b_floor: int     # the largest integer less than b_estimate     b_ceil: int     # the triangle number corresponding to b_floor     triangle_b_first_guess: int     # the triangle number corresponding to b_ceil     triangle_b_second_guess: int      for idx_a, triangle_a in enumerate(triangle_numbers[1:], 1):         b_estimate = (-1 + sqrt(1 + 8 * target / triangle_a)) / 2         b_floor = floor(b_estimate)         b_ceil = ceil(b_estimate)         triangle_b_first_guess = triangle_numbers[b_floor]         triangle_b_second_guess = triangle_numbers[b_ceil]          if abs(target - triangle_b_first_guess * triangle_a) < abs(             target - best_product         ):             best_product = triangle_b_first_guess * triangle_a             area = idx_a * b_floor          if abs(target - triangle_b_second_guess * triangle_a) < abs(             target - best_product         ):             best_product = triangle_b_second_guess * triangle_a             area = idx_a * b_ceil      return area\n2: def is_harshad_number_in_base(num: int, base: int) -> bool:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      if num < 0:         return False      n = int_to_base(num, base)     d = sum_of_digits(num, base)     return int(n, base) % int(d, base) == 0", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef longest_common_prefix(iterables):\n    return (c[0] for c in takewhile(all_equal, zip(*iterables)))", "output": "Yield elements of the longest common prefix among given *iterables*."}
{"task": "summary", "input": "summarize code:\ndef solution(first_x_coord: float = 1.4, first_y_coord: float = -9.6) -> int:\n    num_reflections: int = 0\n    point_x: float = first_x_coord\n    point_y: float = first_y_coord\n    gradient: float = (10.1 - point_y) / (0.0 - point_x)\n\n    while not (-0.01 <= point_x <= 0.01 and point_y > 0):\n        point_x, point_y, gradient = next_point(point_x, point_y, gradient)\n        num_reflections += 1\n\n    return num_reflections", "output": "Return the number of times that the beam hits the interior wall of the"}
{"task": "summary", "input": "summarize code:\ndef _flatten_tensor(tensor):\n    \"Depth-first iterator over scalars in a tensor.\"\n    iterator = iter(tensor)\n    while True:\n        try:\n            value = next(iterator)\n        except StopIteration:\n            return iterator\n        iterator = chain((value,), iterator)\n        if _is_scalar(value):\n            return iterator\n        iterator = chain.from_iterable(iterator)", "output": "Depth-first iterator over scalars in a tensor."}
{"task": "summary", "input": "summarize code:\ndef convex_hull_recursive(points: list[Point]) -> list[Point]:\n    points = sorted(_validate_input(points))\n    n = len(points)\n\n    # divide all the points into an upper hull and a lower hull\n    # the left most point and the right most point are definitely\n    # members of the convex hull by definition.\n    # use these two anchors to divide all the points into two hulls,\n    # an upper hull and a lower hull.\n\n    # all points to the left (above) the line joining the extreme points belong to the\n    # upper hull\n    # all points to the right (below) the line joining the extreme points below to the\n    # lower hull\n    # ignore all points on the line joining the extreme points since they cannot be\n    # part of the convex hull\n\n    left_most_point = points[0]\n    right_most_point = points[n - 1]\n\n    convex_set = {left_most_point, right_most_point}\n    upper_hull = []\n    lower_hull = []\n\n    for i in range(1, n - 1):\n        det = _det(left_most_point, right_most_point, points[i])\n\n        if det > 0:\n            upper_hull.append(points[i])\n        elif det < 0:\n            lower_hull.append(points[i])\n\n    _construct_hull(upper_hull, left_most_point, right_most_point, convex_set)\n    _construct_hull(lower_hull, right_most_point, left_most_point, convex_set)\n\n    return sorted(convex_set)", "output": "Constructs the convex hull of a set of 2D points using a divide-and-conquer strategy"}
{"task": "detection", "input": "classify code:\ndef max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit", "output": "BUGGY"}
{"task": "search", "input": "search code:\nComputes the solution to the problem up to the specified limit\n\nChoices:\n0: def array_equalization(vector: list[int], step_size: int) -> int:     if step_size <= 0:         raise ValueError(\"Step size must be positive and non-zero.\")     if not isinstance(step_size, int):         raise ValueError(\"Step size must be an integer.\")      unique_elements = set(vector)     min_updates = maxsize      for element in unique_elements:         elem_index = 0         updates = 0         while elem_index < len(vector):             if vector[elem_index] != element:                 updates += 1                 elem_index += step_size             else:                 elem_index += 1         min_updates = min(min_updates, updates)      return min_updates\n1: def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:     right = right or len(list_data) - 1     if left > right:         return -1     elif list_data[left] == key:         return left     elif list_data[right] == key:         return right     else:         return search(list_data, key, left + 1, right - 1)\n2: def solution(limit: int = 999_966_663_333) -> int:     primes_upper_bound = math.floor(math.sqrt(limit)) + 100     primes = prime_sieve(primes_upper_bound)      matches_sum = 0     prime_index = 0     last_prime = primes[prime_index]      while (last_prime**2) <= limit:         next_prime = primes[prime_index + 1]          lower_bound = last_prime**2         upper_bound = next_prime**2          # Get numbers divisible by lps(current)         current = lower_bound + last_prime         while upper_bound > current <= limit:             matches_sum += current             current += last_prime          # Reset the upper_bound         while (upper_bound - next_prime) > limit:             upper_bound -= next_prime          # Add the numbers divisible by ups(current)         current = upper_bound - next_prime         while current > lower_bound:             matches_sum += current             current -= next_prime          # Remove the numbers divisible by both ups and lps         current = 0         while upper_bound > current <= limit:             if current <= lower_bound:                 # Increment the current number                 current += last_prime * next_prime                 continue              if current > limit:                 break              # Remove twice since it was added by both ups and lps             matches_sum -= current * 2              # Increment the current number             current += last_prime * next_prime          # Setup for next pair         last_prime = next_prime         prime_index += 1      return matches_sum", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to volume.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_volume(0.82, 3, 300)\n      90\n      >>> moles_to_volume(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (pressure)))", "output": "def moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to volume.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_volume(0.82, 3, 300)\n      90\n      >>> moles_to_volume(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (pressure)))"}
{"task": "summary", "input": "summarize code:\ndef geometric_mean(series: list) -> float:\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 1\n    for value in series:\n        answer *= value\n    return pow(answer, 1 / len(series))", "output": "return the geometric mean of series"}
{"task": "summary", "input": "summarize code:\ndef benchmark() -> None:\n\n    def do_benchmark(number: int) -> None:\n        setup = \"import __main__ as z\"\n        print(f\"Benchmark when {number = }:\")\n        print(f\"{get_set_bits_count_using_modulo_operator(number) = }\")\n        timing = timeit(\n            f\"z.get_set_bits_count_using_modulo_operator({number})\", setup=setup\n        )\n        print(f\"timeit() runs in {timing} seconds\")\n        print(f\"{get_set_bits_count_using_brian_kernighans_algorithm(number) = }\")\n        timing = timeit(\n            f\"z.get_set_bits_count_using_brian_kernighans_algorithm({number})\",\n            setup=setup,\n        )\n        print(f\"timeit() runs in {timing} seconds\")\n\n    for number in (25, 37, 58, 0):\n        do_benchmark(number)\n        print()", "output": "Benchmark code for comparing 2 functions, with different length int values."}
{"task": "search", "input": "search code:\nYield slices of length *n* from the sequence *seq*.\n\nChoices:\n0: def is_palindrome(head: ListNode | None) -> bool:     if not head:         return True     # split the list to two parts     fast: ListNode | None = head.next_node     slow: ListNode | None = head     while fast and fast.next_node:         fast = fast.next_node.next_node         slow = slow.next_node if slow else None     if slow:         # slow will always be defined,         # adding this check to resolve mypy static check         second = slow.next_node         slow.next_node = None  # Don't forget here! But forget still works!     # reverse the second part     node: ListNode | None = None     while second:         nxt = second.next_node         second.next_node = node         node = second         second = nxt     # compare two parts     # second part has the same or one less node     while node and head:         if node.val != head.val:             return False         node = node.next_node         head = head.next_node     return True\n1: def sliced(seq, n, strict=False):     iterator = takewhile(len, (seq[i : i + n] for i in count(0, n)))     if strict:          def ret():             for _slice in iterator:                 if len(_slice) != n:                     raise ValueError(\"seq is not divisible by n.\")                 yield _slice          return ret()     else:         return iterator\n2: def netstring_server_timeout_override(server_socket):      try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock, timeout=0.01)             while 1:                 request = client.read_ns(1)                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'ping':                     client.write_ns(b'pong')     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise", "output": "1"}
{"task": "search", "input": "search code:\nFind all unique triplets in a sorted array of integers that sum up to zero.\n\nChoices:\n0: def three_sum(nums: list[int]) -> list[list[int]]:     nums.sort()     ans = []     for i in range(len(nums) - 2):         if i == 0 or (nums[i] != nums[i - 1]):             low, high, c = i + 1, len(nums) - 1, 0 - nums[i]             while low < high:                 if nums[low] + nums[high] == c:                     ans.append([nums[i], nums[low], nums[high]])                      while low < high and nums[low] == nums[low + 1]:                         low += 1                     while low < high and nums[high] == nums[high - 1]:                         high -= 1                      low += 1                     high -= 1                 elif nums[low] + nums[high] < c:                     low += 1                 else:                     high -= 1     return ans\n1: def compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:      id_ = 0     n = len(graph)  # No of vertices in graph     low = [0] * n     visited = [False] * n      def dfs(at, parent, bridges, id_):         visited[at] = True         low[at] = id_         id_ += 1         for to in graph[at]:             if to == parent:                 pass             elif not visited[to]:                 dfs(to, at, bridges, id_)                 low[at] = min(low[at], low[to])                 if id_ <= low[to]:                     bridges.append((at, to) if at < to else (to, at))             else:                 # This edge is a back edge and cannot be a bridge                 low[at] = min(low[at], low[to])      bridges: list[tuple[int, int]] = []     for i in range(n):         if not visited[i]:             dfs(i, -1, bridges, id_)     return bridges\n2: def is_pangram(     input_str: str = \"The quick brown fox jumps over the lazy dog\", ) -> bool:     # Declare frequency as a set to have unique occurrences of letters     frequency = set()      # Replace all the whitespace in our sentence     input_str = input_str.replace(\" \", \"\")     for alpha in input_str:         if \"a\" <= alpha.lower() <= \"z\":             frequency.add(alpha.lower())     return len(frequency) == 26", "output": "0"}
{"task": "detection", "input": "classify code:\ndef strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef recursive_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Recursive matching algorithm.\n\n    | Time complexity: O(2^(\\|text\\| + \\|pattern\\|))\n    | Space complexity: Recursion depth is O(\\|text\\| + \\|pattern\\|).\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> recursive_match('abc', 'a.c')\n    True\n    >>> recursive_match('abc', 'af*.c')\n    True\n    >>> recursive_match('abc', 'a.c*')\n    True\n    >>> recursive_match('abc', 'a.c*d')\n    False\n    >>> recursive_match('aa', '.*')\n    True\n    \"\"\"\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef collatz_sequence_length(n: int) -> int:\n    if n in COLLATZ_SEQUENCE_LENGTHS:\n        return COLLATZ_SEQUENCE_LENGTHS[n]\n    next_n = n // 2 if n % 2 == 0 else 3 * n + 1\n    sequence_length = collatz_sequence_length(next_n) + 1\n    COLLATZ_SEQUENCE_LENGTHS[n] = sequence_length\n    return sequence_length", "output": "Returns the Collatz sequence length for n."}
{"task": "search", "input": "search code:\nPower Iteration.\n\nChoices:\n0: def solution(length: int = 50) -> int:      different_colour_ways_number = [[0] * 3 for _ in range(length + 1)]      for row_length in range(length + 1):         for tile_length in range(2, 5):             for tile_start in range(row_length - tile_length + 1):                 different_colour_ways_number[row_length][tile_length - 2] += (                     different_colour_ways_number[row_length - tile_start - tile_length][                         tile_length - 2                     ]                     + 1                 )      return sum(different_colour_ways_number[length])\n1: def power_iteration(     input_matrix: np.ndarray,     vector: np.ndarray,     error_tol: float = 1e-12,     max_iterations: int = 100, ) -> tuple[float, np.ndarray]:      # Ensure matrix is square.     assert np.shape(input_matrix)[0] == np.shape(input_matrix)[1]     # Ensure proper dimensionality.     assert np.shape(input_matrix)[0] == np.shape(vector)[0]     # Ensure inputs are either both complex or both real     assert np.iscomplexobj(input_matrix) == np.iscomplexobj(vector)     is_complex = np.iscomplexobj(input_matrix)     if is_complex:         # Ensure complex input_matrix is Hermitian         assert np.array_equal(input_matrix, input_matrix.conj().T)      # Set convergence to False. Will define convergence when we exceed max_iterations     # or when we have small changes from one iteration to next.      convergence = False     lambda_previous = 0     iterations = 0     error = 1e12      while not convergence:         # Multiple matrix by the vector.         w = np.dot(input_matrix, vector)         # Normalize the resulting output vector.         vector = w / np.linalg.norm(w)         # Find rayleigh quotient         # (faster than usual b/c we know vector is normalized already)         vector_h = vector.conj().T if is_complex else vector.T         lambda_ = np.dot(vector_h, np.dot(input_matrix, vector))          # Check convergence.         error = np.abs(lambda_ - lambda_previous) / lambda_         iterations += 1          if error <= error_tol or iterations >= max_iterations:             convergence = True          lambda_previous = lambda_      if is_complex:         lambda_ = np.real(lambda_)      return float(lambda_), vector\n2: def windowed_complete(iterable, n):     if n < 0:         raise ValueError('n must be >= 0')      seq = tuple(iterable)     size = len(seq)      if n > size:         raise ValueError('n must be <= len(seq)')      for i in range(size - n + 1):         beginning = seq[:i]         middle = seq[i : i + n]         end = seq[i + n :]         yield beginning, middle, end", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef cramers_rule_2x2(equation1: list[int], equation2: list[int]) -> tuple[float, float]:\n\n    # Check if the input is valid\n    if not len(equation1) == len(equation2) == 3:\n        raise ValueError(\"Please enter a valid equation.\")\n    if equation1[0] == equation1[1] == equation2[0] == equation2[1] == 0:\n        raise ValueError(\"Both a & b of two equations can't be zero.\")\n\n    # Extract the coefficients\n    a1, b1, c1 = equation1\n    a2, b2, c2 = equation2\n\n    # Calculate the determinants of the matrices\n    determinant = a1 * b2 - a2 * b1\n    determinant_x = c1 * b2 - c2 * b1\n    determinant_y = a1 * c2 - a2 * c1\n\n    # Check if the system of linear equations has a solution (using Cramer's rule)\n    if determinant == 0:\n        if determinant_x == determinant_y == 0:\n            raise ValueError(\"Infinite solutions. (Consistent system)\")\n        else:\n            raise ValueError(\"No solution. (Inconsistent system)\")\n    elif determinant_x == determinant_y == 0:\n        # Trivial solution (Inconsistent system)\n        return (0.0, 0.0)\n    else:\n        x = determinant_x / determinant\n        y = determinant_y / determinant\n        # Non-Trivial Solution (Consistent system)\n        return (x, y)", "output": "Solves the system of linear equation in 2 variables."}
{"task": "detection", "input": "classify code:\ndef minor(matrix: list[list], row: int, column: int) -> list[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nImplementation of ElfHash Algorithm, a variant of PJW hash function.\n\nChoices:\n0: def count_inversions_bf(arr):      num_inversions = 0     n = len(arr)      for i in range(n - 1):         for j in range(i + 1, n):             if arr[i] > arr[j]:                 num_inversions += 1      return num_inversions\n1: def elf_hash(data: str) -> int:     hash_ = x = 0     for letter in data:         hash_ = (hash_ << 4) + ord(letter)         x = hash_ & 0xF0000000         if x != 0:             hash_ ^= x >> 24         hash_ &= ~x     return hash_\n2: def is_hermitian(matrix: np.ndarray) -> bool:     return np.array_equal(matrix, matrix.conjugate().T)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef postorder(curr_node: Node | None) -> list[Node]:\n    node_list = []\n    if curr_node is not None:\n        node_list = postorder(curr_node.left) + postorder(curr_node.right) + [curr_node]\n    return node_list", "output": "postOrder (left, right, self)"}
{"task": "detection", "input": "classify code:\ndef is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nWrap an iterable in a ``with`` statement, so it closes once exhausted.\n\nChoices:\n0: def luhn_validation(credit_card_number: str) -> bool:     cc_number = credit_card_number     total = 0     half_len = len(cc_number) - 2     for i in range(half_len, -1, -2):         #  double the value of every second digit         digit = int(cc_number[i])         digit *= 2         # If doubling of a number results in a two digit number         # i.e greater than 9(e.g., 6 x 2 = 12),         # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),         # to get a single digit number.         if digit > 9:             digit %= 10             digit += 1         cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]         total += digit      # Sum up the remaining digits     for i in range(len(cc_number) - 1, -1, -2):         total += int(cc_number[i])      return total % 10 == 0\n1: def with_iter(context_manager):     with context_manager as iterable:         yield from iterable\n2: def electrical_impedance(     resistance: float, reactance: float, impedance: float ) -> dict[str, float]:     if (resistance, reactance, impedance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance == 0:         return {\"resistance\": sqrt(pow(impedance, 2) - pow(reactance, 2))}     elif reactance == 0:         return {\"reactance\": sqrt(pow(impedance, 2) - pow(resistance, 2))}     elif impedance == 0:         return {\"impedance\": sqrt(pow(resistance, 2) + pow(reactance, 2))}     else:         raise ValueError(\"Exactly one argument must be 0\")", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef floyd(n):\n    result = \"\"\n    for i in range(n):\n        for _ in range(n - i - 1):  # printing spaces\n            result += \" \"\n        for _ in range(i + 1):  # printing stars\n            result += \"* \"\n        result += \"\\n\"\n    return result", "output": "Print the upper half of a diamond pattern with '*' characters."}
{"task": "search", "input": "search code:\nPure implementation of generating the first solution for the Tabu search to start,\n\nChoices:\n0: def patience_sort(collection: list) -> list:     stacks: list[Stack] = []     # sort into stacks     for element in collection:         new_stacks = Stack([element])         i = bisect_left(stacks, new_stacks)         if i != len(stacks):             stacks[i].append(element)         else:             stacks.append(new_stacks)      # use a heap-based merge to merge stack efficiently     collection[:] = merge(*(reversed(stack) for stack in stacks))     return collection\n1: def closing_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:     if kernel is None:         kernel = np.ones((3, 3))     return transform(transform(image, \"erosion\", kernel), \"dilation\", kernel)\n2: def generate_first_solution(path, dict_of_neighbours):      with open(path) as f:         start_node = f.read(1)     end_node = start_node      first_solution = []      visiting = start_node      distance_of_first_solution = 0     while visiting not in first_solution:         minim = 10000         for k in dict_of_neighbours[visiting]:             if int(k[1]) < int(minim) and k[0] not in first_solution:                 minim = k[1]                 best_node = k[0]          first_solution.append(visiting)         distance_of_first_solution = distance_of_first_solution + int(minim)         visiting = best_node      first_solution.append(end_node)      position = 0     for k in dict_of_neighbours[first_solution[-2]]:         if k[0] == start_node:             break         position += 1      distance_of_first_solution = (         distance_of_first_solution         + int(dict_of_neighbours[first_solution[-2]][position][1])         - 10000     )     return first_solution, distance_of_first_solution", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef term_frequency(term: str, document: str) -> int:\n    # strip all punctuation and newlines and replace it with ''\n    document_without_punctuation = document.translate(\n        str.maketrans(\"\", \"\", string.punctuation)\n    ).replace(\"\\n\", \"\")\n    tokenize_document = document_without_punctuation.split(\" \")  # word tokenization\n    return len([word for word in tokenize_document if word.lower() == term.lower()])", "output": "Return the number of times a term occurs within"}
{"task": "search", "input": "search code:\nWe cannot get the optimal w of our kernel SVM model, which is different from a\n\nChoices:\n0: def get_path(root, path, default=_UNSET):     if isinstance(path, str):         path = path.split('.')     cur = root     try:         for seg in path:             try:                 cur = cur[seg]             except (KeyError, IndexError) as exc:                 raise PathAccessError(exc, seg, path)             except TypeError as exc:                 # either string index in a list, or a parent that                 # doesn't support indexing                 try:                     seg = int(seg)                     cur = cur[seg]                 except (ValueError, KeyError, IndexError, TypeError):                     if not is_iterable(cur):                         exc = TypeError('%r object is not indexable'                                         % type(cur).__name__)                     raise PathAccessError(exc, seg, path)     except PathAccessError:         if default is _UNSET:             raise         return default     return cur\n1: def plot_partition_boundary(     model, train_data, ax, resolution=100, colors=(\"b\", \"k\", \"r\") ):     train_data_x = train_data[:, 1]     train_data_y = train_data[:, 2]     train_data_tags = train_data[:, 0]     xrange = np.linspace(train_data_x.min(), train_data_x.max(), resolution)     yrange = np.linspace(train_data_y.min(), train_data_y.max(), resolution)     test_samples = np.array([(x, y) for x in xrange for y in yrange]).reshape(         resolution * resolution, 2     )      test_tags = model.predict(test_samples, classify=False)     grid = test_tags.reshape((len(xrange), len(yrange)))      # Plot contour map which represents the partition boundary     ax.contour(         xrange,         yrange,         np.asmatrix(grid).T,         levels=(-1, 0, 1),         linestyles=(\"--\", \"-\", \"--\"),         linewidths=(1, 1, 1),         colors=colors,     )     # Plot all train samples     ax.scatter(         train_data_x,         train_data_y,         c=train_data_tags,         cmap=plt.cm.Dark2,         lw=0,         alpha=0.5,     )      # Plot support vectors     support = model.support     ax.scatter(         train_data_x[support],         train_data_y[support],         c=train_data_tags[support],         cmap=plt.cm.Dark2,     )\n2: def not_32(i: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")      i_str = format(i, \"032b\")     new_str = \"\"     for c in i_str:         new_str += \"1\" if c == \"0\" else \"0\"     return int(new_str, 2)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef num_digits_faster(n: int) -> int:\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))", "output": "Find the number of digits in a number."}
{"task": "summary", "input": "summarize code:\ndef nth_combination(iterable, r, index):\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = 1\n    k = min(r, n - r)\n    for i in range(1, k + 1):\n        c = c * (n - k + i) // i\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    while r:\n        c, n, r = c * r // n, n - 1, r - 1\n        while index >= c:\n            index -= c\n            c, n = c * (n - r) // n, n - 1\n        result.append(pool[-1 - n])\n\n    return tuple(result)", "output": "Equivalent to ``list(combinations(iterable, r))[index]``."}
{"task": "summary", "input": "summarize code:\ndef remove_duplicates(sentence: str) -> str:\n    return \" \".join(sorted(set(sentence.split())))", "output": "Remove duplicates from sentence"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 100) -> int:\n\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i**2\n        sum_of_ints += i\n    return sum_of_ints**2 - sum_of_squares", "output": "Returns the difference between the sum of the squares of the first n"}
{"task": "summary", "input": "summarize code:\ndef min_path_sum(grid: list) -> int:\n\n    if not grid or not grid[0]:\n        raise TypeError(\"The grid does not contain the appropriate information\")\n\n    for cell_n in range(1, len(grid[0])):\n        grid[0][cell_n] += grid[0][cell_n - 1]\n    row_above = grid[0]\n\n    for row_n in range(1, len(grid)):\n        current_row = grid[row_n]\n        grid[row_n] = fill_row(current_row, row_above)\n        row_above = grid[row_n]\n\n    return grid[-1][-1]", "output": "Find the path from top left to bottom right of array of numbers"}
{"task": "summary", "input": "summarize code:\ndef rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)", "output": "A pure Python implementation of a recursive linear search algorithm"}
{"task": "repair", "input": "fix bug:\ndef fletcher16(text: str) -> int:\n    \"\"\"\n    Loop through every character in the data and add to two sums.\n\n    >>> fletcher16('hello world')\n    6752\n    >>> fletcher16('onethousandfourhundredthirtyfour')\n    28347\n    >>> fletcher16('The quick brown fox jumps over the lazy dog.')\n    5655\n    \"\"\"\n    data = bytes(text, \"ascii\")\n    sum1 = 0\n    sum2 = 0\n    for character in data:\n        sum1 = (sum1 + character) % 255\n        sum2 = (sum1 + sum2) % 255\n    return (sum2 << 8) | sum1", "output": "def fletcher16(text: str) -> int:\n    \"\"\"\n    Loop through every character in the data and add to two sums.\n\n    >>> fletcher16('hello world')\n    6752\n    >>> fletcher16('onethousandfourhundredthirtyfour')\n    28347\n    >>> fletcher16('The quick brown fox jumps over the lazy dog.')\n    5655\n    \"\"\"\n    data = bytes(text, \"ascii\")\n    sum1 = 0\n    sum2 = 0\n    for character in data:\n        sum1 = (sum1 + character) % 255\n        sum2 = (sum1 + sum2) % 255\n    return (sum2 << 8) | sum1"}
{"task": "search", "input": "search code:\nCalculate AND of a list of input values\n\nChoices:\n0: def n_input_and_gate(inputs: list[int]) -> int:     return int(all(inputs))\n1: def solution(n: int = 15) -> int:     total = 0     for m in range(2, n + 1):         x1 = 2 / (m + 1)         p = 1.0         for i in range(1, m + 1):             xi = i * x1             p *= xi**i         total += int(p)     return total\n2: def narcissistic_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False     expo = len(str(n))  # the power that all digits will be raised to     # check if sum of each digit multiplied expo times is equal to number     return n == sum(int(i) ** expo for i in str(n))", "output": "0"}
{"task": "detection", "input": "classify code:\ndef orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    \"\"\"\n    Calculates the work required to move an object from one orbit to another in a\n    gravitational field based on the change in total mechanical energy.\n\n    The formula used is:\n        W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\n    where:\n        W = work done (Joules)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the central body (kg)\n        m = mass of the orbiting object (kg)\n        r_initial = initial orbit radius (m)\n        r_final = final orbit radius (m)\n\n    Args:\n        mass_central (float): Mass of the central body (kg)\n        mass_object (float): Mass of the object being moved (kg)\n        r_initial (float): Initial orbital radius (m)\n        r_final (float): Final orbital radius (m)\n\n    Returns:\n        str: Work done in Joules as a string in scientific notation (3 decimals)\n\n    Examples:\n        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n        '2.811e+09'\n        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n        '-1.405e+09'\n        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n        '1.514e+11'\n    \"\"\"\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\"", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef _construct_solution(dp: list, wt: list, i: int, j: int, optimal_set: set):\n    # for the current item i at a maximum weight j to be part of an optimal subset,\n    # the optimal value at (i, j) must be greater than the optimal value at (i-1, j).\n    # where i - 1 means considering only the previous items at the given maximum weight\n    if i > 0 and j > 0:\n        if dp[i - 1][j] == dp[i][j]:\n            _construct_solution(dp, wt, i - 1, j, optimal_set)\n        else:\n            optimal_set.add(i)\n            _construct_solution(dp, wt, i - 1, j - wt[i - 1], optimal_set)", "output": "Recursively reconstructs one of the optimal subsets given"}
{"task": "summary", "input": "summarize code:\ndef integer_square_root(num: int) -> int:\n    if not isinstance(num, int) or num < 0:\n        raise ValueError(\"num must be non-negative integer\")\n\n    if num < 2:\n        return num\n\n    left_bound = 0\n    right_bound = num // 2\n\n    while left_bound <= right_bound:\n        mid = left_bound + (right_bound - left_bound) // 2\n        mid_squared = mid * mid\n        if mid_squared == num:\n            return mid\n\n        if mid_squared < num:\n            left_bound = mid + 1\n        else:\n            right_bound = mid - 1\n\n    return right_bound", "output": "Returns the integer square root of a non-negative integer num."}
{"task": "search", "input": "search code:\nEquivalent to ``list(combinations(iterable, r)).index(element)``\n\nChoices:\n0: def get_filter_points(     sample_rate: int,     freq_min: int,     freq_high: int,     mel_filter_num: int = 10,     ftt_size: int = 1024, ) -> tuple[np.ndarray, np.ndarray]:     # Convert minimum and maximum frequencies to mel scale     fmin_mel = freq_to_mel(freq_min)     fmax_mel = freq_to_mel(freq_high)      logging.info(f\"MEL min: {fmin_mel}\")     logging.info(f\"MEL max: {fmax_mel}\")      # Generate equally spaced mel frequencies     mels = np.linspace(fmin_mel, fmax_mel, num=mel_filter_num + 2)      # Convert mel frequencies back to Hertz     freqs = mel_to_freq(mels)      # Calculate filter points as integer values     filter_points = np.floor((ftt_size + 1) / sample_rate * freqs).astype(int)      return filter_points, freqs\n1: def hill_climbing(     search_prob,     find_max: bool = True,     max_x: float = math.inf,     min_x: float = -math.inf,     max_y: float = math.inf,     min_y: float = -math.inf,     visualization: bool = False,     max_iter: int = 10000, ) -> SearchProblem:     current_state = search_prob     scores = []  # list to store the current score at each iteration     iterations = 0     solution_found = False     visited = set()     while not solution_found and iterations < max_iter:         visited.add(current_state)         iterations += 1         current_score = current_state.score()         scores.append(current_score)         neighbors = current_state.get_neighbors()         max_change = -math.inf         min_change = math.inf         next_state = None  # to hold the next best neighbor         for neighbor in neighbors:             if neighbor in visited:                 continue  # do not want to visit the same state again             if (                 neighbor.x > max_x                 or neighbor.x < min_x                 or neighbor.y > max_y                 or neighbor.y < min_y             ):                 continue  # neighbor outside our bounds             change = neighbor.score() - current_score             if find_max:  # finding max                 # going to direction with greatest ascent                 if change > max_change and change > 0:                     max_change = change                     next_state = neighbor             elif change < min_change and change < 0:  # finding min                 # to direction with greatest descent                 min_change = change                 next_state = neighbor         if next_state is not None:             # we found at least one neighbor which improved the current state             current_state = next_state         else:             # since we have no neighbor that improves the solution we stop the search             solution_found = True      if visualization:         from matplotlib import pyplot as plt          plt.plot(range(iterations), scores)         plt.xlabel(\"Iterations\")         plt.ylabel(\"Function values\")         plt.show()      return current_state\n2: def combination_index(element, iterable):     element = enumerate(element)     k, y = next(element, (None, None))     if k is None:         return 0      indexes = []     pool = enumerate(iterable)     for n, x in pool:         if x == y:             indexes.append(n)             tmp, y = next(element, (None, None))             if tmp is None:                 break             else:                 k = tmp     else:         raise ValueError('element is not a combination of iterable')      n, _ = last(pool, default=(n, None))      index = 1     for i, j in enumerate(reversed(indexes), start=1):         j = n - j         if i <= j:             index += comb(j, i)      return comb(n + 1, k + 1) - index", "output": "2"}
{"task": "detection", "input": "classify code:\ndef approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef is_magic_gon(numbers: list[int]) -> bool:\n    if len(numbers) % 3 != 0:\n        raise ValueError(\"a gon ring should have a length that is a multiple of 3\")\n\n    if min(numbers[::3]) != numbers[0]:\n        return False\n\n    total = sum(numbers[:3])\n\n    return all(sum(numbers[i : i + 3]) == total for i in range(3, len(numbers), 3))", "output": "Check if the solution set is a magic n-gon ring"}
{"task": "summary", "input": "summarize code:\ndef triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:\n    for triplet in permutations(arr, 3):\n        if sum(triplet) == target:\n            return tuple(sorted(triplet))\n    return (0, 0, 0)", "output": "Returns a triplet in the array with sum equal to target,"}
{"task": "detection", "input": "classify code:\ndef get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2", "output": "BUGGY"}
{"task": "search", "input": "search code:\nNormalize the URL path by resolving segments of '.' and '..',\n\nChoices:\n0: def minimax(     depth: int, node_index: int, is_max: bool, scores: list[int], height: float ) -> int:      if depth < 0:         raise ValueError(\"Depth cannot be less than 0\")     if len(scores) == 0:         raise ValueError(\"Scores cannot be empty\")      # Base case: If the current depth equals the height of the tree,     # return the score of the current node.     if depth == height:         return scores[node_index]      # If it's the maximizer's turn, choose the maximum score     # between the two possible moves.     if is_max:         return max(             minimax(depth + 1, node_index * 2, False, scores, height),             minimax(depth + 1, node_index * 2 + 1, False, scores, height),         )      # If it's the minimizer's turn, choose the minimum score     # between the two possible moves.     return min(         minimax(depth + 1, node_index * 2, True, scores, height),         minimax(depth + 1, node_index * 2 + 1, True, scores, height),     )\n1: def convex_hull_bf(points: list[Point]) -> list[Point]:      points = sorted(_validate_input(points))     n = len(points)     convex_set = set()      for i in range(n - 1):         for j in range(i + 1, n):             points_left_of_ij = points_right_of_ij = False             ij_part_of_convex_hull = True             for k in range(n):                 if k not in {i, j}:                     det_k = _det(points[i], points[j], points[k])                      if det_k > 0:                         points_left_of_ij = True                     elif det_k < 0:                         points_right_of_ij = True                     # point[i], point[j], point[k] all lie on a straight line                     # if point[k] is to the left of point[i] or it's to the                     # right of point[j], then point[i], point[j] cannot be                     # part of the convex hull of A                     elif points[k] < points[i] or points[k] > points[j]:                         ij_part_of_convex_hull = False                         break                  if points_left_of_ij and points_right_of_ij:                     ij_part_of_convex_hull = False                     break              if ij_part_of_convex_hull:                 convex_set.update([points[i], points[j]])      return sorted(convex_set)\n2: def resolve_path_parts(path_parts):     # TODO: what to do with multiple slashes     ret = []      for part in path_parts:         if part == '.':             pass         elif part == '..':             if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting                 ret.pop()         else:             ret.append(part)      if list(path_parts[-1:]) in (['.'], ['..']):         ret.append('')      return ret", "output": "2"}
{"task": "search", "input": "search code:\nReturn the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi\n\nChoices:\n0: def find_winner(num_people: int, step_size: int) -> int:     return josephus_recursive(num_people, step_size) + 1\n1: def compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:      id_ = 0     n = len(graph)  # No of vertices in graph     low = [0] * n     visited = [False] * n      def dfs(at, parent, bridges, id_):         visited[at] = True         low[at] = id_         id_ += 1         for to in graph[at]:             if to == parent:                 pass             elif not visited[to]:                 dfs(to, at, bridges, id_)                 low[at] = min(low[at], low[to])                 if id_ <= low[to]:                     bridges.append((at, to) if at < to else (to, at))             else:                 # This edge is a back edge and cannot be a bridge                 low[at] = min(low[at], low[to])      bridges: list[tuple[int, int]] = []     for i in range(n):         if not visited[i]:             dfs(i, -1, bridges, id_)     return bridges\n2: def fibonacci_generator() -> Generator[int]:     a, b = 0, 1     while True:         a, b = b, a + b         yield b", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef _complex_sumprod(v1, v2):\n\n    real = attrgetter('real')\n    imag = attrgetter('imag')\n    r1 = chain(map(real, v1), map(neg, map(imag, v1)))\n    r2 = chain(map(real, v2), map(imag, v2))\n    i1 = chain(map(real, v1), map(imag, v1))\n    i2 = chain(map(imag, v2), map(real, v2))\n    return complex(_fsumprod(r1, r2), _fsumprod(i1, i2))", "output": "High precision sumprod() for complex numbers."}
{"task": "summary", "input": "summarize code:\ndef split_at(iterable, pred, maxsplit=-1, keep_separator=False):\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item):\n            yield buf\n            if keep_separator:\n                yield [item]\n            if maxsplit == 1:\n                yield list(it)\n                return\n            buf = []\n            maxsplit -= 1\n        else:\n            buf.append(item)\n    yield buf", "output": "Yield lists of items from *iterable*, where each list is delimited by"}
{"task": "search", "input": "search code:\nGet images list and annotations list from input dir.\n\nChoices:\n0: def main() -> None:     img_paths, annos = get_dataset(LABEL_DIR, IMG_DIR)     for index in range(NUMBER_IMAGES):         idxs = random.sample(range(len(annos)), 4)         new_image, new_annos, path = update_image_and_anno(             img_paths,             annos,             idxs,             OUTPUT_SIZE,             SCALE_RANGE,             filter_scale=FILTER_TINY_SCALE,         )          # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'         letter_code = random_chars(32)         file_name = path.split(os.sep)[-1].rsplit(\".\", 1)[0]         file_root = f\"{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}\"         cv2.imwrite(f\"{file_root}.jpg\", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])         print(f\"Succeeded {index + 1}/{NUMBER_IMAGES} with {file_name}\")         annos_list = []         for anno in new_annos:             width = anno[3] - anno[1]             height = anno[4] - anno[2]             x_center = anno[1] + width / 2             y_center = anno[2] + height / 2             obj = f\"{anno[0]} {x_center} {y_center} {width} {height}\"             annos_list.append(obj)         with open(f\"{file_root}.txt\", \"w\") as outfile:             outfile.write(\"\\n\".join(line for line in annos_list))\n1: def partitions(iterable):     sequence = list(iterable)     n = len(sequence)     for i in powerset(range(1, n)):         yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]\n2: def counting_sort(collection):     # if the collection is empty, returns empty     if collection == []:         return []      # get some information about the collection     coll_len = len(collection)     coll_max = max(collection)     coll_min = min(collection)      # create the counting array     counting_arr_length = coll_max + 1 - coll_min     counting_arr = [0] * counting_arr_length      # count how much a number appears in the collection     for number in collection:         counting_arr[number - coll_min] += 1      # sum each position with it's predecessors. now, counting_arr[i] tells     # us how many elements <= i has in the collection     for i in range(1, counting_arr_length):         counting_arr[i] = counting_arr[i] + counting_arr[i - 1]      # create the output collection     ordered = [0] * coll_len      # place the elements in the output, respecting the original order (stable     # sort) from end to begin, updating counting_arr     for i in reversed(range(coll_len)):         ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]         counting_arr[collection[i] - coll_min] -= 1      return ordered", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:\n\n    game_matrix = [list(row) for row in matrix]\n    total_score = 0\n\n    for move in moves:\n        pos_x, pos_y = move\n        game_matrix, score = play(game_matrix, pos_x, pos_y, size)\n        total_score += score\n\n    return total_score", "output": "Processes the game logic for the given matrix and moves."}
{"task": "summary", "input": "summarize code:\ndef gaussian_elimination(\n    coefficients: NDArray[float64], vector: NDArray[float64]\n) -> NDArray[float64]:\n    # coefficients must to be a square matrix so we need to check first\n    rows, columns = np.shape(coefficients)\n    if rows != columns:\n        return np.array((), dtype=float)\n\n    # augmented matrix\n    augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)\n    augmented_mat = augmented_mat.astype(\"float64\")\n\n    # scale the matrix leaving it triangular\n    for row in range(rows - 1):\n        pivot = augmented_mat[row, row]\n        for col in range(row + 1, columns):\n            factor = augmented_mat[col, row] / pivot\n            augmented_mat[col, :] -= factor * augmented_mat[row, :]\n\n    x = retroactive_resolution(\n        augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]\n    )\n\n    return x", "output": "This function performs Gaussian elimination method"}
{"task": "summary", "input": "summarize code:\ndef add(first: int, second: int) -> int:\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first", "output": "Implementation of addition of integer"}
{"task": "summary", "input": "summarize code:\ndef ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:\n    if (voltage, current, resistance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if resistance < 0:\n        raise ValueError(\"Resistance cannot be negative\")\n    if voltage == 0:\n        return {\"voltage\": float(current * resistance)}\n    elif current == 0:\n        return {\"current\": voltage / resistance}\n    elif resistance == 0:\n        return {\"resistance\": voltage / current}\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")", "output": "Apply Ohm's Law, on any two given electrical values, which can be voltage, current,"}
{"task": "search", "input": "search code:\nFunction to luhn algorithm validation for a given credit card number.\n\nChoices:\n0: def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:     r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]     return 0.2989 * r + 0.5870 * g + 0.1140 * b\n1: def get_factors(     number: int, factors: Counter | None = None, factor: int = 2 ) -> Counter:      match number:         case int(number) if number == 1:             return Counter({1: 1})         case int(num) if number > 0:             number = num         case _:             raise TypeError(\"number must be integer and greater than zero\")      factors = factors or Counter()      if number == factor:  # break condition         # all numbers are factors of itself         factors[factor] += 1         return factors      if number % factor > 0:         # if it is greater than zero         # so it is not a factor of number and we check next number         return get_factors(number, factors, factor + 1)      factors[factor] += 1     # else we update factors (that is Counter(dict-like) type) and check again     return get_factors(number // factor, factors, factor)\n2: def luhn_validation(credit_card_number: str) -> bool:     cc_number = credit_card_number     total = 0     half_len = len(cc_number) - 2     for i in range(half_len, -1, -2):         #  double the value of every second digit         digit = int(cc_number[i])         digit *= 2         # If doubling of a number results in a two digit number         # i.e greater than 9(e.g., 6 x 2 = 12),         # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),         # to get a single digit number.         if digit > 9:             digit %= 10             digit += 1         cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]         total += digit      # Sum up the remaining digits     for i in range(len(cc_number) - 1, -1, -2):         total += int(cc_number[i])      return total % 10 == 0", "output": "2"}
{"task": "search", "input": "search code:\nDetermines if num is in the form 1_2_3_4_5_6_7_8_9\n\nChoices:\n0: def is_square_form(num: int) -> bool:     digit = 9      while num > 0:         if num % 10 != digit:             return False         num //= 100         digit -= 1      return True\n1: def strip_iter(iterable, strip_value=None):     return rstrip_iter(lstrip_iter(iterable, strip_value), strip_value)\n2: def write_file_binary(file_path: str, to_write: str) -> None:     byte_length = 8     try:         with open(file_path, \"wb\") as opened_file:             result_byte_array = [                 to_write[i : i + byte_length]                 for i in range(0, len(to_write), byte_length)             ]              if len(result_byte_array[-1]) % byte_length == 0:                 result_byte_array.append(\"10000000\")             else:                 result_byte_array[-1] += \"1\" + \"0\" * (                     byte_length - len(result_byte_array[-1]) - 1                 )              for elem in result_byte_array[:-1]:                 opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))     except OSError:         print(\"File not accessible\")         sys.exit()", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(a: int = 100, b: int = 100) -> int:\n\n    # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of\n    # BASE raised to the POWER\n    return max(\n        sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)\n    )", "output": "Considering natural numbers of the form, a**b, where a, b < 100,"}
{"task": "search", "input": "search code:\nReturns prime numbers below max_number\n\nChoices:\n0: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def get_rotation(     img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int ) -> np.ndarray:     matrix = cv2.getAffineTransform(pt1, pt2)     return cv2.warpAffine(img, matrix, (rows, cols))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef largest_rectangle_area(heights: list[int]) -> int:\n    stack: list[int] = []\n    max_area = 0\n    heights = [*heights, 0]  # make a new list by appending the sentinel 0\n    n = len(heights)\n\n    for i in range(n):\n        # make sure the stack remains in increasing order\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]  # height of the bar\n            # if stack is empty, it means entire width can be taken from index 0 to i-1\n            w = i if not stack else i - stack[-1] - 1  # calculate width\n            max_area = max(max_area, h * w)\n\n        stack.append(i)\n\n    return max_area", "output": "Inputs an array of integers representing the heights of bars,"}
{"task": "summary", "input": "summarize code:\ndef benchmark_levenshtein_distance(func: Callable) -> None:\n    from timeit import timeit\n\n    stmt = f\"{func.__name__}('sitting', 'kitten')\"\n    setup = f\"from __main__ import {func.__name__}\"\n    number = 25_000\n    result = timeit(stmt=stmt, setup=setup, number=number)\n    print(f\"{func.__name__:<30} finished {number:,} runs in {result:.5f} seconds\")", "output": "Benchmark the Levenshtein distance function."}
{"task": "summary", "input": "summarize code:\ndef pairwise_iter(src, end=_UNSET):\n    return windowed_iter(src, 2, fill=end)", "output": "Convenience function for calling :func:`windowed_iter` on *src*,"}
{"task": "summary", "input": "summarize code:\ndef xor_gate(input_1: int, input_2: int) -> int:\n    return (input_1, input_2).count(0) % 2", "output": "calculate xor of the input values"}
{"task": "summary", "input": "summarize code:\ndef relu(vector: list[float]):\n\n    # compare two arrays and then return element-wise maxima.\n    return np.maximum(0, vector)", "output": "Implements the relu function"}
{"task": "summary", "input": "summarize code:\ndef msd_radix_sort(list_of_ints: list[int]) -> list[int]:\n    if not list_of_ints:\n        return []\n\n    if min(list_of_ints) < 0:\n        raise ValueError(\"All numbers must be positive\")\n\n    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)\n    return _msd_radix_sort(list_of_ints, most_bits)", "output": "Implementation of the MSD radix sort algorithm. Only works"}
{"task": "search", "input": "search code:\nFind binomial coefficient using Pascal's triangle.\n\nChoices:\n0: def solution(n: int = 20) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     i = 0     while 1:         i += n * (n - 1)         nfound = 0         for j in range(2, n):             if i % j != 0:                 nfound = 1                 break         if nfound == 0:             if i == 0:                 i = 1             return i     return None\n1: def binomial_coefficient(n: int, r: int) -> int:     if n < 0 or r < 0:         raise ValueError(\"n and r must be non-negative integers\")     if 0 in (n, r):         return 1     c = [0 for i in range(r + 1)]     # nc0 = 1     c[0] = 1     for i in range(1, n + 1):         # to compute current row from previous row.         j = min(i, r)         while j > 0:             c[j] += c[j - 1]             j -= 1     return c[r]\n2: def longest_palindromic_subsequence(input_string: str) -> int:     n = len(input_string)     rev = input_string[::-1]     m = len(rev)     dp = [[-1] * (m + 1) for i in range(n + 1)]     for i in range(n + 1):         dp[i][0] = 0     for i in range(m + 1):         dp[0][i] = 0      # create and initialise dp array     for i in range(1, n + 1):         for j in range(1, m + 1):             # If characters at i and j are the same             # include them in the palindromic subsequence             if input_string[i - 1] == rev[j - 1]:                 dp[i][j] = 1 + dp[i - 1][j - 1]             else:                 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])      return dp[n][m]", "output": "1"}
{"task": "search", "input": "search code:\nfind different DFS walk from given node to Header node\n\nChoices:\n0: def rstrip_iter(iterable, strip_value=None):     iterator = iter(iterable)     for i in iterator:         if i == strip_value:             cache = list()             cache.append(i)             broken = False             for i in iterator:                 if i == strip_value:                     cache.append(i)                 else:                     broken = True                     break             if not broken:  # Return to caller here because the end of the                 return     # iterator has been reached             yield from cache         yield i\n1: def build_sparse_table(number_list: list[int]) -> list[list[int]]:     if not number_list:         raise ValueError(\"empty number list not allowed\")      length = len(number_list)     # Initialise sparse_table -- sparse_table[j][i] represents the minimum value of the     # subset of length (2 ** j) of number_list, starting from index i.      # smallest power of 2 subset length that fully covers number_list     row = int(log2(length)) + 1     sparse_table = [[0 for i in range(length)] for j in range(row)]      # minimum of subset of length 1 is that value itself     for i, value in enumerate(number_list):         sparse_table[0][i] = value     j = 1      # compute the minimum value for all intervals with size (2 ** j)     while (1 << j) <= length:         i = 0         # while subset starting from i still have at least (2 ** j) elements         while (i + (1 << j) - 1) < length:             # split range [i, i + 2 ** j] and find minimum of 2 halves             sparse_table[j][i] = min(                 sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]             )             i += 1         j += 1     return sparse_table\n2: def my_dfs(graph, start, end, path=None):     path = (path or []) + [start]     if start == end:         paths.append(path)     for node in graph[start]:         if tuple(node) not in path:             my_dfs(graph, tuple(node), end, path)", "output": "2"}
{"task": "search", "input": "search code:\nReturns probability that Pyramidal Peter beats Cubic Colin\n\nChoices:\n0: def compute_pairwise_affinities(data_matrix: ndarray, sigma: float = 1.0) -> ndarray:     n_samples = data_matrix.shape[0]     squared_sum = np.sum(np.square(data_matrix), axis=1)     squared_distance = np.add(         np.add(-2 * np.dot(data_matrix, data_matrix.T), squared_sum).T, squared_sum     )      affinity_matrix = np.exp(-squared_distance / (2 * sigma**2))     np.fill_diagonal(affinity_matrix, 0)      affinity_matrix /= np.sum(affinity_matrix)     return (affinity_matrix + affinity_matrix.T) / (2 * n_samples)\n1: def abs_val(num: float) -> float:     return -num if num < 0 else num\n2: def solution() -> float:      peter_totals_frequencies = total_frequency_distribution(         sides_number=4, dice_number=9     )     colin_totals_frequencies = total_frequency_distribution(         sides_number=6, dice_number=6     )      peter_wins_count = 0     min_peter_total = 9     max_peter_total = 4 * 9     min_colin_total = 6     for peter_total in range(min_peter_total, max_peter_total + 1):         peter_wins_count += peter_totals_frequencies[peter_total] * sum(             colin_totals_frequencies[min_colin_total:peter_total]         )      total_games_number = (4**9) * (6**6)     peter_win_probability = peter_wins_count / total_games_number      rounded_peter_win_probability = round(peter_win_probability, ndigits=7)      return rounded_peter_win_probability", "output": "2"}
{"task": "detection", "input": "classify code:\ndef generate_parentheses_iterative(length: int) -> list:\n    \"\"\"\n    Generate all valid combinations of parentheses (Iterative Approach).\n\n    The algorithm works as follows:\n    1. Initialize an empty list to store the combinations.\n    2. Initialize a stack to keep track of partial combinations.\n    3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n    4. While the stack is not empty:\n        a. Pop a partial combination and its open and close counts from the stack.\n        b. If the combination length is equal to 2*length, add it to the result.\n        c. If open count < length, push new combination with added '(' on stack.\n        d. If close count < open count, push new combination with added ')' on stack.\n    5. Return the result containing all valid combinations.\n\n    Args:\n        length: The desired length of the parentheses combinations\n\n    Returns:\n        A list of strings representing valid combinations of parentheses\n\n    Time Complexity:\n        O(2^(2*length))\n\n    Space Complexity:\n        O(2^(2*length))\n\n    >>> generate_parentheses_iterative(3)\n    ['()()()', '()(())', '(())()', '(()())', '((()))']\n    >>> generate_parentheses_iterative(2)\n    ['()()', '(())']\n    >>> generate_parentheses_iterative(1)\n    ['()']\n    >>> generate_parentheses_iterative(0)\n    ['']\n    \"\"\"\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(max_base: int = 5) -> int:\n    freqs = defaultdict(list)\n    num = 0\n\n    while True:\n        digits = get_digits(num)\n        freqs[digits].append(num)\n\n        if len(freqs[digits]) == max_base:\n            base = freqs[digits][0] ** 3\n            return base\n\n        num += 1", "output": "Iterate through every possible cube and sort the cube's digits in"}
{"task": "search", "input": "search code:\nBuild the highway following the parameters given\n\nChoices:\n0: def contains_an_even_digit(n: int) -> bool:     return any(digit in \"02468\" for digit in str(n))\n1: def find_triplets_with_0_sum_hashing(arr: list[int]) -> list[list[int]]:     target_sum = 0      # Initialize the final output array with blank.     output_arr = []      # Set the initial element as arr[i].     for index, item in enumerate(arr[:-2]):         # to store second elements that can complement the final sum.         set_initialize = set()          # current sum needed for reaching the target sum         current_sum = target_sum - item          # Traverse the subarray arr[i+1:].         for other_item in arr[index + 1 :]:             # required value for the second element             required_value = current_sum - other_item              # Verify if the desired value exists in the set.             if required_value in set_initialize:                 # finding triplet elements combination.                 combination_array = sorted([item, other_item, required_value])                 if combination_array not in output_arr:                     output_arr.append(combination_array)              # Include the current element in the set             # for subsequent complement verification.             set_initialize.add(other_item)      # Return all the triplet combinations.     return output_arr\n2: def construct_highway(     number_of_cells: int,     frequency: int,     initial_speed: int,     random_frequency: bool = False,     random_speed: bool = False,     max_speed: int = 5, ) -> list:      highway = [[-1] * number_of_cells]  # Create a highway without any car     i = 0     initial_speed = max(initial_speed, 0)     while i < number_of_cells:         highway[0][i] = (             randint(0, max_speed) if random_speed else initial_speed         )  # Place the cars         i += (             randint(1, max_speed * 2) if random_frequency else frequency         )  # Arbitrary number, may need tuning     return highway", "output": "2"}
{"task": "search", "input": "search code:\nInvoke *func* on each item in *iterable* (or on each *chunk_size* group\n\nChoices:\n0: def zigzag(root: Node | None) -> Generator[int]:     if root is None:         return      flag = 0     height_tree = height(root)      for h in range(1, height_tree + 1):         if not flag:             yield from get_nodes_from_left_to_right(root, h)             flag = 1         else:             yield from get_nodes_from_right_to_left(root, h)             flag = 0\n1: def compress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         add_key_to_lexicon(lexicon, curr_string, index, last_match_id)         index += 1         curr_string = \"\"      while curr_string != \"\" and curr_string not in lexicon:         curr_string += \"0\"      if curr_string != \"\":         last_match_id = lexicon[curr_string]         result += last_match_id      return result\n2: def side_effect(func, iterable, chunk_size=None, before=None, after=None):     try:         if before is not None:             before()          if chunk_size is None:             for item in iterable:                 func(item)                 yield item         else:             for chunk in chunked(iterable, chunk_size):                 func(chunk)                 yield from chunk     finally:         if after is not None:             after()", "output": "2"}
{"task": "search", "input": "search code:\nEliminate all the other values (except d) from values[s] and propagate.\n\nChoices:\n0: def solution(num_terms: int = 60, max_start: int = 1000000) -> int:     return sum(1 for i in range(1, max_start) if chain_length(i) == num_terms)\n1: def norm_squared(vector: ndarray) -> float:     return np.dot(vector, vector)\n2: def assign(values, s, d):     other_values = values[s].replace(d, \"\")     if all(eliminate(values, s, d2) for d2 in other_values):         return values     else:         return False", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef local_weight(\n    point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float\n) -> np.ndarray:\n    weight_mat = weight_matrix(point, x_train, tau)\n    weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (\n        x_train.T @ weight_mat @ y_train.T\n    )\n\n    return weight", "output": "Calculate the local weights at a given prediction point using the weight"}
{"task": "summary", "input": "summarize code:\ndef summarize_book(ol_book_data: dict) -> dict:\n    desired_keys = {\n        \"title\": \"Title\",\n        \"publish_date\": \"Publish date\",\n        \"authors\": \"Authors\",\n        \"number_of_pages\": \"Number of pages\",\n        \"isbn_10\": \"ISBN (10)\",\n        \"isbn_13\": \"ISBN (13)\",\n    }\n    data = {better_key: ol_book_data[key] for key, better_key in desired_keys.items()}\n    data[\"Authors\"] = [\n        get_openlibrary_data(author[\"key\"])[\"name\"] for author in data[\"Authors\"]\n    ]\n    for key, value in data.items():\n        if isinstance(value, list):\n            data[key] = \", \".join(value)\n    return data", "output": "Given Open Library book data, return a summary as a Python dict."}
{"task": "detection", "input": "classify code:\ndef selection(chart: List[List[int]], prime_implicants: List[str]) -> List[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0", "output": "BUGGY"}
{"task": "search", "input": "search code:\nThe trapped_rainwater function calculates the total amount of rainwater that can be\n\nChoices:\n0: def solution(n: int = 51) -> int:     unique_coefficients = get_pascal_triangle_unique_coefficients(n)     squarefrees = get_squarefrees(unique_coefficients)     return sum(squarefrees)\n1: def merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:     if tree1 is None:         return tree2     if tree2 is None:         return tree1      tree1.value = tree1.value + tree2.value     tree1.left = merge_two_binary_trees(tree1.left, tree2.left)     tree1.right = merge_two_binary_trees(tree1.right, tree2.right)     return tree1\n2: def trapped_rainwater(heights: tuple[int, ...]) -> int:     if not heights:         return 0     if any(h < 0 for h in heights):         raise ValueError(\"No height can be negative\")     length = len(heights)      left_max = [0] * length     left_max[0] = heights[0]     for i, height in enumerate(heights[1:], start=1):         left_max[i] = max(height, left_max[i - 1])      right_max = [0] * length     right_max[-1] = heights[-1]     for i in range(length - 2, -1, -1):         right_max[i] = max(heights[i], right_max[i + 1])      return sum(         min(left, right) - height         for left, right, height in zip(left_max, right_max, heights)     )", "output": "2"}
{"task": "search", "input": "search code:\nComparing local neighborhood pixel value with threshold value of centre pixel.\n\nChoices:\n0: def is_prime(number: int) -> bool:      return all(number % divisor != 0 for divisor in range(2, isqrt(number) + 1))\n1: def get_neighbors_pixel(     image: np.ndarray, x_coordinate: int, y_coordinate: int, center: int ) -> int:      try:         return int(image[x_coordinate][y_coordinate] >= center)     except (IndexError, TypeError):         return 0\n2: def create_all_state(     increment: int,     total_number: int,     level: int,     current_list: list[int],     total_list: list[list[int]], ) -> None:     if level == 0:         total_list.append(current_list[:])         return      for i in range(increment, total_number - level + 2):         current_list.append(i)         create_all_state(i + 1, total_number, level - 1, current_list, total_list)         current_list.pop()", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef lstrip(iterable, strip_value=None):\n    return list(lstrip_iter(iterable, strip_value))", "output": "Strips values from the beginning of an iterable. Stripped items will"}
{"task": "search", "input": "search code:\nA pure Python implementation of a fibonacci search algorithm.\n\nChoices:\n0: def create_cipher_map(key: str) -> dict[str, str]:     # Create a list of the letters in the alphabet     alphabet = [chr(i + 65) for i in range(26)]     # Remove duplicate characters from key     key = remove_duplicates(key.upper())     offset = len(key)     # First fill cipher with key characters     cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}     # Then map remaining characters in alphabet to     # the alphabet from the beginning     for i in range(len(cipher_alphabet), 26):         char = alphabet[i - offset]         # Ensure we are not mapping letters to letters previously mapped         while char in key:             offset -= 1             char = alphabet[i - offset]         cipher_alphabet[alphabet[i]] = char     return cipher_alphabet\n1: def fibonacci_search(arr: list, val: int) -> int:     len_list = len(arr)     # Find m such that F_m >= n where F_i is the i_th fibonacci number.     i = 0     while True:         if fibonacci(i) >= len_list:             fibb_k = i             break         i += 1     offset = 0     while fibb_k > 0:         index_k = min(             offset + fibonacci(fibb_k - 1), len_list - 1         )  # Prevent out of range         item_k_1 = arr[index_k]         if item_k_1 == val:             return index_k         elif val < item_k_1:             fibb_k -= 1         elif val > item_k_1:             offset += fibonacci(fibb_k - 1)             fibb_k -= 2     return -1\n2: def erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:     output = np.zeros_like(image)     image_padded = np.zeros(         (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)     )      # Copy image to padded image     image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image      # Iterate over image & apply kernel     for x in range(image.shape[1]):         for y in range(image.shape[0]):             summation = (                 kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]             ).sum()             output[y, x] = int(summation == 5)     return output", "output": "1"}
{"task": "detection", "input": "classify code:\ndef sum_of_harmonic_progression(\n    first_term: float, common_difference: float, number_of_terms: int\n) -> float:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)\n\n    Find the sum of n terms in an harmonic progression.  The calculation starts with the\n    first_term and loops adding the common difference of Arithmetic Progression by which\n    the given Harmonic Progression is linked.\n\n    >>> sum_of_harmonic_progression(1 / 2, 2, 2)\n    0.75\n    >>> sum_of_harmonic_progression(1 / 5, 5, 5)\n    0.45666666666666667\n    \"\"\"\n    arithmetic_progression = [1 / first_term]\n    first_term = 1 / first_term\n    for _ in range(number_of_terms - 1):\n        first_term += common_difference\n        arithmetic_progression.append(first_term)\n    harmonic_series = [1 / step for step in arithmetic_progression]\n    return sum(harmonic_series)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the modular exponentiation, that is the value\n\nChoices:\n0: def encode(word: str) -> str:     encoded = \"\"     for letter in word.lower():         if letter.isalpha() or letter == \" \":             encoded += encode_dict[letter]         else:             raise Exception(\"encode() accepts only letters of the alphabet and spaces\")     return encoded\n1: def _modexpt(base: int, exponent: int, modulo_value: int) -> int:      if exponent == 1:         return base     if exponent % 2 == 0:         x = _modexpt(base, exponent // 2, modulo_value) % modulo_value         return (x * x) % modulo_value     else:         return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value\n2: def naturaldate(value) -> str:     try:         value = dt.date(value.year, value.month, value.day)     except AttributeError:         # Passed value wasn't date-ish         return value     except (OverflowError, ValueError):         # Date arguments out of range         return value     delta = _abs_timedelta(value - dt.date.today())     if delta.days >= 5 * 365 / 12:         return naturalday(value, \"%b %d %Y\")     return naturalday(value)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef rotate_to_the_right(head: Node, places: int) -> Node:\n    # Check if the list is empty or has only one element\n    if not head:\n        raise ValueError(\"The linked list is empty.\")\n\n    if head.next_node is None:\n        return head\n\n    # Calculate the length of the linked list\n    length = 1\n    temp_node = head\n    while temp_node.next_node is not None:\n        length += 1\n        temp_node = temp_node.next_node\n\n    # Adjust the value of places to avoid places longer than the list.\n    places %= length\n\n    if places == 0:\n        return head  # As no rotation is needed.\n\n    # Find the new head position after rotation.\n    new_head_index = length - places\n\n    # Traverse to the new head position\n    temp_node = head\n    for _ in range(new_head_index - 1):\n        assert temp_node.next_node\n        temp_node = temp_node.next_node\n\n    # Update pointers to perform rotation\n    assert temp_node.next_node\n    new_head = temp_node.next_node\n    temp_node.next_node = None\n    temp_node = new_head\n    while temp_node.next_node:\n        temp_node = temp_node.next_node\n    temp_node.next_node = head\n\n    assert new_head\n    return new_head", "output": "Rotate a linked list to the right by places times."}
{"task": "search", "input": "search code:\nChecks if the values can be used for the ``enigma`` function\n\nChoices:\n0: def get_word_pattern(word: str) -> str:     word = word.upper()     next_num = 0     letter_nums = {}     word_pattern = []      for letter in word:         if letter not in letter_nums:             letter_nums[letter] = str(next_num)             next_num += 1         word_pattern.append(letter_nums[letter])     return \".\".join(word_pattern)\n1: def _validator(     rotpos: RotorPositionT, rotsel: RotorSelectionT, pb: str ) -> tuple[RotorPositionT, RotorSelectionT, dict[str, str]]:     # Checks if there are 3 unique rotors      if (unique_rotsel := len(set(rotsel))) < 3:         msg = f\"Please use 3 unique rotors (not {unique_rotsel})\"         raise Exception(msg)      # Checks if rotor positions are valid     rotorpos1, rotorpos2, rotorpos3 = rotpos     if not 0 < rotorpos1 <= len(abc):         msg = f\"First rotor position is not within range of 1..26 ({rotorpos1}\"         raise ValueError(msg)     if not 0 < rotorpos2 <= len(abc):         msg = f\"Second rotor position is not within range of 1..26 ({rotorpos2})\"         raise ValueError(msg)     if not 0 < rotorpos3 <= len(abc):         msg = f\"Third rotor position is not within range of 1..26 ({rotorpos3})\"         raise ValueError(msg)      # Validates string and returns dict     pbdict = _plugboard(pb)      return rotpos, rotsel, pbdict\n2: def sigmoid_derivative(value: np.ndarray) -> np.ndarray:     return (value) * (1 - (value))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef is_palindrome_dict(head: ListNode | None) -> bool:\n    if not head or not head.next_node:\n        return True\n    d: dict[int, list[int]] = {}\n    pos = 0\n    while head:\n        if head.val in d:\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next_node\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            for step, i in enumerate(range(len(v))):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n        if middle > 1:\n            return False\n    return True", "output": "Check if a linked list is a palindrome using a dictionary."}
{"task": "search", "input": "search code:\nThis will check whether a given password is strong or not. The password must be at\n\nChoices:\n0: def is_strong_password(password: str, min_length: int = 8) -> bool:      if len(password) < min_length:         return False      upper = any(char in ascii_uppercase for char in password)     lower = any(char in ascii_lowercase for char in password)     num = any(char in digits for char in password)     spec_char = any(char in punctuation for char in password)      return upper and lower and num and spec_char\n1: def city_select(     pheromone: list[list[float]],     current_city: dict[int, list[int]],     unvisited_cities: dict[int, list[int]],     alpha: float,     beta: float, ) -> tuple[dict[int, list[int]], dict[int, list[int]]]:     probabilities = []     for city, value in unvisited_cities.items():         city_distance = distance(value, next(iter(current_city.values())))         probability = (pheromone[city][next(iter(current_city.keys()))] ** alpha) * (             (1 / city_distance) ** beta         )         probabilities.append(probability)      chosen_city_i = random.choices(         list(unvisited_cities.keys()), weights=probabilities     )[0]     chosen_city = {chosen_city_i: unvisited_cities[chosen_city_i]}     del unvisited_cities[next(iter(chosen_city.keys()))]     return chosen_city, unvisited_cities\n2: def kth_number(lst: list[int], k: int) -> int:     # pick a pivot and separate into list based on pivot.     pivot = random_pivot(lst)      # partition based on pivot     # linear time     small = [e for e in lst if e < pivot]     big = [e for e in lst if e > pivot]      # if we get lucky, pivot might be the element we want.     # we can easily see this:     # small (elements smaller than k)     # + pivot (kth element)     # + big (elements larger than k)     if len(small) == k - 1:         return pivot     # pivot is in elements bigger than k     elif len(small) < k - 1:         return kth_number(big, k - len(small) - 1)     # pivot is in elements smaller than k     else:         return kth_number(small, k)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:\n\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must not be zero.\")\n    delta = b * b - 4 * a * c\n\n    root_1 = (-b + sqrt(delta)) / (2 * a)\n    root_2 = (-b - sqrt(delta)) / (2 * a)\n\n    return (\n        root_1.real if not root_1.imag else root_1,\n        root_2.real if not root_2.imag else root_2,\n    )", "output": "Given the numerical coefficients a, b and c,"}
{"task": "detection", "input": "classify code:\ndef longest_subsequence(array: List[int]) -> List[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef factorial(digit: int) -> int:\n    \"\"\"\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    >>> factorial(5)\n    120\n    \"\"\"\n\n    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns True if graph is cyclic else False\n\nChoices:\n0: def check_cycle(graph: dict) -> bool:     # Keep track of visited nodes     visited: set[int] = set()     # To detect a back edge, keep track of vertices currently in the recursion stack     rec_stk: set[int] = set()     return any(         node not in visited and depth_first_search(graph, node, visited, rec_stk)         for node in graph     )\n1: def solution(n: int = 1000) -> int:      total = 0     num = 0     while 1:         num += 3         if num >= n:             break         total += num         num += 2         if num >= n:             break         total += num         num += 1         if num >= n:             break         total += num         num += 3         if num >= n:             break         total += num         num += 1         if num >= n:             break         total += num         num += 2         if num >= n:             break         total += num         num += 3         if num >= n:             break         total += num     return total\n2: def convert_to_2d(     x: float, y: float, z: float, scale: float, distance: float ) -> tuple[float, float]:     if not all(isinstance(val, (float, int)) for val in locals().values()):         msg = f\"Input values must either be float or int: {list(locals().values())}\"         raise TypeError(msg)     projected_x = ((x * distance) / (z + distance)) * scale     projected_y = ((y * distance) / (z + distance)) * scale     return projected_x, projected_y", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef iterate_function(\n    eval_function: Callable[[Any, np.ndarray], np.ndarray],\n    function_params: Any,\n    nb_iterations: int,\n    z_0: np.ndarray,\n    infinity: float | None = None,\n) -> np.ndarray:\n\n    z_n = z_0.astype(\"complex64\")\n    for _ in range(nb_iterations):\n        z_n = eval_function(function_params, z_n)\n        if infinity is not None:\n            np.nan_to_num(z_n, copy=False, nan=infinity)\n            z_n[abs(z_n) == np.inf] = infinity\n    return z_n", "output": "Iterate the function \"eval_function\" exactly nb_iterations times."}
{"task": "search", "input": "search code:\nFunction updates the largest_square_area, using bottom up\n\nChoices:\n0: def is_palindrome(n: int | str) -> bool:     n = str(n)     return n == n[::-1]\n1: def is_square_form(num: int) -> bool:     digit = 9      while num > 0:         if num % 10 != digit:             return False         num //= 100         digit -= 1      return True\n2: def largest_square_area_in_matrix_bottom_up_space_optimization(     rows: int, cols: int, mat: list[list[int]] ) -> int:     current_row = [0] * (cols + 1)     next_row = [0] * (cols + 1)     largest_square_area = 0     for row in range(rows - 1, -1, -1):         for col in range(cols - 1, -1, -1):             right = current_row[col + 1]             diagonal = next_row[col + 1]             bottom = next_row[col]              if mat[row][col] == 1:                 current_row[col] = 1 + min(right, diagonal, bottom)                 largest_square_area = max(current_row[col], largest_square_area)             else:                 current_row[col] = 0         next_row = current_row      return largest_square_area", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef windowed(seq, n, fillvalue=None, step=1):\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        yield ()\n        return\n    if step < 1:\n        raise ValueError('step must be >= 1')\n\n    iterator = iter(seq)\n\n    # Generate first window\n    window = deque(islice(iterator, n), maxlen=n)\n\n    # Deal with the first window not being full\n    if not window:\n        return\n    if len(window) < n:\n        yield tuple(window) + ((fillvalue,) * (n - len(window)))\n        return\n    yield tuple(window)\n\n    # Create the filler for the next windows. The padding ensures\n    # we have just enough elements to fill the last window.\n    padding = (fillvalue,) * (n - 1 if step >= n else step - 1)\n    filler = map(window.append, chain(iterator, padding))\n\n    # Generate the rest of the windows\n    for _ in islice(filler, step - 1, None, step):\n        yield tuple(window)", "output": "Return a sliding window of width *n* over the given iterable."}
{"task": "summary", "input": "summarize code:\ndef top_k_frequent_words(words: list[str], k_value: int) -> list[str]:\n    heap: Heap[WordCount] = Heap()\n    count_by_word = Counter(words)\n    heap.build_max_heap(\n        [WordCount(word, count) for word, count in count_by_word.items()]\n    )\n    return [heap.extract_max().word for _ in range(min(k_value, len(count_by_word)))]", "output": "Returns the `k_value` most frequently occurring words,"}
{"task": "summary", "input": "summarize code:\ndef longest_subsequence(array: list[int]) -> list[int]:\n    n = len(array)\n    # The longest increasing subsequence ending at array[i]\n    longest_increasing_subsequence = []\n    for i in range(n):\n        longest_increasing_subsequence.append([array[i]])\n\n    for i in range(1, n):\n        for prev in range(i):\n            # If array[prev] is less than or equal to array[i], then\n            # longest_increasing_subsequence[prev] + array[i]\n            # is a valid increasing subsequence\n\n            # longest_increasing_subsequence[i] is only set to\n            # longest_increasing_subsequence[prev] + array[i] if the length is longer.\n\n            if array[prev] <= array[i] and len(\n                longest_increasing_subsequence[prev]\n            ) + 1 > len(longest_increasing_subsequence[i]):\n                longest_increasing_subsequence[i] = copy.copy(\n                    longest_increasing_subsequence[prev]\n                )\n                longest_increasing_subsequence[i].append(array[i])\n\n    result: list[int] = []\n    for i in range(n):\n        if len(longest_increasing_subsequence[i]) > len(result):\n            result = longest_increasing_subsequence[i]\n\n    return result", "output": "Some examples"}
{"task": "summary", "input": "summarize code:\ndef strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]", "output": "Remove leading and trailing characters (whitespace by default) from a string."}
{"task": "summary", "input": "summarize code:\ndef beta(velocity: float) -> float:\n    if velocity > c:\n        raise ValueError(\"Speed must not exceed light speed 299,792,458 [m/s]!\")\n    elif velocity < 1:\n        # Usually the speed should be much higher than 1 (c order of magnitude)\n        raise ValueError(\"Speed must be greater than or equal to 1!\")\n\n    return velocity / c", "output": "Calculates  = v/c, the given velocity as a fraction of c"}
{"task": "summary", "input": "summarize code:\ndef compute_nums(n: int) -> list[int]:\n    if not isinstance(n, int):\n        raise ValueError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be >= 0\")\n\n    list_nums = []\n    for num in range(len(odd_composites)):\n        i = 0\n        while 2 * i * i <= odd_composites[num]:\n            rem = odd_composites[num] - 2 * i * i\n            if is_prime(rem):\n                break\n            i += 1\n        else:\n            list_nums.append(odd_composites[num])\n            if len(list_nums) == n:\n                return list_nums\n\n    return []", "output": "Returns a list of first n odd composite numbers which do"}
{"task": "detection", "input": "classify code:\ndef is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPreprocess the edge array\n\nChoices:\n0: def preprocess(edge_array):     for i in range(len(edge_array)):         for j in range(len(edge_array[i])):             t = edge_array[i][j].split(\"-\")             edge_array[i][j] = t\n1: def tf_idf(tf: int, idf: int) -> float:     return round(tf * idf, 3)\n2: def maximum_non_adjacent_sum(nums: list[int]) -> int:     if not nums:         return 0     max_including = nums[0]     max_excluding = 0     for num in nums[1:]:         max_including, max_excluding = (             max_excluding + num,             max(max_including, max_excluding),         )     return max(max_excluding, max_including)", "output": "0"}
{"task": "search", "input": "search code:\nAlternative recursive implementation\n\nChoices:\n0: def evaluate_recursive(expression: list[str]):      op = expression.pop(0)     if is_operand(op):         return int(op)      operation = operators[op]      a = evaluate_recursive(expression)     b = evaluate_recursive(expression)     return operation(a, b)\n1: def show_results(     function_label: str,     function_params: Any,     escape_radius: float,     z_final: np.ndarray, ) -> None:      abs_z_final = (abs(z_final)).transpose()     abs_z_final[:, :] = abs_z_final[::-1, :]     plt.matshow(abs_z_final < escape_radius)     plt.title(f\"Julia set of ${function_label}$, $c={function_params}$\")     plt.show()\n2: def collapse(iterable, base_type=None, levels=None):     stack = deque()     # Add our first node group, treat the iterable as a single node     stack.appendleft((0, repeat(iterable, 1)))      while stack:         node_group = stack.popleft()         level, nodes = node_group          # Check if beyond max level         if levels is not None and level > levels:             yield from nodes             continue          for node in nodes:             # Check if done iterating             if isinstance(node, (str, bytes)) or (                 (base_type is not None) and isinstance(node, base_type)             ):                 yield node             # Otherwise try to create child nodes             else:                 try:                     tree = iter(node)                 except TypeError:                     yield node                 else:                     # Save our current location                     stack.appendleft(node_group)                     # Append the new child node                     stack.appendleft((level + 1, tree))                     # Break to process child node                     break", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef combination_with_replacement_index(element, iterable):\n    element = tuple(element)\n    l = len(element)\n    element = enumerate(element)\n\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = tuple(iterable)\n    for n, x in enumerate(pool):\n        while x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n        if y is None:\n            break\n    else:\n        raise ValueError(\n            'element is not a combination with replacement of iterable'\n        )\n\n    n = len(pool)\n    occupations = [0] * n\n    for p in indexes:\n        occupations[p] += 1\n\n    index = 0\n    cumulative_sum = 0\n    for k in range(1, n):\n        cumulative_sum += occupations[k - 1]\n        j = l + n - 1 - k - cumulative_sum\n        i = n - k\n        if i <= j:\n            index += comb(j, i)\n\n    return index", "output": "Equivalent to"}
{"task": "summary", "input": "summarize code:\ndef inspect_formatargspec(\n        args, varargs=None, varkw=None, defaults=None,\n        kwonlyargs=(), kwonlydefaults={}, annotations={},\n        formatarg=str,\n        formatvarargs=lambda name: '*' + name,\n        formatvarkw=lambda name: '**' + name,\n        formatvalue=lambda value: '=' + repr(value),\n        formatreturns=lambda text: ' -> ' + text,\n        formatannotation=formatannotation):\n\n    def formatargandannotation(arg):\n        result = formatarg(arg)\n        if arg in annotations:\n            result += ': ' + formatannotation(annotations[arg])\n        return result\n    specs = []\n    if defaults:\n        firstdefault = len(args) - len(defaults)\n    for i, arg in enumerate(args):\n        spec = formatargandannotation(arg)\n        if defaults and i >= firstdefault:\n            spec = spec + formatvalue(defaults[i - firstdefault])\n        specs.append(spec)\n    if varargs is not None:\n        specs.append(formatvarargs(formatargandannotation(varargs)))\n    else:\n        if kwonlyargs:\n            specs.append('*')\n    if kwonlyargs:\n        for kwonlyarg in kwonlyargs:\n            spec = formatargandannotation(kwonlyarg)\n            if kwonlydefaults and kwonlyarg in kwonlydefaults:\n                spec += formatvalue(kwonlydefaults[kwonlyarg])\n            specs.append(spec)\n    if varkw is not None:\n        specs.append(formatvarkw(formatargandannotation(varkw)))\n    result = '(' + ', '.join(specs) + ')'\n    if 'return' in annotations:\n        result += formatreturns(formatannotation(annotations['return']))\n    return result", "output": "Copy formatargspec from python 3.7 standard library."}
{"task": "summary", "input": "summarize code:\ndef gauss_easter(year: int) -> datetime:\n    metonic_cycle = year % 19\n    julian_leap_year = year % 4\n    non_leap_year = year % 7\n    leap_day_inhibits = math.floor(year / 100)\n    lunar_orbit_correction = math.floor((13 + 8 * leap_day_inhibits) / 25)\n    leap_day_reinstall_number = leap_day_inhibits / 4\n    secular_moon_shift = (\n        15 - lunar_orbit_correction + leap_day_inhibits - leap_day_reinstall_number\n    ) % 30\n    century_starting_point = (4 + leap_day_inhibits - leap_day_reinstall_number) % 7\n\n    # days to be added to March 21\n    days_to_add = (19 * metonic_cycle + secular_moon_shift) % 30\n\n    # PHM -> Paschal Full Moon\n    days_from_phm_to_sunday = (\n        2 * julian_leap_year\n        + 4 * non_leap_year\n        + 6 * days_to_add\n        + century_starting_point\n    ) % 7\n\n    if days_to_add == 29 and days_from_phm_to_sunday == 6:\n        return datetime(year, 4, 19, tzinfo=UTC)\n    elif days_to_add == 28 and days_from_phm_to_sunday == 6:\n        return datetime(year, 4, 18, tzinfo=UTC)\n    else:\n        return datetime(year, 3, 22, tzinfo=UTC) + timedelta(\n            days=int(days_to_add + days_from_phm_to_sunday)\n        )", "output": "Calculation Gregorian easter date for given year"}
{"task": "search", "input": "search code:\nCalculate inductive reactance, frequency or inductance from two given electrical\n\nChoices:\n0: def find_components(     reversed_graph: dict[int, list[int]], vert: int, visited: list[bool] ) -> list[int]:      visited[vert] = True     component = [vert]      for neighbour in reversed_graph[vert]:         if not visited[neighbour]:             component += find_components(reversed_graph, neighbour, visited)      return component\n1: def ind_reactance(     inductance: float, frequency: float, reactance: float ) -> dict[str, float]:      if (inductance, frequency, reactance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if inductance < 0:         raise ValueError(\"Inductance cannot be negative\")     if frequency < 0:         raise ValueError(\"Frequency cannot be negative\")     if reactance < 0:         raise ValueError(\"Inductive reactance cannot be negative\")     if inductance == 0:         return {\"inductance\": reactance / (2 * pi * frequency)}     elif frequency == 0:         return {\"frequency\": reactance / (2 * pi * inductance)}     elif reactance == 0:         return {\"reactance\": 2 * pi * frequency * inductance}     else:         raise ValueError(\"Exactly one argument must be 0\")\n2: def lstrip(iterable, strip_value=None):     return list(lstrip_iter(iterable, strip_value))", "output": "1"}
{"task": "search", "input": "search code:\nPerform traceback to find the optimal local alignment.\n\nChoices:\n0: def unique(iterable, key=None, reverse=False):     sequenced = sorted(iterable, key=key, reverse=reverse)     return unique_justseen(sequenced, key=key)\n1: def traceback(score: list[list[int]], query: str, subject: str) -> str:     # make both query and subject uppercase     query = query.upper()     subject = subject.upper()     # find the indices of the maximum value in the score matrix     max_value = float(\"-inf\")     i_max = j_max = 0     for i, row in enumerate(score):         for j, value in enumerate(row):             if value > max_value:                 max_value = value                 i_max, j_max = i, j     # Traceback logic to find optimal alignment     i = i_max     j = j_max     align1 = \"\"     align2 = \"\"     gap = score_function(\"-\", \"-\")     # guard against empty query or subject     if i == 0 or j == 0:         return \"\"     while i > 0 and j > 0:         if score[i][j] == score[i - 1][j - 1] + score_function(             query[i - 1], subject[j - 1]         ):             # optimal path is a diagonal take both letters             align1 = query[i - 1] + align1             align2 = subject[j - 1] + align2             i -= 1             j -= 1         elif score[i][j] == score[i - 1][j] + gap:             # optimal path is a vertical             align1 = query[i - 1] + align1             align2 = f\"-{align2}\"             i -= 1         else:             # optimal path is a horizontal             align1 = f\"-{align1}\"             align2 = subject[j - 1] + align2             j -= 1      return f\"{align1}\\n{align2}\"\n2: def choose(n: int, r: int) -> int:     ret = 1.0     for i in range(1, r + 1):         ret *= (n + 1 - i) / i     return round(ret)", "output": "1"}
{"task": "search", "input": "search code:\nReturns the total of all the name scores in the file.\n\nChoices:\n0: def maclaurin_cos(theta: float, accuracy: int = 30) -> float:      if not isinstance(theta, (int, float)):         raise ValueError(\"maclaurin_cos() requires either an int or float for theta\")      if not isinstance(accuracy, int) or accuracy <= 0:         raise ValueError(\"maclaurin_cos() requires a positive int for accuracy\")      theta = float(theta)     div = theta // (2 * pi)     theta -= 2 * div * pi     return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))\n1: def calculate_waiting_times(duration_times: list[int]) -> list[int]:     waiting_times = [0] * len(duration_times)     for i in range(1, len(duration_times)):         waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]     return waiting_times\n2: def solution():     total_sum = 0     temp_sum = 0     with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:         name = str(file.readlines()[0])         name = name.replace('\"', \"\").split(\",\")      name.sort()     for i in range(len(name)):         for j in name[i]:             temp_sum += ord(j) - ord(\"A\") + 1         total_sum += (i + 1) * temp_sum         temp_sum = 0     return total_sum", "output": "2"}
{"task": "search", "input": "search code:\nA basic netstring server loop, supporting a few operations\n\nChoices:\n0: def netstring_server(server_socket):     \"A basic netstring server loop, supporting a few operations\"     try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock)             while 1:                 request = client.read_ns()                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'reply4k':                     client.write_ns(b'a' * 4096)                 elif request == b'ping':                     client.write_ns(b'pong')                 elif request == b'reply128k':                     client.setmaxsize(128 * 1024)                     client.write_ns(b'huge' * 32 * 1024)  # 128kb                     client.setmaxsize(32768)  # back to default     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise\n1: def next_number(number: int) -> int:      sum_of_digits_squared = 0     while number:         # Increased Speed Slightly by checking every 5 digits together.         sum_of_digits_squared += DIGITS_SQUARED[number % 100000]         number //= 100000      return sum_of_digits_squared\n2: def rotate_array(arr: list[int], steps: int) -> list[int]:      n = len(arr)     if n == 0:         return arr      steps = steps % n      if steps < 0:         steps += n      def reverse(start: int, end: int) -> None:          while start < end:             arr[start], arr[end] = arr[end], arr[start]             start += 1             end -= 1      reverse(0, n - 1)     reverse(0, steps - 1)     reverse(steps, n - 1)      return arr", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef insert_node(head: Node | None, data: int) -> Node:\n    new_node = Node(data)\n    # If the linked list is empty, the new_node becomes the head\n    if head is None:\n        return new_node\n\n    temp_node = head\n    while temp_node.next_node:\n        temp_node = temp_node.next_node\n\n    temp_node.next_node = new_node\n    return head", "output": "Insert a new node at the end of a linked list and return the new head."}
{"task": "search", "input": "search code:\nReturns the first true value in the iterable.\n\nChoices:\n0: def running_key_decrypt(key: str, ciphertext: str) -> str:     ciphertext = ciphertext.replace(\" \", \"\").upper()     key = key.replace(\" \", \"\").upper()     key_length = len(key)     plaintext = []     ord_a = ord(\"A\")      for i, char in enumerate(ciphertext):         c = ord(char) - ord_a         k = ord(key[i % key_length]) - ord_a         p = (c - k) % 26         plaintext.append(chr(p + ord_a))      return \"\".join(plaintext)\n1: def solution(num: int = 100) -> int:     return sum(int(x) for x in str(factorial(num)))\n2: def first_true(iterable, default=None, pred=None):     return next(filter(pred, iterable), default)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef check1(number: int) -> bool:\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f", "output": "Takes a number and checks if it is pandigital from END"}
{"task": "summary", "input": "summarize code:\ndef benchmark() -> None:\n    from collections.abc import Callable\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        print(f\"{call}: {func(value)} -- {timing} seconds\")\n\n    for value in (262144, 1125899906842624, 1267650600228229401496703205376):\n        for func in (num_digits, num_digits_fast, num_digits_faster):\n            benchmark_a_function(func, value)\n        print()", "output": "Benchmark multiple functions, with three different length int values."}
{"task": "search", "input": "search code:\nConsidering natural numbers of the form, a**b, where a, b < 100,\n\nChoices:\n0: def solution(n: int = 1000) -> int:     return sum(2 * a * ((a - 1) // 2) for a in range(3, n + 1))\n1: def solution(a: int = 100, b: int = 100) -> int:      # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of     # BASE raised to the POWER     return max(         sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)     )\n2: def remove_prefix(data_bits: str) -> str:     counter = 0     for letter in data_bits:         if letter == \"1\":             break         counter += 1      data_bits = data_bits[counter:]     data_bits = data_bits[counter + 1 :]     return data_bits", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(nth: int = 10001) -> int:\n    return next(itertools.islice(prime_generator(), nth - 1, nth))", "output": "Returns the n-th prime number."}
{"task": "search", "input": "search code:\nCounts the number of inversions using a divide-and-conquer algorithm\n\nChoices:\n0: def count_inversions_recursive(arr):     if len(arr) <= 1:         return arr, 0     mid = len(arr) // 2     p = arr[0:mid]     q = arr[mid:]      a, inversion_p = count_inversions_recursive(p)     b, inversions_q = count_inversions_recursive(q)     c, cross_inversions = _count_cross_inversions(a, b)      num_inversions = inversion_p + inversions_q + cross_inversions     return c, num_inversions\n1: def union_set(x: Node, y: Node) -> None:     x, y = find_set(x), find_set(y)     if x == y:         return      elif x.rank > y.rank:         y.parent = x     else:         x.parent = y         if x.rank == y.rank:             y.rank += 1\n2: def some(seq):     for e in seq:         if e:             return e     return False", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    \"\"\"\n    digits = 0\n    while n > 0:\n        n = n // 10\n        digits += 1\n    return digits", "output": "def num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    >>> num_digits(0)\n    1\n    >>> num_digits(-1)\n    1\n    >>> num_digits(-123456)\n    6\n    \"\"\"\n    digits = 0\n    n = abs(n)\n    while True:\n        n = n // 10\n        digits += 1\n        if n == 0:\n            break\n    return digits"}
{"task": "detection", "input": "classify code:\ndef get_check_digit(barcode: int) -> int:\n    \"\"\"\n    Returns the last digit of barcode by excluding the last digit first\n    and then computing to reach the actual last digit from the remaining\n    12 digits.\n\n    >>> get_check_digit(8718452538119)\n    9\n    >>> get_check_digit(87184523)\n    5\n    >>> get_check_digit(87193425381086)\n    9\n    >>> [get_check_digit(x) for x in range(0, 100, 10)]\n    [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]\n    \"\"\"\n    barcode //= 10  # exclude the last digit\n    checker = False\n    s = 0\n\n    # extract and check each digit\n    while barcode != 0:\n        mult = 1 if checker else 3\n        s += mult * (barcode % 10)\n        barcode //= 10\n        checker = not checker\n\n    return (10 - (s % 10)) % 10", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set", "output": "def simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set"}
{"task": "detection", "input": "classify code:\ndef is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReverse in-order traversal visits right subtree, root node, left subtree.\n\nChoices:\n0: def count_vowels(s: str) -> int:     if not isinstance(s, str):         raise ValueError(\"Input must be a string\")      vowels = \"aeiouAEIOU\"     return sum(1 for char in s if char in vowels)\n1: def triangular_number(position: int) -> int:     if position < 0:         raise ValueError(\"param `position` must be non-negative\")      return position * (position + 1) // 2\n2: def reverse_inorder(root: Node | None) -> Generator[int]:     if not root:         return     yield from reverse_inorder(root.right)     yield root.data     yield from reverse_inorder(root.left)", "output": "2"}
{"task": "search", "input": "search code:\nVersion with one liner\n\nChoices:\n0: def union_set(x: Node, y: Node) -> None:     x, y = find_set(x), find_set(y)     if x == y:         return      elif x.rank > y.rank:         y.parent = x     else:         x.parent = y         if x.rank == y.rank:             y.rank += 1\n1: def manhattan_distance_one_liner(point_a: list, point_b: list) -> float:      _validate_point(point_a)     _validate_point(point_b)     if len(point_a) != len(point_b):         raise ValueError(\"Both points must be in the same n-dimensional space\")      return float(sum(abs(x - y) for x, y in zip(point_a, point_b)))\n2: def find_unit_clauses(     clauses: list[Clause],     model: dict[str, bool | None],  # noqa: ARG001 ) -> tuple[list[str], dict[str, bool | None]]:     unit_symbols = []     for clause in clauses:         if len(clause) == 1:             unit_symbols.append(next(iter(clause.literals.keys())))         else:             f_count, n_count = 0, 0             for literal, value in clause.literals.items():                 if value is False:                     f_count += 1                 elif value is None:                     sym = literal                     n_count += 1             if f_count == len(clause) - 1 and n_count == 1:                 unit_symbols.append(sym)     assignment: dict[str, bool | None] = {}     for i in unit_symbols:         symbol = i[:2]         assignment[symbol] = len(i) == 2     unit_symbols = [i[:2] for i in unit_symbols]      return unit_symbols, assignment", "output": "1"}
{"task": "detection", "input": "classify code:\ndef _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\n    Args:\n        total_elements (int): The total number of elements.\n        elements_to_choose (int): The number of elements to choose.\n\n    Returns:\n        int: The binomial coefficient C(total_elements, elements_to_choose).\n\n    Examples:\n    >>> _binomial_coefficient(5, 2)\n    10\n    >>> _binomial_coefficient(6, 3)\n    20\n    \"\"\"\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient", "output": "BUGGY"}
{"task": "search", "input": "search code:\nBuilds a KD-Tree from a list of points.\n\nChoices:\n0: def build_kdtree(points: list[list[float]], depth: int = 0) -> KDNode | None:     if not points:         return None      k = len(points[0])  # Dimensionality of the points     axis = depth % k      # Sort point list and choose median as pivot element     points.sort(key=lambda point: point[axis])     median_idx = len(points) // 2      # Create node and construct subtrees     left_points = points[:median_idx]     right_points = points[median_idx + 1 :]      return KDNode(         point=points[median_idx],         left=build_kdtree(left_points, depth + 1),         right=build_kdtree(right_points, depth + 1),     )\n1: def normalize(audio: np.ndarray) -> np.ndarray:     # Divide the entire audio signal by the maximum absolute value     return audio / np.max(np.abs(audio))\n2: def circle_bottom_arc_integral(point: float) -> float:      return (         (1 - 2 * point) * sqrt(point - point**2) + 2 * point + asin(sqrt(1 - point))     ) / 4", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef get_gas_stations(\n    gas_quantities: list[int], costs: list[int]\n) -> tuple[GasStation, ...]:\n    return tuple(\n        GasStation(quantity, cost) for quantity, cost in zip(gas_quantities, costs)\n    )", "output": "This function returns a tuple of gas stations."}
{"task": "summary", "input": "summarize code:\ndef _quotient_and_remainder(value, divisor, unit, minimum_unit, suppress):\n    if unit == minimum_unit:\n        return (value / divisor, 0)\n    elif unit in suppress:\n        return (0, value)\n    else:\n        return divmod(value, divisor)", "output": "Divide `value` by `divisor` returning the quotient and remainder."}
{"task": "summary", "input": "summarize code:\ndef solution(max_power: int = 9) -> int:\n    result = 0\n    for length in range(1, max_power + 1):\n        result += reversible_numbers(length, 0, [0] * length, length)\n    return result", "output": "To evaluate the solution, use solution()"}
{"task": "search", "input": "search code:\nInsert element\n\nChoices:\n0: def carrier_concentration(     electron_conc: float,     hole_conc: float,     intrinsic_conc: float, ) -> tuple:     if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:         raise ValueError(\"You cannot supply more or less than 2 values\")     elif electron_conc < 0:         raise ValueError(\"Electron concentration cannot be negative in a semiconductor\")     elif hole_conc < 0:         raise ValueError(\"Hole concentration cannot be negative in a semiconductor\")     elif intrinsic_conc < 0:         raise ValueError(             \"Intrinsic concentration cannot be negative in a semiconductor\"         )     elif electron_conc == 0:         return (             \"electron_conc\",             intrinsic_conc**2 / hole_conc,         )     elif hole_conc == 0:         return (             \"hole_conc\",             intrinsic_conc**2 / electron_conc,         )     elif intrinsic_conc == 0:         return (             \"intrinsic_conc\",             (electron_conc * hole_conc) ** 0.5,         )     else:         return (-1, -1)\n1: def insert(root: Node | None, value: int) -> Node | None:     node = Node(value)     left, right = split(root, value)     return merge(merge(left, node), right)\n2: def solution():     file_path = os.path.join(os.path.dirname(__file__), \"num.txt\")     with open(file_path) as file_hand:         return str(sum(int(line) for line in file_hand))[:10]", "output": "1"}
{"task": "detection", "input": "classify code:\ndef format_ruleset(ruleset: int) -> List[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef simple_fibonacci(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    fn_1 = f1\n    fn_2 = f2\n    n -= 2\n\n    while n > 0:\n        fn_1, fn_2 = fn_1 + fn_2, fn_1\n        n -= 1\n\n    return fn_1", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef naturaltime(\n    value,\n    future=False,\n    months=True,\n    minimum_unit=\"seconds\",\n    when=None,\n) -> str:\n    now = when or _now()\n    date, delta = _date_and_delta(value, now=now)\n    if date is None:\n        return value\n    # determine tense by value only if datetime/timedelta were passed\n    if isinstance(value, (dt.datetime, dt.timedelta)):\n        future = date > now\n\n    ago = _(\"%s from now\") if future else _(\"%s ago\")\n    delta = naturaldelta(delta, months, minimum_unit)\n\n    if delta == _(\"a moment\"):\n        return _(\"now\")\n\n    return ago % delta", "output": "Return a natural representation of a time in a resolution that makes sense."}
{"task": "summary", "input": "summarize code:\ndef simplify_kmap(kmap: list[list[int]]) -> str:\n    simplified_f = []\n    for a, row in enumerate(kmap):\n        for b, item in enumerate(row):\n            if item:\n                term = (\"A\" if a else \"A'\") + (\"B\" if b else \"B'\")\n                simplified_f.append(term)\n    return \" + \".join(simplified_f)", "output": "Simplify the Karnaugh map."}
{"task": "summary", "input": "summarize code:\ndef geometric_series(\n    nth_term: float,\n    start_term_a: float,\n    common_ratio_r: float,\n) -> list[float]:\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if not series:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series", "output": "Pure Python implementation of Geometric Series algorithm"}
{"task": "repair", "input": "fix bug:\ndef is_match(string: str, pattern: str) -> bool:\n    \"\"\"\n    >>> is_match(\"\", \"\")\n    True\n    >>> is_match(\"aa\", \"a\")\n    False\n    >>> is_match(\"abc\", \"abc\")\n    True\n    >>> is_match(\"abc\", \"*c\")\n    True\n    >>> is_match(\"abc\", \"a*\")\n    True\n    >>> is_match(\"abc\", \"*a*\")\n    True\n    >>> is_match(\"abc\", \"?b?\")\n    True\n    >>> is_match(\"abc\", \"*?\")\n    True\n    >>> is_match(\"abc\", \"a*d\")\n    False\n    >>> is_match(\"abc\", \"a*c?\")\n    False\n    >>> is_match('baaabab','*****ba*****ba')\n    False\n    >>> is_match('baaabab','*****ba*****ab')\n    True\n    >>> is_match('aa','*')\n    True\n    \"\"\"\n    dp = [[False] * (len(pattern) + 1) for _ in string + \"1\"]\n    dp[0][0] = True\n    # Fill in the first row\n    for j, char in enumerate(pattern, 1):\n        if char == \"*\":\n            dp[0][j] = dp[0][j - 1]\n    # Fill in the rest of the DP table\n    for i, s_char in enumerate(string, 1):\n        for j, p_char in enumerate(pattern, 1):\n            if p_char in (s_char, \"?\"):\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[len(string)][len(pattern)]", "output": "def is_match(string: str, pattern: str) -> bool:\n    \"\"\"\n    >>> is_match(\"\", \"\")\n    True\n    >>> is_match(\"aa\", \"a\")\n    False\n    >>> is_match(\"abc\", \"abc\")\n    True\n    >>> is_match(\"abc\", \"*c\")\n    True\n    >>> is_match(\"abc\", \"a*\")\n    True\n    >>> is_match(\"abc\", \"*a*\")\n    True\n    >>> is_match(\"abc\", \"?b?\")\n    True\n    >>> is_match(\"abc\", \"*?\")\n    True\n    >>> is_match(\"abc\", \"a*d\")\n    False\n    >>> is_match(\"abc\", \"a*c?\")\n    False\n    >>> is_match('baaabab','*****ba*****ba')\n    False\n    >>> is_match('baaabab','*****ba*****ab')\n    True\n    >>> is_match('aa','*')\n    True\n    \"\"\"\n    dp = [[False] * (len(pattern) + 1) for _ in string + \"1\"]\n    dp[0][0] = True\n    # Fill in the first row\n    for j, char in enumerate(pattern, 1):\n        if char == \"*\":\n            dp[0][j] = dp[0][j - 1]\n    # Fill in the rest of the DP table\n    for i, s_char in enumerate(string, 1):\n        for j, p_char in enumerate(pattern, 1):\n            if p_char in (s_char, \"?\"):\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[len(string)][len(pattern)]"}
{"task": "summary", "input": "summarize code:\ndef sliding_window(iterable, n):\n    if n > 20:\n        return _sliding_window_deque(iterable, n)\n    elif n > 2:\n        return _sliding_window_islice(iterable, n)\n    elif n == 2:\n        return pairwise(iterable)\n    elif n == 1:\n        return zip(iterable)\n    else:\n        raise ValueError(f'n should be at least one, not {n}')", "output": "Return a sliding window of width *n* over *iterable*."}
{"task": "search", "input": "search code:\nMobius function\n\nChoices:\n0: def perfect(number: int) -> bool:     if not isinstance(number, int):         raise ValueError(\"number must be an integer\")     if number <= 0:         return False     return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number\n1: def always_iterable(obj, base_type=(str, bytes)):     if obj is None:         return iter(())      if (base_type is not None) and isinstance(obj, base_type):         return iter((obj,))      try:         return iter(obj)     except TypeError:         return iter((obj,))\n2: def mobius(n: int) -> int:     factors = prime_factors(n)     if is_square_free(factors):         return -1 if len(factors) % 2 else 1     return 0", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef is_harmonic_series(series: list) -> bool:\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [1, 2/3, 2]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    if len(series) == 1 and series[0] != 0:\n        return True\n    rec_series = []\n    series_len = len(series)\n    for i in range(series_len):\n        if series[i] == 0:\n            raise ValueError(\"Input series cannot have 0 as an element\")\n        rec_series.append(1 / series[i])\n    common_diff = rec_series[1] - rec_series[0]\n    for index in range(2, series_len):\n        if rec_series[index] - rec_series[index - 1] != common_diff:\n            return False\n    return True", "output": "checking whether the input series is arithmetic series or not"}
{"task": "search", "input": "search code:\nInput Parameters:\n\nChoices:\n0: def format_histogram_counts(bin_counts, width=None, format_bin=None):     lines = []     if not format_bin:         format_bin = lambda v: v     if not width:         try:             import shutil  # python 3 convenience             width = shutil.get_terminal_size()[0]         except Exception:             width = 80      bins = [b for b, _ in bin_counts]     count_max = max([count for _, count in bin_counts])     count_cols = len(str(count_max))      labels = ['%s' % format_bin(b) for b in bins]     label_cols = max([len(l) for l in labels])     tmp_line = '{}: {} #'.format('x' * label_cols, count_max)      bar_cols = max(width - len(tmp_line), 3)     line_k = float(bar_cols) / count_max     tmpl = \"{label:>{label_cols}}: {count:>{count_cols}} {bar}\"     for label, (bin_val, count) in zip(labels, bin_counts):         bar_len = int(round(count * line_k))         bar = ('#' * bar_len) or '|'         line = tmpl.format(label=label,                            label_cols=label_cols,                            count=count,                            count_cols=count_cols,                            bar=bar)         lines.append(line)      return '\\n'.join(lines)\n1: def second_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )\n2: def min_steps_to_one(number: int) -> int:      if number <= 0:         msg = f\"n must be greater than 0. Got n = {number}\"         raise ValueError(msg)      table = [number + 1] * (number + 1)      # starting position     table[1] = 0     for i in range(1, number):         table[i + 1] = min(table[i + 1], table[i] + 1)         # check if out of bounds         if i * 2 <= number:             table[i * 2] = min(table[i * 2], table[i] + 1)         # check if out of bounds         if i * 3 <= number:             table[i * 3] = min(table[i * 3], table[i] + 1)     return table[number]", "output": "1"}
{"task": "search", "input": "search code:\nIterate through the array from both sides to find the index of search_item.\n\nChoices:\n0: def split_when(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      it = iter(iterable)     try:         cur_item = next(it)     except StopIteration:         return      buf = [cur_item]     for next_item in it:         if pred(cur_item, next_item):             yield buf             if maxsplit == 1:                 yield [next_item, *it]                 return             buf = []             maxsplit -= 1          buf.append(next_item)         cur_item = next_item      yield buf\n1: def compute_transform_tables(     source_string: str,     destination_string: str,     copy_cost: int,     replace_cost: int,     delete_cost: int,     insert_cost: int, ) -> tuple[list[list[int]], list[list[str]]]:     source_seq = list(source_string)     destination_seq = list(destination_string)     len_source_seq = len(source_seq)     len_destination_seq = len(destination_seq)     costs = [         [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]     ops = [         [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]      for i in range(1, len_source_seq + 1):         costs[i][0] = i * delete_cost         ops[i][0] = f\"D{source_seq[i - 1]}\"      for i in range(1, len_destination_seq + 1):         costs[0][i] = i * insert_cost         ops[0][i] = f\"I{destination_seq[i - 1]}\"      for i in range(1, len_source_seq + 1):         for j in range(1, len_destination_seq + 1):             if source_seq[i - 1] == destination_seq[j - 1]:                 costs[i][j] = costs[i - 1][j - 1] + copy_cost                 ops[i][j] = f\"C{source_seq[i - 1]}\"             else:                 costs[i][j] = costs[i - 1][j - 1] + replace_cost                 ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])              if costs[i - 1][j] + delete_cost < costs[i][j]:                 costs[i][j] = costs[i - 1][j] + delete_cost                 ops[i][j] = f\"D{source_seq[i - 1]}\"              if costs[i][j - 1] + insert_cost < costs[i][j]:                 costs[i][j] = costs[i][j - 1] + insert_cost                 ops[i][j] = f\"I{destination_seq[j - 1]}\"      return costs, ops\n2: def double_linear_search(array: list[int], search_item: int) -> int:     # define the start and end index of the given array     start_ind, end_ind = 0, len(array) - 1     while start_ind <= end_ind:         if array[start_ind] == search_item:             return start_ind         elif array[end_ind] == search_item:             return end_ind         else:             start_ind += 1             end_ind -= 1     # returns -1 if search_item is not found in array     return -1", "output": "2"}
{"task": "detection", "input": "classify code:\ndef nth_fibonacci_bruteforce(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_bruteforce(100)\n    354224848179261915075\n    >>> nth_fibonacci_bruteforce(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    fib0 = 0\n    fib1 = 1\n    for _ in range(2, n + 1):\n        fib0, fib1 = fib1, fib0 + fib1\n    return fib1", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef add_file_length(source_path: str, compressed: str) -> str:\n    file_length = os.path.getsize(source_path)\n    file_length_binary = bin(file_length)[2:]\n    length_length = len(file_length_binary)\n\n    return \"0\" * (length_length - 1) + file_length_binary + compressed", "output": "Adds given file's length in front (using Elias gamma coding) of the compressed"}
{"task": "summary", "input": "summarize code:\ndef add_three(\n    x_num: int, x_den: int, y_num: int, y_den: int, z_num: int, z_den: int\n) -> tuple[int, int]:\n    top: int = x_num * y_den * z_den + y_num * x_den * z_den + z_num * x_den * y_den\n    bottom: int = x_den * y_den * z_den\n    hcf: int = gcd(top, bottom)\n    top //= hcf\n    bottom //= hcf\n    return top, bottom", "output": "Given the numerators and denominators of three fractions, return the"}
{"task": "summary", "input": "summarize code:\ndef strip(iterable, strip_value=None):\n    return list(strip_iter(iterable, strip_value))", "output": "Strips values from the beginning and end of an iterable. Stripped items"}
{"task": "search", "input": "search code:\nIf *obj* is iterable, return an iterator over its items::\n\nChoices:\n0: def always_iterable(obj, base_type=(str, bytes)):     if obj is None:         return iter(())      if (base_type is not None) and isinstance(obj, base_type):         return iter((obj,))      try:         return iter(obj)     except TypeError:         return iter((obj,))\n1: def power(a: int, b: int) -> float:     if b < 0:         return 1 / actual_power(a, -b)     return actual_power(a, b)\n2: def catalan_number(node_count: int) -> int:     return binomial_coefficient(2 * node_count, node_count) // (node_count + 1)", "output": "0"}
{"task": "search", "input": "search code:\nAn implementation of the Monte Carlo method used to find pi.\n\nChoices:\n0: def distinct_combinations(iterable, r):     if r < 0:         raise ValueError('r must be non-negative')     elif r == 0:         yield ()         return     pool = tuple(iterable)     generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]     current_combo = [None] * r     level = 0     while generators:         try:             cur_idx, p = next(generators[-1])         except StopIteration:             generators.pop()             level -= 1             continue         current_combo[level] = p         if level + 1 == r:             yield tuple(current_combo)         else:             generators.append(                 unique_everseen(                     enumerate(pool[cur_idx + 1 :], cur_idx + 1),                     key=itemgetter(1),                 )             )             level += 1\n1: def pi_estimator(iterations: int) -> None:      # A local function to see if a dot lands in the circle.     def is_in_circle(x: float, y: float) -> bool:         distance_from_centre = sqrt((x**2) + (y**2))         # Our circle has a radius of 1, so a distance         # greater than 1 would land outside the circle.         return distance_from_centre <= 1      # The proportion of guesses that landed in the circle     proportion = mean(         int(is_in_circle(uniform(-1.0, 1.0), uniform(-1.0, 1.0)))         for _ in range(iterations)     )     # The ratio of the area for circle to square is pi/4.     pi_estimate = proportion * 4     print(f\"The estimated value of pi is {pi_estimate}\")     print(f\"The numpy value of pi is {pi}\")     print(f\"The total error is {abs(pi - pi_estimate)}\")\n2: def knapsack_with_example_solution(w: int, wt: list, val: list):     if not (isinstance(wt, (list, tuple)) and isinstance(val, (list, tuple))):         raise ValueError(             \"Both the weights and values vectors must be either lists or tuples\"         )      num_items = len(wt)     if num_items != len(val):         msg = (             \"The number of weights must be the same as the number of values.\\n\"             f\"But got {num_items} weights and {len(val)} values\"         )         raise ValueError(msg)     for i in range(num_items):         if not isinstance(wt[i], int):             msg = (                 \"All weights must be integers but got weight of \"                 f\"type {type(wt[i])} at index {i}\"             )             raise TypeError(msg)      optimal_val, dp_table = knapsack(w, wt, val, num_items)     example_optional_set: set = set()     _construct_solution(dp_table, wt, num_items, w, example_optional_set)      return optimal_val, example_optional_set", "output": "1"}
{"task": "search", "input": "search code:\nFind the number of digits in a number.\n\nChoices:\n0: def iterate_function(     eval_function: Callable[[Any, np.ndarray], np.ndarray],     function_params: Any,     nb_iterations: int,     z_0: np.ndarray,     infinity: float | None = None, ) -> np.ndarray:      z_n = z_0.astype(\"complex64\")     for _ in range(nb_iterations):         z_n = eval_function(function_params, z_n)         if infinity is not None:             np.nan_to_num(z_n, copy=False, nan=infinity)             z_n[abs(z_n) == np.inf] = infinity     return z_n\n1: def num_digits_fast(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      return 1 if n == 0 else math.floor(math.log(abs(n), 10) + 1)\n2: def median(items: list):     mid, rem = divmod(len(items), 2)     if rem != 0:         return quick_select(items=items, index=mid)     else:         low_mid = quick_select(items=items, index=mid - 1)         high_mid = quick_select(items=items, index=mid)         return (low_mid + high_mid) / 2", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef fibonacci_search(arr: list, val: int) -> int:\n    len_list = len(arr)\n    # Find m such that F_m >= n where F_i is the i_th fibonacci number.\n    i = 0\n    while True:\n        if fibonacci(i) >= len_list:\n            fibb_k = i\n            break\n        i += 1\n    offset = 0\n    while fibb_k > 0:\n        index_k = min(\n            offset + fibonacci(fibb_k - 1), len_list - 1\n        )  # Prevent out of range\n        item_k_1 = arr[index_k]\n        if item_k_1 == val:\n            return index_k\n        elif val < item_k_1:\n            fibb_k -= 1\n        elif val > item_k_1:\n            offset += fibonacci(fibb_k - 1)\n            fibb_k -= 2\n    return -1", "output": "A pure Python implementation of a fibonacci search algorithm."}
{"task": "summary", "input": "summarize code:\ndef vol_cube(side_length: float) -> float:\n    if side_length < 0:\n        raise ValueError(\"vol_cube() only accepts non-negative values\")\n    return pow(side_length, 3)", "output": "Calculate the Volume of a Cube."}
{"task": "detection", "input": "classify code:\ndef find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef digital_differential_analyzer_line(\n    p1: tuple[int, int], p2: tuple[int, int]\n) -> list[tuple[int, int]]:\n    x1, y1 = p1\n    x2, y2 = p2\n    dx = x2 - x1\n    dy = y2 - y1\n    steps = max(abs(dx), abs(dy))\n    x_increment = dx / float(steps)\n    y_increment = dy / float(steps)\n    coordinates = []\n    x: float = x1\n    y: float = y1\n    for _ in range(steps):\n        x += x_increment\n        y += y_increment\n        coordinates.append((round(x), round(y)))\n    return coordinates", "output": "Draws a line between two points using the DDA algorithm."}
{"task": "search", "input": "search code:\nBreak *iterable* into lists of length *n*:\n\nChoices:\n0: def solution() -> int:     return compute_nums(1)[0]\n1: def abs_val(num: float) -> float:     return -num if num < 0 else num\n2: def chunked(iterable, n, strict=False):     iterator = iter(partial(take, n, iter(iterable)), [])     if strict:         if n is None:             raise ValueError('n must not be None when using strict mode.')          def ret():             for chunk in iterator:                 if len(chunk) != n:                     raise ValueError('iterable is not divisible by n.')                 yield chunk          return ret()     else:         return iterator", "output": "2"}
{"task": "detection", "input": "classify code:\ndef get_squares(n: int) -> list[int]:\n    \"\"\"\n    >>> get_squares(0)\n    []\n    >>> get_squares(1)\n    [0]\n    >>> get_squares(2)\n    [0, 1]\n    >>> get_squares(3)\n    [0, 1, 4]\n    >>> get_squares(4)\n    [0, 1, 4, 9]\n    \"\"\"\n    return [number * number for number in range(n)]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nConverts an underscored string to camelcased. Useful for turning a\n\nChoices:\n0: def ugly_numbers(n: int) -> int:     ugly_nums = [1]      i2, i3, i5 = 0, 0, 0     next_2 = ugly_nums[i2] * 2     next_3 = ugly_nums[i3] * 3     next_5 = ugly_nums[i5] * 5      for _ in range(1, n):         next_num = min(next_2, next_3, next_5)         ugly_nums.append(next_num)         if next_num == next_2:             i2 += 1             next_2 = ugly_nums[i2] * 2         if next_num == next_3:             i3 += 1             next_3 = ugly_nums[i3] * 3         if next_num == next_5:             i5 += 1             next_5 = ugly_nums[i5] * 5     return ugly_nums[-1]\n1: def under2camel(under_string):     return ''.join(w.capitalize() or '_' for w in under_string.split('_'))\n2: def nearest_neighbour_search(     root: KDNode | None, query_point: list[float] ) -> tuple[list[float] | None, float, int]:     nearest_point: list[float] | None = None     nearest_dist: float = float(\"inf\")     nodes_visited: int = 0      def search(node: KDNode | None, depth: int = 0) -> None:         nonlocal nearest_point, nearest_dist, nodes_visited         if node is None:             return          nodes_visited += 1          # Calculate the current distance (squared distance)         current_point = node.point         current_dist = sum(             (query_coord - point_coord) ** 2             for query_coord, point_coord in zip(query_point, current_point)         )          # Update nearest point if the current node is closer         if nearest_point is None or current_dist < nearest_dist:             nearest_point = current_point             nearest_dist = current_dist          # Determine which subtree to search first (based on axis and query point)         k = len(query_point)  # Dimensionality of points         axis = depth % k          if query_point[axis] <= current_point[axis]:             nearer_subtree = node.left             further_subtree = node.right         else:             nearer_subtree = node.right             further_subtree = node.left          # Search the nearer subtree first         search(nearer_subtree, depth + 1)          # If the further subtree has a closer point         if (query_point[axis] - current_point[axis]) ** 2 < nearest_dist:             search(further_subtree, depth + 1)      search(root, 0)     return nearest_point, nearest_dist, nodes_visited", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef build_tree(letters: list[Letter]) -> Letter | TreeNode:\n    response: list[Letter | TreeNode] = list(letters)\n    while len(response) > 1:\n        left = response.pop(0)\n        right = response.pop(0)\n        total_freq = left.freq + right.freq\n        node = TreeNode(total_freq, left, right)\n        response.append(node)\n        response.sort(key=lambda x: x.freq)\n    return response[0]", "output": "Run through the list of Letters and build the min heap"}
{"task": "search", "input": "search code:\nCompute the first derivative of a polynomial.\n\nChoices:\n0: def polynomial_derivative(coefficients):     n = len(coefficients)     powers = reversed(range(1, n))     return list(map(mul, coefficients, powers))\n1: def matrix_pow_np(m: ndarray, power: int) -> ndarray:     result = np.array([[1, 0], [0, 1]], dtype=int)  # Identity Matrix     base = m     if power < 0:  # Negative power is not allowed         raise ValueError(\"power is negative\")     while power:         if power % 2 == 1:             result = np.dot(result, base)         base = np.dot(base, base)         power //= 2     return result\n2: def knapsack(     weights: list, values: list, number_of_items: int, max_weight: int, index: int ) -> int:     if index == number_of_items:         return 0     ans1 = 0     ans2 = 0     ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)     if weights[index] <= max_weight:         ans2 = values[index] + knapsack(             weights, values, number_of_items, max_weight - weights[index], index + 1         )     return max(ans1, ans2)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef run_maze(\n    maze: list[list[int]],\n    i: int,\n    j: int,\n    destination_row: int,\n    destination_column: int,\n    solutions: list[list[int]],\n) -> bool:\n    size = len(maze)\n    # Final check point.\n    if i == destination_row and j == destination_column and maze[i][j] == 0:\n        solutions[i][j] = 0\n        return True\n\n    lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds\n    upper_flag = (i < size) and (j < size)  # Check upper bounds\n\n    if lower_flag and upper_flag:\n        # check for already visited and block points.\n        block_flag = (solutions[i][j]) and (not maze[i][j])\n        if block_flag:\n            # check visited\n            solutions[i][j] = 0\n\n            # check for directions\n            if (\n                run_maze(maze, i + 1, j, destination_row, destination_column, solutions)\n                or run_maze(\n                    maze, i, j + 1, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i - 1, j, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i, j - 1, destination_row, destination_column, solutions\n                )\n            ):\n                return True\n\n            solutions[i][j] = 1\n            return False\n    return False", "output": "This method is recursive starting from (i, j) and going in one of four directions:"}
{"task": "detection", "input": "classify code:\ndef binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n    -1\n    \"\"\"\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef lower(word: str) -> str:\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)", "output": "Will convert the entire string to lowercase letters"}
{"task": "search", "input": "search code:\nRobustly parses a short text description of a time period into a\n\nChoices:\n0: def parse_timedelta(text):     td_kwargs = {}     for match in _PARSE_TD_RE.finditer(text):         value, unit = match.group('value'), match.group('unit')         try:             unit_key = _PARSE_TD_KW_MAP[unit]         except KeyError:             raise ValueError('invalid time unit %r, expected one of %r'                              % (unit, _PARSE_TD_KW_MAP.keys()))         try:             value = float(value)         except ValueError:             raise ValueError('invalid time value for unit %r: %r'                              % (unit, value))         td_kwargs[unit_key] = value     return timedelta(**td_kwargs)\n1: def liouville_lambda(number: int) -> int:     if not isinstance(number, int):         msg = f\"Input value of [number={number}] must be an integer\"         raise TypeError(msg)     if number < 1:         raise ValueError(\"Input must be a positive integer\")     return -1 if len(prime_factors(number)) % 2 else 1\n2: def binary_search(sorted_collection: list[int], item: int) -> int:     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     left = 0     right = len(sorted_collection) - 1      while left <= right:         midpoint = left + (right - left) // 2         current_item = sorted_collection[midpoint]         if current_item == item:             return midpoint         elif item < current_item:             right = midpoint - 1         else:             left = midpoint + 1     return -1", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef make_tree_seven() -> Node:\n    tree = Node(1)\n    tree.left = Node(2)\n    tree.right = Node(3)\n    tree.left.left = Node(4)\n    tree.left.right = Node(5)\n    tree.right.left = Node(6)\n    tree.right.right = Node(7)\n    return tree", "output": "Return a binary tree with 7 nodes that looks like this:"}
{"task": "repair", "input": "fix bug:\ndef selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection", "output": "def selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection"}
{"task": "summary", "input": "summarize code:\ndef with_iter(context_manager):\n    with context_manager as iterable:\n        yield from iterable", "output": "Wrap an iterable in a ``with`` statement, so it closes once exhausted."}
{"task": "summary", "input": "summarize code:\ndef naturaldate(value) -> str:\n    try:\n        value = dt.date(value.year, value.month, value.day)\n    except AttributeError:\n        # Passed value wasn't date-ish\n        return value\n    except (OverflowError, ValueError):\n        # Date arguments out of range\n        return value\n    delta = _abs_timedelta(value - dt.date.today())\n    if delta.days >= 5 * 365 / 12:\n        return naturalday(value, \"%b %d %Y\")\n    return naturalday(value)", "output": "Like `naturalday`, but append a year for dates more than ~five months away."}
{"task": "summary", "input": "summarize code:\ndef get_multiplier(color: str) -> float:\n    if color not in multiplier_color_values:\n        msg = f\"{color} is not a valid color for multiplier band\"\n        raise ValueError(msg)\n    return multiplier_color_values[color]", "output": "Function returns the multiplier value associated with the color."}
{"task": "summary", "input": "summarize code:\ndef product_sum(arr: list[int | list], depth: int) -> int:\n    total_sum = 0\n    for ele in arr:\n        total_sum += product_sum(ele, depth + 1) if isinstance(ele, list) else ele\n    return total_sum * depth", "output": "Recursively calculates the product sum of an array."}
{"task": "search", "input": "search code:\nFind the smallest range from each list in nums.\n\nChoices:\n0: def dp_match(text: str, pattern: str) -> bool:     m = len(text)     n = len(pattern)     dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]     dp[0][0] = True      for j in range(1, n + 1):         dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]      for i in range(1, m + 1):         for j in range(1, n + 1):             if pattern[j - 1] in {\".\", text[i - 1]}:                 dp[i][j] = dp[i - 1][j - 1]             elif pattern[j - 1] == \"*\":                 dp[i][j] = dp[i][j - 2]                 if pattern[j - 2] in {\".\", text[i - 1]}:                     dp[i][j] |= dp[i - 1][j]             else:                 dp[i][j] = False      return dp[m][n]\n1: def solution(nth: int = 10001) -> int:      count = 0     number = 1     while count != nth and number < 3:         number += 1         if is_prime(number):             count += 1     while count != nth:         number += 2         if is_prime(number):             count += 1     return number\n2: def smallest_range(nums: list[list[int]]) -> list[int]:      min_heap: list[tuple[int, int, int]] = []     current_max = -maxsize - 1      for i, items in enumerate(nums):         heappush(min_heap, (items[0], i, 0))         current_max = max(current_max, items[0])      # Initialize smallest_range with large integer values     smallest_range = [-maxsize - 1, maxsize]      while min_heap:         current_min, list_index, element_index = heappop(min_heap)          if current_max - current_min < smallest_range[1] - smallest_range[0]:             smallest_range = [current_min, current_max]          if element_index == len(nums[list_index]) - 1:             break          next_element = nums[list_index][element_index + 1]         heappush(min_heap, (next_element, list_index, element_index + 1))         current_max = max(current_max, next_element)      return smallest_range", "output": "2"}
{"task": "search", "input": "search code:\nReturns ``True`` if all the elements are equal to each other.\n\nChoices:\n0: def all_equal(iterable, key=None):     iterator = groupby(iterable, key)     for first in iterator:         for second in iterator:             return False         return True     return True\n1: def consume(iterator, n=None):     # Use functions that consume iterators at C speed.     if n is None:         # feed the entire iterator into a zero-length deque         deque(iterator, maxlen=0)     else:         # advance to the empty slice starting at position n         next(islice(iterator, n, n), None)\n2: def is_collection(obj):     return is_iterable(obj) and not isinstance(obj, (str, bytes))", "output": "0"}
{"task": "detection", "input": "classify code:\ndef binary_multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply 'a' and 'b' using bitwise multiplication.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: a * b\n\n    Examples:\n    >>> binary_multiply(2, 3)\n    6\n    >>> binary_multiply(5, 0)\n    0\n    >>> binary_multiply(3, 4)\n    12\n    >>> binary_multiply(10, 5)\n    50\n    >>> binary_multiply(0, 5)\n    0\n    >>> binary_multiply(2, 1)\n    2\n    >>> binary_multiply(1, 10)\n    10\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef get_forbes_real_time_billionaires() -> list[dict[str, int | str]]:\n    response_json = httpx.get(API_URL, timeout=10).json()\n    return [\n        {\n            \"Name\": person[\"personName\"],\n            \"Source\": person[\"source\"],\n            \"Country\": person[\"countryOfCitizenship\"],\n            \"Gender\": person[\"gender\"],\n            \"Worth ($)\": f\"{person['finalWorth'] / 1000:.1f} Billion\",\n            \"Age\": str(years_old(person[\"birthDate\"] / 1000)),\n        }\n        for person in response_json[\"personList\"][\"personsLists\"]\n    ]", "output": "Get the top 10 real-time billionaires using Forbes API."}
{"task": "repair", "input": "fix bug:\ndef is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True", "output": "def is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True"}
{"task": "summary", "input": "summarize code:\ndef speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5", "output": "Calculates the speed of sound in a fluid from its density and bulk modulus"}
{"task": "search", "input": "search code:\nReturn the sum of all numbers, less than n , which are palindromic in\n\nChoices:\n0: def optimal_merge_pattern(files: list) -> float:     optimal_merge_cost = 0     while len(files) > 1:         temp = 0         # Consider two files with minimum cost to be merged         for _ in range(2):             min_index = files.index(min(files))             temp += files[min_index]             files.pop(min_index)         files.append(temp)         optimal_merge_cost += temp     return optimal_merge_cost\n1: def calculate_variance(items: list, means: list, total_count: int) -> float:     squared_diff = []  # An empty list to store all squared differences     # iterate over number of elements in items     for i in range(len(items)):         # for loop iterates over number of elements in inner layer of items         for j in range(len(items[i])):             # appending squared differences to 'squared_diff' list             squared_diff.append((items[i][j] - means[i]) ** 2)      # one divided by (the number of all instances - number of classes) multiplied by     # sum of all squared differences     n_classes = len(means)  # Number of classes in dataset     return 1 / (total_count - n_classes) * sum(squared_diff)\n2: def solution(n: int = 1000000):     total = 0      for i in range(1, n):         if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):             total += i     return total", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)", "output": "def knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)"}
{"task": "search", "input": "search code:\nFind the minimum cost traced by all possible paths from top left to bottom right in\n\nChoices:\n0: def minimum_cost_path(matrix: list[list[int]]) -> int:      # preprocessing the first row     for i in range(1, len(matrix[0])):         matrix[0][i] += matrix[0][i - 1]      # preprocessing the first column     for i in range(1, len(matrix)):         matrix[i][0] += matrix[i - 1][0]      # updating the path cost for current position     for i in range(1, len(matrix)):         for j in range(1, len(matrix[0])):             matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])      return matrix[-1][-1]\n1: def solution(n: int = 20) -> int:      g = 1     for i in range(1, n + 1):         g = lcm(g, i)     return g\n2: def is_geometric_series(series: list) -> bool:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     if len(series) == 1:         return True     try:         common_ratio = series[1] / series[0]         for index in range(len(series) - 1):             if series[index + 1] / series[index] != common_ratio:                 return False     except ZeroDivisionError:         return False     return True", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef find_median(nums: list[int | float]) -> float:\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2", "output": "This is the implementation of the median."}
{"task": "search", "input": "search code:\ndecrypt_message\n\nChoices:\n0: def all_equal(iterable, key=None):     iterator = groupby(iterable, key)     for first in iterator:         for second in iterator:             return False         return True     return True\n1: def decrypt_message(     message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5 ) -> str:     message, alphabet, character_to_number, number_to_character = __prepare(         message, alphabet     )      decrypted_numeric = []     for i in range(0, len(message), period):         a, b, c = __decrypt_part(message[i : i + period], character_to_number)          for j in range(len(a)):             decrypted_numeric.append(a[j] + b[j] + c[j])      return \"\".join(number_to_character[each] for each in decrypted_numeric)\n2: def run(n: int) -> list[int]:      # Incrementor variable for our group list comprehension.     # This is the first number in each list of values     # to test.     base = 2      while True:         # Increment each value of a generated range         group = [base + i for i in range(n)]          # Run elements through the unique_prime_factors function         # Append our target number to the end.         checker = [upf_len(x) for x in group]         checker.append(n)          # If all numbers in the list are equal, return the group variable.         if equality(checker):             return group          # Increment our base variable by 1         base += 1", "output": "1"}
{"task": "search", "input": "search code:\nInstalls a signal handler for *signalnum*, which defaults to\n\nChoices:\n0: def is_palindrome(head: ListNode | None) -> bool:     if not head:         return True     # split the list to two parts     fast: ListNode | None = head.next_node     slow: ListNode | None = head     while fast and fast.next_node:         fast = fast.next_node.next_node         slow = slow.next_node if slow else None     if slow:         # slow will always be defined,         # adding this check to resolve mypy static check         second = slow.next_node         slow.next_node = None  # Don't forget here! But forget still works!     # reverse the second part     node: ListNode | None = None     while second:         nxt = second.next_node         second.next_node = node         node = second         second = nxt     # compare two parts     # second part has the same or one less node     while node and head:         if node.val != head.val:             return False         node = node.next_node         head = head.next_node     return True\n1: def level_order(root: Node | None) -> Generator[int]:      if root is None:         return      process_queue = deque([root])      while process_queue:         node = process_queue.popleft()         yield node.data          if node.left:             process_queue.append(node.left)         if node.right:             process_queue.append(node.right)\n2: def pdb_on_signal(signalnum=None):     import pdb     import signal     if not signalnum:         signalnum = signal.SIGINT      old_handler = signal.getsignal(signalnum)      def pdb_int_handler(sig, frame):         signal.signal(signalnum, old_handler)         pdb.set_trace()         pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help      signal.signal(signalnum, pdb_int_handler)     return", "output": "2"}
{"task": "search", "input": "search code:\nEliminate d from values[s]; propagate when values or places <= 2.\n\nChoices:\n0: def normalize_array(array: np.ndarray, cap: float = 1) -> np.ndarray:     diff = np.max(array) - np.min(array)     return (array - np.min(array)) / (1 if diff == 0 else diff) * cap\n1: def eliminate(values, s, d):     if d not in values[s]:         return values  ## Already eliminated     values[s] = values[s].replace(d, \"\")     ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.     if len(values[s]) == 0:         return False  ## Contradiction: removed last value     elif len(values[s]) == 1:         d2 = values[s]         if not all(eliminate(values, s2, d2) for s2 in peers[s]):             return False     ## (2) If a unit u is reduced to only one place for a value d, then put it there.     for u in units[s]:         dplaces = [s for s in u if d in values[s]]         if len(dplaces) == 0:             return False  ## Contradiction: no place for this value         # d can only be in one place in unit; assign it there         elif len(dplaces) == 1 and not assign(values, dplaces[0], d):             return False     return values\n2: def bitap_string_match(text: str, pattern: str) -> int:     if not pattern:         return 0     m = len(pattern)     if m > len(text):         return -1      # Initial state of bit string 1110     state = ~1     # Bit = 0 if character appears at index, and 1 otherwise     pattern_mask: list[int] = [~0] * 27  # 1111      for i, char in enumerate(pattern):         # For the pattern mask for this character, set the bit to 0 for each i         # the character appears.         pattern_index: int = ord(char) - ord(\"a\")         pattern_mask[pattern_index] &= ~(1 << i)      for i, char in enumerate(text):         text_index = ord(char) - ord(\"a\")         # If this character does not appear in pattern, it's pattern mask is 1111.         # Performing a bitwise OR between state and 1111 will reset the state to 1111         # and start searching the start of pattern again.         state |= pattern_mask[text_index]         state <<= 1          # If the mth bit (counting right to left) of the state is 0, then we have         # found pattern in text         if (state & (1 << m)) == 0:             return i - m + 1      return -1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef sieve(n: int) -> list[int]:\n\n    if n <= 0 or isinstance(n, float):\n        msg = f\"Number {n} must instead be a positive integer\"\n        raise ValueError(msg)\n\n    in_prime = []\n    start = 2\n    end = int(math.sqrt(n))  # Size of every segment\n    temp = [True] * (end + 1)\n    prime = []\n\n    while start <= end:\n        if temp[start] is True:\n            in_prime.append(start)\n            for i in range(start * start, end + 1, start):\n                temp[i] = False\n        start += 1\n    prime += in_prime\n\n    low = end + 1\n    high = min(2 * end, n)\n\n    while low <= n:\n        temp = [True] * (high - low + 1)\n        for each in in_prime:\n            t = math.floor(low / each) * each\n            if t < low:\n                t += each\n\n            for j in range(t, high + 1, each):\n                temp[j - low] = False\n\n        for j in range(len(temp)):\n            if temp[j] is True:\n                prime.append(j + low)\n\n        low = high + 1\n        high = min(high + end, n)\n\n    return prime", "output": "Segmented Sieve."}
{"task": "summary", "input": "summarize code:\ndef calculate_fft(audio_windowed: np.ndarray, ftt_size: int = 1024) -> np.ndarray:\n    # Transpose the audio data to have time in rows and channels in columns\n    audio_transposed = np.transpose(audio_windowed)\n\n    # Initialize an array to store the FFT results\n    audio_fft = np.empty(\n        (int(1 + ftt_size // 2), audio_transposed.shape[1]),\n        dtype=np.complex64,\n        order=\"F\",\n    )\n\n    # Compute FFT for each channel\n    for n in range(audio_fft.shape[1]):\n        audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]\n\n    # Transpose the FFT results back to the original shape\n    return np.transpose(audio_fft)", "output": "Calculate the Fast Fourier Transform (FFT) of windowed audio data."}
{"task": "repair", "input": "fix bug:\ndef calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "output": "def calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r"}
{"task": "search", "input": "search code:\nFinds the maximum total in a triangle as described by the problem statement\n\nChoices:\n0: def take(n, iterable):     return list(islice(iterable, n))\n1: def solution():     script_dir = os.path.dirname(os.path.realpath(__file__))     triangle = os.path.join(script_dir, \"triangle.txt\")      with open(triangle) as f:         triangle = f.readlines()      a = [[int(y) for y in x.rstrip(\"\\r\\n\").split(\" \")] for x in triangle]      for i in range(1, len(a)):         for j in range(len(a[i])):             number1 = a[i - 1][j] if j != len(a[i - 1]) else 0             number2 = a[i - 1][j - 1] if j > 0 else 0             a[i][j] += max(number1, number2)     return max(a[-1])\n2: def gabor_filter_kernel(     ksize: int, sigma: int, theta: int, lambd: int, gamma: int, psi: int ) -> np.ndarray:      # prepare kernel     # the kernel size have to be odd     if (ksize % 2) == 0:         ksize = ksize + 1     gabor = np.zeros((ksize, ksize), dtype=np.float32)      # each value     for y in range(ksize):         for x in range(ksize):             # distance from center             px = x - ksize // 2             py = y - ksize // 2              # degree to radiant             _theta = theta / 180 * np.pi             cos_theta = np.cos(_theta)             sin_theta = np.sin(_theta)              # get kernel x             _x = cos_theta * px + sin_theta * py              # get kernel y             _y = -sin_theta * px + cos_theta * py              # fill kernel             gabor[y, x] = np.exp(-(_x**2 + gamma**2 * _y**2) / (2 * sigma**2)) * np.cos(                 2 * np.pi * _x / lambd + psi             )      return gabor", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius", "output": "def centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius"}
{"task": "summary", "input": "summarize code:\ndef create_edge(nodes, graph, cluster, c1):\n    for i in cluster[c1]:\n        count = 0\n        c2 = c1 + 1\n        while c2 < max(cluster.keys()):\n            for j in cluster[c2]:\n                if int(i, 2) & int(j, 2) == int(i, 2):\n                    if tuple(nodes[i]) in graph:\n                        graph[tuple(nodes[i])].append(nodes[j])\n                    else:\n                        graph[tuple(nodes[i])] = [nodes[j]]\n                    count += 1\n            if count == 0:\n                c2 = c2 + 1\n            else:\n                break", "output": "create edge between the nodes"}
{"task": "search", "input": "search code:\nReturns the sequence of elements and then returns ``None`` indefinitely.\n\nChoices:\n0: def pad_none(iterable):     return chain(iterable, repeat(None))\n1: def intword(value, format=\"%.1f\"):     try:         value = int(value)     except (TypeError, ValueError):         return value      if value < powers[0]:         return str(value)     for ordinal, power in enumerate(powers[1:], 1):         if value < power:             chopped = value / float(powers[ordinal - 1])             if float(format % chopped) == float(10**3):                 chopped = value / float(powers[ordinal])                 singular, plural = human_powers[ordinal]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped             else:                 singular, plural = human_powers[ordinal - 1]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped     return str(value)\n2: def main() -> None:     img_paths, annos = get_dataset(LABEL_DIR, IMG_DIR)     for index in range(NUMBER_IMAGES):         idxs = random.sample(range(len(annos)), 4)         new_image, new_annos, path = update_image_and_anno(             img_paths,             annos,             idxs,             OUTPUT_SIZE,             SCALE_RANGE,             filter_scale=FILTER_TINY_SCALE,         )          # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'         letter_code = random_chars(32)         file_name = path.split(os.sep)[-1].rsplit(\".\", 1)[0]         file_root = f\"{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}\"         cv2.imwrite(f\"{file_root}.jpg\", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])         print(f\"Succeeded {index + 1}/{NUMBER_IMAGES} with {file_name}\")         annos_list = []         for anno in new_annos:             width = anno[3] - anno[1]             height = anno[4] - anno[2]             x_center = anno[1] + width / 2             y_center = anno[2] + height / 2             obj = f\"{anno[0]} {x_center} {y_center} {width} {height}\"             annos_list.append(obj)         with open(f\"{file_root}.txt\", \"w\") as outfile:             outfile.write(\"\\n\".join(line for line in annos_list))", "output": "0"}
{"task": "detection", "input": "classify code:\ndef hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nfunction is the f we want to find its root\n\nChoices:\n0: def _running_median_minheap_only(iterator):  # pragma: no cover     \"Backport of non-windowed running_median() for Python 3.13 and prior.\"      read = iterator.__next__     lo = []  # max-heap (actually a minheap with negated values)     hi = []  # min-heap (same size as or one smaller than lo)      with suppress(StopIteration):         while True:             heappush(lo, -heappushpop(hi, read()))             yield -lo[0]              heappush(hi, -heappushpop(lo, -read()))             yield (hi[0] - lo[0]) / 2\n1: def is_scalar(obj):     return not is_iterable(obj) or isinstance(obj, (str, bytes))\n2: def intersection(function: Callable[[float], float], x0: float, x1: float) -> float:     x_n: float = x0     x_n1: float = x1     while True:         if x_n == x_n1 or function(x_n1) == function(x_n):             raise ZeroDivisionError(\"float division by zero, could not find root\")         x_n2: float = x_n1 - (             function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))         )         if abs(x_n2 - x_n1) < 10**-5:             return x_n2         x_n = x_n1         x_n1 = x_n2", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid's Algorithm\n\n    >>> greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    >>> greatest_common_divisor(121, 11)\n    11\n\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while a % b != 0:\n        a, b = b, a % b\n\n    return b", "output": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid's Algorithm\n\n    >>> greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    >>> greatest_common_divisor(121, 11)\n    11\n\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while a % b != 0:\n        a, b = b, a % b\n\n    return b"}
{"task": "search", "input": "search code:\nEquivalent to ``list(combinations(iterable, r))[index]``.\n\nChoices:\n0: def nth_combination(iterable, r, index):     pool = tuple(iterable)     n = len(pool)     if (r < 0) or (r > n):         raise ValueError      c = 1     k = min(r, n - r)     for i in range(1, k + 1):         c = c * (n - k + i) // i      if index < 0:         index += c      if (index < 0) or (index >= c):         raise IndexError      result = []     while r:         c, n, r = c * r // n, n - 1, r - 1         while index >= c:             index -= c             c, n = c * (n - r) // n, n - 1         result.append(pool[-1 - n])      return tuple(result)\n1: def matrix_pow_np(m: ndarray, power: int) -> ndarray:     result = np.array([[1, 0], [0, 1]], dtype=int)  # Identity Matrix     base = m     if power < 0:  # Negative power is not allowed         raise ValueError(\"power is negative\")     while power:         if power % 2 == 1:             result = np.dot(result, base)         base = np.dot(base, base)         power //= 2     return result\n2: def mkdir_p(path):     try:         os.makedirs(path)     except OSError as exc:         if exc.errno == errno.EEXIST and os.path.isdir(path):             return         raise     return", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef exchange_sort(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Uses exchange sort to sort a list of numbers.\n    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    >>> exchange_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([-1, -2, -3])\n    [-3, -2, -1]\n    >>> exchange_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([0, 10, -2, 5, 3])\n    [-2, 0, 3, 5, 10]\n    >>> exchange_sort([])\n    []\n    \"\"\"\n    numbers_length = len(numbers)\n    for i in range(numbers_length):\n        for j in range(i + 1, numbers_length):\n            if numbers[j] < numbers[i]:\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n    return numbers", "output": "def exchange_sort(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Uses exchange sort to sort a list of numbers.\n    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    >>> exchange_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([-1, -2, -3])\n    [-3, -2, -1]\n    >>> exchange_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([0, 10, -2, 5, 3])\n    [-2, 0, 3, 5, 10]\n    >>> exchange_sort([])\n    []\n    \"\"\"\n    numbers_length = len(numbers)\n    for i in range(numbers_length):\n        for j in range(i + 1, numbers_length):\n            if numbers[j] < numbers[i]:\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n    return numbers"}
{"task": "summary", "input": "summarize code:\ndef dotproduct(vec1, vec2):\n    return sum(map(mul, vec1, vec2))", "output": "Returns the dot product of the two iterables."}
{"task": "summary", "input": "summarize code:\ndef mel_to_freq(mels: float) -> float:\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)", "output": "Convert a frequency in the mel scale to Hertz."}
{"task": "summary", "input": "summarize code:\ndef area_parallelogram(base: float, height: float) -> float:\n    if base < 0 or height < 0:\n        raise ValueError(\"area_parallelogram() only accepts non-negative values\")\n    return base * height", "output": "Calculate the area of a parallelogram."}
{"task": "detection", "input": "classify code:\ndef count_vowels(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a given string.\n\n    :param s: Input string to count vowels in.\n    :return: Number of vowels in the input string.\n\n    Examples:\n    >>> count_vowels(\"hello world\")\n    3\n    >>> count_vowels(\"HELLO WORLD\")\n    3\n    >>> count_vowels(\"123 hello world\")\n    3\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a quick brown fox\")\n    5\n    >>> count_vowels(\"the quick BROWN fox\")\n    5\n    >>> count_vowels(\"PYTHON\")\n    1\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nThird method: Support vector regressor\n\nChoices:\n0: def support_vector_regressor(x_train: list, x_test: list, train_user: list) -> float:     regressor = SVR(kernel=\"rbf\", C=1, gamma=0.1, epsilon=0.1)     regressor.fit(x_train, train_user)     y_pred = regressor.predict(x_test)     return float(y_pred[0])\n1: def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:     result = [0] * (gon_side * 3)     result[0:3] = perm[0:3]     perm.append(perm[1])      magic_number = 1 if gon_side < 5 else 2      for i in range(1, len(perm) // 3 + magic_number):         result[3 * i] = perm[2 * i + 1]         result[3 * i + 1] = result[3 * i - 1]         result[3 * i + 2] = perm[2 * i + 2]      return result\n2: def triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:     for triplet in permutations(arr, 3):         if sum(triplet) == target:             return tuple(sorted(triplet))     return (0, 0, 0)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef unique_prime_factors(n: int) -> set:\n    \"\"\"\n    Find unique prime factors of an integer.\n    Tests include sorting because only the set matters,\n    not the order in which it is produced.\n    >>> sorted(set(unique_prime_factors(14)))\n    [2, 7]\n    >>> sorted(set(unique_prime_factors(644)))\n    [2, 7, 23]\n    >>> sorted(set(unique_prime_factors(646)))\n    [2, 17, 19]\n    \"\"\"\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors", "output": "def unique_prime_factors(n: int) -> set:\n    \"\"\"\n    Find unique prime factors of an integer.\n    Tests include sorting because only the set matters,\n    not the order in which it is produced.\n    >>> sorted(set(unique_prime_factors(14)))\n    [2, 7]\n    >>> sorted(set(unique_prime_factors(644)))\n    [2, 7, 23]\n    >>> sorted(set(unique_prime_factors(646)))\n    [2, 17, 19]\n    \"\"\"\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors"}
{"task": "search", "input": "search code:\nFunction updates the largest_square_area[0], if recursive call found\n\nChoices:\n0: def is_pentagonal(n: int) -> bool:     root = (1 + 24 * n) ** 0.5     return ((1 + root) / 6) % 1 == 0\n1: def largest_square_area_in_matrix_top_down_approch_with_dp(     rows: int, cols: int, mat: list[list[int]] ) -> int:      def update_area_of_max_square_using_dp_array(         row: int, col: int, dp_array: list[list[int]]     ) -> int:         if row >= rows or col >= cols:             return 0         if dp_array[row][col] != -1:             return dp_array[row][col]          right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)         diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)         down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)          if mat[row][col]:             sub_problem_sol = 1 + min([right, diagonal, down])             largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)             dp_array[row][col] = sub_problem_sol             return sub_problem_sol         else:             return 0      largest_square_area = [0]     dp_array = [[-1] * cols for _ in range(rows)]     update_area_of_max_square_using_dp_array(0, 0, dp_array)      return largest_square_area[0]\n2: def knuth_morris_pratt(text: str, pattern: str) -> int:      # 1) Construct the failure array     failure = get_failure_array(pattern)      # 2) Step through text searching for pattern     i, j = 0, 0  # index into text, pattern     while i < len(text):         if pattern[j] == text[i]:             if j == (len(pattern) - 1):                 return i - j             j += 1          # if this is a prefix in our pattern         # just go back far enough to continue         elif j > 0:             j = failure[j - 1]             continue         i += 1     return -1", "output": "1"}
{"task": "search", "input": "search code:\nThis function is the inverse of :func:`itertools.accumulate`. By default\n\nChoices:\n0: def iter_merge_sort(input_list: list) -> list:     if len(input_list) <= 1:         return input_list     input_list = list(input_list)      # iteration for two-way merging     p = 2     while p <= len(input_list):         # getting low, high and middle value for merge-sort of single list         for i in range(0, len(input_list), p):             low = i             high = i + p - 1             mid = (low + high + 1) // 2             input_list = merge(input_list, low, mid, high)         # final merge of last two parts         if p * 2 >= len(input_list):             mid = i             input_list = merge(input_list, 0, mid, len(input_list) - 1)             break         p *= 2      return input_list\n1: def difference(iterable, func=sub, *, initial=None):     a, b = tee(iterable)     try:         first = [next(b)]     except StopIteration:         return iter([])      if initial is not None:         first = []      return chain(first, map(func, b, a))\n2: def lin_search(left: int, right: int, array: list[int], target: int) -> int:     for i in range(left, right):         if array[i] == target:             return i     return -1", "output": "1"}
{"task": "search", "input": "search code:\nReturn an \"absolute\" value for a timedelta, always representing a time distance.\n\nChoices:\n0: def fix_print_exception():     sys.excepthook = print_exception\n1: def _abs_timedelta(delta):     if delta.days < 0:         now = _now()         return now - (now + delta)     return delta\n2: def interquartile_range_checker(train_user: list) -> float:     train_user.sort()     q1 = np.percentile(train_user, 25)     q3 = np.percentile(train_user, 75)     iqr = q3 - q1     low_lim = q1 - (iqr * 0.1)     return float(low_lim)", "output": "1"}
{"task": "search", "input": "search code:\nReturns the sum of all the amicable numbers under n.\n\nChoices:\n0: def solution(n: int = 10000) -> int:     total = sum(         i         for i in range(1, n)         if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i     )     return total\n1: def ceil(x: float) -> int:     return int(x) if x - int(x) <= 0 else int(x) + 1\n2: def iter_index(iterable, value, start=0, stop=None):     seq_index = getattr(iterable, 'index', None)     if seq_index is None:         # Slow path for general iterables         iterator = islice(iterable, start, stop)         for i, element in enumerate(iterator, start):             if element is value or element == value:                 yield i     else:         # Fast path for sequences         stop = len(iterable) if stop is None else stop         i = start - 1         with suppress(ValueError):             while True:                 yield (i := seq_index(value, i + 1, stop))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef sum_of_digits_compact(n: int) -> int:\n    return sum(int(c) for c in str(abs(n)))", "output": "Find the sum of digits of a number"}
{"task": "search", "input": "search code:\nReturn True if this number is power of 4 or False otherwise.\n\nChoices:\n0: def is_ip_v4_address_valid(ip: str) -> bool:     octets = ip.split(\".\")     if len(octets) != 4:         return False      for octet in octets:         if not octet.isdigit():             return False          number = int(octet)         if len(str(number)) != len(octet):             return False          if not 0 <= number <= 255:             return False      return True\n1: def decipher(message: str, cipher_map: dict[str, str]) -> str:     # Reverse our cipher mappings     rev_cipher_map = {v: k for k, v in cipher_map.items()}     return \"\".join(rev_cipher_map.get(ch, ch) for ch in message.upper())\n2: def power_of_4(number: int) -> bool:     if not isinstance(number, int):         raise TypeError(\"number must be an integer\")     if number <= 0:         raise ValueError(\"number must be positive\")     if number & (number - 1) == 0:         c = 0         while number:             c += 1             number >>= 1         return c % 2 == 1     else:         return False", "output": "2"}
{"task": "detection", "input": "classify code:\ndef counting_sort(collection):\n    \"\"\"Pure implementation of counting sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> counting_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> counting_sort([])\n    []\n    >>> counting_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef median(nums):\n    \"\"\"Find median of a list of numbers.\"\"\"\n    # Sort list\n    sorted_list = sorted(nums)\n    print(\"List of numbers:\")\n    print(sorted_list)\n\n    # Is number of items in list even?\n    if len(sorted_list) % 2 == 0:\n        # Find index for first middle value.\n        mid_index_1 = len(sorted_list) / 2\n        # Find index for second middle value.\n        mid_index_2 = -(len(sorted_list) / 2) - 1\n        # Divide middle values by 2 to get average (mean).\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n        return med  # Return makes `else:` unnecessary.\n    # Number of items is odd.\n    mid_index = (len(sorted_list) - 1) / 2\n    # Middle index is median.\n    med = sorted_list[mid_index]\n    return med", "output": "def median(nums):\n    \"\"\"\n    Find median of a list of numbers.\n\n    >>> median([0])\n    0\n    >>> median([4,1,3,2])\n    2.5\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    med = None\n    if len(sorted_list) % 2 == 0:\n        mid_index_1 = len(sorted_list) // 2\n        mid_index_2 = (len(sorted_list) // 2) - 1\n        med = (sorted_list[mid_index_1] + sorted_list[mid_index_2]) / float(2)\n    else:\n        mid_index = (len(sorted_list) - 1) // 2\n        med = sorted_list[mid_index]\n    return med"}
{"task": "summary", "input": "summarize code:\ndef get_transitions(\n    start: str, transitions: list[tuple[str, str, float]], steps: int\n) -> dict[str, int]:\n\n    graph = MarkovChainGraphUndirectedUnweighted()\n\n    for node1, node2, probability in transitions:\n        graph.add_transition_probability(node1, node2, probability)\n\n    visited = Counter(graph.get_nodes())\n    node = start\n\n    for _ in range(steps):\n        node = graph.transition(node)\n        visited[node] += 1\n\n    return visited", "output": "Running Markov Chain algorithm and calculating the number of times each node is"}
{"task": "search", "input": "search code:\nPure Python implementation of P-Series algorithm\n\nChoices:\n0: def prime_generator() -> Iterator[int]:      num = 2     while True:         if is_prime(num):             yield num         num += 1\n1: def solution(n_digits: int = 20) -> int:     cache: dict[str, int] = {}     return solve(digit=n_digits, prev1=0, prev2=0, sum_max=9, first=True, cache=cache)\n2: def p_series(nth_term: float | str, power: float | str) -> list[str]:     if nth_term == \"\":         return [\"\"]     nth_term = int(nth_term)     power = int(power)     series: list[str] = []     for temp in range(int(nth_term)):         series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")     return series", "output": "2"}
{"task": "search", "input": "search code:\nCheck if vector is equal to (0, 0, 0) or not.\n\nChoices:\n0: def naturalday(value, format=\"%b %d\") -> str:     try:         value = dt.date(value.year, value.month, value.day)     except AttributeError:         # Passed value wasn't date-ish         return value     except (OverflowError, ValueError):         # Date arguments out of range         return value     delta = value - dt.date.today()     if delta.days == 0:         return _(\"today\")     elif delta.days == 1:         return _(\"tomorrow\")     elif delta.days == -1:         return _(\"yesterday\")     return value.strftime(format)\n1: def is_zero_vector(vector: Vector3d, accuracy: int) -> bool:     return tuple(round(x, accuracy) for x in vector) == (0, 0, 0)\n2: def find_unit_clauses(     clauses: list[Clause],     model: dict[str, bool | None],  # noqa: ARG001 ) -> tuple[list[str], dict[str, bool | None]]:     unit_symbols = []     for clause in clauses:         if len(clause) == 1:             unit_symbols.append(next(iter(clause.literals.keys())))         else:             f_count, n_count = 0, 0             for literal, value in clause.literals.items():                 if value is False:                     f_count += 1                 elif value is None:                     sym = literal                     n_count += 1             if f_count == len(clause) - 1 and n_count == 1:                 unit_symbols.append(sym)     assignment: dict[str, bool | None] = {}     for i in unit_symbols:         symbol = i[:2]         assignment[symbol] = len(i) == 2     unit_symbols = [i[:2] for i in unit_symbols]      return unit_symbols, assignment", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef nearest_neighbour_search(\n    root: KDNode | None, query_point: list[float]\n) -> tuple[list[float] | None, float, int]:\n    nearest_point: list[float] | None = None\n    nearest_dist: float = float(\"inf\")\n    nodes_visited: int = 0\n\n    def search(node: KDNode | None, depth: int = 0) -> None:\n        nonlocal nearest_point, nearest_dist, nodes_visited\n        if node is None:\n            return\n\n        nodes_visited += 1\n\n        # Calculate the current distance (squared distance)\n        current_point = node.point\n        current_dist = sum(\n            (query_coord - point_coord) ** 2\n            for query_coord, point_coord in zip(query_point, current_point)\n        )\n\n        # Update nearest point if the current node is closer\n        if nearest_point is None or current_dist < nearest_dist:\n            nearest_point = current_point\n            nearest_dist = current_dist\n\n        # Determine which subtree to search first (based on axis and query point)\n        k = len(query_point)  # Dimensionality of points\n        axis = depth % k\n\n        if query_point[axis] <= current_point[axis]:\n            nearer_subtree = node.left\n            further_subtree = node.right\n        else:\n            nearer_subtree = node.right\n            further_subtree = node.left\n\n        # Search the nearer subtree first\n        search(nearer_subtree, depth + 1)\n\n        # If the further subtree has a closer point\n        if (query_point[axis] - current_point[axis]) ** 2 < nearest_dist:\n            search(further_subtree, depth + 1)\n\n    search(root, 0)\n    return nearest_point, nearest_dist, nodes_visited", "output": "Performs a nearest neighbor search in a KD-Tree for a given query point."}
{"task": "search", "input": "search code:\nCalculate a Lorentz transformation for movement in the x direction given a\n\nChoices:\n0: def transform(velocity: float, event: np.ndarray | None = None) -> np.ndarray:     # Ensure event is not empty     if event is None:         event = np.array([ct, x, y, z])  # Symbolic four vector     else:         event[0] *= c  # x0 is ct (speed of light * time)      return transformation_matrix(velocity) @ event\n1: def solution(pence: int = 200) -> int:     coins = [1, 2, 5, 10, 20, 50, 100, 200]     number_of_ways = [0] * (pence + 1)     number_of_ways[0] = 1  # base case: 1 way to make 0 pence      for coin in coins:         for i in range(coin, pence + 1, 1):             number_of_ways[i] += number_of_ways[i - coin]     return number_of_ways[pence]\n2: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    answer = 1\n    gen = fibonacci_generator()\n    while len(str(next(gen))) < n:\n        answer += 1\n    return answer + 1", "output": "Returns the index of the first term in the Fibonacci sequence to contain"}
{"task": "repair", "input": "fix bug:\ndef vernam_encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_encrypt(\"HELLO\",\"KEY\")\n    'RIJVS'\n    \"\"\"\n    ciphertext = \"\"\n    for i in range(len(plaintext)):\n        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65\n        while ct > 25:\n            ct = ct - 26\n        ciphertext += chr(65 + ct)\n    return ciphertext", "output": "def vernam_encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_encrypt(\"HELLO\",\"KEY\")\n    'RIJVS'\n    \"\"\"\n    ciphertext = \"\"\n    for i in range(len(plaintext)):\n        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65\n        while ct > 25:\n            ct = ct - 26\n        ciphertext += chr(65 + ct)\n    return ciphertext"}
{"task": "detection", "input": "classify code:\ndef num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    \"\"\"\n    digits = 0\n    while n > 0:\n        n = n // 10\n        digits += 1\n    return digits", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFormat the exception part of a traceback.\n\nChoices:\n0: def solution(limit: int = 1_000_000) -> int:      # generating an array from -1 to limit     phi = np.arange(-1, limit)      for i in range(2, limit + 1):         if phi[i] == i - 1:             ind = np.arange(2 * i, limit + 1, i)  # indexes for selection             phi[ind] -= phi[ind] // i      return int(np.sum(phi[2 : limit + 1]))\n1: def format_exception_only(etype, value):     # Gracefully handle (the way Python 2.4 and earlier did) the case of     # being called with (None, None).     if etype is None:         return [_format_final_exc_line(etype, value)]      stype = etype.__name__     smod = etype.__module__     if smod not in (\"__main__\", \"builtins\", \"exceptions\"):         stype = smod + '.' + stype      if not issubclass(etype, SyntaxError):         return [_format_final_exc_line(stype, value)]      # It was a syntax error; show exactly where the problem was found.     lines = []     filename = value.filename or \"<string>\"     lineno = str(value.lineno) or '?'     lines.append(f'  File \"{filename}\", line {lineno}\\n')     badline = value.text     offset = value.offset     if badline is not None:         lines.append('    %s\\n' % badline.strip())         if offset is not None:             caretspace = badline.rstrip('\\n')[:offset].lstrip()             # non-space whitespace (likes tabs) must be kept for alignment             caretspace = ((c.isspace() and c or ' ') for c in caretspace)             # only three spaces to account for offset1 == pos 0             lines.append('   %s^\\n' % ''.join(caretspace))     msg = value.msg or \"<no detail available>\"     lines.append(f\"{stype}: {msg}\\n\")     return lines\n2: def split_when(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      it = iter(iterable)     try:         cur_item = next(it)     except StopIteration:         return      buf = [cur_item]     for next_item in it:         if pred(cur_item, next_item):             yield buf             if maxsplit == 1:                 yield [next_item, *it]                 return             buf = []             maxsplit -= 1          buf.append(next_item)         cur_item = next_item      yield buf", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef max_subarray_sum(\n    arr: Sequence[float], allow_empty_subarrays: bool = False\n) -> float:\n    if not arr:\n        return 0\n\n    max_sum = 0 if allow_empty_subarrays else float(\"-inf\")\n    curr_sum = 0.0\n    for num in arr:\n        curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "output": "Solves the maximum subarray sum problem using Kadane's algorithm."}
{"task": "search", "input": "search code:\nTransform each item from *iterable* with *function* and yield the\n\nChoices:\n0: def binary_search(array: list, lower_bound: int, upper_bound: int, value: int) -> int:      r = int((lower_bound + upper_bound) // 2)     if array[r] == value:         return r     if lower_bound >= upper_bound:         return -1     if array[r] < value:         return binary_search(array, r + 1, upper_bound, value)     else:         return binary_search(array, lower_bound, r - 1, value)\n1: def comp_and_swap(array: list[int], index1: int, index2: int, direction: int) -> None:     if (direction == 1 and array[index1] > array[index2]) or (         direction == 0 and array[index1] < array[index2]     ):         array[index1], array[index2] = array[index2], array[index1]\n2: def map_except(function, iterable, *exceptions):     for item in iterable:         try:             yield function(item)         except exceptions:             pass", "output": "2"}
{"task": "search", "input": "search code:\nFunction returns the multiplier value associated with the color.\n\nChoices:\n0: def erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:     output = np.zeros_like(image)     image_padded = np.zeros(         (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)     )      # Copy image to padded image     image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image      # Iterate over image & apply kernel     for x in range(image.shape[1]):         for y in range(image.shape[0]):             summation = (                 kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]             ).sum()             output[y, x] = int(summation == 5)     return output\n1: def get_multiplier(color: str) -> float:     if color not in multiplier_color_values:         msg = f\"{color} is not a valid color for multiplier band\"         raise ValueError(msg)     return multiplier_color_values[color]\n2: def inspect_formatargspec(         args, varargs=None, varkw=None, defaults=None,         kwonlyargs=(), kwonlydefaults={}, annotations={},         formatarg=str,         formatvarargs=lambda name: '*' + name,         formatvarkw=lambda name: '**' + name,         formatvalue=lambda value: '=' + repr(value),         formatreturns=lambda text: ' -> ' + text,         formatannotation=formatannotation):      def formatargandannotation(arg):         result = formatarg(arg)         if arg in annotations:             result += ': ' + formatannotation(annotations[arg])         return result     specs = []     if defaults:         firstdefault = len(args) - len(defaults)     for i, arg in enumerate(args):         spec = formatargandannotation(arg)         if defaults and i >= firstdefault:             spec = spec + formatvalue(defaults[i - firstdefault])         specs.append(spec)     if varargs is not None:         specs.append(formatvarargs(formatargandannotation(varargs)))     else:         if kwonlyargs:             specs.append('*')     if kwonlyargs:         for kwonlyarg in kwonlyargs:             spec = formatargandannotation(kwonlyarg)             if kwonlydefaults and kwonlyarg in kwonlydefaults:                 spec += formatvalue(kwonlydefaults[kwonlyarg])             specs.append(spec)     if varkw is not None:         specs.append(formatvarkw(formatargandannotation(varkw)))     result = '(' + ', '.join(specs) + ')'     if 'return' in annotations:         result += formatreturns(formatannotation(annotations['return']))     return result", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef nth_product(index, *args):\n    pools = list(map(tuple, reversed(args)))\n    ns = list(map(len, pools))\n\n    c = reduce(mul, ns)\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = []\n    for pool, n in zip(pools, ns):\n        result.append(pool[index % n])\n        index //= n\n\n    return tuple(reversed(result))", "output": "Equivalent to ``list(product(*args))[index]``."}
{"task": "search", "input": "search code:\nOutputs the answer is the least Fibonacci number pandigital from both sides.\n\nChoices:\n0: def solution() -> int:      a = 1     b = 1     c = 2     # temporary Fibonacci numbers      a1 = 1     b1 = 1     c1 = 2     # temporary Fibonacci numbers mod 1e9      # mod m=1e9, done for fast optimisation     tocheck = [0] * 1000000     m = 1000000000      for x in range(1000000):         c1 = (a1 + b1) % m         a1 = b1 % m         b1 = c1 % m         if check1(b1):             tocheck[x + 3] = 1      for x in range(1000000):         c = a + b         a = b         b = c         # perform check only if in tocheck         if tocheck[x + 3] and check(b):             return x + 3  # first 2 already done     return -1\n1: def butterfly_pattern(n: int) -> str:     result = []      # Upper part     for i in range(1, n):         left_stars = \"*\" * i         spaces = \" \" * (2 * (n - i) - 1)         right_stars = \"*\" * i         result.append(left_stars + spaces + right_stars)      # Middle part     result.append(\"*\" * (2 * n - 1))      # Lower part     for i in range(n - 1, 0, -1):         left_stars = \"*\" * i         spaces = \" \" * (2 * (n - i) - 1)         right_stars = \"*\" * i         result.append(left_stars + spaces + right_stars)      return \"\\n\".join(result)\n2: def oct_to_decimal(oct_string: str) -> int:     oct_string = str(oct_string).strip()     if not oct_string:         raise ValueError(\"Empty string was passed to the function\")     is_negative = oct_string[0] == \"-\"     if is_negative:         oct_string = oct_string[1:]     if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):         raise ValueError(\"Non-octal value was passed to the function\")     decimal_number = 0     for char in oct_string:         decimal_number = 8 * decimal_number + int(char)     if is_negative:         decimal_number = -decimal_number     return decimal_number", "output": "0"}
{"task": "search", "input": "search code:\nCreates a state space tree to iterate through each branch using DFS.\n\nChoices:\n0: def solution(num: int = 100) -> int:     return sum(map(int, str(factorial(num))))\n1: def fib_memoization(n: int) -> list[int]:     if n < 0:         raise ValueError(\"n is negative\")     # Cache must be outside recursive function     # other it will reset every time it calls itself.     cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache      def rec_fn_memoized(num: int) -> int:         if num in cache:             return cache[num]          value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)         cache[num] = value         return value      return [rec_fn_memoized(i) for i in range(n + 1)]\n2: def create_state_space_tree(     sequence: list[int | str],     current_sequence: list[int | str],     index: int,     index_used: list[int], ) -> None:      if index == len(sequence):         print(current_sequence)         return      for i in range(len(sequence)):         if not index_used[i]:             current_sequence.append(sequence[i])             index_used[i] = True             create_state_space_tree(sequence, current_sequence, index + 1, index_used)             current_sequence.pop()             index_used[i] = False", "output": "2"}
{"task": "search", "input": "search code:\nreturn true if the input integer is even\n\nChoices:\n0: def slow_reversible_numbers(     remaining_length: int, remainder: int, digits: list[int], length: int ) -> int:     if remaining_length == 0:         if digits[0] == 0 or digits[-1] == 0:             return 0          for i in range(length // 2 - 1, -1, -1):             remainder += digits[i] + digits[length - i - 1]              if remainder % 2 == 0:                 return 0              remainder //= 10          return 1      if remaining_length == 1:         if remainder % 2 == 0:             return 0          result = 0         for digit in range(10):             digits[length // 2] = digit             result += slow_reversible_numbers(                 0, (remainder + 2 * digit) // 10, digits, length             )         return result      result = 0     for digit1 in range(10):         digits[(length + remaining_length) // 2 - 1] = digit1          if (remainder + digit1) % 2 == 0:             other_parity_digits = ODD_DIGITS         else:             other_parity_digits = EVEN_DIGITS          for digit2 in other_parity_digits:             digits[(length - remaining_length) // 2] = digit2             result += slow_reversible_numbers(                 remaining_length - 2,                 (remainder + digit1 + digit2) // 10,                 digits,                 length,             )     return result\n1: def is_even(number: int) -> bool:     return number & 1 == 0\n2: def idft(Xarr):     N = len(Xarr)     roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]     for k in range(N):         coeffs = [roots_of_unity[k * n % N] for n in range(N)]         yield _complex_sumprod(Xarr, coeffs) / N", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef _running_median_minheap_only(iterator):  # pragma: no cover\n    \"Backport of non-windowed running_median() for Python 3.13 and prior.\"\n\n    read = iterator.__next__\n    lo = []  # max-heap (actually a minheap with negated values)\n    hi = []  # min-heap (same size as or one smaller than lo)\n\n    with suppress(StopIteration):\n        while True:\n            heappush(lo, -heappushpop(hi, read()))\n            yield -lo[0]\n\n            heappush(hi, -heappushpop(lo, -read()))\n            yield (hi[0] - lo[0]) / 2", "output": "Backport of non-windowed running_median() for Python 3.13 and prior."}
{"task": "search", "input": "search code:\nConverts a file path to a Python module\n\nChoices:\n0: def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:     check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2     check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002     check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002      return check_hue and check_saturation and check_value\n1: def convert_path_to_module(file_path: pathlib.Path) -> ModuleType:     spec = importlib.util.spec_from_file_location(file_path.name, str(file_path))     module = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]     spec.loader.exec_module(module)  # type: ignore[union-attr]     return module\n2: def indent(text, margin, newline='\\n', key=bool):     indented_lines = [(margin + line if key(line) else line)                       for line in iter_splitlines(text)]     return newline.join(indented_lines)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 30) -> int:\n    digit_to_powers = []\n    for digit in range(2, 100):\n        for power in range(2, 100):\n            number = int(math.pow(digit, power))\n            if digit == digit_sum(number):\n                digit_to_powers.append(number)\n\n    digit_to_powers.sort()\n    return digit_to_powers[n - 1]", "output": "Returns the value of 30th digit power sum."}
{"task": "repair", "input": "fix bug:\ndef odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr", "output": "def odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr"}
{"task": "search", "input": "search code:\nCount the number of minimum squares to represent a number\n\nChoices:\n0: def minimum_squares_to_represent_a_number(number: int) -> int:     if number != int(number):         raise ValueError(\"the value of input must be a natural number\")     if number < 0:         raise ValueError(\"the value of input must not be a negative number\")     if number == 0:         return 1     answers = [-1] * (number + 1)     answers[0] = 0     for i in range(1, number + 1):         answer = sys.maxsize         root = int(math.sqrt(i))         for j in range(1, root + 1):             current_answer = 1 + answers[i - (j**2)]             answer = min(answer, current_answer)         answers[i] = answer     return answers[number]\n1: def gnome_sort(lst: list) -> list:     if len(lst) <= 1:         return lst      i = 1      while i < len(lst):         if lst[i - 1] <= lst[i]:             i += 1         else:             lst[i - 1], lst[i] = lst[i], lst[i - 1]             i -= 1             if i == 0:                 i = 1      return lst\n2: def summarize_book(ol_book_data: dict) -> dict:     desired_keys = {         \"title\": \"Title\",         \"publish_date\": \"Publish date\",         \"authors\": \"Authors\",         \"number_of_pages\": \"Number of pages\",         \"isbn_10\": \"ISBN (10)\",         \"isbn_13\": \"ISBN (13)\",     }     data = {better_key: ol_book_data[key] for key, better_key in desired_keys.items()}     data[\"Authors\"] = [         get_openlibrary_data(author[\"key\"])[\"name\"] for author in data[\"Authors\"]     ]     for key, value in data.items():         if isinstance(value, list):             data[key] = \", \".join(value)     return data", "output": "0"}
{"task": "detection", "input": "classify code:\ndef alt_ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    >>> alt_ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> alt_ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    \"\"\"\n    return int(\"0x\" + \"\".join(f\"{int(i):02x}\" for i in ipv4_address.split(\".\")), 16)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef equilibrium_index(arr: list[int]) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5])\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1])\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3])\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i, value in enumerate(arr):\n        total_sum -= value\n        if left_sum == total_sum:\n            return i\n        left_sum += value\n\n    return -1", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef get_check_digit(barcode: int) -> int:\n    \"\"\"\n    Returns the last digit of barcode by excluding the last digit first\n    and then computing to reach the actual last digit from the remaining\n    12 digits.\n\n    >>> get_check_digit(8718452538119)\n    9\n    >>> get_check_digit(87184523)\n    5\n    >>> get_check_digit(87193425381086)\n    9\n    >>> [get_check_digit(x) for x in range(0, 100, 10)]\n    [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]\n    \"\"\"\n    barcode //= 10  # exclude the last digit\n    checker = False\n    s = 0\n\n    # extract and check each digit\n    while barcode != 0:\n        mult = 1 if checker else 3\n        s += mult * (barcode % 10)\n        barcode //= 10\n        checker = not checker\n\n    return (10 - (s % 10)) % 10", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn the no. of pairs with sum \"sum\"\n\nChoices:\n0: def pairs_with_sum(arr: list, req_sum: int) -> int:     return len([1 for a, b in combinations(arr, 2) if a + b == req_sum])\n1: def _is_matrix_spd(matrix: np.ndarray) -> bool:     # Ensure matrix is square.     assert np.shape(matrix)[0] == np.shape(matrix)[1]      # If matrix not symmetric, exit right away.     if np.allclose(matrix, matrix.T) is False:         return False      # Get eigenvalues and eignevectors for a symmetric matrix.     eigen_values, _ = np.linalg.eigh(matrix)      # Check sign of all eigenvalues.     # np.all returns a value of type np.bool_     return bool(np.all(eigen_values > 0))\n2: def iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:     vectors = initial_vectors     for _ in range(steps):         vectors = iteration_step(vectors)     return vectors", "output": "0"}
{"task": "search", "input": "search code:\nconstructs a list of points from an array-like object of numbers\n\nChoices:\n0: def generate_parentheses_iterative(length: int) -> list:     result = []     stack = []      # Each element in stack is a tuple (current_combination, open_count, close_count)     stack.append((\"\", 0, 0))      while stack:         current_combination, open_count, close_count = stack.pop()          if len(current_combination) == 2 * length:             result.append(current_combination)          if open_count < length:             stack.append((current_combination + \"(\", open_count + 1, close_count))          if close_count < open_count:             stack.append((current_combination + \")\", open_count, close_count + 1))      return result\n1: def _construct_points(     list_of_tuples: list[Point] | list[list[float]] | Iterable[list[float]], ) -> list[Point]:      points: list[Point] = []     if list_of_tuples:         for p in list_of_tuples:             if isinstance(p, Point):                 points.append(p)             else:                 try:                     points.append(Point(p[0], p[1]))                 except (IndexError, TypeError):                     print(                         f\"Ignoring deformed point {p}. All points\"                         \" must have at least 2 coordinates.\"                     )     return points\n2: def binary_mod_multiply(a: int, b: int, modulus: int) -> int:     res = 0     while b > 0:         if b & 1:             res = ((res % modulus) + (a % modulus)) % modulus          a += a         b >>= 1      return res", "output": "1"}
{"task": "search", "input": "search code:\nReturns the index of the first term in the Fibonacci sequence to contain\n\nChoices:\n0: def is_collection(obj):     return is_iterable(obj) and not isinstance(obj, (str, bytes))\n1: def solution(n: int = 1000) -> int:     f1, f2 = 1, 1     index = 2     while True:         i = 0         f = f1 + f2         f1, f2 = f2, f         index += 1         for _ in str(f):             i += 1         if i == n:             break     return index\n2: def assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:     if i == 0 and j == 0:         return []     elif ops[i][j][0] in {\"C\", \"R\"}:         seq = assemble_transformation(ops, i - 1, j - 1)         seq.append(ops[i][j])         return seq     elif ops[i][j][0] == \"D\":         seq = assemble_transformation(ops, i - 1, j)         seq.append(ops[i][j])         return seq     else:         seq = assemble_transformation(ops, i, j - 1)         seq.append(ops[i][j])         return seq", "output": "1"}
{"task": "detection", "input": "classify code:\ndef sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32", "output": "BUGGY"}
{"task": "search", "input": "search code:\ncalculate xor of the input values\n\nChoices:\n0: def binary_multiply(a: int, b: int) -> int:     res = 0     while b > 0:         if b & 1:             res += a          a += a         b >>= 1      return res\n1: def xor_gate(input_1: int, input_2: int) -> int:     return (input_1, input_2).count(0) % 2\n2: def ilen(iterable):     # This is the \"most beautiful of the fast variants\" of this function.     # If you think you can improve on it, please ensure that your version     # is both 10x faster and 10x more beautiful.     return sum(compress(repeat(1), zip(iterable)))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef nimply_gate(input_1: int, input_2: int) -> int:\n    return int(input_1 == 1 and input_2 == 0)", "output": "Calculate NIMPLY of the input values"}
{"task": "repair", "input": "fix bug:\ndef surface_area_cube(side_length: Union[int, float]) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * pow(side_length, 2)\r", "output": "def surface_area_cube(side_length: float) -> float:\r\n    \"\"\"\r\n    Calculate the Surface Area of a Cube.\r\n\r\n    >>> surface_area_cube(1)\r\n    6\r\n    >>> surface_area_cube(3)\r\n    54\r\n    \"\"\"\r\n    return 6 * side_length ** 2\r"}
{"task": "summary", "input": "summarize code:\ndef get_all(type_obj, include_subtypes=True):\n    # TODO: old-style classes\n    if not isinstance(type_obj, type):\n        raise TypeError('expected a type, not %r' % type_obj)\n    try:\n        type_is_tracked = gc.is_tracked(type_obj)\n    except AttributeError:\n        type_is_tracked = False  # Python 2.6 and below don't get the speedup\n    if type_is_tracked:\n        to_check = gc.get_referrers(type_obj)\n    else:\n        to_check = gc.get_objects()\n\n    if include_subtypes:\n        ret = [x for x in to_check if isinstance(x, type_obj)]\n    else:\n        ret = [x for x in to_check if type(x) is type_obj]\n    return ret", "output": "Get a list containing all instances of a given type. This will"}
{"task": "summary", "input": "summarize code:\ndef remove_prefix(data_bits: str) -> str:\n    counter = 0\n    for letter in data_bits:\n        if letter == \"1\":\n            break\n        counter += 1\n\n    data_bits = data_bits[counter:]\n    data_bits = data_bits[counter + 1 :]\n    return data_bits", "output": "Removes size prefix, that compressed file should have"}
{"task": "search", "input": "search code:\nImplementation of breadth first search using collection.queue.\n\nChoices:\n0: def breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:     visited = {start}     result = [start]     queue = deque([start])     while queue:         v = queue.popleft()         for child in graph[v]:             if child not in visited:                 visited.add(child)                 result.append(child)                 queue.append(child)     return result\n1: def activate(locale, path=None):     if path is None:         path = _get_default_locale_path()      if path is None:         raise Exception(             \"Humanize cannot determinate the default location of the 'locale' folder. \"             \"You need to pass the path explicitly.\"         )     if locale not in _TRANSLATIONS:         translation = gettext_module.translation(\"humanize\", path, [locale])         _TRANSLATIONS[locale] = translation     _CURRENT.locale = locale     return _TRANSLATIONS[locale]\n2: def not_32(i: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")      i_str = format(i, \"032b\")     new_str = \"\"     for c in i_str:         new_str += \"1\" if c == \"0\" else \"0\"     return int(new_str, 2)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef lomuto_partition(sorting: list, left: int, right: int) -> int:\n    \"\"\"\n    Example:\n    >>> lomuto_partition([1,5,7,6], 0, 3)\n    2\n    \"\"\"\n    pivot = sorting[right]\n    store_index = left\n    for i in range(left, right):\n        if sorting[i] < pivot:\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\n            store_index += 1\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\n    return store_index", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the sequence elements *n* times\n\nChoices:\n0: def ncycles(iterable, n):     return chain.from_iterable(repeat(tuple(iterable), n))\n1: def interleave_evenly(iterables, lengths=None):     if lengths is None:         try:             lengths = [len(it) for it in iterables]         except TypeError:             raise ValueError(                 'Iterable lengths could not be determined automatically. '                 'Specify them with the lengths keyword.'             )     elif len(iterables) != len(lengths):         raise ValueError('Mismatching number of iterables and lengths.')      dims = len(lengths)      # sort iterables by length, descending     lengths_permute = sorted(         range(dims), key=lambda i: lengths[i], reverse=True     )     lengths_desc = [lengths[i] for i in lengths_permute]     iters_desc = [iter(iterables[i]) for i in lengths_permute]      # the longest iterable is the primary one (Bresenham: the longest     # distance along an axis)     delta_primary, deltas_secondary = lengths_desc[0], lengths_desc[1:]     iter_primary, iters_secondary = iters_desc[0], iters_desc[1:]     errors = [delta_primary // dims] * len(deltas_secondary)      to_yield = sum(lengths)     while to_yield:         yield next(iter_primary)         to_yield -= 1         # update errors for each secondary iterable         errors = [e - delta for e, delta in zip(errors, deltas_secondary)]          # those iterables for which the error is negative are yielded         # (\"diagonal step\" in Bresenham)         for i, e_ in enumerate(errors):             if e_ < 0:                 yield next(iters_secondary[i])                 to_yield -= 1                 errors[i] += delta_primary\n2: def sieve(n):     # This implementation comes from an older version of the itertools     # documentation.  The newer implementation is easier to read but is     # less lazy.     if n > 2:         yield 2     start = 3     data = bytearray((0, 1)) * (n // 2)     for p in iter_index(data, 1, start, stop=isqrt(n) + 1):         yield from iter_index(data, 1, start, p * p)         data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))         start = p * p     yield from iter_index(data, 1, start)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(number: int = 10000000) -> int:\n    for i in range(1, number):\n        if CHAINS[i] is None:\n            chain(i + 1)\n\n    return CHAINS[:number].count(False)", "output": "The function returns the number of integers that end up being 89 in each chain."}
{"task": "summary", "input": "summarize code:\ndef choose(n: int, r: int) -> int:\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)", "output": "Calculate the binomial coefficient c(n,r) using the multiplicative formula."}
{"task": "detection", "input": "classify code:\ndef check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - ord(\"a\")] = True\n    return all(flag)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef contains_an_even_digit(n: int) -> bool:\n    \"\"\"\n    Return True if n contains an even digit.\n    >>> contains_an_even_digit(0)\n    True\n    >>> contains_an_even_digit(975317933)\n    False\n    >>> contains_an_even_digit(-245679)\n    True\n    \"\"\"\n    return any(digit in \"02468\" for digit in str(n))", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef geometric_series(nth_term: int, start_term_a: int, common_ratio_r: int) -> list:\n    \"\"\"Pure Python implementation of Geometric Series algorithm\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, '4.41', '9.261000000000001', '19.448100000000004']\n    >>> geometric_series(4, 2, -2)\n    [2, '-4.0', '8.0', '-16.0']\n    >>> geometric_series(4, -2, 2)\n    [-2, '-4.0', '-8.0', '-16.0']\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if \"\" in (nth_term, start_term_a, common_ratio_r):\n        return \"\"\n    series = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(str(float(start_term_a) * float(multiple)))\n            multiple = pow(float(common_ratio_r), power)\n    return series", "output": "def geometric_series(\n    nth_term: float | int,\n    start_term_a: float | int,\n    common_ratio_r: float | int,\n) -> list[float | int]:\n    \"\"\"\n    Pure Python implementation of Geometric Series algorithm\n\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\n    >>> geometric_series(4, 2, -2)\n    [2, -4.0, 8.0, -16.0]\n    >>> geometric_series(4, -2, 2)\n    [-2, -4.0, -8.0, -16.0]\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float | int] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series"}
{"task": "search", "input": "search code:\nYield the circular shifts of *iterable*.\n\nChoices:\n0: def decimal_to_negative_base_2(num: int) -> int:     if num == 0:         return 0     ans = \"\"     while num != 0:         num, rem = divmod(num, -2)         if rem < 0:             rem += 2             num += 1         ans = str(rem) + ans     return int(ans)\n1: def circular_shifts(iterable, steps=1):     buffer = deque(iterable)     if steps == 0:         raise ValueError('Steps should be a non-zero integer')      buffer.rotate(steps)     steps = -steps     n = len(buffer)     n //= math.gcd(n, steps)      for _ in repeat(None, n):         buffer.rotate(steps)         yield tuple(buffer)\n2: def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:     result = [0] * (gon_side * 3)     result[0:3] = perm[0:3]     perm.append(perm[1])      magic_number = 1 if gon_side < 5 else 2      for i in range(1, len(perm) // 3 + magic_number):         result[3 * i] = perm[2 * i + 1]         result[3 * i + 1] = result[3 * i - 1]         result[3 * i + 2] = perm[2 * i + 2]      return result", "output": "1"}
{"task": "detection", "input": "classify code:\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid's Algorithm\n\n    >>> greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    >>> greatest_common_divisor(121, 11)\n    11\n\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while a % b != 0:\n        a, b = b, a % b\n\n    return b", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef level_order(root: Node | None) -> Generator[int]:\n\n    if root is None:\n        return\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        yield node.data\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)", "output": "Returns a list of nodes value from a whole binary tree in Level Order Traverse."}
{"task": "search", "input": "search code:\n\"\n\nChoices:\n0: def mark_ends(iterable):     it = iter(iterable)     for a in it:         first = True         for b in it:             yield first, False, a             a = b             first = False         yield first, True, a\n1: def sum_of_geometric_progression(     first_term: int, common_ratio: int, num_of_terms: int ) -> float:     if common_ratio == 1:         # Formula for sum if common ratio is 1         return num_of_terms * first_term      # Formula for finding sum of n terms of a GeometricProgression     return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)\n2: def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:     result = [0] * (gon_side * 3)     result[0:3] = perm[0:3]     perm.append(perm[1])      magic_number = 1 if gon_side < 5 else 2      for i in range(1, len(perm) // 3 + magic_number):         result[3 * i] = perm[2 * i + 1]         result[3 * i + 1] = result[3 * i - 1]         result[3 * i + 2] = perm[2 * i + 2]      return result", "output": "1"}
{"task": "detection", "input": "classify code:\ndef fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection", "output": "BUGGY"}
{"task": "search", "input": "search code:\nProcesses a single move, updating the matrix and calculating the score.\n\nChoices:\n0: def my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:     kernels = {         1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),         3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),         5: np.array(             [                 [0, 0, -1, 0, 0],                 [0, -1, -2, -1, 0],                 [-1, -2, 16, -2, -1],                 [0, -1, -2, -1, 0],                 [0, 0, -1, 0, 0],             ]         ),         7: np.array(             [                 [0, 0, 0, -1, 0, 0, 0],                 [0, 0, -2, -3, -2, 0, 0],                 [0, -2, -7, -10, -7, -2, 0],                 [-1, -3, -10, 68, -10, -3, -1],                 [0, -2, -7, -10, -7, -2, 0],                 [0, 0, -2, -3, -2, 0, 0],                 [0, 0, 0, -1, 0, 0, 0],             ]         ),     }     if ksize not in kernels:         msg = f\"ksize must be in {tuple(kernels)}\"         raise ValueError(msg)      # Apply the Laplacian kernel using convolution     return filter2D(         src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)     )\n1: def play(     matrix_g: list[list[str]], pos_x: int, pos_y: int, size: int ) -> tuple[list[list[str]], int]:      same_colors = find_repeat(matrix_g, pos_x, pos_y, size)      if len(same_colors) != 0:         for pos in same_colors:             matrix_g[pos[0]][pos[1]] = \"-\"         for column in range(size):             matrix_g = move_x(matrix_g, column, size)          matrix_g = move_y(matrix_g, size)      return (matrix_g, increment_score(len(same_colors)))\n2: def unique_everseen(iterable, key=None):     seenset = set()     seenset_add = seenset.add     seenlist = []     seenlist_add = seenlist.append     use_key = key is not None      for element in iterable:         k = key(element) if use_key else element         try:             if k not in seenset:                 seenset_add(k)                 yield element         except TypeError:             if k not in seenlist:                 seenlist_add(k)                 yield element", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef unique_justseen(iterable, key=None):\n    if key is None:\n        return map(itemgetter(0), groupby(iterable))\n\n    return map(next, map(itemgetter(1), groupby(iterable, key)))", "output": "Yields elements in order, ignoring serial duplicates"}
{"task": "summary", "input": "summarize code:\ndef check(number: int) -> bool:\n\n    check_last = [0] * 11\n    check_front = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    if not f:\n        return f\n\n    # mark first 9 numbers\n    number = int(str(number)[:9])\n\n    for _ in range(9):\n        check_front[int(number % 10)] = 1\n        number = number // 10\n\n    # check first 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_front[x + 1]:\n            f = False\n    return f", "output": "Takes a number and checks if it is pandigital both from start and end"}
{"task": "search", "input": "search code:\nChecks if a matrix is Hermitian.\n\nChoices:\n0: def adjacent(predicate, iterable, distance=1):     # Allow distance=0 mainly for testing that it reproduces results with map()     if distance < 0:         raise ValueError('distance must be at least 0')      i1, i2 = tee(iterable)     padding = [False] * distance     selected = chain(padding, map(predicate, i1), padding)     adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))     return zip(adjacent_to_selected, i2)\n1: def go_next(i: int, z_result: list[int], s: str) -> bool:     return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]\n2: def is_hermitian(matrix: np.ndarray) -> bool:     return np.array_equal(matrix, matrix.conjugate().T)", "output": "2"}
{"task": "search", "input": "search code:\nCalculate the weight of every point in the training data around a given\n\nChoices:\n0: def weight_matrix(point: np.ndarray, x_train: np.ndarray, tau: float) -> np.ndarray:     m = len(x_train)  # Number of training samples     weights = np.eye(m)  # Initialize weights as identity matrix     for j in range(m):         diff = point - x_train[j]         weights[j, j] = np.exp(diff @ diff.T / (-2.0 * tau**2))      return weights\n1: def avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:     arr = np.array(arr)     if arr.shape[0] != arr.shape[1]:         raise ValueError(\"The input array is not a square matrix\")     i = 0     j = 0     mat_i = 0     mat_j = 0      # compute the shape of the output matrix     avgpool_shape = (arr.shape[0] - size) // stride + 1     # initialize the output matrix with zeros of shape avgpool_shape     updated_arr = np.zeros((avgpool_shape, avgpool_shape))      while i < arr.shape[0]:         # if the end of the matrix is reached, break         if i + size > arr.shape[0]:             break         while j < arr.shape[1]:             # if the end of the matrix is reached, break             if j + size > arr.shape[1]:                 break             # compute the average of the pooling matrix             updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))             # shift the pooling matrix by stride of column pixels             j += stride             mat_j += 1          # shift the pooling matrix by stride of row pixels         i += stride         mat_i += 1         # reset the column index to 0         j = 0         mat_j = 0      return updated_arr\n2: def solution(nth: int = 10001) -> int:      try:         nth = int(nth)     except (TypeError, ValueError):         raise TypeError(\"Parameter nth must be int or castable to int.\") from None     if nth <= 0:         raise ValueError(\"Parameter nth must be greater than or equal to one.\")     primes: list[int] = []     num = 2     while len(primes) < nth:         if is_prime(num):             primes.append(num)             num += 1         else:             num += 1     return primes[len(primes) - 1]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef constrained_batches(\n    iterable, max_size, max_count=None, get_len=len, strict=True\n):\n    if max_size <= 0:\n        raise ValueError('maximum size must be greater than zero')\n\n    batch = []\n    batch_size = 0\n    batch_count = 0\n    for item in iterable:\n        item_len = get_len(item)\n        if strict and item_len > max_size:\n            raise ValueError('item size exceeds maximum size')\n\n        reached_count = batch_count == max_count\n        reached_size = item_len + batch_size > max_size\n        if batch_count and (reached_size or reached_count):\n            yield tuple(batch)\n            batch.clear()\n            batch_size = 0\n            batch_count = 0\n\n        batch.append(item)\n        batch_size += item_len\n        batch_count += 1\n\n    if batch:\n        yield tuple(batch)", "output": "Yield batches of items from *iterable* with a combined size limited by"}
{"task": "search", "input": "search code:\nDivide the elements from *iterable* into *n* parts, maintaining\n\nChoices:\n0: def quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:      if a == 0:         raise ValueError(\"Coefficient 'a' must not be zero.\")     delta = b * b - 4 * a * c      root_1 = (-b + sqrt(delta)) / (2 * a)     root_2 = (-b - sqrt(delta)) / (2 * a)      return (         root_1.real if not root_1.imag else root_1,         root_2.real if not root_2.imag else root_2,     )\n1: def combination_sum_iv_dp_array(array: list[int], target: int) -> int:      def count_of_possible_combinations_with_dp_array(         target: int, dp_array: list[int]     ) -> int:         if target < 0:             return 0         if target == 0:             return 1         if dp_array[target] != -1:             return dp_array[target]         answer = sum(             count_of_possible_combinations_with_dp_array(target - item, dp_array)             for item in array         )         dp_array[target] = answer         return answer      dp_array = [-1] * (target + 1)     return count_of_possible_combinations_with_dp_array(target, dp_array)\n2: def divide(n, iterable):     if n < 1:         raise ValueError('n must be at least 1')      try:         iterable[:0]     except TypeError:         seq = tuple(iterable)     else:         seq = iterable      q, r = divmod(len(seq), n)      ret = []     stop = 0     for i in range(1, n + 1):         start = stop         stop += q + 1 if i <= r else q         ret.append(iter(seq[start:stop]))      return ret", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    data_x, _data_y = collect_dataset()\n\n    # Number of principal components to retain\n    n_components = 2\n\n    # Apply PCA\n    transformed_data, variance_ratio = apply_pca(data_x, n_components)\n\n    print(\"Transformed Dataset (First 5 rows):\")\n    print(transformed_data[:5])\n\n    print(\"\\nExplained Variance Ratio:\")\n    print(variance_ratio)", "output": "Driver function to execute PCA and display results."}
{"task": "summary", "input": "summarize code:\ndef decrypt_message(\n    message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5\n) -> str:\n    message, alphabet, character_to_number, number_to_character = __prepare(\n        message, alphabet\n    )\n\n    decrypted_numeric = []\n    for i in range(0, len(message), period):\n        a, b, c = __decrypt_part(message[i : i + period], character_to_number)\n\n        for j in range(len(a)):\n            decrypted_numeric.append(a[j] + b[j] + c[j])\n\n    return \"\".join(number_to_character[each] for each in decrypted_numeric)", "output": "decrypt_message"}
{"task": "repair", "input": "fix bug:\ndef sum_of_harmonic_progression(\n    first_term: float, common_difference: float, number_of_terms: int\n) -> float:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)\n\n    Find the sum of n terms in an harmonic progression.  The calculation starts with the\n    first_term and loops adding the common difference of Arithmetic Progression by which\n    the given Harmonic Progression is linked.\n\n    >>> sum_of_harmonic_progression(1 / 2, 2, 2)\n    0.75\n    >>> sum_of_harmonic_progression(1 / 5, 5, 5)\n    0.45666666666666667\n    \"\"\"\n    arithmetic_progression = [1 / first_term]\n    first_term = 1 / first_term\n    for _ in range(number_of_terms - 1):\n        first_term += common_difference\n        arithmetic_progression.append(first_term)\n    harmonic_series = [1 / step for step in arithmetic_progression]\n    return sum(harmonic_series)", "output": "def sum_of_harmonic_progression(\n    first_term: float, common_difference: float, number_of_terms: int\n) -> float:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)\n\n    Find the sum of n terms in an harmonic progression.  The calculation starts with the\n    first_term and loops adding the common difference of Arithmetic Progression by which\n    the given Harmonic Progression is linked.\n\n    >>> sum_of_harmonic_progression(1 / 2, 2, 2)\n    0.75\n    >>> sum_of_harmonic_progression(1 / 5, 5, 5)\n    0.45666666666666667\n    \"\"\"\n    arithmetic_progression = [1 / first_term]\n    first_term = 1 / first_term\n    for _ in range(number_of_terms - 1):\n        first_term += common_difference\n        arithmetic_progression.append(first_term)\n    harmonic_series = [1 / step for step in arithmetic_progression]\n    return sum(harmonic_series)"}
{"task": "repair", "input": "fix bug:\ndef atbash_slow(sequence: str) -> str:\n    \"\"\"\n    >>> atbash_slow(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash_slow(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    output = \"\"\n    for i in sequence:\n        extract = ord(i)\n        if 65 <= extract <= 90:\n            output += chr(155 - extract)\n        elif 97 <= extract <= 122:\n            output += chr(219 - extract)\n        else:\n            output += i\n    return output", "output": "def atbash_slow(sequence: str) -> str:\n    \"\"\"\n    >>> atbash_slow(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash_slow(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    output = \"\"\n    for i in sequence:\n        extract = ord(i)\n        if 65 <= extract <= 90:\n            output += chr(155 - extract)\n        elif 97 <= extract <= 122:\n            output += chr(219 - extract)\n        else:\n            output += i\n    return output"}
{"task": "summary", "input": "summarize code:\ndef calculate_variance(items: list, means: list, total_count: int) -> float:\n    squared_diff = []  # An empty list to store all squared differences\n    # iterate over number of elements in items\n    for i in range(len(items)):\n        # for loop iterates over number of elements in inner layer of items\n        for j in range(len(items[i])):\n            # appending squared differences to 'squared_diff' list\n            squared_diff.append((items[i][j] - means[i]) ** 2)\n\n    # one divided by (the number of all instances - number of classes) multiplied by\n    # sum of all squared differences\n    n_classes = len(means)  # Number of classes in dataset\n    return 1 / (total_count - n_classes) * sum(squared_diff)", "output": "Calculate the variance"}
{"task": "search", "input": "search code:\nPercent-decode a string, by replacing %xx escapes with their\n\nChoices:\n0: def lower(word: str) -> str:      # Converting to ASCII value, obtaining the integer representation     # and checking to see if the character is a capital letter.     # If it is a capital letter, it is shifted by 32, making it a lowercase letter.     return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)\n1: def unquote(string, encoding='utf-8', errors='replace'):     if '%' not in string:         string.split         return string     if encoding is None:         encoding = 'utf-8'     if errors is None:         errors = 'replace'     bits = _ASCII_RE.split(string)     res = [bits[0]]     append = res.append     for i in range(1, len(bits), 2):         append(unquote_to_bytes(bits[i]).decode(encoding, errors))         append(bits[i + 1])     return ''.join(res)\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef _is_matrix_spd(matrix: np.ndarray) -> bool:\n    # Ensure matrix is square.\n    assert np.shape(matrix)[0] == np.shape(matrix)[1]\n\n    # If matrix not symmetric, exit right away.\n    if np.allclose(matrix, matrix.T) is False:\n        return False\n\n    # Get eigenvalues and eignevectors for a symmetric matrix.\n    eigen_values, _ = np.linalg.eigh(matrix)\n\n    # Check sign of all eigenvalues.\n    # np.all returns a value of type np.bool_\n    return bool(np.all(eigen_values > 0))", "output": "Returns True if input matrix is symmetric positive definite."}
{"task": "search", "input": "search code:\nYield the items from *iterable* that haven't been seen recently.\n\nChoices:\n0: def unique_in_window(iterable, n, key=None):     if n <= 0:         raise ValueError('n must be greater than 0')      window = deque(maxlen=n)     counts = Counter()     use_key = key is not None      for item in iterable:         if len(window) == n:             to_discard = window[0]             if counts[to_discard] == 1:                 del counts[to_discard]             else:                 counts[to_discard] -= 1          k = key(item) if use_key else item         if k not in counts:             yield item         counts[k] += 1         window.append(k)\n1: def bell_numbers(max_set_length: int) -> list[int]:     if max_set_length < 0:         raise ValueError(\"max_set_length must be non-negative\")      bell = [0] * (max_set_length + 1)     bell[0] = 1      for i in range(1, max_set_length + 1):         for j in range(i):             bell[i] += _binomial_coefficient(i - 1, j) * bell[j]      return bell\n2: def is_prime(number: int) -> bool:      # precondition     if not isinstance(number, int) or not number >= 0:         raise ValueError(\"is_prime() only accepts positive integers\")      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "0"}
{"task": "detection", "input": "classify code:\ndef add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1001) -> int:\n    total = 1\n\n    for i in range(1, ceil(n / 2.0)):\n        odd = 2 * i + 1\n        even = 2 * i\n        total = total + 4 * odd**2 - 6 * even\n\n    return total", "output": "Returns the sum of the numbers on the diagonals in a n by n spiral"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 2000000) -> int:\n\n    return sum(num for num in range(3, n, 2) if is_prime(num)) + 2 if n > 2 else 0", "output": "Returns the sum of all the primes below n."}
{"task": "repair", "input": "fix bug:\ndef kth_permutation(k, n):\n    \"\"\"\n    Finds k'th lexicographic permutation (in increasing order) of\n    0,1,2,...n-1 in O(n^2) time.\n\n    Examples:\n    First permutation is always 0,1,2,...n\n    >>> kth_permutation(0,5)\n    [0, 1, 2, 3, 4]\n\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n    [1,2,3,0], [1,3,0,2]\n    >>> kth_permutation(10,4)\n    [1, 3, 0, 2]\n    \"\"\"\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation", "output": "def kth_permutation(k, n):\n    \"\"\"\n    Finds k'th lexicographic permutation (in increasing order) of\n    0,1,2,...n-1 in O(n^2) time.\n\n    Examples:\n    First permutation is always 0,1,2,...n\n    >>> kth_permutation(0,5)\n    [0, 1, 2, 3, 4]\n\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n    [1,2,3,0], [1,3,0,2]\n    >>> kth_permutation(10,4)\n    [1, 3, 0, 2]\n    \"\"\"\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation"}
{"task": "detection", "input": "classify code:\ndef match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns a 2-tuple of iterables derived from the input iterable.\n\nChoices:\n0: def solution(max_perimeter: int = 10**9) -> int:      prev_value = 1     value = 2      perimeters_sum = 0     i = 0     perimeter = 0     while perimeter <= max_perimeter:         perimeters_sum += perimeter          prev_value += 2 * value         value += prev_value          perimeter = 2 * value + 2 if i % 2 == 0 else 2 * value - 2         i += 1      return perimeters_sum\n1: def partition(pred, iterable):     if pred is None:         pred = bool      t1, t2, p = tee(iterable, 3)     p1, p2 = tee(map(pred, p))     return (compress(t1, map(not_, p1)), compress(t2, p2))\n2: def solution(max_d: int = 12_000) -> int:      fractions_number = 0     for d in range(max_d + 1):         n_start = d // 3 + 1         n_step = 1         if d % 2 == 0:             n_start += 1 - n_start % 2             n_step = 2         for n in range(n_start, (d + 1) // 2, n_step):             if gcd(n, d) == 1:                 fractions_number += 1     return fractions_number", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef is_palindrome_stack(head: ListNode | None) -> bool:\n    if not head or not head.next_node:\n        return True\n\n    # 1. Get the midpoint (slow)\n    slow: ListNode | None = head\n    fast: ListNode | None = head\n    while fast and fast.next_node:\n        fast = fast.next_node.next_node\n        slow = slow.next_node if slow else None\n\n    # slow will always be defined,\n    # adding this check to resolve mypy static check\n    if slow:\n        stack = [slow.val]\n\n        # 2. Push the second half into the stack\n        while slow.next_node:\n            slow = slow.next_node\n            stack.append(slow.val)\n\n        # 3. Comparison\n        cur: ListNode | None = head\n        while stack and cur:\n            if stack.pop() != cur.val:\n                return False\n            cur = cur.next_node\n\n    return True", "output": "Check if a linked list is a palindrome using a stack."}
{"task": "detection", "input": "classify code:\ndef _count_cross_inversions(p, q):\n    \"\"\"\n    Counts the inversions across two sorted arrays.\n    And combine the two arrays into one sorted array\n    For all 1<= i<=len(P) and for all 1 <= j <= len(Q),\n    if P[i] > Q[j], then (i, j) is a cross inversion\n    Parameters\n    ----------\n    P: array-like, sorted in non-decreasing order\n    Q: array-like, sorted in non-decreasing order\n    Returns\n    ------\n    R: array-like, a sorted array of the elements of `P` and `Q`\n    num_inversion: int, the number of inversions across `P` and `Q`\n    Examples\n    --------\n    >>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\n    ([0, 1, 2, 2, 3, 5], 4)\n    >>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\n    ([1, 2, 3, 3, 4, 5], 0)\n    \"\"\"\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion", "output": "BUGGY"}
{"task": "search", "input": "search code:\nImplementation of addition of integer\n\nChoices:\n0: def add(first: int, second: int) -> int:     while second != 0:         c = first & second         first ^= second         second = c << 1     return first\n1: def iter_index(iterable, value, start=0, stop=None):     seq_index = getattr(iterable, 'index', None)     if seq_index is None:         # Slow path for general iterables         iterator = islice(iterable, start, stop)         for i, element in enumerate(iterator, start):             if element is value or element == value:                 yield i     else:         # Fast path for sequences         stop = len(iterable) if stop is None else stop         i = start - 1         with suppress(ValueError):             while True:                 yield (i := seq_index(value, i + 1, stop))\n2: def filter_common_word(possibles: list[str], common_word: str) -> list[str]:     return [possible for possible in possibles if common_word in possible.lower()]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef emitter_converter(size_par, data):\n    if size_par + len(data) <= 2**size_par - (len(data) - 1):\n        raise ValueError(\"size of parity don't match with size of data\")\n\n    data_out = []\n    parity = []\n    bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]\n\n    # sorted information data for the size of the output data\n    data_ord = []\n    # data position template + parity\n    data_out_gab = []\n    # parity bit counter\n    qtd_bp = 0\n    # counter position of data bits\n    cont_data = 0\n\n    for x in range(1, size_par + len(data) + 1):\n        # Performs a template of bit positions - who should be given,\n        # and who should be parity\n        if qtd_bp < size_par:\n            if (np.log(x) / np.log(2)).is_integer():\n                data_out_gab.append(\"P\")\n                qtd_bp = qtd_bp + 1\n            else:\n                data_out_gab.append(\"D\")\n        else:\n            data_out_gab.append(\"D\")\n\n        # Sorts the data to the new output size\n        if data_out_gab[-1] == \"D\":\n            data_ord.append(data[cont_data])\n            cont_data += 1\n        else:\n            data_ord.append(None)\n\n    # Calculates parity\n    qtd_bp = 0  # parity bit counter\n    for bp in range(1, size_par + 1):\n        # Bit counter one for a given parity\n        cont_bo = 0\n        # counter to control the loop reading\n        for cont_loop, x in enumerate(data_ord):\n            if x is not None:\n                try:\n                    aux = (bin_pos[cont_loop])[-1 * (bp)]\n                except IndexError:\n                    aux = \"0\"\n                if aux == \"1\" and x == \"1\":\n                    cont_bo += 1\n        parity.append(cont_bo % 2)\n\n        qtd_bp += 1\n\n    # Mount the message\n    cont_bp = 0  # parity bit counter\n    for x in range(size_par + len(data)):\n        if data_ord[x] is None:\n            data_out.append(str(parity[cont_bp]))\n            cont_bp += 1\n        else:\n            data_out.append(data_ord[x])\n\n    return data_out", "output": "- bits of information merged with parity bits"}
{"task": "detection", "input": "classify code:\ndef combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations with using bottom up approach,\n    and returns the count of possible combination in O(N^2) Time Complexity\n    as we are using Dynamic programming array here.\n\n    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    dp_array = [0] * (target + 1)\n    dp_array[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - array[j] >= 0:\n                dp_array[i] += dp_array[i - array[j]]\n\n    return dp_array[target]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nWhile :meth:`str.split` will split on whitespace,\n\nChoices:\n0: def split_punct_ws(text):     return [w for w in _punct_re.split(text) if w]\n1: def mobius(n: int) -> int:     factors = prime_factors(n)     if is_square_free(factors):         return -1 if len(factors) % 2 else 1     return 0\n2: def is_hermitian(matrix: np.ndarray) -> bool:     return np.array_equal(matrix, matrix.conjugate().T)", "output": "0"}
{"task": "search", "input": "search code:\nTake in 2 integers, convert them to binary,\n\nChoices:\n0: def patience_sort(collection: list) -> list:     stacks: list[Stack] = []     # sort into stacks     for element in collection:         new_stacks = Stack([element])         i = bisect_left(stacks, new_stacks)         if i != len(stacks):             stacks[i].append(element)         else:             stacks.append(new_stacks)      # use a heap-based merge to merge stack efficiently     collection[:] = merge(*(reversed(stack) for stack in stacks))     return collection\n1: def solution(n: int = 30) -> int:     digit_to_powers = []     for digit in range(2, 100):         for power in range(2, 100):             number = int(math.pow(digit, power))             if digit == digit_sum(number):                 digit_to_powers.append(number)      digit_to_powers.sort()     return digit_to_powers[n - 1]\n2: def binary_and(a: int, b: int) -> str:     if a < 0 or b < 0:         raise ValueError(\"the value of both inputs must be positive\")      a_binary = format(a, \"b\")     b_binary = format(b, \"b\")      max_len = max(len(a_binary), len(b_binary))      return \"0b\" + \"\".join(         str(int(char_a == \"1\" and char_b == \"1\"))         for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))     )", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef windowed_complete(iterable, n):\n    if n < 0:\n        raise ValueError('n must be >= 0')\n\n    seq = tuple(iterable)\n    size = len(seq)\n\n    if n > size:\n        raise ValueError('n must be <= len(seq)')\n\n    for i in range(size - n + 1):\n        beginning = seq[:i]\n        middle = seq[i : i + n]\n        end = seq[i + n :]\n        yield beginning, middle, end", "output": "Yield ``(beginning, middle, end)`` tuples, where:"}
{"task": "search", "input": "search code:\nReturn a standardized list of values.\n\nChoices:\n0: def _norm_args_typeerror(other):     if type(other) in (set, frozenset):         inc, exc = other, None     elif type(other) is _ComplementSet:         inc, exc = other._included, other._excluded     else:         raise TypeError('argument must be another set or complement(set)')     return inc, exc\n1: def nth(iterable, n, default=None):     return next(islice(iterable, n, None), default)\n2: def standardization(data: list, ndigits: int = 3) -> list:     # variables for calculation     mu = mean(data)     sigma = stdev(data)     # standardize data     return [round((x - mu) / (sigma), ndigits) for x in data]", "output": "2"}
{"task": "search", "input": "search code:\nReturn a Python Standard Library set that contains i.\n\nChoices:\n0: def find_python_set(node: Node) -> set:     sets = ({0, 1, 2}, {3, 4, 5})     for s in sets:         if node.data in s:             return s     msg = f\"{node.data} is not in {sets}\"     raise ValueError(msg)\n1: def singularize(word):     orig_word, word = word, word.strip().lower()     if not word or word in _IRR_S2P:         return orig_word      irr_singular = _IRR_P2S.get(word)     if irr_singular:         singular = irr_singular     elif not word.endswith('s'):         return orig_word     elif len(word) == 2:         singular = word[:-1]  # or just return word?     elif word.endswith('ies') and word[-4:-3] not in 'aeiou':         singular = word[:-3] + 'y'     elif word.endswith('es') and word[-3] == 's':         singular = word[:-2]     else:         singular = word[:-1]     return _match_case(orig_word, singular)\n2: def logical_left_shift(number: int, shift_amount: int) -> str:     if number < 0 or shift_amount < 0:         raise ValueError(\"both inputs must be positive integers\")      binary_number = str(bin(number))     binary_number += \"0\" * shift_amount     return binary_number", "output": "0"}
{"task": "detection", "input": "classify code:\ndef _count_cross_inversions(p, q):\n    \"\"\"\n    Counts the inversions across two sorted arrays.\n    And combine the two arrays into one sorted array\n    For all 1<= i<=len(P) and for all 1 <= j <= len(Q),\n    if P[i] > Q[j], then (i, j) is a cross inversion\n    Parameters\n    ----------\n    P: array-like, sorted in non-decreasing order\n    Q: array-like, sorted in non-decreasing order\n    Returns\n    ------\n    R: array-like, a sorted array of the elements of `P` and `Q`\n    num_inversion: int, the number of inversions across `P` and `Q`\n    Examples\n    --------\n    >>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\n    ([0, 1, 2, 2, 3, 5], 4)\n    >>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\n    ([1, 2, 3, 3, 4, 5], 0)\n    \"\"\"\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion", "output": "CORRECT"}
{"task": "search", "input": "search code:\nComputes a^b % c iteratively, where a is the base, b is the exponent, and c is the\n\nChoices:\n0: def binary_exp_mod_iterative(base: float, exponent: int, modulus: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")     if modulus <= 0:         raise ValueError(\"Modulus must be a positive integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res = ((res % modulus) * (base % modulus)) % modulus          base *= base         exponent >>= 1      return res\n1: def stalin_sort(sequence: list[int]) -> list[int]:     result = [sequence[0]]     for element in sequence[1:]:         if element >= result[-1]:             result.append(element)      return result\n2: def get_digits(num: int) -> str:     return \"\".join(sorted(str(num**3)))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef optimal_merge_pattern(files: list) -> float:\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost", "output": "Function to merge all the files with optimum cost"}
{"task": "summary", "input": "summarize code:\ndef summation_of_cost_derivative(index, end=m):\n    summation_value = 0\n    for i in range(end):\n        if index == -1:\n            summation_value += _error(i)\n        else:\n            summation_value += _error(i) * train_data[i][0][index]\n    return summation_value", "output": "Calculates the sum of cost function derivative"}
{"task": "search", "input": "search code:\nSorts sequence[start..end] (both inclusive) in-place.\n\nChoices:\n0: def is_safe_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return (number - 1) % 2 == 0 and is_prime(number) and is_prime((number - 1) // 2)\n1: def base16_encode(data: bytes) -> str:     # Turn the data into a list of integers (where each integer is a byte),     # Then turn each byte into its hexadecimal representation, make sure     # it is uppercase, and then join everything together and return it.     return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])\n2: def slowsort(sequence: list, start: int | None = None, end: int | None = None) -> None:     if start is None:         start = 0      if end is None:         end = len(sequence) - 1      if start >= end:         return      mid = (start + end) // 2      slowsort(sequence, start, mid)     slowsort(sequence, mid + 1, end)      if sequence[end] < sequence[mid]:         sequence[end], sequence[mid] = sequence[mid], sequence[end]      slowsort(sequence, start, end - 1)", "output": "2"}
{"task": "search", "input": "search code:\nReturn the number of values of L <= limit such that a wire of length L can be\n\nChoices:\n0: def solution(limit: int = 1500000) -> int:     frequencies: defaultdict = defaultdict(int)     euclid_m = 2     while 2 * euclid_m * (euclid_m + 1) <= limit:         for euclid_n in range((euclid_m % 2) + 1, euclid_m, 2):             if gcd(euclid_m, euclid_n) > 1:                 continue             primitive_perimeter = 2 * euclid_m * (euclid_m + euclid_n)             for perimeter in range(primitive_perimeter, limit + 1, primitive_perimeter):                 frequencies[perimeter] += 1         euclid_m += 1     return sum(1 for frequency in frequencies.values() if frequency == 1)\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def benchmark_levenshtein_distance(func: Callable) -> None:     from timeit import timeit      stmt = f\"{func.__name__}('sitting', 'kitten')\"     setup = f\"from __main__ import {func.__name__}\"     number = 25_000     result = timeit(stmt=stmt, setup=setup, number=number)     print(f\"{func.__name__:<30} finished {number:,} runs in {result:.5f} seconds\")", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef slow_reversible_numbers(\n    remaining_length: int, remainder: int, digits: list[int], length: int\n) -> int:\n    if remaining_length == 0:\n        if digits[0] == 0 or digits[-1] == 0:\n            return 0\n\n        for i in range(length // 2 - 1, -1, -1):\n            remainder += digits[i] + digits[length - i - 1]\n\n            if remainder % 2 == 0:\n                return 0\n\n            remainder //= 10\n\n        return 1\n\n    if remaining_length == 1:\n        if remainder % 2 == 0:\n            return 0\n\n        result = 0\n        for digit in range(10):\n            digits[length // 2] = digit\n            result += slow_reversible_numbers(\n                0, (remainder + 2 * digit) // 10, digits, length\n            )\n        return result\n\n    result = 0\n    for digit1 in range(10):\n        digits[(length + remaining_length) // 2 - 1] = digit1\n\n        if (remainder + digit1) % 2 == 0:\n            other_parity_digits = ODD_DIGITS\n        else:\n            other_parity_digits = EVEN_DIGITS\n\n        for digit2 in other_parity_digits:\n            digits[(length - remaining_length) // 2] = digit2\n            result += slow_reversible_numbers(\n                remaining_length - 2,\n                (remainder + digit1 + digit2) // 10,\n                digits,\n                length,\n            )\n    return result", "output": "Count the number of reversible numbers of given length."}
{"task": "search", "input": "search code:\nAfter each command, program prints treap\n\nChoices:\n0: def main() -> None:     root = None     print(         \"enter numbers to create a tree, + value to add value into treap, \"         \"- value to erase all nodes with value. 'q' to quit. \"     )      args = input()     while args != \"q\":         root = interact_treap(root, args)         print(root)         args = input()      print(\"good by!\")\n1: def sylvester(number: int) -> int:     assert isinstance(number, int), f\"The input value of [n={number}] is not an integer\"      if number == 1:         return 2     elif number < 1:         msg = f\"The input value of [n={number}] has to be > 0\"         raise ValueError(msg)     else:         num = sylvester(number - 1)         lower = num - 1         upper = num         return lower * upper + 1\n2: def quote_query_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])     return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t                      for t in text])", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef count_vowels(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a given string.\n\n    :param s: Input string to count vowels in.\n    :return: Number of vowels in the input string.\n\n    Examples:\n    >>> count_vowels(\"hello world\")\n    3\n    >>> count_vowels(\"HELLO WORLD\")\n    3\n    >>> count_vowels(\"123 hello world\")\n    3\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a quick brown fox\")\n    5\n    >>> count_vowels(\"the quick BROWN fox\")\n    5\n    >>> count_vowels(\"PYTHON\")\n    1\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)", "output": "def count_vowels(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a given string.\n\n    :param s: Input string to count vowels in.\n    :return: Number of vowels in the input string.\n\n    Examples:\n    >>> count_vowels(\"hello world\")\n    3\n    >>> count_vowels(\"HELLO WORLD\")\n    3\n    >>> count_vowels(\"123 hello world\")\n    3\n    >>> count_vowels(\"\")\n    0\n    >>> count_vowels(\"a quick brown fox\")\n    5\n    >>> count_vowels(\"the quick BROWN fox\")\n    5\n    >>> count_vowels(\"PYTHON\")\n    1\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)"}
{"task": "search", "input": "search code:\nReturns the sum of all the multiples of 3 or 5 below n.\n\nChoices:\n0: def doublestarmap(func, iterable):     for item in iterable:         yield func(**item)\n1: def solution(n: int = 1000) -> int:      a = 3     result = 0     while a < n:         if a % 3 == 0 or a % 5 == 0:             result += a         elif a % 15 == 0:             result -= a         a += 1     return result\n2: def capacitor_series(capacitors: list[float]) -> float:      first_sum = 0.0     for index, capacitor in enumerate(capacitors):         if capacitor <= 0:             msg = f\"Capacitor at index {index} has a negative or zero value!\"             raise ValueError(msg)         first_sum += 1 / capacitor     return 1 / first_sum", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solve(arr: NDArray, row: int, cols: set[int], cache: dict[str, int]) -> int:\n\n    cache_id = f\"{row}, {sorted(cols)}\"\n    if cache_id in cache:\n        return cache[cache_id]\n\n    if row == len(arr):\n        return 0\n\n    max_sum = 0\n    for col in cols:\n        new_cols = cols - {col}\n        max_sum = max(\n            max_sum,\n            int(arr[row, col])\n            + solve(arr=arr, row=row + 1, cols=new_cols, cache=cache),\n        )\n    cache[cache_id] = max_sum\n    return max_sum", "output": "Finds the max sum for array `arr` starting with row index `row`, and with columns"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    t_num = 1\n    i = 1\n\n    while True:\n        i += 1\n        t_num += i\n\n        if count_divisors(t_num) > 500:\n            break\n\n    return t_num", "output": "Returns the value of the first triangle number to have over five hundred"}
{"task": "summary", "input": "summarize code:\ndef open_knight_tour_helper(\n    board: list[list[int]], pos: tuple[int, int], curr: int\n) -> bool:\n\n    if is_complete(board):\n        return True\n\n    for position in get_valid_pos(pos, len(board)):\n        y, x = position\n\n        if board[y][x] == 0:\n            board[y][x] = curr + 1\n            if open_knight_tour_helper(board, position, curr + 1):\n                return True\n            board[y][x] = 0\n\n    return False", "output": "Helper function to solve knight tour problem."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    # number of letters in zero, one, two, ..., nineteen (0 for zero since it's\n    # never said aloud)\n    ones_counts = [0, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6, 6, 8, 8, 7, 7, 9, 8, 8]\n    # number of letters in twenty, thirty, ..., ninety (0 for numbers less than\n    # 20 due to inconsistency in teens)\n    tens_counts = [0, 0, 6, 6, 5, 5, 5, 7, 6, 6]\n\n    count = 0\n\n    for i in range(1, n + 1):\n        if i < 1000:\n            if i >= 100:\n                # add number of letters for \"n hundred\"\n                count += ones_counts[i // 100] + 7\n\n                if i % 100 != 0:\n                    # add number of letters for \"and\" if number is not multiple\n                    # of 100\n                    count += 3\n\n            if 0 < i % 100 < 20:\n                # add number of letters for one, two, three, ..., nineteen\n                # (could be combined with below if not for inconsistency in\n                # teens)\n                count += ones_counts[i % 100]\n            else:\n                # add number of letters for twenty, twenty one, ..., ninety\n                # nine\n                count += ones_counts[i % 10]\n                count += tens_counts[(i % 100 - i % 10) // 10]\n        else:\n            count += ones_counts[i // 1000] + 8\n    return count", "output": "Returns the number of letters used to write all numbers from 1 to n."}
{"task": "detection", "input": "classify code:\ndef filter_common_word(possibles: list[str], common_word: str) -> list[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef bruteforce(input_string: str) -> dict[int, str]:\n    results = {}\n    for key_guess in range(1, len(input_string)):  # tries every key\n        results[key_guess] = decrypt(input_string, key_guess)\n    return results", "output": "Uses decrypt function by guessing every key"}
{"task": "summary", "input": "summarize code:\ndef three_sum(nums: list[int]) -> list[list[int]]:\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans", "output": "Find all unique triplets in a sorted array of integers that sum up to zero."}
{"task": "repair", "input": "fix bug:\ndef find_min(arr):\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i][j - 1]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff", "output": "def find_min(arr: list[int]) -> int:\n    \"\"\"\n    >>> find_min([1, 2, 3, 4, 5])\n    1\n    >>> find_min([5, 5, 5, 5, 5])\n    5\n    >>> find_min([5, 5, 5, 5])\n    0\n    >>> find_min([3])\n    3\n    >>> find_min([])\n    0\n    \"\"\"\n    n = len(arr)\n    s = sum(arr)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i - 1][j]\n\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff"}
{"task": "search", "input": "search code:\nAdvance *iterable* by *n* steps. If *n* is ``None``, consume it\n\nChoices:\n0: def consume(iterator, n=None):     # Use functions that consume iterators at C speed.     if n is None:         # feed the entire iterator into a zero-length deque         deque(iterator, maxlen=0)     else:         # advance to the empty slice starting at position n         next(islice(iterator, n, n), None)\n1: def netstring_server(server_socket):     \"A basic netstring server loop, supporting a few operations\"     try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock)             while 1:                 request = client.read_ns()                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'reply4k':                     client.write_ns(b'a' * 4096)                 elif request == b'ping':                     client.write_ns(b'pong')                 elif request == b'reply128k':                     client.setmaxsize(128 * 1024)                     client.write_ns(b'huge' * 32 * 1024)  # 128kb                     client.setmaxsize(32768)  # back to default     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise\n2: def _date_and_delta(value, *, now=None):     if not now:         now = _now()     if isinstance(value, dt.datetime):         date = value         delta = now - value     elif isinstance(value, dt.timedelta):         date = now - value         delta = value     else:         try:             value = int(value)             delta = dt.timedelta(seconds=value)             date = now - delta         except (ValueError, TypeError):             return None, value     return date, _abs_timedelta(delta)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(max_n: int = 10000000) -> int:\n\n    min_numerator = 1  # i\n    min_denominator = 0  # (i)\n    totients = get_totients(max_n + 1)\n\n    for i in range(2, max_n + 1):\n        t = totients[i]\n\n        if i * min_denominator < min_numerator * t and has_same_digits(i, t):\n            min_numerator = i\n            min_denominator = t\n\n    return min_numerator", "output": "Finds the value of n from 1 to max such that n/(n) produces a minimum."}
{"task": "detection", "input": "classify code:\ndef two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum([15, 2, 11, 7], 13)\n    [1, 2]\n    >>> two_sum([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum([7, 15, 11, 2], 18)\n    [0, 2]\n    >>> two_sum([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum([2, 7, 11, 15], 8)\n    []\n    >>> two_sum([3 * i for i in range(10)], 19)\n    []\n    \"\"\"\n    chk_map: dict[int, int] = {}\n    for index, val in enumerate(nums):\n        compl = target - val\n        if compl in chk_map:\n            return [chk_map[compl], index]\n        chk_map[val] = index\n    return []", "output": "CORRECT"}
{"task": "search", "input": "search code:\ndijk({1: [(2, 7), (3, 9), (6, 14)],\n\nChoices:\n0: def split(root: Node | None, value: int) -> tuple[Node | None, Node | None]:     if root is None or root.value is None:  # None tree is split into 2 Nones         return None, None     elif value < root.value:         left, root.left = split(root.left, value)         return left, root     else:         root.right, right = split(root.right, value)         return root, right\n1: def get_temperature_coeffecient(color: str) -> int:     if color not in temperature_coeffecient_color_values:         msg = f\"{color} is not a valid color for temperature coeffecient band\"         raise ValueError(msg)     return temperature_coeffecient_color_values[color]\n2: def dijk(g, s):     dist, known, path = {s: 0}, set(), {s: 0}     while True:         if len(known) == len(g) - 1:             break         mini = 100000         for key, value in dist:             if key not in known and value < mini:                 mini = value                 u = key         known.add(u)         for v in g[u]:             if v[0] not in known and dist[u] + v[1] < dist.get(v[0], 100000):                 dist[v[0]] = dist[u] + v[1]                 path[v[0]] = u     for key, value in dist.items():         if key != s:             print(value)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in xrange(m)] for _ in xrange(m + 1)]\n    for i in xrange(m + 1):\n        memo[i][0] = 1\n\n    for n in xrange(m + 1):\n        for k in xrange(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1", "output": "def partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1"}
{"task": "search", "input": "search code:\nSet the bit at position to 1.\n\nChoices:\n0: def _batched(iterable, n, *, strict=False):  # pragma: no cover     if n < 1:         raise ValueError('n must be at least one')     iterator = iter(iterable)     while batch := tuple(islice(iterator, n)):         if strict and len(batch) != n:             raise ValueError('batched(): incomplete batch')         yield batch\n1: def set_bit(number: int, position: int) -> int:     return number | (1 << position)\n2: def get_gas_stations(     gas_quantities: list[int], costs: list[int] ) -> tuple[GasStation, ...]:     return tuple(         GasStation(quantity, cost) for quantity, cost in zip(gas_quantities, costs)     )", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef binarize(image: np.ndarray, threshold: float = 127.0) -> np.ndarray:\n    return np.where(image > threshold, 1, 0)", "output": "Binarizes a grayscale image based on a given threshold value,"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    xmulti = []\n    zmulti = []\n    z = 3\n    x = 5\n    temp = 1\n    while True:\n        result = z * temp\n        if result < n:\n            zmulti.append(result)\n            temp += 1\n        else:\n            temp = 1\n            break\n    while True:\n        result = x * temp\n        if result < n:\n            xmulti.append(result)\n            temp += 1\n        else:\n            break\n    collection = list(set(xmulti + zmulti))\n    return sum(collection)", "output": "Returns the sum of all the multiples of 3 or 5 below n."}
{"task": "search", "input": "search code:\nReturns the sum of all the primes below n.\n\nChoices:\n0: def get_multiplier(color: str) -> float:     if color not in multiplier_color_values:         msg = f\"{color} is not a valid color for multiplier band\"         raise ValueError(msg)     return multiplier_color_values[color]\n1: def solution(n: int = 2000000) -> int:      return sum(takewhile(lambda x: x < n, prime_generator()))\n2: def dynamic_lucas_number(n_th_number: int) -> int:     if not isinstance(n_th_number, int):         raise TypeError(\"dynamic_lucas_number accepts only integer arguments.\")     a, b = 2, 1     for _ in range(n_th_number):         a, b = b, a + b     return a", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_rotation(\n    img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int\n) -> np.ndarray:\n    matrix = cv2.getAffineTransform(pt1, pt2)\n    return cv2.warpAffine(img, matrix, (rows, cols))", "output": "Get image rotation"}
{"task": "summary", "input": "summarize code:\ndef quantum_fourier_transform(number_of_qubits: int = 3) -> qiskit.result.counts.Counts:\n    if isinstance(number_of_qubits, str):\n        raise TypeError(\"number of qubits must be a integer.\")\n    if number_of_qubits <= 0:\n        raise ValueError(\"number of qubits must be > 0.\")\n    if math.floor(number_of_qubits) != number_of_qubits:\n        raise ValueError(\"number of qubits must be exact integer.\")\n    if number_of_qubits > 10:\n        raise ValueError(\"number of qubits too large to simulate(>10).\")\n\n    qr = QuantumRegister(number_of_qubits, \"qr\")\n    cr = ClassicalRegister(number_of_qubits, \"cr\")\n\n    quantum_circuit = QuantumCircuit(qr, cr)\n\n    counter = number_of_qubits\n\n    for i in range(counter):\n        quantum_circuit.h(number_of_qubits - i - 1)\n        counter -= 1\n        for j in range(counter):\n            quantum_circuit.cp(np.pi / 2 ** (counter - j), j, counter)\n\n    for k in range(number_of_qubits // 2):\n        quantum_circuit.swap(k, number_of_qubits - k - 1)\n\n    # measure all the qubits\n    quantum_circuit.measure(qr, cr)\n    # simulate with 10000 shots\n    backend = Aer.get_backend(\"qasm_simulator\")\n    job = execute(quantum_circuit, backend, shots=10000)\n\n    return job.result().get_counts(quantum_circuit)", "output": "# >>> quantum_fourier_transform(2)"}
{"task": "summary", "input": "summarize code:\ndef lstrip(iterable, pred):\n    return dropwhile(pred, iterable)", "output": "Yield the items from *iterable*, but strip any from the beginning"}
{"task": "search", "input": "search code:\nSolves the system of linear equation in 2 variables.\n\nChoices:\n0: def cramers_rule_2x2(equation1: list[int], equation2: list[int]) -> tuple[float, float]:      # Check if the input is valid     if not len(equation1) == len(equation2) == 3:         raise ValueError(\"Please enter a valid equation.\")     if equation1[0] == equation1[1] == equation2[0] == equation2[1] == 0:         raise ValueError(\"Both a & b of two equations can't be zero.\")      # Extract the coefficients     a1, b1, c1 = equation1     a2, b2, c2 = equation2      # Calculate the determinants of the matrices     determinant = a1 * b2 - a2 * b1     determinant_x = c1 * b2 - c2 * b1     determinant_y = a1 * c2 - a2 * c1      # Check if the system of linear equations has a solution (using Cramer's rule)     if determinant == 0:         if determinant_x == determinant_y == 0:             raise ValueError(\"Infinite solutions. (Consistent system)\")         else:             raise ValueError(\"No solution. (Inconsistent system)\")     elif determinant_x == determinant_y == 0:         # Trivial solution (Inconsistent system)         return (0.0, 0.0)     else:         x = determinant_x / determinant         y = determinant_y / determinant         # Non-Trivial Solution (Consistent system)         return (x, y)\n1: def compute_pairwise_affinities(data_matrix: ndarray, sigma: float = 1.0) -> ndarray:     n_samples = data_matrix.shape[0]     squared_sum = np.sum(np.square(data_matrix), axis=1)     squared_distance = np.add(         np.add(-2 * np.dot(data_matrix, data_matrix.T), squared_sum).T, squared_sum     )      affinity_matrix = np.exp(-squared_distance / (2 * sigma**2))     np.fill_diagonal(affinity_matrix, 0)      affinity_matrix /= np.sum(affinity_matrix)     return (affinity_matrix + affinity_matrix.T) / (2 * n_samples)\n2: def simple_moving_average(     data: Sequence[float], window_size: int ) -> list[float | None]:     if window_size < 1:         raise ValueError(\"Window size must be a positive integer\")      sma: list[float | None] = []      for i in range(len(data)):         if i < window_size - 1:             sma.append(None)  # SMA not available for early data points         else:             window = data[i - window_size + 1 : i + 1]             sma_value = sum(window) / window_size             sma.append(sma_value)     return sma", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef sum_reverse(n: int) -> int:\n    return int(n) + int(str(n)[::-1])", "output": "Returns the sum of n and reverse of n."}
{"task": "search", "input": "search code:\nUnion of two sets.\n\nChoices:\n0: def union_set(x: Node, y: Node) -> None:     x, y = find_set(x), find_set(y)     if x == y:         return      elif x.rank > y.rank:         y.parent = x     else:         x.parent = y         if x.rank == y.rank:             y.rank += 1\n1: def mark_ends(iterable):     it = iter(iterable)     for a in it:         first = True         for b in it:             yield first, False, a             a = b             first = False         yield first, True, a\n2: def bogo_sort(collection):      def is_sorted(collection):         for i in range(len(collection) - 1):             if collection[i] > collection[i + 1]:                 return False         return True      while not is_sorted(collection):         random.shuffle(collection)     return collection", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef convert_to_2d(\n    x: float, y: float, z: float, scale: float, distance: float\n) -> tuple[float, float]:\n    if not all(isinstance(val, (float, int)) for val in locals().values()):\n        msg = f\"Input values must either be float or int: {list(locals().values())}\"\n        raise TypeError(msg)\n    projected_x = ((x * distance) / (z + distance)) * scale\n    projected_y = ((y * distance) / (z + distance)) * scale\n    return projected_x, projected_y", "output": "Converts 3d point to a 2d drawable point"}
{"task": "search", "input": "search code:\nRandomly choose k data points as initial centroids\n\nChoices:\n0: def get_initial_centroids(data, k, seed=None):     # useful for obtaining consistent results     rng = np.random.default_rng(seed)     n = data.shape[0]  # number of data points      # Pick K indices from range [0, N).     rand_indices = rng.integers(0, n, k)      # Keep centroids as dense format, as many entries will be nonzero due to averaging.     # As long as at least one document in a cluster contains a word,     # it will carry a nonzero weight in the TF-IDF vector of the centroid.     centroids = data[rand_indices, :]      return centroids\n1: def evaluate_poly(poly: Sequence[float], x: float) -> float:     return sum(c * (x**i) for i, c in enumerate(poly))\n2: def base16_encode(data: bytes) -> str:     # Turn the data into a list of integers (where each integer is a byte),     # Then turn each byte into its hexadecimal representation, make sure     # it is uppercase, and then join everything together and return it.     return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])", "output": "0"}
{"task": "search", "input": "search code:\n[summary]\n\nChoices:\n0: def rotate_to_the_right(head: Node, places: int) -> Node:     # Check if the list is empty or has only one element     if not head:         raise ValueError(\"The linked list is empty.\")      if head.next_node is None:         return head      # Calculate the length of the linked list     length = 1     temp_node = head     while temp_node.next_node is not None:         length += 1         temp_node = temp_node.next_node      # Adjust the value of places to avoid places longer than the list.     places %= length      if places == 0:         return head  # As no rotation is needed.      # Find the new head position after rotation.     new_head_index = length - places      # Traverse to the new head position     temp_node = head     for _ in range(new_head_index - 1):         assert temp_node.next_node         temp_node = temp_node.next_node      # Update pointers to perform rotation     assert temp_node.next_node     new_head = temp_node.next_node     temp_node.next_node = None     temp_node = new_head     while temp_node.next_node:         temp_node = temp_node.next_node     temp_node.next_node = head      assert new_head     return new_head\n1: def combination_with_replacement_index(element, iterable):     element = tuple(element)     l = len(element)     element = enumerate(element)      k, y = next(element, (None, None))     if k is None:         return 0      indexes = []     pool = tuple(iterable)     for n, x in enumerate(pool):         while x == y:             indexes.append(n)             tmp, y = next(element, (None, None))             if tmp is None:                 break             else:                 k = tmp         if y is None:             break     else:         raise ValueError(             'element is not a combination with replacement of iterable'         )      n = len(pool)     occupations = [0] * n     for p in indexes:         occupations[p] += 1      index = 0     cumulative_sum = 0     for k in range(1, n):         cumulative_sum += occupations[k - 1]         j = l + n - 1 - k - cumulative_sum         i = n - k         if i <= j:             index += comb(j, i)      return index\n2: def get_anime_episode(episode_endpoint: str) -> list:      episode_page_url = f\"{BASE_URL}{episode_endpoint}\"      response = httpx.get(         url=episode_page_url, headers={\"User-Agent\": UserAgent().chrome}, timeout=10     )     response.raise_for_status()      soup = BeautifulSoup(response.text, \"html.parser\")      url = soup.find(\"iframe\", {\"id\": \"playerframe\"})     if url is None or isinstance(url, NavigableString):         msg = f\"Could not find url and download url from {episode_endpoint}\"         raise RuntimeError(msg)      episode_url = url[\"src\"]     if not isinstance(episode_url, str):         msg = f\"Could not find url and download url from {episode_endpoint}\"         raise RuntimeError(msg)     download_url = episode_url.replace(\"/embed/\", \"/playlist/\") + \".m3u8\"      return [f\"{BASE_URL}{episode_url}\", f\"{BASE_URL}{download_url}\"]", "output": "2"}
{"task": "search", "input": "search code:\nThe complement of :func:`unique()`.\n\nChoices:\n0: def cross(items_a, items_b):     return [a + b for a in items_a for b in items_b]\n1: def redundant(src, key=None, groups=False):     if key is None:         pass     elif callable(key):         key_func = key     elif isinstance(key, (str, bytes)):         def key_func(x): return getattr(x, key, x)     else:         raise TypeError('\"key\" expected a string or callable, not %r' % key)     seen = {}  # key to first seen item     redundant_order = []     redundant_groups = {}     for i in src:         k = key_func(i) if key else i         if k not in seen:             seen[k] = i         else:             if k in redundant_groups:                 if groups:                     redundant_groups[k].append(i)             else:                 redundant_order.append(k)                 redundant_groups[k] = [seen[k], i]     if not groups:         ret = [redundant_groups[k][1] for k in redundant_order]     else:         ret = [redundant_groups[k] for k in redundant_order]     return ret\n2: def solution() -> int:      for a in range(300):         for b in range(a + 1, 400):             for c in range(b + 1, 500):                 if (a + b + c) == 1000 and (a**2) + (b**2) == (c**2):                     return a * b * c      return -1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef remove_word(\n    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool\n) -> None:\n    for i in range(len(word)):\n        if vertical:\n            puzzle[row + i][col] = \"\"\n        else:\n            puzzle[row][col + i] = \"\"", "output": "Remove a word from the given position."}
{"task": "detection", "input": "classify code:\ndef sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 100) -> int:\n\n    sum_of_squares = sum(i * i for i in range(1, n + 1))\n    square_of_sum = int(math.pow(sum(range(1, n + 1)), 2))\n    return square_of_sum - sum_of_squares", "output": "Returns the difference between the sum of the squares of the first n"}
{"task": "summary", "input": "summarize code:\ndef flip_bit(number: int, position: int) -> int:\n    return number ^ (1 << position)", "output": "Flip the bit at position."}
{"task": "summary", "input": "summarize code:\ndef iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:\n    vectors = initial_vectors\n    for _ in range(steps):\n        vectors = iteration_step(vectors)\n    return vectors", "output": "Go through the number of iterations determined by the argument \"steps\"."}
{"task": "summary", "input": "summarize code:\ndef diophantine_all_soln(a: int, b: int, c: int, n: int = 2) -> None:\n    (x0, y0) = diophantine(a, b, c)  # Initial value\n    d = greatest_common_divisor(a, b)\n    p = a // d\n    q = b // d\n\n    for i in range(n):\n        x = x0 + i * q\n        y = y0 - i * p\n        print(x, y)", "output": "Lemma : if n|ab and gcd(a,n) = 1, then n|b."}
{"task": "summary", "input": "summarize code:\ndef solution(base: int = 800800, degree: int = 800800) -> int:\n\n    upper_bound = degree * log2(base)\n    max_prime = int(upper_bound)\n    prime_numbers = calculate_prime_numbers(max_prime)\n\n    hybrid_integers_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left < right:\n        while (\n            prime_numbers[right] * log2(prime_numbers[left])\n            + prime_numbers[left] * log2(prime_numbers[right])\n            > upper_bound\n        ):\n            right -= 1\n        hybrid_integers_count += right - left\n        left += 1\n\n    return hybrid_integers_count", "output": "Returns the number of hybrid-integers less than or equal to base^degree"}
{"task": "summary", "input": "summarize code:\ndef value_chain(*args):\n    scalar_types = (str, bytes)\n    for value in args:\n        if isinstance(value, scalar_types):\n            yield value\n            continue\n        try:\n            yield from value\n        except TypeError:\n            yield value", "output": "Yield all arguments passed to the function in the same order in which"}
{"task": "summary", "input": "summarize code:\ndef power(x: int, y: int, mod: int) -> int:\n\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, mod) % mod\n    temp = (temp * temp) % mod\n    if y % 2 == 1:\n        temp = (temp * x) % mod\n    return temp", "output": "Examples:"}
{"task": "search", "input": "search code:\nCreate a Mel-spaced filter bank for audio processing.\n\nChoices:\n0: def while_solution(max_number: int = 10**8) -> int:      prime_numbers = calculate_prime_numbers(max_number // 2)      semiprimes_count = 0     left = 0     right = len(prime_numbers) - 1     while left <= right:         while prime_numbers[left] * prime_numbers[right] >= max_number:             right -= 1         semiprimes_count += right - left + 1         left += 1      return semiprimes_count\n1: def mel_spaced_filterbank(     sample_rate: int, mel_filter_num: int = 10, ftt_size: int = 1024 ) -> np.ndarray:     freq_min = 0     freq_high = sample_rate // 2      logging.info(f\"Minimum frequency: {freq_min}\")     logging.info(f\"Maximum frequency: {freq_high}\")      # Calculate filter points and mel frequencies     filter_points, mel_freqs = get_filter_points(         sample_rate,         freq_min,         freq_high,         mel_filter_num,         ftt_size,     )      filters = get_filters(filter_points, ftt_size)      # normalize filters     # taken from the librosa library     enorm = 2.0 / (mel_freqs[2 : mel_filter_num + 2] - mel_freqs[:mel_filter_num])     return filters * enorm[:, np.newaxis]\n2: def create_state_space_tree(     nums: list[int],     max_sum: int,     num_index: int,     path: list[int],     result: list[list[int]],     remaining_nums_sum: int, ) -> None:      if sum(path) > max_sum or (remaining_nums_sum + sum(path)) < max_sum:         return     if sum(path) == max_sum:         result.append(path)         return     for index in range(num_index, len(nums)):         create_state_space_tree(             nums,             max_sum,             index + 1,             [*path, nums[index]],             result,             remaining_nums_sum - nums[index],         )", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef calculate_average_waiting_time(waiting_times: List[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "def calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)"}
{"task": "summary", "input": "summarize code:\ndef naturalday(value, format=\"%b %d\") -> str:\n    try:\n        value = dt.date(value.year, value.month, value.day)\n    except AttributeError:\n        # Passed value wasn't date-ish\n        return value\n    except (OverflowError, ValueError):\n        # Date arguments out of range\n        return value\n    delta = value - dt.date.today()\n    if delta.days == 0:\n        return _(\"today\")\n    elif delta.days == 1:\n        return _(\"tomorrow\")\n    elif delta.days == -1:\n        return _(\"yesterday\")\n    return value.strftime(format)", "output": "Return a natural day."}
{"task": "search", "input": "search code:\nUse depth first search to find strongly connected\n\nChoices:\n0: def solution(n: int = 1000) -> int:      total = 0     terms = (n - 1) // 3     total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.     terms = (n - 1) // 5     total += ((terms) * (10 + (terms - 1) * 5)) // 2     terms = (n - 1) // 15     total -= ((terms) * (30 + (terms - 1) * 15)) // 2     return total\n1: def escape_shell_args(args, sep=' ', style=None):     if not style:         style = 'cmd' if sys.platform == 'win32' else 'sh'      if style == 'sh':         return args2sh(args, sep=sep)     elif style == 'cmd':         return args2cmd(args, sep=sep)      raise ValueError(\"style expected one of 'cmd' or 'sh', not %r\" % style)\n2: def find_components(     reversed_graph: dict[int, list[int]], vert: int, visited: list[bool] ) -> list[int]:      visited[vert] = True     component = [vert]      for neighbour in reversed_graph[vert]:         if not visited[neighbour]:             component += find_components(reversed_graph, neighbour, visited)      return component", "output": "2"}
{"task": "search", "input": "search code:\nSize of matrix created from array [30, 35, 15, 5, 10, 20, 25] will be:\n\nChoices:\n0: def intersperse(e, iterable, n=1):     if n == 0:         raise ValueError('n must be > 0')     elif n == 1:         # interleave(repeat(e), iterable) -> e, x_0, e, x_1, e, x_2...         # islice(..., 1, None) -> x_0, e, x_1, e, x_2...         return islice(interleave(repeat(e), iterable), 1, None)     else:         # interleave(filler, chunks) -> [e], [x_0, x_1], [e], [x_2, x_3]...         # islice(..., 1, None) -> [x_0, x_1], [e], [x_2, x_3]...         # flatten(...) -> x_0, x_1, e, x_2, x_3...         filler = repeat([e])         chunks = chunked(iterable, n)         return flatten(islice(interleave(filler, chunks), 1, None))\n1: def longest_prefix(input_str: str) -> int:      # just returning maximum value of the array gives us answer     return max(prefix_function(input_str))\n2: def main():      array = [30, 35, 15, 5, 10, 20, 25]     n = len(array)      matrix, optimal_solution = matrix_chain_order(array)      print(\"No. of Operation required: \" + str(matrix[1][n - 1]))     print_optimal_solution(optimal_solution, 1, n - 1)", "output": "2"}
{"task": "search", "input": "search code:\nTake in 2 positive integers.\n\nChoices:\n0: def insertion_sort[T: Comparable](collection: MutableSequence[T]) -> MutableSequence[T]:      for insert_index in range(1, len(collection)):         insert_value = collection[insert_index]         while insert_index > 0 and insert_value < collection[insert_index - 1]:             collection[insert_index] = collection[insert_index - 1]             insert_index -= 1         collection[insert_index] = insert_value     return collection\n1: def collatz_sequence_length(n: int) -> int:     if n in COLLATZ_SEQUENCE_LENGTHS:         return COLLATZ_SEQUENCE_LENGTHS[n]     next_n = n // 2 if n % 2 == 0 else 3 * n + 1     sequence_length = collatz_sequence_length(next_n) + 1     COLLATZ_SEQUENCE_LENGTHS[n] = sequence_length     return sequence_length\n2: def logical_left_shift(number: int, shift_amount: int) -> str:     if number < 0 or shift_amount < 0:         raise ValueError(\"both inputs must be positive integers\")      binary_number = str(bin(number))     binary_number += \"0\" * shift_amount     return binary_number", "output": "2"}
{"task": "detection", "input": "classify code:\ndef calculate_turn_around_times(\r\n    burst_times: List[int], waiting_times: List[int]\r\n) -> List[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "output": "BUGGY"}
{"task": "search", "input": "search code:\nThe Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text\n\nChoices:\n0: def knuth_morris_pratt(text: str, pattern: str) -> int:      # 1) Construct the failure array     failure = get_failure_array(pattern)      # 2) Step through text searching for pattern     i, j = 0, 0  # index into text, pattern     while i < len(text):         if pattern[j] == text[i]:             if j == (len(pattern) - 1):                 return i - j             j += 1          # if this is a prefix in our pattern         # just go back far enough to continue         elif j > 0:             j = failure[j - 1]             continue         i += 1     return -1\n1: def min_steps_to_one(number: int) -> int:      if number <= 0:         msg = f\"n must be greater than 0. Got n = {number}\"         raise ValueError(msg)      table = [number + 1] * (number + 1)      # starting position     table[1] = 0     for i in range(1, number):         table[i + 1] = min(table[i + 1], table[i] + 1)         # check if out of bounds         if i * 2 <= number:             table[i * 2] = min(table[i * 2], table[i] + 1)         # check if out of bounds         if i * 3 <= number:             table[i * 3] = min(table[i * 3], table[i] + 1)     return table[number]\n2: def quantum_fourier_transform(number_of_qubits: int = 3) -> qiskit.result.counts.Counts:     if isinstance(number_of_qubits, str):         raise TypeError(\"number of qubits must be a integer.\")     if number_of_qubits <= 0:         raise ValueError(\"number of qubits must be > 0.\")     if math.floor(number_of_qubits) != number_of_qubits:         raise ValueError(\"number of qubits must be exact integer.\")     if number_of_qubits > 10:         raise ValueError(\"number of qubits too large to simulate(>10).\")      qr = QuantumRegister(number_of_qubits, \"qr\")     cr = ClassicalRegister(number_of_qubits, \"cr\")      quantum_circuit = QuantumCircuit(qr, cr)      counter = number_of_qubits      for i in range(counter):         quantum_circuit.h(number_of_qubits - i - 1)         counter -= 1         for j in range(counter):             quantum_circuit.cp(np.pi / 2 ** (counter - j), j, counter)      for k in range(number_of_qubits // 2):         quantum_circuit.swap(k, number_of_qubits - k - 1)      # measure all the qubits     quantum_circuit.measure(qr, cr)     # simulate with 10000 shots     backend = Aer.get_backend(\"qasm_simulator\")     job = execute(quantum_circuit, backend, shots=10000)      return job.result().get_counts(quantum_circuit)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef edit_distance(source: str, target: str) -> int:\n    \"\"\"\n    Edit distance algorithm is a string metric, i.e., it is a way of quantifying how\n    dissimilar two strings are to one another. It is measured by counting the minimum\n    number of operations required to transform one string into another.\n\n    This implementation assumes that the cost of operations (insertion, deletion and\n    substitution) is always 1\n\n    Args:\n    source: the initial string with respect to which we are calculating the edit\n        distance for the target\n    target: the target string, formed after performing n operations on the source string\n\n    >>> edit_distance(\"GATTIC\", \"GALTIC\")\n    1\n    >>> edit_distance(\"NUM3\", \"HUM2\")\n    2\n    >>> edit_distance(\"cap\", \"CAP\")\n    3\n    >>> edit_distance(\"Cat\", \"\")\n    3\n    >>> edit_distance(\"cat\", \"cat\")\n    0\n    >>> edit_distance(\"\", \"123456789\")\n    9\n    >>> edit_distance(\"Be@uty\", \"Beautyyyy!\")\n    5\n    >>> edit_distance(\"lstring\", \"lsstring\")\n    1\n    \"\"\"\n    if len(source) == 0:\n        return len(target)\n    elif len(target) == 0:\n        return len(source)\n\n    delta = int(source[-1] != target[-1])  # Substitution\n    return min(\n        edit_distance(source[:-1], target[:-1]) + delta,\n        edit_distance(source, target[:-1]) + 1,\n        edit_distance(source[:-1], target) + 1,\n    )", "output": "CORRECT"}
{"task": "search", "input": "search code:\nRecursively draw the Vicsek fractal at the specified position, with the\n\nChoices:\n0: def calculate_waiting_times(burst_times: list[int]) -> list[int]:     quantum = 2     rem_burst_times = list(burst_times)     waiting_times = [0] * len(burst_times)     t = 0     while True:         done = True         for i, burst_time in enumerate(burst_times):             if rem_burst_times[i] > 0:                 done = False                 if rem_burst_times[i] > quantum:                     t += quantum                     rem_burst_times[i] -= quantum                 else:                     t += rem_burst_times[i]                     waiting_times[i] = t - burst_time                     rem_burst_times[i] = 0         if done is True:             return waiting_times\n1: def knapsack(     weights: list, values: list, number_of_items: int, max_weight: int, index: int ) -> int:     if index == number_of_items:         return 0     ans1 = 0     ans2 = 0     ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)     if weights[index] <= max_weight:         ans2 = values[index] + knapsack(             weights, values, number_of_items, max_weight - weights[index], index + 1         )     return max(ans1, ans2)\n2: def draw_fractal_recursive(x: float, y: float, length: float, depth: float):     if depth == 0:         draw_cross(x, y, length)         return      draw_fractal_recursive(x, y, length / 3, depth - 1)     draw_fractal_recursive(x + length / 3, y, length / 3, depth - 1)     draw_fractal_recursive(x - length / 3, y, length / 3, depth - 1)     draw_fractal_recursive(x, y + length / 3, length / 3, depth - 1)     draw_fractal_recursive(x, y - length / 3, length / 3, depth - 1)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef find_pattern(pattern: str, input_str: str) -> int:\n    answer = 0\n    # concatenate 'pattern' and 'input_str' and call z_function\n    # with concatenated string\n    z_result = z_function(pattern + input_str)\n\n    for val in z_result:\n        # if value is greater then length of the pattern string\n        # that means this index is starting position of substring\n        # which is equal to pattern string\n        if val >= len(pattern):\n            answer += 1\n\n    return answer", "output": "Example of using z-function for pattern occurrence"}
{"task": "search", "input": "search code:\nNormalizes image in Numpy 2D array format, between ranges 0-cap,\n\nChoices:\n0: def normalize_image(     image: np.ndarray, cap: float = 255.0, data_type: np.dtype = np.uint8 ) -> np.ndarray:     normalized = (image - np.min(image)) / (np.max(image) - np.min(image)) * cap     return normalized.astype(data_type)\n1: def normalize_array(array: np.ndarray, cap: float = 1) -> np.ndarray:     diff = np.max(array) - np.min(array)     return (array - np.min(array)) / (1 if diff == 0 else diff) * cap\n2: def split_punct_ws(text):     return [w for w in _punct_re.split(text) if w]", "output": "0"}
{"task": "search", "input": "search code:\nStrips values from the beginning of an iterable. Stripped items will\n\nChoices:\n0: def inorder(curr_node: Node | None) -> list[Node]:     node_list = []     if curr_node is not None:         node_list = [*inorder(curr_node.left), curr_node, *inorder(curr_node.right)]     return node_list\n1: def calculate_mean(instance_count: int, items: list) -> float:     # the sum of all items divided by number of instances     return sum(items) / instance_count\n2: def lstrip_iter(iterable, strip_value=None):     iterator = iter(iterable)     for i in iterator:         if i != strip_value:             yield i             break     for i in iterator:         yield i", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef merge_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Time Complexity: O(n log n)\n    Space Complexity: O(n)\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def merge(left: list, right: list) -> list:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n\n        :param left: Left collection\n        :param right: Right collection\n        :return: Merged result\n        \"\"\"\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))", "output": "def merge_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Time Complexity: O(n log n)\n    Space Complexity: O(n)\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def merge(left: list, right: list) -> list:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n\n        :param left: Left collection\n        :param right: Right collection\n        :return: Merged result\n        \"\"\"\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))"}
{"task": "summary", "input": "summarize code:\ndef dijk(g, s):\n    dist, known, path = {s: 0}, set(), {s: 0}\n    while True:\n        if len(known) == len(g) - 1:\n            break\n        mini = 100000\n        for key, value in dist:\n            if key not in known and value < mini:\n                mini = value\n                u = key\n        known.add(u)\n        for v in g[u]:\n            if v[0] not in known and dist[u] + v[1] < dist.get(v[0], 100000):\n                dist[v[0]] = dist[u] + v[1]\n                path[v[0]] = u\n    for key, value in dist.items():\n        if key != s:\n            print(value)", "output": "dijk({1: [(2, 7), (3, 9), (6, 14)],"}
{"task": "summary", "input": "summarize code:\ndef interquartile_range_checker(train_user: list) -> float:\n    train_user.sort()\n    q1 = np.percentile(train_user, 25)\n    q3 = np.percentile(train_user, 75)\n    iqr = q3 - q1\n    low_lim = q1 - (iqr * 0.1)\n    return float(low_lim)", "output": "Optional method: interquatile range"}
{"task": "summary", "input": "summarize code:\ndef triangular_number(position: int) -> int:\n    if position < 0:\n        raise ValueError(\"param `position` must be non-negative\")\n\n    return position * (position + 1) // 2", "output": "Generate the triangular number at the specified position."}
{"task": "summary", "input": "summarize code:\ndef valid_connection(\n    graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int]\n) -> bool:\n\n    # 1. Validate that path exists between current and next vertices\n    if graph[path[curr_ind - 1]][next_ver] == 0:\n        return False\n\n    # 2. Validate that next vertex is not already in path\n    return not any(vertex == next_ver for vertex in path)", "output": "Checks whether it is possible to add next into path by validating 2 statements"}
{"task": "search", "input": "search code:\nThis function is used to perform maxpooling on the input array of 2D matrix(image)\n\nChoices:\n0: def num_digits_faster(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      return len(str(abs(n)))\n1: def sum_32(a: int, b: int) -> int:     return (a + b) % 2**32\n2: def maxpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:     arr = np.array(arr)     if arr.shape[0] != arr.shape[1]:         raise ValueError(\"The input array is not a square matrix\")     i = 0     j = 0     mat_i = 0     mat_j = 0      # compute the shape of the output matrix     maxpool_shape = (arr.shape[0] - size) // stride + 1     # initialize the output matrix with zeros of shape maxpool_shape     updated_arr = np.zeros((maxpool_shape, maxpool_shape))      while i < arr.shape[0]:         if i + size > arr.shape[0]:             # if the end of the matrix is reached, break             break         while j < arr.shape[1]:             # if the end of the matrix is reached, break             if j + size > arr.shape[1]:                 break             # compute the maximum of the pooling matrix             updated_arr[mat_i][mat_j] = np.max(arr[i : i + size, j : j + size])             # shift the pooling matrix by stride of column pixels             j += stride             mat_j += 1          # shift the pooling matrix by stride of row pixels         i += stride         mat_i += 1          # reset the column index to 0         j = 0         mat_j = 0      return updated_arr", "output": "2"}
{"task": "search", "input": "search code:\nGenerate a sequence of prime numbers\n\nChoices:\n0: def prime_generator():      num = 2     while True:         if is_prime(num):             yield num         num += 1\n1: def subset_combinations(elements: list[int], n: int) -> list:     r = len(elements)     if n > r:         return []      dp: list[list[tuple]] = [[] for _ in range(r + 1)]      dp[0].append(())      for i in range(1, r + 1):         for j in range(i, 0, -1):             for prev_combination in dp[j - 1]:                 dp[j].append((*prev_combination, elements[i - 1]))      try:         return sorted(dp[n])     except TypeError:         return dp[n]\n2: def f(x: float) -> float:     return math.pow(x, 3) - (2 * x) - 5", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef erase(root: Node | None, value: int) -> Node | None:\n    left, right = split(root, value - 1)\n    _, right = split(right, value)\n    return merge(left, right)", "output": "Erase element"}
{"task": "summary", "input": "summarize code:\ndef check_args(init_velocity: float, angle: float) -> None:\n\n    # Ensure valid instance\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError(\"Invalid velocity. Should be an integer or float.\")\n\n    if not isinstance(angle, (int, float)):\n        raise TypeError(\"Invalid angle. Should be an integer or float.\")\n\n    # Ensure valid angle\n    if angle > 90 or angle < 1:\n        raise ValueError(\"Invalid angle. Range is 1-90 degrees.\")\n\n    # Ensure valid velocity\n    if init_velocity < 0:\n        raise ValueError(\"Invalid velocity. Should be a positive number.\")", "output": "Check that the arguments are valid"}
{"task": "search", "input": "search code:\nReturn the elements from each of the input iterables that aren't in the\n\nChoices:\n0: def unique_to_each(*iterables):     pool = [list(it) for it in iterables]     counts = Counter(chain.from_iterable(map(set, pool)))     uniques = {element for element in counts if counts[element] == 1}     return [list(filter(uniques.__contains__, it)) for it in pool]\n1: def insertion_sort[T: Comparable](collection: MutableSequence[T]) -> MutableSequence[T]:      for insert_index in range(1, len(collection)):         insert_value = collection[insert_index]         while insert_index > 0 and insert_value < collection[insert_index - 1]:             collection[insert_index] = collection[insert_index - 1]             insert_index -= 1         collection[insert_index] = insert_value     return collection\n2: def remove_duplicates(key: str) -> str:      key_no_dups = \"\"     for ch in key:         if ch == \" \" or (ch not in key_no_dups and ch.isalpha()):             key_no_dups += ch     return key_no_dups", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp", "output": "def ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp"}
{"task": "search", "input": "search code:\nReturns the sum of the digits of the number 2^power.\n\nChoices:\n0: def main() -> None:     trees = {\"zero\": Node(0), \"seven\": make_tree_seven(), \"nine\": make_tree_nine()}     for name, tree in trees.items():         print(f\"      The {name} tree: {tuple(tree)}\")         # (0,)         # (4, 2, 5, 1, 6, 3, 7)         # (7, 4, 8, 2, 5, 9, 1, 3, 6)         print(f\"Mirror of {name} tree: {tuple(tree.mirror())}\")\n1: def mkdir_p(path):     try:         os.makedirs(path)     except OSError as exc:         if exc.errno == errno.EEXIST and os.path.isdir(path):             return         raise     return\n2: def solution(power: int = 1000) -> int:     num = 2**power     string_num = str(num)     list_num = list(string_num)     sum_of_num = 0      for i in list_num:         sum_of_num += int(i)      return sum_of_num", "output": "2"}
{"task": "detection", "input": "classify code:\ndef is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )", "output": "BUGGY"}
{"task": "search", "input": "search code:\nTakes a format string, turns it into a list of alternating string\n\nChoices:\n0: def tokenize_format_str(fstr, resolve_pos=True):     ret = []     if resolve_pos:         fstr = infer_positional_format_args(fstr)     formatter = Formatter()     for lit, fname, fspec, conv in formatter.parse(fstr):         if lit:             ret.append(lit)         if fname is None:             continue         ret.append(BaseFormatField(fname, fspec, conv))     return ret\n1: def apply_tsne(     data_matrix: ndarray,     n_components: int = 2,     learning_rate: float = 200.0,     n_iter: int = 500, ) -> ndarray:     if n_components < 1 or n_iter < 1:         raise ValueError(\"n_components and n_iter must be >= 1\")      n_samples = data_matrix.shape[0]     rng = np.random.default_rng()     embedding = rng.standard_normal((n_samples, n_components)) * 1e-4      high_dim_affinities = compute_pairwise_affinities(data_matrix)     high_dim_affinities = np.maximum(high_dim_affinities, 1e-12)      embedding_increment = np.zeros_like(embedding)     momentum = 0.5      for iteration in range(n_iter):         low_dim_affinities, numerator_matrix = compute_low_dim_affinities(embedding)         low_dim_affinities = np.maximum(low_dim_affinities, 1e-12)          affinity_diff = high_dim_affinities - low_dim_affinities          gradient = 4 * (             np.dot((affinity_diff * numerator_matrix), embedding)             - np.multiply(                 np.sum(affinity_diff * numerator_matrix, axis=1)[:, np.newaxis],                 embedding,             )         )          embedding_increment = momentum * embedding_increment - learning_rate * gradient         embedding += embedding_increment          if iteration == int(n_iter / 4):             momentum = 0.8      return embedding\n2: def exactly_n(iterable, n, predicate=bool):     iterator = filter(predicate, iterable)     if n <= 0:         if n < 0:             return False         for _ in iterator:             return False         return True      iterator = islice(iterator, n - 1, None)     for _ in iterator:         for _ in iterator:             return False         return True     return False", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef compute_low_dim_affinities(embedding_matrix: ndarray) -> tuple[ndarray, ndarray]:\n    squared_sum = np.sum(np.square(embedding_matrix), axis=1)\n    numerator_matrix = 1 / (\n        1\n        + np.add(\n            np.add(-2 * np.dot(embedding_matrix, embedding_matrix.T), squared_sum).T,\n            squared_sum,\n        )\n    )\n    np.fill_diagonal(numerator_matrix, 0)\n\n    q_matrix = numerator_matrix / np.sum(numerator_matrix)\n    return q_matrix, numerator_matrix", "output": "Compute low-dimensional affinities (Q matrix) using a Student-t distribution."}
{"task": "detection", "input": "classify code:\ndef prime_sieve(n: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n ** 0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "CORRECT"}
{"task": "search", "input": "search code:\nGenerate a random graph\n\nChoices:\n0: def horn_schunck(     image0: np.ndarray,     image1: np.ndarray,     num_iter: SupportsIndex,     alpha: float | None = None, ) -> tuple[np.ndarray, np.ndarray]:     if alpha is None:         alpha = 0.1      # Initialize flow     horizontal_flow = np.zeros_like(image0)     vertical_flow = np.zeros_like(image0)      # Prepare kernels for the calculation of the derivatives and the average velocity     kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25     kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25     kernel_t = np.array([[1, 1], [1, 1]]) * 0.25     kernel_laplacian = np.array(         [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]     )      # Iteratively refine the flow     for _ in range(num_iter):         warped_image = warp(image0, horizontal_flow, vertical_flow)         derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)         derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)         derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)          avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)         avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)          # This updates the flow as proposed in the paper (Step 12)         update = (             derivative_x * avg_horizontal_velocity             + derivative_y * avg_vertical_velocity             + derivative_t         )         update = update / (alpha**2 + derivative_x**2 + derivative_y**2)          horizontal_flow = avg_horizontal_velocity - derivative_x * update         vertical_flow = avg_vertical_velocity - derivative_y * update      return horizontal_flow, vertical_flow\n1: def random_graph(     vertices_number: int, probability: float, directed: bool = False ) -> dict:     graph: dict = {i: [] for i in range(vertices_number)}      # if probability is greater or equal than 1, then generate a complete graph     if probability >= 1:         return complete_graph(vertices_number)     # if probability is lower or equal than 0, then return a graph without edges     if probability <= 0:         return graph      # for each couple of nodes, add an edge from u to v     # if the number randomly generated is greater than probability probability     for i in range(vertices_number):         for j in range(i + 1, vertices_number):             if random.random() < probability:                 graph[i].append(j)                 if not directed:                     # if the graph is undirected, add an edge in from j to i, either                     graph[j].append(i)     return graph\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(nth: int = 10001) -> int:\n\n    count = 0\n    number = 1\n    while count != nth and number < 3:\n        number += 1\n        if is_prime(number):\n            count += 1\n    while count != nth:\n        number += 2\n        if is_prime(number):\n            count += 1\n    return number", "output": "Returns the n-th prime number."}
{"task": "search", "input": "search code:\nEquivalent to ``list(permutations(iterable, r))[index]```\n\nChoices:\n0: def binary_exp_iterative(base: float, exponent: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res *= base          base *= base         exponent >>= 1      return res\n1: def search_scraper(anime_name: str) -> list:      # concat the name to form the search url.     search_url = f\"{BASE_URL}/search?keyword={anime_name}\"      response = httpx.get(         search_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10     )  # request the url.      # Is the response ok?     response.raise_for_status()      # parse with soup.     soup = BeautifulSoup(response.text, \"html.parser\")      # get list of anime     anime_ul = soup.find(\"ul\", {\"class\": \"items\"})     if anime_ul is None or isinstance(anime_ul, NavigableString):         msg = f\"Could not find and anime with name {anime_name}\"         raise ValueError(msg)     anime_li = anime_ul.children      # for each anime, insert to list. the name and url.     anime_list = []     for anime in anime_li:         if isinstance(anime, Tag):             anime_url = anime.find(\"a\")             if anime_url is None or isinstance(anime_url, NavigableString):                 continue             anime_title = anime.find(\"a\")             if anime_title is None or isinstance(anime_title, NavigableString):                 continue              anime_list.append({\"title\": anime_title[\"title\"], \"url\": anime_url[\"href\"]})      return anime_list\n2: def nth_permutation(iterable, r, index):     pool = list(iterable)     n = len(pool)      if r is None or r == n:         r, c = n, factorial(n)     elif not 0 <= r < n:         raise ValueError     else:         c = perm(n, r)     assert c > 0  # factorial(n)>0, and r<n so perm(n,r) is never zero      if index < 0:         index += c      if not 0 <= index < c:         raise IndexError      result = [0] * r     q = index * factorial(n) // c if r < n else index     for d in range(1, n + 1):         q, i = divmod(q, d)         if 0 <= n - d < r:             result[n - d] = i         if q == 0:             break      return tuple(map(pool.pop, result))", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef binary_xor(a: int, b: int) -> str:\n    if a < 0 or b < 0:\n        raise ValueError(\"the value of both inputs must be positive\")\n\n    a_binary = str(bin(a))[2:]  # remove the leading \"0b\"\n    b_binary = str(bin(b))[2:]  # remove the leading \"0b\"\n\n    max_len = max(len(a_binary), len(b_binary))\n\n    return \"0b\" + \"\".join(\n        str(int(char_a != char_b))\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\n    )", "output": "Take in 2 integers, convert them to binary,"}
{"task": "summary", "input": "summarize code:\ndef mish(vector: np.ndarray) -> np.ndarray:\n    return vector * np.tanh(softplus(vector))", "output": "Implements the Mish activation function."}
{"task": "summary", "input": "summarize code:\ndef harmonic_mean(series: list) -> float:\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 0\n    for val in series:\n        answer += 1 / val\n    return len(series) / answer", "output": "return the harmonic mean of series"}
{"task": "detection", "input": "classify code:\ndef maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef pancake_sort(arr):\n    cur = len(arr)\n    while cur > 1:\n        # Find the maximum number in arr\n        mi = arr.index(max(arr[0:cur]))\n        # Reverse from 0 to mi\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\n        # Reverse whole list\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\n        cur -= 1\n    return arr", "output": "Sort Array with Pancake Sort."}
{"task": "search", "input": "search code:\nReturns all the possible families of digit replacements in a number which\n\nChoices:\n0: def patience_sort(collection: list) -> list:     stacks: list[Stack] = []     # sort into stacks     for element in collection:         new_stacks = Stack([element])         i = bisect_left(stacks, new_stacks)         if i != len(stacks):             stacks[i].append(element)         else:             stacks.append(new_stacks)      # use a heap-based merge to merge stack efficiently     collection[:] = merge(*(reversed(stack) for stack in stacks))     return collection\n1: def parse_token(token: str | float) -> float | str:     if token in OPERATORS:         return token     try:         return float(token)     except ValueError:         msg = f\"{token} is neither a number nor a valid operator\"         raise ValueError(msg)\n2: def digit_replacements(number: int) -> list[list[int]]:     number_str = str(number)     replacements = []     digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]      for duplicate in Counter(number_str) - Counter(set(number_str)):         family = [int(number_str.replace(duplicate, digit)) for digit in digits]         replacements.append(family)      return replacements", "output": "2"}
{"task": "search", "input": "search code:\nReturns a list of nodes value from a particular level:\n\nChoices:\n0: def get_nodes_from_left_to_right(root: Node | None, level: int) -> Generator[int]:      def populate_output(root: Node | None, level: int) -> Generator[int]:         if not root:             return         if level == 1:             yield root.data         elif level > 1:             yield from populate_output(root.left, level - 1)             yield from populate_output(root.right, level - 1)      yield from populate_output(root, level)\n1: def solution(power: int = 1000) -> int:     n = 2**power     r = 0     while n:         r, n = r + n % 10, n // 10     return r\n2: def solution(n: int = 10) -> str:     if not isinstance(n, int) or n < 0:         raise ValueError(\"Invalid input\")     modulus = 10**n     number = 28433 * (pow(2, 7830457, modulus)) + 1     return str(number % modulus)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef pigeon_sort(array):\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "def pigeon_sort(array):\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if(len(array) == 0):\n        return array\n\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array"}
{"task": "search", "input": "search code:\nTransforms a snake_case given string to camelCase (or PascalCase if indicated)\n\nChoices:\n0: def snake_to_camel_case(input_str: str, use_pascal: bool = False) -> str:      if not isinstance(input_str, str):         msg = f\"Expected string as input, found {type(input_str)}\"         raise ValueError(msg)     if not isinstance(use_pascal, bool):         msg = f\"Expected boolean as use_pascal parameter, found {type(use_pascal)}\"         raise ValueError(msg)      words = input_str.split(\"_\")      start_index = 0 if use_pascal else 1      words_to_capitalize = words[start_index:]      capitalized_words = [word[0].upper() + word[1:] for word in words_to_capitalize]      initial_word = \"\" if use_pascal else words[0]      return \"\".join([initial_word, *capitalized_words])\n1: def naturaldate(value) -> str:     try:         value = dt.date(value.year, value.month, value.day)     except AttributeError:         # Passed value wasn't date-ish         return value     except (OverflowError, ValueError):         # Date arguments out of range         return value     delta = _abs_timedelta(value - dt.date.today())     if delta.days >= 5 * 365 / 12:         return naturalday(value, \"%b %d %Y\")     return naturalday(value)\n2: def benchmark() -> None:      def do_benchmark(number: int) -> None:         setup = \"import __main__ as z\"         print(f\"Benchmark when {number = }:\")         print(f\"{get_set_bits_count_using_modulo_operator(number) = }\")         timing = timeit(             f\"z.get_set_bits_count_using_modulo_operator({number})\", setup=setup         )         print(f\"timeit() runs in {timing} seconds\")         print(f\"{get_set_bits_count_using_brian_kernighans_algorithm(number) = }\")         timing = timeit(             f\"z.get_set_bits_count_using_brian_kernighans_algorithm({number})\",             setup=setup,         )         print(f\"timeit() runs in {timing} seconds\")      for number in (25, 37, 58, 0):         do_benchmark(number)         print()", "output": "0"}
{"task": "search", "input": "search code:\nPure implementation of bubble sort algorithm in Python\n\nChoices:\n0: def bubble_sort_iterative(collection: list[Any]) -> list[Any]:     length = len(collection)     for i in reversed(range(length)):         swapped = False         for j in range(i):             if collection[j] > collection[j + 1]:                 swapped = True                 collection[j], collection[j + 1] = collection[j + 1], collection[j]         if not swapped:             break  # Stop iteration if the collection is sorted.     return collection\n1: def centripetal(mass: float, velocity: float, radius: float) -> float:     if mass < 0:         raise ValueError(\"The mass of the body cannot be negative\")     if radius <= 0:         raise ValueError(\"The radius is always a positive non zero integer\")     return (mass * (velocity) ** 2) / radius\n2: def closing_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:     if kernel is None:         kernel = np.ones((3, 3))     return transform(transform(image, \"erosion\", kernel), \"dilation\", kernel)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef search(target: int, prime_list: list) -> bool:\n    \"\"\"\n    function to search a number in a list using Binary Search.\n    >>> search(3, [1, 2, 3])\n    True\n    >>> search(4, [1, 2, 3])\n    False\n    >>> search(101, list(range(-100, 100)))\n    False\n    \"\"\"\n\n    left, right = 0, len(prime_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if prime_list[middle] == target:\n            return True\n        elif prime_list[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return False", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCalculate the area of a parallelogram.\n\nChoices:\n0: def area_parallelogram(base: float, height: float) -> float:     if base < 0 or height < 0:         raise ValueError(\"area_parallelogram() only accepts non-negative values\")     return base * height\n1: def length_conversion(value: float, from_type: str, to_type: str) -> float:      from_sanitized = from_type.lower().strip(\"s\")     to_sanitized = to_type.lower().strip(\"s\")      from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)     to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)      if from_sanitized not in METRIC_CONVERSION:         msg = (             f\"Invalid 'from_type' value: {from_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     if to_sanitized not in METRIC_CONVERSION:         msg = (             f\"Invalid 'to_type' value: {to_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     from_exponent = METRIC_CONVERSION[from_sanitized]     to_exponent = METRIC_CONVERSION[to_sanitized]     exponent = 1      if from_exponent > to_exponent:         exponent = from_exponent - to_exponent     else:         exponent = -(to_exponent - from_exponent)      return value * pow(10, exponent)\n2: def exits_word(     board: list[list[str]],     word: str,     row: int,     column: int,     word_index: int,     visited_points_set: set[int], ) -> bool:      if board[row][column] != word[word_index]:         return False      if word_index == len(word) - 1:         return True      traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]     len_board = len(board)     len_board_column = len(board[0])     for direction in traverts_directions:         next_i = row + direction[0]         next_j = column + direction[1]         if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):             continue          key = get_point_key(len_board, len_board_column, next_i, next_j)         if key in visited_points_set:             continue          visited_points_set.add(key)         if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):             return True          visited_points_set.remove(key)      return False", "output": "0"}
{"task": "search", "input": "search code:\nThis function performs Gaussian elimination method\n\nChoices:\n0: def rstrip(iterable, pred):     cache = []     cache_append = cache.append     cache_clear = cache.clear     for x in iterable:         if pred(x):             cache_append(x)         else:             yield from cache             cache_clear()             yield x\n1: def ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:     if (voltage, current, resistance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance < 0:         raise ValueError(\"Resistance cannot be negative\")     if voltage == 0:         return {\"voltage\": float(current * resistance)}     elif current == 0:         return {\"current\": voltage / resistance}     elif resistance == 0:         return {\"resistance\": voltage / current}     else:         raise ValueError(\"Exactly one argument must be 0\")\n2: def gaussian_elimination(     coefficients: NDArray[float64], vector: NDArray[float64] ) -> NDArray[float64]:     # coefficients must to be a square matrix so we need to check first     rows, columns = np.shape(coefficients)     if rows != columns:         return np.array((), dtype=float)      # augmented matrix     augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)     augmented_mat = augmented_mat.astype(\"float64\")      # scale the matrix leaving it triangular     for row in range(rows - 1):         pivot = augmented_mat[row, row]         for col in range(row + 1, columns):             factor = augmented_mat[col, row] / pivot             augmented_mat[col, :] -= factor * augmented_mat[row, :]      x = retroactive_resolution(         augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]     )      return x", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef calculate_waiting_times(duration_times: List[int]) -> List[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times", "output": "def calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times"}
{"task": "detection", "input": "classify code:\ndef text_to_bits(text, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_to_bits(\"msg\")\n    '011011010111001101100111'\n    \"\"\"\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \"big\"))[2:]\n    return bits.zfill(8 * ((len(bits) + 7) // 8))", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCheck if a number is a perfect cube or not using binary search.\n\nChoices:\n0: def example(wav_file_path: str = \"./path-to-file/sample.wav\") -> np.ndarray:     from scipy.io import wavfile      # Load the audio from the WAV file     sample_rate, audio = wavfile.read(wav_file_path)      # Calculate MFCCs     return mfcc(audio, sample_rate)\n1: def decode(coded: str) -> str:     if set(coded) - {\"A\", \"B\", \" \"} != set():         raise Exception(\"decode() accepts only 'A', 'B' and spaces\")     decoded = \"\"     for word in coded.split():         while len(word) != 0:             decoded += decode_dict[word[:5]]             word = word[5:]         decoded += \" \"     return decoded.strip()\n2: def perfect_cube_binary_search(n: int) -> bool:     if not isinstance(n, int):         raise TypeError(\"perfect_cube_binary_search() only accepts integers\")     if n < 0:         n = -n     left = 0     right = n     while left <= right:         mid = left + (right - left) // 2         if mid * mid * mid == n:             return True         elif mid * mid * mid < n:             left = mid + 1         else:             right = mid - 1     return False", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )", "output": "def question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )"}
{"task": "search", "input": "search code:\nGenerates all possible combinations of k numbers out of 1 ... n using backtracking.\n\nChoices:\n0: def _running_median_minheap_only(iterator):  # pragma: no cover     \"Backport of non-windowed running_median() for Python 3.13 and prior.\"      read = iterator.__next__     lo = []  # max-heap (actually a minheap with negated values)     hi = []  # min-heap (same size as or one smaller than lo)      with suppress(StopIteration):         while True:             heappush(lo, -heappushpop(hi, read()))             yield -lo[0]              heappush(hi, -heappushpop(lo, -read()))             yield (hi[0] - lo[0]) / 2\n1: def generate_all_combinations(n: int, k: int) -> list[list[int]]:     if k < 0:         raise ValueError(\"k must not be negative\")     if n < 0:         raise ValueError(\"n must not be negative\")      result: list[list[int]] = []     create_all_state(1, n, k, [], result)     return result\n2: def split_punct_ws(text):     return [w for w in _punct_re.split(text) if w]", "output": "1"}
{"task": "search", "input": "search code:\nCalculates the sum of cost function derivative\n\nChoices:\n0: def summation_of_cost_derivative(index, end=m):     summation_value = 0     for i in range(end):         if index == -1:             summation_value += _error(i)         else:             summation_value += _error(i) * train_data[i][0][index]     return summation_value\n1: def generate_sum_of_subsets_solutions(nums: list[int], max_sum: int) -> list[list[int]]:      result: list[list[int]] = []     path: list[int] = []     num_index = 0     remaining_nums_sum = sum(nums)     create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)     return result\n2: def gronsfeld(text: str, key: str) -> str:     ascii_len = len(ascii_uppercase)     key_len = len(key)     encrypted_text = \"\"     keys = [int(char) for char in key]     upper_case_text = text.upper()      for i, char in enumerate(upper_case_text):         if char in ascii_uppercase:             new_position = (ascii_uppercase.index(char) + keys[i % key_len]) % ascii_len             shifted_letter = ascii_uppercase[new_position]             encrypted_text += shifted_letter         else:             encrypted_text += char      return encrypted_text", "output": "0"}
{"task": "search", "input": "search code:\nCalculates the value of Gamma function of num\n\nChoices:\n0: def compute_transform_tables(     source_string: str,     destination_string: str,     copy_cost: int,     replace_cost: int,     delete_cost: int,     insert_cost: int, ) -> tuple[list[list[int]], list[list[str]]]:     source_seq = list(source_string)     destination_seq = list(destination_string)     len_source_seq = len(source_seq)     len_destination_seq = len(destination_seq)     costs = [         [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]     ops = [         [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]      for i in range(1, len_source_seq + 1):         costs[i][0] = i * delete_cost         ops[i][0] = f\"D{source_seq[i - 1]}\"      for i in range(1, len_destination_seq + 1):         costs[0][i] = i * insert_cost         ops[0][i] = f\"I{destination_seq[i - 1]}\"      for i in range(1, len_source_seq + 1):         for j in range(1, len_destination_seq + 1):             if source_seq[i - 1] == destination_seq[j - 1]:                 costs[i][j] = costs[i - 1][j - 1] + copy_cost                 ops[i][j] = f\"C{source_seq[i - 1]}\"             else:                 costs[i][j] = costs[i - 1][j - 1] + replace_cost                 ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])              if costs[i - 1][j] + delete_cost < costs[i][j]:                 costs[i][j] = costs[i - 1][j] + delete_cost                 ops[i][j] = f\"D{source_seq[i - 1]}\"              if costs[i][j - 1] + insert_cost < costs[i][j]:                 costs[i][j] = costs[i][j - 1] + insert_cost                 ops[i][j] = f\"I{destination_seq[j - 1]}\"      return costs, ops\n1: def filter_map(func, iterable):     for x in iterable:         y = func(x)         if y is not None:             yield y\n2: def gamma_recursive(num: float) -> float:     if num <= 0:         raise ValueError(\"math domain error\")     if num > 171.5:         raise OverflowError(\"math range error\")     elif num - int(num) not in (0, 0.5):         raise NotImplementedError(\"num must be an integer or a half-integer\")     elif num == 0.5:         return math.sqrt(math.pi)     else:         return 1.0 if num == 1 else (num - 1) * gamma_recursive(num - 1)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef run_linear_regression(data_x, data_y):\n    iterations = 100000\n    alpha = 0.0001550\n\n    no_features = data_x.shape[1]\n    len_data = data_x.shape[0] - 1\n\n    theta = np.zeros((1, no_features))\n\n    for i in range(iterations):\n        theta = run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)\n        error = sum_of_square_error(data_x, data_y, len_data, theta)\n        print(f\"At Iteration {i + 1} - Error is {error:.5f}\")\n\n    return theta", "output": "Implement Linear regression over the dataset"}
{"task": "search", "input": "search code:\nAsk for user value and validate that it fulfill a condition.\n\nChoices:\n0: def valid_input(     input_type: Callable[[object], num],  # Usually float or int     input_msg: str,     err_msg: str,     condition: Callable[[num], bool] = lambda _: True,     default: str | None = None, ) -> num:     while True:         try:             user_input = input_type(input(input_msg).strip() or default)             if condition(user_input):                 return user_input             else:                 print(f\"{user_input}: {err_msg}\")                 continue         except ValueError:             print(                 f\"{user_input}: Incorrect input type, expected {input_type.__name__!r}\"             )\n1: def remove_digit(num: int) -> int:      if not isinstance(num, int):         raise TypeError(\"only integers accepted as input\")     else:         num_str = str(abs(num))         num_transpositions = [list(num_str) for char in range(len(num_str))]         for index in range(len(num_str)):             num_transpositions[index].pop(index)         return max(             int(\"\".join(list(transposition))) for transposition in num_transpositions         )\n2: def create_edge(nodes, graph, cluster, c1):     for i in cluster[c1]:         count = 0         c2 = c1 + 1         while c2 < max(cluster.keys()):             for j in cluster[c2]:                 if int(i, 2) & int(j, 2) == int(i, 2):                     if tuple(nodes[i]) in graph:                         graph[tuple(nodes[i])].append(nodes[j])                     else:                         graph[tuple(nodes[i])] = [nodes[j]]                     count += 1             if count == 0:                 c2 = c2 + 1             else:                 break", "output": "0"}
{"task": "detection", "input": "classify code:\ndef text_from_bits(bits, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_from_bits('011011010111001101100111')\n    'msg'\n    \"\"\"\n    n = int(bits, 2)\n    return n.to_bytes((n.bit_length() + 7) // 8, \"big\").decode(encoding, errors) or \"\\0\"", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0", "output": "def is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0"}
{"task": "search", "input": "search code:\nReturns the maximum height that the object reach\n\nChoices:\n0: def max_tasks(tasks_info: list[tuple[int, int]]) -> list[int]:     tasks = sorted(         (             Task(task_id, deadline, reward)             for task_id, (deadline, reward) in enumerate(tasks_info)         ),         key=attrgetter(\"reward\"),         reverse=True,     )     return [task.task_id for i, task in enumerate(tasks, start=1) if task.deadline >= i]\n1: def max_height(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(angle)     return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)\n2: def kth_number(lst: list[int], k: int) -> int:     # pick a pivot and separate into list based on pivot.     pivot = random_pivot(lst)      # partition based on pivot     # linear time     small = [e for e in lst if e < pivot]     big = [e for e in lst if e > pivot]      # if we get lucky, pivot might be the element we want.     # we can easily see this:     # small (elements smaller than k)     # + pivot (kth element)     # + big (elements larger than k)     if len(small) == k - 1:         return pivot     # pivot is in elements bigger than k     elif len(small) < k - 1:         return kth_number(big, k - len(small) - 1)     # pivot is in elements smaller than k     else:         return kth_number(small, k)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef mkdir_p(path):\n    try:\n        os.makedirs(path)\n    except OSError as exc:\n        if exc.errno == errno.EEXIST and os.path.isdir(path):\n            return\n        raise\n    return", "output": "Creates a directory and any parent directories that may need to"}
{"task": "summary", "input": "summarize code:\ndef generate_parameters(formula: Formula) -> tuple[list[Clause], list[str]]:\n    clauses = formula.clauses\n    symbols_set = []\n    for clause in formula.clauses:\n        for literal in clause.literals:\n            symbol = literal[:2]\n            if symbol not in symbols_set:\n                symbols_set.append(symbol)\n    return clauses, symbols_set", "output": "| Return the clauses and symbols from a formula."}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 10000) -> int:\n    lychrel_nums = []\n    for num in range(1, limit):\n        iterations = 0\n        a = num\n        while iterations < 50:\n            num = sum_reverse(num)\n            iterations += 1\n            if is_palindrome(num):\n                break\n        else:\n            lychrel_nums.append(a)\n    return len(lychrel_nums)", "output": "Returns the count of all lychrel numbers below limit."}
{"task": "summary", "input": "summarize code:\ndef binary_search(sorted_collection: list[int], item: int) -> int:\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1", "output": "Pure implementation of a binary search algorithm in Python"}
{"task": "summary", "input": "summarize code:\ndef new_generation(cells: list[list[int]]) -> list[list[int]]:\n    next_generation = []\n    for i in range(len(cells)):\n        next_generation_row = []\n        for j in range(len(cells[i])):\n            # Get the number of live neighbours\n            neighbour_count = 0\n            if i > 0 and j > 0:\n                neighbour_count += cells[i - 1][j - 1]\n            if i > 0:\n                neighbour_count += cells[i - 1][j]\n            if i > 0 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i - 1][j + 1]\n            if j > 0:\n                neighbour_count += cells[i][j - 1]\n            if j < len(cells[i]) - 1:\n                neighbour_count += cells[i][j + 1]\n            if i < len(cells) - 1 and j > 0:\n                neighbour_count += cells[i + 1][j - 1]\n            if i < len(cells) - 1:\n                neighbour_count += cells[i + 1][j]\n            if i < len(cells) - 1 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i + 1][j + 1]\n\n            # Rules of the game of life (excerpt from Wikipedia):\n            # 1. Any live cell with two or three live neighbours survives.\n            # 2. Any dead cell with three live neighbours becomes a live cell.\n            # 3. All other live cells die in the next generation.\n            #    Similarly, all other dead cells stay dead.\n            alive = cells[i][j] == 1\n            if (alive and 2 <= neighbour_count <= 3) or (\n                not alive and neighbour_count == 3\n            ):\n                next_generation_row.append(1)\n            else:\n                next_generation_row.append(0)\n\n        next_generation.append(next_generation_row)\n    return next_generation", "output": "Generates the next generation for a given state of Conway's Game of Life."}
{"task": "detection", "input": "classify code:\ndef check_anagrams(a: str, b: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return sorted(a.lower()) == sorted(b.lower())\r", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef compute(a_i, k, i, n):\n    if i >= n:\n        return 0, i\n    if k > len(a_i):\n        a_i.extend([0 for _ in range(k - len(a_i))])\n\n    # note: a_i -> b * 10^k + c\n    # ds_b -> digitsum(b)\n    # ds_c -> digitsum(c)\n    start_i = i\n    ds_b, ds_c, diff = 0, 0, 0\n    for j in range(len(a_i)):\n        if j >= k:\n            ds_b += a_i[j]\n        else:\n            ds_c += a_i[j]\n\n    while i < n:\n        i += 1\n        addend = ds_c + ds_b\n        diff += addend\n        ds_c = 0\n        for j in range(k):\n            s = a_i[j] + addend\n            addend, a_i[j] = divmod(s, 10)\n\n            ds_c += a_i[j]\n\n        if addend > 0:\n            break\n\n    if addend > 0:\n        add(a_i, k, addend)\n    return diff, i - start_i", "output": "same as next_term(a_i, k, i, n) but computes terms without memoizing results."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 4000000) -> int:\n\n    fib = [0, 1]\n    i = 0\n    while fib[i] <= n:\n        fib.append(fib[i] + fib[i + 1])\n        if fib[i + 2] > n:\n            break\n        i += 1\n    total = 0\n    for j in range(len(fib) - 1):\n        if fib[j] % 2 == 0:\n            total += fib[j]\n\n    return total", "output": "Returns the sum of all even fibonacci sequence elements that are lower"}
{"task": "summary", "input": "summarize code:\ndef find_primitive(modulus: int) -> int | None:\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None", "output": "Find a primitive root modulo modulus, if one exists."}
{"task": "summary", "input": "summarize code:\ndef binary_count_setbits(a: int) -> int:\n    if a < 0:\n        raise ValueError(\"Input value must be a positive integer\")\n    elif isinstance(a, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    return bin(a).count(\"1\")", "output": "Take in 1 integer, return a number that is"}
{"task": "summary", "input": "summarize code:\ndef get_bounds(\n    fft_results: np.ndarray, samplerate: int\n) -> tuple[int | float, int | float]:\n    lowest = min([-20, np.min(fft_results[1 : samplerate // 2 - 1])])\n    highest = max([20, np.max(fft_results[1 : samplerate // 2 - 1])])\n    return lowest, highest", "output": "Get bounds for printing fft results"}
{"task": "detection", "input": "classify code:\ndef tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(min_block_length: int = 50) -> int:\n\n    fill_count_functions = [1] * min_block_length\n\n    for n in count(min_block_length):\n        fill_count_functions.append(1)\n\n        for block_length in range(min_block_length, n + 1):\n            for block_start in range(n - block_length):\n                fill_count_functions[n] += fill_count_functions[\n                    n - block_start - block_length - 1\n                ]\n\n            fill_count_functions[n] += 1\n\n        if fill_count_functions[n] > 1_000_000:\n            break\n\n    return n", "output": "Returns for given minimum block length the least value of n"}
{"task": "detection", "input": "classify code:\ndef get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:\n    \"\"\"\n    Find the sum of n terms in an arithmetic progression.\n\n    >>> sum_of_series(1, 1, 10)\n    55.0\n    >>> sum_of_series(1, 10, 100)\n    49600.0\n    \"\"\"\n    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\n    # formula for sum of series\n    return total", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPseudo-Code\n\nChoices:\n0: def data_safety_checker(list_vote: list, actual_result: float) -> bool:     safe = 0     not_safe = 0      if not isinstance(actual_result, float):         raise TypeError(\"Actual result should be float. Value passed is a list\")      for i in list_vote:         if i > actual_result:             safe = not_safe + 1         elif abs(abs(i) - abs(actual_result)) <= 0.1:             safe += 1         else:             not_safe += 1     return safe > not_safe\n1: def solution(n: int = 7) -> int:     pandigital_str = \"\".join(str(i) for i in range(1, n + 1))     perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]     pandigitals = [num for num in perm_list if is_prime(num)]     return max(pandigitals) if pandigitals else 0\n2: def util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:      # Base Case     if curr_ind == len(graph):         # return whether path exists between current and starting vertices         return graph[path[curr_ind - 1]][path[0]] == 1      # Recursive Step     for next_ver in range(len(graph)):         if valid_connection(graph, next_ver, curr_ind, path):             # Insert current vertex  into path as next transition             path[curr_ind] = next_ver             # Validate created path             if util_hamilton_cycle(graph, path, curr_ind + 1):                 return True             # Backtrack             path[curr_ind] = -1     return False", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef longest_common_substring(text1: str, text2: str) -> str:\n\n    if not (isinstance(text1, str) and isinstance(text2, str)):\n        raise ValueError(\"longest_common_substring() takes two strings for inputs\")\n\n    if not text1 or not text2:\n        return \"\"\n\n    text1_length = len(text1)\n    text2_length = len(text2)\n\n    dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]\n    end_pos = 0\n    max_length = 0\n\n    for i in range(1, text1_length + 1):\n        for j in range(1, text2_length + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n                if dp[i][j] > max_length:\n                    end_pos = i\n                    max_length = dp[i][j]\n\n    return text1[end_pos - max_length : end_pos]", "output": "Finds the longest common substring between two strings."}
{"task": "detection", "input": "classify code:\ndef atbash_slow(sequence: str) -> str:\n    \"\"\"\n    >>> atbash_slow(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash_slow(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    output = \"\"\n    for i in sequence:\n        extract = ord(i)\n        if 65 <= extract <= 90:\n            output += chr(155 - extract)\n        elif 97 <= extract <= 122:\n            output += chr(219 - extract)\n        else:\n            output += i\n    return output", "output": "CORRECT"}
{"task": "search", "input": "search code:\nDetermine whether the string is a valid phone number or not\n\nChoices:\n0: def solution(n: int = 20) -> int:     n = 2 * n  # middle entry of odd rows starting at row 3 is the solution for n = 1,     # 2, 3,...     k = n // 2      return int(factorial(n) / (factorial(k) * factorial(n - k)))\n1: def indian_phone_validator(phone: str) -> bool:     pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")     if match := re.search(pat, phone):         return match.string == phone     return False\n2: def get_module_callables(mod, ignore=None):     if isinstance(mod, str):         mod = sys.modules[mod]     types, funcs = {}, {}     for attr_name in dir(mod):         if ignore and ignore(attr_name):             continue         try:             attr = getattr(mod, attr_name)         except Exception:             continue         try:             attr_mod_name = attr.__module__         except AttributeError:             continue         if attr_mod_name != mod.__name__:             continue         if isinstance(attr, type):             types[attr_name] = attr         elif callable(attr):             funcs[attr_name] = attr     return types, funcs", "output": "1"}
{"task": "search", "input": "search code:\nCalculate the area of a circle.\n\nChoices:\n0: def printboard(board: list[list[int]]) -> None:     for i in range(len(board)):         for j in range(len(board)):             if board[i][j] == 1:                 print(\"Q\", end=\" \")  # Queen is present             else:                 print(\".\", end=\" \")  # Empty cell         print()\n1: def median(matrix: list[list[int]]) -> int:     # Flatten the matrix into a sorted 1D list     linear = sorted(num for row in matrix for num in row)      # Calculate the middle index     mid = (len(linear) - 1) // 2      # Return the median     return linear[mid]\n2: def area_circle(radius: float) -> float:     if radius < 0:         raise ValueError(\"area_circle() only accepts non-negative values\")     return pi * radius**2", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n    return sum(compute_truncated_primes(11))", "output": "Returns the sum of truncated primes"}
{"task": "repair", "input": "fix bug:\ndef minimum_cost_path(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]", "output": "def minimum_cost_path(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]"}
{"task": "detection", "input": "classify code:\ndef is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef double_linear_search(array: list[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r", "output": "CORRECT"}
{"task": "search", "input": "search code:\nYield ``(beginning, middle, end)`` tuples, where:\n\nChoices:\n0: def base64_decode(encoded_data: str) -> bytes:     # Make sure encoded_data is either a string or a bytes-like object     if not isinstance(encoded_data, bytes) and not isinstance(encoded_data, str):         msg = (             \"argument should be a bytes-like object or ASCII string, \"             f\"not '{encoded_data.__class__.__name__}'\"         )         raise TypeError(msg)      # In case encoded_data is a bytes-like object, make sure it contains only     # ASCII characters so we convert it to a string object     if isinstance(encoded_data, bytes):         try:             encoded_data = encoded_data.decode(\"utf-8\")         except UnicodeDecodeError:             raise ValueError(\"base64 encoded data should only contain ASCII characters\")      padding = encoded_data.count(\"=\")      # Check if the encoded string contains non base64 characters     if padding:         assert all(char in B64_CHARSET for char in encoded_data[:-padding]), (             \"Invalid base64 character(s) found.\"         )     else:         assert all(char in B64_CHARSET for char in encoded_data), (             \"Invalid base64 character(s) found.\"         )      # Check the padding     assert len(encoded_data) % 4 == 0 and padding < 3, \"Incorrect padding\"      if padding:         # Remove padding if there is one         encoded_data = encoded_data[:-padding]          binary_stream = \"\".join(             bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data         )[: -padding * 2]     else:         binary_stream = \"\".join(             bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data         )      data = [         int(binary_stream[index : index + 8], 2)         for index in range(0, len(binary_stream), 8)     ]      return bytes(data)\n1: def windowed_complete(iterable, n):     if n < 0:         raise ValueError('n must be >= 0')      seq = tuple(iterable)     size = len(seq)      if n > size:         raise ValueError('n must be <= len(seq)')      for i in range(size - n + 1):         beginning = seq[:i]         middle = seq[i : i + n]         end = seq[i + n :]         yield beginning, middle, end\n2: def solution(number: int = 10000000) -> int:     for i in range(1, number):         if CHAINS[i] is None:             chain(i + 1)      return CHAINS[:number].count(False)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result", "output": "BUGGY"}
{"task": "search", "input": "search code:\nDownload an image from a given URL by scraping the 'og:image' meta tag.\n\nChoices:\n0: def download_image(url: str) -> str:     try:         response = httpx.get(url, timeout=10)         response.raise_for_status()     except httpx.RequestError as e:         return f\"An error occurred during the HTTP request to {url}: {e!r}\"      soup = BeautifulSoup(response.text, \"html.parser\")     image_meta_tag = soup.find(\"meta\", {\"property\": \"og:image\"})     if not image_meta_tag:         return \"No meta tag with property 'og:image' was found.\"      image_url = image_meta_tag.get(\"content\")     if not image_url:         return f\"Image URL not found in meta tag {image_meta_tag}.\"      try:         image_data = httpx.get(image_url, timeout=10).content     except httpx.RequestError as e:         return f\"An error occurred during the HTTP request to {image_url}: {e!r}\"     if not image_data:         return f\"Failed to download the image from {image_url}.\"      file_name = f\"{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H-%M-%S}.jpg\"     with open(file_name, \"wb\") as out_file:         out_file.write(image_data)     return f\"Image downloaded and saved in the file {file_name}\"\n1: def add(digits, k, addend):     for j in range(k, len(digits)):         s = digits[j] + addend         if s >= 10:             quotient, digits[j] = divmod(s, 10)             addend = addend // 10 + quotient         else:             digits[j] = s             addend = addend // 10          if addend == 0:             break      while addend > 0:         addend, digit = divmod(addend, 10)         digits.append(digit)\n2: def solution(n: int = 1000) -> int:     answer = 1     gen = fibonacci_generator()     while len(str(next(gen))) < n:         answer += 1     return answer + 1", "output": "0"}
{"task": "search", "input": "search code:\nYield each of the items from *iterable*. If the iteration raises one of\n\nChoices:\n0: def fibonacci(n: int) -> int:     if n == 1 or not isinstance(n, int):         return 0     elif n == 2:         return 1     else:         sequence = [0, 1]         for i in range(2, n + 1):             sequence.append(sequence[i - 1] + sequence[i - 2])          return sequence[n]\n1: def iter_suppress(iterable, *exceptions):     try:         yield from iterable     except exceptions:         return\n2: def format_nonexp_repr(obj, req_names=None, opt_names=None, opt_key=None):     cn = obj.__class__.__name__     req_names = req_names or []     opt_names = opt_names or []     uniq_names, all_names = set(), []     for name in req_names + opt_names:         if name in uniq_names:             continue         uniq_names.add(name)         all_names.append(name)      if opt_key is None:         opt_key = lambda v: v is None     assert callable(opt_key)      items = [(name, getattr(obj, name, None)) for name in all_names]     labels = [f'{name}={val!r}' for name, val in items               if not (name in opt_names and opt_key(val))]     if not labels:         labels = ['id=%s' % id(obj)]     ret = '<{} {}>'.format(cn, ' '.join(labels))     return ret", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef decompress_data(data_bits: str) -> str:\n    lexicon = {\"0\": \"0\", \"1\": \"1\"}\n    result, curr_string = \"\", \"\"\n    index = len(lexicon)\n\n    for i in range(len(data_bits)):\n        curr_string += data_bits[i]\n        if curr_string not in lexicon:\n            continue\n\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n        lexicon[curr_string] = last_match_id + \"0\"\n\n        if math.log2(index).is_integer():\n            new_lex = {}\n            for curr_key in list(lexicon):\n                new_lex[\"0\" + curr_key] = lexicon.pop(curr_key)\n            lexicon = new_lex\n\n        lexicon[bin(index)[2:]] = last_match_id + \"1\"\n        index += 1\n        curr_string = \"\"\n    return result", "output": "Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm"}
{"task": "summary", "input": "summarize code:\ndef pdb_on_exception(limit=100):\n    import pdb\n    import sys\n    import traceback\n\n    def pdb_excepthook(exc_type, exc_val, exc_tb):\n        traceback.print_tb(exc_tb, limit=limit)\n        pdb.post_mortem(exc_tb)\n\n    sys.excepthook = pdb_excepthook\n    return", "output": "Installs a handler which, instead of exiting, attaches a"}
{"task": "summary", "input": "summarize code:\ndef calculate_turnaroundtime(\n    burst_time: list[int], no_of_processes: int, waiting_time: list[int]\n) -> list[int]:\n    turn_around_time = [0] * no_of_processes\n    for i in range(no_of_processes):\n        turn_around_time[i] = burst_time[i] + waiting_time[i]\n    return turn_around_time", "output": "Calculate the turn around time of each Processes"}
{"task": "summary", "input": "summarize code:\ndef simulate(\n    highway: list, number_of_update: int, probability: float, max_speed: int\n) -> list:\n\n    number_of_cells = len(highway[0])\n\n    for i in range(number_of_update):\n        next_speeds_calculated = update(highway[i], probability, max_speed)\n        real_next_speeds = [-1] * number_of_cells\n\n        for car_index in range(number_of_cells):\n            speed = next_speeds_calculated[car_index]\n            if speed != -1:\n                # Change the position based on the speed (with % to create the loop)\n                index = (car_index + speed) % number_of_cells\n                # Commit the change of position\n                real_next_speeds[index] = speed\n        highway.append(real_next_speeds)\n\n    return highway", "output": "The main function, it will simulate the evolution of the highway"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000000) -> int:\n    largest_number = 1\n    pre_counter = 1\n    counters = {1: 1}\n\n    for input1 in range(2, n):\n        counter = 0\n        number = input1\n\n        while True:\n            if number in counters:\n                counter += counters[number]\n                break\n            if number % 2 == 0:\n                number //= 2\n                counter += 1\n            else:\n                number = (3 * number) + 1\n                counter += 1\n\n        if input1 not in counters:\n            counters[input1] = counter\n\n        if counter > pre_counter:\n            largest_number = input1\n            pre_counter = counter\n    return largest_number", "output": "Returns the number under n that generates the longest sequence using the"}
{"task": "summary", "input": "summarize code:\ndef fast_primes(max_n: int) -> Generator[int]:\n    numbers: Generator = (i for i in range(1, (max_n + 1), 2))\n    # It's useless to test even numbers as they will not be prime\n    if max_n > 2:\n        yield 2  # Because 2 will not be tested, it's necessary to yield it now\n    for i in (n for n in numbers if n > 1):\n        bound = int(math.sqrt(i)) + 1\n        for j in range(3, bound, 2):\n            # As we removed the even numbers, we don't need them now\n            if (i % j) == 0:\n                break\n        else:\n            yield i", "output": "Return a list of all primes numbers up to max."}
{"task": "search", "input": "search code:\nThis function creates a state space tree and calls the safe function until it\n\nChoices:\n0: def solve(board: list[list[int]], row: int) -> bool:     if row >= len(board):         solution.append(board)         printboard(board)         print()         return True     for i in range(len(board)):         if is_safe(board, row, i):             board[row][i] = 1             solve(board, row + 1)             board[row][i] = 0     return False\n1: def select(     parent_1: tuple[str, float],     population_score: list[tuple[str, float]],     genes: list[str], ) -> list[str]:     pop = []     # Generate more children proportionally to the fitness score.     child_n = int(parent_1[1] * 100) + 1     child_n = 10 if child_n >= 10 else child_n     for _ in range(child_n):         parent_2 = population_score[random.randint(0, N_SELECTED)][0]          child_1, child_2 = crossover(parent_1[0], parent_2)         # Append new string to the population list.         pop.append(mutate(child_1, genes))         pop.append(mutate(child_2, genes))     return pop\n2: def solution(n_limit: int = 50 * 10**6) -> int:     n_sol = [0] * n_limit      for delta in range(1, (n_limit + 1) // 4 + 1):         for y in range(4 * delta - 1, delta, -1):             n = y * (4 * delta - y)             if n >= n_limit:                 break             n_sol[n] += 1      ans = 0     for i in range(n_limit):         if n_sol[i] == 1:             ans += 1      return ans", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef read_file_binary(file_path: str) -> str:\n    result = \"\"\n    try:\n        with open(file_path, \"rb\") as binary_file:\n            data = binary_file.read()\n        for dat in data:\n            curr_byte = f\"{dat:08b}\"\n            result += curr_byte\n        return result\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()", "output": "Reads given file as bytes and returns them as a long string"}
{"task": "summary", "input": "summarize code:\ndef find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer", "output": "Find the minimum change from the given denominations and value"}
{"task": "detection", "input": "classify code:\ndef pig_latin(word: str) -> str:\n    \"\"\"Compute the piglatin of a given string.\n\n    https://en.wikipedia.org/wiki/Pig_Latin\n\n    Usage examples:\n    >>> pig_latin(\"pig\")\n    'igpay'\n    >>> pig_latin(\"latin\")\n    'atinlay'\n    >>> pig_latin(\"banana\")\n    'ananabay'\n    >>> pig_latin(\"friends\")\n    'iendsfray'\n    >>> pig_latin(\"smile\")\n    'ilesmay'\n    >>> pig_latin(\"string\")\n    'ingstray'\n    >>> pig_latin(\"eat\")\n    'eatway'\n    >>> pig_latin(\"omelet\")\n    'omeletway'\n    >>> pig_latin(\"are\")\n    'areway'\n    >>> pig_latin(\" \")\n    ''\n    >>> pig_latin(None)\n    ''\n    \"\"\"\n    if not (word or \"\").strip():\n        return \"\"\n    word = word.lower()\n    if word[0] in \"aeiou\":\n        return f\"{word}way\"\n    for i, char in enumerate(word):  # noqa: B007\n        if char in \"aeiou\":\n            break\n    return f\"{word[i:]}{word[:i]}ay\"", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFind the area of the grid which contains as close to two million rectangles\n\nChoices:\n0: def solution(target: int = 2000000) -> int:     triangle_numbers: list[int] = [0]     idx: int      for idx in range(1, ceil(sqrt(target * 2) * 1.1)):         triangle_numbers.append(triangle_numbers[-1] + idx)      # we want this to be as close as possible to target     best_product: int = 0     # the area corresponding to the grid that gives the product closest to target     area: int = 0     # an estimate of b, using the quadratic formula     b_estimate: float     # the largest integer less than b_estimate     b_floor: int     # the largest integer less than b_estimate     b_ceil: int     # the triangle number corresponding to b_floor     triangle_b_first_guess: int     # the triangle number corresponding to b_ceil     triangle_b_second_guess: int      for idx_a, triangle_a in enumerate(triangle_numbers[1:], 1):         b_estimate = (-1 + sqrt(1 + 8 * target / triangle_a)) / 2         b_floor = floor(b_estimate)         b_ceil = ceil(b_estimate)         triangle_b_first_guess = triangle_numbers[b_floor]         triangle_b_second_guess = triangle_numbers[b_ceil]          if abs(target - triangle_b_first_guess * triangle_a) < abs(             target - best_product         ):             best_product = triangle_b_first_guess * triangle_a             area = idx_a * b_floor          if abs(target - triangle_b_second_guess * triangle_a) < abs(             target - best_product         ):             best_product = triangle_b_second_guess * triangle_a             area = idx_a * b_ceil      return area\n1: def surface_area_hemisphere(radius: float) -> float:     if radius < 0:         raise ValueError(\"surface_area_hemisphere() only accepts non-negative values\")     return 3 * pi * radius**2\n2: def vol_cube(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"vol_cube() only accepts non-negative values\")     return pow(side_length, 3)", "output": "0"}
{"task": "search", "input": "search code:\nReads source file, compresses it and writes the compressed result in destination\n\nChoices:\n0: def format_exception_only(etype, value):     # Gracefully handle (the way Python 2.4 and earlier did) the case of     # being called with (None, None).     if etype is None:         return [_format_final_exc_line(etype, value)]      stype = etype.__name__     smod = etype.__module__     if smod not in (\"__main__\", \"builtins\", \"exceptions\"):         stype = smod + '.' + stype      if not issubclass(etype, SyntaxError):         return [_format_final_exc_line(stype, value)]      # It was a syntax error; show exactly where the problem was found.     lines = []     filename = value.filename or \"<string>\"     lineno = str(value.lineno) or '?'     lines.append(f'  File \"{filename}\", line {lineno}\\n')     badline = value.text     offset = value.offset     if badline is not None:         lines.append('    %s\\n' % badline.strip())         if offset is not None:             caretspace = badline.rstrip('\\n')[:offset].lstrip()             # non-space whitespace (likes tabs) must be kept for alignment             caretspace = ((c.isspace() and c or ' ') for c in caretspace)             # only three spaces to account for offset1 == pos 0             lines.append('   %s^\\n' % ''.join(caretspace))     msg = value.msg or \"<no detail available>\"     lines.append(f\"{stype}: {msg}\\n\")     return lines\n1: def vol_spheres_union(     radius_1: float, radius_2: float, centers_distance: float ) -> float:      if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:         raise ValueError(             \"vol_spheres_union() only accepts non-negative values, non-zero radius\"         )      if centers_distance == 0:         return vol_sphere(max(radius_1, radius_2))      return (         vol_sphere(radius_1)         + vol_sphere(radius_2)         - vol_spheres_intersect(radius_1, radius_2, centers_distance)     )\n2: def compress(source_path: str, destination_path: str) -> None:     data_bits = read_file_binary(source_path)     compressed = compress_data(data_bits)     compressed = add_file_length(source_path, compressed)     write_file_binary(destination_path, compressed)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef takewhile_inclusive(predicate, iterable):\n    for x in iterable:\n        yield x\n        if not predicate(x):\n            break", "output": "A variant of :func:`takewhile` that yields one additional element."}
{"task": "search", "input": "search code:\nReturns the integer square root of a non-negative integer num.\n\nChoices:\n0: def display_linked_list(root: TreeNode | None) -> None:     current = root     while current:         if current.right is None:             print(current.data, end=\"\")             break         print(current.data, end=\" \")         current = current.right\n1: def integer_square_root(num: int) -> int:     if not isinstance(num, int) or num < 0:         raise ValueError(\"num must be non-negative integer\")      if num < 2:         return num      left_bound = 0     right_bound = num // 2      while left_bound <= right_bound:         mid = left_bound + (right_bound - left_bound) // 2         mid_squared = mid * mid         if mid_squared == num:             return mid          if mid_squared < num:             left_bound = mid + 1         else:             right_bound = mid - 1      return right_bound\n2: def distribute(n, iterable):     if n < 1:         raise ValueError('n must be at least 1')      children = tee(iterable, n)     return [islice(it, index, None, n) for index, it in enumerate(children)]", "output": "1"}
{"task": "search", "input": "search code:\nReturn number in string scientific notation z.wq x 10.\n\nChoices:\n0: def get_factors(     number: int, factors: Counter | None = None, factor: int = 2 ) -> Counter:      match number:         case int(number) if number == 1:             return Counter({1: 1})         case int(num) if number > 0:             number = num         case _:             raise TypeError(\"number must be integer and greater than zero\")      factors = factors or Counter()      if number == factor:  # break condition         # all numbers are factors of itself         factors[factor] += 1         return factors      if number % factor > 0:         # if it is greater than zero         # so it is not a factor of number and we check next number         return get_factors(number, factors, factor + 1)      factors[factor] += 1     # else we update factors (that is Counter(dict-like) type) and check again     return get_factors(number // factor, factors, factor)\n1: def scientific(value, precision=2):     exponents = {         \"0\": \"\",         \"1\": \"\",         \"2\": \"\",         \"3\": \"\",         \"4\": \"\",         \"5\": \"\",         \"6\": \"\",         \"7\": \"\",         \"8\": \"\",         \"9\": \"\",         \"+\": \"\",         \"-\": \"\",     }     negative = False     try:         if \"-\" in str(value):             value = str(value).replace(\"-\", \"\")             negative = True          if isinstance(value, str):             value = float(value)          fmt = \"{:.%se}\" % str(int(precision))         n = fmt.format(value)      except (ValueError, TypeError):         return value      part1, part2 = n.split(\"e\")     if \"-0\" in part2:         part2 = part2.replace(\"-0\", \"-\")      if \"+0\" in part2:         part2 = part2.replace(\"+0\", \"\")      new_part2 = []     if negative:         new_part2.append(exponents[\"-\"])      for char in part2:         new_part2.append(exponents[char])      final_str = part1 + \" x 10\" + \"\".join(new_part2)      return final_str\n2: def comp_and_swap(array: list[int], index1: int, index2: int, direction: int) -> None:     if (direction == 1 and array[index1] > array[index2]) or (         direction == 0 and array[index1] < array[index2]     ):         array[index1], array[index2] = array[index2], array[index1]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef n_input_and_gate(inputs: list[int]) -> int:\n    return int(all(inputs))", "output": "Calculate AND of a list of input values"}
{"task": "summary", "input": "summarize code:\ndef fib_recursive_cached(n: int) -> list[int]:\n\n    @functools.cache\n    def fib_recursive_term(i: int) -> int:\n        if i < 0:\n            raise ValueError(\"n is negative\")\n        if i < 2:\n            return i\n        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)\n\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    return [fib_recursive_term(i) for i in range(n + 1)]", "output": "Calculates the first n (0-indexed) Fibonacci numbers using recursion"}
{"task": "search", "input": "search code:\nSolve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4.\n\nChoices:\n0: def quote_fragment_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])     return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t                      for t in text])\n1: def is_harmonic_series(series: list) -> bool:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [1, 2/3, 2]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     if len(series) == 1 and series[0] != 0:         return True     rec_series = []     series_len = len(series)     for i in range(series_len):         if series[i] == 0:             raise ValueError(\"Input series cannot have 0 as an element\")         rec_series.append(1 / series[i])     common_diff = rec_series[1] - rec_series[0]     for index in range(2, series_len):         if rec_series[index] - rec_series[index - 1] != common_diff:             return False     return True\n2: def runge_kutta_gills(     func: Callable[[float, float], float],     x_initial: float,     y_initial: float,     step_size: float,     x_final: float, ) -> np.ndarray:     if x_initial >= x_final:         raise ValueError(             \"The final value of x must be greater than initial value of x.\"         )      if step_size <= 0:         raise ValueError(\"Step size must be positive.\")      n = int((x_final - x_initial) / step_size)     y = np.zeros(n + 1)     y[0] = y_initial     for i in range(n):         k1 = step_size * func(x_initial, y[i])         k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)         k3 = step_size * func(             x_initial + step_size / 2,             y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,         )         k4 = step_size * func(             x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3         )          y[i + 1] = y[i] + (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4) / 6         x_initial += step_size     return y", "output": "2"}
{"task": "search", "input": "search code:\nFunction checks the all possible combinations, and returns the count\n\nChoices:\n0: def combination_sum_iv(array: list[int], target: int) -> int:      def count_of_possible_combinations(target: int) -> int:         if target < 0:             return 0         if target == 0:             return 1         return sum(count_of_possible_combinations(target - item) for item in array)      return count_of_possible_combinations(target)\n1: def find_pattern(pattern: str, input_str: str) -> int:     answer = 0     # concatenate 'pattern' and 'input_str' and call z_function     # with concatenated string     z_result = z_function(pattern + input_str)      for val in z_result:         # if value is greater then length of the pattern string         # that means this index is starting position of substring         # which is equal to pattern string         if val >= len(pattern):             answer += 1      return answer\n2: def run_maze(     maze: list[list[int]],     i: int,     j: int,     destination_row: int,     destination_column: int,     solutions: list[list[int]], ) -> bool:     size = len(maze)     # Final check point.     if i == destination_row and j == destination_column and maze[i][j] == 0:         solutions[i][j] = 0         return True      lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds     upper_flag = (i < size) and (j < size)  # Check upper bounds      if lower_flag and upper_flag:         # check for already visited and block points.         block_flag = (solutions[i][j]) and (not maze[i][j])         if block_flag:             # check visited             solutions[i][j] = 0              # check for directions             if (                 run_maze(maze, i + 1, j, destination_row, destination_column, solutions)                 or run_maze(                     maze, i, j + 1, destination_row, destination_column, solutions                 )                 or run_maze(                     maze, i - 1, j, destination_row, destination_column, solutions                 )                 or run_maze(                     maze, i, j - 1, destination_row, destination_column, solutions                 )             ):                 return True              solutions[i][j] = 1             return False     return False", "output": "0"}
{"task": "search", "input": "search code:\nReturn the pull request number which triggered this action.\n\nChoices:\n0: def covariance_between_classes(     features: np.ndarray, labels: np.ndarray, classes: int ) -> np.ndarray:      general_data_mean = features.mean(1)     covariance_sum = np.nan     for i in range(classes):         data = features[:, labels == i]         device_data = data.shape[1]         data_mean = data.mean(1)         if i > 0:             # If covariance_sum is not None             covariance_sum += device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )         else:             # If covariance_sum is np.nan (i.e. first loop)             covariance_sum = device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )      return covariance_sum / features.shape[1]\n1: def get_files_url() -> str:     with open(os.environ[\"GITHUB_EVENT_PATH\"]) as file:         event = json.load(file)     return event[\"pull_request\"][\"url\"] + \"/files\"\n2: def inorder(root: Node | None) -> None:     if not root:  # None         return     else:         inorder(root.left)         print(root.value, end=\",\")         inorder(root.right)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef is_safe(row: int, col: int, rows: int, cols: int) -> bool:\n    return 0 <= row < rows and 0 <= col < cols", "output": "Checking whether coordinate (row, col) is valid or not."}
{"task": "summary", "input": "summarize code:\ndef merge(left_half: list, right_half: list) -> list:\n    sorted_array = [None] * (len(right_half) + len(left_half))\n\n    pointer1 = 0  # pointer to current index for left Half\n    pointer2 = 0  # pointer to current index for the right Half\n    index = 0  # pointer to current index for the sorted array Half\n\n    while pointer1 < len(left_half) and pointer2 < len(right_half):\n        if left_half[pointer1] < right_half[pointer2]:\n            sorted_array[index] = left_half[pointer1]\n            pointer1 += 1\n            index += 1\n        else:\n            sorted_array[index] = right_half[pointer2]\n            pointer2 += 1\n            index += 1\n    while pointer1 < len(left_half):\n        sorted_array[index] = left_half[pointer1]\n        pointer1 += 1\n        index += 1\n\n    while pointer2 < len(right_half):\n        sorted_array[index] = right_half[pointer2]\n        pointer2 += 1\n        index += 1\n\n    return sorted_array", "output": "Helper function for mergesort."}
{"task": "summary", "input": "summarize code:\ndef inorder(root: Node | None) -> Generator[int]:\n    if not root:\n        return\n    yield from inorder(root.left)\n    yield root.data\n    yield from inorder(root.right)", "output": "In-order traversal visits left subtree, root node, right subtree."}
{"task": "detection", "input": "classify code:\ndef identity(n: int) -> List[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nExtract the labels into a 1D uint8 numpy array [index].\n\nChoices:\n0: def _extract_labels(f, one_hot=False, num_classes=10):     print(\"Extracting\", f.name)     with gzip.GzipFile(fileobj=f) as bytestream:         magic = _read32(bytestream)         if magic != 2049:             msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"             raise ValueError(msg)         num_items = _read32(bytestream)         buf = bytestream.read(num_items)         labels = np.frombuffer(buf, dtype=np.uint8)         if one_hot:             return _dense_to_one_hot(labels, num_classes)         return labels\n1: def _ngettext_noop(singular, plural):     return (singular, plural)\n2: def _complex_sumprod(v1, v2):      real = attrgetter('real')     imag = attrgetter('imag')     r1 = chain(map(real, v1), map(neg, map(imag, v1)))     r2 = chain(map(real, v2), map(imag, v2))     i1 = chain(map(real, v1), map(imag, v1))     i2 = chain(map(imag, v2), map(real, v2))     return complex(_fsumprod(r1, r2), _fsumprod(i1, i2))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef merge(input_list: list, low: int, mid: int, high: int) -> list:\n    result = []\n    left, right = input_list[low:mid], input_list[mid : high + 1]\n    while left and right:\n        result.append((left if left[0] <= right[0] else right).pop(0))\n    input_list[low : high + 1] = result + left + right\n    return input_list", "output": "sorting left-half and right-half individually"}
{"task": "search", "input": "search code:\nHelper function for mergesort.\n\nChoices:\n0: def mean_absolute_error(predicted_y, original_y):     total = sum(abs(y - predicted_y[i]) for i, y in enumerate(original_y))     return total / len(original_y)\n1: def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:     return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))\n2: def merge(left_half: list, right_half: list) -> list:     sorted_array = [None] * (len(right_half) + len(left_half))      pointer1 = 0  # pointer to current index for left Half     pointer2 = 0  # pointer to current index for the right Half     index = 0  # pointer to current index for the sorted array Half      while pointer1 < len(left_half) and pointer2 < len(right_half):         if left_half[pointer1] < right_half[pointer2]:             sorted_array[index] = left_half[pointer1]             pointer1 += 1             index += 1         else:             sorted_array[index] = right_half[pointer2]             pointer2 += 1             index += 1     while pointer1 < len(left_half):         sorted_array[index] = left_half[pointer1]         pointer1 += 1         index += 1      while pointer2 < len(right_half):         sorted_array[index] = right_half[pointer2]         pointer2 += 1         index += 1      return sorted_array", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef get_squarefrees(unique_coefficients: set[int]) -> set[int]:\n\n    non_squarefrees = set()\n    for number in unique_coefficients:\n        divisor = 2\n        copy_number = number\n        while divisor**2 <= copy_number:\n            multiplicity = 0\n            while copy_number % divisor == 0:\n                copy_number //= divisor\n                multiplicity += 1\n            if multiplicity >= 2:\n                non_squarefrees.add(number)\n                break\n            divisor += 1\n\n    return unique_coefficients.difference(non_squarefrees)", "output": "Calculates the squarefree numbers inside unique_coefficients."}
{"task": "summary", "input": "summarize code:\ndef compute_truncated_primes(count: int = 11) -> list[int]:\n    list_truncated_primes: list[int] = []\n    num = 13\n    while len(list_truncated_primes) != count:\n        if validate(num):\n            list_nums = list_truncated_nums(num)\n            if all(is_prime(i) for i in list_nums):\n                list_truncated_primes.append(num)\n        num += 2\n    return list_truncated_primes", "output": "Returns the list of truncated primes"}
{"task": "detection", "input": "classify code:\ndef binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculates the work required to move an object from one orbit to another in a\n\nChoices:\n0: def orbital_transfer_work(     mass_central: float, mass_object: float, r_initial: float, r_final: float ) -> str:     gravitational_constant = 6.67430e-11      if r_initial <= 0 or r_final <= 0:         raise ValueError(\"Orbital radii must be greater than zero.\")      work = (gravitational_constant * mass_central * mass_object / 2) * (         1 / r_initial - 1 / r_final     )     return f\"{work:.3e}\"\n1: def mf_knapsack(i, wt, val, j):     global f  # a global dp table for knapsack     if f[i][j] < 0:         if j < wt[i - 1]:             val = mf_knapsack(i - 1, wt, val, j)         else:             val = max(                 mf_knapsack(i - 1, wt, val, j),                 mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],             )         f[i][j] = val     return f[i][j]\n2: def erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:     output = np.zeros_like(image)     image_padded = np.zeros(         (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)     )      # Copy image to padded image     image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image      # Iterate over image & apply kernel     for x in range(image.shape[1]):         for y in range(image.shape[0]):             summation = (                 kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]             ).sum()             output[y, x] = int(summation == 5)     return output", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    img_paths, annos = get_dataset(LABEL_DIR, IMG_DIR)\n    for index in range(NUMBER_IMAGES):\n        idxs = random.sample(range(len(annos)), 4)\n        new_image, new_annos, path = update_image_and_anno(\n            img_paths,\n            annos,\n            idxs,\n            OUTPUT_SIZE,\n            SCALE_RANGE,\n            filter_scale=FILTER_TINY_SCALE,\n        )\n\n        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n        letter_code = random_chars(32)\n        file_name = path.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        file_root = f\"{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}\"\n        cv2.imwrite(f\"{file_root}.jpg\", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])\n        print(f\"Succeeded {index + 1}/{NUMBER_IMAGES} with {file_name}\")\n        annos_list = []\n        for anno in new_annos:\n            width = anno[3] - anno[1]\n            height = anno[4] - anno[2]\n            x_center = anno[1] + width / 2\n            y_center = anno[2] + height / 2\n            obj = f\"{anno[0]} {x_center} {y_center} {width} {height}\"\n            annos_list.append(obj)\n        with open(f\"{file_root}.txt\", \"w\") as outfile:\n            outfile.write(\"\\n\".join(line for line in annos_list))", "output": "Get images list and annotations list from input dir."}
{"task": "summary", "input": "summarize code:\ndef is_9_pandigital(n: int) -> bool:\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")", "output": "Checks whether n is a 9-digit 1 to 9 pandigital number."}
{"task": "summary", "input": "summarize code:\ndef simple_fibonacci(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    n -= 2\n\n    while n > 0:\n        f2, f1 = f1 + f2, f2\n        n -= 1\n\n    return f2", "output": "Returns the nth number of the Fibonacci sequence that"}
{"task": "search", "input": "search code:\nYield the index of each item in *iterable* for which *pred* returns\n\nChoices:\n0: def opening_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:     if kernel is None:         np.ones((3, 3))      return transform(transform(image, \"dilation\", kernel), \"erosion\", kernel)\n1: def harmonic_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 0     for val in series:         answer += 1 / val     return len(series) / answer\n2: def rlocate(iterable, pred=bool, window_size=None):     if window_size is None:         try:             len_iter = len(iterable)             return (len_iter - i - 1 for i in locate(reversed(iterable), pred))         except TypeError:             pass      return reversed(list(locate(iterable, pred, window_size)))", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef dft(xarr):\n    N = len(xarr)\n    roots_of_unity = [e ** (n / N * tau * -1j) for n in range(N)]\n    for k in range(N):\n        coeffs = [roots_of_unity[k * n % N] for n in range(N)]\n        yield _complex_sumprod(xarr, coeffs)", "output": "Discrete Fourier Transform. *xarr* is a sequence of complex numbers."}
{"task": "detection", "input": "classify code:\ndef shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )", "output": "CORRECT"}
{"task": "search", "input": "search code:\nNon-windowed running_median() for Python 3.14+\n\nChoices:\n0: def interpolation_search_by_recursion(     sorted_collection: list[int], item: int, left: int = 0, right: int | None = None ) -> int | None:     if right is None:         right = len(sorted_collection) - 1     # avoid divided by 0 during interpolation     if sorted_collection[left] == sorted_collection[right]:         if sorted_collection[left] == item:             return left         return None      point = left + ((item - sorted_collection[left]) * (right - left)) // (         sorted_collection[right] - sorted_collection[left]     )      # out of range check     if point < 0 or point >= len(sorted_collection):         return None      if sorted_collection[point] == item:         return point     if point < left:         return interpolation_search_by_recursion(sorted_collection, item, point, left)     if point > right:         return interpolation_search_by_recursion(sorted_collection, item, right, left)     if sorted_collection[point] > item:         return interpolation_search_by_recursion(             sorted_collection, item, left, point - 1         )     return interpolation_search_by_recursion(sorted_collection, item, point + 1, right)\n1: def _running_median_minheap_and_maxheap(iterator):  # pragma: no cover     \"Non-windowed running_median() for Python 3.14+\"      read = iterator.__next__     lo = []  # max-heap     hi = []  # min-heap (same size as or one smaller than lo)      with suppress(StopIteration):         while True:             heappush_max(lo, heappushpop(hi, read()))             yield lo[0]              heappush(hi, heappushpop_max(lo, read()))             yield (lo[0] + hi[0]) / 2\n2: def combinations(n: int, k: int) -> int:      # If either of the conditions are true, the function is being asked     # to calculate a factorial of a negative number, which is not possible     if n < k or k < 0:         raise ValueError(\"Please enter positive integers for n and k where n >= k\")     res = 1     for i in range(k):         res *= n - i         res //= i + 1     return res", "output": "1"}
{"task": "search", "input": "search code:\nPrint the prime numbers up to n\n\nChoices:\n0: def random_chars(number_char: int = 32) -> str:     assert number_char > 1, \"The number of character should greater than 1\"     letter_code = ascii_lowercase + digits     return \"\".join(random.choice(letter_code) for _ in range(number_char))\n1: def prime_sieve_eratosthenes(num: int) -> list[int]:      if num <= 0:         raise ValueError(\"Input must be a positive integer\")      primes = [True] * (num + 1)      p = 2     while p * p <= num:         if primes[p]:             for i in range(p * p, num + 1, p):                 primes[i] = False         p += 1      return [prime for prime in range(2, num + 1) if primes[prime]]\n2: def height(root: Node | None) -> int:     return (max(height(root.left), height(root.right)) + 1) if root else 0", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef prime_sieve(limit: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "def prime_sieve(limit: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes"}
{"task": "search", "input": "search code:\nCount the number of set bits in a 32 bit integer\n\nChoices:\n0: def get_set_bits_count_using_brian_kernighans_algorithm(number: int) -> int:     if number < 0:         raise ValueError(\"the value of input must not be negative\")     result = 0     while number:         number &= number - 1         result += 1     return result\n1: def solution(n: int = 7) -> int:     pandigital_str = \"\".join(str(i) for i in range(1, n + 1))     perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]     pandigitals = [num for num in perm_list if is_prime(num)]     return max(pandigitals) if pandigitals else 0\n2: def covariance_between_classes(     features: np.ndarray, labels: np.ndarray, classes: int ) -> np.ndarray:      general_data_mean = features.mean(1)     covariance_sum = np.nan     for i in range(classes):         data = features[:, labels == i]         device_data = data.shape[1]         data_mean = data.mean(1)         if i > 0:             # If covariance_sum is not None             covariance_sum += device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )         else:             # If covariance_sum is np.nan (i.e. first loop)             covariance_sum = device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )      return covariance_sum / features.shape[1]", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef abs_max(x: List[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j", "output": "def abs_max(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j"}
{"task": "search", "input": "search code:\nInput Parameters:\n\nChoices:\n0: def first_effusion_rate(     effusion_rate: float, molar_mass_1: float, molar_mass_2: float ) -> float | ValueError:     return (         round(effusion_rate * sqrt(molar_mass_2 / molar_mass_1), 6)         if validate(effusion_rate, molar_mass_1, molar_mass_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )\n1: def main() -> None:     import seaborn as sns      mpg_data = sns.load_dataset(\"mpg\")      poly_reg = PolynomialRegression(degree=2)     poly_reg.fit(mpg_data.weight, mpg_data.mpg)      weight_sorted = np.sort(mpg_data.weight)     predictions = poly_reg.predict(weight_sorted)      plt.scatter(mpg_data.weight, mpg_data.mpg, color=\"gray\", alpha=0.5)     plt.plot(weight_sorted, predictions, color=\"red\", linewidth=3)     plt.title(\"Predicting Fuel Efficiency Using Polynomial Regression\")     plt.xlabel(\"Weight (lbs)\")     plt.ylabel(\"Fuel Efficiency (mpg)\")     plt.show()\n2: def find_python_set(node: Node) -> set:     sets = ({0, 1, 2}, {3, 4, 5})     for s in sets:         if node.data in s:             return s     msg = f\"{node.data} is not in {sets}\"     raise ValueError(msg)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef simple_moving_average(\n    data: Sequence[float], window_size: int\n) -> list[float | None]:\n    if window_size < 1:\n        raise ValueError(\"Window size must be a positive integer\")\n\n    sma: list[float | None] = []\n\n    for i in range(len(data)):\n        if i < window_size - 1:\n            sma.append(None)  # SMA not available for early data points\n        else:\n            window = data[i - window_size + 1 : i + 1]\n            sma_value = sum(window) / window_size\n            sma.append(sma_value)\n    return sma", "output": "Calculate the simple moving average (SMA) for some given time series data."}
{"task": "search", "input": "search code:\nThis function find the inverses of a i.e., a^(-1)\n\nChoices:\n0: def lstrip(iterable, strip_value=None):     return list(lstrip_iter(iterable, strip_value))\n1: def dis_between_closest_pair(points, points_counts, min_dis=float(\"inf\")):      for i in range(points_counts - 1):         for j in range(i + 1, points_counts):             current_dis = euclidean_distance_sqr(points[i], points[j])             min_dis = min(min_dis, current_dis)     return min_dis\n2: def invert_modulo(a: int, n: int) -> int:     (b, _x) = extended_euclid(a, n)  # Implemented below     if b < 0:         b = (b % n + n) % n     return b", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef merge(arr: list[int]) -> list[int]:\n    if len(arr) > 1:\n        middle_length = len(arr) // 2  # Finds the middle of the array\n        left_array = arr[\n            :middle_length\n        ]  # Creates an array of the elements in the first half.\n        right_array = arr[\n            middle_length:\n        ]  # Creates an array of the elements in the second half.\n        left_size = len(left_array)\n        right_size = len(right_array)\n        merge(left_array)  # Starts sorting the left.\n        merge(right_array)  # Starts sorting the right\n        left_index = 0  # Left Counter\n        right_index = 0  # Right Counter\n        index = 0  # Position Counter\n        while (\n            left_index < left_size and right_index < right_size\n        ):  # Runs until the lowers size of the left and right are sorted.\n            if left_array[left_index] < right_array[right_index]:\n                arr[index] = left_array[left_index]\n                left_index += 1\n            else:\n                arr[index] = right_array[right_index]\n                right_index += 1\n            index += 1\n        while (\n            left_index < left_size\n        ):  # Adds the left over elements in the left half of the array\n            arr[index] = left_array[left_index]\n            left_index += 1\n            index += 1\n        while (\n            right_index < right_size\n        ):  # Adds the left over elements in the right half of the array\n            arr[index] = right_array[right_index]\n            right_index += 1\n            index += 1\n    return arr", "output": "Return a sorted array."}
{"task": "summary", "input": "summarize code:\ndef union_set(x: Node, y: Node) -> None:\n    x, y = find_set(x), find_set(y)\n    if x == y:\n        return\n\n    elif x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1", "output": "Union of two sets."}
{"task": "summary", "input": "summarize code:\ndef comb_sort(data: list) -> list:\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data", "output": "Pure implementation of comb sort algorithm in Python"}
{"task": "search", "input": "search code:\nReturns the count of numbers <= 10000 with odd periods.\n\nChoices:\n0: def solution(n: int = 10000) -> int:     count_odd_periods = 0     for i in range(2, n + 1):         sr = sqrt(i)         if sr - floor(sr) != 0 and continuous_fraction_period(i) % 2 == 1:             count_odd_periods += 1     return count_odd_periods\n1: def is_prime(number: int) -> bool:      return all(number % divisor != 0 for divisor in range(2, isqrt(number) + 1))\n2: def choose(n: int, r: int) -> int:     ret = 1.0     for i in range(1, r + 1):         ret *= (n + 1 - i) / i     return round(ret)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [5, 7]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = array[i:]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq"}
{"task": "summary", "input": "summarize code:\ndef create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]", "output": "Create ngrams from a sentence"}
{"task": "search", "input": "search code:\nAdd two numbers as 32-bit ints.\n\nChoices:\n0: def naturaldate(value) -> str:     try:         value = dt.date(value.year, value.month, value.day)     except AttributeError:         # Passed value wasn't date-ish         return value     except (OverflowError, ValueError):         # Date arguments out of range         return value     delta = _abs_timedelta(value - dt.date.today())     if delta.days >= 5 * 365 / 12:         return naturalday(value, \"%b %d %Y\")     return naturalday(value)\n1: def get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:     coefficients = {1}     previous_coefficients = [1]     for _ in range(2, depth + 1):         coefficients_begins_one = [*previous_coefficients, 0]         coefficients_ends_one = [0, *previous_coefficients]         previous_coefficients = []         for x, y in zip(coefficients_begins_one, coefficients_ends_one):             coefficients.add(x + y)             previous_coefficients.append(x + y)     return coefficients\n2: def sum_32(a: int, b: int) -> int:     return (a + b) % 2**32", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef horn_schunck(\n    image0: np.ndarray,\n    image1: np.ndarray,\n    num_iter: SupportsIndex,\n    alpha: float | None = None,\n) -> tuple[np.ndarray, np.ndarray]:\n    if alpha is None:\n        alpha = 0.1\n\n    # Initialize flow\n    horizontal_flow = np.zeros_like(image0)\n    vertical_flow = np.zeros_like(image0)\n\n    # Prepare kernels for the calculation of the derivatives and the average velocity\n    kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25\n    kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25\n    kernel_t = np.array([[1, 1], [1, 1]]) * 0.25\n    kernel_laplacian = np.array(\n        [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]\n    )\n\n    # Iteratively refine the flow\n    for _ in range(num_iter):\n        warped_image = warp(image0, horizontal_flow, vertical_flow)\n        derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)\n        derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)\n        derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)\n\n        avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)\n        avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)\n\n        # This updates the flow as proposed in the paper (Step 12)\n        update = (\n            derivative_x * avg_horizontal_velocity\n            + derivative_y * avg_vertical_velocity\n            + derivative_t\n        )\n        update = update / (alpha**2 + derivative_x**2 + derivative_y**2)\n\n        horizontal_flow = avg_horizontal_velocity - derivative_x * update\n        vertical_flow = avg_vertical_velocity - derivative_y * update\n\n    return horizontal_flow, vertical_flow", "output": "This function performs the Horn-Schunck algorithm and returns the estimated"}
{"task": "search", "input": "search code:\nA happy number is a number which eventually reaches 1 when replaced by the sum of\n\nChoices:\n0: def is_happy_number(number: int) -> bool:     if not isinstance(number, int) or number <= 0:         msg = f\"{number=} must be a positive integer\"         raise ValueError(msg)      seen = set()     while number != 1 and number not in seen:         seen.add(number)         number = sum(int(digit) ** 2 for digit in str(number))     return number == 1\n1: def solution() -> int:     script_dir = os.path.dirname(os.path.realpath(__file__))     triangle_path = os.path.join(script_dir, \"triangle.txt\")      with open(triangle_path) as in_file:         triangle = [[int(i) for i in line.split()] for line in in_file]      while len(triangle) != 1:         last_row = triangle.pop()         curr_row = triangle[-1]         for j in range(len(last_row) - 1):             curr_row[j] += max(last_row[j], last_row[j + 1])     return triangle[0][0]\n2: def under2camel(under_string):     return ''.join(w.capitalize() or '_' for w in under_string.split('_'))", "output": "0"}
{"task": "search", "input": "search code:\nImplements the softmax function\n\nChoices:\n0: def solution(n: int = 1000) -> int:      squares = get_squares(n)     squares_set = set(squares)     for a in range(1, n // 3):         for b in range(a + 1, (n - a) // 2 + 1):             if (                 squares[a] + squares[b] in squares_set                 and squares[n - a - b] == squares[a] + squares[b]             ):                 return a * b * (n - a - b)      return -1\n1: def softmax(vector):      # Calculate e^x for each x in your vector where e is Euler's     # number (approximately 2.718)     exponent_vector = np.exp(vector)      # Add up the all the exponentials     sum_of_exponents = np.sum(exponent_vector)      # Divide every exponent by the sum of all exponents     softmax_vector = exponent_vector / sum_of_exponents      return softmax_vector\n2: def sdbm(plain_text: str) -> int:     hash_value = 0     for plain_chr in plain_text:         hash_value = (             ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value         )     return hash_value", "output": "1"}
{"task": "detection", "input": "classify code:\ndef palindromic_string(input_string: str) -> str:\n    \"\"\"\n    >>> palindromic_string('abbbaba')\n    'abbba'\n    >>> palindromic_string('ababa')\n    'ababa'\n\n    Manacher's algorithm which finds Longest palindromic Substring in linear time.\n\n    1. first this convert input_string(\"xyx\") into new_string(\"x|y|x\") where odd\n        positions are actual input characters.\n    2. for each character in new_string it find corresponding length and\n        store the length and left,right to store previously calculated info.\n        (please look the explanation for details)\n\n    3. return corresponding output_string by removing all \"|\"\n    \"\"\"\n    max_length = 0\n\n    # if input_string is \"aba\" than new_input_string become \"a|b|a\"\n    new_input_string = \"\"\n    output_string = \"\"\n\n    # append each character + \"|\" in new_string for range(0, length-1)\n    for i in input_string[: len(input_string) - 1]:\n        new_input_string += i + \"|\"\n    # append last character\n    new_input_string += input_string[-1]\n\n    # we will store the starting and ending of previous furthest ending palindromic\n    # substring\n    left, right = 0, 0\n\n    # length[i] shows the length of palindromic substring with center i\n    length = [1 for i in range(len(new_input_string))]\n\n    # for each character in new_string find corresponding palindromic string\n    start = 0\n    for j in range(len(new_input_string)):\n        k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)\n        while (\n            j - k >= 0\n            and j + k < len(new_input_string)\n            and new_input_string[k + j] == new_input_string[j - k]\n        ):\n            k += 1\n\n        length[j] = 2 * k - 1\n\n        # does this string is ending after the previously explored end (that is right) ?\n        # if yes the update the new right to the last index of this\n        if j + k - 1 > right:\n            left = j - k + 1\n            right = j + k - 1\n\n        # update max_length and start position\n        if max_length < length[j]:\n            max_length = length[j]\n            start = j\n\n    # create that string\n    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]\n    for i in s:\n        if i != \"|\":\n            output_string += i\n\n    return output_string", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef postorder(root: Node | None) -> Generator[int]:\n    if not root:\n        return\n    yield from postorder(root.left)\n    yield from postorder(root.right)\n    yield root.data", "output": "Post-order traversal visits left subtree, right subtree, root node."}
{"task": "detection", "input": "classify code:\ndef sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value", "output": "CORRECT"}
{"task": "search", "input": "search code:\nadds addend to digit array given in digits\n\nChoices:\n0: def add(digits, k, addend):     for j in range(k, len(digits)):         s = digits[j] + addend         if s >= 10:             quotient, digits[j] = divmod(s, 10)             addend = addend // 10 + quotient         else:             digits[j] = s             addend = addend // 10          if addend == 0:             break      while addend > 0:         addend, digit = divmod(addend, 10)         digits.append(digit)\n1: def distinct_combinations(iterable, r):     if r < 0:         raise ValueError('r must be non-negative')     elif r == 0:         yield ()         return     pool = tuple(iterable)     generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]     current_combo = [None] * r     level = 0     while generators:         try:             cur_idx, p = next(generators[-1])         except StopIteration:             generators.pop()             level -= 1             continue         current_combo[level] = p         if level + 1 == r:             yield tuple(current_combo)         else:             generators.append(                 unique_everseen(                     enumerate(pool[cur_idx + 1 :], cur_idx + 1),                     key=itemgetter(1),                 )             )             level += 1\n2: def merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:     if tree1 is None:         return tree2     if tree2 is None:         return tree1      tree1.value = tree1.value + tree2.value     tree1.left = merge_two_binary_trees(tree1.left, tree2.left)     tree1.right = merge_two_binary_trees(tree1.right, tree2.right)     return tree1", "output": "0"}
{"task": "search", "input": "search code:\nEncrypt a given `plaintext` (string) and `key` (string), returning the\n\nChoices:\n0: def solution(max_base: int = 10, max_power: int = 22) -> int:     bases = range(1, max_base)     powers = range(1, max_power)     return sum(         1 for power in powers for base in bases if len(str(base**power)) == power     )\n1: def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:     # Mark current node as visited and add to recursion stack     visited.add(vertex)     rec_stk.add(vertex)      for node in graph[vertex]:         if node not in visited:             if depth_first_search(graph, node, visited, rec_stk):                 return True         elif node in rec_stk:             return True      # The node needs to be removed from recursion stack before function ends     rec_stk.remove(vertex)     return False\n2: def encrypt(plaintext: str, key: str) -> str:     if not isinstance(plaintext, str):         raise TypeError(\"plaintext must be a string\")     if not isinstance(key, str):         raise TypeError(\"key must be a string\")      if not plaintext:         raise ValueError(\"plaintext is empty\")     if not key:         raise ValueError(\"key is empty\")      key += plaintext     plaintext = plaintext.lower()     key = key.lower()     plaintext_iterator = 0     key_iterator = 0     ciphertext = \"\"     while plaintext_iterator < len(plaintext):         if (             ord(plaintext[plaintext_iterator]) < 97             or ord(plaintext[plaintext_iterator]) > 122         ):             ciphertext += plaintext[plaintext_iterator]             plaintext_iterator += 1         elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:             key_iterator += 1         else:             ciphertext += chr(                 (                     (ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))                     - 97                 )                 % 26                 + 97             )             key_iterator += 1             plaintext_iterator += 1     return ciphertext", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef longest_subsequence(array: List[int]) -> List[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    isFound = False\n    i = 1\n    longest_subseq = []\n    while not isFound and i < array_length:\n        if array[i] < pivot:\n            isFound = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot] + longest_subsequence(temp_array)\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq"}
{"task": "summary", "input": "summarize code:\ndef assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:\n    if i == 0 and j == 0:\n        return []\n    elif ops[i][j][0] in {\"C\", \"R\"}:\n        seq = assemble_transformation(ops, i - 1, j - 1)\n        seq.append(ops[i][j])\n        return seq\n    elif ops[i][j][0] == \"D\":\n        seq = assemble_transformation(ops, i - 1, j)\n        seq.append(ops[i][j])\n        return seq\n    else:\n        seq = assemble_transformation(ops, i, j - 1)\n        seq.append(ops[i][j])\n        return seq", "output": "Assembles the transformations based on the ops table."}
{"task": "summary", "input": "summarize code:\ndef is_complete(board: list[list[int]]) -> bool:\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "Check if the board (matrix) has been completely filled with non-zero values."}
{"task": "search", "input": "search code:\nCalculates  = v/c, the given velocity as a fraction of c\n\nChoices:\n0: def beta(velocity: float) -> float:     if velocity > c:         raise ValueError(\"Speed must not exceed light speed 299,792,458 [m/s]!\")     elif velocity < 1:         # Usually the speed should be much higher than 1 (c order of magnitude)         raise ValueError(\"Speed must be greater than or equal to 1!\")      return velocity / c\n1: def shuffled(seq):     seq = list(seq)     random.shuffle(seq)     return seq\n2: def evaluate_recursive(expression: list[str]):      op = expression.pop(0)     if is_operand(op):         return int(op)      operation = operators[op]      a = evaluate_recursive(expression)     b = evaluate_recursive(expression)     return operation(a, b)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef newton_raphson(\n    f: RealFunc,\n    x0: float = 0,\n    max_iter: int = 100,\n    step: float = 1e-6,\n    max_error: float = 1e-6,\n    log_steps: bool = False,\n) -> tuple[float, float, list[float]]:\n\n    def f_derivative(x: float) -> float:\n        return calc_derivative(f, x, step)\n\n    a = x0  # Set initial guess\n    steps = []\n    for _ in range(max_iter):\n        if log_steps:  # Log intermediate steps\n            steps.append(a)\n\n        error = abs(f(a))\n        if error < max_error:\n            return a, error, steps\n\n        if f_derivative(a) == 0:\n            raise ZeroDivisionError(\"No converging solution found, zero derivative\")\n        a -= f(a) / f_derivative(a)  # Calculate next estimate\n    raise ArithmeticError(\"No converging solution found, iteration limit reached\")", "output": "Find a root of the given function f using the Newton-Raphson method."}
{"task": "search", "input": "search code:\nTakes list of strings `matrix_str` to parse the matrix and calculates the max sum.\n\nChoices:\n0: def solution(matrix_str: list[str] = MATRIX_2) -> int:      n = len(matrix_str)     arr = np.empty(shape=(n, n), dtype=int)     for row, matrix_row_str in enumerate(matrix_str):         matrix_row_list_str = matrix_row_str.split()         for col, elem_str in enumerate(matrix_row_list_str):             arr[row, col] = int(elem_str)      cache: dict[str, int] = {}     return solve(arr=arr, row=0, cols=set(range(n)), cache=cache)\n1: def array_equalization(vector: list[int], step_size: int) -> int:     if step_size <= 0:         raise ValueError(\"Step size must be positive and non-zero.\")     if not isinstance(step_size, int):         raise ValueError(\"Step size must be an integer.\")      unique_elements = set(vector)     min_updates = maxsize      for element in unique_elements:         elem_index = 0         updates = 0         while elem_index < len(vector):             if vector[elem_index] != element:                 updates += 1                 elem_index += step_size             else:                 elem_index += 1         min_updates = min(min_updates, updates)      return min_updates\n2: def floor_ceiling(root: Node | None, key: int) -> tuple[int | None, int | None]:     floor_val = None     ceiling_val = None      while root:         if root.key == key:             floor_val = root.key             ceiling_val = root.key             break          if key < root.key:             ceiling_val = root.key             root = root.left         else:             floor_val = root.key             root = root.right      return floor_val, ceiling_val", "output": "0"}
{"task": "search", "input": "search code:\nFind a root of the given function f using the Newton-Raphson method.\n\nChoices:\n0: def interleave_longest(*iterables):     for xs in zip_longest(*iterables, fillvalue=_marker):         for x in xs:             if x is not _marker:                 yield x\n1: def partition(src, key=bool):     bucketized = bucketize(src, key)     return bucketized.get(True, []), bucketized.get(False, [])\n2: def newton_raphson(     f: RealFunc,     x0: float = 0,     max_iter: int = 100,     step: float = 1e-6,     max_error: float = 1e-6,     log_steps: bool = False, ) -> tuple[float, float, list[float]]:      def f_derivative(x: float) -> float:         return calc_derivative(f, x, step)      a = x0  # Set initial guess     steps = []     for _ in range(max_iter):         if log_steps:  # Log intermediate steps             steps.append(a)          error = abs(f(a))         if error < max_error:             return a, error, steps          if f_derivative(a) == 0:             raise ZeroDivisionError(\"No converging solution found, zero derivative\")         a -= f(a) / f_derivative(a)  # Calculate next estimate     raise ArithmeticError(\"No converging solution found, iteration limit reached\")", "output": "2"}
{"task": "detection", "input": "classify code:\ndef dp_count(S, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 4)\n    4\n    >>> dp_count([1, 2, 3], 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 10)\n    5\n    >>> dp_count([10], 99)\n    0\n    >>> dp_count([4, 5, 6], 0)\n    1\n    >>> dp_count([1, 2, 3], -5)\n    0\n    \"\"\"\n    if n < 0:\n        return 0\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef create_state_space_tree(\n    nums: list[int],\n    max_sum: int,\n    num_index: int,\n    path: list[int],\n    result: list[list[int]],\n    remaining_nums_sum: int,\n) -> None:\n\n    if sum(path) > max_sum or (remaining_nums_sum + sum(path)) < max_sum:\n        return\n    if sum(path) == max_sum:\n        result.append(path)\n        return\n    for index in range(num_index, len(nums)):\n        create_state_space_tree(\n            nums,\n            max_sum,\n            index + 1,\n            [*path, nums[index]],\n            result,\n            remaining_nums_sum - nums[index],\n        )", "output": "Creates a state space tree to iterate through each branch using DFS."}
{"task": "detection", "input": "classify code:\ndef levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculates a list of totients from 0 to max_one exclusive, using the\n\nChoices:\n0: def get_totients(max_one: int) -> list[int]:     totients = np.arange(max_one)      for i in range(2, max_one):         if totients[i] == i:             x = np.arange(i, max_one, i)  # array of indexes to select             totients[x] -= totients[x] // i      return totients.tolist()\n1: def capacitor_series(capacitors: list[float]) -> float:      first_sum = 0.0     for index, capacitor in enumerate(capacitors):         if capacitor <= 0:             msg = f\"Capacitor at index {index} has a negative or zero value!\"             raise ValueError(msg)         first_sum += 1 / capacitor     return 1 / first_sum\n2: def right_rotation(node: MyNode) -> MyNode:     print(\"left rotation node:\", node.get_data())     ret = node.get_left()     assert ret is not None     node.set_left(ret.get_right())     ret.set_right(node)     h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1     node.set_height(h1)     h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1     ret.set_height(h2)     return ret", "output": "0"}
{"task": "search", "input": "search code:\nRun steep gradient descent and updates the Feature vector accordingly_\n\nChoices:\n0: def pheromone_update(     pheromone: list[list[float]],     cities: dict[int, list[int]],     pheromone_evaporation: float,     ants_route: list[list[int]],     q: float,  # Pheromone system parameters Q, which is a constant     best_path: list[int],     best_distance: float, ) -> tuple[list[list[float]], list[int], float]:     for a in range(len(cities)):  # Update the volatilization of pheromone on all routes         for b in range(len(cities)):             pheromone[a][b] *= pheromone_evaporation     for ant_route in ants_route:         total_distance = 0.0         for i in range(len(ant_route) - 1):  # Calculate total distance             total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])         delta_pheromone = q / total_distance         for i in range(len(ant_route) - 1):  # Update pheromones             pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone             pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][                 ant_route[i + 1]             ]          if total_distance < best_distance:             best_path = ant_route             best_distance = total_distance      return pheromone, best_path, best_distance\n1: def run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta):     n = len_data      prod = np.dot(theta, data_x.transpose())     prod -= data_y.transpose()     sum_grad = np.dot(prod, data_x)     theta = theta - (alpha / n) * sum_grad     return theta\n2: def generate_roman_numerals(num: int) -> str:      numerals = \"\"      m_count = num // 1000     numerals += m_count * \"M\"     num %= 1000      c_count = num // 100     if c_count == 9:         numerals += \"CM\"         c_count -= 9     elif c_count == 4:         numerals += \"CD\"         c_count -= 4     if c_count >= 5:         numerals += \"D\"         c_count -= 5     numerals += c_count * \"C\"     num %= 100      x_count = num // 10     if x_count == 9:         numerals += \"XC\"         x_count -= 9     elif x_count == 4:         numerals += \"XL\"         x_count -= 4     if x_count >= 5:         numerals += \"L\"         x_count -= 5     numerals += x_count * \"X\"     num %= 10      if num == 9:         numerals += \"IX\"         num -= 9     elif num == 4:         numerals += \"IV\"         num -= 4     if num >= 5:         numerals += \"V\"         num -= 5     numerals += num * \"I\"      return numerals", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution_fast() -> int:\n\n    for a in range(300):\n        for b in range(400):\n            c = 1000 - a - b\n            if a < b < c and (a**2) + (b**2) == (c**2):\n                return a * b * c\n\n    return -1", "output": "Returns the product of a,b,c which are Pythagorean Triplet that satisfies"}
{"task": "search", "input": "search code:\nreturns a unit basis vector with a One\n\nChoices:\n0: def unit_basis_vector(dimension: int, pos: int) -> Vector:     # precondition     assert isinstance(dimension, int)     assert isinstance(pos, int)     ans = [0] * dimension     ans[pos] = 1     return Vector(ans)\n1: def chain(number: int) -> bool:      if CHAINS[number - 1] is not None:         return CHAINS[number - 1]  # type: ignore[return-value]      number_chain = chain(next_number(number))     CHAINS[number - 1] = number_chain      while number < 10000000:         CHAINS[number - 1] = number_chain         number *= 10      return number_chain\n2: def solution(limit: int = 100) -> int:     singles: list[int] = [*list(range(1, 21)), 25]     doubles: list[int] = [2 * x for x in range(1, 21)] + [50]     triples: list[int] = [3 * x for x in range(1, 21)]     all_values: list[int] = singles + doubles + triples + [0]      num_checkouts: int = 0     double: int     throw1: int     throw2: int     checkout_total: int      for double in doubles:         for throw1, throw2 in combinations_with_replacement(all_values, 2):             checkout_total = double + throw1 + throw2             if checkout_total < limit:                 num_checkouts += 1      return num_checkouts", "output": "0"}
{"task": "search", "input": "search code:\nchecking whether the input series is geometric series or not\n\nChoices:\n0: def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive     array_length = len(array)     # If the array contains only one element, we return it (it's the stop condition of     # recursion)     if array_length <= 1:         return array         # Else     pivot = array[0]     is_found = False     i = 1     longest_subseq: list[int] = []     while not is_found and i < array_length:         if array[i] < pivot:             is_found = True             temp_array = array[i:]             temp_array = longest_subsequence(temp_array)             if len(temp_array) > len(longest_subseq):                 longest_subseq = temp_array         else:             i += 1      temp_array = [element for element in array[1:] if element >= pivot]     temp_array = [pivot, *longest_subsequence(temp_array)]     if len(temp_array) > len(longest_subseq):         return temp_array     else:         return longest_subseq\n1: def is_geometric_series(series: list) -> bool:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     if len(series) == 1:         return True     try:         common_ratio = series[1] / series[0]         for index in range(len(series) - 1):             if series[index + 1] / series[index] != common_ratio:                 return False     except ZeroDivisionError:         return False     return True\n2: def combination_sum_iv_dp_array(array: list[int], target: int) -> int:      def count_of_possible_combinations_with_dp_array(         target: int, dp_array: list[int]     ) -> int:         if target < 0:             return 0         if target == 0:             return 1         if dp_array[target] != -1:             return dp_array[target]         answer = sum(             count_of_possible_combinations_with_dp_array(target - item, dp_array)             for item in array         )         dp_array[target] = answer         return answer      dp_array = [-1] * (target + 1)     return count_of_possible_combinations_with_dp_array(target, dp_array)", "output": "1"}
{"task": "search", "input": "search code:\nDraw the Vicsek fractal at the specified position, with the specified\n\nChoices:\n0: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n1: def draw_vicsek_fractal(x: float, y: float, length: float, depth: float, color=\"blue\"):     turtle.speed(0)     turtle.hideturtle()     set_color(color)     draw_fractal_recursive(x, y, length, depth)     turtle.Screen().update()\n2: def mode(input_list: list) -> list[Any]:     if not input_list:         return []     result = [input_list.count(value) for value in input_list]     y = max(result)  # Gets the maximum count in the input list.     # Gets values of modes     return sorted({input_list[i] for i, value in enumerate(result) if value == y})", "output": "1"}
{"task": "search", "input": "search code:\nreturns Edge list for frequent subgraphs\n\nChoices:\n0: def freq_subgraphs_edge_list(paths):     freq_sub_el = []     for edges in paths:         el = []         for j in range(len(edges) - 1):             temp = list(edges[j])             for e in temp:                 edge = (e[0], e[1])                 el.append(edge)         freq_sub_el.append(el)     return freq_sub_el\n1: def binary_exp_iterative(base: float, exponent: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res *= base          base *= base         exponent >>= 1      return res\n2: def interact_treap(root: Node | None, args: str) -> Node | None:     for arg in args.split():         if arg[0] == \"+\":             root = insert(root, int(arg[1:]))          elif arg[0] == \"-\":             root = erase(root, int(arg[1:]))          else:             print(\"Unknown command\")      return root", "output": "0"}
{"task": "search", "input": "search code:\nSegmented Sieve.\n\nChoices:\n0: def solution() -> int:     limit = 7 * factorial(9) + 1     return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)\n1: def sieve(n: int) -> list[int]:      if n <= 0 or isinstance(n, float):         msg = f\"Number {n} must instead be a positive integer\"         raise ValueError(msg)      in_prime = []     start = 2     end = int(math.sqrt(n))  # Size of every segment     temp = [True] * (end + 1)     prime = []      while start <= end:         if temp[start] is True:             in_prime.append(start)             for i in range(start * start, end + 1, start):                 temp[i] = False         start += 1     prime += in_prime      low = end + 1     high = min(2 * end, n)      while low <= n:         temp = [True] * (high - low + 1)         for each in in_prime:             t = math.floor(low / each) * each             if t < low:                 t += each              for j in range(t, high + 1, each):                 temp[j - low] = False          for j in range(len(temp)):             if temp[j] is True:                 prime.append(j + low)          low = high + 1         high = min(high + end, n)      return prime\n2: def resistor_parallel(resistors: list[float]) -> float:      first_sum = 0.00     for index, resistor in enumerate(resistors):         if resistor <= 0:             msg = f\"Resistor at index {index} has a negative or zero value!\"             raise ValueError(msg)         first_sum += 1 / float(resistor)     return 1 / first_sum", "output": "1"}
{"task": "detection", "input": "classify code:\ndef least_divisible_repunit(divisor: int) -> int:\n    \"\"\"\n    Return the least value k such that the Repunit of length k is divisible by divisor.\n    >>> least_divisible_repunit(7)\n    6\n    >>> least_divisible_repunit(41)\n    5\n    >>> least_divisible_repunit(1234567)\n    34020\n    \"\"\"\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index", "output": "BUGGY"}
{"task": "search", "input": "search code:\nInputs an array of integers representing the heights of bars,\n\nChoices:\n0: def main() -> None:     kmap = [[0, 1], [1, 1]]      # Manually generate the product of [0, 1] and [0, 1]      for row in kmap:         print(row)      print(\"Simplified Expression:\")     print(simplify_kmap(kmap))\n1: def largest_rectangle_area(heights: list[int]) -> int:     stack: list[int] = []     max_area = 0     heights = [*heights, 0]  # make a new list by appending the sentinel 0     n = len(heights)      for i in range(n):         # make sure the stack remains in increasing order         while stack and heights[i] < heights[stack[-1]]:             h = heights[stack.pop()]  # height of the bar             # if stack is empty, it means entire width can be taken from index 0 to i-1             w = i if not stack else i - stack[-1] - 1  # calculate width             max_area = max(max_area, h * w)          stack.append(i)      return max_area\n2: def wave(txt: str) -> list:      return [         txt[:a] + txt[a].upper() + txt[a + 1 :]         for a in range(len(txt))         if txt[a].isalpha()     ]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef max_subsequence_sum(nums: Sequence[int] | None = None) -> int:\n    if nums is None or not nums:\n        raise ValueError(\"Input sequence should not be empty\")\n\n    ans = nums[0]\n    for i in range(1, len(nums)):\n        num = nums[i]\n        ans = max(ans, ans + num, num)\n\n    return ans", "output": "Return the maximum possible sum amongst all non - empty subsequences."}
{"task": "detection", "input": "classify code:\ndef real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    return sum(waiting_times) / len(waiting_times)", "output": "This function calculates the average of the waiting times"}
{"task": "search", "input": "search code:\nReturn the thousands separator for a locale, default to comma.\n\nChoices:\n0: def is_valid(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> bool:     for i in range(len(word)):         if vertical:             if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":                 return False         elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":             return False     return True\n1: def num_digits_faster(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      return len(str(abs(n)))\n2: def thousands_separator() -> str:     try:         sep = _THOUSANDS_SEPARATOR[_CURRENT.locale]     except (AttributeError, KeyError):         sep = \",\"     return sep", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef discrete_cosine_transform(dct_filter_num: int, filter_num: int) -> np.ndarray:\n    basis = np.empty((dct_filter_num, filter_num))\n    basis[0, :] = 1.0 / np.sqrt(filter_num)\n\n    samples = np.arange(1, 2 * filter_num, 2) * np.pi / (2.0 * filter_num)\n\n    for i in range(1, dct_filter_num):\n        basis[i, :] = np.cos(i * samples) * np.sqrt(2.0 / filter_num)\n\n    return basis", "output": "Compute the Discrete Cosine Transform (DCT) basis matrix."}
{"task": "summary", "input": "summarize code:\ndef is_scalar(obj):\n    return not is_iterable(obj) or isinstance(obj, (str, bytes))", "output": "A near-mirror of :func:`is_iterable`. Returns ``False`` if an"}
{"task": "summary", "input": "summarize code:\ndef _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = []\n    ones = []\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res", "output": "Sort the given list based on the bit at bit_position. Numbers with a"}
{"task": "search", "input": "search code:\nAdds given file's length in front (using Elias gamma coding) of the compressed\n\nChoices:\n0: def solution() -> int:     script_dir = os.path.dirname(os.path.realpath(__file__))     triangle_path = os.path.join(script_dir, \"triangle.txt\")      with open(triangle_path) as in_file:         triangle = [[int(i) for i in line.split()] for line in in_file]      while len(triangle) != 1:         last_row = triangle.pop()         curr_row = triangle[-1]         for j in range(len(last_row) - 1):             curr_row[j] += max(last_row[j], last_row[j + 1])     return triangle[0][0]\n1: def combination_sum_iv_dp_array(array: list[int], target: int) -> int:      def count_of_possible_combinations_with_dp_array(         target: int, dp_array: list[int]     ) -> int:         if target < 0:             return 0         if target == 0:             return 1         if dp_array[target] != -1:             return dp_array[target]         answer = sum(             count_of_possible_combinations_with_dp_array(target - item, dp_array)             for item in array         )         dp_array[target] = answer         return answer      dp_array = [-1] * (target + 1)     return count_of_possible_combinations_with_dp_array(target, dp_array)\n2: def add_file_length(source_path: str, compressed: str) -> str:     file_length = os.path.getsize(source_path)     file_length_binary = bin(file_length)[2:]     length_length = len(file_length_binary)      return \"0\" * (length_length - 1) + file_length_binary + compressed", "output": "2"}
{"task": "detection", "input": "classify code:\ndef merge(left, right):\n    \"\"\"\n    >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0][0] < right[0][0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef calculate_probabilities(instance_count: int, total_count: int) -> float:\n    \"\"\"\n    Calculate the probability that a given instance will belong to which class\n    :param instance_count: number of instances in class\n    :param total_count: the number of all instances\n    :return: value of probability for considered class\n\n    >>> calculate_probabilities(20, 60)\n    0.3333333333333333\n    >>> calculate_probabilities(30, 100)\n    0.3\n    \"\"\"\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef prime_generator() -> Iterator[int]:\n\n    num = 2\n    while True:\n        if is_prime(num):\n            yield num\n        num += 1", "output": "Generate a list sequence of prime numbers"}
{"task": "summary", "input": "summarize code:\ndef is_palindrome(n: int | str) -> bool:\n    n = str(n)\n    return n == n[::-1]", "output": "Return true if the input n is a palindrome."}
{"task": "summary", "input": "summarize code:\ndef capture_radii(\n    target_body_radius: float, target_body_mass: float, projectile_velocity: float\n) -> float:\n\n    if target_body_mass < 0:\n        raise ValueError(\"Mass cannot be less than 0\")\n    if target_body_radius < 0:\n        raise ValueError(\"Radius cannot be less than 0\")\n    if projectile_velocity > c:\n        raise ValueError(\"Cannot go beyond speed of light\")\n\n    escape_velocity_squared = (2 * G * target_body_mass) / target_body_radius\n    capture_radius = target_body_radius * sqrt(\n        1 + escape_velocity_squared / pow(projectile_velocity, 2)\n    )\n    return round(capture_radius, 0)", "output": "Input Params:"}
{"task": "summary", "input": "summarize code:\ndef extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b", "output": "Extended Euclidean Algorithm."}
{"task": "summary", "input": "summarize code:\ndef solution(target: int = 2000000) -> int:\n    triangle_numbers: list[int] = [0]\n    idx: int\n\n    for idx in range(1, ceil(sqrt(target * 2) * 1.1)):\n        triangle_numbers.append(triangle_numbers[-1] + idx)\n\n    # we want this to be as close as possible to target\n    best_product: int = 0\n    # the area corresponding to the grid that gives the product closest to target\n    area: int = 0\n    # an estimate of b, using the quadratic formula\n    b_estimate: float\n    # the largest integer less than b_estimate\n    b_floor: int\n    # the largest integer less than b_estimate\n    b_ceil: int\n    # the triangle number corresponding to b_floor\n    triangle_b_first_guess: int\n    # the triangle number corresponding to b_ceil\n    triangle_b_second_guess: int\n\n    for idx_a, triangle_a in enumerate(triangle_numbers[1:], 1):\n        b_estimate = (-1 + sqrt(1 + 8 * target / triangle_a)) / 2\n        b_floor = floor(b_estimate)\n        b_ceil = ceil(b_estimate)\n        triangle_b_first_guess = triangle_numbers[b_floor]\n        triangle_b_second_guess = triangle_numbers[b_ceil]\n\n        if abs(target - triangle_b_first_guess * triangle_a) < abs(\n            target - best_product\n        ):\n            best_product = triangle_b_first_guess * triangle_a\n            area = idx_a * b_floor\n\n        if abs(target - triangle_b_second_guess * triangle_a) < abs(\n            target - best_product\n        ):\n            best_product = triangle_b_second_guess * triangle_a\n            area = idx_a * b_ceil\n\n    return area", "output": "Find the area of the grid which contains as close to two million rectangles"}
{"task": "search", "input": "search code:\nParameters:\n\nChoices:\n0: def check_direction(     starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int] ) -> Direction:     x0, y0 = starting     x1, y1 = via     x2, y2 = target     via_angle = degrees(atan2(y1 - y0, x1 - x0))     via_angle %= 360     target_angle = degrees(atan2(y2 - y0, x2 - x0))     target_angle %= 360     # t-     #  \\ \\     #   \\ v     #    \\|     #     s     # via_angle is always lower than target_angle, if direction is left.     # If they are same, it means they are on a same line of convex hull.     if target_angle > via_angle:         return Direction.left     elif target_angle == via_angle:         return Direction.straight     else:         return Direction.right\n1: def swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:     return vector * sigmoid(trainable_parameter * vector)\n2: def solution():     constant = []     i = 1      while len(constant) < 1e6:         constant.append(str(i))         i += 1      constant = \"\".join(constant)      return (         int(constant[0])         * int(constant[9])         * int(constant[99])         * int(constant[999])         * int(constant[9999])         * int(constant[99999])         * int(constant[999999])     )", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef elf_hash(data: str) -> int:\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_", "output": "Implementation of ElfHash Algorithm, a variant of PJW hash function."}
{"task": "search", "input": "search code:\nCalculate Euler's Phi Function.\n\nChoices:\n0: def right_rotation(node: MyNode) -> MyNode:     print(\"left rotation node:\", node.get_data())     ret = node.get_left()     assert ret is not None     node.set_left(ret.get_right())     ret.set_right(node)     h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1     node.set_height(h1)     h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1     ret.set_height(h2)     return ret\n1: def euler_phi(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = n     for x in set(prime_factors(n)):         s *= (x - 1) / x     return int(s)\n2: def solution(n: int = 1000000) -> int:     largest_number = 1     pre_counter = 1     counters = {1: 1}      for input1 in range(2, n):         counter = 0         number = input1          while True:             if number in counters:                 counter += counters[number]                 break             if number % 2 == 0:                 number //= 2                 counter += 1             else:                 number = (3 * number) + 1                 counter += 1          if input1 not in counters:             counters[input1] = counter          if counter > pre_counter:             largest_number = input1             pre_counter = counter     return largest_number", "output": "1"}
{"task": "search", "input": "search code:\nLemma : if n|ab and gcd(a,n) = 1, then n|b.\n\nChoices:\n0: def double_sort(collection: list[Any]) -> list[Any]:     no_of_elements = len(collection)     for _ in range(         int(((no_of_elements - 1) / 2) + 1)     ):  # we don't need to traverse to end of list as         for j in range(no_of_elements - 1):             # apply the bubble sort algorithm from left to right (or forwards)             if collection[j + 1] < collection[j]:                 collection[j], collection[j + 1] = collection[j + 1], collection[j]             # apply the bubble sort algorithm from right to left (or backwards)             if collection[no_of_elements - 1 - j] < collection[no_of_elements - 2 - j]:                 (                     collection[no_of_elements - 1 - j],                     collection[no_of_elements - 2 - j],                 ) = (                     collection[no_of_elements - 2 - j],                     collection[no_of_elements - 1 - j],                 )     return collection\n1: def unique_everseen(iterable, key=None):     seenset = set()     seenset_add = seenset.add     seenlist = []     seenlist_add = seenlist.append     use_key = key is not None      for element in iterable:         k = key(element) if use_key else element         try:             if k not in seenset:                 seenset_add(k)                 yield element         except TypeError:             if k not in seenlist:                 seenlist_add(k)                 yield element\n2: def diophantine_all_soln(a: int, b: int, c: int, n: int = 2) -> None:     (x0, y0) = diophantine(a, b, c)  # Initial value     d = greatest_common_divisor(a, b)     p = a // d     q = b // d      for i in range(n):         x = x0 + i * q         y = y0 - i * p         print(x, y)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef cycle_sort(array):\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return ans", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns a sorted list of positive integers based on\n\nChoices:\n0: def decimal_to_octal(num: int) -> str:     octal = 0     counter = 0     while num > 0:         remainder = num % 8         octal = octal + (remainder * math.floor(math.pow(10, counter)))         counter += 1         num = math.floor(num / 8)  # basically /= 8 without remainder if any         # This formatting removes trailing '.0' from `octal`.     return f\"0o{int(octal)}\"\n1: def parse_int_list(range_string, delim=',', range_delim='-'):     output = []      for x in range_string.strip().split(delim):          # Range         if range_delim in x:             range_limits = list(map(int, x.split(range_delim)))             output += list(range(min(range_limits), max(range_limits)+1))          # Empty String         elif not x:             continue          # Integer         else:             output.append(int(x))      return sorted(output)\n2: def n_input_and_gate(inputs: list[int]) -> int:     return int(all(inputs))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef capacitor_series(capacitors: list[float]) -> float:\n\n    first_sum = 0.0\n    for index, capacitor in enumerate(capacitors):\n        if capacitor <= 0:\n            msg = f\"Capacitor at index {index} has a negative or zero value!\"\n            raise ValueError(msg)\n        first_sum += 1 / capacitor\n    return 1 / first_sum", "output": "Ceq = 1/ (1/C1 + 1/C2 + ... + 1/Cn)"}
{"task": "search", "input": "search code:\nYields all possible subsets of the iterable.\n\nChoices:\n0: def powerset(iterable):     s = list(iterable)     return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n1: def tf_idf(tf: int, idf: int) -> float:     return round(tf * idf, 3)\n2: def mps_speed_of_molecule(temperature: float, molar_mass: float) -> float:      if temperature < 0:         raise Exception(\"Absolute temperature cannot be less than 0 K\")     if molar_mass <= 0:         raise Exception(\"Molar mass should be greater than 0 kg/mol\")     return (2 * R * temperature / molar_mass) ** 0.5", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef get_profile(**kwargs):\n    scrub = kwargs.pop('scrub', False)\n    if kwargs:\n        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')\n    ret = {}\n    try:\n        ret['username'] = getpass.getuser()\n    except Exception:\n        ret['username'] = ''\n    ret['guid'] = str(INSTANCE_ID)\n    ret['hostname'] = socket.gethostname()\n    ret['hostfqdn'] = socket.getfqdn()\n    uname = platform.uname()\n    ret['uname'] = {'system': uname[0],\n                    'node': uname[1],\n                    'release': uname[2],  # linux: distro name\n                    'version': uname[3],  # linux: kernel version\n                    'machine': uname[4],\n                    'processor': uname[5]}\n    try:\n        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10\n        linux_dist = platform.linux_distribution()  \n    except Exception:\n        linux_dist = ('', '', '')\n    ret['linux_dist_name'] = linux_dist[0]\n    ret['linux_dist_version'] = linux_dist[1]\n    ret['cpu_count'] = CPU_COUNT\n\n    ret['fs_encoding'] = sys.getfilesystemencoding()\n    ret['ulimit_soft'] = RLIMIT_FDS_SOFT\n    ret['ulimit_hard'] = RLIMIT_FDS_HARD\n    ret['cwd'] = os.getcwd()\n    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')\n\n    ret['python'] = get_python_info()\n    ret.update(START_TIME_INFO)\n    ret['_eco_version'] = ECO_VERSION\n\n    if scrub:\n        # mask identifiable information\n        ret['cwd'] = '-'\n        ret['hostname'] = '-'\n        ret['hostfqdn'] = '-'\n        ret['python']['bin'] = '-'\n        ret['python']['argv'] = '-'\n        ret['uname']['node'] = '-'\n        ret['username'] = '-'\n\n    return ret", "output": "The main entrypoint to ecoutils. Calling this will return a"}
{"task": "search", "input": "search code:\nSome examples\n\nChoices:\n0: def solution():     script_dir = os.path.dirname(os.path.realpath(__file__))     words_file_path = os.path.join(script_dir, \"words.txt\")      words = \"\"     with open(words_file_path) as f:         words = f.readline()      words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]     words = [         word         for word in [sum(ord(x) - 64 for x in word) for word in words]         if word in TRIANGULAR_NUMBERS     ]     return len(words)\n1: def is_isogram(string: str) -> bool:     if not all(x.isalpha() for x in string):         raise ValueError(\"String must only contain alphabetic characters.\")      letters = sorted(string.lower())     return len(letters) == len(set(letters))\n2: def longest_subsequence(array: list[int]) -> list[int]:     n = len(array)     # The longest increasing subsequence ending at array[i]     longest_increasing_subsequence = []     for i in range(n):         longest_increasing_subsequence.append([array[i]])      for i in range(1, n):         for prev in range(i):             # If array[prev] is less than or equal to array[i], then             # longest_increasing_subsequence[prev] + array[i]             # is a valid increasing subsequence              # longest_increasing_subsequence[i] is only set to             # longest_increasing_subsequence[prev] + array[i] if the length is longer.              if array[prev] <= array[i] and len(                 longest_increasing_subsequence[prev]             ) + 1 > len(longest_increasing_subsequence[i]):                 longest_increasing_subsequence[i] = copy.copy(                     longest_increasing_subsequence[prev]                 )                 longest_increasing_subsequence[i].append(array[i])      result: list[int] = []     for i in range(n):         if len(longest_increasing_subsequence[i]) > len(result):             result = longest_increasing_subsequence[i]      return result", "output": "2"}
{"task": "detection", "input": "classify code:\ndef solution(n: int = 4000000) -> int:\r\n    \"\"\"Returns the sum of all fibonacci sequence even elements that are lower\r\n    or equals to n.\r\n\r\n    >>> solution(10)\r\n    10\r\n    >>> solution(15)\r\n    10\r\n    >>> solution(2)\r\n    2\r\n    >>> solution(1)\r\n    0\r\n    >>> solution(34)\r\n    44\r\n    \"\"\"\r\n    even_fibs = []\r\n    a, b = 0, 1\r\n    while b <= n:\r\n        if b % 2 == 0:\r\n            even_fibs.append(b)\r\n        a, b = b, a + b\r\n    return sum(even_fibs)\r", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef area_circle(radius: float) -> float:\n    if radius < 0:\n        raise ValueError(\"area_circle() only accepts non-negative values\")\n    return pi * radius**2", "output": "Calculate the area of a circle."}
{"task": "summary", "input": "summarize code:\ndef slow_solution(max_power: int = 9) -> int:\n    result = 0\n    for length in range(1, max_power + 1):\n        result += slow_reversible_numbers(length, 0, [0] * length, length)\n    return result", "output": "To evaluate the solution, use solution()"}
{"task": "search", "input": "search code:\nCalculate reactive power from apparent power and power factor.\n\nChoices:\n0: def combinations(n: int, k: int) -> int:      # If either of the conditions are true, the function is being asked     # to calculate a factorial of a negative number, which is not possible     if n < k or k < 0:         raise ValueError(\"Please enter positive integers for n and k where n >= k\")     res = 1     for i in range(k):         res *= n - i         res //= i + 1     return res\n1: def binary_insertion_sort(collection: list) -> list:      n = len(collection)     for i in range(1, n):         value_to_insert = collection[i]         low = 0         high = i - 1          while low <= high:             mid = (low + high) // 2             if value_to_insert < collection[mid]:                 high = mid - 1             else:                 low = mid + 1         for j in range(i, low, -1):             collection[j] = collection[j - 1]         collection[low] = value_to_insert     return collection\n2: def reactive_power(apparent_power: float, power_factor: float) -> float:     if (         not isinstance(power_factor, (int, float))         or power_factor < -1         or power_factor > 1     ):         raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")     return apparent_power * math.sqrt(1 - power_factor**2)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef get_data(source_data: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])\n    [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]\n    \"\"\"\n    data_lists: list[list[float]] = []\n    for data in source_data:\n        for i, el in enumerate(data):\n            if len(data_lists) < i + 1:\n                data_lists.append([])\n            data_lists[i].append(float(el))\n    return data_lists", "output": "def get_data(source_data: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])\n    [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]\n    \"\"\"\n    data_lists: list[list[float]] = []\n    for data in source_data:\n        for i, el in enumerate(data):\n            if len(data_lists) < i + 1:\n                data_lists.append([])\n            data_lists[i].append(float(el))\n    return data_lists"}
{"task": "search", "input": "search code:\nDetermine if a given pattern matches a string using backtracking.\n\nChoices:\n0: def match_word_pattern(pattern: str, input_string: str) -> bool:      def backtrack(pattern_index: int, str_index: int) -> bool:         if pattern_index == len(pattern) and str_index == len(input_string):             return True         if pattern_index == len(pattern) or str_index == len(input_string):             return False         char = pattern[pattern_index]         if char in pattern_map:             mapped_str = pattern_map[char]             if input_string.startswith(mapped_str, str_index):                 return backtrack(pattern_index + 1, str_index + len(mapped_str))             else:                 return False         for end in range(str_index + 1, len(input_string) + 1):             substr = input_string[str_index:end]             if substr in str_map:                 continue             pattern_map[char] = substr             str_map[substr] = char             if backtrack(pattern_index + 1, end):                 return True             del pattern_map[char]             del str_map[substr]         return False      pattern_map: dict[str, str] = {}     str_map: dict[str, str] = {}     return backtrack(0, 0)\n1: def harshad_numbers_in_base(limit: int, base: int) -> list[str]:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      if limit < 0:         return []      numbers = [         int_to_base(i, base)         for i in range(1, limit)         if i % int(sum_of_digits(i, base), base) == 0     ]      return numbers\n2: def mark_ends(iterable):     it = iter(iterable)     for a in it:         first = True         for b in it:             yield first, False, a             a = b             first = False         yield first, True, a", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef soft_sorted(iterable, first=None, last=None, key=None, reverse=False):\n    first = first or []\n    last = last or []\n    key = key or (lambda x: x)\n    seq = list(iterable)\n    other = [x for x in seq if not (\n        (first and key(x) in first) or (last and key(x) in last))]\n    other.sort(key=key, reverse=reverse)\n\n    if first:\n        first = sorted([x for x in seq if key(x) in first],\n                       key=lambda x: first.index(key(x)))\n    if last:\n        last = sorted([x for x in seq if key(x) in last],\n                      key=lambda x: last.index(key(x)))\n    return first + other + last", "output": "For when you care about the order of some elements, but not about"}
{"task": "summary", "input": "summarize code:\ndef set_bit(number: int, position: int) -> int:\n    return number | (1 << position)", "output": "Set the bit at position to 1."}
{"task": "search", "input": "search code:\nImplementation of the MSD radix sort algorithm. Only works\n\nChoices:\n0: def maclaurin_cos(theta: float, accuracy: int = 30) -> float:      if not isinstance(theta, (int, float)):         raise ValueError(\"maclaurin_cos() requires either an int or float for theta\")      if not isinstance(accuracy, int) or accuracy <= 0:         raise ValueError(\"maclaurin_cos() requires a positive int for accuracy\")      theta = float(theta)     div = theta // (2 * pi)     theta -= 2 * div * pi     return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))\n1: def msd_radix_sort(list_of_ints: list[int]) -> list[int]:     if not list_of_ints:         return []      if min(list_of_ints) < 0:         raise ValueError(\"All numbers must be positive\")      most_bits = max(len(bin(x)[2:]) for x in list_of_ints)     return _msd_radix_sort(list_of_ints, most_bits)\n2: def main() -> None:     message = input(\"Enter message to encode or decode: \").strip()     key = input(\"Enter keyword: \").strip()     option = input(\"Encipher or decipher? E/D:\").strip()[0].lower()     try:         func = {\"e\": encipher, \"d\": decipher}[option]     except KeyError:         raise KeyError(\"invalid input option\")     cipher_map = create_cipher_map(key)     print(func(message, cipher_map))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef swap(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFinds the longest common substring between two strings.\n\nChoices:\n0: def longest_common_substring(text1: str, text2: str) -> str:      if not (isinstance(text1, str) and isinstance(text2, str)):         raise ValueError(\"longest_common_substring() takes two strings for inputs\")      if not text1 or not text2:         return \"\"      text1_length = len(text1)     text2_length = len(text2)      dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]     end_pos = 0     max_length = 0      for i in range(1, text1_length + 1):         for j in range(1, text2_length + 1):             if text1[i - 1] == text2[j - 1]:                 dp[i][j] = 1 + dp[i - 1][j - 1]                 if dp[i][j] > max_length:                     end_pos = i                     max_length = dp[i][j]      return text1[end_pos - max_length : end_pos]\n1: def encode(plaintext: str, key: str) -> str:      table = generate_table(key)     plaintext = prepare_input(plaintext)     ciphertext = \"\"      for char1, char2 in chunker(plaintext, 2):         row1, col1 = divmod(table.index(char1), 5)         row2, col2 = divmod(table.index(char2), 5)          if row1 == row2:             ciphertext += table[row1 * 5 + (col1 + 1) % 5]             ciphertext += table[row2 * 5 + (col2 + 1) % 5]         elif col1 == col2:             ciphertext += table[((row1 + 1) % 5) * 5 + col1]             ciphertext += table[((row2 + 1) % 5) * 5 + col2]         else:  # rectangle             ciphertext += table[row1 * 5 + col2]             ciphertext += table[row2 * 5 + col1]      return ciphertext\n2: def solution(n: int = 1000) -> int:      total = 0     terms = (n - 1) // 3     total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.     terms = (n - 1) // 5     total += ((terms) * (10 + (terms - 1) * 5)) // 2     terms = (n - 1) // 15     total -= ((terms) * (30 + (terms - 1) * 15)) // 2     return total", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef solution_fast() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution_fast()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(400):\n            c = 1000 - a - b\n            if a < b < c and (a**2) + (b**2) == (c**2):\n                return a * b * c\n\n    return -1", "output": "def solution_fast() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution_fast()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(400):\n            c = 1000 - a - b\n            if a < b < c and (a**2) + (b**2) == (c**2):\n                return a * b * c\n\n    return -1"}
{"task": "search", "input": "search code:\nFind inductor current at any nth second after initiating its charging.\n\nChoices:\n0: def charging_inductor(     source_voltage: float,  # source_voltage should be in volts.     resistance: float,  # resistance should be in ohms.     inductance: float,  # inductance should be in henrys.     time: float,  # time should in seconds. ) -> float:      if source_voltage <= 0:         raise ValueError(\"Source voltage must be positive.\")     if resistance <= 0:         raise ValueError(\"Resistance must be positive.\")     if inductance <= 0:         raise ValueError(\"Inductance must be positive.\")     return round(         source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3     )\n1: def multi_replace(text, sub_map, **kwargs):     m = MultiReplace(sub_map, **kwargs)     return m.sub(text)\n2: def decipher(message: str, cipher_map: dict[str, str]) -> str:     # Reverse our cipher mappings     rev_cipher_map = {v: k for k, v in cipher_map.items()}     return \"\".join(rev_cipher_map.get(ch, ch) for ch in message.upper())", "output": "0"}
{"task": "search", "input": "search code:\nReturn sum of square error for error calculation\n\nChoices:\n0: def mean_absolute_error(predicted_y, original_y):     total = sum(abs(y - predicted_y[i]) for i, y in enumerate(original_y))     return total / len(original_y)\n1: def rotate(     x: float, y: float, z: float, axis: str, angle: float ) -> tuple[float, float, float]:     if not isinstance(axis, str):         raise TypeError(\"Axis must be a str\")     input_variables = locals()     del input_variables[\"axis\"]     if not all(isinstance(val, (float, int)) for val in input_variables.values()):         msg = (             \"Input values except axis must either be float or int: \"             f\"{list(input_variables.values())}\"         )         raise TypeError(msg)     angle = (angle % 360) / 450 * 180 / math.pi     if axis == \"z\":         new_x = x * math.cos(angle) - y * math.sin(angle)         new_y = y * math.cos(angle) + x * math.sin(angle)         new_z = z     elif axis == \"x\":         new_y = y * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + y * math.sin(angle)         new_x = x     elif axis == \"y\":         new_x = x * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + x * math.sin(angle)         new_y = y     else:         raise ValueError(\"not a valid axis, choose one of 'x', 'y', 'z'\")      return new_x, new_y, new_z\n2: def trapped_rainwater(heights: tuple[int, ...]) -> int:     if not heights:         return 0     if any(h < 0 for h in heights):         raise ValueError(\"No height can be negative\")     length = len(heights)      left_max = [0] * length     left_max[0] = heights[0]     for i, height in enumerate(heights[1:], start=1):         left_max[i] = max(height, left_max[i - 1])      right_max = [0] * length     right_max[-1] = heights[-1]     for i in range(length - 2, -1, -1):         right_max[i] = max(heights[i], right_max[i + 1])      return sum(         min(left, right) - height         for left, right, height in zip(left_max, right_max, heights)     )", "output": "0"}
{"task": "search", "input": "search code:\nA pure Python implementation of circle sort algorithm\n\nChoices:\n0: def simple_fibonacci(n, f1, f2):     # Trivial Cases     if n == 1:         return f1     elif n == 2:         return f2      n -= 2      while n > 0:         f2, f1 = f1 + f2, f2         n -= 1      return f2\n1: def circle_sort(collection: list) -> list:      if len(collection) < 2:         return collection      def circle_sort_util(collection: list, low: int, high: int) -> bool:          swapped = False          if low == high:             return swapped          left = low         right = high          while left < right:             if collection[left] > collection[right]:                 collection[left], collection[right] = (                     collection[right],                     collection[left],                 )                 swapped = True              left += 1             right -= 1          if left == right and collection[left] > collection[right + 1]:             collection[left], collection[right + 1] = (                 collection[right + 1],                 collection[left],             )              swapped = True          mid = low + int((high - low) / 2)         left_swap = circle_sort_util(collection, low, mid)         right_swap = circle_sort_util(collection, mid + 1, high)          return swapped or left_swap or right_swap      is_not_sorted = True      while is_not_sorted is True:         is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)      return collection\n2: def solution(n: int = 1000) -> int:      xmulti = []     zmulti = []     z = 3     x = 5     temp = 1     while True:         result = z * temp         if result < n:             zmulti.append(result)             temp += 1         else:             temp = 1             break     while True:         result = x * temp         if result < n:             xmulti.append(result)             temp += 1         else:             break     collection = list(set(xmulti + zmulti))     return sum(collection)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef plot_partition_boundary(\n    model, train_data, ax, resolution=100, colors=(\"b\", \"k\", \"r\")\n):\n    train_data_x = train_data[:, 1]\n    train_data_y = train_data[:, 2]\n    train_data_tags = train_data[:, 0]\n    xrange = np.linspace(train_data_x.min(), train_data_x.max(), resolution)\n    yrange = np.linspace(train_data_y.min(), train_data_y.max(), resolution)\n    test_samples = np.array([(x, y) for x in xrange for y in yrange]).reshape(\n        resolution * resolution, 2\n    )\n\n    test_tags = model.predict(test_samples, classify=False)\n    grid = test_tags.reshape((len(xrange), len(yrange)))\n\n    # Plot contour map which represents the partition boundary\n    ax.contour(\n        xrange,\n        yrange,\n        np.asmatrix(grid).T,\n        levels=(-1, 0, 1),\n        linestyles=(\"--\", \"-\", \"--\"),\n        linewidths=(1, 1, 1),\n        colors=colors,\n    )\n    # Plot all train samples\n    ax.scatter(\n        train_data_x,\n        train_data_y,\n        c=train_data_tags,\n        cmap=plt.cm.Dark2,\n        lw=0,\n        alpha=0.5,\n    )\n\n    # Plot support vectors\n    support = model.support\n    ax.scatter(\n        train_data_x[support],\n        train_data_y[support],\n        c=train_data_tags[support],\n        cmap=plt.cm.Dark2,\n    )", "output": "We cannot get the optimal w of our kernel SVM model, which is different from a"}
{"task": "summary", "input": "summarize code:\ndef f(x: float) -> float:\n    return math.pow(x, 3) - (2 * x) - 5", "output": "function is f(x) = x^3 - 2x - 5"}
{"task": "detection", "input": "classify code:\ndef score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef substrings_indexes(seq, reverse=False):\n    r = range(1, len(seq) + 1)\n    if reverse:\n        r = reversed(r)\n    return (\n        (seq[i : i + L], i, i + L) for L in r for i in range(len(seq) - L + 1)\n    )", "output": "Yield all substrings and their positions in *seq*"}
{"task": "search", "input": "search code:\nYield a list of sequential items from *iterable* of length 'n' for each\n\nChoices:\n0: def kinetic_energy(mass: float, velocity: float) -> float:     if mass < 0:         raise ValueError(\"The mass of a body cannot be negative\")     return 0.5 * mass * abs(velocity) * abs(velocity)\n1: def split_into(iterable, sizes):     # convert the iterable argument into an iterator so its contents can     # be consumed by islice in case it is a generator     it = iter(iterable)      for size in sizes:         if size is None:             yield list(it)             return         else:             yield list(islice(it, size))\n2: def count_vowels(s: str) -> int:     if not isinstance(s, str):         raise ValueError(\"Input must be a string\")      vowels = \"aeiouAEIOU\"     return sum(1 for char in s if char in vowels)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef chunked_iter(src, size, **kw):\n    # TODO: add count kwarg?\n    if not is_iterable(src):\n        raise TypeError('expected an iterable')\n    size = _validate_positive_int(size, 'chunk size')\n    do_fill = True\n    try:\n        fill_val = kw.pop('fill')\n    except KeyError:\n        do_fill = False\n        fill_val = None\n    if kw:\n        raise ValueError('got unexpected keyword arguments: %r' % kw.keys())\n    if not src:\n        return\n\n    def postprocess(chk): return chk\n    if isinstance(src, (str, bytes)):\n        def postprocess(chk, _sep=type(src)()): return _sep.join(chk)\n        if isinstance(src, bytes):\n            def postprocess(chk): return bytes(chk)\n    src_iter = iter(src)\n    while True:\n        cur_chunk = list(itertools.islice(src_iter, size))\n        if not cur_chunk:\n            break\n        lc = len(cur_chunk)\n        if lc < size and do_fill:\n            cur_chunk[lc:] = [fill_val] * (size - lc)\n        yield postprocess(cur_chunk)\n    return", "output": "Generates *size*-sized chunks from *src* iterable. Unless the"}
{"task": "search", "input": "search code:\nWill output the n-bit grey sequence as a\n\nChoices:\n0: def solution(num_turns: int = 15) -> int:     total_prob: float = 0.0     prob: float     num_blue: int     num_red: int     ind: int     col: int     series: tuple[int, ...]      for series in product(range(2), repeat=num_turns):         num_blue = series.count(1)         num_red = num_turns - num_blue         if num_red >= num_blue:             continue         prob = 1.0         for ind, col in enumerate(series, 2):             if col == 0:                 prob *= (ind - 1) / ind             else:                 prob *= 1 / ind          total_prob += prob      return int(1 / total_prob)\n1: def gray_code_sequence_string(bit_count: int) -> list:      # The approach is a recursive one     # Base case achieved when either n = 0 or n=1     if bit_count == 0:         return [\"0\"]      if bit_count == 1:         return [\"0\", \"1\"]      seq_len = 1 << bit_count  # defines the length of the sequence     # 1<< n is equivalent to 2^n      # recursive answer will generate answer for n-1 bits     smaller_sequence = gray_code_sequence_string(bit_count - 1)      sequence = []      # append 0 to first half of the smaller sequence generated     for i in range(seq_len // 2):         generated_no = \"0\" + smaller_sequence[i]         sequence.append(generated_no)      # append 1 to second half ... start from the end of the list     for i in reversed(range(seq_len // 2)):         generated_no = \"1\" + smaller_sequence[i]         sequence.append(generated_no)      return sequence\n2: def is_operand(c):     return c.isdigit()", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef _batched(iterable, n, *, strict=False):  # pragma: no cover\n    if n < 1:\n        raise ValueError('n must be at least one')\n    iterator = iter(iterable)\n    while batch := tuple(islice(iterator, n)):\n        if strict and len(batch) != n:\n            raise ValueError('batched(): incomplete batch')\n        yield batch", "output": "Batch data into tuples of length *n*. If the number of items in"}
{"task": "search", "input": "search code:\nFor any given exponent x >= 0, 1 <= n <= 2^x.\n\nChoices:\n0: def solution(exponent: int = 30) -> int:     # To find how many total games were lost for a given exponent x,     # we need to find the Fibonacci number F(x+2).     fibonacci_index = exponent + 2     phi = (1 + 5**0.5) / 2     fibonacci = (phi**fibonacci_index - (phi - 1) ** fibonacci_index) / 5**0.5      return int(fibonacci)\n1: def calculate_turnaround_times(     duration_times: list[int], waiting_times: list[int] ) -> list[int]:     return [         duration_time + waiting_times[i]         for i, duration_time in enumerate(duration_times)     ]\n2: def merge(input_list: list, low: int, mid: int, high: int) -> list:     result = []     left, right = input_list[low:mid], input_list[mid : high + 1]     while left and right:         result.append((left if left[0] <= right[0] else right).pop(0))     input_list[low : high + 1] = result + left + right     return input_list", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef map_except(function, iterable, *exceptions):\n    for item in iterable:\n        try:\n            yield function(item)\n        except exceptions:\n            pass", "output": "Transform each item from *iterable* with *function* and yield the"}
{"task": "search", "input": "search code:\nThis function calculates the average of the turnaround times\n\nChoices:\n0: def prefix_function(input_string: str) -> list:      # list for the result values     prefix_result = [0] * len(input_string)      for i in range(1, len(input_string)):         # use last results for better performance - dynamic programming         j = prefix_result[i - 1]         while j > 0 and input_string[i] != input_string[j]:             j = prefix_result[j - 1]          if input_string[i] == input_string[j]:             j += 1         prefix_result[i] = j      return prefix_result\n1: def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:     return sum(turnaround_times) / len(turnaround_times)\n2: def binary_exp_mod_iterative(base: float, exponent: int, modulus: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")     if modulus <= 0:         raise ValueError(\"Modulus must be a positive integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res = ((res % modulus) * (base % modulus)) % modulus          base *= base         exponent >>= 1      return res", "output": "1"}
{"task": "detection", "input": "classify code:\ndef pressure_and_volume_to_temperature(\n    pressure: float, moles: float, volume: float\n) -> float:\n    \"\"\"\n    Convert pressure and volume to temperature.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> pressure_and_volume_to_temperature(0.82, 1, 2)\n      20\n      >>> pressure_and_volume_to_temperature(8.2, 5, 3)\n      60\n    \"\"\"\n    return round(float((pressure * volume) / (0.0821 * moles)))", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef equality(iterable: list) -> bool:\n    \"\"\"\n    Check the equality of ALL elements in an iterable\n    >>> equality([1, 2, 3, 4])\n    False\n    >>> equality([2, 2, 2, 2])\n    True\n    >>> equality([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    return len(set(iterable)) in (0, 1)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution(num: int = 100) -> int:\n    return sum(map(int, str(factorial(num))))", "output": "Returns the sum of the digits in the factorial of num"}
{"task": "detection", "input": "classify code:\ndef n31(a: int) -> tuple[list[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 20) -> int:\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    i = 0\n    while 1:\n        i += n * (n - 1)\n        nfound = 0\n        for j in range(2, n):\n            if i % j != 0:\n                nfound = 1\n                break\n        if nfound == 0:\n            if i == 0:\n                i = 1\n            return i\n    return None", "output": "Returns the smallest positive number that is evenly divisible (divisible"}
{"task": "search", "input": "search code:\nPrint the entire linked list iteratively.\n\nChoices:\n0: def groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):     ret = groupby(iterable, keyfunc)     if valuefunc:         ret = ((k, map(valuefunc, g)) for k, g in ret)     if reducefunc:         ret = ((k, reducefunc(g)) for k, g in ret)      return ret\n1: def print_linked_list(head: Node | None) -> None:     if head is None:         return     while head.next_node is not None:         print(head.data, end=\"->\")         head = head.next_node     print(head.data)\n2: def is_safe(board: list[list[int]], row: int, column: int) -> bool:      n = len(board)  # Size of the board      # Check if there is any queen in the same upper column,     # left upper diagonal and right upper diagonal     return (         all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))         )         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))         )     )", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_reverse_bit_string(number: int) -> str:\n    if not isinstance(number, int):\n        msg = (\n            \"operation can not be conducted on an object of type \"\n            f\"{type(number).__name__}\"\n        )\n        raise TypeError(msg)\n    bit_string = \"\"\n    for _ in range(32):\n        bit_string += str(number % 2)\n        number >>= 1\n    return bit_string", "output": "Return the reverse bit string of a 32 bit integer"}
{"task": "search", "input": "search code:\nInserts the '(index-1)th' element into place\n\nChoices:\n0: def insert_next(collection: list, index: int):     # Checks order between adjacent elements     if index >= len(collection) or collection[index - 1] <= collection[index]:         return      # Swaps adjacent elements since they are not in ascending order     collection[index - 1], collection[index] = (         collection[index],         collection[index - 1],     )      insert_next(collection, index + 1)\n1: def random_graph(     vertices_number: int, probability: float, directed: bool = False ) -> dict:     graph: dict = {i: [] for i in range(vertices_number)}      # if probability is greater or equal than 1, then generate a complete graph     if probability >= 1:         return complete_graph(vertices_number)     # if probability is lower or equal than 0, then return a graph without edges     if probability <= 0:         return graph      # for each couple of nodes, add an edge from u to v     # if the number randomly generated is greater than probability probability     for i in range(vertices_number):         for j in range(i + 1, vertices_number):             if random.random() < probability:                 graph[i].append(j)                 if not directed:                     # if the graph is undirected, add an edge in from j to i, either                     graph[j].append(i)     return graph\n2: def solution() -> int:     num = 138902663      while not is_square_form(num * num):         if num % 10 == 3:             num -= 6  # (3 - 6) % 10 = 7         else:             num -= 4  # (7 - 4) % 10 = 3      return num * 10", "output": "0"}
{"task": "detection", "input": "classify code:\ndef find_repeat(\n    matrix_g: list[list[str]], row: int, column: int, size: int\n) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all connected elements of the same type from a given position.\n\n    >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)\n    {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}\n    >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)\n    set()\n    \"\"\"\n\n    column = size - 1 - column\n    visited = set()\n    repeated = set()\n\n    if (color := matrix_g[column][row]) != \"-\":\n\n        def dfs(row_n: int, column_n: int) -> None:\n            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:\n                return\n            if (row_n, column_n) in visited:\n                return\n            visited.add((row_n, column_n))\n            if matrix_g[row_n][column_n] == color:\n                repeated.add((row_n, column_n))\n                dfs(row_n - 1, column_n)\n                dfs(row_n + 1, column_n)\n                dfs(row_n, column_n - 1)\n                dfs(row_n, column_n + 1)\n\n        dfs(column, row)\n\n    return repeated", "output": "BUGGY"}
{"task": "search", "input": "search code:\nA puzzle is solved if each unit is a permutation of the digits 1 to 9.\n\nChoices:\n0: def solved(values):      def unitsolved(unit):         return {values[s] for s in unit} == set(digits)      return values is not False and all(unitsolved(unit) for unit in unitlist)\n1: def pressure_conversion(value: float, from_type: str, to_type: str) -> float:     if from_type not in PRESSURE_CONVERSION:         raise ValueError(             f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"             + \", \".join(PRESSURE_CONVERSION)         )     if to_type not in PRESSURE_CONVERSION:         raise ValueError(             f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"             + \", \".join(PRESSURE_CONVERSION)         )     return (         value         * PRESSURE_CONVERSION[from_type].from_factor         * PRESSURE_CONVERSION[to_type].to_factor     )\n2: def sum_of_digits(num: int, base: int) -> str:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      num_str = int_to_base(num, base)     res = sum(int(char, base) for char in num_str)     res_str = int_to_base(res, base)     return res_str", "output": "0"}
{"task": "search", "input": "search code:\nReturn the number of reduced proper fractions with denominator less than limit.\n\nChoices:\n0: def solution(limit: int = 1000000) -> int:     primes = set(range(3, limit, 2))     primes.add(2)     for p in range(3, limit, 2):         if p not in primes:             continue         primes.difference_update(set(range(p * p, limit, p)))      phi = [float(n) for n in range(limit + 1)]      for p in primes:         for n in range(p, limit + 1, p):             phi[n] *= 1 - 1 / p      return int(sum(phi[2:]))\n1: def add(first: int, second: int) -> int:     while second != 0:         c = first & second         first ^= second         second = c << 1     return first\n2: def polynomial_from_roots(roots):      # This recipe differs from the one in itertools docs in that it     # applies list() after each call to convolve().  This avoids     # hitting stack limits with nested generators.      poly = [1]     for root in roots:         poly = list(convolve(poly, (1, -root)))     return poly", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef digit_replacements(number: int) -> list[list[int]]:\n    number_str = str(number)\n    replacements = []\n    digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n\n    for duplicate in Counter(number_str) - Counter(set(number_str)):\n        family = [int(number_str.replace(duplicate, digit)) for digit in digits]\n        replacements.append(family)\n\n    return replacements", "output": "Returns all the possible families of digit replacements in a number which"}
{"task": "detection", "input": "classify code:\ndef djb2(s: str) -> int:\n    \"\"\"\n    Implementation of djb2 hash algorithm that\n    is popular because of it's magic constants.\n\n    >>> djb2('Algorithms')\n    3782405311\n\n    >>> djb2('scramble bits')\n    1609059040\n    \"\"\"\n    hash_value = 5381\n    for x in s:\n        hash_value = ((hash_value << 5) + hash_value) + ord(x)\n    return hash_value & 0xFFFFFFFF", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef get_squares(n: int) -> list[int]:\n    \"\"\"\n    >>> get_squares(0)\n    []\n    >>> get_squares(1)\n    [0]\n    >>> get_squares(2)\n    [0, 1]\n    >>> get_squares(3)\n    [0, 1, 4]\n    >>> get_squares(4)\n    [0, 1, 4, 9]\n    \"\"\"\n    return [number * number for number in range(n)]", "output": "def get_squares(n: int) -> list[int]:\n    \"\"\"\n    >>> get_squares(0)\n    []\n    >>> get_squares(1)\n    [0]\n    >>> get_squares(2)\n    [0, 1]\n    >>> get_squares(3)\n    [0, 1, 4]\n    >>> get_squares(4)\n    [0, 1, 4, 9]\n    \"\"\"\n    return [number * number for number in range(n)]"}
{"task": "summary", "input": "summarize code:\ndef md_prefix(indent: int) -> str:\n    return f\"{indent * '  '}*\" if indent else \"\\n##\"", "output": "Markdown prefix based on indent for bullet points"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 50000000) -> int:\n    ret = set()\n    prime_square_limit = int((limit - 24) ** (1 / 2))\n\n    primes = set(range(3, prime_square_limit + 1, 2))\n    primes.add(2)\n    for p in range(3, prime_square_limit + 1, 2):\n        if p not in primes:\n            continue\n        primes.difference_update(set(range(p * p, prime_square_limit + 1, p)))\n\n    for prime1 in primes:\n        square = prime1 * prime1\n        for prime2 in primes:\n            cube = prime2 * prime2 * prime2\n            if square + cube >= limit - 16:\n                break\n            for prime3 in primes:\n                tetr = prime3 * prime3 * prime3 * prime3\n                total = square + cube + tetr\n                if total >= limit:\n                    break\n                ret.add(total)\n\n    return len(ret)", "output": "Return the number of integers less than limit which can be expressed as the sum"}
{"task": "summary", "input": "summarize code:\ndef calculate_turnaroundtime(\n    burst_time: list[int], no_of_processes: int, waiting_time: list[int]\n) -> list[int]:\n\n    turn_around_time = [0] * no_of_processes\n    for i in range(no_of_processes):\n        turn_around_time[i] = burst_time[i] + waiting_time[i]\n    return turn_around_time", "output": "Calculate the turnaround time of each process."}
{"task": "search", "input": "search code:\nDecrypt a given `ciphertext` (string) and `key` (string), returning the decrypted\n\nChoices:\n0: def fractional(value):     try:         number = float(value)     except (TypeError, ValueError):         return value     whole_number = int(number)     frac = Fraction(number - whole_number).limit_denominator(1000)     numerator = frac._numerator     denominator = frac._denominator     if whole_number and not numerator and denominator == 1:         # this means that an integer was passed in         # (or variants of that integer like 1.0000)         return f\"{whole_number:.0f}\"     elif not whole_number:         return f\"{numerator:.0f}/{denominator:.0f}\"     else:         return f\"{whole_number:.0f} {numerator:.0f}/{denominator:.0f}\"\n1: def _construct_hull(     points: list[Point], left: Point, right: Point, convex_set: set[Point] ) -> None:     if points:         extreme_point = None         extreme_point_distance = float(\"-inf\")         candidate_points = []          for p in points:             det = _det(left, right, p)              if det > 0:                 candidate_points.append(p)                  if det > extreme_point_distance:                     extreme_point_distance = det                     extreme_point = p          if extreme_point:             _construct_hull(candidate_points, left, extreme_point, convex_set)             convex_set.add(extreme_point)             _construct_hull(candidate_points, extreme_point, right, convex_set)\n2: def decrypt(ciphertext: str, key: str) -> str:     if not isinstance(ciphertext, str):         raise TypeError(\"ciphertext must be a string\")     if not isinstance(key, str):         raise TypeError(\"key must be a string\")      if not ciphertext:         raise ValueError(\"ciphertext is empty\")     if not key:         raise ValueError(\"key is empty\")      key = key.lower()     ciphertext_iterator = 0     key_iterator = 0     plaintext = \"\"     while ciphertext_iterator < len(ciphertext):         if (             ord(ciphertext[ciphertext_iterator]) < 97             or ord(ciphertext[ciphertext_iterator]) > 122         ):             plaintext += ciphertext[ciphertext_iterator]         else:             plaintext += chr(                 (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26                 + 97             )             key += chr(                 (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26                 + 97             )             key_iterator += 1         ciphertext_iterator += 1     return plaintext", "output": "2"}
{"task": "search", "input": "search code:\nConvenience function for calling :func:`windowed_iter` on *src*,\n\nChoices:\n0: def get_week_day(year: int, month: int, day: int) -> str:     # minimal input check:     assert len(str(year)) > 2, \"year should be in YYYY format\"     assert 1 <= month <= 12, \"month should be between 1 to 12\"     assert 1 <= day <= 31, \"day should be between 1 to 31\"      # Doomsday algorithm:     century = year // 100     century_anchor = (5 * (century % 4) + 2) % 7     centurian = year % 100     centurian_m = centurian % 12     dooms_day = (         (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor     ) % 7     day_anchor = (         DOOMSDAY_NOT_LEAP[month - 1]         if year % 4 != 0 or (centurian == 0 and year % 400 != 0)         else DOOMSDAY_LEAP[month - 1]     )     week_day = (dooms_day + day - day_anchor) % 7     return WEEK_DAY_NAMES[week_day]\n1: def pairwise_iter(src, end=_UNSET):     return windowed_iter(src, 2, fill=end)\n2: def update_image_and_anno(     img_list: list, anno_list: list, flip_type: int = 1 ) -> tuple[list, list, list]:     new_annos_lists = []     path_list = []     new_imgs_list = []     for idx in range(len(img_list)):         new_annos = []         path = img_list[idx]         path_list.append(path)         img_annos = anno_list[idx]         img = cv2.imread(path)         if flip_type == 1:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 x_center_new = 1 - bbox[1]                 new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])         elif flip_type == 0:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 y_center_new = 1 - bbox[2]                 new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])         new_annos_lists.append(new_annos)         new_imgs_list.append(new_img)     return new_imgs_list, new_annos_lists, path_list", "output": "1"}
{"task": "search", "input": "search code:\nReturn the value found after the forward propagation training.\n\nChoices:\n0: def compress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         add_key_to_lexicon(lexicon, curr_string, index, last_match_id)         index += 1         curr_string = \"\"      while curr_string != \"\" and curr_string not in lexicon:         curr_string += \"0\"      if curr_string != \"\":         last_match_id = lexicon[curr_string]         result += last_match_id      return result\n1: def idft(Xarr):     N = len(Xarr)     roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]     for k in range(N):         coeffs = [roots_of_unity[k * n % N] for n in range(N)]         yield _complex_sumprod(Xarr, coeffs) / N\n2: def forward_propagation(expected: int, number_propagations: int) -> float:      # Random weight     weight = float(2 * (random.randint(1, 100)) - 1)      for _ in range(number_propagations):         # Forward propagation         layer_1 = sigmoid_function(INITIAL_VALUE * weight)         # How much did we miss?         layer_1_error = (expected / 100) - layer_1         # Error delta         layer_1_delta = layer_1_error * sigmoid_function(layer_1, True)         # Update weight         weight += INITIAL_VALUE * layer_1_delta      return layer_1 * 100", "output": "2"}
{"task": "search", "input": "search code:\nWarps the pixels of an image into a new image using the horizontal and vertical\n\nChoices:\n0: def warp(     image: np.ndarray, horizontal_flow: np.ndarray, vertical_flow: np.ndarray ) -> np.ndarray:     flow = np.stack((horizontal_flow, vertical_flow), 2)      # Create a grid of all pixel coordinates and subtract the flow to get the     # target pixels coordinates     grid = np.stack(         np.meshgrid(np.arange(0, image.shape[1]), np.arange(0, image.shape[0])), 2     )     grid = np.round(grid - flow).astype(np.int32)      # Find the locations outside of the original image     invalid = (grid < 0) | (grid >= np.array([image.shape[1], image.shape[0]]))     grid[invalid] = 0      warped = image[grid[:, :, 1], grid[:, :, 0]]      # Set pixels at invalid locations to 0     warped[invalid[:, :, 0] | invalid[:, :, 1]] = 0      return warped\n1: def get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:     num_filters = len(filter_points) - 2     filters = np.zeros((num_filters, int(ftt_size / 2) + 1))      for n in range(num_filters):         start = filter_points[n]         mid = filter_points[n + 1]         end = filter_points[n + 2]          # Linearly increase values from 0 to 1         filters[n, start:mid] = np.linspace(0, 1, mid - start)          # Linearly decrease values from 1 to 0         filters[n, mid:end] = np.linspace(1, 0, end - mid)      return filters\n2: def get_black_and_white_rgb(distance: float) -> tuple:     if distance == 1:         return (0, 0, 0)     else:         return (255, 255, 255)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef log_difference(number: int) -> float:\n\n    log_number = math.log(2, 10) * number\n    difference = round((log_number - int(log_number)), 15)\n\n    return difference", "output": "This function returns the decimal value of a number multiplied with log(2)"}
{"task": "search", "input": "search code:\nOpening filter, defined as the sequence of\n\nChoices:\n0: def bisection(function: Callable[[float], float], a: float, b: float) -> float:     start: float = a     end: float = b     if function(a) == 0:  # one of the a or b is a root for the function         return a     elif function(b) == 0:         return b     elif (         function(a) * function(b) > 0     ):  # if none of these are root and they are both positive or negative,         # then this algorithm can't find the root         raise ValueError(\"could not find root in given interval.\")     else:         mid: float = start + (end - start) / 2.0         while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7             if function(mid) == 0:                 return mid             elif function(mid) * function(start) < 0:                 end = mid             else:                 start = mid             mid = start + (end - start) / 2.0         return mid\n1: def closing_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:     if kernel is None:         kernel = np.ones((3, 3))     return transform(transform(image, \"erosion\", kernel), \"dilation\", kernel)\n2: def recursive_lucas_number(n_th_number: int) -> int:     if not isinstance(n_th_number, int):         raise TypeError(\"recursive_lucas_number accepts only integer arguments.\")     if n_th_number == 0:         return 2     if n_th_number == 1:         return 1      return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(         n_th_number - 2     )", "output": "1"}
{"task": "search", "input": "search code:\nDisplay these values as a 2-D grid.\n\nChoices:\n0: def fast_primes(max_n: int) -> Generator[int]:     numbers: Generator = (i for i in range(1, (max_n + 1), 2))     # It's useless to test even numbers as they will not be prime     if max_n > 2:         yield 2  # Because 2 will not be tested, it's necessary to yield it now     for i in (n for n in numbers if n > 1):         bound = int(math.sqrt(i)) + 1         for j in range(3, bound, 2):             # As we removed the even numbers, we don't need them now             if (i % j) == 0:                 break         else:             yield i\n1: def summarize_book(ol_book_data: dict) -> dict:     desired_keys = {         \"title\": \"Title\",         \"publish_date\": \"Publish date\",         \"authors\": \"Authors\",         \"number_of_pages\": \"Number of pages\",         \"isbn_10\": \"ISBN (10)\",         \"isbn_13\": \"ISBN (13)\",     }     data = {better_key: ol_book_data[key] for key, better_key in desired_keys.items()}     data[\"Authors\"] = [         get_openlibrary_data(author[\"key\"])[\"name\"] for author in data[\"Authors\"]     ]     for key, value in data.items():         if isinstance(value, list):             data[key] = \", \".join(value)     return data\n2: def display(values):     width = 1 + max(len(values[s]) for s in squares)     line = \"+\".join([\"-\" * (width * 3)] * 3)     for r in rows:         print(             \"\".join(                 values[r + c].center(width) + (\"|\" if c in \"36\" else \"\") for c in cols             )         )         if r in \"CF\":             print(line)     print()", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef is_sq(number: int) -> bool:\n    sq: int = int(number**0.5)\n    return number == sq * sq", "output": "Check if number is a perfect square."}
{"task": "search", "input": "search code:\nConstructs the convex hull of a set of 2D points using a divide-and-conquer strategy\n\nChoices:\n0: def choose(n: int, r: int) -> int:     ret = 1.0     for i in range(1, r + 1):         ret *= (n + 1 - i) / i     return round(ret)\n1: def res(x, y):     if 0 not in (x, y):         # We use the relation x^y = y*log10(x), where 10 is the base.         return y * math.log10(x)     elif x == 0:  # 0 raised to any number is 0         return 0     elif y == 0:         return 1  # any number raised to 0 is 1     raise AssertionError(\"This should never happen\")\n2: def convex_hull_recursive(points: list[Point]) -> list[Point]:     points = sorted(_validate_input(points))     n = len(points)      # divide all the points into an upper hull and a lower hull     # the left most point and the right most point are definitely     # members of the convex hull by definition.     # use these two anchors to divide all the points into two hulls,     # an upper hull and a lower hull.      # all points to the left (above) the line joining the extreme points belong to the     # upper hull     # all points to the right (below) the line joining the extreme points below to the     # lower hull     # ignore all points on the line joining the extreme points since they cannot be     # part of the convex hull      left_most_point = points[0]     right_most_point = points[n - 1]      convex_set = {left_most_point, right_most_point}     upper_hull = []     lower_hull = []      for i in range(1, n - 1):         det = _det(left_most_point, right_most_point, points[i])          if det > 0:             upper_hull.append(points[i])         elif det < 0:             lower_hull.append(points[i])      _construct_hull(upper_hull, left_most_point, right_most_point, convex_set)     _construct_hull(lower_hull, right_most_point, left_most_point, convex_set)      return sorted(convex_set)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef bisect_right(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "def bisect_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo"}
{"task": "summary", "input": "summarize code:\ndef get_module_callables(mod, ignore=None):\n    if isinstance(mod, str):\n        mod = sys.modules[mod]\n    types, funcs = {}, {}\n    for attr_name in dir(mod):\n        if ignore and ignore(attr_name):\n            continue\n        try:\n            attr = getattr(mod, attr_name)\n        except Exception:\n            continue\n        try:\n            attr_mod_name = attr.__module__\n        except AttributeError:\n            continue\n        if attr_mod_name != mod.__name__:\n            continue\n        if isinstance(attr, type):\n            types[attr_name] = attr\n        elif callable(attr):\n            funcs[attr_name] = attr\n    return types, funcs", "output": "Returns two maps of (*types*, *funcs*) from *mod*, optionally"}
{"task": "detection", "input": "classify code:\ndef abbr(a: str, b: str) -> bool:\n    \"\"\"\n    >>> abbr(\"daBcd\", \"ABC\")\n    True\n    >>> abbr(\"dBcd\", \"ABC\")\n    False\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m + 1):\n            if dp[i][j]:\n                if j < m and a[i].upper() == b[j]:\n                    dp[i + 1][j + 1] = True\n                if a[i].islower():\n                    dp[i + 1][j] = True\n    return dp[n][m]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef get_child_right_position(position: int) -> int:\n    return (2 * position) + 2", "output": "heap helper function get the position of the right child of the current node"}
{"task": "search", "input": "search code:\nFunction implements adler-32 hash.\n\nChoices:\n0: def random_chars(number_char: int = 32) -> str:     assert number_char > 1, \"The number of character should greater than 1\"     letter_code = ascii_lowercase + digits     return \"\".join(random.choice(letter_code) for _ in range(number_char))\n1: def partition(pred, iterable):     if pred is None:         pred = bool      t1, t2, p = tee(iterable, 3)     p1, p2 = tee(map(pred, p))     return (compress(t1, map(not_, p1)), compress(t2, p2))\n2: def adler32(plain_text: str) -> int:     a = 1     b = 0     for plain_chr in plain_text:         a = (a + ord(plain_chr)) % MOD_ADLER         b = (b + a) % MOD_ADLER     return (b << 16) | a", "output": "2"}
{"task": "search", "input": "search code:\nApplies the Scaled Exponential Linear Unit function to each element of the vector.\n\nChoices:\n0: def scaled_exponential_linear_unit(     vector: np.ndarray, alpha: float = 1.6732, lambda_: float = 1.0507 ) -> np.ndarray:     return lambda_ * np.where(vector > 0, vector, alpha * (np.exp(vector) - 1))\n1: def tabu_search(     first_solution, distance_of_first_solution, dict_of_neighbours, iters, size ):     count = 1     solution = first_solution     tabu_list = []     best_cost = distance_of_first_solution     best_solution_ever = solution      while count <= iters:         neighborhood = find_neighborhood(solution, dict_of_neighbours)         index_of_best_solution = 0         best_solution = neighborhood[index_of_best_solution]         best_cost_index = len(best_solution) - 1          found = False         while not found:             i = 0             while i < len(best_solution):                 if best_solution[i] != solution[i]:                     first_exchange_node = best_solution[i]                     second_exchange_node = solution[i]                     break                 i = i + 1              if [first_exchange_node, second_exchange_node] not in tabu_list and [                 second_exchange_node,                 first_exchange_node,             ] not in tabu_list:                 tabu_list.append([first_exchange_node, second_exchange_node])                 found = True                 solution = best_solution[:-1]                 cost = neighborhood[index_of_best_solution][best_cost_index]                 if cost < best_cost:                     best_cost = cost                     best_solution_ever = solution             else:                 index_of_best_solution = index_of_best_solution + 1                 best_solution = neighborhood[index_of_best_solution]          if len(tabu_list) >= size:             tabu_list.pop(0)          count = count + 1      return best_solution_ever, best_cost\n2: def emitter_converter(size_par, data):     if size_par + len(data) <= 2**size_par - (len(data) - 1):         raise ValueError(\"size of parity don't match with size of data\")      data_out = []     parity = []     bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]      # sorted information data for the size of the output data     data_ord = []     # data position template + parity     data_out_gab = []     # parity bit counter     qtd_bp = 0     # counter position of data bits     cont_data = 0      for x in range(1, size_par + len(data) + 1):         # Performs a template of bit positions - who should be given,         # and who should be parity         if qtd_bp < size_par:             if (np.log(x) / np.log(2)).is_integer():                 data_out_gab.append(\"P\")                 qtd_bp = qtd_bp + 1             else:                 data_out_gab.append(\"D\")         else:             data_out_gab.append(\"D\")          # Sorts the data to the new output size         if data_out_gab[-1] == \"D\":             data_ord.append(data[cont_data])             cont_data += 1         else:             data_ord.append(None)      # Calculates parity     qtd_bp = 0  # parity bit counter     for bp in range(1, size_par + 1):         # Bit counter one for a given parity         cont_bo = 0         # counter to control the loop reading         for cont_loop, x in enumerate(data_ord):             if x is not None:                 try:                     aux = (bin_pos[cont_loop])[-1 * (bp)]                 except IndexError:                     aux = \"0\"                 if aux == \"1\" and x == \"1\":                     cont_bo += 1         parity.append(cont_bo % 2)          qtd_bp += 1      # Mount the message     cont_bp = 0  # parity bit counter     for x in range(size_par + len(data)):         if data_ord[x] is None:             data_out.append(str(parity[cont_bp]))             cont_bp += 1         else:             data_out.append(data_ord[x])      return data_out", "output": "0"}
{"task": "search", "input": "search code:\nReturns the week-day name out of a given date.\n\nChoices:\n0: def get_week_day(year: int, month: int, day: int) -> str:     # minimal input check:     assert len(str(year)) > 2, \"year should be in YYYY format\"     assert 1 <= month <= 12, \"month should be between 1 to 12\"     assert 1 <= day <= 31, \"day should be between 1 to 31\"      # Doomsday algorithm:     century = year // 100     century_anchor = (5 * (century % 4) + 2) % 7     centurian = year % 100     centurian_m = centurian % 12     dooms_day = (         (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor     ) % 7     day_anchor = (         DOOMSDAY_NOT_LEAP[month - 1]         if year % 4 != 0 or (centurian == 0 and year % 400 != 0)         else DOOMSDAY_LEAP[month - 1]     )     week_day = (dooms_day + day - day_anchor) % 7     return WEEK_DAY_NAMES[week_day]\n1: def is_isogram(string: str) -> bool:     if not all(x.isalpha() for x in string):         raise ValueError(\"String must only contain alphabetic characters.\")      letters = sorted(string.lower())     return len(letters) == len(set(letters))\n2: def is_palindrome(n: int) -> bool:     if n % 10 == 0:         return False     s = str(n)     return s == s[::-1]", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))", "output": "def get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))"}
{"task": "detection", "input": "classify code:\ndef shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the number of different ways the number m can be written as a\n\nChoices:\n0: def log_difference(number: int) -> float:      log_number = math.log(2, 10) * number     difference = round((log_number - int(log_number)), 15)      return difference\n1: def solution(m: int = 100) -> int:     memo = [[0 for _ in range(m)] for _ in range(m + 1)]     for i in range(m + 1):         memo[i][0] = 1      for n in range(m + 1):         for k in range(1, m):             memo[n][k] += memo[n][k - 1]             if n > k:                 memo[n][k] += memo[n - k - 1][k]      return memo[m][m - 1] - 1\n2: def unzip(iterable):     head, iterable = spy(iterable)     if not head:         # empty iterable, e.g. zip([], [], [])         return ()     # spy returns a one-length iterable as head     head = head[0]     iterables = tee(iterable, len(head))      # If we have an iterable like iter([(1, 2, 3), (4, 5), (6,)]),     # the second unzipped iterable fails at the third tuple since     # it tries to access (6,)[1].     # Same with the third unzipped iterable and the second tuple.     # To support these \"improperly zipped\" iterables, we suppress     # the IndexError, which just stops the unzipped iterables at     # first length mismatch.     return tuple(         iter_suppress(map(itemgetter(i), it), IndexError)         for i, it in enumerate(iterables)     )", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef hypercube_points(\n    num_points: int, hypercube_size: float, num_dimensions: int\n) -> np.ndarray:\n    rng = np.random.default_rng()\n    shape = (num_points, num_dimensions)\n    return hypercube_size * rng.random(shape)", "output": "Generates random points uniformly distributed within an n-dimensional hypercube."}
{"task": "summary", "input": "summarize code:\ndef _extract_labels(f, one_hot=False, num_classes=10):\n    print(\"Extracting\", f.name)\n    with gzip.GzipFile(fileobj=f) as bytestream:\n        magic = _read32(bytestream)\n        if magic != 2049:\n            msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"\n            raise ValueError(msg)\n        num_items = _read32(bytestream)\n        buf = bytestream.read(num_items)\n        labels = np.frombuffer(buf, dtype=np.uint8)\n        if one_hot:\n            return _dense_to_one_hot(labels, num_classes)\n        return labels", "output": "Extract the labels into a 1D uint8 numpy array [index]."}
{"task": "summary", "input": "summarize code:\ndef fib_iterative_yield(n: int) -> Iterator[int]:\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    a, b = 0, 1\n    yield a\n    for _ in range(n):\n        yield b\n        a, b = b, a + b", "output": "Calculates the first n (1-indexed) Fibonacci numbers using iteration with yield"}
{"task": "repair", "input": "fix bug:\ndef list_truncated_nums(n: int) -> List[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r", "output": "def list_truncated_nums(n: int) -> list[int]:\r\n    \"\"\"\r\n    Returns a list of all left and right truncated numbers of n\r\n    >>> list_truncated_nums(927628)\r\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\r\n    >>> list_truncated_nums(467)\r\n    [467, 67, 46, 7, 4]\r\n    >>> list_truncated_nums(58)\r\n    [58, 8, 5]\r\n    \"\"\"\r\n    str_num = str(n)\r\n    list_nums = [n]\r\n    for i in range(1, len(str_num)):\r\n        list_nums.append(int(str_num[i:]))\r\n        list_nums.append(int(str_num[:-i]))\r\n    return list_nums\r"}
{"task": "search", "input": "search code:\nCompute high-dimensional affinities (P matrix) using a Gaussian kernel.\n\nChoices:\n0: def vol_cuboid(width: float, height: float, length: float) -> float:     if width < 0 or height < 0 or length < 0:         raise ValueError(\"vol_cuboid() only accepts non-negative values\")     return float(width * height * length)\n1: def compute_pairwise_affinities(data_matrix: ndarray, sigma: float = 1.0) -> ndarray:     n_samples = data_matrix.shape[0]     squared_sum = np.sum(np.square(data_matrix), axis=1)     squared_distance = np.add(         np.add(-2 * np.dot(data_matrix, data_matrix.T), squared_sum).T, squared_sum     )      affinity_matrix = np.exp(-squared_distance / (2 * sigma**2))     np.fill_diagonal(affinity_matrix, 0)      affinity_matrix /= np.sum(affinity_matrix)     return (affinity_matrix + affinity_matrix.T) / (2 * n_samples)\n2: def validate_initial_digits(credit_card_number: str) -> bool:     return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef apnumber(value):\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n    if not 0 <= value < 10:\n        return str(value)\n    return (\n        _(\"zero\"),\n        _(\"one\"),\n        _(\"two\"),\n        _(\"three\"),\n        _(\"four\"),\n        _(\"five\"),\n        _(\"six\"),\n        _(\"seven\"),\n        _(\"eight\"),\n        _(\"nine\"),\n    )[value]", "output": "Converts an integer to Associated Press style."}
{"task": "search", "input": "search code:\nAttempt to solve a sequence of grids. Report results.\n\nChoices:\n0: def solution(n: int = 100) -> int:      sum_cubes = (n * (n + 1) // 2) ** 2     sum_squares = n * (n + 1) * (2 * n + 1) // 6     return sum_cubes - sum_squares\n1: def main() -> None:     trees = {\"zero\": Node(0), \"seven\": make_tree_seven(), \"nine\": make_tree_nine()}     for name, tree in trees.items():         print(f\"      The {name} tree: {tuple(tree)}\")         # (0,)         # (4, 2, 5, 1, 6, 3, 7)         # (7, 4, 8, 2, 5, 9, 1, 3, 6)         print(f\"Mirror of {name} tree: {tuple(tree.mirror())}\")\n2: def solve_all(grids, name=\"\", showif=0.0):      def time_solve(grid):         start = time.monotonic()         values = solve(grid)         t = time.monotonic() - start         ## Display puzzles that take long enough         if showif is not None and t > showif:             display(grid_values(grid))             if values:                 display(values)             print(f\"({t:.5f} seconds)\\n\")         return (t, solved(values))      times, results = zip(*[time_solve(grid) for grid in grids])     if (n := len(grids)) > 1:         print(             \"Solved %d of %d %s puzzles (avg %.2f secs (%d Hz), max %.2f secs).\"  # noqa: UP031             % (sum(results), n, name, sum(times) / n, n / sum(times), max(times))         )", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )", "output": "Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled."}
{"task": "repair", "input": "fix bug:\ndef djb2(s: str) -> int:\n    \"\"\"\n    Implementation of djb2 hash algorithm that\n    is popular because of it's magic constants.\n\n    >>> djb2('Algorithms')\n    3782405311\n\n    >>> djb2('scramble bits')\n    1609059040\n    \"\"\"\n    hash_value = 5381\n    for x in s:\n        hash_value = ((hash_value << 5) + hash_value) + ord(x)\n    return hash_value & 0xFFFFFFFF", "output": "def djb2(s: str) -> int:\n    \"\"\"\n    Implementation of djb2 hash algorithm that\n    is popular because of it's magic constants.\n\n    >>> djb2('Algorithms')\n    3782405311\n\n    >>> djb2('scramble bits')\n    1609059040\n    \"\"\"\n    hash_value = 5381\n    for x in s:\n        hash_value = ((hash_value << 5) + hash_value) + ord(x)\n    return hash_value & 0xFFFFFFFF"}
{"task": "search", "input": "search code:\nYield groups of consecutive items using :func:`itertools.groupby`.\n\nChoices:\n0: def consecutive_groups(iterable, ordering=None):     if ordering is None:         key = lambda x: x[0] - x[1]     else:         key = lambda x: x[0] - ordering(x[1])      for k, g in groupby(enumerate(iterable), key=key):         yield map(itemgetter(1), g)\n1: def split_punct_ws(text):     return [w for w in _punct_re.split(text) if w]\n2: def generate_pascal_triangle(num_rows: int) -> list[list[int]]:      if not isinstance(num_rows, int):         raise TypeError(\"The input value of 'num_rows' should be 'int'\")      if num_rows == 0:         return []     elif num_rows < 0:         raise ValueError(             \"The input value of 'num_rows' should be greater than or equal to 0\"         )      triangle: list[list[int]] = []     for current_row_idx in range(num_rows):         current_row = populate_current_row(triangle, current_row_idx)         triangle.append(current_row)     return triangle", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef abs_val(num: float) -> float:\n    return -num if num < 0 else num", "output": "Find the absolute value of a number."}
{"task": "search", "input": "search code:\nSplit *iterable* into pieces based on the output of *pred*.\n\nChoices:\n0: def partition(pred, iterable):     if pred is None:         pred = bool      t1, t2, p = tee(iterable, 3)     p1, p2 = tee(map(pred, p))     return (compress(t1, map(not_, p1)), compress(t2, p2))\n1: def extended_gcd(a: int, b: int) -> tuple[int, int, int]:     assert a >= 0     assert b >= 0      if b == 0:         d, x, y = a, 1, 0     else:         (d, p, q) = extended_gcd(b, a % b)         x = q         y = p - q * (a // b)      assert a % d == 0     assert b % d == 0     assert d == a * x + b * y      return (d, x, y)\n2: def split_when(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      it = iter(iterable)     try:         cur_item = next(it)     except StopIteration:         return      buf = [cur_item]     for next_item in it:         if pred(cur_item, next_item):             yield buf             if maxsplit == 1:                 yield [next_item, *it]                 return             buf = []             maxsplit -= 1          buf.append(next_item)         cur_item = next_item      yield buf", "output": "2"}
{"task": "detection", "input": "classify code:\ndef max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef area_square(side_length: float) -> float:\n    if side_length < 0:\n        raise ValueError(\"area_square() only accepts non-negative values\")\n    return side_length**2", "output": "Calculate the area of a square."}
{"task": "summary", "input": "summarize code:\ndef count_inversions_recursive(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    p = arr[0:mid]\n    q = arr[mid:]\n\n    a, inversion_p = count_inversions_recursive(p)\n    b, inversions_q = count_inversions_recursive(q)\n    c, cross_inversions = _count_cross_inversions(a, b)\n\n    num_inversions = inversion_p + inversions_q + cross_inversions\n    return c, num_inversions", "output": "Counts the number of inversions using a divide-and-conquer algorithm"}
{"task": "search", "input": "search code:\nReturns an escaped version of each string in *args*, according to\n\nChoices:\n0: def encrypt(plaintext: str, key: str) -> str:     if not isinstance(plaintext, str):         raise TypeError(\"plaintext must be a string\")     if not isinstance(key, str):         raise TypeError(\"key must be a string\")      if not plaintext:         raise ValueError(\"plaintext is empty\")     if not key:         raise ValueError(\"key is empty\")      key += plaintext     plaintext = plaintext.lower()     key = key.lower()     plaintext_iterator = 0     key_iterator = 0     ciphertext = \"\"     while plaintext_iterator < len(plaintext):         if (             ord(plaintext[plaintext_iterator]) < 97             or ord(plaintext[plaintext_iterator]) > 122         ):             ciphertext += plaintext[plaintext_iterator]             plaintext_iterator += 1         elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:             key_iterator += 1         else:             ciphertext += chr(                 (                     (ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))                     - 97                 )                 % 26                 + 97             )             key_iterator += 1             plaintext_iterator += 1     return ciphertext\n1: def escape_shell_args(args, sep=' ', style=None):     if not style:         style = 'cmd' if sys.platform == 'win32' else 'sh'      if style == 'sh':         return args2sh(args, sep=sep)     elif style == 'cmd':         return args2cmd(args, sep=sep)      raise ValueError(\"style expected one of 'cmd' or 'sh', not %r\" % style)\n2: def last(iterable, default=_marker):     try:         if isinstance(iterable, Sequence):             return iterable[-1]         # Work around https://bugs.python.org/issue38525         if getattr(iterable, '__reversed__', None):             return next(reversed(iterable))         return deque(iterable, maxlen=1)[-1]     except (IndexError, TypeError, StopIteration):         if default is _marker:             raise ValueError(                 'last() was called on an empty iterable, '                 'and no default value was provided.'             )         return default", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef heaps(arr: list) -> list:\n\n    if len(arr) <= 1:\n        return [tuple(arr)]\n\n    res = []\n\n    def generate(n: int, arr: list):\n        c = [0] * n\n        res.append(tuple(arr))\n\n        i = 0\n        while i < n:\n            if c[i] < i:\n                if i % 2 == 0:\n                    arr[0], arr[i] = arr[i], arr[0]\n                else:\n                    arr[c[i]], arr[i] = arr[i], arr[c[i]]\n                res.append(tuple(arr))\n                c[i] += 1\n                i = 0\n            else:\n                c[i] = 0\n                i += 1\n\n    generate(len(arr), arr)\n    return res", "output": "Pure python implementation of the iterative Heap's algorithm,"}
{"task": "search", "input": "search code:\nTake in 1 integer, return a number that is\n\nChoices:\n0: def arithmetic_right_shift(number: int, shift_amount: int) -> str:     if number >= 0:  # Get binary representation of positive number         binary_number = \"0\" + str(bin(number)).strip(\"-\")[2:]     else:  # Get binary (2's complement) representation of negative number         binary_number_length = len(bin(number)[3:])  # Find 2's complement of number         binary_number = bin(abs(number) - (1 << binary_number_length))[3:]         binary_number = (             \"1\" + \"0\" * (binary_number_length - len(binary_number)) + binary_number         )      if shift_amount >= len(binary_number):         return \"0b\" + binary_number[0] * len(binary_number)     return (         \"0b\"         + binary_number[0] * shift_amount         + binary_number[: len(binary_number) - shift_amount]     )\n1: def is_palindrome(n: int) -> bool:     return str(n) == str(n)[::-1]\n2: def binary_count_setbits(a: int) -> int:     if a < 0:         raise ValueError(\"Input value must be a positive integer\")     elif isinstance(a, float):         raise TypeError(\"Input value must be a 'int' type\")     return bin(a).count(\"1\")", "output": "2"}
{"task": "search", "input": "search code:\nThis function returns a boolean value True if it is safe to place a queen there\n\nChoices:\n0: def is_safe(board: list[list[int]], row: int, column: int) -> bool:      n = len(board)  # Size of the board      # Check if there is any queen in the same upper column,     # left upper diagonal and right upper diagonal     return (         all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))         )         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))         )     )\n1: def get_support(cluster):     return [i * 100 / len(cluster) for i in cluster]\n2: def cyclic_sort(nums: list[int]) -> list[int]:      # Perform cyclic sort     index = 0     while index < len(nums):         # Calculate the correct index for the current element         correct_index = nums[index] - 1         # If the current element is not at its correct position,         # swap it with the element at its correct index         if index != correct_index:             nums[index], nums[correct_index] = nums[correct_index], nums[index]         else:             # If the current element is already in its correct position,             # move to the next element             index += 1      return nums", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef apply_tsne(\n    data_matrix: ndarray,\n    n_components: int = 2,\n    learning_rate: float = 200.0,\n    n_iter: int = 500,\n) -> ndarray:\n    if n_components < 1 or n_iter < 1:\n        raise ValueError(\"n_components and n_iter must be >= 1\")\n\n    n_samples = data_matrix.shape[0]\n    rng = np.random.default_rng()\n    embedding = rng.standard_normal((n_samples, n_components)) * 1e-4\n\n    high_dim_affinities = compute_pairwise_affinities(data_matrix)\n    high_dim_affinities = np.maximum(high_dim_affinities, 1e-12)\n\n    embedding_increment = np.zeros_like(embedding)\n    momentum = 0.5\n\n    for iteration in range(n_iter):\n        low_dim_affinities, numerator_matrix = compute_low_dim_affinities(embedding)\n        low_dim_affinities = np.maximum(low_dim_affinities, 1e-12)\n\n        affinity_diff = high_dim_affinities - low_dim_affinities\n\n        gradient = 4 * (\n            np.dot((affinity_diff * numerator_matrix), embedding)\n            - np.multiply(\n                np.sum(affinity_diff * numerator_matrix, axis=1)[:, np.newaxis],\n                embedding,\n            )\n        )\n\n        embedding_increment = momentum * embedding_increment - learning_rate * gradient\n        embedding += embedding_increment\n\n        if iteration == int(n_iter / 4):\n            momentum = 0.8\n\n    return embedding", "output": "Apply t-SNE for dimensionality reduction."}
{"task": "search", "input": "search code:\nThis function can calculate any one of the three -\n\nChoices:\n0: def combination_with_replacement_index(element, iterable):     element = tuple(element)     l = len(element)     element = enumerate(element)      k, y = next(element, (None, None))     if k is None:         return 0      indexes = []     pool = tuple(iterable)     for n, x in enumerate(pool):         while x == y:             indexes.append(n)             tmp, y = next(element, (None, None))             if tmp is None:                 break             else:                 k = tmp         if y is None:             break     else:         raise ValueError(             'element is not a combination with replacement of iterable'         )      n = len(pool)     occupations = [0] * n     for p in indexes:         occupations[p] += 1      index = 0     cumulative_sum = 0     for k in range(1, n):         cumulative_sum += occupations[k - 1]         j = l + n - 1 - k - cumulative_sum         i = n - k         if i <= j:             index += comb(j, i)      return index\n1: def carrier_concentration(     electron_conc: float,     hole_conc: float,     intrinsic_conc: float, ) -> tuple:     if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:         raise ValueError(\"You cannot supply more or less than 2 values\")     elif electron_conc < 0:         raise ValueError(\"Electron concentration cannot be negative in a semiconductor\")     elif hole_conc < 0:         raise ValueError(\"Hole concentration cannot be negative in a semiconductor\")     elif intrinsic_conc < 0:         raise ValueError(             \"Intrinsic concentration cannot be negative in a semiconductor\"         )     elif electron_conc == 0:         return (             \"electron_conc\",             intrinsic_conc**2 / hole_conc,         )     elif hole_conc == 0:         return (             \"hole_conc\",             intrinsic_conc**2 / electron_conc,         )     elif intrinsic_conc == 0:         return (             \"intrinsic_conc\",             (electron_conc * hole_conc) ** 0.5,         )     else:         return (-1, -1)\n2: def job_sequencing_with_deadlines(jobs: list) -> list:      # Sort the jobs in descending order of profit     jobs = sorted(jobs, key=lambda value: value[2], reverse=True)      # Create a list of size equal to the maximum deadline     # and initialize it with -1     max_deadline = max(jobs, key=lambda value: value[1])[1]     time_slots = [-1] * max_deadline      # Finding the maximum profit and the count of jobs     count = 0     max_profit = 0     for job in jobs:         # Find a free time slot for this job         # (Note that we start from the last possible slot)         for i in range(job[1] - 1, -1, -1):             if time_slots[i] == -1:                 time_slots[i] = job[0]                 count += 1                 max_profit += job[2]                 break     return [count, max_profit]", "output": "1"}
{"task": "search", "input": "search code:\ncreate edge between the nodes\n\nChoices:\n0: def create_edge(nodes, graph, cluster, c1):     for i in cluster[c1]:         count = 0         c2 = c1 + 1         while c2 < max(cluster.keys()):             for j in cluster[c2]:                 if int(i, 2) & int(j, 2) == int(i, 2):                     if tuple(nodes[i]) in graph:                         graph[tuple(nodes[i])].append(nodes[j])                     else:                         graph[tuple(nodes[i])] = [nodes[j]]                     count += 1             if count == 0:                 c2 = c2 + 1             else:                 break\n1: def pairs_with_sum(arr: list, req_sum: int) -> int:     return len([1 for a, b in combinations(arr, 2) if a + b == req_sum])\n2: def increment_score(count: int) -> int:     return int(count * (count + 1) / 2)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef reshape(matrix, shape):\n    if isinstance(shape, int):\n        return batched(chain.from_iterable(matrix), shape)\n    first_dim, *dims = shape\n    scalar_stream = _flatten_tensor(matrix)\n    reshaped = reduce(batched, reversed(dims), scalar_stream)\n    return islice(reshaped, first_dim)", "output": "Change the shape of a *matrix*."}
{"task": "summary", "input": "summarize code:\ndef balanced_parentheses(parentheses: str) -> bool:\n    stack: Stack[str] = Stack()\n    bracket_pairs = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}\n    for bracket in parentheses:\n        if bracket in bracket_pairs:\n            stack.push(bracket)\n        elif bracket in (\")\", \"]\", \"}\") and (\n            stack.is_empty() or bracket_pairs[stack.pop()] != bracket\n        ):\n            return False\n    return stack.is_empty()", "output": "Use a stack to check if a string of parentheses is balanced."}
{"task": "repair", "input": "fix bug:\ndef digit_sum(n: int) -> int:\n    \"\"\"\n    Returns the sum of the digits of the number.\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(456)\n    15\n    >>> digit_sum(78910)\n    25\n    \"\"\"\n    return sum(int(digit) for digit in str(n))", "output": "def digit_sum(n: int) -> int:\n    \"\"\"\n    Returns the sum of the digits of the number.\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(456)\n    15\n    >>> digit_sum(78910)\n    25\n    \"\"\"\n    return sum(int(digit) for digit in str(n))"}
{"task": "search", "input": "search code:\nReturns the number of hybrid-integers less than or equal to base^degree\n\nChoices:\n0: def solution(base: int = 800800, degree: int = 800800) -> int:      upper_bound = degree * log2(base)     max_prime = int(upper_bound)     prime_numbers = calculate_prime_numbers(max_prime)      hybrid_integers_count = 0     left = 0     right = len(prime_numbers) - 1     while left < right:         while (             prime_numbers[right] * log2(prime_numbers[left])             + prime_numbers[left] * log2(prime_numbers[right])             > upper_bound         ):             right -= 1         hybrid_integers_count += right - left         left += 1      return hybrid_integers_count\n1: def vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:     return point1[0] * point2[1] - point1[1] * point2[0]\n2: def combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:      dp_array = [0] * (target + 1)     dp_array[0] = 1      for i in range(1, target + 1):         for j in range(n):             if i - array[j] >= 0:                 dp_array[i] += dp_array[i - array[j]]      return dp_array[target]", "output": "0"}
{"task": "search", "input": "search code:\nErase element\n\nChoices:\n0: def erase(root: Node | None, value: int) -> Node | None:     left, right = split(root, value - 1)     _, right = split(right, value)     return merge(left, right)\n1: def circular_shifts(iterable, steps=1):     buffer = deque(iterable)     if steps == 0:         raise ValueError('Steps should be a non-zero integer')      buffer.rotate(steps)     steps = -steps     n = len(buffer)     n //= math.gcd(n, steps)      for _ in repeat(None, n):         buffer.rotate(steps)         yield tuple(buffer)\n2: def get_cluster(nodes):     cluster = {}     for key, value in nodes.items():         cluster.setdefault(key.count(\"1\"), {})[key] = value     return cluster", "output": "0"}
{"task": "detection", "input": "classify code:\ndef largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef radix_sort(list_of_ints: list[int]) -> list[int]:\n    placement = 1\n    max_digit = max(list_of_ints)\n    while placement <= max_digit:\n        # declare and initialize empty buckets\n        buckets: list[list] = [[] for _ in range(RADIX)]\n        # split list_of_ints between the buckets\n        for i in list_of_ints:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n        # put each buckets' contents into list_of_ints\n        a = 0\n        for b in range(RADIX):\n            for i in buckets[b]:\n                list_of_ints[a] = i\n                a += 1\n        # move to next\n        placement *= RADIX\n    return list_of_ints", "output": "Examples:"}
{"task": "search", "input": "search code:\nA Pangram String contains all the alphabets at least once.\n\nChoices:\n0: def postorder(curr_node: Node | None) -> list[Node]:     node_list = []     if curr_node is not None:         node_list = postorder(curr_node.left) + postorder(curr_node.right) + [curr_node]     return node_list\n1: def is_pangram(     input_str: str = \"The quick brown fox jumps over the lazy dog\", ) -> bool:     # Declare frequency as a set to have unique occurrences of letters     frequency = set()      # Replace all the whitespace in our sentence     input_str = input_str.replace(\" \", \"\")     for alpha in input_str:         if \"a\" <= alpha.lower() <= \"z\":             frequency.add(alpha.lower())     return len(frequency) == 26\n2: def compute_pairwise_affinities(data_matrix: ndarray, sigma: float = 1.0) -> ndarray:     n_samples = data_matrix.shape[0]     squared_sum = np.sum(np.square(data_matrix), axis=1)     squared_distance = np.add(         np.add(-2 * np.dot(data_matrix, data_matrix.T), squared_sum).T, squared_sum     )      affinity_matrix = np.exp(-squared_distance / (2 * sigma**2))     np.fill_diagonal(affinity_matrix, 0)      affinity_matrix /= np.sum(affinity_matrix)     return (affinity_matrix + affinity_matrix.T) / (2 * n_samples)", "output": "1"}
{"task": "search", "input": "search code:\nDivide `value` by `divisor` returning the quotient and remainder.\n\nChoices:\n0: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n1: def _quotient_and_remainder(value, divisor, unit, minimum_unit, suppress):     if unit == minimum_unit:         return (value / divisor, 0)     elif unit in suppress:         return (0, value)     else:         return divmod(value, divisor)\n2: def merge_sort(collection: list) -> list:      def merge(left: list, right: list) -> list:         result = []         while left and right:             result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))         result.extend(left)         result.extend(right)         return result      if len(collection) <= 1:         return collection     mid_index = len(collection) // 2     return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))", "output": "1"}
{"task": "search", "input": "search code:\nReturn a randomly shuffled copy of the input sequence.\n\nChoices:\n0: def shuffled(seq):     seq = list(seq)     random.shuffle(seq)     return seq\n1: def parse_token(token: str | float) -> float | str:     if token in OPERATORS:         return token     try:         return float(token)     except ValueError:         msg = f\"{token} is neither a number nor a valid operator\"         raise ValueError(msg)\n2: def apnumber(value):     try:         value = int(value)     except (TypeError, ValueError):         return value     if not 0 <= value < 10:         return str(value)     return (         _(\"zero\"),         _(\"one\"),         _(\"two\"),         _(\"three\"),         _(\"four\"),         _(\"five\"),         _(\"six\"),         _(\"seven\"),         _(\"eight\"),         _(\"nine\"),     )[value]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef permute_recursive(nums: list[int]) -> list[list[int]]:\n    result: list[list[int]] = []\n    if len(nums) == 0:\n        return [[]]\n    for _ in range(len(nums)):\n        n = nums.pop(0)\n        permutations = permute_recursive(nums.copy())\n        for perm in permutations:\n            perm.append(n)\n        result.extend(permutations)\n        nums.append(n)\n    return result", "output": "Return all permutations."}
{"task": "search", "input": "search code:\nRuns the calculation for numbers <= `max_num`.\n\nChoices:\n0: def quote_path_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])     return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t                      for t in text])\n1: def show_frequency_response(filter_type: FilterType, samplerate: int) -> None:      size = 512     inputs = [1] + [0] * (size - 1)     outputs = [filter_type.process(item) for item in inputs]      filler = [0] * (samplerate - size)  # zero-padding     outputs += filler     fft_out = np.abs(np.fft.fft(outputs))     fft_db = 20 * np.log10(fft_out)      # Frequencies on log scale from 24 to nyquist frequency     plt.xlim(24, samplerate / 2 - 1)     plt.xlabel(\"Frequency (Hz)\")     plt.xscale(\"log\")      # Display within reasonable bounds     bounds = get_bounds(fft_db, samplerate)     plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))     plt.ylabel(\"Gain (dB)\")      plt.plot(fft_db)     plt.show()\n2: def solution(max_num: int = 1000000) -> int:      primes = generate_primes(max_num)     chain = [0] * (max_num + 1)     for prime_idx, prime in enumerate(primes):         if prime**2 > max_num:             break          multiply(             chain=chain,             primes=primes,             min_prime_idx=prime_idx,             prev_num=1,             max_num=max_num,             prev_sum=0,             primes_degrees={},         )      return find_longest_chain(chain=chain, max_num=max_num)", "output": "2"}
{"task": "search", "input": "search code:\nInsert a new node at the end of a linked list and return the new head.\n\nChoices:\n0: def sum_of_digits_recursion(n: int) -> int:     n = abs(n)     return n if n < 10 else n % 10 + sum_of_digits(n // 10)\n1: def go_next(i: int, z_result: list[int], s: str) -> bool:     return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]\n2: def insert_node(head: Node | None, data: int) -> Node:     new_node = Node(data)     # If the linked list is empty, the new_node becomes the head     if head is None:         return new_node      temp_node = head     while temp_node.next_node:         temp_node = temp_node.next_node      temp_node.next_node = new_node     return head", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef non_bouncy_exact(n: int) -> int:\n    return choose(8 + n, n) + choose(9 + n, n) - 10", "output": "Calculate the number of non-bouncy numbers with at most n digits."}
{"task": "search", "input": "search code:\nInplace implementation of the MSD radix sort algorithm.\n\nChoices:\n0: def reactive_power(apparent_power: float, power_factor: float) -> float:     if (         not isinstance(power_factor, (int, float))         or power_factor < -1         or power_factor > 1     ):         raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")     return apparent_power * math.sqrt(1 - power_factor**2)\n1: def msd_radix_sort_inplace(list_of_ints: list[int]):      length = len(list_of_ints)     if not list_of_ints or length == 1:         return      if min(list_of_ints) < 0:         raise ValueError(\"All numbers must be positive\")      most_bits = max(len(bin(x)[2:]) for x in list_of_ints)     _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)\n2: def generate_pascal_triangle_optimized(num_rows: int) -> list[list[int]]:      if not isinstance(num_rows, int):         raise TypeError(\"The input value of 'num_rows' should be 'int'\")      if num_rows == 0:         return []     elif num_rows < 0:         raise ValueError(             \"The input value of 'num_rows' should be greater than or equal to 0\"         )      result: list[list[int]] = [[1]]      for row_index in range(1, num_rows):         temp_row = [0] + result[-1] + [0]         row_length = row_index + 1         # Calculate the number of distinct elements in a row         distinct_elements = sum(divmod(row_length, 2))         row_first_half = [             temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)         ]         row_second_half = row_first_half[: (row_index + 1) // 2]         row_second_half.reverse()         row = row_first_half + row_second_half         result.append(row)      return result", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(matrix_str: list[str] = MATRIX_2) -> int:\n\n    n = len(matrix_str)\n    arr = np.empty(shape=(n, n), dtype=int)\n    for row, matrix_row_str in enumerate(matrix_str):\n        matrix_row_list_str = matrix_row_str.split()\n        for col, elem_str in enumerate(matrix_row_list_str):\n            arr[row, col] = int(elem_str)\n\n    cache: dict[str, int] = {}\n    return solve(arr=arr, row=0, cols=set(range(n)), cache=cache)", "output": "Takes list of strings `matrix_str` to parse the matrix and calculates the max sum."}
{"task": "search", "input": "search code:\nDetermines whether number is prime\n\nChoices:\n0: def is_prime(number: int) -> bool:      return all(number % divisor != 0 for divisor in range(2, isqrt(number) + 1))\n1: def get_cost_derivative(index):     cost_derivative_value = summation_of_cost_derivative(index, m) / m     return cost_derivative_value\n2: def in_static_equilibrium(     forces: NDArray[float64], location: NDArray[float64], eps: float = 10**-1 ) -> bool:     # summation of moments is zero     moments: NDArray[float64] = cross(location, forces)     sum_moments: float = sum(moments)     return bool(abs(sum_moments) < eps)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef collect_dataset() -> tuple[ndarray, ndarray]:\n    iris_dataset = load_iris()\n    return np.array(iris_dataset.data), np.array(iris_dataset.target)", "output": "Load the Iris dataset and return features and labels."}
{"task": "detection", "input": "classify code:\ndef actual_power(a: int, b: int) -> int:\n    \"\"\"\n    Function using divide and conquer to calculate a^b.\n    It only works for integer a,b.\n\n    :param a: The base of the power operation, an integer.\n    :param b: The exponent of the power operation, a non-negative integer.\n    :return: The result of a^b.\n\n    Examples:\n    >>> actual_power(3, 2)\n    9\n    >>> actual_power(5, 3)\n    125\n    >>> actual_power(2, 5)\n    32\n    >>> actual_power(7, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    half = actual_power(a, b // 2)\n\n    if (b % 2) == 0:\n        return half * half\n    else:\n        return a * half * half", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef sentence_to_title_case(input_str: str) -> str:\n\n    return \" \".join(to_title_case(word) for word in input_str.split())", "output": "Converts a string to title case, preserving the input as is"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    kmap = [[0, 1], [1, 1]]\n\n    # Manually generate the product of [0, 1] and [0, 1]\n\n    for row in kmap:\n        print(row)\n\n    print(\"Simplified Expression:\")\n    print(simplify_kmap(kmap))", "output": "Main function to create and simplify a K-Map."}
{"task": "summary", "input": "summarize code:\ndef tabulate(function, start=0):\n    return map(function, count(start))", "output": "Return an iterator over the results of ``func(start)``,"}
{"task": "summary", "input": "summarize code:\ndef last(iterable, default=_marker):\n    try:\n        if isinstance(iterable, Sequence):\n            return iterable[-1]\n        # Work around https://bugs.python.org/issue38525\n        if getattr(iterable, '__reversed__', None):\n            return next(reversed(iterable))\n        return deque(iterable, maxlen=1)[-1]\n    except (IndexError, TypeError, StopIteration):\n        if default is _marker:\n            raise ValueError(\n                'last() was called on an empty iterable, '\n                'and no default value was provided.'\n            )\n        return default", "output": "Return the last item of *iterable*, or *default* if *iterable* is"}
{"task": "summary", "input": "summarize code:\ndef check_cycle(graph: dict) -> bool:\n    # Keep track of visited nodes\n    visited: set[int] = set()\n    # To detect a back edge, keep track of vertices currently in the recursion stack\n    rec_stk: set[int] = set()\n    return any(\n        node not in visited and depth_first_search(graph, node, visited, rec_stk)\n        for node in graph\n    )", "output": "Returns True if graph is cyclic else False"}
{"task": "search", "input": "search code:\nThis function implements the minimax algorithm, which helps achieve the optimal\n\nChoices:\n0: def bitap_string_match(text: str, pattern: str) -> int:     if not pattern:         return 0     m = len(pattern)     if m > len(text):         return -1      # Initial state of bit string 1110     state = ~1     # Bit = 0 if character appears at index, and 1 otherwise     pattern_mask: list[int] = [~0] * 27  # 1111      for i, char in enumerate(pattern):         # For the pattern mask for this character, set the bit to 0 for each i         # the character appears.         pattern_index: int = ord(char) - ord(\"a\")         pattern_mask[pattern_index] &= ~(1 << i)      for i, char in enumerate(text):         text_index = ord(char) - ord(\"a\")         # If this character does not appear in pattern, it's pattern mask is 1111.         # Performing a bitwise OR between state and 1111 will reset the state to 1111         # and start searching the start of pattern again.         state |= pattern_mask[text_index]         state <<= 1          # If the mth bit (counting right to left) of the state is 0, then we have         # found pattern in text         if (state & (1 << m)) == 0:             return i - m + 1      return -1\n1: def minimax(     depth: int, node_index: int, is_max: bool, scores: list[int], height: float ) -> int:      if depth < 0:         raise ValueError(\"Depth cannot be less than 0\")     if len(scores) == 0:         raise ValueError(\"Scores cannot be empty\")      # Base case: If the current depth equals the height of the tree,     # return the score of the current node.     if depth == height:         return scores[node_index]      # If it's the maximizer's turn, choose the maximum score     # between the two possible moves.     if is_max:         return max(             minimax(depth + 1, node_index * 2, False, scores, height),             minimax(depth + 1, node_index * 2 + 1, False, scores, height),         )      # If it's the minimizer's turn, choose the minimum score     # between the two possible moves.     return min(         minimax(depth + 1, node_index * 2, True, scores, height),         minimax(depth + 1, node_index * 2 + 1, True, scores, height),     )\n2: def is_palindrome(n: int) -> bool:     if n % 10 == 0:         return False     s = str(n)     return s == s[::-1]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n    num = 138902663\n\n    while not is_square_form(num * num):\n        if num % 10 == 3:\n            num -= 6  # (3 - 6) % 10 = 7\n        else:\n            num -= 4  # (7 - 4) % 10 = 3\n\n    return num * 10", "output": "Returns the first integer whose square is of the form 1_2_3_4_5_6_7_8_9_0"}
{"task": "detection", "input": "classify code:\ndef check1(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital from END\n\n    >>> check1(123456789987654321)\n    True\n\n    >>> check1(120000987654321)\n    True\n\n    >>> check1(12345678957656779870004321)\n    False\n\n    \"\"\"\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f", "output": "CORRECT"}
{"task": "search", "input": "search code:\n:param matrix_a: A square Matrix.\n\nChoices:\n0: def solution(n: int = 1000000) -> int:     largest_number = 1     pre_counter = 1     counters = {1: 1}      for input1 in range(2, n):         counter = 0         number = input1          while True:             if number in counters:                 counter += counters[number]                 break             if number % 2 == 0:                 number //= 2                 counter += 1             else:                 number = (3 * number) + 1                 counter += 1          if input1 not in counters:             counters[input1] = counter          if counter > pre_counter:             largest_number = input1             pre_counter = counter     return largest_number\n1: def matrix_multiply_recursive(matrix_a: Matrix, matrix_b: Matrix) -> Matrix:     if not matrix_a or not matrix_b:         return []     if not all(         (len(matrix_a) == len(matrix_b), is_square(matrix_a), is_square(matrix_b))     ):         raise ValueError(\"Invalid matrix dimensions\")      # Initialize the result matrix with zeros     result = [[0] * len(matrix_b[0]) for _ in range(len(matrix_a))]      # Recursive multiplication of matrices     def multiply(         i_loop: int,         j_loop: int,         k_loop: int,         matrix_a: Matrix,         matrix_b: Matrix,         result: Matrix,     ) -> None:         if i_loop >= len(matrix_a):             return         if j_loop >= len(matrix_b[0]):             return multiply(i_loop + 1, 0, 0, matrix_a, matrix_b, result)         if k_loop >= len(matrix_b):             return multiply(i_loop, j_loop + 1, 0, matrix_a, matrix_b, result)         result[i_loop][j_loop] += matrix_a[i_loop][k_loop] * matrix_b[k_loop][j_loop]         return multiply(i_loop, j_loop, k_loop + 1, matrix_a, matrix_b, result)      # Perform the recursive matrix multiplication     multiply(0, 0, 0, matrix_a, matrix_b, result)     return result\n2: def zero_vector(dimension: int) -> Vector:     # precondition     assert isinstance(dimension, int)     return Vector([0] * dimension)", "output": "1"}
{"task": "search", "input": "search code:\nYield tuples whose elements are offset from *iterable*.\n\nChoices:\n0: def dilation(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:     output = np.zeros_like(image)     image_padded = np.zeros(         (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)     )      # Copy image to padded image     image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image      # Iterate over image & apply kernel     for x in range(image.shape[1]):         for y in range(image.shape[0]):             summation = (                 kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]             ).sum()             output[y, x] = int(summation > 0)     return output\n1: def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:     arr.sort()     n = len(arr)     for i in range(n - 1):         left, right = i + 1, n - 1         while left < right:             if arr[i] + arr[left] + arr[right] == target:                 return (arr[i], arr[left], arr[right])             elif arr[i] + arr[left] + arr[right] < target:                 left += 1             elif arr[i] + arr[left] + arr[right] > target:                 right -= 1     return (0, 0, 0)\n2: def stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):     children = tee(iterable, len(offsets))      return zip_offset(         *children, offsets=offsets, longest=longest, fillvalue=fillvalue     )", "output": "2"}
{"task": "detection", "input": "classify code:\ndef merge_insertion_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n    answer = 0\n    decimal_context = decimal.Context(prec=105)\n    for i in range(2, 100):\n        number = decimal.Decimal(i)\n        sqrt_number = number.sqrt(decimal_context)\n        if len(str(sqrt_number)) > 1:\n            answer += int(str(sqrt_number)[0])\n            sqrt_number_str = str(sqrt_number)[2:101]\n            answer += sum(int(x) for x in sqrt_number_str)\n    return answer", "output": "To evaluate the sum, Used decimal python module to calculate the decimal"}
{"task": "repair", "input": "fix bug:\ndef jaro_winkler(str1: str, str2: str) -> float:\n    \"\"\"\n    Jaro-Winkler distance is a string metric measuring an edit distance between two\n    sequences.\n    Output value is between 0.0 and 1.0.\n\n    >>> jaro_winkler(\"martha\", \"marhta\")\n    0.9611111111111111\n    >>> jaro_winkler(\"CRATE\", \"TRACE\")\n    0.7333333333333334\n    >>> jaro_winkler(\"test\", \"dbdbdbdb\")\n    0.0\n    >>> jaro_winkler(\"test\", \"test\")\n    1.0\n    >>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n    0.6363636363636364\n    >>> jaro_winkler(\"test\", \"\")\n    0.0\n    >>> jaro_winkler(\"hello\", \"world\")\n    0.4666666666666666\n    >>> jaro_winkler(\"hell**o\", \"*world\")\n    0.4365079365079365\n    \"\"\"\n\n    def get_matched_characters(_str1: str, _str2: str) -> str:\n        matched = []\n        limit = min(len(_str1), len(_str2)) // 2\n        for i, char in enumerate(_str1):\n            left = int(max(0, i - limit))\n            right = int(min(i + limit + 1, len(_str2)))\n            if char in _str2[left:right]:\n                matched.append(char)\n                _str2 = (\n                    f\"{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}\"\n                )\n\n        return \"\".join(matched)\n\n    # matching characters\n    matching_1 = get_matched_characters(str1, str2)\n    matching_2 = get_matched_characters(str2, str1)\n    match_count = len(matching_1)\n\n    # transposition\n    transpositions = (\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\n    )\n\n    if not match_count:\n        jaro = 0.0\n    else:\n        jaro = (\n            1\n            / 3\n            * (\n                match_count / len(str1)\n                + match_count / len(str2)\n                + (match_count - transpositions) / match_count\n            )\n        )\n\n    # common prefix up to 4 characters\n    prefix_len = 0\n    for c1, c2 in zip(str1[:4], str2[:4]):\n        if c1 == c2:\n            prefix_len += 1\n        else:\n            break\n\n    return jaro + 0.1 * prefix_len * (1 - jaro)", "output": "def jaro_winkler(str1: str, str2: str) -> float:\n    \"\"\"\n    Jaro-Winkler distance is a string metric measuring an edit distance between two\n    sequences.\n    Output value is between 0.0 and 1.0.\n\n    >>> jaro_winkler(\"martha\", \"marhta\")\n    0.9611111111111111\n    >>> jaro_winkler(\"CRATE\", \"TRACE\")\n    0.7333333333333334\n    >>> jaro_winkler(\"test\", \"dbdbdbdb\")\n    0.0\n    >>> jaro_winkler(\"test\", \"test\")\n    1.0\n    >>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n    0.6363636363636364\n    >>> jaro_winkler(\"test\", \"\")\n    0.0\n    >>> jaro_winkler(\"hello\", \"world\")\n    0.4666666666666666\n    >>> jaro_winkler(\"hell**o\", \"*world\")\n    0.4365079365079365\n    \"\"\"\n\n    def get_matched_characters(_str1: str, _str2: str) -> str:\n        matched = []\n        limit = min(len(_str1), len(_str2)) // 2\n        for i, char in enumerate(_str1):\n            left = int(max(0, i - limit))\n            right = int(min(i + limit + 1, len(_str2)))\n            if char in _str2[left:right]:\n                matched.append(char)\n                _str2 = (\n                    f\"{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}\"\n                )\n\n        return \"\".join(matched)\n\n    # matching characters\n    matching_1 = get_matched_characters(str1, str2)\n    matching_2 = get_matched_characters(str2, str1)\n    match_count = len(matching_1)\n\n    # transposition\n    transpositions = (\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\n    )\n\n    if not match_count:\n        jaro = 0.0\n    else:\n        jaro = (\n            1\n            / 3\n            * (\n                match_count / len(str1)\n                + match_count / len(str2)\n                + (match_count - transpositions) / match_count\n            )\n        )\n\n    # common prefix up to 4 characters\n    prefix_len = 0\n    for c1, c2 in zip(str1[:4], str2[:4]):\n        if c1 == c2:\n            prefix_len += 1\n        else:\n            break\n\n    return jaro + 0.1 * prefix_len * (1 - jaro)"}
{"task": "detection", "input": "classify code:\ndef decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPure implementation of graham scan algorithm in Python\n\nChoices:\n0: def graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:      if len(points) <= 2:         # There is no convex hull         raise ValueError(\"graham_scan: argument must contain more than 3 points.\")     if len(points) == 3:         return points     # find the lowest and the most left point     minidx = 0     miny, minx = maxsize, maxsize     for i, point in enumerate(points):         x = point[0]         y = point[1]         if y < miny:             miny = y             minx = x             minidx = i         if y == miny and x < minx:             minx = x             minidx = i      # remove the lowest and the most left point from points for preparing for sort     points.pop(minidx)      sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))     # This insert actually costs complexity,     # and you should instead add (minx, miny) into stack later.     # I'm using insert just for easy understanding.     sorted_points.insert(0, (minx, miny))      stack: deque[tuple[int, int]] = deque()     stack.append(sorted_points[0])     stack.append(sorted_points[1])     stack.append(sorted_points[2])     # The first 3 points lines are towards the left because we sort them by their angle     # from minx, miny.     current_direction = Direction.left      for i in range(3, len(sorted_points)):         while True:             starting = stack[-2]             via = stack[-1]             target = sorted_points[i]             next_direction = check_direction(starting, via, target)              if next_direction == Direction.left:                 current_direction = Direction.left                 break             if next_direction == Direction.straight:                 if current_direction == Direction.left:                     # We keep current_direction as left.                     # Because if the straight line keeps as straight,                     # we want to know if this straight line is towards left.                     break                 elif current_direction == Direction.right:                     # If the straight line is towards right,                     # every previous points on that straight line is not convex hull.                     stack.pop()             if next_direction == Direction.right:                 stack.pop()         stack.append(sorted_points[i])     return list(stack)\n1: def emitter_converter(size_par, data):     if size_par + len(data) <= 2**size_par - (len(data) - 1):         raise ValueError(\"size of parity don't match with size of data\")      data_out = []     parity = []     bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]      # sorted information data for the size of the output data     data_ord = []     # data position template + parity     data_out_gab = []     # parity bit counter     qtd_bp = 0     # counter position of data bits     cont_data = 0      for x in range(1, size_par + len(data) + 1):         # Performs a template of bit positions - who should be given,         # and who should be parity         if qtd_bp < size_par:             if (np.log(x) / np.log(2)).is_integer():                 data_out_gab.append(\"P\")                 qtd_bp = qtd_bp + 1             else:                 data_out_gab.append(\"D\")         else:             data_out_gab.append(\"D\")          # Sorts the data to the new output size         if data_out_gab[-1] == \"D\":             data_ord.append(data[cont_data])             cont_data += 1         else:             data_ord.append(None)      # Calculates parity     qtd_bp = 0  # parity bit counter     for bp in range(1, size_par + 1):         # Bit counter one for a given parity         cont_bo = 0         # counter to control the loop reading         for cont_loop, x in enumerate(data_ord):             if x is not None:                 try:                     aux = (bin_pos[cont_loop])[-1 * (bp)]                 except IndexError:                     aux = \"0\"                 if aux == \"1\" and x == \"1\":                     cont_bo += 1         parity.append(cont_bo % 2)          qtd_bp += 1      # Mount the message     cont_bp = 0  # parity bit counter     for x in range(size_par + len(data)):         if data_ord[x] is None:             data_out.append(str(parity[cont_bp]))             cont_bp += 1         else:             data_out.append(data_ord[x])      return data_out\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "0"}
{"task": "search", "input": "search code:\nCalculate the distance between two coordinate points\n\nChoices:\n0: def make_tree_nine() -> Node:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     tree.right.right = Node(6)     tree.left.left.left = Node(7)     tree.left.left.right = Node(8)     tree.left.right.right = Node(9)     return tree\n1: def solution_fast() -> int:      for a in range(300):         for b in range(400):             c = 1000 - a - b             if a < b < c and (a**2) + (b**2) == (c**2):                 return a * b * c      return -1\n2: def distance(city1: list[int], city2: list[int]) -> float:     return (((city1[0] - city2[0]) ** 2) + ((city1[1] - city2[1]) ** 2)) ** 0.5", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef validate(*values: float) -> bool:\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result", "output": "Input Parameters:"}
{"task": "detection", "input": "classify code:\ndef is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nParameters\n\nChoices:\n0: def _construct_hull(     points: list[Point], left: Point, right: Point, convex_set: set[Point] ) -> None:     if points:         extreme_point = None         extreme_point_distance = float(\"-inf\")         candidate_points = []          for p in points:             det = _det(left, right, p)              if det > 0:                 candidate_points.append(p)                  if det > extreme_point_distance:                     extreme_point_distance = det                     extreme_point = p          if extreme_point:             _construct_hull(candidate_points, left, extreme_point, convex_set)             convex_set.add(extreme_point)             _construct_hull(candidate_points, extreme_point, right, convex_set)\n1: def get_nodes(frequency_table):     nodes = {}     for _, item in enumerate(frequency_table):         nodes.setdefault(item[2], []).append(item[0])     return nodes\n2: def run(n: int) -> list[int]:      # Incrementor variable for our group list comprehension.     # This is the first number in each list of values     # to test.     base = 2      while True:         # Increment each value of a generated range         group = [base + i for i in range(n)]          # Run elements through the unique_prime_factors function         # Append our target number to the end.         checker = [upf_len(x) for x in group]         checker.append(n)          # If all numbers in the list are equal, return the group variable.         if equality(checker):             return group          # Increment our base variable by 1         base += 1", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    total = 0\n\n    for i in range(1, 101):\n        for j in range(1, i + 1):\n            if combinations(i, j) > 1e6:\n                total += 1\n    return total", "output": "Returns the number of values of nCr, for 1  n  100, are greater than"}
{"task": "repair", "input": "fix bug:\ndef check_anagrams(a: str, b: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return sorted(a.lower()) == sorted(b.lower())\r", "output": "def check_anagrams(first_str: str, second_str: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('This is    a      string', 'Is     this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return (\r\n        \"\".join(sorted(first_str.lower())).strip()\r\n        == \"\".join(sorted(second_str.lower())).strip()\r\n    )\r"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 4000000) -> int:\n\n    if n <= 1:\n        return 0\n    a = 0\n    b = 2\n    count = 0\n    while 4 * b + a <= n:\n        a, b = b, 4 * b + a\n        count += a\n    return count + b", "output": "Returns the sum of all even fibonacci sequence elements that are lower"}
{"task": "search", "input": "search code:\nCalculate the Volume of a Cube.\n\nChoices:\n0: def vol_cube(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"vol_cube() only accepts non-negative values\")     return pow(side_length, 3)\n1: def vol_spheres_union(     radius_1: float, radius_2: float, centers_distance: float ) -> float:      if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:         raise ValueError(             \"vol_spheres_union() only accepts non-negative values, non-zero radius\"         )      if centers_distance == 0:         return vol_sphere(max(radius_1, radius_2))      return (         vol_sphere(radius_1)         + vol_sphere(radius_2)         - vol_spheres_intersect(radius_1, radius_2, centers_distance)     )\n2: def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:     if not nums1 and not nums2:         raise ValueError(\"Both input arrays are empty.\")      # Merge the arrays into a single sorted array.     merged = sorted(nums1 + nums2)     total = len(merged)      if total % 2 == 1:  # If the total number of elements is odd         return float(merged[total // 2])  # then return the middle element      # If the total number of elements is even, calculate     # the average of the two middle elements as the median.     middle1 = merged[total // 2 - 1]     middle2 = merged[total // 2]     return (float(middle1) + float(middle2)) / 2.0", "output": "0"}
{"task": "search", "input": "search code:\nThis function returns the number negative base 2\n\nChoices:\n0: def bottom_up_cut_rod(n: int, prices: list):     _enforce_args(n, prices)      # length(max_rev) = n + 1, to accommodate for the revenue obtainable from a rod of     # length 0.     max_rev = [float(\"-inf\") for _ in range(n + 1)]     max_rev[0] = 0      for i in range(1, n + 1):         max_revenue_i = max_rev[i]         for j in range(1, i + 1):             max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])          max_rev[i] = max_revenue_i      return max_rev[n]\n1: def prime_generator():      num = 2     while True:         if is_prime(num):             yield num         num += 1\n2: def decimal_to_negative_base_2(num: int) -> int:     if num == 0:         return 0     ans = \"\"     while num != 0:         num, rem = divmod(num, -2)         if rem < 0:             rem += 2             num += 1         ans = str(rem) + ans     return int(ans)", "output": "2"}
{"task": "search", "input": "search code:\nExamples(rounded for precision):\n\nChoices:\n0: def validate_adjacency_list(graph: list[list[int | None]]) -> None:     if not isinstance(graph, list):         raise ValueError(\"Graph should be a list of lists.\")      for node_index, neighbors in enumerate(graph):         if not isinstance(neighbors, list):             no_neighbors_message: str = (                 f\"Node {node_index} should have a list of neighbors.\"             )             raise ValueError(no_neighbors_message)         for neighbor_index in neighbors:             if (                 not isinstance(neighbor_index, int)                 or neighbor_index < 0                 or neighbor_index >= len(graph)             ):                 invalid_neighbor_message: str = (                     f\"Invalid neighbor {neighbor_index} in node {node_index} \"                     f\"adjacency list.\"                 )                 raise ValueError(invalid_neighbor_message)\n1: def benchmark() -> None:     from collections.abc import Callable      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         print(f\"{call}: {func(value)} -- {timing} seconds\")      for value in (262144, 1125899906842624, 1267650600228229401496703205376):         for func in (num_digits, num_digits_fast, num_digits_faster):             benchmark_a_function(func, value)         print()\n2: def mse(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     square_diff = np.square(difference)      score = square_diff.mean()     return score", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef filter_common_word(possibles: List[str], common_word: str) -> List[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]", "output": "def filter_common_word(possibles: list[str], common_word: str) -> list[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]"}
{"task": "search", "input": "search code:\nprint \"Valid IP address\" If IP is valid.\n\nChoices:\n0: def solution(limit: int = 999_966_663_333) -> int:     primes_upper_bound = math.floor(math.sqrt(limit)) + 100     primes = prime_sieve(primes_upper_bound)      matches_sum = 0     prime_index = 0     last_prime = primes[prime_index]      while (last_prime**2) <= limit:         next_prime = primes[prime_index + 1]          lower_bound = last_prime**2         upper_bound = next_prime**2          # Get numbers divisible by lps(current)         current = lower_bound + last_prime         while upper_bound > current <= limit:             matches_sum += current             current += last_prime          # Reset the upper_bound         while (upper_bound - next_prime) > limit:             upper_bound -= next_prime          # Add the numbers divisible by ups(current)         current = upper_bound - next_prime         while current > lower_bound:             matches_sum += current             current -= next_prime          # Remove the numbers divisible by both ups and lps         current = 0         while upper_bound > current <= limit:             if current <= lower_bound:                 # Increment the current number                 current += last_prime * next_prime                 continue              if current > limit:                 break              # Remove twice since it was added by both ups and lps             matches_sum -= current * 2              # Increment the current number             current += last_prime * next_prime          # Setup for next pair         last_prime = next_prime         prime_index += 1      return matches_sum\n1: def heap_sort(unsorted: list[int]) -> list[int]:     n = len(unsorted)     for i in range(n // 2 - 1, -1, -1):         heapify(unsorted, i, n)     for i in range(n - 1, 0, -1):         unsorted[0], unsorted[i] = unsorted[i], unsorted[0]         heapify(unsorted, 0, i)     return unsorted\n2: def is_ip_v4_address_valid(ip: str) -> bool:     octets = ip.split(\".\")     if len(octets) != 4:         return False      for octet in octets:         if not octet.isdigit():             return False          number = int(octet)         if len(str(number)) != len(octet):             return False          if not 0 <= number <= 255:             return False      return True", "output": "2"}
{"task": "search", "input": "search code:\nReturns a shallow copy of the function, including code object,\n\nChoices:\n0: def get_filter_points(     sample_rate: int,     freq_min: int,     freq_high: int,     mel_filter_num: int = 10,     ftt_size: int = 1024, ) -> tuple[np.ndarray, np.ndarray]:     # Convert minimum and maximum frequencies to mel scale     fmin_mel = freq_to_mel(freq_min)     fmax_mel = freq_to_mel(freq_high)      logging.info(f\"MEL min: {fmin_mel}\")     logging.info(f\"MEL max: {fmax_mel}\")      # Generate equally spaced mel frequencies     mels = np.linspace(fmin_mel, fmax_mel, num=mel_filter_num + 2)      # Convert mel frequencies back to Hertz     freqs = mel_to_freq(mels)      # Calculate filter points as integer values     filter_points = np.floor((ftt_size + 1) / sample_rate * freqs).astype(int)      return filter_points, freqs\n1: def copy_function(orig, copy_dict=True):     ret = FunctionType(orig.__code__,                        orig.__globals__,                        name=orig.__name__,                        argdefs=getattr(orig, \"__defaults__\", None),                        closure=getattr(orig, \"__closure__\", None))     if hasattr(orig, \"__kwdefaults__\"):         ret.__kwdefaults__ = orig.__kwdefaults__     if copy_dict:         ret.__dict__.update(orig.__dict__)     return ret\n2: def update(highway_now: list, probability: float, max_speed: int) -> list:      number_of_cells = len(highway_now)     # Beforce calculations, the highway is empty     next_highway = [-1] * number_of_cells      for car_index in range(number_of_cells):         if highway_now[car_index] != -1:             # Add 1 to the current speed of the car and cap the speed             next_highway[car_index] = min(highway_now[car_index] + 1, max_speed)             # Number of empty cell before the next car             dn = get_distance(highway_now, car_index) - 1             # We can't have the car causing an accident             next_highway[car_index] = min(next_highway[car_index], dn)             if random() < probability:                 # Randomly, a driver will slow down                 next_highway[car_index] = max(next_highway[car_index] - 1, 0)     return next_highway", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef knapsack_with_example_solution(w: int, wt: list, val: list):\n    if not (isinstance(wt, (list, tuple)) and isinstance(val, (list, tuple))):\n        raise ValueError(\n            \"Both the weights and values vectors must be either lists or tuples\"\n        )\n\n    num_items = len(wt)\n    if num_items != len(val):\n        msg = (\n            \"The number of weights must be the same as the number of values.\\n\"\n            f\"But got {num_items} weights and {len(val)} values\"\n        )\n        raise ValueError(msg)\n    for i in range(num_items):\n        if not isinstance(wt[i], int):\n            msg = (\n                \"All weights must be integers but got weight of \"\n                f\"type {type(wt[i])} at index {i}\"\n            )\n            raise TypeError(msg)\n\n    optimal_val, dp_table = knapsack(w, wt, val, num_items)\n    example_optional_set: set = set()\n    _construct_solution(dp_table, wt, num_items, w, example_optional_set)\n\n    return optimal_val, example_optional_set", "output": "Solves the integer weights knapsack problem returns one of"}
{"task": "search", "input": "search code:\nFit a polynomial regression model to predict fuel efficiency using seaborn's mpg\n\nChoices:\n0: def main() -> None:     import seaborn as sns      mpg_data = sns.load_dataset(\"mpg\")      poly_reg = PolynomialRegression(degree=2)     poly_reg.fit(mpg_data.weight, mpg_data.mpg)      weight_sorted = np.sort(mpg_data.weight)     predictions = poly_reg.predict(weight_sorted)      plt.scatter(mpg_data.weight, mpg_data.mpg, color=\"gray\", alpha=0.5)     plt.plot(weight_sorted, predictions, color=\"red\", linewidth=3)     plt.title(\"Predicting Fuel Efficiency Using Polynomial Regression\")     plt.xlabel(\"Weight (lbs)\")     plt.ylabel(\"Fuel Efficiency (mpg)\")     plt.show()\n1: def unique(iterable, key=None, reverse=False):     sequenced = sorted(iterable, key=key, reverse=reverse)     return unique_justseen(sequenced, key=key)\n2: def insert_node(head: Node | None, data: int) -> Node:     new_node = Node(data)     # If the linked list is empty, the new_node becomes the head     if head is None:         return new_node      temp_node = head     while temp_node.next_node:         temp_node = temp_node.next_node      temp_node.next_node = new_node     return head", "output": "0"}
{"task": "detection", "input": "classify code:\ndef decimal_to_binary(no_of_variable: int, minterms: list[float]) -> list[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef resonant_frequency(inductance: float, capacitance: float) -> tuple:\n\n    if inductance <= 0:\n        raise ValueError(\"Inductance cannot be 0 or negative\")\n\n    elif capacitance <= 0:\n        raise ValueError(\"Capacitance cannot be 0 or negative\")\n\n    else:\n        return (\n            \"Resonant frequency\",\n            float(1 / (2 * pi * (sqrt(inductance * capacitance)))),\n        )", "output": "This function can calculate the resonant frequency of LC circuit,"}
{"task": "search", "input": "search code:\nReturn the angle toward to point from (minx, miny)\n\nChoices:\n0: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n1: def angle_comparer(point: tuple[int, int], minx: int, miny: int) -> float:     # sort the points accorgind to the angle from the lowest and the most left point     x, y = point     return degrees(atan2(y - miny, x - minx))\n2: def get_digits(num: int) -> str:     return \"\".join(sorted(str(num**3)))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef max_sum_in_array(array: list[int], k: int) -> int:\n    if len(array) < k or k < 0:\n        raise ValueError(\"Invalid Input\")\n    max_sum = current_sum = sum(array[:k])\n    for i in range(len(array) - k):\n        current_sum = current_sum - array[i] + array[i + k]\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "output": "Returns the maximum sum of k consecutive elements"}
{"task": "detection", "input": "classify code:\ndef evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nDistribute the items from *iterable* among *n* smaller iterables.\n\nChoices:\n0: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")      for value in (262144, 1125899906842624, 1267650600228229401496703205376):         for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):             benchmark_a_function(func, value)         print()\n1: def solution(power: int = 1000) -> int:     num = 2**power     string_num = str(num)     list_num = list(string_num)     sum_of_num = 0      for i in list_num:         sum_of_num += int(i)      return sum_of_num\n2: def distribute(n, iterable):     if n < 1:         raise ValueError('n must be at least 1')      children = tee(iterable, n)     return [islice(it, index, None, n) for index, it in enumerate(children)]", "output": "2"}
{"task": "search", "input": "search code:\nReturns the sum of all the multiples of 3 or 5 below n.\n\nChoices:\n0: def solution(numerator: int = 1, digit: int = 1000) -> int:     the_digit = 1     longest_list_length = 0      for divide_by_number in range(numerator, digit + 1):         has_been_divided: list[int] = []         now_divide = numerator         for _ in range(1, digit + 1):             if now_divide in has_been_divided:                 if longest_list_length < len(has_been_divided):                     longest_list_length = len(has_been_divided)                     the_digit = divide_by_number             else:                 has_been_divided.append(now_divide)                 now_divide = now_divide * 10 % divide_by_number      return the_digit\n1: def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:     r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]     return 0.2989 * r + 0.5870 * g + 0.1140 * b\n2: def solution(n: int = 1000) -> int:      result = 0     for i in range(n):         if i % 3 == 0 or i % 5 == 0:             result += i     return result", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef sin(\n    angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10\n) -> float:\n    # Simplify the angle to be between 360 and -360 degrees.\n    angle_in_degrees = angle_in_degrees - ((angle_in_degrees // 360.0) * 360.0)\n\n    # Converting from degrees to radians\n    angle_in_radians = radians(angle_in_degrees)\n\n    result = angle_in_radians\n    a = 3\n    b = -1\n\n    for _ in range(accuracy):\n        result += (b * (angle_in_radians**a)) / factorial(a)\n\n        b = -b  # One positive term and the next will be negative and so on...\n        a += 2  # Increased by 2 for every term.\n\n    return round(result, rounded_values_count)", "output": "Implement sin function."}
{"task": "search", "input": "search code:\nFind the minimum change from the given denominations and value\n\nChoices:\n0: def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:     right = right or len(list_data) - 1     if left > right:         return -1     elif list_data[left] == key:         return left     elif list_data[right] == key:         return right     else:         return search(list_data, key, left + 1, right - 1)\n1: def _extract_labels(f, one_hot=False, num_classes=10):     print(\"Extracting\", f.name)     with gzip.GzipFile(fileobj=f) as bytestream:         magic = _read32(bytestream)         if magic != 2049:             msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"             raise ValueError(msg)         num_items = _read32(bytestream)         buf = bytestream.read(num_items)         labels = np.frombuffer(buf, dtype=np.uint8)         if one_hot:             return _dense_to_one_hot(labels, num_classes)         return labels\n2: def find_minimum_change(denominations: list[int], value: str) -> list[int]:     total_value = int(value)      # Initialize Result     answer = []      # Traverse through all denomination     for denomination in reversed(denominations):         # Find denominations         while int(total_value) >= int(denomination):             total_value -= int(denomination)             answer.append(denomination)  # Append the \"answers\" array      return answer", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef cocktail_shaker_sort(arr: list[int]) -> list[int]:\n    start, end = 0, len(arr) - 1\n\n    while start < end:\n        swapped = False\n\n        # Pass from left to right\n        for i in range(start, end):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n\n        if not swapped:\n            break\n\n        end -= 1  # Decrease the end pointer after each pass\n\n        # Pass from right to left\n        for i in range(end, start, -1):\n            if arr[i] < arr[i - 1]:\n                arr[i], arr[i - 1] = arr[i - 1], arr[i]\n                swapped = True\n\n        if not swapped:\n            break\n\n        start += 1  # Increase the start pointer after each pass\n\n    return arr", "output": "Sorts a list using the Cocktail Shaker Sort algorithm."}
{"task": "search", "input": "search code:\nApply Coulomb's Law on any three given values. These can be force, charge1,\n\nChoices:\n0: def maxpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:     arr = np.array(arr)     if arr.shape[0] != arr.shape[1]:         raise ValueError(\"The input array is not a square matrix\")     i = 0     j = 0     mat_i = 0     mat_j = 0      # compute the shape of the output matrix     maxpool_shape = (arr.shape[0] - size) // stride + 1     # initialize the output matrix with zeros of shape maxpool_shape     updated_arr = np.zeros((maxpool_shape, maxpool_shape))      while i < arr.shape[0]:         if i + size > arr.shape[0]:             # if the end of the matrix is reached, break             break         while j < arr.shape[1]:             # if the end of the matrix is reached, break             if j + size > arr.shape[1]:                 break             # compute the maximum of the pooling matrix             updated_arr[mat_i][mat_j] = np.max(arr[i : i + size, j : j + size])             # shift the pooling matrix by stride of column pixels             j += stride             mat_j += 1          # shift the pooling matrix by stride of row pixels         i += stride         mat_i += 1          # reset the column index to 0         j = 0         mat_j = 0      return updated_arr\n1: def _enforce_args(n: int, prices: list):     if n < 0:         msg = f\"n must be greater than or equal to 0. Got n = {n}\"         raise ValueError(msg)      if n > len(prices):         msg = (             \"Each integral piece of rod must have a corresponding price. \"             f\"Got n = {n} but length of prices = {len(prices)}\"         )         raise ValueError(msg)\n2: def couloumbs_law(     force: float, charge1: float, charge2: float, distance: float ) -> dict[str, float]:      charge_product = abs(charge1 * charge2)      if (force, charge1, charge2, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if distance < 0:         raise ValueError(\"Distance cannot be negative\")     if force == 0:         force = COULOMBS_CONSTANT * charge_product / (distance**2)         return {\"force\": force}     elif charge1 == 0:         charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)         return {\"charge1\": charge1}     elif charge2 == 0:         charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)         return {\"charge2\": charge2}     elif distance == 0:         distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5         return {\"distance\": distance}     raise ValueError(\"Exactly one argument must be 0\")", "output": "2"}
{"task": "search", "input": "search code:\nDecodes the given base16 encoded data into bytes.\n\nChoices:\n0: def base16_decode(data: str) -> bytes:     # Check data validity, following RFC3548     # https://www.ietf.org/rfc/rfc3548.txt     if (len(data) % 2) != 0:         raise ValueError(         )     # Check the character set - the standard base16 alphabet     # is uppercase according to RFC3548 section 6     if not set(data) <= set(\"0123456789ABCDEF\"):         raise ValueError(         )     # For every two hexadecimal digits (= a byte), turn it into an integer.     # Then, string the result together into bytes, and return it.     return bytes(int(data[i] + data[i + 1], 16) for i in range(0, len(data), 2))\n1: def orbital_transfer_work(     mass_central: float, mass_object: float, r_initial: float, r_final: float ) -> str:     gravitational_constant = 6.67430e-11      if r_initial <= 0 or r_final <= 0:         raise ValueError(\"Orbital radii must be greater than zero.\")      work = (gravitational_constant * mass_central * mass_object / 2) * (         1 / r_initial - 1 / r_final     )     return f\"{work:.3e}\"\n2: def double_linear_search(array: list[int], search_item: int) -> int:     # define the start and end index of the given array     start_ind, end_ind = 0, len(array) - 1     while start_ind <= end_ind:         if array[start_ind] == search_item:             return start_ind         elif array[end_ind] == search_item:             return end_ind         else:             start_ind += 1             end_ind -= 1     # returns -1 if search_item is not found in array     return -1", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef _maybe_download(filename, work_directory, source_url):\n    if not gfile.Exists(work_directory):\n        gfile.MakeDirs(work_directory)\n    filepath = os.path.join(work_directory, filename)\n    if not gfile.Exists(filepath):\n        urllib.request.urlretrieve(source_url, filepath)  # noqa: S310\n        with gfile.GFile(filepath) as f:\n            size = f.size()\n        print(\"Successfully downloaded\", filename, size, \"bytes.\")\n    return filepath", "output": "Download the data from source url, unless it's already here."}
{"task": "summary", "input": "summarize code:\ndef find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:\n    if len(nums) == 0:\n        raise ValueError(\"find_max_recursive() arg is an empty sequence\")\n    if (\n        left >= len(nums)\n        or left < -len(nums)\n        or right >= len(nums)\n        or right < -len(nums)\n    ):\n        raise IndexError(\"list index out of range\")\n    if left == right:\n        return nums[left]\n    mid = (left + right) >> 1  # the middle\n    left_max = find_max_recursive(nums, left, mid)  # find max in range[left, mid]\n    right_max = find_max_recursive(\n        nums, mid + 1, right\n    )  # find max in range[mid + 1, right]\n\n    return left_max if left_max >= right_max else right_max", "output": "find max value in list"}
{"task": "summary", "input": "summarize code:\ndef gamma_iterative(num: float) -> float:\n    if num <= 0:\n        raise ValueError(\"math domain error\")\n\n    return quad(integrand, 0, inf, args=(num))[0]", "output": "Calculates the value of Gamma function of num"}
{"task": "search", "input": "search code:\nReturns root node of the merged tree.\n\nChoices:\n0: def merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:     if tree1 is None:         return tree2     if tree2 is None:         return tree1      tree1.value = tree1.value + tree2.value     tree1.left = merge_two_binary_trees(tree1.left, tree2.left)     tree1.right = merge_two_binary_trees(tree1.right, tree2.right)     return tree1\n1: def minimax(     depth: int, node_index: int, is_max: bool, scores: list[int], height: float ) -> int:      if depth < 0:         raise ValueError(\"Depth cannot be less than 0\")     if len(scores) == 0:         raise ValueError(\"Scores cannot be empty\")      # Base case: If the current depth equals the height of the tree,     # return the score of the current node.     if depth == height:         return scores[node_index]      # If it's the maximizer's turn, choose the maximum score     # between the two possible moves.     if is_max:         return max(             minimax(depth + 1, node_index * 2, False, scores, height),             minimax(depth + 1, node_index * 2 + 1, False, scores, height),         )      # If it's the minimizer's turn, choose the minimum score     # between the two possible moves.     return min(         minimax(depth + 1, node_index * 2, True, scores, height),         minimax(depth + 1, node_index * 2 + 1, True, scores, height),     )\n2: def windowed(seq, n, fillvalue=None, step=1):     if n < 0:         raise ValueError('n must be >= 0')     if n == 0:         yield ()         return     if step < 1:         raise ValueError('step must be >= 1')      iterator = iter(seq)      # Generate first window     window = deque(islice(iterator, n), maxlen=n)      # Deal with the first window not being full     if not window:         return     if len(window) < n:         yield tuple(window) + ((fillvalue,) * (n - len(window)))         return     yield tuple(window)      # Create the filler for the next windows. The padding ensures     # we have just enough elements to fill the last window.     padding = (fillvalue,) * (n - 1 if step >= n else step - 1)     filler = map(window.append, chain(iterator, padding))      # Generate the rest of the windows     for _ in islice(filler, step - 1, None, step):         yield tuple(window)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\n    \"\"\"\n    returns the list containing all the possible\n    combinations a string(`target`) can be constructed from\n    the given list of substrings(`word_bank`)\n\n    >>> all_construct(\"hello\", [\"he\", \"l\", \"o\"])\n    [['he', 'l', 'l', 'o']]\n    >>> all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"])\n    [['purp', 'le'], ['p', 'ur', 'p', 'le']]\n    \"\"\"\n\n    word_bank = word_bank or []\n    # create a table\n    table_size: int = len(target) + 1\n\n    table: list[list[list[str]]] = []\n    for _ in range(table_size):\n        table.append([])\n    # seed value\n    table[0] = [[]]  # because empty string has empty combination\n\n    # iterate through the indices\n    for i in range(table_size):\n        # condition\n        if table[i] != []:\n            for word in word_bank:\n                # slice condition\n                if target[i : i + len(word)] == word:\n                    new_combinations: list[list[str]] = [\n                        [word, *way] for way in table[i]\n                    ]\n                    # adds the word to every combination the current position holds\n                    # now,push that combination to the table[i+len(word)]\n                    table[i + len(word)] += new_combinations\n\n    # combinations are in reverse order so reverse for better output\n    for combination in table[len(target)]:\n        combination.reverse()\n\n    return table[len(target)]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nConvert a binary value to its decimal equivalent\n\nChoices:\n0: def make_tree() -> Node | None:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     return tree\n1: def bin_to_decimal(bin_string: str) -> int:     bin_string = str(bin_string).strip()     if not bin_string:         raise ValueError(\"Empty string was passed to the function\")     is_negative = bin_string[0] == \"-\"     if is_negative:         bin_string = bin_string[1:]     if not all(char in \"01\" for char in bin_string):         raise ValueError(\"Non-binary value was passed to the function\")     decimal_number = 0     for char in bin_string:         decimal_number = 2 * decimal_number + int(char)     return -decimal_number if is_negative else decimal_number\n2: def sum_of_divisors(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = 1     temp = 1     while n % 2 == 0:         temp += 1         n = int(n / 2)     if temp > 1:         s *= (2**temp - 1) / (2 - 1)     for i in range(3, int(math.sqrt(n)) + 1, 2):         temp = 1         while n % i == 0:             temp += 1             n = int(n / i)         if temp > 1:             s *= (i**temp - 1) / (i - 1)     return int(s)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef _pgettext(msgctxt, message):\n    # This GNU gettext function was added in Python 3.8, so for older versions we\n    # reimplement it. It works by joining `msgctx` and `message` by '4' byte.\n    try:\n        # Python 3.8+\n        return get_translation().pgettext(msgctxt, message)\n    except AttributeError:\n        # Python 3.7 and older\n        key = msgctxt + \"\\x04\" + message\n        translation = get_translation().gettext(key)\n        return message if translation == key else translation", "output": "Fetches a particular translation."}
{"task": "repair", "input": "fix bug:\ndef largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]", "output": "def largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]"}
{"task": "summary", "input": "summarize code:\ndef traceback(score: list[list[int]], query: str, subject: str) -> str:\n    # make both query and subject uppercase\n    query = query.upper()\n    subject = subject.upper()\n    # find the indices of the maximum value in the score matrix\n    max_value = float(\"-inf\")\n    i_max = j_max = 0\n    for i, row in enumerate(score):\n        for j, value in enumerate(row):\n            if value > max_value:\n                max_value = value\n                i_max, j_max = i, j\n    # Traceback logic to find optimal alignment\n    i = i_max\n    j = j_max\n    align1 = \"\"\n    align2 = \"\"\n    gap = score_function(\"-\", \"-\")\n    # guard against empty query or subject\n    if i == 0 or j == 0:\n        return \"\"\n    while i > 0 and j > 0:\n        if score[i][j] == score[i - 1][j - 1] + score_function(\n            query[i - 1], subject[j - 1]\n        ):\n            # optimal path is a diagonal take both letters\n            align1 = query[i - 1] + align1\n            align2 = subject[j - 1] + align2\n            i -= 1\n            j -= 1\n        elif score[i][j] == score[i - 1][j] + gap:\n            # optimal path is a vertical\n            align1 = query[i - 1] + align1\n            align2 = f\"-{align2}\"\n            i -= 1\n        else:\n            # optimal path is a horizontal\n            align1 = f\"-{align1}\"\n            align2 = subject[j - 1] + align2\n            j -= 1\n\n    return f\"{align1}\\n{align2}\"", "output": "Perform traceback to find the optimal local alignment."}
{"task": "detection", "input": "classify code:\ndef generate_roman_numerals(num: int) -> str:\n    \"\"\"\n    Generates a string of roman numerals for a given integer.\n    e.g.\n    >>> generate_roman_numerals(89)\n    'LXXXIX'\n    >>> generate_roman_numerals(4)\n    'IV'\n    \"\"\"\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals", "output": "CORRECT"}
{"task": "search", "input": "search code:\nreturns the list containing all the possible\n\nChoices:\n0: def all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:      word_bank = word_bank or []     # create a table     table_size: int = len(target) + 1      table: list[list[list[str]]] = []     for _ in range(table_size):         table.append([])     # seed value     table[0] = [[]]  # because empty string has empty combination      # iterate through the indices     for i in range(table_size):         # condition         if table[i] != []:             for word in word_bank:                 # slice condition                 if target[i : i + len(word)] == word:                     new_combinations: list[list[str]] = [                         [word, *way] for way in table[i]                     ]                     # adds the word to every combination the current position holds                     # now,push that combination to the table[i+len(word)]                     table[i + len(word)] += new_combinations      # combinations are in reverse order so reverse for better output     for combination in table[len(target)]:         combination.reverse()      return table[len(target)]\n1: def add_key_to_lexicon(     lexicon: dict[str, str], curr_string: str, index: int, last_match_id: str ) -> None:     lexicon.pop(curr_string)     lexicon[curr_string + \"0\"] = last_match_id      if math.log2(index).is_integer():         for curr_key, value in lexicon.items():             lexicon[curr_key] = f\"0{value}\"      lexicon[curr_string + \"1\"] = bin(index)[2:]\n2: def solution(limit: int = 50000000) -> int:     ret = set()     prime_square_limit = int((limit - 24) ** (1 / 2))      primes = set(range(3, prime_square_limit + 1, 2))     primes.add(2)     for p in range(3, prime_square_limit + 1, 2):         if p not in primes:             continue         primes.difference_update(set(range(p * p, prime_square_limit + 1, p)))      for prime1 in primes:         square = prime1 * prime1         for prime2 in primes:             cube = prime2 * prime2 * prime2             if square + cube >= limit - 16:                 break             for prime3 in primes:                 tetr = prime3 * prime3 * prime3 * prime3                 total = square + cube + tetr                 if total >= limit:                     break                 ret.add(total)      return len(ret)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n\n    Args:\n        * `elements`: The list of elements from which combinations will be generated.\n        * `n`: The number of elements in each combination.\n\n    Returns:\n        A list of tuples, each representing a combination of `n` elements.\n\n    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n    >>> subset_combinations(elements=[1, 2, 3], n=1)\n    [(1,), (2,), (3,)]\n    >>> subset_combinations(elements=[1, 2, 3], n=3)\n    [(1, 2, 3)]\n    >>> subset_combinations(elements=[42], n=1)\n    [(42,)]\n    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n    [(6, 7, 8, 9)]\n    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n    [()]\n    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n    >>> subset_combinations(elements=['single'], n=0)\n    [()]\n    >>> subset_combinations(elements=[], n=9)\n    []\n    >>> from itertools import combinations\n    >>> all(subset_combinations(items, n) == list(combinations(items, n))\n    ...     for items, n in (\n    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n    True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nRecursively calculates the product sum of an array.\n\nChoices:\n0: def backtrack(     candidates: list, path: list, answer: list, target: int, previous_index: int ) -> None:     if target == 0:         answer.append(path.copy())     else:         for index in range(previous_index, len(candidates)):             if target >= candidates[index]:                 path.append(candidates[index])                 backtrack(candidates, path, answer, target - candidates[index], index)                 path.pop(len(path) - 1)\n1: def product_sum(arr: list[int | list], depth: int) -> int:     total_sum = 0     for ele in arr:         total_sum += product_sum(ele, depth + 1) if isinstance(ele, list) else ele     return total_sum * depth\n2: def bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:     if length > 1:         middle = int(length / 2)         for i in range(low, low + middle):             comp_and_swap(array, i, i + middle, direction)         bitonic_merge(array, low, middle, direction)         bitonic_merge(array, low + middle, middle, direction)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(num: int = 100) -> int:\n    fact = 1\n    result = 0\n    for i in range(1, num + 1):\n        fact *= i\n\n    for j in str(fact):\n        result += int(j)\n\n    return result", "output": "Returns the sum of the digits in the factorial of num"}
{"task": "summary", "input": "summarize code:\ndef validate_matrix_content(matrix: list[str], size: int) -> None:\n    print(matrix)\n    if len(matrix) != size:\n        raise ValueError(\"The matrix dont match with size.\")\n    for row in matrix:\n        if len(row) != size:\n            msg = f\"Each row in the matrix must have exactly {size} characters.\"\n            raise ValueError(msg)\n        if not all(char.isalnum() for char in row):\n            raise ValueError(\"Matrix rows can only contain letters and numbers.\")", "output": "Validates that the number of elements in the matrix matches the given size."}
{"task": "summary", "input": "summarize code:\ndef rstrip(iterable, pred):\n    cache = []\n    cache_append = cache.append\n    cache_clear = cache.clear\n    for x in iterable:\n        if pred(x):\n            cache_append(x)\n        else:\n            yield from cache\n            cache_clear()\n            yield x", "output": "Yield the items from *iterable*, but strip any from the end"}
{"task": "repair", "input": "fix bug:\ndef create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]", "output": "def create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]"}
{"task": "search", "input": "search code:\nCalculates the first n (1-indexed) Fibonacci numbers using iteration with yield\n\nChoices:\n0: def fib_iterative_yield(n: int) -> Iterator[int]:     if n < 0:         raise ValueError(\"n is negative\")     a, b = 0, 1     yield a     for _ in range(n):         yield b         a, b = b, a + b\n1: def build_sparse_table(number_list: list[int]) -> list[list[int]]:     if not number_list:         raise ValueError(\"empty number list not allowed\")      length = len(number_list)     # Initialise sparse_table -- sparse_table[j][i] represents the minimum value of the     # subset of length (2 ** j) of number_list, starting from index i.      # smallest power of 2 subset length that fully covers number_list     row = int(log2(length)) + 1     sparse_table = [[0 for i in range(length)] for j in range(row)]      # minimum of subset of length 1 is that value itself     for i, value in enumerate(number_list):         sparse_table[0][i] = value     j = 1      # compute the minimum value for all intervals with size (2 ** j)     while (1 << j) <= length:         i = 0         # while subset starting from i still have at least (2 ** j) elements         while (i + (1 << j) - 1) < length:             # split range [i, i + 2 ** j] and find minimum of 2 halves             sparse_table[j][i] = min(                 sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]             )             i += 1         j += 1     return sparse_table\n2: def num_digits_fast(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      return 1 if n == 0 else math.floor(math.log(abs(n), 10) + 1)", "output": "0"}
{"task": "search", "input": "search code:\nheap helper function get the position of the right child of the current node\n\nChoices:\n0: def get_child_right_position(position: int) -> int:     return (2 * position) + 2\n1: def local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:     center = image[x_coordinate][y_coordinate]     powers = [1, 2, 4, 8, 16, 32, 64, 128]      # skip get_neighbors_pixel if center is null     if center is None:         return 0      # Starting from the top right, assigning value to pixels clockwise     binary_values = [         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),         get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),     ]      # Converting the binary value to decimal.     return sum(         binary_value * power for binary_value, power in zip(binary_values, powers)     )\n2: def _maybe_download(filename, work_directory, source_url):     if not gfile.Exists(work_directory):         gfile.MakeDirs(work_directory)     filepath = os.path.join(work_directory, filename)     if not gfile.Exists(filepath):         urllib.request.urlretrieve(source_url, filepath)  # noqa: S310         with gfile.GFile(filepath) as f:             size = f.size()         print(\"Successfully downloaded\", filename, size, \"bytes.\")     return filepath", "output": "0"}
{"task": "search", "input": "search code:\n:param number: nth number to calculate in the sequence\n\nChoices:\n0: def are_collinear(a: Point3d, b: Point3d, c: Point3d, accuracy: int = 10) -> bool:     ab = create_vector(a, b)     ac = create_vector(a, c)     return is_zero_vector(get_3d_vectors_cross(ab, ac), accuracy)\n1: def interpolation_search_by_recursion(     sorted_collection: list[int], item: int, left: int = 0, right: int | None = None ) -> int | None:     if right is None:         right = len(sorted_collection) - 1     # avoid divided by 0 during interpolation     if sorted_collection[left] == sorted_collection[right]:         if sorted_collection[left] == item:             return left         return None      point = left + ((item - sorted_collection[left]) * (right - left)) // (         sorted_collection[right] - sorted_collection[left]     )      # out of range check     if point < 0 or point >= len(sorted_collection):         return None      if sorted_collection[point] == item:         return point     if point < left:         return interpolation_search_by_recursion(sorted_collection, item, point, left)     if point > right:         return interpolation_search_by_recursion(sorted_collection, item, right, left)     if sorted_collection[point] > item:         return interpolation_search_by_recursion(             sorted_collection, item, left, point - 1         )     return interpolation_search_by_recursion(sorted_collection, item, point + 1, right)\n2: def sylvester(number: int) -> int:     assert isinstance(number, int), f\"The input value of [n={number}] is not an integer\"      if number == 1:         return 2     elif number < 1:         msg = f\"The input value of [n={number}] has to be > 0\"         raise ValueError(msg)     else:         num = sylvester(number - 1)         lower = num - 1         upper = num         return lower * upper + 1", "output": "2"}
{"task": "search", "input": "search code:\nReturns True if number is bouncy, False otherwise\n\nChoices:\n0: def sum_reverse(n: int) -> int:     return int(n) + int(str(n)[::-1])\n1: def can_string_be_rearranged_as_palindrome_counter(     input_str: str = \"\", ) -> bool:     return sum(c % 2 for c in Counter(input_str.replace(\" \", \"\").lower()).values()) < 2\n2: def check_bouncy(n: int) -> bool:     if not isinstance(n, int):         raise ValueError(\"check_bouncy() accepts only integer arguments\")     str_n = str(n)     sorted_str_n = \"\".join(sorted(str_n))     return str_n not in {sorted_str_n, sorted_str_n[::-1]}", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef swap_odd_even_bits(num: int) -> int:\n    # Get all even bits - 0xAAAAAAAA is a 32-bit number with all even bits set to 1\n    even_bits = num & 0xAAAAAAAA\n\n    # Get all odd bits - 0x55555555 is a 32-bit number with all odd bits set to 1\n    odd_bits = num & 0x55555555\n\n    # Right shift even bits and left shift odd bits and swap them\n    return even_bits >> 1 | odd_bits << 1", "output": "1. We use bitwise AND operations to separate the even bits (0, 2, 4, 6, etc.) and"}
{"task": "detection", "input": "classify code:\ndef reverse_letters(input_str: str) -> str:\n    \"\"\"\n    Reverses letters in a given string without adjusting the position of the words\n    >>> reverse_letters('The cat in the hat')\n    'ehT tac ni eht tah'\n    >>> reverse_letters('The quick brown fox jumped over the lazy dog.')\n    'ehT kciuq nworb xof depmuj revo eht yzal .god'\n    >>> reverse_letters('Is this true?')\n    'sI siht ?eurt'\n    >>> reverse_letters(\"I   love       Python\")\n    'I evol nohtyP'\n    \"\"\"\n    return \" \".join([word[::-1] for word in input_str.split()])", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef jaro_winkler(str1: str, str2: str) -> float:\n    \"\"\"\n    Jaro-Winkler distance is a string metric measuring an edit distance between two\n    sequences.\n    Output value is between 0.0 and 1.0.\n\n    >>> jaro_winkler(\"martha\", \"marhta\")\n    0.9611111111111111\n    >>> jaro_winkler(\"CRATE\", \"TRACE\")\n    0.7333333333333334\n    >>> jaro_winkler(\"test\", \"dbdbdbdb\")\n    0.0\n    >>> jaro_winkler(\"test\", \"test\")\n    1.0\n    >>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n    0.6363636363636364\n    >>> jaro_winkler(\"test\", \"\")\n    0.0\n    >>> jaro_winkler(\"hello\", \"world\")\n    0.4666666666666666\n    >>> jaro_winkler(\"hell**o\", \"*world\")\n    0.4365079365079365\n    \"\"\"\n\n    def get_matched_characters(_str1: str, _str2: str) -> str:\n        matched = []\n        limit = min(len(_str1), len(_str2)) // 2\n        for i, char in enumerate(_str1):\n            left = int(max(0, i - limit))\n            right = int(min(i + limit + 1, len(_str2)))\n            if char in _str2[left:right]:\n                matched.append(char)\n                _str2 = (\n                    f\"{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}\"\n                )\n\n        return \"\".join(matched)\n\n    # matching characters\n    matching_1 = get_matched_characters(str1, str2)\n    matching_2 = get_matched_characters(str2, str1)\n    match_count = len(matching_1)\n\n    # transposition\n    transpositions = (\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\n    )\n\n    if not match_count:\n        jaro = 0.0\n    else:\n        jaro = (\n            1\n            / 3\n            * (\n                match_count / len(str1)\n                + match_count / len(str2)\n                + (match_count - transpositions) / match_count\n            )\n        )\n\n    # common prefix up to 4 characters\n    prefix_len = 0\n    for c1, c2 in zip(str1[:4], str2[:4]):\n        if c1 == c2:\n            prefix_len += 1\n        else:\n            break\n\n    return jaro + 0.1 * prefix_len * (1 - jaro)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef calculate_probabilities(instance_count: int, total_count: int) -> float:\n    \"\"\"\n    Calculate the probability that a given instance will belong to which class\n    :param instance_count: number of instances in class\n    :param total_count: the number of all instances\n    :return: value of probability for considered class\n\n    >>> calculate_probabilities(20, 60)\n    0.3333333333333333\n    >>> calculate_probabilities(30, 100)\n    0.3\n    \"\"\"\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef some(seq):\n    for e in seq:\n        if e:\n            return e\n    return False", "output": "Return some element of seq that is true."}
{"task": "search", "input": "search code:\nReturns the sum of the digits in the factorial of num\n\nChoices:\n0: def solution(num: int = 100) -> int:     return sum(map(int, str(factorial(num))))\n1: def normalization(data: list, ndigits: int = 3) -> list:     # variables for calculation     x_min = min(data)     x_max = max(data)     # normalize data     return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]\n2: def get_support(cluster):     return [i * 100 / len(cluster) for i in cluster]", "output": "0"}
{"task": "detection", "input": "classify code:\ndef alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nLoops through each pair of adjacent vectors. Each line between two adjacent\n\nChoices:\n0: def euler_phi(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = n     for x in set(prime_factors(n)):         s *= (x - 1) / x     return int(s)\n1: def suppress_non_maximum(image_shape, gradient_direction, sobel_grad):     destination = np.zeros(image_shape)      for row in range(1, image_shape[0] - 1):         for col in range(1, image_shape[1] - 1):             direction = gradient_direction[row, col]              if (                 0 <= direction < PI / 8                 or 15 * PI / 8 <= direction <= 2 * PI                 or 7 * PI / 8 <= direction <= 9 * PI / 8             ):                 w = sobel_grad[row, col - 1]                 e = sobel_grad[row, col + 1]                 if sobel_grad[row, col] >= w and sobel_grad[row, col] >= e:                     destination[row, col] = sobel_grad[row, col]              elif (                 PI / 8 <= direction < 3 * PI / 8                 or 9 * PI / 8 <= direction < 11 * PI / 8             ):                 sw = sobel_grad[row + 1, col - 1]                 ne = sobel_grad[row - 1, col + 1]                 if sobel_grad[row, col] >= sw and sobel_grad[row, col] >= ne:                     destination[row, col] = sobel_grad[row, col]              elif (                 3 * PI / 8 <= direction < 5 * PI / 8                 or 11 * PI / 8 <= direction < 13 * PI / 8             ):                 n = sobel_grad[row - 1, col]                 s = sobel_grad[row + 1, col]                 if sobel_grad[row, col] >= n and sobel_grad[row, col] >= s:                     destination[row, col] = sobel_grad[row, col]              elif (                 5 * PI / 8 <= direction < 7 * PI / 8                 or 13 * PI / 8 <= direction < 15 * PI / 8             ):                 nw = sobel_grad[row - 1, col - 1]                 se = sobel_grad[row + 1, col + 1]                 if sobel_grad[row, col] >= nw and sobel_grad[row, col] >= se:                     destination[row, col] = sobel_grad[row, col]      return destination\n2: def iteration_step(vectors: list[np.ndarray]) -> list[np.ndarray]:     new_vectors = []     for i, start_vector in enumerate(vectors[:-1]):         end_vector = vectors[i + 1]         new_vectors.append(start_vector)         difference_vector = end_vector - start_vector         new_vectors.append(start_vector + difference_vector / 3)         new_vectors.append(             start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)         )         new_vectors.append(start_vector + difference_vector * 2 / 3)     new_vectors.append(vectors[-1])     return new_vectors", "output": "2"}
{"task": "search", "input": "search code:\nInput Parameters\n\nChoices:\n0: def running_key_encrypt(key: str, plaintext: str) -> str:     plaintext = plaintext.replace(\" \", \"\").upper()     key = key.replace(\" \", \"\").upper()     key_length = len(key)     ciphertext = []     ord_a = ord(\"A\")      for i, char in enumerate(plaintext):         p = ord(char) - ord_a         k = ord(key[i % key_length]) - ord_a         c = (p + k) % 26         ciphertext.append(chr(c + ord_a))      return \"\".join(ciphertext)\n1: def length_conversion(value: float, from_type: str, to_type: str) -> float:     new_from = from_type.lower().rstrip(\"s\")     new_from = TYPE_CONVERSION.get(new_from, new_from)     new_to = to_type.lower().rstrip(\"s\")     new_to = TYPE_CONVERSION.get(new_to, new_to)     if new_from not in METRIC_CONVERSION:         msg = (             f\"Invalid 'from_type' value: {from_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     if new_to not in METRIC_CONVERSION:         msg = (             f\"Invalid 'to_type' value: {to_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     return (         value         * METRIC_CONVERSION[new_from].from_factor         * METRIC_CONVERSION[new_to].to_factor     )\n2: def center_of_mass(particles: list[Particle]) -> Coord3D:     if not particles:         raise ValueError(\"No particles provided\")      if any(particle.mass <= 0 for particle in particles):         raise ValueError(\"Mass of all particles must be greater than 0\")      total_mass = sum(particle.mass for particle in particles)      center_of_mass_x = round(         sum(particle.x * particle.mass for particle in particles) / total_mass, 2     )     center_of_mass_y = round(         sum(particle.y * particle.mass for particle in particles) / total_mass, 2     )     center_of_mass_z = round(         sum(particle.z * particle.mass for particle in particles) / total_mass, 2     )     return Coord3D(center_of_mass_x, center_of_mass_y, center_of_mass_z)", "output": "2"}
{"task": "search", "input": "search code:\nCreates a directory and any parent directories that may need to\n\nChoices:\n0: def mkdir_p(path):     try:         os.makedirs(path)     except OSError as exc:         if exc.errno == errno.EEXIST and os.path.isdir(path):             return         raise     return\n1: def solution(pence: int = 200) -> int:     coins = [1, 2, 5, 10, 20, 50, 100, 200]     number_of_ways = [0] * (pence + 1)     number_of_ways[0] = 1  # base case: 1 way to make 0 pence      for coin in coins:         for i in range(coin, pence + 1, 1):             number_of_ways[i] += number_of_ways[i - coin]     return number_of_ways[pence]\n2: def compress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         add_key_to_lexicon(lexicon, curr_string, index, last_match_id)         index += 1         curr_string = \"\"      while curr_string != \"\" and curr_string not in lexicon:         curr_string += \"0\"      if curr_string != \"\":         last_match_id = lexicon[curr_string]         result += last_match_id      return result", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef naturalsize(value, binary=False, gnu=False, format=\"%.1f\"):\n    if gnu:\n        suffix = suffixes[\"gnu\"]\n    elif binary:\n        suffix = suffixes[\"binary\"]\n    else:\n        suffix = suffixes[\"decimal\"]\n\n    base = 1024 if (gnu or binary) else 1000\n    bytes = float(value)\n    abs_bytes = abs(bytes)\n\n    if abs_bytes == 1 and not gnu:\n        return \"%d Byte\" % bytes\n    elif abs_bytes < base and not gnu:\n        return \"%d Bytes\" % bytes\n    elif abs_bytes < base and gnu:\n        return \"%dB\" % bytes\n\n    for i, s in enumerate(suffix):\n        unit = base ** (i + 2)\n        if abs_bytes < unit and not gnu:\n            return (format + \" %s\") % ((base * bytes / unit), s)\n        elif abs_bytes < unit and gnu:\n            return (format + \"%s\") % ((base * bytes / unit), s)\n    if gnu:\n        return (format + \"%s\") % ((base * bytes / unit), s)\n    return (format + \" %s\") % ((base * bytes / unit), s)", "output": "Format a number of bytes like a human readable filesize (e.g. 10 kB)."}
{"task": "search", "input": "search code:\nPercent-encode a single segment of a URL path.\n\nChoices:\n0: def solve(nums: list[int], goal: int, depth: int) -> bool:     if len(nums) > depth:         return False     for el in nums:         if el + nums[-1] == goal:             return True         nums.append(el + nums[-1])         if solve(nums=nums, goal=goal, depth=depth):             return True         del nums[-1]     return False\n1: def sum_of_digit_factorial(n: int) -> int:     return sum(DIGIT_FACTORIAL[d] for d in str(n))\n2: def quote_path_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])     return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t                      for t in text])", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef generate_clause() -> Clause:\n    literals = []\n    no_of_literals = random.randint(1, 5)\n    base_var = \"A\"\n    i = 0\n    while i < no_of_literals:\n        var_no = random.randint(1, 5)\n        var_name = base_var + str(var_no)\n        var_complement = random.randint(0, 1)\n        if var_complement == 1:\n            var_name += \"'\"\n        if var_name in literals:\n            i -= 1\n        else:\n            literals.append(var_name)\n        i += 1\n    return Clause(literals)", "output": "| Randomly generate a clause."}
{"task": "repair", "input": "fix bug:\ndef is_complete(board: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)", "output": "def is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)"}
{"task": "detection", "input": "classify code:\ndef moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to pressure.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_pressure(0.82, 3, 300)\n      90\n      >>> moles_to_pressure(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (volume)))", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCalculate NOT of the input values\n\nChoices:\n0: def topological_sort(start: str, visited: list[str], sort: list[str]) -> list[str]:     current = start     # add current to visited     visited.append(current)     neighbors = edges[current]     for neighbor in neighbors:         # if neighbor not in visited, visit         if neighbor not in visited:             sort = topological_sort(neighbor, visited, sort)     # if all neighbors visited add current to sort     sort.append(current)     # if all vertices haven't been visited select a new one to visit     if len(visited) != len(vertices):         for vertice in vertices:             if vertice not in visited:                 sort = topological_sort(vertice, visited, sort)     # return sort     return sort\n1: def not_gate(input_1: int) -> int:      return 1 if input_1 == 0 else 0\n2: def iter_splitlines(text):     prev_end, len_text = 0, len(text)     # print('last: %r' % last_idx)     # start, end = None, None     for match in _line_ending_re.finditer(text):         start, end = match.start(1), match.end(1)         # print(start, end)         if prev_end <= start:             yield text[prev_end:start]         if end == len_text:             yield ''         prev_end = end     tail = text[prev_end:]     if tail:         yield tail     return", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef shuffled(seq):\n    seq = list(seq)\n    random.shuffle(seq)\n    return seq", "output": "Return a randomly shuffled copy of the input sequence."}
{"task": "search", "input": "search code:\nThe missing counterpart to the built-in :func:`textwrap.dedent`.\n\nChoices:\n0: def process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:      game_matrix = [list(row) for row in matrix]     total_score = 0      for move in moves:         pos_x, pos_y = move         game_matrix, score = play(game_matrix, pos_x, pos_y, size)         total_score += score      return total_score\n1: def generate_pascal_triangle(num_rows: int) -> list[list[int]]:      if not isinstance(num_rows, int):         raise TypeError(\"The input value of 'num_rows' should be 'int'\")      if num_rows == 0:         return []     elif num_rows < 0:         raise ValueError(             \"The input value of 'num_rows' should be greater than or equal to 0\"         )      triangle: list[list[int]] = []     for current_row_idx in range(num_rows):         current_row = populate_current_row(triangle, current_row_idx)         triangle.append(current_row)     return triangle\n2: def indent(text, margin, newline='\\n', key=bool):     indented_lines = [(margin + line if key(line) else line)                       for line in iter_splitlines(text)]     return newline.join(indented_lines)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same row, column,\n    # left upper diagonal, and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, n)))\n        and all(\n            board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, -1, -1))\n        )\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, n)))\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, -1, -1)))\n    )", "output": "def is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same upper column,\n    # left upper diagonal and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))\n        )\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))\n        )\n    )"}
{"task": "summary", "input": "summarize code:\ndef consume(iterator, n=None):\n    # Use functions that consume iterators at C speed.\n    if n is None:\n        # feed the entire iterator into a zero-length deque\n        deque(iterator, maxlen=0)\n    else:\n        # advance to the empty slice starting at position n\n        next(islice(iterator, n, n), None)", "output": "Advance *iterable* by *n* steps. If *n* is ``None``, consume it"}
{"task": "search", "input": "search code:\nCall Extended Euclidean Algorithm.\n\nChoices:\n0: def _extract_labels(f, one_hot=False, num_classes=10):     print(\"Extracting\", f.name)     with gzip.GzipFile(fileobj=f) as bytestream:         magic = _read32(bytestream)         if magic != 2049:             msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"             raise ValueError(msg)         num_items = _read32(bytestream)         buf = bytestream.read(num_items)         labels = np.frombuffer(buf, dtype=np.uint8)         if one_hot:             return _dense_to_one_hot(labels, num_classes)         return labels\n1: def main():     if len(sys.argv) < 3:         print(\"2 integer arguments required\")         return 1     a = int(sys.argv[1])     b = int(sys.argv[2])     print(extended_euclidean_algorithm(a, b))     return 0\n2: def intersection(function: Callable[[float], float], x0: float, x1: float) -> float:     x_n: float = x0     x_n1: float = x1     while True:         if x_n == x_n1 or function(x_n1) == function(x_n):             raise ZeroDivisionError(\"float division by zero, could not find root\")         x_n2: float = x_n1 - (             function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))         )         if abs(x_n2 - x_n1) < 10**-5:             return x_n2         x_n = x_n1         x_n1 = x_n2", "output": "1"}
{"task": "search", "input": "search code:\nPure python implementation of the iterative Heap's algorithm,\n\nChoices:\n0: def prepare_grid(window_size: float, nb_pixels: int) -> np.ndarray:     x = np.linspace(-window_size, window_size, nb_pixels)     x = x.reshape((nb_pixels, 1))     y = np.linspace(-window_size, window_size, nb_pixels)     y = y.reshape((1, nb_pixels))     return x + 1.0j * y\n1: def heaps(arr: list) -> list:      if len(arr) <= 1:         return [tuple(arr)]      res = []      def generate(n: int, arr: list):         c = [0] * n         res.append(tuple(arr))          i = 0         while i < n:             if c[i] < i:                 if i % 2 == 0:                     arr[0], arr[i] = arr[i], arr[0]                 else:                     arr[c[i]], arr[i] = arr[i], arr[c[i]]                 res.append(tuple(arr))                 c[i] += 1                 i = 0             else:                 c[i] = 0                 i += 1      generate(len(arr), arr)     return res\n2: def generate_parameters(formula: Formula) -> tuple[list[Clause], list[str]]:     clauses = formula.clauses     symbols_set = []     for clause in formula.clauses:         for literal in clause.literals:             symbol = literal[:2]             if symbol not in symbols_set:                 symbols_set.append(symbol)     return clauses, symbols_set", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer", "output": "def find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer"}
{"task": "search", "input": "search code:\nConvert a decimal representation of an IP address to its IPv4 format.\n\nChoices:\n0: def decimal_to_ipv4(decimal_ipv4: int) -> str:      if not (0 <= decimal_ipv4 <= 4294967295):         raise ValueError(\"Invalid decimal IPv4 address\")      ip_parts = []     for _ in range(4):         ip_parts.append(str(decimal_ipv4 & 255))         decimal_ipv4 >>= 8      return \".\".join(reversed(ip_parts))\n1: def check_partition_perfect(positive_integer: int) -> bool:      exponent = math.log2(math.sqrt(4 * positive_integer + 1) / 2 + 1 / 2)      return exponent == int(exponent)\n2: def to_title_case(word: str) -> str:      if \"a\" <= word[0] <= \"z\":         word = chr(ord(word[0]) - 32) + word[1:]      for i in range(1, len(word)):         if \"A\" <= word[i] <= \"Z\":             word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]      return word", "output": "0"}
{"task": "search", "input": "search code:\nReturns the list of truncated primes\n\nChoices:\n0: def compute_truncated_primes(count: int = 11) -> list[int]:     list_truncated_primes: list[int] = []     num = 13     while len(list_truncated_primes) != count:         if validate(num):             list_nums = list_truncated_nums(num)             if all(is_prime(i) for i in list_nums):                 list_truncated_primes.append(num)         num += 2     return list_truncated_primes\n1: def smallest_range(nums: list[list[int]]) -> list[int]:      min_heap: list[tuple[int, int, int]] = []     current_max = -maxsize - 1      for i, items in enumerate(nums):         heappush(min_heap, (items[0], i, 0))         current_max = max(current_max, items[0])      # Initialize smallest_range with large integer values     smallest_range = [-maxsize - 1, maxsize]      while min_heap:         current_min, list_index, element_index = heappop(min_heap)          if current_max - current_min < smallest_range[1] - smallest_range[0]:             smallest_range = [current_min, current_max]          if element_index == len(nums[list_index]) - 1:             break          next_element = nums[list_index][element_index + 1]         heappush(min_heap, (next_element, list_index, element_index + 1))         current_max = max(current_max, next_element)      return smallest_range\n2: def get_profile(**kwargs):     scrub = kwargs.pop('scrub', False)     if kwargs:         raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')     ret = {}     try:         ret['username'] = getpass.getuser()     except Exception:         ret['username'] = ''     ret['guid'] = str(INSTANCE_ID)     ret['hostname'] = socket.gethostname()     ret['hostfqdn'] = socket.getfqdn()     uname = platform.uname()     ret['uname'] = {'system': uname[0],                     'node': uname[1],                     'release': uname[2],  # linux: distro name                     'version': uname[3],  # linux: kernel version                     'machine': uname[4],                     'processor': uname[5]}     try:         # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10         linux_dist = platform.linux_distribution()       except Exception:         linux_dist = ('', '', '')     ret['linux_dist_name'] = linux_dist[0]     ret['linux_dist_version'] = linux_dist[1]     ret['cpu_count'] = CPU_COUNT      ret['fs_encoding'] = sys.getfilesystemencoding()     ret['ulimit_soft'] = RLIMIT_FDS_SOFT     ret['ulimit_hard'] = RLIMIT_FDS_HARD     ret['cwd'] = os.getcwd()     ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')      ret['python'] = get_python_info()     ret.update(START_TIME_INFO)     ret['_eco_version'] = ECO_VERSION      if scrub:         # mask identifiable information         ret['cwd'] = '-'         ret['hostname'] = '-'         ret['hostfqdn'] = '-'         ret['python']['bin'] = '-'         ret['python']['argv'] = '-'         ret['uname']['node'] = '-'         ret['username'] = '-'      return ret", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef search_scraper(anime_name: str) -> list:\n\n    # concat the name to form the search url.\n    search_url = f\"{BASE_URL}/search?keyword={anime_name}\"\n\n    response = httpx.get(\n        search_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10\n    )  # request the url.\n\n    # Is the response ok?\n    response.raise_for_status()\n\n    # parse with soup.\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    # get list of anime\n    anime_ul = soup.find(\"ul\", {\"class\": \"items\"})\n    if anime_ul is None or isinstance(anime_ul, NavigableString):\n        msg = f\"Could not find and anime with name {anime_name}\"\n        raise ValueError(msg)\n    anime_li = anime_ul.children\n\n    # for each anime, insert to list. the name and url.\n    anime_list = []\n    for anime in anime_li:\n        if isinstance(anime, Tag):\n            anime_url = anime.find(\"a\")\n            if anime_url is None or isinstance(anime_url, NavigableString):\n                continue\n            anime_title = anime.find(\"a\")\n            if anime_title is None or isinstance(anime_title, NavigableString):\n                continue\n\n            anime_list.append({\"title\": anime_title[\"title\"], \"url\": anime_url[\"href\"]})\n\n    return anime_list", "output": "[summary]"}
{"task": "detection", "input": "classify code:\ndef is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef recur_fibo(n):\n    if n <= 1:\n        return n\n    else:\n        (recur_fibo(n - 1) + recur_fibo(n - 2))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns support\n\nChoices:\n0: def always_iterable(obj, base_type=(str, bytes)):     if obj is None:         return iter(())      if (base_type is not None) and isinstance(obj, base_type):         return iter((obj,))      try:         return iter(obj)     except TypeError:         return iter((obj,))\n1: def get_support(cluster):     return [i * 100 / len(cluster) for i in cluster]\n2: def bin_to_hexadecimal(binary_str: str) -> str:     # Sanitising parameter     binary_str = str(binary_str).strip()      # Exceptions     if not binary_str:         raise ValueError(\"Empty string was passed to the function\")     is_negative = binary_str[0] == \"-\"     binary_str = binary_str[1:] if is_negative else binary_str     if not all(char in \"01\" for char in binary_str):         raise ValueError(\"Non-binary value was passed to the function\")      binary_str = (         \"0\" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str     )      hexadecimal = []     for x in range(0, len(binary_str), 4):         hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])     hexadecimal_str = \"0x\" + \"\".join(hexadecimal)      return \"-\" + hexadecimal_str if is_negative else hexadecimal_str", "output": "1"}
{"task": "search", "input": "search code:\nAutomatic generate random 32 characters.\n\nChoices:\n0: def num_digits(n: int) -> int:      if not isinstance(n, int):         raise TypeError(\"Input must be an integer\")      digits = 0     n = abs(n)     while True:         n = n // 10         digits += 1         if n == 0:             break     return digits\n1: def random_chars(number_char: int = 32) -> str:     assert number_char > 1, \"The number of character should greater than 1\"     letter_code = ascii_lowercase + digits     return \"\".join(random.choice(letter_code) for _ in range(number_char))\n2: def solution(n: int = 200) -> int:     return two_pound(n)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef side_effect(func, iterable, chunk_size=None, before=None, after=None):\n    try:\n        if before is not None:\n            before()\n\n        if chunk_size is None:\n            for item in iterable:\n                func(item)\n                yield item\n        else:\n            for chunk in chunked(iterable, chunk_size):\n                func(chunk)\n                yield from chunk\n    finally:\n        if after is not None:\n            after()", "output": "Invoke *func* on each item in *iterable* (or on each *chunk_size* group"}
{"task": "repair", "input": "fix bug:\ndef alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)", "output": "def alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)"}
{"task": "detection", "input": "classify code:\ndef peak(lst: list[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef remove_digit(num: int) -> int:\n\n    if not isinstance(num, int):\n        raise TypeError(\"only integers accepted as input\")\n    else:\n        num_str = str(abs(num))\n        num_transpositions = [list(num_str) for char in range(len(num_str))]\n        for index in range(len(num_str)):\n            num_transpositions[index].pop(index)\n        return max(\n            int(\"\".join(list(transposition))) for transposition in num_transpositions\n        )", "output": "returns the biggest possible result"}
{"task": "summary", "input": "summarize code:\ndef longest_prefix(input_str: str) -> int:\n\n    # just returning maximum value of the array gives us answer\n    return max(prefix_function(input_str))", "output": "Prefix-function use case"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 10) -> str:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Invalid input\")\n    modulus = 10**n\n    number = 28433 * (pow(2, 7830457, modulus)) + 1\n    return str(number % modulus)", "output": "Returns the last n digits of NUMBER."}
{"task": "summary", "input": "summarize code:\ndef solution(num: int = 100) -> int:\n    nfact = factorial(num)\n    result = split_and_add(nfact)\n    return result", "output": "Returns the sum of the digits in the factorial of num"}
{"task": "detection", "input": "classify code:\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    >>> is_palindrome(\"Able was I ere I saw Elba\")\n    True\n    >>> is_palindrome(\"racecar\")\n    True\n    >>> is_palindrome(\"Mr. Owl ate my metal worm?\")\n    True\n    \"\"\"\n    # Since Punctuation, capitalization, and spaces are usually ignored while checking Palindrome,\n    # we first remove them from our string.\n    s = \"\".join([character for character in s.lower() if character.isalnum()])\n    return s == s[::-1]", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef str_eval(s: str) -> int:\n    \"\"\"\n    Returns product of digits in given string n\n\n    >>> str_eval(\"987654321\")\n    362880\n    >>> str_eval(\"22222222\")\n    256\n    \"\"\"\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product", "output": "def str_eval(s: str) -> int:\n    \"\"\"\n    Returns product of digits in given string n\n\n    >>> str_eval(\"987654321\")\n    362880\n    >>> str_eval(\"22222222\")\n    256\n    \"\"\"\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product"}
{"task": "detection", "input": "classify code:\ndef spiral_traversal(matrix: list[list]) -> list[int]:\n    \"\"\"\n    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n    Example:\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    Algorithm:\n        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n                output of [step 2])\n        Step 2. Now perform matrix's Transpose operation (Change rows to column\n                and vice versa) and reverse the resultant matrix.\n        Step 3. Pass the output of [2nd step], to same recursive function till\n                base case hits.\n    Dry Run:\n    Stage 1.\n    [1, 2, 3, 4] +   spiral_traversal([\n        [8, 12], [7, 11], [6, 10], [5, 9]]\n     ])\n    Stage 2.\n    [1, 2, 3, 4, 8, 12] + spiral_traversal([\n        [11, 10, 9], [7, 6, 5]\n    ])\n    Stage 3.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 4.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 5.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\n    Stage 6.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])\n    \"\"\"\n    if matrix:\n        return list(matrix.pop(0)) + spiral_traversal(\n            [list(row) for row in zip(*matrix)][::-1]\n        )\n    else:\n        return []", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef mode(input_list: list) -> list[Any]:\n    if not input_list:\n        return []\n    result = [input_list.count(value) for value in input_list]\n    y = max(result)  # Gets the maximum count in the input list.\n    # Gets values of modes\n    return sorted({input_list[i] for i, value in enumerate(result) if value == y})", "output": "This function returns the mode(Mode as in the measures of"}
{"task": "search", "input": "search code:\nReturns total time of the motion\n\nChoices:\n0: def format_invocation(name='', args=(), kwargs=None, **kw):     _repr = kw.pop('repr', repr)     if kw:         raise TypeError('unexpected keyword args: %r' % ', '.join(kw.keys()))     kwargs = kwargs or {}     a_text = ', '.join([_repr(a) for a in args])     if isinstance(kwargs, dict):         kwarg_items = [(k, kwargs[k]) for k in sorted(kwargs)]     else:         kwarg_items = kwargs     kw_text = ', '.join([f'{k}={_repr(v)}' for k, v in kwarg_items])      all_args_text = a_text     if all_args_text and kw_text:         all_args_text += ', '     all_args_text += kw_text      return f'{name}({all_args_text})'\n1: def total_time(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(angle)     return round(2 * init_velocity * sin(radians) / g, 2)\n2: def odd_even_sort(input_list: list) -> list:     is_sorted = False     while is_sorted is False:  # Until all the indices are traversed keep looping         is_sorted = True         for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices             if input_list[i] > input_list[i + 1]:                 input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]                 # swapping if elements not in order                 is_sorted = False          for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices             if input_list[i] > input_list[i + 1]:                 input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]                 # swapping if elements not in order                 is_sorted = False     return input_list", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef pairs_with_sum(arr: list, req_sum: int) -> int:\n    return len([1 for a, b in combinations(arr, 2) if a + b == req_sum])", "output": "Return the no. of pairs with sum \"sum\""}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 5000) -> int:\n    pentagonal_nums = [(i * (3 * i - 1)) // 2 for i in range(1, limit)]\n    for i, pentagonal_i in enumerate(pentagonal_nums):\n        for j in range(i, len(pentagonal_nums)):\n            pentagonal_j = pentagonal_nums[j]\n            a = pentagonal_i + pentagonal_j\n            b = pentagonal_j - pentagonal_i\n            if is_pentagonal(a) and is_pentagonal(b):\n                return b\n\n    return -1", "output": "Returns the minimum difference of two pentagonal numbers P1 and P2 such that"}
{"task": "repair", "input": "fix bug:\ndef is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )", "output": "def is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )"}
{"task": "search", "input": "search code:\nFind the path from top left to bottom right of array of numbers\n\nChoices:\n0: def is_bit_set(number: int, position: int) -> bool:     return ((number >> position) & 1) == 1\n1: def charging_inductor(     source_voltage: float,  # source_voltage should be in volts.     resistance: float,  # resistance should be in ohms.     inductance: float,  # inductance should be in henrys.     time: float,  # time should in seconds. ) -> float:      if source_voltage <= 0:         raise ValueError(\"Source voltage must be positive.\")     if resistance <= 0:         raise ValueError(\"Resistance must be positive.\")     if inductance <= 0:         raise ValueError(\"Inductance must be positive.\")     return round(         source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3     )\n2: def min_path_sum(grid: list) -> int:      if not grid or not grid[0]:         raise TypeError(\"The grid does not contain the appropriate information\")      for cell_n in range(1, len(grid[0])):         grid[0][cell_n] += grid[0][cell_n - 1]     row_above = grid[0]      for row_n in range(1, len(grid)):         current_row = grid[row_n]         grid[row_n] = fill_row(current_row, row_above)         row_above = grid[row_n]      return grid[-1][-1]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef fibonacci(n: int) -> int:\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]", "output": "Computes the Fibonacci number for input n by iterating through n numbers"}
{"task": "search", "input": "search code:\nDepth First Search on Graph\n\nChoices:\n0: def zigzag(root: Node | None) -> Generator[int]:     if root is None:         return      flag = 0     height_tree = height(root)      for h in range(1, height_tree + 1):         if not flag:             yield from get_nodes_from_left_to_right(root, h)             flag = 1         else:             yield from get_nodes_from_right_to_left(root, h)             flag = 0\n1: def depth_first_search(graph: dict, start: str) -> set[str]:     explored, stack = set(start), [start]      while stack:         v = stack.pop()         explored.add(v)         # Differences from BFS:         # 1) pop last element instead of first one         # 2) add adjacent elements to stack without exploring them         for adj in reversed(graph[v]):             if adj not in explored:                 stack.append(adj)     return explored\n2: def get_significant_digits(colors: list) -> str:     digit = \"\"     for color in colors:         if color not in significant_figures_color_values:             msg = f\"{color} is not a valid color for significant figure bands\"             raise ValueError(msg)         digit = digit + str(significant_figures_color_values[color])     return str(digit)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef sum_of_digits(n: int) -> int:\n    n = abs(n)\n    res = 0\n    while n > 0:\n        res += n % 10\n        n //= 10\n    return res", "output": "Find the sum of digits of a number."}
{"task": "search", "input": "search code:\nReturns a symmetric positive definite matrix given a dimension.\n\nChoices:\n0: def get_week_day(year: int, month: int, day: int) -> str:     # minimal input check:     assert len(str(year)) > 2, \"year should be in YYYY format\"     assert 1 <= month <= 12, \"month should be between 1 to 12\"     assert 1 <= day <= 31, \"day should be between 1 to 31\"      # Doomsday algorithm:     century = year // 100     century_anchor = (5 * (century % 4) + 2) % 7     centurian = year % 100     centurian_m = centurian % 12     dooms_day = (         (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor     ) % 7     day_anchor = (         DOOMSDAY_NOT_LEAP[month - 1]         if year % 4 != 0 or (centurian == 0 and year % 400 != 0)         else DOOMSDAY_LEAP[month - 1]     )     week_day = (dooms_day + day - day_anchor) % 7     return WEEK_DAY_NAMES[week_day]\n1: def left_rotate_32(i: int, shift: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")     if shift < 0:         raise ValueError(\"Shift must be non-negative\")     return ((i << shift) ^ (i >> (32 - shift))) % 2**32\n2: def _create_spd_matrix(dimension: int) -> Any:     rng = np.random.default_rng()     random_matrix = rng.normal(size=(dimension, dimension))     spd_matrix = np.dot(random_matrix, random_matrix.T)     assert _is_matrix_spd(spd_matrix)     return spd_matrix", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 4000000) -> int:\n\n    i = 1\n    j = 2\n    total = 0\n    while j <= n:\n        if j % 2 == 0:\n            total += j\n        i, j = j, i + j\n\n    return total", "output": "Returns the sum of all even fibonacci sequence elements that are lower"}
{"task": "search", "input": "search code:\nSimple implementation of Root Mean Squared Error\n\nChoices:\n0: def root_mean_square_error(original: np.ndarray, reference: np.ndarray) -> float:     return float(np.sqrt(((original - reference) ** 2).mean()))\n1: def solution(min_total: int = 10**12) -> int:      prev_numerator = 1     prev_denominator = 0      numerator = 1     denominator = 1      while numerator <= 2 * min_total - 1:         prev_numerator += 2 * numerator         numerator += 2 * prev_numerator          prev_denominator += 2 * denominator         denominator += 2 * prev_denominator      return (denominator + 1) // 2\n2: def binary_search_std_lib(sorted_collection: list[int], item: int) -> int:     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     index = bisect.bisect_left(sorted_collection, item)     if index != len(sorted_collection) and sorted_collection[index] == item:         return index     return -1", "output": "0"}
{"task": "search", "input": "search code:\nCheck if an integer is palindromic.\n\nChoices:\n0: def update_image_and_anno(     img_list: list, anno_list: list, flip_type: int = 1 ) -> tuple[list, list, list]:     new_annos_lists = []     path_list = []     new_imgs_list = []     for idx in range(len(img_list)):         new_annos = []         path = img_list[idx]         path_list.append(path)         img_annos = anno_list[idx]         img = cv2.imread(path)         if flip_type == 1:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 x_center_new = 1 - bbox[1]                 new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])         elif flip_type == 0:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 y_center_new = 1 - bbox[2]                 new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])         new_annos_lists.append(new_annos)         new_imgs_list.append(new_img)     return new_imgs_list, new_annos_lists, path_list\n1: def is_palindrome(n: int) -> bool:     if n % 10 == 0:         return False     s = str(n)     return s == s[::-1]\n2: def is_palindrome(n: int | str) -> bool:     n = str(n)     return n == n[::-1]", "output": "1"}
{"task": "search", "input": "search code:\nCheck that the arguments are valid\n\nChoices:\n0: def get_distance(highway_now: list, car_index: int) -> int:      distance = 0     cells = highway_now[car_index + 1 :]     for cell in range(len(cells)):  # May need a better name for this         if cells[cell] != -1:  # If the cell is not empty then             return distance  # we have the distance we wanted         distance += 1     # Here if the car is near the end of the highway     return distance + get_distance(highway_now, -1)\n1: def solution(n: int = 7) -> int:     pandigital_str = \"\".join(str(i) for i in range(1, n + 1))     perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]     pandigitals = [num for num in perm_list if is_prime(num)]     return max(pandigitals) if pandigitals else 0\n2: def check_args(init_velocity: float, angle: float) -> None:      # Ensure valid instance     if not isinstance(init_velocity, (int, float)):         raise TypeError(\"Invalid velocity. Should be an integer or float.\")      if not isinstance(angle, (int, float)):         raise TypeError(\"Invalid angle. Should be an integer or float.\")      # Ensure valid angle     if angle > 90 or angle < 1:         raise ValueError(\"Invalid angle. Range is 1-90 degrees.\")      # Ensure valid velocity     if init_velocity < 0:         raise ValueError(\"Invalid velocity. Should be a positive number.\")", "output": "2"}
{"task": "search", "input": "search code:\nVisit input iterables in a cycle until each is exhausted.\n\nChoices:\n0: def rotate_to_the_right(head: Node, places: int) -> Node:     # Check if the list is empty or has only one element     if not head:         raise ValueError(\"The linked list is empty.\")      if head.next_node is None:         return head      # Calculate the length of the linked list     length = 1     temp_node = head     while temp_node.next_node is not None:         length += 1         temp_node = temp_node.next_node      # Adjust the value of places to avoid places longer than the list.     places %= length      if places == 0:         return head  # As no rotation is needed.      # Find the new head position after rotation.     new_head_index = length - places      # Traverse to the new head position     temp_node = head     for _ in range(new_head_index - 1):         assert temp_node.next_node         temp_node = temp_node.next_node      # Update pointers to perform rotation     assert temp_node.next_node     new_head = temp_node.next_node     temp_node.next_node = None     temp_node = new_head     while temp_node.next_node:         temp_node = temp_node.next_node     temp_node.next_node = head      assert new_head     return new_head\n1: def map_if(iterable, pred, func, func_else=None):      if func_else is None:         for item in iterable:             yield func(item) if pred(item) else item      else:         for item in iterable:             yield func(item) if pred(item) else func_else(item)\n2: def roundrobin(*iterables):     # Algorithm credited to George Sakkis     iterators = map(iter, iterables)     for num_active in range(len(iterables), 0, -1):         iterators = cycle(islice(iterators, num_active))         yield from map(next, iterators)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef is_palindrome(s):\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    \"\"\"\n    return s == s[::-1]", "output": "def is_palindrome(s: str) -> bool:\n    \"\"\"\n    Determine whether the string is palindrome\n    :param s:\n    :return: Boolean\n    >>> is_palindrome(\"a man a plan a canal panama\".replace(\" \", \"\"))\n    True\n    >>> is_palindrome(\"Hello\")\n    False\n    >>> is_palindrome(\"Able was I ere I saw Elba\")\n    True\n    >>> is_palindrome(\"racecar\")\n    True\n    >>> is_palindrome(\"Mr. Owl ate my metal worm?\")\n    True\n    \"\"\"\n    # Since Punctuation, capitalization, and spaces are usually ignored while checking Palindrome,\n    # we first remove them from our string.\n    s = \"\".join([character for character in s.lower() if character.isalnum()])\n    return s == s[::-1]"}
{"task": "summary", "input": "summarize code:\ndef _calculate(days: int, absent: int, late: int) -> int:\n\n    # if we are absent twice, or late 3 consecutive days,\n    # no further prize strings are possible\n    if late == 3 or absent == 2:\n        return 0\n\n    # if we have no days left, and have not failed any other rules,\n    # we have a prize string\n    if days == 0:\n        return 1\n\n    # No easy solution, so now we need to do the recursive calculation\n\n    # First, check if the combination is already in the cache, and\n    # if yes, return the stored value from there since we already\n    # know the number of possible prize strings from this point on\n    key = (days, absent, late)\n    if key in cache:\n        return cache[key]\n\n    # now we calculate the three possible ways that can unfold from\n    # this point on, depending on our attendance today\n\n    # 1) if we are late (but not absent), the \"absent\" counter stays as\n    # it is, but the \"late\" counter increases by one\n    state_late = _calculate(days - 1, absent, late + 1)\n\n    # 2) if we are absent, the \"absent\" counter increases by 1, and the\n    # \"late\" counter resets to 0\n    state_absent = _calculate(days - 1, absent + 1, 0)\n\n    # 3) if we are on time, this resets the \"late\" counter and keeps the\n    # absent counter\n    state_ontime = _calculate(days - 1, absent, 0)\n\n    prizestrings = state_late + state_absent + state_ontime\n\n    cache[key] = prizestrings\n    return prizestrings", "output": "A small helper function for the recursion, mainly to have"}
{"task": "search", "input": "search code:\nchecking whether the input series is arithmetic series or not\n\nChoices:\n0: def factorial(num: int) -> int:     fact = 1     for i in range(1, num + 1):         fact *= i     return fact\n1: def increment_score(count: int) -> int:     return int(count * (count + 1) / 2)\n2: def is_harmonic_series(series: list) -> bool:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [1, 2/3, 2]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     if len(series) == 1 and series[0] != 0:         return True     rec_series = []     series_len = len(series)     for i in range(series_len):         if series[i] == 0:             raise ValueError(\"Input series cannot have 0 as an element\")         rec_series.append(1 / series[i])     common_diff = rec_series[1] - rec_series[0]     for index in range(2, series_len):         if rec_series[index] - rec_series[index - 1] != common_diff:             return False     return True", "output": "2"}
{"task": "detection", "input": "classify code:\ndef scalar_multiply(matrix: list[list], n: int) -> list[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef trapped_rainwater(heights: tuple[int, ...]) -> int:\n    if not heights:\n        return 0\n    if any(h < 0 for h in heights):\n        raise ValueError(\"No height can be negative\")\n    length = len(heights)\n\n    left_max = [0] * length\n    left_max[0] = heights[0]\n    for i, height in enumerate(heights[1:], start=1):\n        left_max[i] = max(height, left_max[i - 1])\n\n    right_max = [0] * length\n    right_max[-1] = heights[-1]\n    for i in range(length - 2, -1, -1):\n        right_max[i] = max(heights[i], right_max[i + 1])\n\n    return sum(\n        min(left, right) - height\n        for left, right, height in zip(left_max, right_max, heights)\n    )", "output": "The trapped_rainwater function calculates the total amount of rainwater that can be"}
{"task": "search", "input": "search code:\nReturn a minimum unit suitable that is not suppressed.\n\nChoices:\n0: def _suitable_minimum_unit(min_unit, suppress):     if min_unit in suppress:         for unit in Unit:             if unit > min_unit and unit not in suppress:                 return unit          raise ValueError(             \"Minimum unit is suppressed and no suitable replacement was found\"         )      return min_unit\n1: def print_exception(etype, value, tb, limit=None, file=None):      if file is None:         file = sys.stderr     if tb:         tbi = TracebackInfo.from_traceback(tb, limit)         print(str(tbi), end='', file=file)      for line in format_exception_only(etype, value):         print(line, end='', file=file)\n2: def unique(iterable, key=None, reverse=False):     sequenced = sorted(iterable, key=key, reverse=reverse)     return unique_justseen(sequenced, key=key)", "output": "0"}
{"task": "search", "input": "search code:\nThis function calculates the waiting time of some processes that have a\n\nChoices:\n0: def calculate_waiting_times(duration_times: list[int]) -> list[int]:     waiting_times = [0] * len(duration_times)     for i in range(1, len(duration_times)):         waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]     return waiting_times\n1: def update_image_and_anno(     img_list: list, anno_list: list, flip_type: int = 1 ) -> tuple[list, list, list]:     new_annos_lists = []     path_list = []     new_imgs_list = []     for idx in range(len(img_list)):         new_annos = []         path = img_list[idx]         path_list.append(path)         img_annos = anno_list[idx]         img = cv2.imread(path)         if flip_type == 1:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 x_center_new = 1 - bbox[1]                 new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])         elif flip_type == 0:             new_img = cv2.flip(img, flip_type)             for bbox in img_annos:                 y_center_new = 1 - bbox[2]                 new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])         new_annos_lists.append(new_annos)         new_imgs_list.append(new_img)     return new_imgs_list, new_annos_lists, path_list\n2: def get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:     num_filters = len(filter_points) - 2     filters = np.zeros((num_filters, int(ftt_size / 2) + 1))      for n in range(num_filters):         start = filter_points[n]         mid = filter_points[n + 1]         end = filter_points[n + 2]          # Linearly increase values from 0 to 1         filters[n, start:mid] = np.linspace(0, 1, mid - start)          # Linearly decrease values from 1 to 0         filters[n, mid:end] = np.linspace(1, 0, end - mid)      return filters", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef get_bitcode(edge_array, distinct_edge):\n    bitcode = [\"0\"] * len(edge_array)\n    for i, row in enumerate(edge_array):\n        for item in row:\n            if distinct_edge in item[0]:\n                bitcode[i] = \"1\"\n                break\n    return \"\".join(bitcode)", "output": "Return bitcode of distinct_edge"}
{"task": "summary", "input": "summarize code:\ndef solution(base: int = 1777, height: int = 1855, digits: int = 8) -> int:\n\n    # calculate baseheight by right-assiciative repeated modular\n    # exponentiation\n    result = base\n    for _ in range(1, height):\n        result = _modexpt(base, result, 10**digits)\n\n    return result", "output": "Returns the last 8 digits of the hyperexponentiation of base by"}
{"task": "search", "input": "search code:\nPure implementation of a binary search algorithm in Python by recursion\n\nChoices:\n0: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n1: def binary_search_by_recursion(     sorted_collection: list[int], item: int, left: int = 0, right: int = -1 ) -> int:     if right < 0:         right = len(sorted_collection) - 1     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     if right < left:         return -1      midpoint = left + (right - left) // 2      if sorted_collection[midpoint] == item:         return midpoint     elif sorted_collection[midpoint] > item:         return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)     else:         return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)\n2: def write_file_binary(file_path: str, to_write: str) -> None:     byte_length = 8     try:         with open(file_path, \"wb\") as opened_file:             result_byte_array = [                 to_write[i : i + byte_length]                 for i in range(0, len(to_write), byte_length)             ]              if len(result_byte_array[-1]) % byte_length == 0:                 result_byte_array.append(\"10000000\")             else:                 result_byte_array[-1] += \"1\" + \"0\" * (                     byte_length - len(result_byte_array[-1]) - 1                 )              for elem in result_byte_array:                 opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))     except OSError:         print(\"File not accessible\")         sys.exit()", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef contains_an_even_digit(n: int) -> bool:\n    \"\"\"\n    Return True if n contains an even digit.\n    >>> contains_an_even_digit(0)\n    True\n    >>> contains_an_even_digit(975317933)\n    False\n    >>> contains_an_even_digit(-245679)\n    True\n    \"\"\"\n    return any(digit in \"02468\" for digit in str(n))", "output": "def contains_an_even_digit(n: int) -> bool:\n    \"\"\"\n    Return True if n contains an even digit.\n    >>> contains_an_even_digit(0)\n    True\n    >>> contains_an_even_digit(975317933)\n    False\n    >>> contains_an_even_digit(-245679)\n    True\n    \"\"\"\n    return any(digit in \"02468\" for digit in str(n))"}
{"task": "search", "input": "search code:\nReturns the largest palindrome made from the product of two 3-digit\n\nChoices:\n0: def breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:     visited = [False] * len(graph)  # Mark all nodes as not visited     queue = []  # breadth-first search queue      # Source node     queue.append(source)     visited[source] = True      while queue:         u = queue.pop(0)  # Pop the front node         # Traverse all adjacent nodes of u         for ind, node in enumerate(graph[u]):             if visited[ind] is False and node > 0:                 queue.append(ind)                 visited[ind] = True                 parents[ind] = u     return visited[sink]\n1: def solution(n: int = 998001) -> int:      answer = 0     for i in range(999, 99, -1):  # 3 digit numbers range from 999 down to 100         for j in range(999, 99, -1):             product_string = str(i * j)             if product_string == product_string[::-1] and i * j < n:                 answer = max(answer, i * j)     return answer\n2: def rlocate(iterable, pred=bool, window_size=None):     if window_size is None:         try:             len_iter = len(iterable)             return (len_iter - i - 1 for i in locate(reversed(iterable), pred))         except TypeError:             pass      return reversed(list(locate(iterable, pred, window_size)))", "output": "1"}
{"task": "search", "input": "search code:\nReturn the 2-d vector product of two vectors.\n\nChoices:\n0: def bubble_sort_iterative(collection: list[Any]) -> list[Any]:     length = len(collection)     for i in reversed(range(length)):         swapped = False         for j in range(i):             if collection[j] > collection[j + 1]:                 swapped = True                 collection[j], collection[j + 1] = collection[j + 1], collection[j]         if not swapped:             break  # Stop iteration if the collection is sorted.     return collection\n1: def subset_combinations(elements: list[int], n: int) -> list:     r = len(elements)     if n > r:         return []      dp: list[list[tuple]] = [[] for _ in range(r + 1)]      dp[0].append(())      for i in range(1, r + 1):         for j in range(i, 0, -1):             for prev_combination in dp[j - 1]:                 dp[j].append((*prev_combination, elements[i - 1]))      try:         return sorted(dp[n])     except TypeError:         return dp[n]\n2: def vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:     return point1[0] * point2[1] - point1[1] * point2[0]", "output": "2"}
{"task": "search", "input": "search code:\nHigh-Low threshold detection. If an edge pixel's gradient value is higher\n\nChoices:\n0: def beta(velocity: float) -> float:     if velocity > c:         raise ValueError(\"Speed must not exceed light speed 299,792,458 [m/s]!\")     elif velocity < 1:         # Usually the speed should be much higher than 1 (c order of magnitude)         raise ValueError(\"Speed must be greater than or equal to 1!\")      return velocity / c\n1: def combination_lists(n: int, k: int) -> list[list[int]]:     return [list(x) for x in combinations(range(1, n + 1), k)]\n2: def detect_high_low_threshold(     image_shape, destination, threshold_low, threshold_high, weak, strong ):     for row in range(1, image_shape[0] - 1):         for col in range(1, image_shape[1] - 1):             if destination[row, col] >= threshold_high:                 destination[row, col] = strong             elif destination[row, col] <= threshold_low:                 destination[row, col] = 0             else:                 destination[row, col] = weak", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef make_tree() -> Node | None:\n    tree = Node(1)\n    tree.left = Node(2)\n    tree.right = Node(3)\n    tree.left.left = Node(4)\n    tree.left.right = Node(5)\n    return tree", "output": "The below tree"}
{"task": "summary", "input": "summarize code:\ndef rec_insertion_sort(collection: list, n: int):\n    # Checks if the entire collection has been sorted\n    if len(collection) <= 1 or n <= 1:\n        return\n\n    insert_next(collection, n - 1)\n    rec_insertion_sort(collection, n - 1)", "output": "Given a collection of numbers and its length, sorts the collections"}
{"task": "summary", "input": "summarize code:\ndef dis_between_closest_in_strip(points, points_counts, min_dis=float(\"inf\")):\n\n    for i in range(min(6, points_counts - 1), points_counts):\n        for j in range(max(0, i - 6), i):\n            current_dis = euclidean_distance_sqr(points[i], points[j])\n            min_dis = min(min_dis, current_dis)\n    return min_dis", "output": "closest pair of points in strip"}
{"task": "repair", "input": "fix bug:\ndef edit_distance(source: str, target: str) -> int:\n    \"\"\"\n    Edit distance algorithm is a string metric, i.e., it is a way of quantifying how\n    dissimilar two strings are to one another. It is measured by counting the minimum\n    number of operations required to transform one string into another.\n\n    This implementation assumes that the cost of operations (insertion, deletion and\n    substitution) is always 1\n\n    Args:\n    source: the initial string with respect to which we are calculating the edit\n        distance for the target\n    target: the target string, formed after performing n operations on the source string\n\n    >>> edit_distance(\"GATTIC\", \"GALTIC\")\n    1\n    >>> edit_distance(\"NUM3\", \"HUM2\")\n    2\n    >>> edit_distance(\"cap\", \"CAP\")\n    3\n    >>> edit_distance(\"Cat\", \"\")\n    3\n    >>> edit_distance(\"cat\", \"cat\")\n    0\n    >>> edit_distance(\"\", \"123456789\")\n    9\n    >>> edit_distance(\"Be@uty\", \"Beautyyyy!\")\n    5\n    >>> edit_distance(\"lstring\", \"lsstring\")\n    1\n    \"\"\"\n    if len(source) == 0:\n        return len(target)\n    elif len(target) == 0:\n        return len(source)\n\n    delta = int(source[-1] != target[-1])  # Substitution\n    return min(\n        edit_distance(source[:-1], target[:-1]) + delta,\n        edit_distance(source, target[:-1]) + 1,\n        edit_distance(source[:-1], target) + 1,\n    )", "output": "def edit_distance(source: str, target: str) -> int:\n    \"\"\"\n    Edit distance algorithm is a string metric, i.e., it is a way of quantifying how\n    dissimilar two strings are to one another. It is measured by counting the minimum\n    number of operations required to transform one string into another.\n\n    This implementation assumes that the cost of operations (insertion, deletion and\n    substitution) is always 1\n\n    Args:\n    source: the initial string with respect to which we are calculating the edit\n        distance for the target\n    target: the target string, formed after performing n operations on the source string\n\n    >>> edit_distance(\"GATTIC\", \"GALTIC\")\n    1\n    >>> edit_distance(\"NUM3\", \"HUM2\")\n    2\n    >>> edit_distance(\"cap\", \"CAP\")\n    3\n    >>> edit_distance(\"Cat\", \"\")\n    3\n    >>> edit_distance(\"cat\", \"cat\")\n    0\n    >>> edit_distance(\"\", \"123456789\")\n    9\n    >>> edit_distance(\"Be@uty\", \"Beautyyyy!\")\n    5\n    >>> edit_distance(\"lstring\", \"lsstring\")\n    1\n    \"\"\"\n    if len(source) == 0:\n        return len(target)\n    elif len(target) == 0:\n        return len(source)\n\n    delta = int(source[-1] != target[-1])  # Substitution\n    return min(\n        edit_distance(source[:-1], target[:-1]) + delta,\n        edit_distance(source, target[:-1]) + 1,\n        edit_distance(source[:-1], target) + 1,\n    )"}
{"task": "detection", "input": "classify code:\ndef wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the sum of the digits in the numerator of the max-th convergent of\n\nChoices:\n0: def snake_to_camel_case(input_str: str, use_pascal: bool = False) -> str:      if not isinstance(input_str, str):         msg = f\"Expected string as input, found {type(input_str)}\"         raise ValueError(msg)     if not isinstance(use_pascal, bool):         msg = f\"Expected boolean as use_pascal parameter, found {type(use_pascal)}\"         raise ValueError(msg)      words = input_str.split(\"_\")      start_index = 0 if use_pascal else 1      words_to_capitalize = words[start_index:]      capitalized_words = [word[0].upper() + word[1:] for word in words_to_capitalize]      initial_word = \"\" if use_pascal else words[0]      return \"\".join([initial_word, *capitalized_words])\n1: def solution(max_n: int = 100) -> int:     pre_numerator = 1     cur_numerator = 2      for i in range(2, max_n + 1):         temp = pre_numerator         e_cont = 2 * i // 3 if i % 3 == 0 else 1         pre_numerator = cur_numerator         cur_numerator = e_cont * pre_numerator + temp      return sum_digits(cur_numerator)\n2: def always_iterable(obj, base_type=(str, bytes)):     if obj is None:         return iter(())      if (base_type is not None) and isinstance(obj, base_type):         return iter((obj,))      try:         return iter(obj)     except TypeError:         return iter((obj,))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef cyclic_sort(nums: list[int]) -> list[int]:\n    \"\"\"\n    Sorts the input list of n integers from 1 to n in-place\n    using the Cyclic Sort algorithm.\n\n    :param nums: List of n integers from 1 to n to be sorted.\n    :return: The same list sorted in ascending order.\n\n    Time complexity: O(n), where n is the number of integers in the list.\n\n    Examples:\n    >>> cyclic_sort([])\n    []\n    >>> cyclic_sort([3, 5, 2, 1, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums", "output": "CORRECT"}
{"task": "search", "input": "search code:\nAlgorithm to find the biggest subset in the given array such that for any 2 elements\n\nChoices:\n0: def find_negative_index(array: list[int]) -> int:     left = 0     right = len(array) - 1      # Edge cases such as no values or all numbers are negative.     if not array or array[0] < 0:         return 0      while right + 1 > left:         mid = (left + right) // 2         num = array[mid]          # Num must be negative and the index must be greater than or equal to 0.         if num < 0 and array[mid - 1] >= 0:             return mid          if num >= 0:             left = mid + 1         else:             right = mid - 1     # No negative numbers so return the last index of the array + 1 which is the length.     return len(array)\n1: def largest_divisible_subset(items: list[int]) -> list[int]:     # Sort the array in ascending order as the sequence does not matter we only have to     # pick up a subset.     items = sorted(items)      number_of_items = len(items)      # Initialize memo with 1s and hash with increasing numbers     memo = [1] * number_of_items     hash_array = list(range(number_of_items))      # Iterate through the array     for i, item in enumerate(items):         for prev_index in range(i):             if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (                 (1 + memo[prev_index]) > memo[i]             ):                 memo[i] = 1 + memo[prev_index]                 hash_array[i] = prev_index      ans = -1     last_index = -1      # Find the maximum length and its corresponding index     for i, memo_item in enumerate(memo):         if memo_item > ans:             ans = memo_item             last_index = i      # Reconstruct the divisible subset     if last_index == -1:         return []     result = [items[last_index]]     while hash_array[last_index] != last_index:         last_index = hash_array[last_index]         result.append(items[last_index])      return result\n2: def chain_length(n: int, previous: set | None = None) -> int:     previous = previous or set()     if n in CHAIN_LENGTH_CACHE:         return CHAIN_LENGTH_CACHE[n]     next_number = sum_digit_factorials(n)     if next_number in previous:         CHAIN_LENGTH_CACHE[n] = 0         return 0     else:         previous.add(n)         ret = 1 + chain_length(next_number, previous)         CHAIN_LENGTH_CACHE[n] = ret         return ret", "output": "1"}
{"task": "detection", "input": "classify code:\ndef _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef sum_of_divisors(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    s = 1\n    temp = 1\n    while n % 2 == 0:\n        temp += 1\n        n = int(n / 2)\n    if temp > 1:\n        s *= (2**temp - 1) / (2 - 1)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        temp = 1\n        while n % i == 0:\n            temp += 1\n            n = int(n / i)\n        if temp > 1:\n            s *= (i**temp - 1) / (i - 1)\n    return int(s)", "output": "Calculate Sum of Divisors."}
{"task": "search", "input": "search code:\nReturns the sum of the digits of the number 2^power.\n\nChoices:\n0: def solution(power: int = 1000) -> int:     n = 2**power     r = 0     while n:         r, n = r + n % 10, n // 10     return r\n1: def nth_combination(iterable, r, index):     pool = tuple(iterable)     n = len(pool)     if (r < 0) or (r > n):         raise ValueError      c = 1     k = min(r, n - r)     for i in range(1, k + 1):         c = c * (n - k + i) // i      if index < 0:         index += c      if (index < 0) or (index >= c):         raise IndexError      result = []     while r:         c, n, r = c * r // n, n - 1, r - 1         while index >= c:             index -= c             c, n = c * (n - r) // n, n - 1         result.append(pool[-1 - n])      return tuple(result)\n2: def hexagonal_num(n: int) -> int:     return n * (2 * n - 1)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef bytes2human(nbytes, ndigits=0):\n    abs_bytes = abs(nbytes)\n    for (size, symbol), (next_size, next_symbol) in _SIZE_RANGES:\n        if abs_bytes <= next_size:\n            break\n    hnbytes = float(nbytes) / size\n    return '{hnbytes:.{ndigits}f}{symbol}'.format(hnbytes=hnbytes,\n                                                  ndigits=ndigits,\n                                                  symbol=symbol)", "output": "Turns an integer value of *nbytes* into a human readable format. Set"}
{"task": "search", "input": "search code:\nCalculate the Volume of a Hollow Circular Cylinder.\n\nChoices:\n0: def vol_hollow_circular_cylinder(     inner_radius: float, outer_radius: float, height: float ) -> float:     # Volume - (outer_radius squared - inner_radius squared) * pi * height     if inner_radius < 0 or outer_radius < 0 or height < 0:         raise ValueError(             \"vol_hollow_circular_cylinder() only accepts non-negative values\"         )     if outer_radius <= inner_radius:         raise ValueError(\"outer_radius must be greater than inner_radius\")     return pi * (pow(outer_radius, 2) - pow(inner_radius, 2)) * height\n1: def first_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )\n2: def _gettext_noop(message):     return message", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef xfrange(stop, start=None, step=1.0):\n    if not step:\n        raise ValueError('step must be non-zero')\n    if start is None:\n        start, stop = 0.0, stop * 1.0\n    else:\n        # swap when all args are used\n        stop, start = start * 1.0, stop * 1.0\n    cur = start\n    while cur < stop:\n        yield cur\n        cur += step", "output": "Same as :func:`frange`, but generator-based instead of returning a"}
{"task": "search", "input": "search code:\nReturns the sum of all numbers less than 1e8 that are both palindromic and\n\nChoices:\n0: def is_safe(row: int, col: int, rows: int, cols: int) -> bool:     return 0 <= row < rows and 0 <= col < cols\n1: def column_reshape(input_array: np.ndarray) -> np.ndarray:      return input_array.reshape((input_array.size, 1))\n2: def solution() -> int:     answer = set()     first_square = 1     sum_squares = 5     while sum_squares < LIMIT:         last_square = first_square + 1         while sum_squares < LIMIT:             if is_palindrome(sum_squares):                 answer.add(sum_squares)             last_square += 1             sum_squares += last_square**2         first_square += 1         sum_squares = first_square**2 + (first_square + 1) ** 2      return sum(answer)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef get_path(root, path, default=_UNSET):\n    if isinstance(path, str):\n        path = path.split('.')\n    cur = root\n    try:\n        for seg in path:\n            try:\n                cur = cur[seg]\n            except (KeyError, IndexError) as exc:\n                raise PathAccessError(exc, seg, path)\n            except TypeError as exc:\n                # either string index in a list, or a parent that\n                # doesn't support indexing\n                try:\n                    seg = int(seg)\n                    cur = cur[seg]\n                except (ValueError, KeyError, IndexError, TypeError):\n                    if not is_iterable(cur):\n                        exc = TypeError('%r object is not indexable'\n                                        % type(cur).__name__)\n                    raise PathAccessError(exc, seg, path)\n    except PathAccessError:\n        if default is _UNSET:\n            raise\n        return default\n    return cur", "output": "Retrieve a value from a nested object via a tuple representing the"}
{"task": "summary", "input": "summarize code:\ndef left_rotation(node: MyNode) -> MyNode:\n    print(\"right rotation node:\", node.get_data())\n    ret = node.get_right()\n    assert ret is not None\n    node.set_right(ret.get_left())\n    ret.set_left(node)\n    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1\n    node.set_height(h1)\n    h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1\n    ret.set_height(h2)\n    return ret", "output": "a mirror symmetry rotation of the left_rotation"}
{"task": "search", "input": "search code:\nThis function performs the Horn-Schunck algorithm and returns the estimated\n\nChoices:\n0: def validate(n: int) -> bool:     return not (         len(str(n)) > 3         and (not is_prime(int(str(n)[-3:])) or not is_prime(int(str(n)[:3])))     )\n1: def sum_digit_factorials(n: int) -> int:     if n in CACHE_SUM_DIGIT_FACTORIALS:         return CACHE_SUM_DIGIT_FACTORIALS[n]     ret = sum(DIGIT_FACTORIALS[let] for let in str(n))     CACHE_SUM_DIGIT_FACTORIALS[n] = ret     return ret\n2: def horn_schunck(     image0: np.ndarray,     image1: np.ndarray,     num_iter: SupportsIndex,     alpha: float | None = None, ) -> tuple[np.ndarray, np.ndarray]:     if alpha is None:         alpha = 0.1      # Initialize flow     horizontal_flow = np.zeros_like(image0)     vertical_flow = np.zeros_like(image0)      # Prepare kernels for the calculation of the derivatives and the average velocity     kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25     kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25     kernel_t = np.array([[1, 1], [1, 1]]) * 0.25     kernel_laplacian = np.array(         [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]     )      # Iteratively refine the flow     for _ in range(num_iter):         warped_image = warp(image0, horizontal_flow, vertical_flow)         derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)         derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)         derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)          avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)         avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)          # This updates the flow as proposed in the paper (Step 12)         update = (             derivative_x * avg_horizontal_velocity             + derivative_y * avg_vertical_velocity             + derivative_t         )         update = update / (alpha**2 + derivative_x**2 + derivative_y**2)          horizontal_flow = avg_horizontal_velocity - derivative_x * update         vertical_flow = avg_vertical_velocity - derivative_y * update      return horizontal_flow, vertical_flow", "output": "2"}
{"task": "detection", "input": "classify code:\ndef comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef partition(arr: list[int], low: int, high: int) -> int:\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] >= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1", "output": "Partitions list based on the pivot element."}
{"task": "detection", "input": "classify code:\ndef abs_max(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef opening_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:\n    if kernel is None:\n        np.ones((3, 3))\n\n    return transform(transform(image, \"dilation\", kernel), \"erosion\", kernel)", "output": "Opening filter, defined as the sequence of"}
{"task": "summary", "input": "summarize code:\ndef ceil(x: float) -> int:\n    return int(x) if x - int(x) <= 0 else int(x) + 1", "output": "Return the ceiling of x as an Integral."}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 1000000) -> int:\n    primes = set(range(3, limit, 2))\n    primes.add(2)\n    for p in range(3, limit, 2):\n        if p not in primes:\n            continue\n        primes.difference_update(set(range(p * p, limit, p)))\n\n    phi = [float(n) for n in range(limit + 1)]\n\n    for p in primes:\n        for n in range(p, limit + 1, p):\n            phi[n] *= 1 - 1 / p\n\n    return int(sum(phi[2:]))", "output": "Return the number of reduced proper fractions with denominator less than limit."}
{"task": "summary", "input": "summarize code:\ndef ordinal(value, gender=\"male\"):\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n    if gender == \"male\":\n        t = (\n            P_(\"0 (male)\", \"th\"),\n            P_(\"1 (male)\", \"st\"),\n            P_(\"2 (male)\", \"nd\"),\n            P_(\"3 (male)\", \"rd\"),\n            P_(\"4 (male)\", \"th\"),\n            P_(\"5 (male)\", \"th\"),\n            P_(\"6 (male)\", \"th\"),\n            P_(\"7 (male)\", \"th\"),\n            P_(\"8 (male)\", \"th\"),\n            P_(\"9 (male)\", \"th\"),\n        )\n    else:\n        t = (\n            P_(\"0 (female)\", \"th\"),\n            P_(\"1 (female)\", \"st\"),\n            P_(\"2 (female)\", \"nd\"),\n            P_(\"3 (female)\", \"rd\"),\n            P_(\"4 (female)\", \"th\"),\n            P_(\"5 (female)\", \"th\"),\n            P_(\"6 (female)\", \"th\"),\n            P_(\"7 (female)\", \"th\"),\n            P_(\"8 (female)\", \"th\"),\n            P_(\"9 (female)\", \"th\"),\n        )\n    if value % 100 in (11, 12, 13):  # special case\n        return f\"{value}{t[0]}\"\n    return f\"{value}{t[value % 10]}\"", "output": "Converts an integer to its ordinal as a string."}
{"task": "summary", "input": "summarize code:\ndef vol_spheres_intersect(\n    radius_1: float, radius_2: float, centers_distance: float\n) -> float:\n    if radius_1 < 0 or radius_2 < 0 or centers_distance < 0:\n        raise ValueError(\"vol_spheres_intersect() only accepts non-negative values\")\n    if centers_distance == 0:\n        return vol_sphere(min(radius_1, radius_2))\n\n    h1 = (\n        (radius_1 - radius_2 + centers_distance)\n        * (radius_1 + radius_2 - centers_distance)\n        / (2 * centers_distance)\n    )\n    h2 = (\n        (radius_2 - radius_1 + centers_distance)\n        * (radius_2 + radius_1 - centers_distance)\n        / (2 * centers_distance)\n    )\n\n    return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)", "output": "Calculate the volume of the intersection of two spheres."}
{"task": "repair", "input": "fix bug:\ndef capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Create a dictionary that maps lowercase letters to uppercase letters\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    lower_to_upper = dict(zip(ascii_lowercase, ascii_uppercase))\n    return lower_to_upper.get(sentence[0], sentence[0]) + sentence[1:]", "output": "def capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    return sentence[0].upper() + sentence[1:]"}
{"task": "summary", "input": "summarize code:\ndef second_molar_mass(\n    molar_mass: float, effusion_rate_1: float, effusion_rate_2: float\n) -> float | ValueError:\n    return (\n        round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)\n        if validate(molar_mass, effusion_rate_1, effusion_rate_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )", "output": "Input Parameters:"}
{"task": "search", "input": "search code:\nComputes a^b recursively, where a is the base and b is the exponent\n\nChoices:\n0: def in_reverse(linked_list: LinkedList) -> str:     return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))\n1: def binary_exp_recursive(base: float, exponent: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")      if exponent == 0:         return 1      if exponent % 2 == 1:         return binary_exp_recursive(base, exponent - 1) * base      b = binary_exp_recursive(base, exponent // 2)     return b * b\n2: def calculate_waiting_times(burst_times: list[int]) -> list[int]:     quantum = 2     rem_burst_times = list(burst_times)     waiting_times = [0] * len(burst_times)     t = 0     while True:         done = True         for i, burst_time in enumerate(burst_times):             if rem_burst_times[i] > 0:                 done = False                 if rem_burst_times[i] > quantum:                     t += quantum                     rem_burst_times[i] -= quantum                 else:                     t += rem_burst_times[i]                     waiting_times[i] = t - burst_time                     rem_burst_times[i] = 0         if done is True:             return waiting_times", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:\n\n    # Initialize path with -1, indicating that we have not visited them yet\n    path = [-1] * (len(graph) + 1)\n    # initialize start and end of path with starting index\n    path[0] = path[-1] = start_index\n    # evaluate and if we find answer return path either return empty array\n    return path if util_hamilton_cycle(graph, path, 1) else []", "output": "Wrapper function to call subroutine called util_hamilton_cycle,"}
{"task": "repair", "input": "fix bug:\ndef n31(a: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)", "output": "def n31(a: int) -> tuple[list[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)"}
{"task": "summary", "input": "summarize code:\ndef check_anagrams(first_str: str, second_str: str) -> bool:\n    first_str = first_str.lower().strip()\n    second_str = second_str.lower().strip()\n\n    # Remove whitespace\n    first_str = first_str.replace(\" \", \"\")\n    second_str = second_str.replace(\" \", \"\")\n\n    # Strings of different lengths are not anagrams\n    if len(first_str) != len(second_str):\n        return False\n\n    # Default values for count should be 0\n    count: defaultdict[str, int] = defaultdict(int)\n\n    # For each character in input strings,\n    # increment count in the corresponding\n    for i in range(len(first_str)):\n        count[first_str[i]] += 1\n        count[second_str[i]] -= 1\n\n    return all(_count == 0 for _count in count.values())", "output": "Two strings are anagrams if they are made up of the same letters but are"}
{"task": "detection", "input": "classify code:\ndef is_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef base16_decode(data: str) -> bytes:\n    # Check data validity, following RFC3548\n    # https://www.ietf.org/rfc/rfc3548.txt\n    if (len(data) % 2) != 0:\n        raise ValueError(\n        )\n    # Check the character set - the standard base16 alphabet\n    # is uppercase according to RFC3548 section 6\n    if not set(data) <= set(\"0123456789ABCDEF\"):\n        raise ValueError(\n        )\n    # For every two hexadecimal digits (= a byte), turn it into an integer.\n    # Then, string the result together into bytes, and return it.\n    return bytes(int(data[i] + data[i + 1], 16) for i in range(0, len(data), 2))", "output": "Decodes the given base16 encoded data into bytes."}
{"task": "search", "input": "search code:\nA pure Python implementation of Dutch National Flag sort algorithm.\n\nChoices:\n0: def solution(power: int = 1000) -> int:     num = 2**power     string_num = str(num)     list_num = list(string_num)     sum_of_num = 0      for i in list_num:         sum_of_num += int(i)      return sum_of_num\n1: def dutch_national_flag_sort(sequence: list) -> list:     if not sequence:         return []     if len(sequence) == 1:         return list(sequence)     low = 0     high = len(sequence) - 1     mid = 0     while mid <= high:         if sequence[mid] == colors[0]:             sequence[low], sequence[mid] = sequence[mid], sequence[low]             low += 1             mid += 1         elif sequence[mid] == colors[1]:             mid += 1         elif sequence[mid] == colors[2]:             sequence[mid], sequence[high] = sequence[high], sequence[mid]             high -= 1         else:             msg = f\"The elements inside the sequence must contains only {colors} values\"             raise ValueError(msg)     return sequence\n2: def length_conversion(value: float, from_type: str, to_type: str) -> float:      from_sanitized = from_type.lower().strip(\"s\")     to_sanitized = to_type.lower().strip(\"s\")      from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)     to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)      if from_sanitized not in METRIC_CONVERSION:         msg = (             f\"Invalid 'from_type' value: {from_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     if to_sanitized not in METRIC_CONVERSION:         msg = (             f\"Invalid 'to_type' value: {to_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     from_exponent = METRIC_CONVERSION[from_sanitized]     to_exponent = METRIC_CONVERSION[to_sanitized]     exponent = 1      if from_exponent > to_exponent:         exponent = from_exponent - to_exponent     else:         exponent = -(to_exponent - from_exponent)      return value * pow(10, exponent)", "output": "1"}
{"task": "search", "input": "search code:\n| Return the clauses and symbols from a formula.\n\nChoices:\n0: def next_point(     point_x: float, point_y: float, incoming_gradient: float ) -> tuple[float, float, float]:     # normal_gradient = gradient of line through which the beam is reflected     # outgoing_gradient = gradient of reflected line     normal_gradient = point_y / 4 / point_x     s2 = 2 * normal_gradient / (1 + normal_gradient * normal_gradient)     c2 = (1 - normal_gradient * normal_gradient) / (         1 + normal_gradient * normal_gradient     )     outgoing_gradient = (s2 - c2 * incoming_gradient) / (c2 + s2 * incoming_gradient)      # to find the next point, solve the simultaeneous equations:     # y^2 + 4x^2 = 100     # y - b = m * (x - a)     # ==> A x^2 + B x + C = 0     quadratic_term = outgoing_gradient**2 + 4     linear_term = 2 * outgoing_gradient * (point_y - outgoing_gradient * point_x)     constant_term = (point_y - outgoing_gradient * point_x) ** 2 - 100      x_minus = (         -linear_term - sqrt(linear_term**2 - 4 * quadratic_term * constant_term)     ) / (2 * quadratic_term)     x_plus = (         -linear_term + sqrt(linear_term**2 - 4 * quadratic_term * constant_term)     ) / (2 * quadratic_term)      # two solutions, one of which is our input point     next_x = x_minus if isclose(x_plus, point_x) else x_plus     next_y = point_y + outgoing_gradient * (next_x - point_x)      return next_x, next_y, outgoing_gradient\n1: def decompress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         lexicon[curr_string] = last_match_id + \"0\"          if math.log2(index).is_integer():             new_lex = {}             for curr_key in list(lexicon):                 new_lex[\"0\" + curr_key] = lexicon.pop(curr_key)             lexicon = new_lex          lexicon[bin(index)[2:]] = last_match_id + \"1\"         index += 1         curr_string = \"\"     return result\n2: def generate_parameters(formula: Formula) -> tuple[list[Clause], list[str]]:     clauses = formula.clauses     symbols_set = []     for clause in formula.clauses:         for literal in clause.literals:             symbol = literal[:2]             if symbol not in symbols_set:                 symbols_set.append(symbol)     return clauses, symbols_set", "output": "2"}
{"task": "search", "input": "search code:\nCalculate IMPLY of the input values\n\nChoices:\n0: def calculate_turnaround_times(     duration_times: list[int], waiting_times: list[int] ) -> list[int]:     return [         duration_time + waiting_times[i]         for i, duration_time in enumerate(duration_times)     ]\n1: def matrix_pow_np(m: ndarray, power: int) -> ndarray:     result = np.array([[1, 0], [0, 1]], dtype=int)  # Identity Matrix     base = m     if power < 0:  # Negative power is not allowed         raise ValueError(\"power is negative\")     while power:         if power % 2 == 1:             result = np.dot(result, base)         base = np.dot(base, base)         power //= 2     return result\n2: def imply_gate(input_1: int, input_2: int) -> int:     return int(input_1 == 0 or input_2 == 1)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef calculate_waiting_times(burst_times: List[int]) -> List[int]:\r\n    \"\"\"\r\n    Calculate the waiting times of a list of processes that have a specified duration.\r\n\r\n    Return: The waiting time for each process.\r\n    >>> calculate_waiting_times([10, 5, 8])\r\n    [13, 10, 13]\r\n    >>> calculate_waiting_times([4, 6, 3, 1])\r\n    [5, 8, 9, 6]\r\n    >>> calculate_waiting_times([12, 2, 10])\r\n    [12, 2, 12]\r\n    \"\"\"\r\n    quantum = 2\r\n    rem_burst_times = list(burst_times)\r\n    waiting_times = [0] * len(burst_times)\r\n    t = 0\r\n    while True:\r\n        done = True\r\n        for i, burst_time in enumerate(burst_times):\r\n            if rem_burst_times[i] > 0:\r\n                done = False\r\n                if rem_burst_times[i] > quantum:\r\n                    t += quantum\r\n                    rem_burst_times[i] -= quantum\r\n                else:\r\n                    t += rem_burst_times[i]\r\n                    waiting_times[i] = t - burst_time\r\n                    rem_burst_times[i] = 0\r\n        if done is True:\r\n            return waiting_times\r", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nConvert an Octal number to Binary.\n\nChoices:\n0: def octal_to_binary(octal_number: str) -> str:     if not octal_number:         raise ValueError(\"Empty string was passed to the function\")      binary_number = \"\"     octal_digits = \"01234567\"     for digit in octal_number:         if digit not in octal_digits:             raise ValueError(\"Non-octal value was passed to the function\")          binary_digit = \"\"         value = int(digit)         for _ in range(3):             binary_digit = str(value % 2) + binary_digit             value //= 2         binary_number += binary_digit      return binary_number\n1: def solution(min_block_length: int = 50) -> int:      fill_count_functions = [1] * min_block_length      for n in count(min_block_length):         fill_count_functions.append(1)          for block_length in range(min_block_length, n + 1):             for block_start in range(n - block_length):                 fill_count_functions[n] += fill_count_functions[                     n - block_start - block_length - 1                 ]              fill_count_functions[n] += 1          if fill_count_functions[n] > 1_000_000:             break      return n\n2: def encrypt(input_string: str, key: int) -> str:     temp_grid: list[list[str]] = [[] for _ in range(key)]     lowest = key - 1      if key <= 0:         raise ValueError(\"Height of grid can't be 0 or negative\")     if key == 1 or len(input_string) <= key:         return input_string      for position, character in enumerate(input_string):         num = position % (lowest * 2)  # puts it in bounds         num = min(num, lowest * 2 - num)  # creates zigzag pattern         temp_grid[num].append(character)     grid = [\"\".join(row) for row in temp_grid]     output_string = \"\".join(grid)      return output_string", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef main():\n\n    array = [30, 35, 15, 5, 10, 20, 25]\n    n = len(array)\n\n    matrix, optimal_solution = matrix_chain_order(array)\n\n    print(\"No. of Operation required: \" + str(matrix[1][n - 1]))\n    print_optimal_solution(optimal_solution, 1, n - 1)", "output": "Size of matrix created from array [30, 35, 15, 5, 10, 20, 25] will be:"}
{"task": "search", "input": "search code:\nReads given file as bytes and returns them as a long string\n\nChoices:\n0: def read_file_binary(file_path: str) -> str:     result = \"\"     try:         with open(file_path, \"rb\") as binary_file:             data = binary_file.read()         for dat in data:             curr_byte = f\"{dat:08b}\"             result += curr_byte         return result     except OSError:         print(\"File not accessible\")         sys.exit()\n1: def msd_radix_sort_inplace(list_of_ints: list[int]):      length = len(list_of_ints)     if not list_of_ints or length == 1:         return      if min(list_of_ints) < 0:         raise ValueError(\"All numbers must be positive\")      most_bits = max(len(bin(x)[2:]) for x in list_of_ints)     _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)\n2: def contains_an_even_digit(n: int) -> bool:     return any(digit in \"02468\" for digit in str(n))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef slugify(text, delim='_', lower=True, ascii=False):\n    ret = delim.join(split_punct_ws(text)) or delim if text else ''\n    if ascii:\n        ret = asciify(ret)\n    if lower:\n        ret = ret.lower()\n    return ret", "output": "A basic function that turns text full of scary characters"}
{"task": "detection", "input": "classify code:\ndef minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef calculate_probabilities(instance_count: int, total_count: int) -> float:\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count", "output": "Calculate the probability that a given instance will belong to which class"}
{"task": "summary", "input": "summarize code:\ndef random_vector(n: int, a: int, b: int) -> Vector:\n    random.seed(None)\n    ans = [random.randint(a, b) for _ in range(n)]\n    return Vector(ans)", "output": "input: size (N) of the vector."}
{"task": "search", "input": "search code:\nReturns the horizontal distance that the object cover\n\nChoices:\n0: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]\n1: def horizontal_distance(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(2 * angle)     return round(init_velocity**2 * sin(radians) / g, 2)\n2: def zigzag(root: Node | None) -> Generator[int]:     if root is None:         return      flag = 0     height_tree = height(root)      for h in range(1, height_tree + 1):         if not flag:             yield from get_nodes_from_left_to_right(root, h)             flag = 1         else:             yield from get_nodes_from_right_to_left(root, h)             flag = 0", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef dynamic_lucas_number(n_th_number: int) -> int:\n    if not isinstance(n_th_number, int):\n        raise TypeError(\"dynamic_lucas_number accepts only integer arguments.\")\n    a, b = 2, 1\n    for _ in range(n_th_number):\n        a, b = b, a + b\n    return a", "output": "Returns the nth lucas number"}
{"task": "summary", "input": "summarize code:\ndef can_complete_journey(gas_stations: tuple[GasStation, ...]) -> int:\n    total_gas = sum(gas_station.gas_quantity for gas_station in gas_stations)\n    total_cost = sum(gas_station.cost for gas_station in gas_stations)\n    if total_gas < total_cost:\n        return -1\n\n    start = 0\n    net = 0\n    for i, gas_station in enumerate(gas_stations):\n        net += gas_station.gas_quantity - gas_station.cost\n        if net < 0:\n            start = i + 1\n            net = 0\n    return start", "output": "This function returns the index from which to start the journey"}
{"task": "summary", "input": "summarize code:\ndef solution(nth: int = 10001) -> int:\n\n    try:\n        nth = int(nth)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter nth must be int or castable to int.\") from None\n    if nth <= 0:\n        raise ValueError(\"Parameter nth must be greater than or equal to one.\")\n    primes: list[int] = []\n    num = 2\n    while len(primes) < nth:\n        if is_prime(num):\n            primes.append(num)\n            num += 1\n        else:\n            num += 1\n    return primes[len(primes) - 1]", "output": "Returns the n-th prime number."}
{"task": "summary", "input": "summarize code:\ndef builtin_voltage(\n    donor_conc: float,  # donor concentration\n    acceptor_conc: float,  # acceptor concentration\n    intrinsic_conc: float,  # intrinsic concentration\n) -> float:\n\n    if donor_conc <= 0:\n        raise ValueError(\"Donor concentration should be positive\")\n    elif acceptor_conc <= 0:\n        raise ValueError(\"Acceptor concentration should be positive\")\n    elif intrinsic_conc <= 0:\n        raise ValueError(\"Intrinsic concentration should be positive\")\n    elif donor_conc <= intrinsic_conc:\n        raise ValueError(\n            \"Donor concentration should be greater than intrinsic concentration\"\n        )\n    elif acceptor_conc <= intrinsic_conc:\n        raise ValueError(\n            \"Acceptor concentration should be greater than intrinsic concentration\"\n        )\n    else:\n        return (\n            Boltzmann\n            * T\n            * log((donor_conc * acceptor_conc) / intrinsic_conc**2)\n            / physical_constants[\"electron volt\"][0]\n        )", "output": "This function can calculate the Builtin Voltage of a pn junction diode."}
{"task": "search", "input": "search code:\nImplementation of a start algorithm.\n\nChoices:\n0: def astar(world, start, goal):     _open = []     _closed = []     _open.append(start)      while _open:         min_f = np.argmin([n.f for n in _open])         current = _open[min_f]         _closed.append(_open.pop(min_f))         if current == goal:             break         for n in world.get_neighbours(current):             for c in _closed:                 if c == n:                     continue             n.g = current.g + 1             x1, y1 = n.position             x2, y2 = goal.position             n.h = (y2 - y1) ** 2 + (x2 - x1) ** 2             n.f = n.h + n.g              for c in _open:                 if c == n and c.f < n.f:                     continue             _open.append(n)     path = []     while current.parent is not None:         path.append(current.position)         current = current.parent     path.append(current.position)     return path[::-1]\n1: def length_conversion(value: float, from_type: str, to_type: str) -> float:      from_sanitized = from_type.lower().strip(\"s\")     to_sanitized = to_type.lower().strip(\"s\")      from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)     to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)      if from_sanitized not in METRIC_CONVERSION:         msg = (             f\"Invalid 'from_type' value: {from_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     if to_sanitized not in METRIC_CONVERSION:         msg = (             f\"Invalid 'to_type' value: {to_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     from_exponent = METRIC_CONVERSION[from_sanitized]     to_exponent = METRIC_CONVERSION[to_sanitized]     exponent = 1      if from_exponent > to_exponent:         exponent = from_exponent - to_exponent     else:         exponent = -(to_exponent - from_exponent)      return value * pow(10, exponent)\n2: def nth_permutation(iterable, r, index):     pool = list(iterable)     n = len(pool)      if r is None or r == n:         r, c = n, factorial(n)     elif not 0 <= r < n:         raise ValueError     else:         c = perm(n, r)     assert c > 0  # factorial(n)>0, and r<n so perm(n,r) is never zero      if index < 0:         index += c      if not 0 <= index < c:         raise IndexError      result = [0] * r     q = index * factorial(n) // c if r < n else index     for d in range(1, n + 1):         q, i = divmod(q, d)         if 0 <= n - d < r:             result[n - d] = i         if q == 0:             break      return tuple(map(pool.pop, result))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    print(\"\\n2 in octal is:\")\n    print(decimal_to_octal(2))  # = 2\n    print(\"\\n8 in octal is:\")\n    print(decimal_to_octal(8))  # = 10\n    print(\"\\n65 in octal is:\")\n    print(decimal_to_octal(65))  # = 101\n    print(\"\\n216 in octal is:\")\n    print(decimal_to_octal(216))  # = 330\n    print(\"\\n512 in octal is:\")\n    print(decimal_to_octal(512))  # = 1000\n    print(\"\\n\")", "output": "Print octal equivalents of decimal numbers."}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def solution(max_base: int = 10, max_power: int = 22) -> int:     bases = range(1, max_base)     powers = range(1, max_power)     return sum(         1 for power in powers for base in bases if len(str(base**power)) == power     )\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def solution(n: int = 1000000) -> int:     largest_number = 1     pre_counter = 1     counters = {1: 1}      for input1 in range(2, n):         counter = 0         number = input1          while True:             if number in counters:                 counter += counters[number]                 break             if number % 2 == 0:                 number //= 2                 counter += 1             else:                 number = (3 * number) + 1                 counter += 1          if input1 not in counters:             counters[input1] = counter          if counter > pre_counter:             largest_number = input1             pre_counter = counter     return largest_number", "output": "1"}
{"task": "search", "input": "search code:\nReturns the number of numbers below number_limit that produce chains with exactly\n\nChoices:\n0: def radix_sort(list_of_ints: list[int]) -> list[int]:     placement = 1     max_digit = max(list_of_ints)     while placement <= max_digit:         # declare and initialize empty buckets         buckets: list[list] = [[] for _ in range(RADIX)]         # split list_of_ints between the buckets         for i in list_of_ints:             tmp = int((i / placement) % RADIX)             buckets[tmp].append(i)         # put each buckets' contents into list_of_ints         a = 0         for b in range(RADIX):             for i in buckets[b]:                 list_of_ints[a] = i                 a += 1         # move to next         placement *= RADIX     return list_of_ints\n1: def mobius(n: int) -> int:     factors = prime_factors(n)     if is_square_free(factors):         return -1 if len(factors) % 2 else 1     return 0\n2: def solution(chain_length: int = 60, number_limit: int = 1000000) -> int:      if not isinstance(chain_length, int) or not isinstance(number_limit, int):         raise TypeError(\"Parameters chain_length and number_limit must be int\")      if chain_length <= 0 or number_limit <= 0:         raise ValueError(             \"Parameters chain_length and number_limit must be greater than 0\"         )      # the counter for the chains with the exact desired length     chains_counter = 0     # the cached sizes of the previous chains     chain_sets_lengths: dict[int, int] = {}      for start_chain_element in range(1, number_limit):         # The temporary set will contain the elements of the chain         chain_set = set()         chain_set_length = 0          # Stop computing the chain when you find a cached size, a repeating item or the         # length is greater then the desired one.         chain_element = start_chain_element         while (             chain_element not in chain_sets_lengths             and chain_element not in chain_set             and chain_set_length <= chain_length         ):             chain_set.add(chain_element)             chain_set_length += 1             chain_element = digit_factorial_sum(chain_element)          if chain_element in chain_sets_lengths:             chain_set_length += chain_sets_lengths[chain_element]          chain_sets_lengths[start_chain_element] = chain_set_length          # If chain contains the exact amount of elements increase the counter         if chain_set_length == chain_length:             chains_counter += 1      return chains_counter", "output": "2"}
{"task": "search", "input": "search code:\nFinds the smallest element of longest chain\n\nChoices:\n0: def noop(*args, **kwargs):     return None\n1: def find_longest_chain(chain: list[int], max_num: int) -> int:      max_len = 0     min_elem = 0     for start in range(2, len(chain)):         visited = {start}         elem = chain[start]         length = 1          while elem > 1 and elem <= max_num and elem not in visited:             visited.add(elem)             elem = chain[elem]             length += 1          if elem == start and length > max_len:             max_len = length             min_elem = start      return min_elem\n2: def solution(num: int = 100) -> int:     fact = 1     result = 0     for i in range(1, num + 1):         fact *= i      for j in str(fact):         result += int(j)      return result", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None", "output": "def find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None"}
{"task": "search", "input": "search code:\nUses decrypt function by guessing every key\n\nChoices:\n0: def bruteforce(input_string: str) -> dict[int, str]:     results = {}     for key_guess in range(1, len(input_string)):  # tries every key         results[key_guess] = decrypt(input_string, key_guess)     return results\n1: def main():     print(\"Volumes:\")     print(f\"Cube: {vol_cube(2) = }\")  # = 8     print(f\"Cuboid: {vol_cuboid(2, 2, 2) = }\")  # = 8     print(f\"Cone: {vol_cone(2, 2) = }\")  # ~= 1.33     print(f\"Right Circular Cone: {vol_right_circ_cone(2, 2) = }\")  # ~= 8.38     print(f\"Prism: {vol_prism(2, 2) = }\")  # = 4     print(f\"Pyramid: {vol_pyramid(2, 2) = }\")  # ~= 1.33     print(f\"Sphere: {vol_sphere(2) = }\")  # ~= 33.5     print(f\"Hemisphere: {vol_hemisphere(2) = }\")  # ~= 16.75     print(f\"Circular Cylinder: {vol_circular_cylinder(2, 2) = }\")  # ~= 25.1     print(f\"Torus: {vol_torus(2, 2) = }\")  # ~= 157.9     print(f\"Conical Frustum: {vol_conical_frustum(2, 2, 4) = }\")  # ~= 58.6     print(f\"Spherical cap: {vol_spherical_cap(1, 2) = }\")  # ~= 5.24     print(f\"Spheres intersection: {vol_spheres_intersect(2, 2, 1) = }\")  # ~= 21.21     print(f\"Spheres union: {vol_spheres_union(2, 2, 1) = }\")  # ~= 45.81     print(         f\"Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }\"     )  # ~= 28.3     print(f\"Icosahedron: {vol_icosahedron(2.5) = }\")  # ~=34.09\n2: def can_complete_journey(gas_stations: tuple[GasStation, ...]) -> int:     total_gas = sum(gas_station.gas_quantity for gas_station in gas_stations)     total_cost = sum(gas_station.cost for gas_station in gas_stations)     if total_gas < total_cost:         return -1      start = 0     net = 0     for i, gas_station in enumerate(gas_stations):         net += gas_station.gas_quantity - gas_station.cost         if net < 0:             start = i + 1             net = 0     return start", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef runge_kutta_gills(\n    func: Callable[[float, float], float],\n    x_initial: float,\n    y_initial: float,\n    step_size: float,\n    x_final: float,\n) -> np.ndarray:\n    if x_initial >= x_final:\n        raise ValueError(\n            \"The final value of x must be greater than initial value of x.\"\n        )\n\n    if step_size <= 0:\n        raise ValueError(\"Step size must be positive.\")\n\n    n = int((x_final - x_initial) / step_size)\n    y = np.zeros(n + 1)\n    y[0] = y_initial\n    for i in range(n):\n        k1 = step_size * func(x_initial, y[i])\n        k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)\n        k3 = step_size * func(\n            x_initial + step_size / 2,\n            y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,\n        )\n        k4 = step_size * func(\n            x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3\n        )\n\n        y[i + 1] = y[i] + (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4) / 6\n        x_initial += step_size\n    return y", "output": "Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4."}
{"task": "summary", "input": "summarize code:\ndef graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:\n\n    if len(points) <= 2:\n        # There is no convex hull\n        raise ValueError(\"graham_scan: argument must contain more than 3 points.\")\n    if len(points) == 3:\n        return points\n    # find the lowest and the most left point\n    minidx = 0\n    miny, minx = maxsize, maxsize\n    for i, point in enumerate(points):\n        x = point[0]\n        y = point[1]\n        if y < miny:\n            miny = y\n            minx = x\n            minidx = i\n        if y == miny and x < minx:\n            minx = x\n            minidx = i\n\n    # remove the lowest and the most left point from points for preparing for sort\n    points.pop(minidx)\n\n    sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))\n    # This insert actually costs complexity,\n    # and you should instead add (minx, miny) into stack later.\n    # I'm using insert just for easy understanding.\n    sorted_points.insert(0, (minx, miny))\n\n    stack: deque[tuple[int, int]] = deque()\n    stack.append(sorted_points[0])\n    stack.append(sorted_points[1])\n    stack.append(sorted_points[2])\n    # The first 3 points lines are towards the left because we sort them by their angle\n    # from minx, miny.\n    current_direction = Direction.left\n\n    for i in range(3, len(sorted_points)):\n        while True:\n            starting = stack[-2]\n            via = stack[-1]\n            target = sorted_points[i]\n            next_direction = check_direction(starting, via, target)\n\n            if next_direction == Direction.left:\n                current_direction = Direction.left\n                break\n            if next_direction == Direction.straight:\n                if current_direction == Direction.left:\n                    # We keep current_direction as left.\n                    # Because if the straight line keeps as straight,\n                    # we want to know if this straight line is towards left.\n                    break\n                elif current_direction == Direction.right:\n                    # If the straight line is towards right,\n                    # every previous points on that straight line is not convex hull.\n                    stack.pop()\n            if next_direction == Direction.right:\n                stack.pop()\n        stack.append(sorted_points[i])\n    return list(stack)", "output": "Pure implementation of graham scan algorithm in Python"}
{"task": "repair", "input": "fix bug:\ndef real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor", "output": "def real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor"}
{"task": "detection", "input": "classify code:\ndef strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nThis function returns a clone of a connected undirected graph.\n\nChoices:\n0: def prime_generator():      num = 2     while True:         if is_prime(num):             yield num         num += 1\n1: def clone_graph(node: Node | None) -> Node | None:     if not node:         return None      originals_to_clones = {}  # map nodes to clones      stack = [node]      while stack:         original = stack.pop()          if original in originals_to_clones:             continue          originals_to_clones[original] = Node(original.value)          stack.extend(original.neighbors or [])      for original, clone in originals_to_clones.items():         for neighbor in original.neighbors or []:             cloned_neighbor = originals_to_clones[neighbor]              if not clone.neighbors:                 clone.neighbors = []              clone.neighbors.append(cloned_neighbor)      return originals_to_clones[node]\n2: def horn_schunck(     image0: np.ndarray,     image1: np.ndarray,     num_iter: SupportsIndex,     alpha: float | None = None, ) -> tuple[np.ndarray, np.ndarray]:     if alpha is None:         alpha = 0.1      # Initialize flow     horizontal_flow = np.zeros_like(image0)     vertical_flow = np.zeros_like(image0)      # Prepare kernels for the calculation of the derivatives and the average velocity     kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25     kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25     kernel_t = np.array([[1, 1], [1, 1]]) * 0.25     kernel_laplacian = np.array(         [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]     )      # Iteratively refine the flow     for _ in range(num_iter):         warped_image = warp(image0, horizontal_flow, vertical_flow)         derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)         derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)         derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)          avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)         avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)          # This updates the flow as proposed in the paper (Step 12)         update = (             derivative_x * avg_horizontal_velocity             + derivative_y * avg_vertical_velocity             + derivative_t         )         update = update / (alpha**2 + derivative_x**2 + derivative_y**2)          horizontal_flow = avg_horizontal_velocity - derivative_x * update         vertical_flow = avg_vertical_velocity - derivative_y * update      return horizontal_flow, vertical_flow", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0", "output": "def luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0"}
{"task": "summary", "input": "summarize code:\ndef vol_spherical_cap(height: float, radius: float) -> float:\n    if height < 0 or radius < 0:\n        raise ValueError(\"vol_spherical_cap() only accepts non-negative values\")\n    # Volume is 1/3 pi * height squared * (3 * radius - height)\n    return 1 / 3 * pi * pow(height, 2) * (3 * radius - height)", "output": "Calculate the volume of the spherical cap."}
{"task": "detection", "input": "classify code:\ndef prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef linear_search(sequence: list, target: int) -> int:\n    \"\"\"A pure Python implementation of a linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return -1", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:\n\n    # Base Case\n    if curr_ind == len(graph):\n        # return whether path exists between current and starting vertices\n        return graph[path[curr_ind - 1]][path[0]] == 1\n\n    # Recursive Step\n    for next_ver in range(len(graph)):\n        if valid_connection(graph, next_ver, curr_ind, path):\n            # Insert current vertex  into path as next transition\n            path[curr_ind] = next_ver\n            # Validate created path\n            if util_hamilton_cycle(graph, path, curr_ind + 1):\n                return True\n            # Backtrack\n            path[curr_ind] = -1\n    return False", "output": "Pseudo-Code"}
{"task": "repair", "input": "fix bug:\ndef _msd_radix_sort(list_of_ints: List[int], bit_position: int) -> List[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res", "output": "def _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res"}
{"task": "repair", "input": "fix bug:\ndef gnome_sort(unsorted):\n    \"\"\"Pure implementation of the gnome sort algorithm in Python.\"\"\"\n    if len(unsorted) <= 1:\n        return unsorted\n\n    i = 1\n\n    while i < len(unsorted):\n        if unsorted[i - 1] <= unsorted[i]:\n            i += 1\n        else:\n            unsorted[i - 1], unsorted[i] = unsorted[i], unsorted[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1", "output": "def gnome_sort(lst: list) -> list:\n    \"\"\"\n    Pure implementation of the gnome sort algorithm in Python\n\n    Take some mutable ordered collection with heterogeneous comparable items inside as\n    arguments, return the same collection ordered by ascending.\n\n    Examples:\n    >>> gnome_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> gnome_sort([])\n    []\n\n    >>> gnome_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    >>> \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\"))))\n    ' !Gadeimnoprstu'\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n\n    i = 1\n\n    while i < len(lst):\n        if lst[i - 1] <= lst[i]:\n            i += 1\n        else:\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1\n\n    return lst"}
{"task": "detection", "input": "classify code:\ndef naive_pattern_search(s: str, pattern: str) -> list:\n    \"\"\"\n    >>> naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\")\n    [4, 10, 18]\n    >>> naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\")\n    []\n    >>> naive_pattern_search(\"\", \"ABC\")\n    []\n    >>> naive_pattern_search(\"TEST\", \"TEST\")\n    [0]\n    >>> naive_pattern_search(\"ABCDEGFTEST\", \"TEST\")\n    [7]\n    \"\"\"\n    pat_len = len(pattern)\n    position = []\n    for i in range(len(s) - pat_len + 1):\n        match_found = True\n        for j in range(pat_len):\n            if s[i + j] != pattern[j]:\n                match_found = False\n                break\n        if match_found:\n            position.append(i)\n    return position", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculates the speed of sound in a fluid from its density and bulk modulus\n\nChoices:\n0: def speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:      if density <= 0:         raise ValueError(\"Impossible fluid density\")     if bulk_modulus <= 0:         raise ValueError(\"Impossible bulk modulus\")      return (bulk_modulus / density) ** 0.5\n1: def swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:     return vector * sigmoid(trainable_parameter * vector)\n2: def md_prefix(indent: int) -> str:     return f\"{indent * '  '}*\" if indent else \"\\n##\"", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef format_exp_repr(obj, pos_names, req_names=None, opt_names=None, opt_key=None):\n    cn = type(obj).__name__\n    req_names = req_names or []\n    opt_names = opt_names or []\n    uniq_names, all_names = set(), []\n    for name in req_names + opt_names:\n        if name in uniq_names:\n            continue\n        uniq_names.add(name)\n        all_names.append(name)\n\n    if opt_key is None:\n        opt_key = lambda v: v is None\n    assert callable(opt_key)\n\n    args = [getattr(obj, name, None) for name in pos_names]\n\n    kw_items = [(name, getattr(obj, name, None)) for name in all_names]\n    kw_items = [(name, val) for name, val in kw_items\n                if not (name in opt_names and opt_key(val))]\n\n    return format_invocation(cn, args, kw_items)", "output": "Render an expression-style repr of an object, based on attribute"}
{"task": "summary", "input": "summarize code:\ndef approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value", "output": "Utility-function to check that two hsv-colors are approximately equal"}
{"task": "search", "input": "search code:\nMake x as a set.\n\nChoices:\n0: def evaluate_poly(poly: Sequence[float], x: float) -> float:     return sum(c * (x**i) for i, c in enumerate(poly))\n1: def make_set(x: Node) -> None:     # rank is the distance from x to its' parent     # root's rank is 0     x.rank = 0     x.parent = x\n2: def solution(percent: float = 99) -> int:     if not 0 < percent < 100:         raise ValueError(\"solution() only accepts values from 0 to 100\")     bouncy_num = 0     num = 1      while True:         if check_bouncy(num):             bouncy_num += 1         if (bouncy_num / num) * 100 >= percent:             return num         num += 1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef surface_area_hemisphere(radius: float) -> float:\n    if radius < 0:\n        raise ValueError(\"surface_area_hemisphere() only accepts non-negative values\")\n    return 3 * pi * radius**2", "output": "Calculate the Surface Area of a Hemisphere."}
{"task": "summary", "input": "summarize code:\ndef _construct_hull(\n    points: list[Point], left: Point, right: Point, convex_set: set[Point]\n) -> None:\n    if points:\n        extreme_point = None\n        extreme_point_distance = float(\"-inf\")\n        candidate_points = []\n\n        for p in points:\n            det = _det(left, right, p)\n\n            if det > 0:\n                candidate_points.append(p)\n\n                if det > extreme_point_distance:\n                    extreme_point_distance = det\n                    extreme_point = p\n\n        if extreme_point:\n            _construct_hull(candidate_points, left, extreme_point, convex_set)\n            convex_set.add(extreme_point)\n            _construct_hull(candidate_points, extreme_point, right, convex_set)", "output": "Parameters"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n\n    a = 1\n    b = 1\n    c = 2\n    # temporary Fibonacci numbers\n\n    a1 = 1\n    b1 = 1\n    c1 = 2\n    # temporary Fibonacci numbers mod 1e9\n\n    # mod m=1e9, done for fast optimisation\n    tocheck = [0] * 1000000\n    m = 1000000000\n\n    for x in range(1000000):\n        c1 = (a1 + b1) % m\n        a1 = b1 % m\n        b1 = c1 % m\n        if check1(b1):\n            tocheck[x + 3] = 1\n\n    for x in range(1000000):\n        c = a + b\n        a = b\n        b = c\n        # perform check only if in tocheck\n        if tocheck[x + 3] and check(b):\n            return x + 3  # first 2 already done\n    return -1", "output": "Outputs the answer is the least Fibonacci number pandigital from both sides."}
{"task": "detection", "input": "classify code:\ndef is_pangram_fastest(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_fastest()\n    True\n    \"\"\"\n    return len({char for char in input_str.lower() if char.isalpha()}) == 26", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef catalan_numbers(upper_limit: int) -> \"list[int]\":\n    if upper_limit < 0:\n        raise ValueError(\"Limit for the Catalan sequence must be  0\")\n\n    catalan_list = [0] * (upper_limit + 1)\n\n    # Base case: C(0) = C(1) = 1\n    catalan_list[0] = 1\n    if upper_limit > 0:\n        catalan_list[1] = 1\n\n    # Recurrence relation: C(i) = sum(C(j).C(i-j-1)), from j = 0 to i\n    for i in range(2, upper_limit + 1):\n        for j in range(i):\n            catalan_list[i] += catalan_list[j] * catalan_list[i - j - 1]\n\n    return catalan_list", "output": "Return a list of the Catalan number sequence from 0 through `upper_limit`."}
{"task": "summary", "input": "summarize code:\ndef prim_heap(graph: list, root: Vertex) -> Iterator[tuple]:\n    for u in graph:\n        u.key = math.inf\n        u.pi = None\n    root.key = 0\n\n    h = list(graph)\n    hq.heapify(h)\n\n    while h:\n        u = hq.heappop(h)\n        for v in u.neighbors:\n            if (v in h) and (u.edges[v.id] < v.key):\n                v.pi = u\n                v.key = u.edges[v.id]\n                hq.heapify(h)\n\n    for i in range(1, len(graph)):\n        yield (int(graph[i].id) + 1, int(graph[i].pi.id) + 1)", "output": "Prim's Algorithm with min heap."}
{"task": "detection", "input": "classify code:\ndef sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    \"\"\"\n    res = 0\n    while n > 0:\n        res += n % 10\n        n = n // 10\n    return res", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef total_frequency_distribution(sides_number: int, dice_number: int) -> list[int]:\n\n    max_face_number = sides_number\n    max_total = max_face_number * dice_number\n    totals_frequencies = [0] * (max_total + 1)\n\n    min_face_number = 1\n    faces_numbers = range(min_face_number, max_face_number + 1)\n    for dice_numbers in product(faces_numbers, repeat=dice_number):\n        total = sum(dice_numbers)\n        totals_frequencies[total] += 1\n\n    return totals_frequencies", "output": "Returns frequency distribution of total"}
{"task": "summary", "input": "summarize code:\ndef solution(num_turns: int = 15) -> int:\n    total_prob: float = 0.0\n    prob: float\n    num_blue: int\n    num_red: int\n    ind: int\n    col: int\n    series: tuple[int, ...]\n\n    for series in product(range(2), repeat=num_turns):\n        num_blue = series.count(1)\n        num_red = num_turns - num_blue\n        if num_red >= num_blue:\n            continue\n        prob = 1.0\n        for ind, col in enumerate(series, 2):\n            if col == 0:\n                prob *= (ind - 1) / ind\n            else:\n                prob *= 1 / ind\n\n        total_prob += prob\n\n    return int(1 / total_prob)", "output": "Find the maximum prize fund that should be allocated to a single game in which"}
{"task": "summary", "input": "summarize code:\ndef stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):\n    children = tee(iterable, len(offsets))\n\n    return zip_offset(\n        *children, offsets=offsets, longest=longest, fillvalue=fillvalue\n    )", "output": "Yield tuples whose elements are offset from *iterable*."}
{"task": "search", "input": "search code:\nReturn the number of times that the beam hits the interior wall of the\n\nChoices:\n0: def calculate_waiting_times(burst_times: list[int]) -> list[int]:     quantum = 2     rem_burst_times = list(burst_times)     waiting_times = [0] * len(burst_times)     t = 0     while True:         done = True         for i, burst_time in enumerate(burst_times):             if rem_burst_times[i] > 0:                 done = False                 if rem_burst_times[i] > quantum:                     t += quantum                     rem_burst_times[i] -= quantum                 else:                     t += rem_burst_times[i]                     waiting_times[i] = t - burst_time                     rem_burst_times[i] = 0         if done is True:             return waiting_times\n1: def filter_common_word(possibles: list[str], common_word: str) -> list[str]:     return [possible for possible in possibles if common_word in possible.lower()]\n2: def solution(first_x_coord: float = 1.4, first_y_coord: float = -9.6) -> int:     num_reflections: int = 0     point_x: float = first_x_coord     point_y: float = first_y_coord     gradient: float = (10.1 - point_y) / (0.0 - point_x)      while not (-0.01 <= point_x <= 0.01 and point_y > 0):         point_x, point_y, gradient = next_point(point_x, point_y, gradient)         num_reflections += 1      return num_reflections", "output": "2"}
{"task": "detection", "input": "classify code:\ndef partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in xrange(m)] for _ in xrange(m + 1)]\n    for i in xrange(m + 1):\n        memo[i][0] = 1\n\n    for n in xrange(m + 1):\n        for k in xrange(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef subdict(d, keep=None, drop=None):\n    if keep is None:\n        keep = d.keys()\n    if drop is None:\n        drop = []\n\n    keys = set(keep) - set(drop)\n\n    return type(d)([(k, v) for k, v in d.items() if k in keys])", "output": "Compute the \"subdictionary\" of a dict, *d*."}
{"task": "search", "input": "search code:\n- label_dir <type: str>: Path to label include annotation of images\n\nChoices:\n0: def get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:     img_paths = []     labels = []     for label_file in glob.glob(os.path.join(label_dir, \"*.txt\")):         label_name = label_file.split(os.sep)[-1].rsplit(\".\", 1)[0]         with open(label_file) as in_file:             obj_lists = in_file.readlines()         img_path = os.path.join(img_dir, f\"{label_name}.jpg\")          boxes = []         for obj_list in obj_lists:             obj = obj_list.rstrip(\"\\n\").split(\" \")             boxes.append(                 [                     int(obj[0]),                     float(obj[1]),                     float(obj[2]),                     float(obj[3]),                     float(obj[4]),                 ]             )         if not boxes:             continue         img_paths.append(img_path)         labels.append(boxes)     return img_paths, labels\n1: def unique_everseen(iterable, key=None):     seenset = set()     seenset_add = seenset.add     seenlist = []     seenlist_add = seenlist.append     use_key = key is not None      for element in iterable:         k = key(element) if use_key else element         try:             if k not in seenset:                 seenset_add(k)                 yield element         except TypeError:             if k not in seenlist:                 seenlist_add(k)                 yield element\n2: def _create_spd_matrix(dimension: int) -> Any:     rng = np.random.default_rng()     random_matrix = rng.normal(size=(dimension, dimension))     spd_matrix = np.dot(random_matrix, random_matrix.T)     assert _is_matrix_spd(spd_matrix)     return spd_matrix", "output": "0"}
{"task": "search", "input": "search code:\nBenchmark the Levenshtein distance function.\n\nChoices:\n0: def score_function(     source_char: str,     target_char: str,     match: int = 1,     mismatch: int = -1,     gap: int = -2, ) -> int:     if \"-\" in (source_char, target_char):         return gap     return match if source_char == target_char else mismatch\n1: def printboard(board: list[list[int]]) -> None:     for i in range(len(board)):         for j in range(len(board)):             if board[i][j] == 1:                 print(\"Q\", end=\" \")  # Queen is present             else:                 print(\".\", end=\" \")  # Empty cell         print()\n2: def benchmark_levenshtein_distance(func: Callable) -> None:     from timeit import timeit      stmt = f\"{func.__name__}('sitting', 'kitten')\"     setup = f\"from __main__ import {func.__name__}\"     number = 25_000     result = timeit(stmt=stmt, setup=setup, number=number)     print(f\"{func.__name__:<30} finished {number:,} runs in {result:.5f} seconds\")", "output": "2"}
{"task": "detection", "input": "classify code:\ndef solve(nums: list[int], goal: int, depth: int) -> bool:\n    \"\"\"\n    Checks if nums can have a sum equal to goal, given that length of nums does\n    not exceed depth.\n\n    >>> solve([1], 2, 2)\n    True\n    >>> solve([1], 2, 0)\n    False\n    \"\"\"\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef text_to_bits(text, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_to_bits(\"msg\")\n    '011011010111001101100111'\n    \"\"\"\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \"big\"))[2:]\n    return bits.zfill(8 * ((len(bits) + 7) // 8))", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPrint the lower half of a diamond pattern with '*' characters.\n\nChoices:\n0: def reverse_floyd(n):     result = \"\"     for i in range(n, 0, -1):         for _ in range(i, 0, -1):  # printing stars             result += \"* \"         result += \"\\n\"         for _ in range(n - i + 1, 0, -1):  # printing spaces             result += \" \"     return result\n1: def benchmark() -> None:     from timeit import timeit      print(\"Running benchmarks\")     setup = (         \"from __main__ import count_negatives_binary_search, \"         \"count_negatives_brute_force, count_negatives_brute_force_with_break, grid\"     )     for func in (         \"count_negatives_binary_search\",  # took 0.7727 seconds         \"count_negatives_brute_force_with_break\",  # took 4.6505 seconds         \"count_negatives_brute_force\",  # took 12.8160 seconds     ):         time = timeit(f\"{func}(grid=grid)\", setup=setup, number=500)         print(f\"{func}() took {time:0.4f} seconds\")\n2: def _gettext_noop(message):     return message", "output": "0"}
{"task": "search", "input": "search code:\nComputes a^b % c recursively, where a is the base, b is the exponent, and c is the\n\nChoices:\n0: def multiplication_table(number: int, number_of_terms: int) -> str:     return \"\\n\".join(         f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)     )\n1: def matmul(m1, m2):     n = len(m2[0])     return batched(starmap(_sumprod, product(m1, transpose(m2))), n)\n2: def binary_exp_mod_recursive(base: float, exponent: int, modulus: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")     if modulus <= 0:         raise ValueError(\"Modulus must be a positive integer\")      if exponent == 0:         return 1      if exponent % 2 == 1:         return (binary_exp_mod_recursive(base, exponent - 1, modulus) * base) % modulus      r = binary_exp_mod_recursive(base, exponent // 2, modulus)     return (r * r) % modulus", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef pluperfect_number(n: int) -> bool:\n    if not isinstance(n, int) or n < 1:\n        return False\n\n    # Init a \"histogram\" of the digits\n    digit_histogram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    digit_total = 0\n    total = 0\n    temp = n\n    while temp > 0:\n        temp, rem = divmod(temp, 10)\n        digit_histogram[rem] += 1\n        digit_total += 1\n\n    for cnt, i in zip(digit_histogram, range(len(digit_histogram))):\n        total += cnt * i**digit_total\n\n    return n == total", "output": "Return True if n is a pluperfect number or False if it is not"}
{"task": "summary", "input": "summarize code:\ndef mark_ends(iterable):\n    it = iter(iterable)\n    for a in it:\n        first = True\n        for b in it:\n            yield first, False, a\n            a = b\n            first = False\n        yield first, True, a", "output": "Yield 3-tuples of the form ``(is_first, is_last, item)``."}
{"task": "summary", "input": "summarize code:\ndef calculate_mean(instance_count: int, items: list) -> float:\n    # the sum of all items divided by number of instances\n    return sum(items) / instance_count", "output": "Calculate given class mean"}
{"task": "search", "input": "search code:\nTake in 2 integers, convert them to binary, and return a binary number that is the\n\nChoices:\n0: def binary_or(a: int, b: int) -> str:     if a < 0 or b < 0:         raise ValueError(\"the value of both inputs must be positive\")     a_binary = str(bin(a))[2:]  # remove the leading \"0b\"     b_binary = str(bin(b))[2:]     max_len = max(len(a_binary), len(b_binary))     return \"0b\" + \"\".join(         str(int(\"1\" in (char_a, char_b)))         for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))     )\n1: def format_exp_repr(obj, pos_names, req_names=None, opt_names=None, opt_key=None):     cn = type(obj).__name__     req_names = req_names or []     opt_names = opt_names or []     uniq_names, all_names = set(), []     for name in req_names + opt_names:         if name in uniq_names:             continue         uniq_names.add(name)         all_names.append(name)      if opt_key is None:         opt_key = lambda v: v is None     assert callable(opt_key)      args = [getattr(obj, name, None) for name in pos_names]      kw_items = [(name, getattr(obj, name, None)) for name in all_names]     kw_items = [(name, val) for name, val in kw_items                 if not (name in opt_names and opt_key(val))]      return format_invocation(cn, args, kw_items)\n2: def sentinel_linear_search(sequence, target):     sequence.append(target)      index = 0     while sequence[index] != target:         index += 1      sequence.pop()      if index == len(sequence):         return None      return index", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(length: int = 50) -> int:\n\n    ways_number = [1] * (length + 1)\n\n    for row_length in range(3, length + 1):\n        for block_length in range(3, row_length + 1):\n            for block_start in range(row_length - block_length):\n                ways_number[row_length] += ways_number[\n                    row_length - block_start - block_length - 1\n                ]\n\n            ways_number[row_length] += 1\n\n    return ways_number[length]", "output": "Returns the number of ways a row of the given length can be filled"}
{"task": "summary", "input": "summarize code:\ndef generate_roman_numerals(num: int) -> str:\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals", "output": "Generates a string of roman numerals for a given integer."}
{"task": "summary", "input": "summarize code:\ndef all_unique(iterable, key=None):\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    for element in map(key, iterable) if key else iterable:\n        try:\n            if element in seenset:\n                return False\n            seenset_add(element)\n        except TypeError:\n            if element in seenlist:\n                return False\n            seenlist_add(element)\n    return True", "output": "Returns ``True`` if all the elements of *iterable* are unique (no two"}
{"task": "detection", "input": "classify code:\ndef check(binary: List[str]) -> List[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef fibonacci(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Negative arguments are not supported\")\n    return _fib(n)[0]", "output": "return F(n)"}
{"task": "detection", "input": "classify code:\ndef kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is mv\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef binary_search_insertion(sorted_list, item):\n    \"\"\"\n    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)\n    [1, 2, 4, 7, 9, 10]\n    \"\"\"\n    left = 0\n    right = len(sorted_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if left == right:\n            if sorted_list[middle] < item:\n                left = middle + 1\n            break\n        elif sorted_list[middle] < item:\n            left = middle + 1\n        else:\n            right = middle - 1\n    sorted_list.insert(left, item)\n    return sorted_list", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn the smallest integer that can be written as the sum of primes in over\n\nChoices:\n0: def format_exception_only(etype, value):     # Gracefully handle (the way Python 2.4 and earlier did) the case of     # being called with (None, None).     if etype is None:         return [_format_final_exc_line(etype, value)]      stype = etype.__name__     smod = etype.__module__     if smod not in (\"__main__\", \"builtins\", \"exceptions\"):         stype = smod + '.' + stype      if not issubclass(etype, SyntaxError):         return [_format_final_exc_line(stype, value)]      # It was a syntax error; show exactly where the problem was found.     lines = []     filename = value.filename or \"<string>\"     lineno = str(value.lineno) or '?'     lines.append(f'  File \"{filename}\", line {lineno}\\n')     badline = value.text     offset = value.offset     if badline is not None:         lines.append('    %s\\n' % badline.strip())         if offset is not None:             caretspace = badline.rstrip('\\n')[:offset].lstrip()             # non-space whitespace (likes tabs) must be kept for alignment             caretspace = ((c.isspace() and c or ' ') for c in caretspace)             # only three spaces to account for offset1 == pos 0             lines.append('   %s^\\n' % ''.join(caretspace))     msg = value.msg or \"<no detail available>\"     lines.append(f\"{stype}: {msg}\\n\")     return lines\n1: def nth_combination_with_replacement(iterable, r, index):     pool = tuple(iterable)     n = len(pool)     if (r < 0) or (r > n):         raise ValueError      c = comb(n + r - 1, r)      if index < 0:         index += c      if (index < 0) or (index >= c):         raise IndexError      result = []     i = 0     while r:         r -= 1         while n >= 0:             num_combs = comb(n + r - 1, r)             if index < num_combs:                 break             n -= 1             i += 1             index -= num_combs         result.append(pool[i])      return tuple(result)\n2: def solution(number_unique_partitions: int = 5000) -> int | None:     for number_to_partition in range(1, NUM_PRIMES):         if len(partition(number_to_partition)) > number_unique_partitions:             return number_to_partition     return None", "output": "2"}
{"task": "search", "input": "search code:\nA pure Python implementation of the heap sort algorithm\n\nChoices:\n0: def heap_sort(unsorted: list[int]) -> list[int]:     n = len(unsorted)     for i in range(n // 2 - 1, -1, -1):         heapify(unsorted, i, n)     for i in range(n - 1, 0, -1):         unsorted[0], unsorted[i] = unsorted[i], unsorted[0]         heapify(unsorted, 0, i)     return unsorted\n1: def product_sum_array(array: list[int | list]) -> int:     return product_sum(array, 1)\n2: def line_length(     fnc: Callable[[float], float],     x_start: float,     x_end: float,     steps: int = 100, ) -> float:      x1 = x_start     fx1 = fnc(x_start)     length = 0.0      for _ in range(steps):         # Approximates curve as a sequence of linear lines and sums their length         x2 = (x_end - x_start) / steps + x1         fx2 = fnc(x2)         length += math.hypot(x2 - x1, fx2 - fx1)          # Increment step         x1 = x2         fx1 = fx2      return length", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef cyclic_sort(nums: list[int]) -> list[int]:\n\n    # Perform cyclic sort\n    index = 0\n    while index < len(nums):\n        # Calculate the correct index for the current element\n        correct_index = nums[index] - 1\n        # If the current element is not at its correct position,\n        # swap it with the element at its correct index\n        if index != correct_index:\n            nums[index], nums[correct_index] = nums[correct_index], nums[index]\n        else:\n            # If the current element is already in its correct position,\n            # move to the next element\n            index += 1\n\n    return nums", "output": "Sorts the input list of n integers from 1 to n in-place"}
{"task": "search", "input": "search code:\nExamples:\n\nChoices:\n0: def radix_sort(list_of_ints: list[int]) -> list[int]:     placement = 1     max_digit = max(list_of_ints)     while placement <= max_digit:         # declare and initialize empty buckets         buckets: list[list] = [[] for _ in range(RADIX)]         # split list_of_ints between the buckets         for i in list_of_ints:             tmp = int((i / placement) % RADIX)             buckets[tmp].append(i)         # put each buckets' contents into list_of_ints         a = 0         for b in range(RADIX):             for i in buckets[b]:                 list_of_ints[a] = i                 a += 1         # move to next         placement *= RADIX     return list_of_ints\n1: def consecutive_groups(iterable, ordering=None):     if ordering is None:         key = lambda x: x[0] - x[1]     else:         key = lambda x: x[0] - ordering(x[1])      for k, g in groupby(enumerate(iterable), key=key):         yield map(itemgetter(1), g)\n2: def sum_of_geometric_progression(     first_term: int, common_ratio: int, num_of_terms: int ) -> float:     if common_ratio == 1:         # Formula for sum if common ratio is 1         return num_of_terms * first_term      # Formula for finding sum of n terms of a GeometricProgression     return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)", "output": "0"}
{"task": "search", "input": "search code:\nConversion between pressure units.\n\nChoices:\n0: def continuous_fraction_period(n: int) -> int:     numerator = 0.0     denominator = 1.0     root = int(sqrt(n))     integer_part = root     period = 0     while integer_part != 2 * root:         numerator = denominator * integer_part - numerator         denominator = (n - numerator**2) / denominator         integer_part = int((root + numerator) / denominator)         period += 1     return period\n1: def pressure_conversion(value: float, from_type: str, to_type: str) -> float:     if from_type not in PRESSURE_CONVERSION:         raise ValueError(             f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"             + \", \".join(PRESSURE_CONVERSION)         )     if to_type not in PRESSURE_CONVERSION:         raise ValueError(             f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"             + \", \".join(PRESSURE_CONVERSION)         )     return (         value         * PRESSURE_CONVERSION[from_type].from_factor         * PRESSURE_CONVERSION[to_type].to_factor     )\n2: def is_prime(number: int) -> bool:      # precondition     if not isinstance(number, int) or not number >= 0:         raise ValueError(\"is_prime() only accepts positive integers\")      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "search", "input": "search code:\nReturn a list of the Catalan number sequence from 0 through `upper_limit`.\n\nChoices:\n0: def dpll_algorithm(     clauses: list[Clause], symbols: list[str], model: dict[str, bool | None] ) -> tuple[bool | None, dict[str, bool | None] | None]:     check_clause_all_true = True     for clause in clauses:         clause_check = clause.evaluate(model)         if clause_check is False:             return False, None         elif clause_check is None:             check_clause_all_true = False             continue      if check_clause_all_true:         return True, model      try:         pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)     except RecursionError:         print(\"raises a RecursionError and is\")         return None, {}     p = None     if len(pure_symbols) > 0:         p, value = pure_symbols[0], assignment[pure_symbols[0]]      if p:         tmp_model = model         tmp_model[p] = value         tmp_symbols = list(symbols)         if p in tmp_symbols:             tmp_symbols.remove(p)         return dpll_algorithm(clauses, tmp_symbols, tmp_model)      unit_symbols, assignment = find_unit_clauses(clauses, model)     p = None     if len(unit_symbols) > 0:         p, value = unit_symbols[0], assignment[unit_symbols[0]]     if p:         tmp_model = model         tmp_model[p] = value         tmp_symbols = list(symbols)         if p in tmp_symbols:             tmp_symbols.remove(p)         return dpll_algorithm(clauses, tmp_symbols, tmp_model)     p = symbols[0]     rest = symbols[1:]     tmp1, tmp2 = model, model     tmp1[p], tmp2[p] = True, False      return dpll_algorithm(clauses, rest, tmp1) or dpll_algorithm(clauses, rest, tmp2)\n1: def relative_time(d, other=None, ndigits=0):     drt, unit = decimal_relative_time(d, other, ndigits, cardinalize=True)     phrase = 'ago'     if drt < 0:         phrase = 'from now'     return f'{abs(drt):g} {unit} {phrase}'\n2: def catalan_numbers(upper_limit: int) -> \"list[int]\":     if upper_limit < 0:         raise ValueError(\"Limit for the Catalan sequence must be  0\")      catalan_list = [0] * (upper_limit + 1)      # Base case: C(0) = C(1) = 1     catalan_list[0] = 1     if upper_limit > 0:         catalan_list[1] = 1      # Recurrence relation: C(i) = sum(C(j).C(i-j-1)), from j = 0 to i     for i in range(2, upper_limit + 1):         for j in range(i):             catalan_list[i] += catalan_list[j] * catalan_list[i - j - 1]      return catalan_list", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef compress_data(data_bits: str) -> str:\n    lexicon = {\"0\": \"0\", \"1\": \"1\"}\n    result, curr_string = \"\", \"\"\n    index = len(lexicon)\n\n    for i in range(len(data_bits)):\n        curr_string += data_bits[i]\n        if curr_string not in lexicon:\n            continue\n\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n        add_key_to_lexicon(lexicon, curr_string, index, last_match_id)\n        index += 1\n        curr_string = \"\"\n\n    while curr_string != \"\" and curr_string not in lexicon:\n        curr_string += \"0\"\n\n    if curr_string != \"\":\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n\n    return result", "output": "Compresses given data_bits using Lempel-Ziv-Welch compression algorithm"}
{"task": "summary", "input": "summarize code:\ndef city_select(\n    pheromone: list[list[float]],\n    current_city: dict[int, list[int]],\n    unvisited_cities: dict[int, list[int]],\n    alpha: float,\n    beta: float,\n) -> tuple[dict[int, list[int]], dict[int, list[int]]]:\n    probabilities = []\n    for city, value in unvisited_cities.items():\n        city_distance = distance(value, next(iter(current_city.values())))\n        probability = (pheromone[city][next(iter(current_city.keys()))] ** alpha) * (\n            (1 / city_distance) ** beta\n        )\n        probabilities.append(probability)\n\n    chosen_city_i = random.choices(\n        list(unvisited_cities.keys()), weights=probabilities\n    )[0]\n    chosen_city = {chosen_city_i: unvisited_cities[chosen_city_i]}\n    del unvisited_cities[next(iter(chosen_city.keys()))]\n    return chosen_city, unvisited_cities", "output": "Choose the next city for ants"}
{"task": "search", "input": "search code:\nFinds all connected elements of the same type from a given position.\n\nChoices:\n0: def main() -> None:      # unittest.main()      import doctest      doctest.testmod()      parser = argparse.ArgumentParser()     parser.add_argument(         \"-s\",         \"--string\",         dest=\"input_string\",         default=\"Hello World!! Welcome to Cryptography\",         help=\"Hash the string\",     )     parser.add_argument(         \"-f\", \"--file\", dest=\"input_file\", help=\"Hash contents of a file\"     )      args = parser.parse_args()      input_string = args.input_string      # hash input should be a bytestring     if args.input_file:         with open(args.input_file, \"rb\") as f:             hash_input = f.read()     else:         hash_input = bytes(input_string, \"utf-8\")      print(SHA256(hash_input).hash)\n1: def find_repeat(     matrix_g: list[list[str]], row: int, column: int, size: int ) -> set[tuple[int, int]]:      column = size - 1 - column     visited = set()     repeated = set()      if (color := matrix_g[column][row]) != \"-\":          def dfs(row_n: int, column_n: int) -> None:             if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:                 return             if (row_n, column_n) in visited:                 return             visited.add((row_n, column_n))             if matrix_g[row_n][column_n] == color:                 repeated.add((row_n, column_n))                 dfs(row_n - 1, column_n)                 dfs(row_n + 1, column_n)                 dfs(row_n, column_n - 1)                 dfs(row_n, column_n + 1)          dfs(column, row)      return repeated\n2: def insert(root: Node | None, value: int) -> Node | None:     node = Node(value)     left, right = split(root, value)     return merge(merge(left, node), right)", "output": "1"}
{"task": "search", "input": "search code:\nA generator that produces numbers in the Fibonacci sequence\n\nChoices:\n0: def gamma_iterative(num: float) -> float:     if num <= 0:         raise ValueError(\"math domain error\")      return quad(integrand, 0, inf, args=(num))[0]\n1: def fibonacci_generator() -> Generator[int]:     a, b = 0, 1     while True:         a, b = b, a + b         yield b\n2: def subslices(iterable):     seq = list(iterable)     slices = starmap(slice, combinations(range(len(seq) + 1), 2))     return map(getitem, repeat(seq), slices)", "output": "1"}
{"task": "search", "input": "search code:\ncreating sparse table which saves each nodes 2^i-th parent\n\nChoices:\n0: def slow_reversible_numbers(     remaining_length: int, remainder: int, digits: list[int], length: int ) -> int:     if remaining_length == 0:         if digits[0] == 0 or digits[-1] == 0:             return 0          for i in range(length // 2 - 1, -1, -1):             remainder += digits[i] + digits[length - i - 1]              if remainder % 2 == 0:                 return 0              remainder //= 10          return 1      if remaining_length == 1:         if remainder % 2 == 0:             return 0          result = 0         for digit in range(10):             digits[length // 2] = digit             result += slow_reversible_numbers(                 0, (remainder + 2 * digit) // 10, digits, length             )         return result      result = 0     for digit1 in range(10):         digits[(length + remaining_length) // 2 - 1] = digit1          if (remainder + digit1) % 2 == 0:             other_parity_digits = ODD_DIGITS         else:             other_parity_digits = EVEN_DIGITS          for digit2 in other_parity_digits:             digits[(length - remaining_length) // 2] = digit2             result += slow_reversible_numbers(                 remaining_length - 2,                 (remainder + digit1 + digit2) // 10,                 digits,                 length,             )     return result\n1: def get_files_url() -> str:     with open(os.environ[\"GITHUB_EVENT_PATH\"]) as file:         event = json.load(file)     return event[\"pull_request\"][\"url\"] + \"/files\"\n2: def create_sparse(max_node: int, parent: list[list[int]]) -> list[list[int]]:     j = 1     while (1 << j) < max_node:         for i in range(1, max_node + 1):             parent[j][i] = parent[j - 1][parent[j - 1][i]]         j += 1     return parent", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef power(a: int, b: int) -> float:\n    if b < 0:\n        return 1 / actual_power(a, -b)\n    return actual_power(a, b)", "output": ":param a: The base (integer)."}
{"task": "summary", "input": "summarize code:\ndef invert_modulo(a: int, n: int) -> int:\n    (b, _x) = extended_euclid(a, n)  # Implemented below\n    if b < 0:\n        b = (b % n + n) % n\n    return b", "output": "This function find the inverses of a i.e., a^(-1)"}
{"task": "search", "input": "search code:\nBenchmark multiple functions, with three different length int values.\n\nChoices:\n0: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")      for value in (262144, 1125899906842624, 1267650600228229401496703205376):         for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):             benchmark_a_function(func, value)         print()\n1: def pretty_print(n):     if n <= 0:         return \"       ...       ....        nothing printing :(\"     upper_half = floyd(n)  # upper half     lower_half = reverse_floyd(n)  # lower half     return upper_half + lower_half\n2: def open_knight_tour_helper(     board: list[list[int]], pos: tuple[int, int], curr: int ) -> bool:      if is_complete(board):         return True      for position in get_valid_pos(pos, len(board)):         y, x = position          if board[y][x] == 0:             board[y][x] = curr + 1             if open_knight_tour_helper(board, position, curr + 1):                 return True             board[y][x] = 0      return False", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef tabu_search(\n    first_solution, distance_of_first_solution, dict_of_neighbours, iters, size\n):\n    count = 1\n    solution = first_solution\n    tabu_list = []\n    best_cost = distance_of_first_solution\n    best_solution_ever = solution\n\n    while count <= iters:\n        neighborhood = find_neighborhood(solution, dict_of_neighbours)\n        index_of_best_solution = 0\n        best_solution = neighborhood[index_of_best_solution]\n        best_cost_index = len(best_solution) - 1\n\n        found = False\n        while not found:\n            i = 0\n            while i < len(best_solution):\n                if best_solution[i] != solution[i]:\n                    first_exchange_node = best_solution[i]\n                    second_exchange_node = solution[i]\n                    break\n                i = i + 1\n\n            if [first_exchange_node, second_exchange_node] not in tabu_list and [\n                second_exchange_node,\n                first_exchange_node,\n            ] not in tabu_list:\n                tabu_list.append([first_exchange_node, second_exchange_node])\n                found = True\n                solution = best_solution[:-1]\n                cost = neighborhood[index_of_best_solution][best_cost_index]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_solution_ever = solution\n            else:\n                index_of_best_solution = index_of_best_solution + 1\n                best_solution = neighborhood[index_of_best_solution]\n\n        if len(tabu_list) >= size:\n            tabu_list.pop(0)\n\n        count = count + 1\n\n    return best_solution_ever, best_cost", "output": "Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in"}
{"task": "detection", "input": "classify code:\ndef generate_large_matrix() -> list[list[int]]:\n    \"\"\"\n    >>> generate_large_matrix() # doctest: +ELLIPSIS\n    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]\n    \"\"\"\n    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2", "output": "Find the midpoint of two points"}
{"task": "search", "input": "search code:\nYield the primes less than n.\n\nChoices:\n0: def sieve(n):     # This implementation comes from an older version of the itertools     # documentation.  The newer implementation is easier to read but is     # less lazy.     if n > 2:         yield 2     start = 3     data = bytearray((0, 1)) * (n // 2)     for p in iter_index(data, 1, start, stop=isqrt(n) + 1):         yield from iter_index(data, 1, start, p * p)         data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))         start = p * p     yield from iter_index(data, 1, start)\n1: def is_9_pandigital(n: int) -> bool:     s = str(n)     return len(s) == 9 and set(s) == set(\"123456789\")\n2: def solution(limit: int = 1_000_000) -> int:      # generating an array from -1 to limit     phi = np.arange(-1, limit)      for i in range(2, limit + 1):         if phi[i] == i - 1:             ind = np.arange(2 * i, limit + 1, i)  # indexes for selection             phi[ind] -= phi[ind] // i      return int(np.sum(phi[2 : limit + 1]))", "output": "0"}
{"task": "search", "input": "search code:\nConverts a string of roman numerals to an integer.\n\nChoices:\n0: def cocktail_shaker_sort(arr: list[int]) -> list[int]:     start, end = 0, len(arr) - 1      while start < end:         swapped = False          # Pass from left to right         for i in range(start, end):             if arr[i] > arr[i + 1]:                 arr[i], arr[i + 1] = arr[i + 1], arr[i]                 swapped = True          if not swapped:             break          end -= 1  # Decrease the end pointer after each pass          # Pass from right to left         for i in range(end, start, -1):             if arr[i] < arr[i - 1]:                 arr[i], arr[i - 1] = arr[i - 1], arr[i]                 swapped = True          if not swapped:             break          start += 1  # Increase the start pointer after each pass      return arr\n1: def parse_roman_numerals(numerals: str) -> int:      total_value = 0      index = 0     while index < len(numerals) - 1:         current_value = SYMBOLS[numerals[index]]         next_value = SYMBOLS[numerals[index + 1]]         if current_value < next_value:             total_value -= current_value         else:             total_value += current_value         index += 1     total_value += SYMBOLS[numerals[index]]      return total_value\n2: def polynomial_eval(coefficients, x):     n = len(coefficients)     if n == 0:         return type(x)(0)     powers = map(pow, repeat(x), reversed(range(n)))     return _sumprod(coefficients, powers)", "output": "1"}
{"task": "search", "input": "search code:\nFinds the longest common subsequence between two strings. Also returns the\n\nChoices:\n0: def longest_common_subsequence(x: str, y: str):     # find the length of strings      assert x is not None     assert y is not None      m = len(x)     n = len(y)      # declaring the array for storing the dp values     dp = [[0] * (n + 1) for _ in range(m + 1)]      for i in range(1, m + 1):         for j in range(1, n + 1):             match = 1 if x[i - 1] == y[j - 1] else 0              dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)      seq = \"\"     i, j = m, n     while i > 0 and j > 0:         match = 1 if x[i - 1] == y[j - 1] else 0          if dp[i][j] == dp[i - 1][j - 1] + match:             if match == 1:                 seq = x[i - 1] + seq             i -= 1             j -= 1         elif dp[i][j] == dp[i - 1][j]:             i -= 1         else:             j -= 1      return dp[m][n], seq\n1: def world_covid19_stats(     url: str = \"https://www.worldometers.info/coronavirus/\", ) -> dict:     soup = BeautifulSoup(         httpx.get(url, timeout=10, follow_redirects=True).text, \"html.parser\"     )     keys = soup.find_all(\"h1\")     values = soup.find_all(\"div\", {\"class\": \"maincounter-number\"})     keys += soup.find_all(\"span\", {\"class\": \"panel-title\"})     values += soup.find_all(\"div\", {\"class\": \"number-table-main\"})     return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}\n2: def intword(value, format=\"%.1f\"):     try:         value = int(value)     except (TypeError, ValueError):         return value      if value < powers[0]:         return str(value)     for ordinal, power in enumerate(powers[1:], 1):         if value < power:             chopped = value / float(powers[ordinal - 1])             if float(format % chopped) == float(10**3):                 chopped = value / float(powers[ordinal])                 singular, plural = human_powers[ordinal]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped             else:                 singular, plural = human_powers[ordinal - 1]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped     return str(value)", "output": "0"}
{"task": "search", "input": "search code:\nActivate internationalisation.\n\nChoices:\n0: def activate(locale, path=None):     if path is None:         path = _get_default_locale_path()      if path is None:         raise Exception(             \"Humanize cannot determinate the default location of the 'locale' folder. \"             \"You need to pass the path explicitly.\"         )     if locale not in _TRANSLATIONS:         translation = gettext_module.translation(\"humanize\", path, [locale])         _TRANSLATIONS[locale] = translation     _CURRENT.locale = locale     return _TRANSLATIONS[locale]\n1: def _modexpt(base: int, exponent: int, modulo_value: int) -> int:      if exponent == 1:         return base     if exponent % 2 == 0:         x = _modexpt(base, exponent // 2, modulo_value) % modulo_value         return (x * x) % modulo_value     else:         return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value\n2: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)", "output": "0"}
{"task": "search", "input": "search code:\nReturns the sum of all even fibonacci sequence elements that are lower\n\nChoices:\n0: def combination_index(element, iterable):     element = enumerate(element)     k, y = next(element, (None, None))     if k is None:         return 0      indexes = []     pool = enumerate(iterable)     for n, x in pool:         if x == y:             indexes.append(n)             tmp, y = next(element, (None, None))             if tmp is None:                 break             else:                 k = tmp     else:         raise ValueError('element is not a combination of iterable')      n, _ = last(pool, default=(n, None))      index = 1     for i, j in enumerate(reversed(indexes), start=1):         j = n - j         if i <= j:             index += comb(j, i)      return comb(n + 1, k + 1) - index\n1: def calculate_turnaroundtime(     burst_time: list[int], no_of_processes: int, waiting_time: list[int] ) -> list[int]:     turn_around_time = [0] * no_of_processes     for i in range(no_of_processes):         turn_around_time[i] = burst_time[i] + waiting_time[i]     return turn_around_time\n2: def solution(n: int = 4000000) -> int:      i = 1     j = 2     total = 0     while j <= n:         if j % 2 == 0:             total += j         i, j = j, i + j      return total", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef prepare_grid(window_size: float, nb_pixels: int) -> np.ndarray:\n    x = np.linspace(-window_size, window_size, nb_pixels)\n    x = x.reshape((nb_pixels, 1))\n    y = np.linspace(-window_size, window_size, nb_pixels)\n    y = y.reshape((1, nb_pixels))\n    return x + 1.0j * y", "output": "Create a grid of complex values of size nb_pixels*nb_pixels with real and"}
{"task": "detection", "input": "classify code:\ndef min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef second_effusion_rate(\n    effusion_rate: float, molar_mass_1: float, molar_mass_2: float\n) -> float | ValueError:\n    return (\n        round(effusion_rate / sqrt(molar_mass_2 / molar_mass_1), 6)\n        if validate(effusion_rate, molar_mass_1, molar_mass_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )", "output": "Input Parameters:"}
{"task": "detection", "input": "classify code:\ndef jaro_winkler(str1: str, str2: str) -> float:\n    \"\"\"\n    Jaro-Winkler distance is a string metric measuring an edit distance between two\n    sequences.\n    Output value is between 0.0 and 1.0.\n\n    >>> jaro_winkler(\"martha\", \"marhta\")\n    0.9611111111111111\n    >>> jaro_winkler(\"CRATE\", \"TRACE\")\n    0.7333333333333334\n    >>> jaro_winkler(\"test\", \"dbdbdbdb\")\n    0.0\n    >>> jaro_winkler(\"test\", \"test\")\n    1.0\n    >>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n    0.6363636363636364\n    >>> jaro_winkler(\"test\", \"\")\n    0.0\n    >>> jaro_winkler(\"hello\", \"world\")\n    0.4666666666666666\n    >>> jaro_winkler(\"hell**o\", \"*world\")\n    0.4365079365079365\n    \"\"\"\n\n    def get_matched_characters(_str1: str, _str2: str) -> str:\n        matched = []\n        limit = min(len(_str1), len(_str2)) // 2\n        for i, char in enumerate(_str1):\n            left = int(max(0, i - limit))\n            right = int(min(i + limit + 1, len(_str2)))\n            if char in _str2[left:right]:\n                matched.append(char)\n                _str2 = (\n                    f\"{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}\"\n                )\n\n        return \"\".join(matched)\n\n    # matching characters\n    matching_1 = get_matched_characters(str1, str2)\n    matching_2 = get_matched_characters(str2, str1)\n    match_count = len(matching_1)\n\n    # transposition\n    transpositions = (\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\n    )\n\n    if not match_count:\n        jaro = 0.0\n    else:\n        jaro = (\n            1\n            / 3\n            * (\n                match_count / len(str1)\n                + match_count / len(str2)\n                + (match_count - transpositions) / match_count\n            )\n        )\n\n    # common prefix up to 4 characters\n    prefix_len = 0\n    for c1, c2 in zip(str1[:4], str2[:4]):\n        if c1 == c2:\n            prefix_len += 1\n        else:\n            break\n\n    return jaro + 0.1 * prefix_len * (1 - jaro)", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef get_distance(highway_now: list, car_index: int) -> int:\n    \"\"\"\n    Get the distance between a car (at index car_index) and the next car\n    >>> get_distance([6, -1, 6, -1, 6], 2)\n    1\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n    3\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n    4\n    \"\"\"\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the last 10 digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.\n\nChoices:\n0: def solution():     total = 0     for i in range(1, 1001):         total += i**i     return str(total)[-10:]\n1: def solution():     total = 0      for i in range(1, 101):         for j in range(1, i + 1):             if combinations(i, j) > 1e6:                 total += 1     return total\n2: def pythagorean_triple(max_perimeter: int) -> typing.Counter[int]:     triplets: typing.Counter[int] = Counter()     for base in range(1, max_perimeter + 1):         for perpendicular in range(base, max_perimeter + 1):             hypotenuse = (base * base + perpendicular * perpendicular) ** 0.5             if hypotenuse == int(hypotenuse):                 perimeter = int(base + perpendicular + hypotenuse)                 if perimeter > max_perimeter:                     continue                 triplets[perimeter] += 1     return triplets", "output": "0"}
{"task": "search", "input": "search code:\nConstructs a top-down dynamic programming solution for the rod-cutting\n\nChoices:\n0: def sum_32(a: int, b: int) -> int:     return (a + b) % 2**32\n1: def number_of_divisors(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     div = 1     temp = 1     while n % 2 == 0:         temp += 1         n = int(n / 2)     div *= temp     for i in range(3, int(math.sqrt(n)) + 1, 2):         temp = 1         while n % i == 0:             temp += 1             n = int(n / i)         div *= temp     if n > 1:         div *= 2     return div\n2: def top_down_cut_rod(n: int, prices: list):     _enforce_args(n, prices)     max_rev = [float(\"-inf\") for _ in range(n + 1)]     return _top_down_cut_rod_recursive(n, prices, max_rev)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef combination_sum_iv(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef find_longest_chain(chain: list[int], max_num: int) -> int:\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem", "output": "Finds the smallest element of longest chain"}
{"task": "detection", "input": "classify code:\ndef swap_case(sentence):\n    \"\"\"\n    This function will convert all lowercase letters to uppercase letters\n    and vice versa.\n\n    >>> swap_case('Algorithm.Python@89')\n    'aLGORITHM.pYTHON@89'\n    \"\"\"\n    new_string = \"\"\n    for char in sentence:\n        if char.isupper():\n            new_string += char.lower()\n        if char.islower():\n            new_string += char.upper()\n        if regexp.search(char):\n            new_string += char\n\n    return new_string", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False", "output": "Return True if it's possible to search the word suffix"}
{"task": "search", "input": "search code:\nThis function is used to perform avgpooling on the input array of 2D matrix(image)\n\nChoices:\n0: def avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:     arr = np.array(arr)     if arr.shape[0] != arr.shape[1]:         raise ValueError(\"The input array is not a square matrix\")     i = 0     j = 0     mat_i = 0     mat_j = 0      # compute the shape of the output matrix     avgpool_shape = (arr.shape[0] - size) // stride + 1     # initialize the output matrix with zeros of shape avgpool_shape     updated_arr = np.zeros((avgpool_shape, avgpool_shape))      while i < arr.shape[0]:         # if the end of the matrix is reached, break         if i + size > arr.shape[0]:             break         while j < arr.shape[1]:             # if the end of the matrix is reached, break             if j + size > arr.shape[1]:                 break             # compute the average of the pooling matrix             updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))             # shift the pooling matrix by stride of column pixels             j += stride             mat_j += 1          # shift the pooling matrix by stride of row pixels         i += stride         mat_i += 1         # reset the column index to 0         j = 0         mat_j = 0      return updated_arr\n1: def sort(array: list) -> list:     if len(array) == 0:         return array     max_depth = 2 * math.ceil(math.log2(len(array)))     size_threshold = 16     return intro_sort(array, 0, len(array), size_threshold, max_depth)\n2: def merge(input_list: list, low: int, mid: int, high: int) -> list:     result = []     left, right = input_list[low:mid], input_list[mid : high + 1]     while left and right:         result.append((left if left[0] <= right[0] else right).pop(0))     input_list[low : high + 1] = result + left + right     return input_list", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef combination_index(element, iterable):\n    element = enumerate(element)\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = enumerate(iterable)\n    for n, x in pool:\n        if x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n    else:\n        raise ValueError('element is not a combination of iterable')\n\n    n, _ = last(pool, default=(n, None))\n\n    index = 1\n    for i, j in enumerate(reversed(indexes), start=1):\n        j = n - j\n        if i <= j:\n            index += comb(j, i)\n\n    return comb(n + 1, k + 1) - index", "output": "Equivalent to ``list(combinations(iterable, r)).index(element)``"}
{"task": "search", "input": "search code:\nReturns the maximum value that can be put in a knapsack of a capacity cap,\n\nChoices:\n0: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n1: def knapsack(     capacity: int,     weights: list[int],     values: list[int],     counter: int,     allow_repetition=False, ) -> int:      @lru_cache     def knapsack_recur(capacity: int, counter: int) -> int:         # Base Case         if counter == 0 or capacity == 0:             return 0          # If weight of the nth item is more than Knapsack of capacity,         #   then this item cannot be included in the optimal solution,         # else return the maximum of two cases:         #   (1) nth item included only once (0-1), if allow_repetition is False         #       nth item included one or more times (0-N), if allow_repetition is True         #   (2) not included         if weights[counter - 1] > capacity:             return knapsack_recur(capacity, counter - 1)         else:             left_capacity = capacity - weights[counter - 1]             new_value_included = values[counter - 1] + knapsack_recur(                 left_capacity, counter - 1 if not allow_repetition else counter             )             without_new_value = knapsack_recur(capacity, counter - 1)             return max(new_value_included, without_new_value)      return knapsack_recur(capacity, counter)\n2: def solution() -> int:     limit = 7 * factorial(9) + 1     return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)", "output": "1"}
{"task": "search", "input": "search code:\nPrint Pascal's triangle for different number of rows\n\nChoices:\n0: def print_pascal_triangle(num_rows: int) -> None:     triangle = generate_pascal_triangle(num_rows)     for row_idx in range(num_rows):         # Print left spaces         for _ in range(num_rows - row_idx - 1):             print(end=\" \")         # Print row values         for col_idx in range(row_idx + 1):             if col_idx != row_idx:                 print(triangle[row_idx][col_idx], end=\" \")             else:                 print(triangle[row_idx][col_idx], end=\"\")         print()\n1: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)\n2: def solution(n: int = 1000000) -> int:      result = max((collatz_sequence_length(i), i) for i in range(1, n))     return result[1]", "output": "0"}
{"task": "search", "input": "search code:\nInterleave multiple iterables so that their elements are evenly distributed\n\nChoices:\n0: def interleave_evenly(iterables, lengths=None):     if lengths is None:         try:             lengths = [len(it) for it in iterables]         except TypeError:             raise ValueError(                 'Iterable lengths could not be determined automatically. '                 'Specify them with the lengths keyword.'             )     elif len(iterables) != len(lengths):         raise ValueError('Mismatching number of iterables and lengths.')      dims = len(lengths)      # sort iterables by length, descending     lengths_permute = sorted(         range(dims), key=lambda i: lengths[i], reverse=True     )     lengths_desc = [lengths[i] for i in lengths_permute]     iters_desc = [iter(iterables[i]) for i in lengths_permute]      # the longest iterable is the primary one (Bresenham: the longest     # distance along an axis)     delta_primary, deltas_secondary = lengths_desc[0], lengths_desc[1:]     iter_primary, iters_secondary = iters_desc[0], iters_desc[1:]     errors = [delta_primary // dims] * len(deltas_secondary)      to_yield = sum(lengths)     while to_yield:         yield next(iter_primary)         to_yield -= 1         # update errors for each secondary iterable         errors = [e - delta for e, delta in zip(errors, deltas_secondary)]          # those iterables for which the error is negative are yielded         # (\"diagonal step\" in Bresenham)         for i, e_ in enumerate(errors):             if e_ < 0:                 yield next(iters_secondary[i])                 to_yield -= 1                 errors[i] += delta_primary\n1: def map_if(iterable, pred, func, func_else=None):      if func_else is None:         for item in iterable:             yield func(item) if pred(item) else item      else:         for item in iterable:             yield func(item) if pred(item) else func_else(item)\n2: def double_linear_search(array: list[int], search_item: int) -> int:     # define the start and end index of the given array     start_ind, end_ind = 0, len(array) - 1     while start_ind <= end_ind:         if array[start_ind] == search_item:             return start_ind         elif array[end_ind] == search_item:             return end_ind         else:             start_ind += 1             end_ind -= 1     # returns -1 if search_item is not found in array     return -1", "output": "0"}
{"task": "search", "input": "search code:\n``unique()`` returns a list of unique values, as determined by\n\nChoices:\n0: def binary_search_by_recursion(     sorted_collection: list[int], item: int, left: int = 0, right: int = -1 ) -> int:     if right < 0:         right = len(sorted_collection) - 1     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     if right < left:         return -1      midpoint = left + (right - left) // 2      if sorted_collection[midpoint] == item:         return midpoint     elif sorted_collection[midpoint] > item:         return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)     else:         return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)\n1: def unique(src, key=None):     return list(unique_iter(src, key))\n2: def place_word(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> None:     for i, char in enumerate(word):         if vertical:             puzzle[row + i][col] = char         else:             puzzle[row][col + i] = char", "output": "1"}
{"task": "search", "input": "search code:\nPercent-encode a single query string key or value.\n\nChoices:\n0: def quote_query_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])     return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t                      for t in text])\n1: def prime_generator():      num = 2     while True:         if is_prime(num):             yield num         num += 1\n2: def assign(values, s, d):     other_values = values[s].replace(d, \"\")     if all(eliminate(values, s, d2) for d2 in other_values):         return values     else:         return False", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef median_of_medians(arr: list) -> int:\n\n    if len(arr) <= 5:\n        return median_of_five(arr)\n    medians = []\n    i = 0\n    while i < len(arr):\n        if (i + 4) <= len(arr):\n            medians.append(median_of_five(arr[i:].copy()))\n        else:\n            medians.append(median_of_five(arr[i : i + 5].copy()))\n        i += 5\n    return median_of_medians(medians)", "output": "Return a pivot to partition data on by calculating"}
{"task": "summary", "input": "summarize code:\ndef consecutive_groups(iterable, ordering=None):\n    if ordering is None:\n        key = lambda x: x[0] - x[1]\n    else:\n        key = lambda x: x[0] - ordering(x[1])\n\n    for k, g in groupby(enumerate(iterable), key=key):\n        yield map(itemgetter(1), g)", "output": "Yield groups of consecutive items using :func:`itertools.groupby`."}
{"task": "summary", "input": "summarize code:\ndef run(n: int) -> list[int]:\n\n    # Incrementor variable for our group list comprehension.\n    # This is the first number in each list of values\n    # to test.\n    base = 2\n\n    while True:\n        # Increment each value of a generated range\n        group = [base + i for i in range(n)]\n\n        # Run elements through the unique_prime_factors function\n        # Append our target number to the end.\n        checker = [upf_len(x) for x in group]\n        checker.append(n)\n\n        # If all numbers in the list are equal, return the group variable.\n        if equality(checker):\n            return group\n\n        # Increment our base variable by 1\n        base += 1", "output": "Runs core process to find problem solution."}
{"task": "summary", "input": "summarize code:\ndef solution(numerator: int = 3, denominator: int = 7, limit: int = 1000000) -> int:\n    max_numerator = 0\n    max_denominator = 1\n\n    for current_denominator in range(1, limit + 1):\n        current_numerator = current_denominator * numerator // denominator\n        if current_denominator % denominator == 0:\n            current_numerator -= 1\n        if current_numerator * max_denominator > current_denominator * max_numerator:\n            max_numerator = current_numerator\n            max_denominator = current_denominator\n    return max_numerator", "output": "Returns the closest numerator of the fraction immediately to the"}
{"task": "search", "input": "search code:\nReturn True if num1 and num2 have the same frequency of every digit, False\n\nChoices:\n0: def solution(n: int = 200) -> int:     return two_pound(n)\n1: def calculate_turnaround_times(     duration_times: list[int], waiting_times: list[int] ) -> list[int]:     return [         duration_time + waiting_times[i]         for i, duration_time in enumerate(duration_times)     ]\n2: def has_same_digits(num1: int, num2: int) -> bool:     return sorted(str(num1)) == sorted(str(num2))", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef traverse_tree(root: Letter | TreeNode, bitstring: str) -> list[Letter]:\n    if isinstance(root, Letter):\n        root.bitstring[root.letter] = bitstring\n        return [root]\n    treenode: TreeNode = root\n    letters = []\n    letters += traverse_tree(treenode.left, bitstring + \"0\")\n    letters += traverse_tree(treenode.right, bitstring + \"1\")\n    return letters", "output": "Recursively traverse the Huffman Tree to set each"}
{"task": "detection", "input": "classify code:\ndef decimal_isolate(number: float, digit_amount: int) -> float:\n    \"\"\"\n    Isolates the decimal part of a number.\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\n    >>> decimal_isolate(1.53, 0)\n    0.53\n    >>> decimal_isolate(35.345, 1)\n    0.3\n    >>> decimal_isolate(35.345, 2)\n    0.34\n    >>> decimal_isolate(35.345, 3)\n    0.345\n    >>> decimal_isolate(-14.789, 3)\n    -0.789\n    >>> decimal_isolate(0, 2)\n    0\n    >>> decimal_isolate(-14.123, 1)\n    -0.1\n    >>> decimal_isolate(-14.123, 2)\n    -0.12\n    >>> decimal_isolate(-14.123, 3)\n    -0.123\n    \"\"\"\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFinds the kth largest element in a list.\n\nChoices:\n0: def kth_largest_element(arr: list[int], position: int) -> int:     if not arr:         return -1     if not isinstance(position, int):         raise ValueError(\"The position should be an integer\")     if not 1 <= position <= len(arr):         raise ValueError(\"Invalid value of 'position'\")     low, high = 0, len(arr) - 1     while low <= high:         if low > len(arr) - 1 or high < 0:             return -1         pivot_index = partition(arr, low, high)         if pivot_index == position - 1:             return arr[pivot_index]         elif pivot_index > position - 1:             high = pivot_index - 1         else:             low = pivot_index + 1     return -1\n1: def find_freq_subgraph_given_support(s, cluster, graph):     k = int(s / 100 * (len(cluster) - 1))     for i in cluster[k]:         my_dfs(graph, tuple(cluster[k][i]), ([\"Header\"],))\n2: def iter_suppress(iterable, *exceptions):     try:         yield from iterable     except exceptions:         return", "output": "0"}
{"task": "search", "input": "search code:\nExamples:\n\nChoices:\n0: def naturaldate(value) -> str:     try:         value = dt.date(value.year, value.month, value.day)     except AttributeError:         # Passed value wasn't date-ish         return value     except (OverflowError, ValueError):         # Date arguments out of range         return value     delta = _abs_timedelta(value - dt.date.today())     if delta.days >= 5 * 365 / 12:         return naturalday(value, \"%b %d %Y\")     return naturalday(value)\n1: def solution(n: int = 100) -> int:      sum_of_squares = 0     sum_of_ints = 0     for i in range(1, n + 1):         sum_of_squares += i**2         sum_of_ints += i     return sum_of_ints**2 - sum_of_squares\n2: def is_carmichael_number(n: int) -> bool:      if n <= 0 or not isinstance(n, int):         msg = f\"Number {n} must instead be a positive integer\"         raise ValueError(msg)      return all(         power(b, n - 1, n) == 1         for b in range(2, n)         if greatest_common_divisor(b, n) == 1     )", "output": "2"}
{"task": "search", "input": "search code:\nCalculate the depreciation expenses over the given period\n\nChoices:\n0: def is_prime(n: int) -> bool:     return sieve[n]\n1: def triplewise(iterable):     # This deviates from the itertools documentation recipe - see     # https://github.com/more-itertools/more-itertools/issues/889     t1, t2, t3 = tee(iterable, 3)     next(t3, None)     next(t3, None)     next(t2, None)     return zip(t1, t2, t3)\n2: def straight_line_depreciation(     useful_years: int,     purchase_value: float,     residual_value: float = 0.0, ) -> list[float]:      if not isinstance(useful_years, int):         raise TypeError(\"Useful years must be an integer\")      if useful_years < 1:         raise ValueError(\"Useful years cannot be less than 1\")      if not isinstance(purchase_value, (float, int)):         raise TypeError(\"Purchase value must be numeric\")      if not isinstance(residual_value, (float, int)):         raise TypeError(\"Residual value must be numeric\")      if purchase_value < 0.0:         raise ValueError(\"Purchase value cannot be less than zero\")      if purchase_value < residual_value:         raise ValueError(\"Purchase value cannot be less than residual value\")      # Calculate annual depreciation expense     depreciable_cost = purchase_value - residual_value     annual_depreciation_expense = depreciable_cost / useful_years      # List of annual depreciation expenses     list_of_depreciation_expenses = []     accumulated_depreciation_expense = 0.0     for period in range(useful_years):         if period != useful_years - 1:             accumulated_depreciation_expense += annual_depreciation_expense             list_of_depreciation_expenses.append(annual_depreciation_expense)         else:             depreciation_expense_in_end_year = (                 depreciable_cost - accumulated_depreciation_expense             )             list_of_depreciation_expenses.append(depreciation_expense_in_end_year)      return list_of_depreciation_expenses", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef calculate_resistance(number_of_bands: int, color_code_list: list) -> dict:\n    is_valid = check_validity(number_of_bands, color_code_list)\n    if is_valid:\n        number_of_significant_bands = get_band_type_count(\n            number_of_bands, \"significant\"\n        )\n        significant_colors = color_code_list[:number_of_significant_bands]\n        significant_digits = int(get_significant_digits(significant_colors))\n        multiplier_color = color_code_list[number_of_significant_bands]\n        multiplier = get_multiplier(multiplier_color)\n        if number_of_bands == 3:\n            tolerance_color = None\n        else:\n            tolerance_color = color_code_list[number_of_significant_bands + 1]\n        tolerance = (\n            20 if tolerance_color is None else get_tolerance(str(tolerance_color))\n        )\n        if number_of_bands != 6:\n            temperature_coeffecient_color = None\n        else:\n            temperature_coeffecient_color = color_code_list[\n                number_of_significant_bands + 2\n            ]\n        temperature_coeffecient = (\n            0\n            if temperature_coeffecient_color is None\n            else get_temperature_coeffecient(str(temperature_coeffecient_color))\n        )\n        resisitance = significant_digits * multiplier\n        if temperature_coeffecient == 0:\n            answer = f\"{resisitance} {tolerance}% \"\n        else:\n            answer = f\"{resisitance} {tolerance}% {temperature_coeffecient} ppm/K\"\n        return {\"resistance\": answer}\n    else:\n        raise ValueError(\"Input is invalid\")", "output": "Function calculates the total resistance of the resistor using the color codes."}
{"task": "detection", "input": "classify code:\ndef minimum_cost_path(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef gronsfeld(text: str, key: str) -> str:\n    ascii_len = len(ascii_uppercase)\n    key_len = len(key)\n    encrypted_text = \"\"\n    keys = [int(char) for char in key]\n    upper_case_text = text.upper()\n\n    for i, char in enumerate(upper_case_text):\n        if char in ascii_uppercase:\n            new_position = (ascii_uppercase.index(char) + keys[i % key_len]) % ascii_len\n            shifted_letter = ascii_uppercase[new_position]\n            encrypted_text += shifted_letter\n        else:\n            encrypted_text += char\n\n    return encrypted_text", "output": "Encrypt plaintext with the Gronsfeld cipher"}
{"task": "detection", "input": "classify code:\ndef binary_search_insertion(sorted_list, item):\n    \"\"\"\n    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)\n    [1, 2, 4, 7, 9, 10]\n    \"\"\"\n    left = 0\n    right = len(sorted_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if left == right:\n            if sorted_list[middle] < item:\n                left = middle + 1\n            break\n        elif sorted_list[middle] < item:\n            left = middle + 1\n        else:\n            right = middle - 1\n    sorted_list.insert(left, item)\n    return sorted_list", "output": "CORRECT"}
{"task": "search", "input": "search code:\n:param index: index of the parameter vector wrt to derivative is to be calculated\n\nChoices:\n0: def _count_cross_inversions(p, q):      r = []     i = j = num_inversion = 0     while i < len(p) and j < len(q):         if p[i] > q[j]:             # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)             # These are all inversions. The claim emerges from the             # property that P is sorted.             num_inversion += len(p) - i             r.append(q[j])             j += 1         else:             r.append(p[i])             i += 1      if i < len(p):         r.extend(p[i:])     else:         r.extend(q[j:])      return r, num_inversion\n1: def leaky_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:     return np.where(vector > 0, vector, alpha * vector)\n2: def get_cost_derivative(index):     cost_derivative_value = summation_of_cost_derivative(index, m) / m     return cost_derivative_value", "output": "2"}
{"task": "search", "input": "search code:\nImplement Linear regression over the dataset\n\nChoices:\n0: def draw_cross(x: float, y: float, length: float):     turtle.up()     turtle.goto(x - length / 2, y - length / 6)     turtle.down()     turtle.seth(0)     turtle.begin_fill()     for _ in range(4):         turtle.fd(length / 3)         turtle.right(90)         turtle.fd(length / 3)         turtle.left(90)         turtle.fd(length / 3)         turtle.left(90)     turtle.end_fill()\n1: def increment_score(count: int) -> int:     return int(count * (count + 1) / 2)\n2: def run_linear_regression(data_x, data_y):     iterations = 100000     alpha = 0.0001550      no_features = data_x.shape[1]     len_data = data_x.shape[0] - 1      theta = np.zeros((1, no_features))      for i in range(iterations):         theta = run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)         error = sum_of_square_error(data_x, data_y, len_data, theta)         print(f\"At Iteration {i + 1} - Error is {error:.5f}\")      return theta", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef fizz_buzz(number: int, iterations: int) -> str:\n    if not isinstance(iterations, int):\n        raise ValueError(\"iterations must be defined as integers\")\n    if not isinstance(number, int) or not number >= 1:\n        raise ValueError(\n        )\n    if not iterations >= 1:\n        raise ValueError(\"Iterations must be done more than 0 times to play FizzBuzz\")\n\n    out = \"\"\n    while number <= iterations:\n        if number % 3 == 0:\n            out += \"Fizz\"\n        if number % 5 == 0:\n            out += \"Buzz\"\n        if 0 not in (number % 3, number % 5):\n            out += str(number)\n\n        # print(out)\n        number += 1\n        out += \" \"\n    return out", "output": "| Plays FizzBuzz."}
{"task": "search", "input": "search code:\nReturns the n-th prime number.\n\nChoices:\n0: def merge(arr: list[int]) -> list[int]:     if len(arr) > 1:         middle_length = len(arr) // 2  # Finds the middle of the array         left_array = arr[             :middle_length         ]  # Creates an array of the elements in the first half.         right_array = arr[             middle_length:         ]  # Creates an array of the elements in the second half.         left_size = len(left_array)         right_size = len(right_array)         merge(left_array)  # Starts sorting the left.         merge(right_array)  # Starts sorting the right         left_index = 0  # Left Counter         right_index = 0  # Right Counter         index = 0  # Position Counter         while (             left_index < left_size and right_index < right_size         ):  # Runs until the lowers size of the left and right are sorted.             if left_array[left_index] < right_array[right_index]:                 arr[index] = left_array[left_index]                 left_index += 1             else:                 arr[index] = right_array[right_index]                 right_index += 1             index += 1         while (             left_index < left_size         ):  # Adds the left over elements in the left half of the array             arr[index] = left_array[left_index]             left_index += 1             index += 1         while (             right_index < right_size         ):  # Adds the left over elements in the right half of the array             arr[index] = right_array[right_index]             right_index += 1             index += 1     return arr\n1: def create_vector(end_point1: Point3d, end_point2: Point3d) -> Vector3d:     x = end_point2[0] - end_point1[0]     y = end_point2[1] - end_point1[1]     z = end_point2[2] - end_point1[2]     return (x, y, z)\n2: def solution(nth: int = 10001) -> int:     return next(itertools.islice(prime_generator(), nth - 1, nth))", "output": "2"}
{"task": "detection", "input": "classify code:\ndef extended_euclidean_algorithm(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns True if n is pentagonal, False otherwise.\n\nChoices:\n0: def local_weight(     point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float ) -> np.ndarray:     weight_mat = weight_matrix(point, x_train, tau)     weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (         x_train.T @ weight_mat @ y_train.T     )      return weight\n1: def is_pentagonal(n: int) -> bool:     root = (1 + 24 * n) ** 0.5     return ((1 + root) / 6) % 1 == 0\n2: def guess_the_number(lower: int, higher: int, to_guess: int) -> None:     assert (         isinstance(lower, int) and isinstance(higher, int) and isinstance(to_guess, int)     ), 'argument values must be type of \"int\"'      if lower > higher:         raise ValueError(\"argument value for lower and higher must be(lower > higher)\")      if not lower < to_guess < higher:         raise ValueError(             \"guess value must be within the range of lower and higher value\"         )      def answer(number: int) -> str:         if number > to_guess:             return \"high\"         elif number < to_guess:             return \"low\"         else:             return \"same\"      print(\"started...\")      last_lowest = lower     last_highest = higher      last_numbers = []      while True:         number = get_avg(last_lowest, last_highest)         last_numbers.append(number)          if answer(number) == \"low\":             last_lowest = number         elif answer(number) == \"high\":             last_highest = number         else:             break      print(f\"guess the number : {last_numbers[-1]}\")     print(f\"details : {last_numbers!s}\")", "output": "1"}
{"task": "search", "input": "search code:\nReturns the value of 30th digit power sum.\n\nChoices:\n0: def solution(n: int = 30) -> int:     digit_to_powers = []     for digit in range(2, 100):         for power in range(2, 100):             number = int(math.pow(digit, power))             if digit == digit_sum(number):                 digit_to_powers.append(number)      digit_to_powers.sort()     return digit_to_powers[n - 1]\n1: def split_and_add(number: int) -> int:     sum_of_digits = 0     while number > 0:         last_digit = number % 10         sum_of_digits += last_digit         number = number // 10  # Removing the last_digit from the given number     return sum_of_digits\n2: def unwrap_text(text, ending='\\n\\n'):     all_grafs = []     cur_graf = []     for line in text.splitlines():         line = line.strip()         if line:             cur_graf.append(line)         else:             all_grafs.append(' '.join(cur_graf))             cur_graf = []     if cur_graf:         all_grafs.append(' '.join(cur_graf))     if ending is None:         return all_grafs     return ending.join(all_grafs)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef generate_pascal_triangle_optimized(num_rows: int) -> list[list[int]]:\n\n    if not isinstance(num_rows, int):\n        raise TypeError(\"The input value of 'num_rows' should be 'int'\")\n\n    if num_rows == 0:\n        return []\n    elif num_rows < 0:\n        raise ValueError(\n            \"The input value of 'num_rows' should be greater than or equal to 0\"\n        )\n\n    result: list[list[int]] = [[1]]\n\n    for row_index in range(1, num_rows):\n        temp_row = [0] + result[-1] + [0]\n        row_length = row_index + 1\n        # Calculate the number of distinct elements in a row\n        distinct_elements = sum(divmod(row_length, 2))\n        row_first_half = [\n            temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)\n        ]\n        row_second_half = row_first_half[: (row_index + 1) // 2]\n        row_second_half.reverse()\n        row = row_first_half + row_second_half\n        result.append(row)\n\n    return result", "output": "This function returns a matrix representing the corresponding pascal's triangle"}
{"task": "search", "input": "search code:\nRecur for all neighbours.\n\nChoices:\n0: def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:     # Mark current node as visited and add to recursion stack     visited.add(vertex)     rec_stk.add(vertex)      for node in graph[vertex]:         if node not in visited:             if depth_first_search(graph, node, visited, rec_stk):                 return True         elif node in rec_stk:             return True      # The node needs to be removed from recursion stack before function ends     rec_stk.remove(vertex)     return False\n1: def different_signs(num1: int, num2: int) -> bool:     return num1 ^ num2 < 0\n2: def matrix_pow_np(m: ndarray, power: int) -> ndarray:     result = np.array([[1, 0], [0, 1]], dtype=int)  # Identity Matrix     base = m     if power < 0:  # Negative power is not allowed         raise ValueError(\"power is negative\")     while power:         if power % 2 == 1:             result = np.dot(result, base)         base = np.dot(base, base)         power //= 2     return result", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef euler_phi(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    s = n\n    for x in set(prime_factors(n)):\n        s *= (x - 1) / x\n    return int(s)", "output": "Calculate Euler's Phi Function."}
{"task": "summary", "input": "summarize code:\ndef find_python_set(node: Node) -> set:\n    sets = ({0, 1, 2}, {3, 4, 5})\n    for s in sets:\n        if node.data in s:\n            return s\n    msg = f\"{node.data} is not in {sets}\"\n    raise ValueError(msg)", "output": "Return a Python Standard Library set that contains i."}
{"task": "summary", "input": "summarize code:\ndef print_preorder(root: Node | None) -> None:\n    if root:\n        print(root.value)\n        print_preorder(root.left)\n        print_preorder(root.right)", "output": "Print pre-order traversal of the tree."}
{"task": "repair", "input": "fix bug:\ndef reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> sentence = \"I love Python\"\n    >>> reverse_words(sentence) == \" \".join(sentence.split()[::-1])\n    True\n    >>> reverse_words(sentence)\n    'Python love I'\n    \"\"\"\n    return \" \".join(reversed(input_str.split(\" \")))", "output": "def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])"}
{"task": "detection", "input": "classify code:\ndef fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n    \"\"\"[summary]\n\n    This function will take input of drug name and zipcode,\n    then request to the BASE_URL site.\n    Get the page data and scrape it to generate the\n    list of the lowest prices for the prescription drug.\n\n    Args:\n        drug_name (str): [Drug name]\n        zip_code(str): [Zip code]\n\n    Returns:\n        list: [List of pharmacy name and price]\n\n    >>> print(fetch_pharmacy_and_price_list(None, None))\n    None\n    >>> print(fetch_pharmacy_and_price_list(None, 30303))\n    None\n    >>> print(fetch_pharmacy_and_price_list(\"eliquis\", None))\n    None\n    \"\"\"\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = httpx.get(request_url, timeout=10).raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contain the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get the price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (httpx.HTTPError, ValueError):\n        return None", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n    return compute_nums(1)[0]", "output": "Return the solution to the problem"}
{"task": "search", "input": "search code:\nCalculate the area of a ellipse.\n\nChoices:\n0: def area_ellipse(radius_x: float, radius_y: float) -> float:     if radius_x < 0 or radius_y < 0:         raise ValueError(\"area_ellipse() only accepts non-negative values\")     return pi * radius_x * radius_y\n1: def is_combination_valid(combination):     return (         int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))         == int(\"\".join(combination[5:9]))     ) or (         int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))         == int(\"\".join(combination[5:9]))     )\n2: def pretty_print(n):     if n <= 0:         return \"       ...       ....        nothing printing :(\"     upper_half = floyd(n)  # upper half     lower_half = reverse_floyd(n)  # lower half     return upper_half + lower_half", "output": "0"}
{"task": "search", "input": "search code:\n:param number: positive integer number\n\nChoices:\n0: def partition(src, key=bool):     bucketized = bucketize(src, key)     return bucketized.get(True, []), bucketized.get(False, [])\n1: def is_proth_number(number: int) -> bool:     if not isinstance(number, int):         message = f\"Input value of [{number=}] must be an integer\"         raise TypeError(message)      if number <= 0:         message = f\"Input value of [{number=}] must be > 0\"         raise ValueError(message)      if number == 1:         return False      number -= 1     n = 0     while number % 2 == 0:         n += 1         number //= 2     return number < 2**n\n2: def gray_code_sequence_string(bit_count: int) -> list:      # The approach is a recursive one     # Base case achieved when either n = 0 or n=1     if bit_count == 0:         return [\"0\"]      if bit_count == 1:         return [\"0\", \"1\"]      seq_len = 1 << bit_count  # defines the length of the sequence     # 1<< n is equivalent to 2^n      # recursive answer will generate answer for n-1 bits     smaller_sequence = gray_code_sequence_string(bit_count - 1)      sequence = []      # append 0 to first half of the smaller sequence generated     for i in range(seq_len // 2):         generated_no = \"0\" + smaller_sequence[i]         sequence.append(generated_no)      # append 1 to second half ... start from the end of the list     for i in reversed(range(seq_len // 2)):         generated_no = \"1\" + smaller_sequence[i]         sequence.append(generated_no)      return sequence", "output": "1"}
{"task": "search", "input": "search code:\nReturns the sum of the factorial of digits in n\n\nChoices:\n0: def is_pentagonal(n: int) -> bool:     root = (1 + 24 * n) ** 0.5     return ((1 + root) / 6) % 1 == 0\n1: def sum_of_digit_factorial(n: int) -> int:     return sum(DIGIT_FACTORIAL[d] for d in str(n))\n2: def sumset(set_a: set, set_b: set) -> set:     assert isinstance(set_a, set), f\"The input value of [set_a={set_a}] is not a set\"     assert isinstance(set_b, set), f\"The input value of [set_b={set_b}] is not a set\"      return {a + b for a in set_a for b in set_b}", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef right_rotation(node: MyNode) -> MyNode:\n    print(\"left rotation node:\", node.get_data())\n    ret = node.get_left()\n    assert ret is not None\n    node.set_left(ret.get_right())\n    ret.set_right(node)\n    h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1\n    node.set_height(h1)\n    h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1\n    ret.set_height(h2)\n    return ret", "output": "A B"}
{"task": "summary", "input": "summarize code:\ndef solution(percent: float = 99) -> int:\n    if not 0 < percent < 100:\n        raise ValueError(\"solution() only accepts values from 0 to 100\")\n    bouncy_num = 0\n    num = 1\n\n    while True:\n        if check_bouncy(num):\n            bouncy_num += 1\n        if (bouncy_num / num) * 100 >= percent:\n            return num\n        num += 1", "output": "Returns the least number for which the proportion of bouncy numbers is"}
{"task": "summary", "input": "summarize code:\ndef describe(data, quantiles=None, format=None):\n    return Stats(data).describe(quantiles=quantiles, format=format)", "output": "A convenience function to get standard summary statistics useful"}
{"task": "search", "input": "search code:\nTurn a value into a date and a timedelta which represents how long ago it was.\n\nChoices:\n0: def _date_and_delta(value, *, now=None):     if not now:         now = _now()     if isinstance(value, dt.datetime):         date = value         delta = now - value     elif isinstance(value, dt.timedelta):         date = now - value         delta = value     else:         try:             value = int(value)             delta = dt.timedelta(seconds=value)             date = now - delta         except (ValueError, TypeError):             return None, value     return date, _abs_timedelta(delta)\n1: def geometric_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 1     for value in series:         answer *= value     return pow(answer, 1 / len(series))\n2: def add_file_length(source_path: str, compressed: str) -> str:     file_length = os.path.getsize(source_path)     file_length_binary = bin(file_length)[2:]     length_length = len(file_length_binary)      return \"0\" * (length_length - 1) + file_length_binary + compressed", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef locate(iterable, pred=bool, window_size=None):\n    if window_size is None:\n        return compress(count(), map(pred, iterable))\n\n    if window_size < 1:\n        raise ValueError('window size must be at least 1')\n\n    it = windowed(iterable, window_size, fillvalue=_marker)\n    return compress(count(), starmap(pred, it))", "output": "Yield the index of each item in *iterable* for which *pred* returns"}
{"task": "search", "input": "search code:\nReturns the sum of all the multiples of 3 or 5 below n.\n\nChoices:\n0: def extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:     # base cases     if abs(a) == 1:         return a, 0     elif abs(b) == 1:         return 0, b      old_remainder, remainder = a, b     old_coeff_a, coeff_a = 1, 0     old_coeff_b, coeff_b = 0, 1      while remainder != 0:         quotient = old_remainder // remainder         old_remainder, remainder = remainder, old_remainder - quotient * remainder         old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a         old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b      # sign correction for negative numbers     if a < 0:         old_coeff_a = -old_coeff_a     if b < 0:         old_coeff_b = -old_coeff_b      return old_coeff_a, old_coeff_b\n1: def solution(n: int = 1000) -> int:      return sum(e for e in range(3, n) if e % 3 == 0 or e % 5 == 0)\n2: def res(x, y):     if 0 not in (x, y):         # We use the relation x^y = y*log10(x), where 10 is the base.         return y * math.log10(x)     elif x == 0:  # 0 raised to any number is 0         return 0     elif y == 0:         return 1  # any number raised to 0 is 1     raise AssertionError(\"This should never happen\")", "output": "1"}
{"task": "search", "input": "search code:\nComputes incrementing Fibonacci numbers starting from 3 until the length\n\nChoices:\n0: def term_frequency(term: str, document: str) -> int:     # strip all punctuation and newlines and replace it with ''     document_without_punctuation = document.translate(         str.maketrans(\"\", \"\", string.punctuation)     ).replace(\"\\n\", \"\")     tokenize_document = document_without_punctuation.split(\" \")  # word tokenization     return len([word for word in tokenize_document if word.lower() == term.lower()])\n1: def fibonacci_digits_index(n: int) -> int:     digits = 0     index = 2      while digits < n:         index += 1         digits = len(str(fibonacci(index)))      return index\n2: def solution(func: Callable[[int], int] = question_function, order: int = 10) -> int:     data_points: list[int] = [func(x_val) for x_val in range(1, order + 1)]      polynomials: list[Callable[[int], int]] = [         interpolate(data_points[:max_coeff]) for max_coeff in range(1, order + 1)     ]      ret: int = 0     poly: Callable[[int], int]     x_val: int      for poly in polynomials:         x_val = 1         while func(x_val) == poly(x_val):             x_val += 1          ret += poly(x_val)      return ret", "output": "1"}
{"task": "search", "input": "search code:\nReturns the sum of the digits in the factorial of num\n\nChoices:\n0: def main() -> None:     data_x, _data_y = collect_dataset()      # Number of principal components to retain     n_components = 2      # Apply PCA     transformed_data, variance_ratio = apply_pca(data_x, n_components)      print(\"Transformed Dataset (First 5 rows):\")     print(transformed_data[:5])      print(\"\\nExplained Variance Ratio:\")     print(variance_ratio)\n1: def solution(num: int = 100) -> int:     fact = 1     result = 0     for i in range(1, num + 1):         fact *= i      for j in str(fact):         result += int(j)      return result\n2: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)", "output": "1"}
{"task": "search", "input": "search code:\nExtended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n\nChoices:\n0: def extended_gcd(a: int, b: int) -> tuple[int, int, int]:     assert a >= 0     assert b >= 0      if b == 0:         d, x, y = a, 1, 0     else:         (d, p, q) = extended_gcd(b, a % b)         x = q         y = p - q * (a // b)      assert a % d == 0     assert b % d == 0     assert d == a * x + b * y      return (d, x, y)\n1: def slow_solution(max_power: int = 9) -> int:     result = 0     for length in range(1, max_power + 1):         result += slow_reversible_numbers(length, 0, [0] * length, length)     return result\n2: def z_function(input_str: str) -> list[int]:     z_result = [0 for i in range(len(input_str))]      # initialize interval's left pointer and right pointer     left_pointer, right_pointer = 0, 0      for i in range(1, len(input_str)):         # case when current index is inside the interval         if i <= right_pointer:             min_edge = min(right_pointer - i + 1, z_result[i - left_pointer])             z_result[i] = min_edge          while go_next(i, z_result, input_str):             z_result[i] += 1          # if new index's result gives us more right interval,         # we've to update left_pointer and right_pointer         if i + z_result[i] - 1 > right_pointer:             left_pointer, right_pointer = i, i + z_result[i] - 1      return z_result", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef _validate_input(points: list[Point] | list[list[float]]) -> list[Point]:\n\n    if not hasattr(points, \"__iter__\"):\n        msg = f\"Expecting an iterable object but got an non-iterable type {points}\"\n        raise ValueError(msg)\n\n    if not points:\n        msg = f\"Expecting a list of points but got {points}\"\n        raise ValueError(msg)\n\n    return _construct_points(points)", "output": "validates an input instance before a convex-hull algorithms uses it"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n\n    # unittest.main()\n\n    import doctest\n\n    doctest.testmod()\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-s\",\n        \"--string\",\n        dest=\"input_string\",\n        default=\"Hello World!! Welcome to Cryptography\",\n        help=\"Hash the string\",\n    )\n    parser.add_argument(\n        \"-f\", \"--file\", dest=\"input_file\", help=\"Hash contents of a file\"\n    )\n\n    args = parser.parse_args()\n\n    input_string = args.input_string\n\n    # hash input should be a bytestring\n    if args.input_file:\n        with open(args.input_file, \"rb\") as f:\n            hash_input = f.read()\n    else:\n        hash_input = bytes(input_string, \"utf-8\")\n\n    print(SHA256(hash_input).hash)", "output": "Provides option 'string' or 'file' to take input"}
{"task": "summary", "input": "summarize code:\ndef get_failure_array(pattern: str) -> list[int]:\n    failure = [0]\n    i = 0\n    j = 1\n    while j < len(pattern):\n        if pattern[i] == pattern[j]:\n            i += 1\n        elif i > 0:\n            i = failure[i - 1]\n            continue\n        j += 1\n        failure.append(i)\n    return failure", "output": "Calculates the new index we should go to if we fail a comparison"}
{"task": "summary", "input": "summarize code:\ndef is_prime(number: int) -> bool:\n\n    # precondition\n    assert isinstance(number, int) and (number >= 0), (\n        \"'number' must been an int and positive\"\n    )\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or not number % 2:\n        # Negatives, 0, 1 and all even numbers are not primes\n        return False\n\n    odd_numbers = range(3, int(math.sqrt(number) + 1), 2)\n    return not any(not number % i for i in odd_numbers)", "output": "Checks to see if a number is a prime in O(sqrt(n))."}
{"task": "summary", "input": "summarize code:\ndef fletcher16(text: str) -> int:\n    data = bytes(text, \"ascii\")\n    sum1 = 0\n    sum2 = 0\n    for character in data:\n        sum1 = (sum1 + character) % 255\n        sum2 = (sum1 + sum2) % 255\n    return (sum2 << 8) | sum1", "output": "Loop through every character in the data and add to two sums."}
{"task": "summary", "input": "summarize code:\ndef mae(predict, actual):\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = abs(predict - actual)\n    score = difference.mean()\n\n    return score", "output": "Examples(rounded for precision):"}
{"task": "summary", "input": "summarize code:\ndef repeat_each(iterable, n=2):\n    return chain.from_iterable(map(repeat, iterable, repeat(n)))", "output": "Repeat each element in *iterable* *n* times."}
{"task": "repair", "input": "fix bug:\ndef binary_multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply 'a' and 'b' using bitwise multiplication.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: a * b\n\n    Examples:\n    >>> binary_multiply(2, 3)\n    6\n    >>> binary_multiply(5, 0)\n    0\n    >>> binary_multiply(3, 4)\n    12\n    >>> binary_multiply(10, 5)\n    50\n    >>> binary_multiply(0, 5)\n    0\n    >>> binary_multiply(2, 1)\n    2\n    >>> binary_multiply(1, 10)\n    10\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res", "output": "def binary_multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply 'a' and 'b' using bitwise multiplication.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: a * b\n\n    Examples:\n    >>> binary_multiply(2, 3)\n    6\n    >>> binary_multiply(5, 0)\n    0\n    >>> binary_multiply(3, 4)\n    12\n    >>> binary_multiply(10, 5)\n    50\n    >>> binary_multiply(0, 5)\n    0\n    >>> binary_multiply(2, 1)\n    2\n    >>> binary_multiply(1, 10)\n    10\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res"}
{"task": "detection", "input": "classify code:\ndef is_sum_subset(arr, arr_len, required_sum):\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 4, 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 4, 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    subset = [[False for i in range(required_sum + 1)] for i in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    # uncomment to print the subset\n    # for i in range(arrLen+1):\n    #     print(subset[i])\n    print(subset[arr_len][required_sum])", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first", "output": "def add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first"}
{"task": "search", "input": "search code:\nThis function loops over a 2d matrix and calls binarySearch on\n\nChoices:\n0: def printboard(board: list[list[int]]) -> None:     for i in range(len(board)):         for j in range(len(board)):             if board[i][j] == 1:                 print(\"Q\", end=\" \")  # Queen is present             else:                 print(\".\", end=\" \")  # Empty cell         print()\n1: def find_isolated_nodes(graph):     isolated = []     for node in graph:         if not graph[node]:             isolated.append(node)     return isolated\n2: def mat_bin_search(value: int, matrix: list) -> list:     index = 0     if matrix[index][0] == value:         return [index, 0]     while index < len(matrix) and matrix[index][0] < value:         r = binary_search(matrix[index], 0, len(matrix[index]) - 1, value)         if r != -1:             return [index, r]         index += 1     return [-1, -1]", "output": "2"}
{"task": "search", "input": "search code:\nShortcut function to invoke MultiReplace in a single call.\n\nChoices:\n0: def _suppress_lower_units(min_unit, suppress):     suppress = set(suppress)     for u in Unit:         if u == min_unit:             break         suppress.add(u)      return suppress\n1: def draw_cross(x: float, y: float, length: float):     turtle.up()     turtle.goto(x - length / 2, y - length / 6)     turtle.down()     turtle.seth(0)     turtle.begin_fill()     for _ in range(4):         turtle.fd(length / 3)         turtle.right(90)         turtle.fd(length / 3)         turtle.left(90)         turtle.fd(length / 3)         turtle.left(90)     turtle.end_fill()\n2: def multi_replace(text, sub_map, **kwargs):     m = MultiReplace(sub_map, **kwargs)     return m.sub(text)", "output": "2"}
{"task": "search", "input": "search code:\nIterate the function \"eval_function\" exactly nb_iterations times.\n\nChoices:\n0: def centripetal(mass: float, velocity: float, radius: float) -> float:     if mass < 0:         raise ValueError(\"The mass of the body cannot be negative\")     if radius <= 0:         raise ValueError(\"The radius is always a positive non zero integer\")     return (mass * (velocity) ** 2) / radius\n1: def iterate_function(     eval_function: Callable[[Any, np.ndarray], np.ndarray],     function_params: Any,     nb_iterations: int,     z_0: np.ndarray,     infinity: float | None = None, ) -> np.ndarray:      z_n = z_0.astype(\"complex64\")     for _ in range(nb_iterations):         z_n = eval_function(function_params, z_n)         if infinity is not None:             np.nan_to_num(z_n, copy=False, nan=infinity)             z_n[abs(z_n) == np.inf] = infinity     return z_n\n2: def zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):      def is_scalar(obj):         if scalar_types and isinstance(obj, scalar_types):             return True         try:             iter(obj)         except TypeError:             return True         else:             return False      size = len(objects)     if not size:         return      new_item = [None] * size     iterables, iterable_positions = [], []     for i, obj in enumerate(objects):         if is_scalar(obj):             new_item[i] = obj         else:             iterables.append(iter(obj))             iterable_positions.append(i)      if not iterables:         yield tuple(objects)         return      for item in zip(*iterables, strict=strict):         for i, new_item[i] in zip(iterable_positions, item):             pass         yield tuple(new_item)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef recursive_imply_list(input_list: list[int]) -> int:\n    if len(input_list) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n    first_implication = imply_gate(input_list[0], input_list[1])\n    if len(input_list) == 2:\n        return first_implication\n    new_list = [first_implication, *input_list[2:]]\n    return recursive_imply_list(new_list)", "output": "Recursively calculates the implication of a list."}
{"task": "search", "input": "search code:\nTakes a number and checks if it is pandigital from END\n\nChoices:\n0: def _extract_buffered(iterator, index_and_position):     'Arbitrary index order, greedily consumed'     buffer = {}     iterator_position = -1     next_to_emit = 0      for index, order in index_and_position:         advance = index - iterator_position         if advance:             try:                 value = next(islice(iterator, advance - 1, None))             except StopIteration:                 raise IndexError(index) from None             iterator_position = index          buffer[order] = value          while next_to_emit in buffer:             yield buffer.pop(next_to_emit)             next_to_emit += 1\n1: def check1(number: int) -> bool:      check_last = [0] * 11      # mark last 9 numbers     for _ in range(9):         check_last[int(number % 10)] = 1         number = number // 10     # flag     f = True      # check last 9 numbers for pandigitality      for x in range(9):         if not check_last[x + 1]:             f = False     return f\n2: def min_steps_to_one(number: int) -> int:      if number <= 0:         msg = f\"n must be greater than 0. Got n = {number}\"         raise ValueError(msg)      table = [number + 1] * (number + 1)      # starting position     table[1] = 0     for i in range(1, number):         table[i + 1] = min(table[i + 1], table[i] + 1)         # check if out of bounds         if i * 2 <= number:             table[i * 2] = min(table[i * 2], table[i] + 1)         # check if out of bounds         if i * 3 <= number:             table[i * 3] = min(table[i * 3], table[i] + 1)     return table[number]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    return fibonacci_digits_index(n)", "output": "Returns the index of the first term in the Fibonacci sequence to contain"}
{"task": "summary", "input": "summarize code:\ndef _construct_points(\n    list_of_tuples: list[Point] | list[list[float]] | Iterable[list[float]],\n) -> list[Point]:\n\n    points: list[Point] = []\n    if list_of_tuples:\n        for p in list_of_tuples:\n            if isinstance(p, Point):\n                points.append(p)\n            else:\n                try:\n                    points.append(Point(p[0], p[1]))\n                except (IndexError, TypeError):\n                    print(\n                        f\"Ignoring deformed point {p}. All points\"\n                        \" must have at least 2 coordinates.\"\n                    )\n    return points", "output": "constructs a list of points from an array-like object of numbers"}
{"task": "summary", "input": "summarize code:\ndef liouville_lambda(number: int) -> int:\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    return -1 if len(prime_factors(number)) % 2 else 1", "output": "This functions takes an integer number as input."}
{"task": "summary", "input": "summarize code:\ndef _shift_to_odd(n):\n    'Return s, d such that 2**s * d == n'\n    s = ((n - 1) ^ n).bit_length() - 1\n    d = n >> s\n    assert (1 << s) * d == n and d & 1 and s >= 0\n    return s, d", "output": "Return s, d such that 2**s * d == n"}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n1: def solution(n: int = 100) -> int:      sum_of_squares = 0     sum_of_ints = 0     for i in range(1, n + 1):         sum_of_squares += i**2         sum_of_ints += i     return sum_of_ints**2 - sum_of_squares\n2: def counting_sort(collection):     # if the collection is empty, returns empty     if collection == []:         return []      # get some information about the collection     coll_len = len(collection)     coll_max = max(collection)     coll_min = min(collection)      # create the counting array     counting_arr_length = coll_max + 1 - coll_min     counting_arr = [0] * counting_arr_length      # count how much a number appears in the collection     for number in collection:         counting_arr[number - coll_min] += 1      # sum each position with it's predecessors. now, counting_arr[i] tells     # us how many elements <= i has in the collection     for i in range(1, counting_arr_length):         counting_arr[i] = counting_arr[i] + counting_arr[i - 1]      # create the output collection     ordered = [0] * coll_len      # place the elements in the output, respecting the original order (stable     # sort) from end to begin, updating counting_arr     for i in reversed(range(coll_len)):         ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]         counting_arr[collection[i] - coll_min] -= 1      return ordered", "output": "0"}
{"task": "detection", "input": "classify code:\ndef max_difference(a: list[int]) -> tuple[int, int]:\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second", "output": "CORRECT"}
{"task": "search", "input": "search code:\nGenerate the triangular number at the specified position.\n\nChoices:\n0: def solution(n: int = 1000) -> int:      a = 3     result = 0     while a < n:         if a % 3 == 0 or a % 5 == 0:             result += a         elif a % 15 == 0:             result -= a         a += 1     return result\n1: def triangular_number(position: int) -> int:     if position < 0:         raise ValueError(\"param `position` must be non-negative\")      return position * (position + 1) // 2\n2: def prepend(value, iterator):     return chain([value], iterator)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef can_string_be_rearranged_as_palindrome_counter(\n    input_str: str = \"\",\n) -> bool:\n    return sum(c % 2 for c in Counter(input_str.replace(\" \", \"\").lower()).values()) < 2", "output": "A Palindrome is a String that reads the same forward as it does backwards."}
{"task": "search", "input": "search code:\nFunction checks the all possible combinations with using bottom up approach,\n\nChoices:\n0: def check1(number: int) -> bool:      check_last = [0] * 11      # mark last 9 numbers     for _ in range(9):         check_last[int(number % 10)] = 1         number = number // 10     # flag     f = True      # check last 9 numbers for pandigitality      for x in range(9):         if not check_last[x + 1]:             f = False     return f\n1: def combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:      dp_array = [0] * (target + 1)     dp_array[0] = 1      for i in range(1, target + 1):         for j in range(n):             if i - array[j] >= 0:                 dp_array[i] += dp_array[i - array[j]]      return dp_array[target]\n2: def get_cluster(nodes):     cluster = {}     for key, value in nodes.items():         cluster.setdefault(key.count(\"1\"), {})[key] = value     return cluster", "output": "1"}
{"task": "search", "input": "search code:\nSplit number digits and add them.\n\nChoices:\n0: def split_and_add(number: int) -> int:     sum_of_digits = 0     while number > 0:         last_digit = number % 10         sum_of_digits += last_digit         number = number // 10  # Removing the last_digit from the given number     return sum_of_digits\n1: def subset_combinations(elements: list[int], n: int) -> list:     r = len(elements)     if n > r:         return []      dp: list[list[tuple]] = [[] for _ in range(r + 1)]      dp[0].append(())      for i in range(1, r + 1):         for j in range(i, 0, -1):             for prev_combination in dp[j - 1]:                 dp[j].append((*prev_combination, elements[i - 1]))      try:         return sorted(dp[n])     except TypeError:         return dp[n]\n2: def _hypothesis_value(data_input_tuple):     hyp_val = 0     for i in range(len(parameter_vector) - 1):         hyp_val += data_input_tuple[i] * parameter_vector[i + 1]     hyp_val += parameter_vector[0]     return hyp_val", "output": "0"}
{"task": "search", "input": "search code:\nfind max value in list\n\nChoices:\n0: def find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:     if len(nums) == 0:         raise ValueError(\"find_max_recursive() arg is an empty sequence\")     if (         left >= len(nums)         or left < -len(nums)         or right >= len(nums)         or right < -len(nums)     ):         raise IndexError(\"list index out of range\")     if left == right:         return nums[left]     mid = (left + right) >> 1  # the middle     left_max = find_max_recursive(nums, left, mid)  # find max in range[left, mid]     right_max = find_max_recursive(         nums, mid + 1, right     )  # find max in range[mid + 1, right]      return left_max if left_max >= right_max else right_max\n1: def slowsort(sequence: list, start: int | None = None, end: int | None = None) -> None:     if start is None:         start = 0      if end is None:         end = len(sequence) - 1      if start >= end:         return      mid = (start + end) // 2      slowsort(sequence, start, mid)     slowsort(sequence, mid + 1, end)      if sequence[end] < sequence[mid]:         sequence[end], sequence[mid] = sequence[mid], sequence[end]      slowsort(sequence, start, end - 1)\n2: def hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:      # Initialize path with -1, indicating that we have not visited them yet     path = [-1] * (len(graph) + 1)     # initialize start and end of path with starting index     path[0] = path[-1] = start_index     # evaluate and if we find answer return path either return empty array     return path if util_hamilton_cycle(graph, path, 1) else []", "output": "0"}
{"task": "search", "input": "search code:\nYield the prime factors of n.\n\nChoices:\n0: def factor(n):      # Corner case reduction     if n < 2:         return      # Trial division reduction     for prime in _primes_below_211:         while not n % prime:             yield prime             n //= prime      # Pollard's rho reduction     primes = []     todo = [n] if n > 1 else []     for n in todo:         if n < 211**2 or is_prime(n):             primes.append(n)         else:             fact = _factor_pollard(n)             todo += (fact, n // fact)     yield from sorted(primes)\n1: def encipher(message: str, cipher_map: dict[str, str]) -> str:     return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())\n2: def hexagonal(number: int) -> int:     if not isinstance(number, int):         msg = f\"Input value of [number={number}] must be an integer\"         raise TypeError(msg)     if number < 1:         raise ValueError(\"Input must be a positive integer\")     return number * (2 * number - 1)", "output": "0"}
{"task": "search", "input": "search code:\nSplits an iterable based on a separator. Like :meth:`str.split`,\n\nChoices:\n0: def is_arithmetic_series(series: list) -> bool:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     if len(series) == 1:         return True     common_diff = series[1] - series[0]     for index in range(len(series) - 1):         if series[index + 1] - series[index] != common_diff:             return False     return True\n1: def solution(matrix_str: list[str] = MATRIX_2) -> int:      n = len(matrix_str)     arr = np.empty(shape=(n, n), dtype=int)     for row, matrix_row_str in enumerate(matrix_str):         matrix_row_list_str = matrix_row_str.split()         for col, elem_str in enumerate(matrix_row_list_str):             arr[row, col] = int(elem_str)      cache: dict[str, int] = {}     return solve(arr=arr, row=0, cols=set(range(n)), cache=cache)\n2: def split(src, sep=None, maxsplit=None):     return list(split_iter(src, sep, maxsplit))", "output": "2"}
{"task": "search", "input": "search code:\nA function to print the solution in the form\n\nChoices:\n0: def can_string_be_rearranged_as_palindrome(input_str: str = \"\") -> bool:     if len(input_str) == 0:         return True     lower_case_input_str = input_str.replace(\" \", \"\").lower()     # character_freq_dict: Stores the frequency of every character in the input string     character_freq_dict: dict[str, int] = {}      for character in lower_case_input_str:         character_freq_dict[character] = character_freq_dict.get(character, 0) + 1     odd_char = 0      for character_count in character_freq_dict.values():         if character_count % 2:             odd_char += 1     return not odd_char > 1\n1: def print_solution(grid: Matrix) -> None:     for row in grid:         for cell in row:             print(cell, end=\" \")         print()\n2: def decode(coded: str) -> str:     if set(coded) - {\"A\", \"B\", \" \"} != set():         raise Exception(\"decode() accepts only 'A', 'B' and spaces\")     decoded = \"\"     for word in coded.split():         while len(word) != 0:             decoded += decode_dict[word[:5]]             word = word[5:]         decoded += \" \"     return decoded.strip()", "output": "1"}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def interleave_evenly(iterables, lengths=None):     if lengths is None:         try:             lengths = [len(it) for it in iterables]         except TypeError:             raise ValueError(                 'Iterable lengths could not be determined automatically. '                 'Specify them with the lengths keyword.'             )     elif len(iterables) != len(lengths):         raise ValueError('Mismatching number of iterables and lengths.')      dims = len(lengths)      # sort iterables by length, descending     lengths_permute = sorted(         range(dims), key=lambda i: lengths[i], reverse=True     )     lengths_desc = [lengths[i] for i in lengths_permute]     iters_desc = [iter(iterables[i]) for i in lengths_permute]      # the longest iterable is the primary one (Bresenham: the longest     # distance along an axis)     delta_primary, deltas_secondary = lengths_desc[0], lengths_desc[1:]     iter_primary, iters_secondary = iters_desc[0], iters_desc[1:]     errors = [delta_primary // dims] * len(deltas_secondary)      to_yield = sum(lengths)     while to_yield:         yield next(iter_primary)         to_yield -= 1         # update errors for each secondary iterable         errors = [e - delta for e, delta in zip(errors, deltas_secondary)]          # those iterables for which the error is negative are yielded         # (\"diagonal step\" in Bresenham)         for i, e_ in enumerate(errors):             if e_ < 0:                 yield next(iters_secondary[i])                 to_yield -= 1                 errors[i] += delta_primary\n1: def base16_encode(data: bytes) -> str:     # Turn the data into a list of integers (where each integer is a byte),     # Then turn each byte into its hexadecimal representation, make sure     # it is uppercase, and then join everything together and return it.     return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "2"}
{"task": "search", "input": "search code:\nFormat a number of bytes like a human readable filesize (e.g. 10 kB).\n\nChoices:\n0: def _maybe_download(filename, work_directory, source_url):     if not gfile.Exists(work_directory):         gfile.MakeDirs(work_directory)     filepath = os.path.join(work_directory, filename)     if not gfile.Exists(filepath):         urllib.request.urlretrieve(source_url, filepath)  # noqa: S310         with gfile.GFile(filepath) as f:             size = f.size()         print(\"Successfully downloaded\", filename, size, \"bytes.\")     return filepath\n1: def naturalsize(value, binary=False, gnu=False, format=\"%.1f\"):     if gnu:         suffix = suffixes[\"gnu\"]     elif binary:         suffix = suffixes[\"binary\"]     else:         suffix = suffixes[\"decimal\"]      base = 1024 if (gnu or binary) else 1000     bytes = float(value)     abs_bytes = abs(bytes)      if abs_bytes == 1 and not gnu:         return \"%d Byte\" % bytes     elif abs_bytes < base and not gnu:         return \"%d Bytes\" % bytes     elif abs_bytes < base and gnu:         return \"%dB\" % bytes      for i, s in enumerate(suffix):         unit = base ** (i + 2)         if abs_bytes < unit and not gnu:             return (format + \" %s\") % ((base * bytes / unit), s)         elif abs_bytes < unit and gnu:             return (format + \"%s\") % ((base * bytes / unit), s)     if gnu:         return (format + \"%s\") % ((base * bytes / unit), s)     return (format + \" %s\") % ((base * bytes / unit), s)\n2: def pretty_print(n):     if n <= 0:         return \"       ...       ....        nothing printing :(\"     upper_half = floyd(n)  # upper half     lower_half = reverse_floyd(n)  # lower half     return upper_half + lower_half", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef idft(Xarr):\n    N = len(Xarr)\n    roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]\n    for k in range(N):\n        coeffs = [roots_of_unity[k * n % N] for n in range(N)]\n        yield _complex_sumprod(Xarr, coeffs) / N", "output": "Inverse Discrete Fourier Transform. *Xarr* is a sequence of"}
{"task": "search", "input": "search code:\nGet a list containing all instances of a given type. This will\n\nChoices:\n0: def get_all(type_obj, include_subtypes=True):     # TODO: old-style classes     if not isinstance(type_obj, type):         raise TypeError('expected a type, not %r' % type_obj)     try:         type_is_tracked = gc.is_tracked(type_obj)     except AttributeError:         type_is_tracked = False  # Python 2.6 and below don't get the speedup     if type_is_tracked:         to_check = gc.get_referrers(type_obj)     else:         to_check = gc.get_objects()      if include_subtypes:         ret = [x for x in to_check if isinstance(x, type_obj)]     else:         ret = [x for x in to_check if type(x) is type_obj]     return ret\n1: def crossover(parent_1: str, parent_2: str) -> tuple[str, str]:     random_slice = random.randint(0, len(parent_1) - 1)     child_1 = parent_1[:random_slice] + parent_2[random_slice:]     child_2 = parent_2[:random_slice] + parent_1[random_slice:]     return (child_1, child_2)\n2: def gunzip_bytes(bytestring):     return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)", "output": "0"}
{"task": "search", "input": "search code:\nMirror binary trees with the given root and returns the root\n\nChoices:\n0: def change_brightness(img: Image, level: float) -> Image:      def brightness(c: int) -> float:         return 128 + level + (c - 128)      if not -255.0 <= level <= 255.0:         raise ValueError(\"level must be between -255.0 (black) and 255.0 (white)\")     return img.point(brightness)\n1: def main() -> None:     trees = {\"zero\": Node(0), \"seven\": make_tree_seven(), \"nine\": make_tree_nine()}     for name, tree in trees.items():         print(f\"      The {name} tree: {tuple(tree)}\")         # (0,)         # (4, 2, 5, 1, 6, 3, 7)         # (7, 4, 8, 2, 5, 9, 1, 3, 6)         print(f\"Mirror of {name} tree: {tuple(tree.mirror())}\")\n2: def multi_replace(text, sub_map, **kwargs):     m = MultiReplace(sub_map, **kwargs)     return m.sub(text)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef is_collection(obj):\n    return is_iterable(obj) and not isinstance(obj, (str, bytes))", "output": "The opposite of :func:`is_scalar`. Returns ``True`` if an object"}
{"task": "summary", "input": "summarize code:\ndef random_matrix(width: int, height: int, a: int, b: int) -> Matrix:\n    random.seed(None)\n    matrix: list[list[float]] = [\n        [random.randint(a, b) for _ in range(width)] for _ in range(height)\n    ]\n    return Matrix(matrix, width, height)", "output": "returns a random matrix WxH with integer components"}
{"task": "detection", "input": "classify code:\ndef euclidean_distance_sqr(point1, point2):\n    \"\"\"\n    >>> euclidean_distance_sqr([1,2],[2,4])\n    5\n    \"\"\"\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res", "output": "def binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n    limit = 7 * factorial(9) + 1\n    return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)", "output": "Returns the sum of all numbers whose"}
{"task": "summary", "input": "summarize code:\ndef encode(plaintext: str, key: str) -> str:\n\n    table = generate_table(key)\n    plaintext = prepare_input(plaintext)\n    ciphertext = \"\"\n\n    for char1, char2 in chunker(plaintext, 2):\n        row1, col1 = divmod(table.index(char1), 5)\n        row2, col2 = divmod(table.index(char2), 5)\n\n        if row1 == row2:\n            ciphertext += table[row1 * 5 + (col1 + 1) % 5]\n            ciphertext += table[row2 * 5 + (col2 + 1) % 5]\n        elif col1 == col2:\n            ciphertext += table[((row1 + 1) % 5) * 5 + col1]\n            ciphertext += table[((row2 + 1) % 5) * 5 + col2]\n        else:  # rectangle\n            ciphertext += table[row1 * 5 + col2]\n            ciphertext += table[row2 * 5 + col1]\n\n    return ciphertext", "output": "Encode the given plaintext using the Playfair cipher."}
{"task": "summary", "input": "summarize code:\ndef multiplication_table(number: int, number_of_terms: int) -> str:\n    return \"\\n\".join(\n        f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)\n    )", "output": "Prints the multiplication table of a given number till the given number of terms"}
{"task": "search", "input": "search code:\nimage: is a grayscale PIL image object\n\nChoices:\n0: def n_input_and_gate(inputs: list[int]) -> int:     return int(all(inputs))\n1: def mean_threshold(image: Image) -> Image:     height, width = image.size     mean = 0     pixels = image.load()     for i in range(width):         for j in range(height):             pixel = pixels[j, i]             mean += pixel     mean //= width * height      for j in range(width):         for i in range(height):             pixels[i, j] = 255 if pixels[i, j] > mean else 0     return image\n2: def main() -> None:     kmap = [[0, 1], [1, 1]]      # Manually generate the product of [0, 1] and [0, 1]      for row in kmap:         print(row)      print(\"Simplified Expression:\")     print(simplify_kmap(kmap))", "output": "1"}
{"task": "search", "input": "search code:\nEquivalent to\n\nChoices:\n0: def dynamic_lucas_number(n_th_number: int) -> int:     if not isinstance(n_th_number, int):         raise TypeError(\"dynamic_lucas_number accepts only integer arguments.\")     a, b = 2, 1     for _ in range(n_th_number):         a, b = b, a + b     return a\n1: def combination_with_replacement_index(element, iterable):     element = tuple(element)     l = len(element)     element = enumerate(element)      k, y = next(element, (None, None))     if k is None:         return 0      indexes = []     pool = tuple(iterable)     for n, x in enumerate(pool):         while x == y:             indexes.append(n)             tmp, y = next(element, (None, None))             if tmp is None:                 break             else:                 k = tmp         if y is None:             break     else:         raise ValueError(             'element is not a combination with replacement of iterable'         )      n = len(pool)     occupations = [0] * n     for p in indexes:         occupations[p] += 1      index = 0     cumulative_sum = 0     for k in range(1, n):         cumulative_sum += occupations[k - 1]         j = l + n - 1 - k - cumulative_sum         i = n - k         if i <= j:             index += comb(j, i)      return index\n2: def is_collection(obj):     return is_iterable(obj) and not isinstance(obj, (str, bytes))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    triangle = os.path.join(script_dir, \"triangle.txt\")\n\n    with open(triangle) as f:\n        triangle = f.readlines()\n\n    a = [[int(y) for y in x.rstrip(\"\\r\\n\").split(\" \")] for x in triangle]\n\n    for i in range(1, len(a)):\n        for j in range(len(a[i])):\n            number1 = a[i - 1][j] if j != len(a[i - 1]) else 0\n            number2 = a[i - 1][j - 1] if j > 0 else 0\n            a[i][j] += max(number1, number2)\n    return max(a[-1])", "output": "Finds the maximum total in a triangle as described by the problem statement"}
{"task": "summary", "input": "summarize code:\ndef clamp(value, format=\"{:}\", floor=None, ceil=None, floor_token=\"<\", ceil_token=\">\"):\n    if value is None:\n        return None\n\n    if floor is not None and value < floor:\n        value = floor\n        token = floor_token\n    elif ceil is not None and value > ceil:\n        value = ceil\n        token = ceil_token\n    else:\n        token = \"\"\n\n    if isinstance(format, str):\n        return token + format.format(value)\n    elif callable(format):\n        return token + format(value)\n    else:\n        raise ValueError(\n            \"Invalid format. Must be either a valid formatting string, or a function \"\n            \"that accepts value and returns a string.\"\n        )", "output": "Returns number with the specified format, clamped between floor and ceil."}
{"task": "repair", "input": "fix bug:\ndef count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions", "output": "def count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions"}
{"task": "summary", "input": "summarize code:\ndef heap_sort(unsorted: list[int]) -> list[int]:\n    n = len(unsorted)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(unsorted, i, n)\n    for i in range(n - 1, 0, -1):\n        unsorted[0], unsorted[i] = unsorted[i], unsorted[0]\n        heapify(unsorted, 0, i)\n    return unsorted", "output": "A pure Python implementation of the heap sort algorithm"}
{"task": "repair", "input": "fix bug:\ndef decimal_to_binary(no_of_variable: int, minterms: List[float]) -> List[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp", "output": "def decimal_to_binary(no_of_variable: int, minterms: list[float]) -> list[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp"}
{"task": "summary", "input": "summarize code:\ndef electric_power(voltage: float, current: float, power: float) -> tuple:\n    if (voltage, current, power).count(0) != 1:\n        raise ValueError(\"Exactly one argument must be 0\")\n    elif power < 0:\n        raise ValueError(\n            \"Power cannot be negative in any electrical/electronics system\"\n        )\n    elif voltage == 0:\n        return Result(\"voltage\", power / current)\n    elif current == 0:\n        return Result(\"current\", power / voltage)\n    elif power == 0:\n        return Result(\"power\", float(round(abs(voltage * current), 2)))\n    else:\n        raise AssertionError", "output": "This function can calculate any one of the three (voltage, current, power),"}
{"task": "summary", "input": "summarize code:\ndef sigmoid(value: np.ndarray) -> np.ndarray:\n    return 1 / (1 + np.exp(-value))", "output": "Applies sigmoid activation function."}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    trees = {\"zero\": Node(0), \"seven\": make_tree_seven(), \"nine\": make_tree_nine()}\n    for name, tree in trees.items():\n        print(f\"      The {name} tree: {tuple(tree)}\")\n        # (0,)\n        # (4, 2, 5, 1, 6, 3, 7)\n        # (7, 4, 8, 2, 5, 9, 1, 3, 6)\n        print(f\"Mirror of {name} tree: {tuple(tree.mirror())}\")", "output": "Mirror binary trees with the given root and returns the root"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 100) -> int:\n\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares", "output": "Returns the difference between the sum of the squares of the first n"}
{"task": "search", "input": "search code:\nYield the distinct combinations of *r* items taken from *iterable*.\n\nChoices:\n0: def singularize(word):     orig_word, word = word, word.strip().lower()     if not word or word in _IRR_S2P:         return orig_word      irr_singular = _IRR_P2S.get(word)     if irr_singular:         singular = irr_singular     elif not word.endswith('s'):         return orig_word     elif len(word) == 2:         singular = word[:-1]  # or just return word?     elif word.endswith('ies') and word[-4:-3] not in 'aeiou':         singular = word[:-3] + 'y'     elif word.endswith('es') and word[-3] == 's':         singular = word[:-2]     else:         singular = word[:-1]     return _match_case(orig_word, singular)\n1: def print_linked_list(head: Node | None) -> None:     if head is None:         return     while head.next_node is not None:         print(head.data, end=\"->\")         head = head.next_node     print(head.data)\n2: def distinct_combinations(iterable, r):     if r < 0:         raise ValueError('r must be non-negative')     elif r == 0:         yield ()         return     pool = tuple(iterable)     generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]     current_combo = [None] * r     level = 0     while generators:         try:             cur_idx, p = next(generators[-1])         except StopIteration:             generators.pop()             level -= 1             continue         current_combo[level] = p         if level + 1 == r:             yield tuple(current_combo)         else:             generators.append(                 unique_everseen(                     enumerate(pool[cur_idx + 1 :], cur_idx + 1),                     key=itemgetter(1),                 )             )             level += 1", "output": "2"}
{"task": "detection", "input": "classify code:\ndef mel_to_freq(mels: float) -> float:\n    \"\"\"\n    Convert a frequency in the mel scale to Hertz.\n\n    Args:\n        mels: The frequency in mel scale.\n\n    Returns:\n        The frequency in Hertz.\n\n    Examples:\n    >>> round(mel_to_freq(999.99), 2)\n    1000.01\n    \"\"\"\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nQuote the fragment part of the URL. Fragments don't have\n\nChoices:\n0: def is_complete(board: list[list[int]]) -> bool:      return not any(elem == 0 for row in board for elem in row)\n1: def gaussian_elimination(     coefficients: NDArray[float64], vector: NDArray[float64] ) -> NDArray[float64]:     # coefficients must to be a square matrix so we need to check first     rows, columns = np.shape(coefficients)     if rows != columns:         return np.array((), dtype=float)      # augmented matrix     augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)     augmented_mat = augmented_mat.astype(\"float64\")      # scale the matrix leaving it triangular     for row in range(rows - 1):         pivot = augmented_mat[row, row]         for col in range(row + 1, columns):             factor = augmented_mat[col, row] / pivot             augmented_mat[col, :] -= factor * augmented_mat[row, :]      x = retroactive_resolution(         augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]     )      return x\n2: def quote_fragment_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])     return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t                      for t in text])", "output": "2"}
{"task": "search", "input": "search code:\nUpdate the speed of the cars\n\nChoices:\n0: def solution(max_d: int = 12_000) -> int:      fractions_number = 0     for d in range(max_d + 1):         n_start = d // 3 + 1         n_step = 1         if d % 2 == 0:             n_start += 1 - n_start % 2             n_step = 2         for n in range(n_start, (d + 1) // 2, n_step):             if gcd(n, d) == 1:                 fractions_number += 1     return fractions_number\n1: def gray_code_sequence_string(bit_count: int) -> list:      # The approach is a recursive one     # Base case achieved when either n = 0 or n=1     if bit_count == 0:         return [\"0\"]      if bit_count == 1:         return [\"0\", \"1\"]      seq_len = 1 << bit_count  # defines the length of the sequence     # 1<< n is equivalent to 2^n      # recursive answer will generate answer for n-1 bits     smaller_sequence = gray_code_sequence_string(bit_count - 1)      sequence = []      # append 0 to first half of the smaller sequence generated     for i in range(seq_len // 2):         generated_no = \"0\" + smaller_sequence[i]         sequence.append(generated_no)      # append 1 to second half ... start from the end of the list     for i in reversed(range(seq_len // 2)):         generated_no = \"1\" + smaller_sequence[i]         sequence.append(generated_no)      return sequence\n2: def update(highway_now: list, probability: float, max_speed: int) -> list:      number_of_cells = len(highway_now)     # Beforce calculations, the highway is empty     next_highway = [-1] * number_of_cells      for car_index in range(number_of_cells):         if highway_now[car_index] != -1:             # Add 1 to the current speed of the car and cap the speed             next_highway[car_index] = min(highway_now[car_index] + 1, max_speed)             # Number of empty cell before the next car             dn = get_distance(highway_now, car_index) - 1             # We can't have the car causing an accident             next_highway[car_index] = min(next_highway[car_index], dn)             if random() < probability:                 # Randomly, a driver will slow down                 next_highway[car_index] = max(next_highway[car_index] - 1, 0)     return next_highway", "output": "2"}
{"task": "search", "input": "search code:\nTimes the execution of a function with parameters\n\nChoices:\n0: def solution(n: int = 100) -> int:      sum_of_squares = sum(i * i for i in range(1, n + 1))     square_of_sum = int(math.pow(sum(range(1, n + 1)), 2))     return square_of_sum - sum_of_squares\n1: def time_func(func, *args, **kwargs):     start = time()     output = func(*args, **kwargs)     end = time()     if int(end - start) > 0:         print(f\"{func.__name__} runtime: {(end - start):0.4f} s\")     else:         print(f\"{func.__name__} runtime: {(end - start) * 1000:0.4f} ms\")     return output\n2: def windowed(seq, n, fillvalue=None, step=1):     if n < 0:         raise ValueError('n must be >= 0')     if n == 0:         yield ()         return     if step < 1:         raise ValueError('step must be >= 1')      iterator = iter(seq)      # Generate first window     window = deque(islice(iterator, n), maxlen=n)      # Deal with the first window not being full     if not window:         return     if len(window) < n:         yield tuple(window) + ((fillvalue,) * (n - len(window)))         return     yield tuple(window)      # Create the filler for the next windows. The padding ensures     # we have just enough elements to fill the last window.     padding = (fillvalue,) * (n - 1 if step >= n else step - 1)     filler = map(window.append, chain(iterator, padding))      # Generate the rest of the windows     for _ in islice(filler, step - 1, None, step):         yield tuple(window)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef benchmark() -> None:\n    import timeit\n\n    print(\n        timeit.timeit(\"solution()\", setup=\"from __main__ import solution\", number=1000)\n    )\n    print(\n        timeit.timeit(\n            \"solution_fast()\", setup=\"from __main__ import solution_fast\", number=1000\n        )\n    )", "output": "Benchmark code comparing two different version function."}
{"task": "summary", "input": "summarize code:\ndef check_partition_perfect(positive_integer: int) -> bool:\n\n    exponent = math.log2(math.sqrt(4 * positive_integer + 1) / 2 + 1 / 2)\n\n    return exponent == int(exponent)", "output": "Check if t = f(positive_integer) = log2(sqrt(4*positive_integer+1)/2 + 1/2) is a"}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def open_knight_tour_helper(     board: list[list[int]], pos: tuple[int, int], curr: int ) -> bool:      if is_complete(board):         return True      for position in get_valid_pos(pos, len(board)):         y, x = position          if board[y][x] == 0:             board[y][x] = curr + 1             if open_knight_tour_helper(board, position, curr + 1):                 return True             board[y][x] = 0      return False\n1: def vol_cuboid(width: float, height: float, length: float) -> float:     if width < 0 or height < 0 or length < 0:         raise ValueError(\"vol_cuboid() only accepts non-negative values\")     return float(width * height * length)\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "2"}
{"task": "search", "input": "search code:\nCeq = 1/ (1/C1 + 1/C2 + ... + 1/Cn)\n\nChoices:\n0: def dijk(g, s):     dist, known, path = {s: 0}, set(), {s: 0}     while True:         if len(known) == len(g) - 1:             break         mini = 100000         for key, value in dist:             if key not in known and value < mini:                 mini = value                 u = key         known.add(u)         for v in g[u]:             if v[0] not in known and dist[u] + v[1] < dist.get(v[0], 100000):                 dist[v[0]] = dist[u] + v[1]                 path[v[0]] = u     for key, value in dist.items():         if key != s:             print(value)\n1: def capacitor_series(capacitors: list[float]) -> float:      first_sum = 0.0     for index, capacitor in enumerate(capacitors):         if capacitor <= 0:             msg = f\"Capacitor at index {index} has a negative or zero value!\"             raise ValueError(msg)         first_sum += 1 / capacitor     return 1 / first_sum\n2: def print_binary_search_tree(root, key, i, j, parent, is_left):     if i > j or i < 0 or j > len(root) - 1:         return      node = root[i][j]     if parent == -1:  # root does not have a parent         print(f\"{key[node]} is the root of the binary search tree.\")     elif is_left:         print(f\"{key[node]} is the left child of key {parent}.\")     else:         print(f\"{key[node]} is the right child of key {parent}.\")      print_binary_search_tree(root, key, i, node - 1, key[node], True)     print_binary_search_tree(root, key, node + 1, j, key[node], False)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef generate_parentheses_iterative(length: int) -> list:\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result", "output": "Generate all valid combinations of parentheses (Iterative Approach)."}
{"task": "summary", "input": "summarize code:\ndef _carry(value1, value2, ratio, unit, min_unit, suppress):\n    if unit == min_unit:\n        return (value1 + value2 / ratio, 0)\n    elif unit in suppress:\n        return (0, value2 + value1 * ratio)\n    else:\n        return (value1, value2)", "output": "Return a tuple with two values."}
{"task": "search", "input": "search code:\nSorts the input list of n integers from 1 to n in-place\n\nChoices:\n0: def product_sum_array(array: list[int | list]) -> int:     return product_sum(array, 1)\n1: def cyclic_sort(nums: list[int]) -> list[int]:      # Perform cyclic sort     index = 0     while index < len(nums):         # Calculate the correct index for the current element         correct_index = nums[index] - 1         # If the current element is not at its correct position,         # swap it with the element at its correct index         if index != correct_index:             nums[index], nums[correct_index] = nums[correct_index], nums[index]         else:             # If the current element is already in its correct position,             # move to the next element             index += 1      return nums\n2: def comb_sort(data: list) -> list:     shrink_factor = 1.3     gap = len(data)     completed = False      while not completed:         # Update the gap value for a next comb         gap = int(gap / shrink_factor)         if gap <= 1:             completed = True          index = 0         while index + gap < len(data):             if data[index] > data[index + gap]:                 # Swap values                 data[index], data[index + gap] = data[index + gap], data[index]                 completed = False             index += 1      return data", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)", "output": "Function description is as follows-"}
{"task": "search", "input": "search code:\nRecursive function for calculating the height of the binary tree.\n\nChoices:\n0: def trapezoidal_rule(boundary, steps):     h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 2.0) * f(a)     for i in x_i:         y += h * f(i)     y += (h / 2.0) * f(b)     return y\n1: def choose(n: int, r: int) -> int:     ret = 1.0     for i in range(1, r + 1):         ret *= (n + 1 - i) / i     return round(ret)\n2: def height(root: Node | None) -> int:     return (max(height(root.left), height(root.right)) + 1) if root else 0", "output": "2"}
{"task": "search", "input": "search code:\nChecks estimation error for area_under_curve_estimator function\n\nChoices:\n0: def area_trapezium(base1: float, base2: float, height: float) -> float:     if base1 < 0 or base2 < 0 or height < 0:         raise ValueError(\"area_trapezium() only accepts non-negative values\")     return 1 / 2 * (base1 + base2) * height\n1: def area_under_line_estimator_check(     iterations: int, min_value: float = 0.0, max_value: float = 1.0 ) -> None:      def identity_function(x: float) -> float:         return x      estimated_value = area_under_curve_estimator(         iterations, identity_function, min_value, max_value     )     expected_value = (max_value * max_value - min_value * min_value) / 2      print(\"******************\")     print(f\"Estimating area under y=x where x varies from {min_value} to {max_value}\")     print(f\"Estimated value is {estimated_value}\")     print(f\"Expected value is {expected_value}\")     print(f\"Total error is {abs(estimated_value - expected_value)}\")     print(\"******************\")\n2: def try_key(ciphertext: list[int], key: tuple[int, ...]) -> str | None:     decoded: str = \"\"     keychar: int     cipherchar: int     decodedchar: int      for keychar, cipherchar in zip(cycle(key), ciphertext):         decodedchar = cipherchar ^ keychar         if decodedchar not in VALID_INTS:             return None         decoded += chr(decodedchar)      return decoded", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef minor(matrix: List[list], row: int, column: int) -> List[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]", "output": "def minor(matrix: list[list], row: int, column: int) -> list[list]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]"}
{"task": "detection", "input": "classify code:\ndef to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef power_of_4(number: int) -> bool:\n    if not isinstance(number, int):\n        raise TypeError(\"number must be an integer\")\n    if number <= 0:\n        raise ValueError(\"number must be positive\")\n    if number & (number - 1) == 0:\n        c = 0\n        while number:\n            c += 1\n            number >>= 1\n        return c % 2 == 1\n    else:\n        return False", "output": "Return True if this number is power of 4 or False otherwise."}
{"task": "detection", "input": "classify code:\ndef capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    return sentence[0].upper() + sentence[1:]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef chunked_even(iterable, n):\n    iterator = iter(iterable)\n\n    # Initialize a buffer to process the chunks while keeping\n    # some back to fill any underfilled chunks\n    min_buffer = (n - 1) * (n - 2)\n    buffer = list(islice(iterator, min_buffer))\n\n    # Append items until we have a completed chunk\n    for _ in islice(map(buffer.append, iterator), n, None, n):\n        yield buffer[:n]\n        del buffer[:n]\n\n    # Check if any chunks need addition processing\n    if not buffer:\n        return\n    length = len(buffer)\n\n    # Chunks are either size `full_size <= n` or `partial_size = full_size - 1`\n    q, r = divmod(length, n)\n    num_lists = q + (1 if r > 0 else 0)\n    q, r = divmod(length, num_lists)\n    full_size = q + (1 if r > 0 else 0)\n    partial_size = full_size - 1\n    num_full = length - partial_size * num_lists\n\n    # Yield chunks of full size\n    partial_start_idx = num_full * full_size\n    if full_size > 0:\n        for i in range(0, partial_start_idx, full_size):\n            yield buffer[i : i + full_size]\n\n    # Yield chunks of partial size\n    if partial_size > 0:\n        for i in range(partial_start_idx, length, partial_size):\n            yield buffer[i : i + partial_size]", "output": "Break *iterable* into lists of approximately length *n*."}
{"task": "summary", "input": "summarize code:\ndef eliminate(values, s, d):\n    if d not in values[s]:\n        return values  ## Already eliminated\n    values[s] = values[s].replace(d, \"\")\n    ## (1) If a square s is reduced to one value d2, then eliminate d2 from the peers.\n    if len(values[s]) == 0:\n        return False  ## Contradiction: removed last value\n    elif len(values[s]) == 1:\n        d2 = values[s]\n        if not all(eliminate(values, s2, d2) for s2 in peers[s]):\n            return False\n    ## (2) If a unit u is reduced to only one place for a value d, then put it there.\n    for u in units[s]:\n        dplaces = [s for s in u if d in values[s]]\n        if len(dplaces) == 0:\n            return False  ## Contradiction: no place for this value\n        # d can only be in one place in unit; assign it there\n        elif len(dplaces) == 1 and not assign(values, dplaces[0], d):\n            return False\n    return values", "output": "Eliminate d from values[s]; propagate when values or places <= 2."}
{"task": "summary", "input": "summarize code:\ndef build_sparse_table(number_list: list[int]) -> list[list[int]]:\n    if not number_list:\n        raise ValueError(\"empty number list not allowed\")\n\n    length = len(number_list)\n    # Initialise sparse_table -- sparse_table[j][i] represents the minimum value of the\n    # subset of length (2 ** j) of number_list, starting from index i.\n\n    # smallest power of 2 subset length that fully covers number_list\n    row = int(log2(length)) + 1\n    sparse_table = [[0 for i in range(length)] for j in range(row)]\n\n    # minimum of subset of length 1 is that value itself\n    for i, value in enumerate(number_list):\n        sparse_table[0][i] = value\n    j = 1\n\n    # compute the minimum value for all intervals with size (2 ** j)\n    while (1 << j) <= length:\n        i = 0\n        # while subset starting from i still have at least (2 ** j) elements\n        while (i + (1 << j) - 1) < length:\n            # split range [i, i + 2 ** j] and find minimum of 2 halves\n            sparse_table[j][i] = min(\n                sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]\n            )\n            i += 1\n        j += 1\n    return sparse_table", "output": "Precompute range minimum queries with power of two length and store the precomputed"}
{"task": "search", "input": "search code:\nFor the given string this function computes value for each index,\n\nChoices:\n0: def solution(n: int = 51) -> int:     unique_coefficients = get_pascal_triangle_unique_coefficients(n)     squarefrees = get_squarefrees(unique_coefficients)     return sum(squarefrees)\n1: def z_function(input_str: str) -> list[int]:     z_result = [0 for i in range(len(input_str))]      # initialize interval's left pointer and right pointer     left_pointer, right_pointer = 0, 0      for i in range(1, len(input_str)):         # case when current index is inside the interval         if i <= right_pointer:             min_edge = min(right_pointer - i + 1, z_result[i - left_pointer])             z_result[i] = min_edge          while go_next(i, z_result, input_str):             z_result[i] += 1          # if new index's result gives us more right interval,         # we've to update left_pointer and right_pointer         if i + z_result[i] - 1 > right_pointer:             left_pointer, right_pointer = i, i + z_result[i] - 1      return z_result\n2: def play(     matrix_g: list[list[str]], pos_x: int, pos_y: int, size: int ) -> tuple[list[list[str]], int]:      same_colors = find_repeat(matrix_g, pos_x, pos_y, size)      if len(same_colors) != 0:         for pos in same_colors:             matrix_g[pos[0]][pos[1]] = \"-\"         for column in range(size):             matrix_g = move_x(matrix_g, column, size)          matrix_g = move_y(matrix_g, size)      return (matrix_g, increment_score(len(same_colors)))", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)"}
{"task": "search", "input": "search code:\nReturns a list of nodes value from a particular level:\n\nChoices:\n0: def bottom_up_cut_rod(n: int, prices: list):     _enforce_args(n, prices)      # length(max_rev) = n + 1, to accommodate for the revenue obtainable from a rod of     # length 0.     max_rev = [float(\"-inf\") for _ in range(n + 1)]     max_rev[0] = 0      for i in range(1, n + 1):         max_revenue_i = max_rev[i]         for j in range(1, i + 1):             max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])          max_rev[i] = max_revenue_i      return max_rev[n]\n1: def prepend(value, iterator):     return chain([value], iterator)\n2: def get_nodes_from_right_to_left(root: Node | None, level: int) -> Generator[int]:      def populate_output(root: Node | None, level: int) -> Generator[int]:         if not root:             return         if level == 1:             yield root.data         elif level > 1:             yield from populate_output(root.right, level - 1)             yield from populate_output(root.left, level - 1)      yield from populate_output(root, level)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef load_data() -> list[list[str]]:\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]", "output": "Returns a sample transaction dataset."}
{"task": "repair", "input": "fix bug:\ndef is_balanced(s: str) -> bool:\n    \"\"\"\n    >>> is_balanced(\"\")\n    True\n    >>> is_balanced(\"()\")\n    True\n    >>> is_balanced(\"[]\")\n    True\n    >>> is_balanced(\"{}\")\n    True\n    >>> is_balanced(\"()[]{}\")\n    True\n    >>> is_balanced(\"(())\")\n    True\n    >>> is_balanced(\"[[\")\n    False\n    >>> is_balanced(\"([{}])\")\n    True\n    >>> is_balanced(\"(()[)]\")\n    False\n    >>> is_balanced(\"([)]\")\n    False\n    >>> is_balanced(\"[[()]]\")\n    True\n    >>> is_balanced(\"(()(()))\")\n    True\n    >>> is_balanced(\"]\")\n    False\n    >>> is_balanced(\"Life is a bowl of cherries.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che{}ies.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che}{ies.\")\n    False\n    \"\"\"\n    open_to_closed = {\"{\": \"}\", \"[\": \"]\", \"(\": \")\"}\n    stack = []\n    for symbol in s:\n        if symbol in open_to_closed:\n            stack.append(symbol)\n        elif symbol in open_to_closed.values() and (\n            not stack or open_to_closed[stack.pop()] != symbol\n        ):\n            return False\n    return not stack  # stack should be empty", "output": "def is_balanced(s: str) -> bool:\n    \"\"\"\n    >>> is_balanced(\"\")\n    True\n    >>> is_balanced(\"()\")\n    True\n    >>> is_balanced(\"[]\")\n    True\n    >>> is_balanced(\"{}\")\n    True\n    >>> is_balanced(\"()[]{}\")\n    True\n    >>> is_balanced(\"(())\")\n    True\n    >>> is_balanced(\"[[\")\n    False\n    >>> is_balanced(\"([{}])\")\n    True\n    >>> is_balanced(\"(()[)]\")\n    False\n    >>> is_balanced(\"([)]\")\n    False\n    >>> is_balanced(\"[[()]]\")\n    True\n    >>> is_balanced(\"(()(()))\")\n    True\n    >>> is_balanced(\"]\")\n    False\n    >>> is_balanced(\"Life is a bowl of cherries.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che{}ies.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che}{ies.\")\n    False\n    \"\"\"\n    open_to_closed = {\"{\": \"}\", \"[\": \"]\", \"(\": \")\"}\n    stack = []\n    for symbol in s:\n        if symbol in open_to_closed:\n            stack.append(symbol)\n        elif symbol in open_to_closed.values() and (\n            not stack or open_to_closed[stack.pop()] != symbol\n        ):\n            return False\n    return not stack  # stack should be empty"}
{"task": "search", "input": "search code:\nGet images list and annotations list from input dir.\n\nChoices:\n0: def all_solution_file_paths() -> list[pathlib.Path]:     solution_file_paths = []     for problem_dir_path in PROJECT_EULER_DIR_PATH.iterdir():         if problem_dir_path.is_file() or problem_dir_path.name.startswith(\"_\"):             continue         for file_path in problem_dir_path.iterdir():             if file_path.suffix != \".py\" or file_path.name.startswith((\"_\", \"test\")):                 continue             solution_file_paths.append(file_path)     return solution_file_paths\n1: def main() -> None:     img_paths, annos = get_dataset(LABEL_DIR, IMAGE_DIR)     print(\"Processing...\")     new_images, new_annos, paths = update_image_and_anno(img_paths, annos, FLIP_TYPE)      for index, image in enumerate(new_images):         # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'         letter_code = random_chars(32)         file_name = paths[index].split(os.sep)[-1].rsplit(\".\", 1)[0]         file_root = f\"{OUTPUT_DIR}/{file_name}_FLIP_{letter_code}\"         cv2.imwrite(f\"{file_root}.jpg\", image, [cv2.IMWRITE_JPEG_QUALITY, 85])         print(f\"Success {index + 1}/{len(new_images)} with {file_name}\")         annos_list = []         for anno in new_annos[index]:             obj = f\"{anno[0]} {anno[1]} {anno[2]} {anno[3]} {anno[4]}\"             annos_list.append(obj)         with open(f\"{file_root}.txt\", \"w\") as outfile:             outfile.write(\"\\n\".join(line for line in annos_list))\n2: def extended_gcd(a: int, b: int) -> tuple[int, int, int]:     assert a >= 0     assert b >= 0      if b == 0:         d, x, y = a, 1, 0     else:         (d, p, q) = extended_gcd(b, a % b)         x = q         y = p - q * (a // b)      assert a % d == 0     assert b % d == 0     assert d == a * x + b * y      return (d, x, y)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef left_shift(data):\n    \"\"\"\n    >>> left_shift(\"0123456789\")\n    '1234567890'\n    \"\"\"\n    return data[1:] + data[0]", "output": "def left_shift(data):\n    \"\"\"\n    >>> left_shift(\"0123456789\")\n    '1234567890'\n    \"\"\"\n    return data[1:] + data[0]"}
{"task": "search", "input": "search code:\nSimilar to :func:`cached`, ``cachedmethod`` is used to cache\n\nChoices:\n0: def triplewise(iterable):     # This deviates from the itertools documentation recipe - see     # https://github.com/more-itertools/more-itertools/issues/889     t1, t2, t3 = tee(iterable, 3)     next(t3, None)     next(t3, None)     next(t2, None)     return zip(t1, t2, t3)\n1: def is_square_form(num: int) -> bool:     digit = 9      while num > 0:         if num % 10 != digit:             return False         num //= 100         digit -= 1      return True\n2: def cachedmethod(cache, scoped=True, typed=False, key=None):     def cached_method_decorator(func):         return CachedMethod(func, cache, scoped=scoped, typed=typed, key=key)     return cached_method_decorator", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef chunk_ranges(input_size, chunk_size, input_offset=0, overlap_size=0, align=False):\n    input_size = _validate_positive_int(\n        input_size, 'input_size', strictly_positive=False)\n    chunk_size = _validate_positive_int(chunk_size, 'chunk_size')\n    input_offset = _validate_positive_int(\n        input_offset, 'input_offset', strictly_positive=False)\n    overlap_size = _validate_positive_int(\n        overlap_size, 'overlap_size', strictly_positive=False)\n\n    input_stop = input_offset + input_size\n\n    if align:\n        initial_chunk_len = chunk_size - \\\n            input_offset % (chunk_size - overlap_size)\n        if initial_chunk_len != overlap_size:\n            yield (input_offset, min(input_offset + initial_chunk_len, input_stop))\n            if input_offset + initial_chunk_len >= input_stop:\n                return\n            input_offset = input_offset + initial_chunk_len - overlap_size\n\n    for i in range(input_offset, input_stop, chunk_size - overlap_size):\n        yield (i, min(i + chunk_size, input_stop))\n\n        if i + chunk_size >= input_stop:\n            return", "output": "Generates *chunk_size*-sized chunk ranges for an input with length *input_size*."}
{"task": "summary", "input": "summarize code:\ndef get_week_day(year: int, month: int, day: int) -> str:\n    # minimal input check:\n    assert len(str(year)) > 2, \"year should be in YYYY format\"\n    assert 1 <= month <= 12, \"month should be between 1 to 12\"\n    assert 1 <= day <= 31, \"day should be between 1 to 31\"\n\n    # Doomsday algorithm:\n    century = year // 100\n    century_anchor = (5 * (century % 4) + 2) % 7\n    centurian = year % 100\n    centurian_m = centurian % 12\n    dooms_day = (\n        (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor\n    ) % 7\n    day_anchor = (\n        DOOMSDAY_NOT_LEAP[month - 1]\n        if year % 4 != 0 or (centurian == 0 and year % 400 != 0)\n        else DOOMSDAY_LEAP[month - 1]\n    )\n    week_day = (dooms_day + day - day_anchor) % 7\n    return WEEK_DAY_NAMES[week_day]", "output": "Returns the week-day name out of a given date."}
{"task": "detection", "input": "classify code:\ndef binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int, right: int\n) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n\n    \"\"\"\n    if right < left:\n        return None\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)", "output": "BUGGY"}
{"task": "search", "input": "search code:\n| Return pure symbols and their values to satisfy clause.\n\nChoices:\n0: def split_at(iterable, pred, maxsplit=-1, keep_separator=False):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         if pred(item):             yield buf             if keep_separator:                 yield [item]             if maxsplit == 1:                 yield list(it)                 return             buf = []             maxsplit -= 1         else:             buf.append(item)     yield buf\n1: def main(     cities: dict[int, list[int]],     ants_num: int,     iterations_num: int,     pheromone_evaporation: float,     alpha: float,     beta: float,     q: float,  # Pheromone system parameters Q, which is a constant ) -> tuple[list[int], float]:     # Initialize the pheromone matrix     cities_num = len(cities)     pheromone = [[1.0] * cities_num] * cities_num      best_path: list[int] = []     best_distance = float(\"inf\")     for _ in range(iterations_num):         ants_route = []         for _ in range(ants_num):             unvisited_cities = copy.deepcopy(cities)             current_city = {next(iter(cities.keys())): next(iter(cities.values()))}             del unvisited_cities[next(iter(current_city.keys()))]             ant_route = [next(iter(current_city.keys()))]             while unvisited_cities:                 current_city, unvisited_cities = city_select(                     pheromone, current_city, unvisited_cities, alpha, beta                 )                 ant_route.append(next(iter(current_city.keys())))             ant_route.append(0)             ants_route.append(ant_route)          pheromone, best_path, best_distance = pheromone_update(             pheromone,             cities,             pheromone_evaporation,             ants_route,             q,             best_path,             best_distance,         )     return best_path, best_distance\n2: def find_pure_symbols(     clauses: list[Clause], symbols: list[str], model: dict[str, bool | None] ) -> tuple[list[str], dict[str, bool | None]]:     pure_symbols = []     assignment: dict[str, bool | None] = {}     literals = []      for clause in clauses:         if clause.evaluate(model):             continue         for literal in clause.literals:             literals.append(literal)      for s in symbols:         sym = s + \"'\"         if (s in literals and sym not in literals) or (             s not in literals and sym in literals         ):             pure_symbols.append(s)     for p in pure_symbols:         assignment[p] = None     for s in pure_symbols:         sym = s + \"'\"         if s in literals:             assignment[s] = True         elif sym in literals:             assignment[s] = False     return pure_symbols, assignment", "output": "2"}
{"task": "detection", "input": "classify code:\ndef is_palindrome(n: int | str) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return True if n == n[::-1] else False", "output": "CORRECT"}
{"task": "search", "input": "search code:\nLet's benchmark our functions side-by-side...\n\nChoices:\n0: def rstrip(iterable, strip_value=None):     return list(rstrip_iter(iterable, strip_value))\n1: def benchmark() -> None:     from timeit import timeit      print(\"Running performance benchmarks...\")     setup = \"from string import printable ; from __main__ import atbash, atbash_slow\"     print(f\"> atbash_slow(): {timeit('atbash_slow(printable)', setup=setup)} seconds\")     print(f\">      atbash(): {timeit('atbash(printable)', setup=setup)} seconds\")\n2: def util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:      # Base Case     if curr_ind == len(graph):         # return whether path exists between current and starting vertices         return graph[path[curr_ind - 1]][path[0]] == 1      # Recursive Step     for next_ver in range(len(graph)):         if valid_connection(graph, next_ver, curr_ind, path):             # Insert current vertex  into path as next transition             path[curr_ind] = next_ver             # Validate created path             if util_hamilton_cycle(graph, path, curr_ind + 1):                 return True             # Backtrack             path[curr_ind] = -1     return False", "output": "1"}
{"task": "search", "input": "search code:\nThe solution traverses a binary tree to find the maximum sum of\n\nChoices:\n0: def check_anagrams(first_str: str, second_str: str) -> bool:     first_str = first_str.lower().strip()     second_str = second_str.lower().strip()      # Remove whitespace     first_str = first_str.replace(\" \", \"\")     second_str = second_str.replace(\" \", \"\")      # Strings of different lengths are not anagrams     if len(first_str) != len(second_str):         return False      # Default values for count should be 0     count: defaultdict[str, int] = defaultdict(int)      # For each character in input strings,     # increment count in the corresponding     for i in range(len(first_str)):         count[first_str[i]] += 1         count[second_str[i]] -= 1      return all(_count == 0 for _count in count.values())\n1: def max_sum_bst(root: TreeNode | None) -> int:     ans: int = 0      def solver(node: TreeNode | None) -> tuple[bool, int, int, int]:         nonlocal ans          if not node:             return True, INT_MAX, INT_MIN, 0  # Valid BST, min, max, sum          is_left_valid, min_left, max_left, sum_left = solver(node.left)         is_right_valid, min_right, max_right, sum_right = solver(node.right)          if is_left_valid and is_right_valid and max_left < node.val < min_right:             total_sum = sum_left + sum_right + node.val             ans = max(ans, total_sum)             return True, min(min_left, node.val), max(max_right, node.val), total_sum          return False, -1, -1, -1  # Not a valid BST      solver(root)     return ans\n2: def find_repeat(     matrix_g: list[list[str]], row: int, column: int, size: int ) -> set[tuple[int, int]]:      column = size - 1 - column     visited = set()     repeated = set()      if (color := matrix_g[column][row]) != \"-\":          def dfs(row_n: int, column_n: int) -> None:             if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:                 return             if (row_n, column_n) in visited:                 return             visited.add((row_n, column_n))             if matrix_g[row_n][column_n] == color:                 repeated.add((row_n, column_n))                 dfs(row_n - 1, column_n)                 dfs(row_n + 1, column_n)                 dfs(row_n, column_n - 1)                 dfs(row_n, column_n + 1)          dfs(column, row)      return repeated", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n\n    Args:\n        * `elements`: The list of elements from which combinations will be generated.\n        * `n`: The number of elements in each combination.\n\n    Returns:\n        A list of tuples, each representing a combination of `n` elements.\n\n    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n    >>> subset_combinations(elements=[1, 2, 3], n=1)\n    [(1,), (2,), (3,)]\n    >>> subset_combinations(elements=[1, 2, 3], n=3)\n    [(1, 2, 3)]\n    >>> subset_combinations(elements=[42], n=1)\n    [(42,)]\n    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n    [(6, 7, 8, 9)]\n    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n    [()]\n    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n    >>> subset_combinations(elements=['single'], n=0)\n    [()]\n    >>> subset_combinations(elements=[], n=9)\n    []\n    >>> from itertools import combinations\n    >>> all(subset_combinations(items, n) == list(combinations(items, n))\n    ...     for items, n in (\n    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n    True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]", "output": "def subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n\n    Args:\n        * `elements`: The list of elements from which combinations will be generated.\n        * `n`: The number of elements in each combination.\n\n    Returns:\n        A list of tuples, each representing a combination of `n` elements.\n\n    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n    >>> subset_combinations(elements=[1, 2, 3], n=1)\n    [(1,), (2,), (3,)]\n    >>> subset_combinations(elements=[1, 2, 3], n=3)\n    [(1, 2, 3)]\n    >>> subset_combinations(elements=[42], n=1)\n    [(42,)]\n    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n    [(6, 7, 8, 9)]\n    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n    [()]\n    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n    >>> subset_combinations(elements=['single'], n=0)\n    [()]\n    >>> subset_combinations(elements=[], n=9)\n    []\n    >>> from itertools import combinations\n    >>> all(subset_combinations(items, n) == list(combinations(items, n))\n    ...     for items, n in (\n    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n    True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]"}
{"task": "summary", "input": "summarize code:\ndef heapify(unsorted: list[int], index: int, heap_size: int) -> None:\n    largest = index\n    left_index = 2 * index + 1\n    right_index = 2 * index + 2\n    if left_index < heap_size and unsorted[left_index] > unsorted[largest]:\n        largest = left_index\n\n    if right_index < heap_size and unsorted[right_index] > unsorted[largest]:\n        largest = right_index\n\n    if largest != index:\n        unsorted[largest], unsorted[index] = (unsorted[index], unsorted[largest])\n        heapify(unsorted, largest, heap_size)", "output": ":param unsorted: unsorted list containing integers numbers"}
{"task": "search", "input": "search code:\nReturns an iterable with *n* elements for efficient looping.\n\nChoices:\n0: def loops(n):     return repeat(None, n)\n1: def can_string_be_rearranged_as_palindrome_counter(     input_str: str = \"\", ) -> bool:     return sum(c % 2 for c in Counter(input_str.replace(\" \", \"\").lower()).values()) < 2\n2: def get_factors(     number: int, factors: Counter | None = None, factor: int = 2 ) -> Counter:      match number:         case int(number) if number == 1:             return Counter({1: 1})         case int(num) if number > 0:             number = num         case _:             raise TypeError(\"number must be integer and greater than zero\")      factors = factors or Counter()      if number == factor:  # break condition         # all numbers are factors of itself         factors[factor] += 1         return factors      if number % factor > 0:         # if it is greater than zero         # so it is not a factor of number and we check next number         return get_factors(number, factors, factor + 1)      factors[factor] += 1     # else we update factors (that is Counter(dict-like) type) and check again     return get_factors(number // factor, factors, factor)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef get_totients(max_one: int) -> list[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = [0] * max_one\n\n    for i in range(0, max_one):\n        totients[i] = i\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            for j in range(i, max_one, i):\n                totients[j] -= totients[j] // i\n\n    return totients", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef is_harshad_number_in_base(num: int, base: int) -> bool:\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    if num < 0:\n        return False\n\n    n = int_to_base(num, base)\n    d = sum_of_digits(num, base)\n    return int(n, base) % int(d, base) == 0", "output": "Determines whether n in base 'base' is a harshad number."}
{"task": "summary", "input": "summarize code:\ndef or_gate(input_1: int, input_2: int) -> int:\n    return int((input_1, input_2).count(1) != 0)", "output": "Calculate OR of the input values"}
{"task": "summary", "input": "summarize code:\ndef chunked(src, size, count=None, **kw):\n    chunk_iter = chunked_iter(src, size, **kw)\n    if count is None:\n        return list(chunk_iter)\n    else:\n        return list(itertools.islice(chunk_iter, count))", "output": "Returns a list of *count* chunks, each with *size* elements,"}
{"task": "summary", "input": "summarize code:\ndef normalize(audio: np.ndarray) -> np.ndarray:\n    # Divide the entire audio signal by the maximum absolute value\n    return audio / np.max(np.abs(audio))", "output": "Normalize an audio signal by scaling it to have values between -1 and 1."}
{"task": "search", "input": "search code:\nReturns a dictionary with keys as the perimeter of a right angled triangle\n\nChoices:\n0: def change_contrast(img: Image, level: int) -> Image:     factor = (259 * (level + 255)) / (255 * (259 - level))      def contrast(c: int) -> int:         return int(128 + factor * (c - 128))      return img.point(contrast)\n1: def solution(func: Callable[[int], int] = question_function, order: int = 10) -> int:     data_points: list[int] = [func(x_val) for x_val in range(1, order + 1)]      polynomials: list[Callable[[int], int]] = [         interpolate(data_points[:max_coeff]) for max_coeff in range(1, order + 1)     ]      ret: int = 0     poly: Callable[[int], int]     x_val: int      for poly in polynomials:         x_val = 1         while func(x_val) == poly(x_val):             x_val += 1          ret += poly(x_val)      return ret\n2: def pythagorean_triple(max_perimeter: int) -> typing.Counter[int]:     triplets: typing.Counter[int] = Counter()     for base in range(1, max_perimeter + 1):         for perpendicular in range(base, max_perimeter + 1):             hypotenuse = (base * base + perpendicular * perpendicular) ** 0.5             if hypotenuse == int(hypotenuse):                 perimeter = int(base + perpendicular + hypotenuse)                 if perimeter > max_perimeter:                     continue                 triplets[perimeter] += 1     return triplets", "output": "2"}
{"task": "search", "input": "search code:\nA variant of :func:`takewhile` that yields one additional element.\n\nChoices:\n0: def _dense_to_one_hot(labels_dense, num_classes):     num_labels = labels_dense.shape[0]     index_offset = np.arange(num_labels) * num_classes     labels_one_hot = np.zeros((num_labels, num_classes))     labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1     return labels_one_hot\n1: def opening_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:     if kernel is None:         np.ones((3, 3))      return transform(transform(image, \"dilation\", kernel), \"erosion\", kernel)\n2: def takewhile_inclusive(predicate, iterable):     for x in iterable:         yield x         if not predicate(x):             break", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef calculate_span(price: list[int]) -> list[int]:\n    n = len(price)\n    s = [0] * n\n    # Create a stack and push index of fist element to it\n    st = []\n    st.append(0)\n\n    # Span value of first element is always 1\n    s[0] = 1\n\n    # Calculate span values for rest of the elements\n    for i in range(1, n):\n        # Pop elements from stack while stack is not\n        # empty and top of stack is smaller than price[i]\n        while len(st) > 0 and price[st[-1]] <= price[i]:\n            st.pop()\n\n        # If stack becomes empty, then price[i] is greater\n        # than all elements on left of it, i.e. price[0],\n        # price[1], ..price[i-1]. Else the price[i]  is\n        # greater than elements after top of stack\n        s[i] = i + 1 if len(st) <= 0 else (i - st[-1])\n\n        # Push this element to stack\n        st.append(i)\n\n    return s", "output": "Calculate the span values for a given list of stock prices."}
{"task": "search", "input": "search code:\nFind the sum of n terms in an arithmetic progression.\n\nChoices:\n0: def liouville_lambda(number: int) -> int:     if not isinstance(number, int):         msg = f\"Input value of [number={number}] must be an integer\"         raise TypeError(msg)     if number < 1:         raise ValueError(\"Input must be a positive integer\")     return -1 if len(prime_factors(number)) % 2 else 1\n1: def exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:     return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))\n2: def sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:     total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)     # formula for sum of series     return total", "output": "2"}
{"task": "detection", "input": "classify code:\ndef backtrack(input_string: str, word_dict: set[str], start: int) -> bool:\n    \"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\n\n    # Base case: if the starting index has reached the end of the string\n    if start == len(input_string):\n        return True\n\n    # Try every possible substring from 'start' to 'end'\n    for end in range(start + 1, len(input_string) + 1):\n        if input_string[start:end] in word_dict and backtrack(\n            input_string, word_dict, end\n        ):\n            return True\n\n    return False", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    -1\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return -1\n    else:\n        return \"\".join(l1)", "output": "def compare_string(string1: str, string2: str) -> str:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    'X'\n    \"\"\"\n    l1 = list(string1)\n    l2 = list(string2)\n    count = 0\n    for i in range(len(l1)):\n        if l1[i] != l2[i]:\n            count += 1\n            l1[i] = \"_\"\n    if count > 1:\n        return \"X\"\n    else:\n        return \"\".join(l1)"}
{"task": "search", "input": "search code:\nImplements the ELU activation function.\n\nChoices:\n0: def exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:     return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))\n1: def get_filter_points(     sample_rate: int,     freq_min: int,     freq_high: int,     mel_filter_num: int = 10,     ftt_size: int = 1024, ) -> tuple[np.ndarray, np.ndarray]:     # Convert minimum and maximum frequencies to mel scale     fmin_mel = freq_to_mel(freq_min)     fmax_mel = freq_to_mel(freq_high)      logging.info(f\"MEL min: {fmin_mel}\")     logging.info(f\"MEL max: {fmax_mel}\")      # Generate equally spaced mel frequencies     mels = np.linspace(fmin_mel, fmax_mel, num=mel_filter_num + 2)      # Convert mel frequencies back to Hertz     freqs = mel_to_freq(mels)      # Calculate filter points as integer values     filter_points = np.floor((ftt_size + 1) / sample_rate * freqs).astype(int)      return filter_points, freqs\n2: def main() -> None:     img_paths, annos = get_dataset(LABEL_DIR, IMG_DIR)     for index in range(NUMBER_IMAGES):         idxs = random.sample(range(len(annos)), 4)         new_image, new_annos, path = update_image_and_anno(             img_paths,             annos,             idxs,             OUTPUT_SIZE,             SCALE_RANGE,             filter_scale=FILTER_TINY_SCALE,         )          # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'         letter_code = random_chars(32)         file_name = path.split(os.sep)[-1].rsplit(\".\", 1)[0]         file_root = f\"{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}\"         cv2.imwrite(f\"{file_root}.jpg\", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])         print(f\"Succeeded {index + 1}/{NUMBER_IMAGES} with {file_name}\")         annos_list = []         for anno in new_annos:             width = anno[3] - anno[1]             height = anno[4] - anno[2]             x_center = anno[1] + width / 2             y_center = anno[2] + height / 2             obj = f\"{anno[0]} {x_center} {y_center} {width} {height}\"             annos_list.append(obj)         with open(f\"{file_root}.txt\", \"w\") as outfile:             outfile.write(\"\\n\".join(line for line in annos_list))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    product = -1\n    candidate = 0\n    for a in range(1, n // 3):\n        # Solving the two equations a**2+b**2=c**2 and a+b+c=N eliminating c\n        b = (n * n - 2 * a * n) // (2 * n - 2 * a)\n        c = n - a - b\n        if c * c == (a * a + b * b):\n            candidate = a * b * c\n            product = max(product, candidate)\n    return product", "output": "Return the product of a,b,c which are Pythagorean Triplet that satisfies"}
{"task": "search", "input": "search code:\nYield lists of items from *iterable*, where each list is delimited by\n\nChoices:\n0: def f(x: float) -> float:     return math.pow(x, 3) - (2 * x) - 5\n1: def split_at(iterable, pred, maxsplit=-1, keep_separator=False):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         if pred(item):             yield buf             if keep_separator:                 yield [item]             if maxsplit == 1:                 yield list(it)                 return             buf = []             maxsplit -= 1         else:             buf.append(item)     yield buf\n2: def find_median(nums: list[int | float]) -> float:     div, mod = divmod(len(nums), 2)     if mod:         return nums[div]     return (nums[div] + nums[(div) - 1]) / 2", "output": "1"}
{"task": "search", "input": "search code:\nThis is the implementation of the median.\n\nChoices:\n0: def find_median(nums: list[int | float]) -> float:     div, mod = divmod(len(nums), 2)     if mod:         return nums[div]     return (nums[div] + nums[(div) - 1]) / 2\n1: def nth(iterable, n, default=None):     return next(islice(iterable, n, None), default)\n2: def tail(n, iterable):     try:         size = len(iterable)     except TypeError:         return iter(deque(iterable, maxlen=n))     else:         return islice(iterable, max(0, size - n), None)", "output": "0"}
{"task": "search", "input": "search code:\nFunction to perform the sum of the factorial of all the digits in number\n\nChoices:\n0: def solution(n_limit: int = 50 * 10**6) -> int:     n_sol = [0] * n_limit      for delta in range(1, (n_limit + 1) // 4 + 1):         for y in range(4 * delta - 1, delta, -1):             n = y * (4 * delta - y)             if n >= n_limit:                 break             n_sol[n] += 1      ans = 0     for i in range(n_limit):         if n_sol[i] == 1:             ans += 1      return ans\n1: def collapse(iterable, base_type=None, levels=None):     stack = deque()     # Add our first node group, treat the iterable as a single node     stack.appendleft((0, repeat(iterable, 1)))      while stack:         node_group = stack.popleft()         level, nodes = node_group          # Check if beyond max level         if levels is not None and level > levels:             yield from nodes             continue          for node in nodes:             # Check if done iterating             if isinstance(node, (str, bytes)) or (                 (base_type is not None) and isinstance(node, base_type)             ):                 yield node             # Otherwise try to create child nodes             else:                 try:                     tree = iter(node)                 except TypeError:                     yield node                 else:                     # Save our current location                     stack.appendleft(node_group)                     # Append the new child node                     stack.appendleft((level + 1, tree))                     # Break to process child node                     break\n2: def digit_factorial_sum(number: int) -> int:     if not isinstance(number, int):         raise TypeError(\"Parameter number must be int\")      if number < 0:         raise ValueError(\"Parameter number must be greater than or equal to 0\")      # Converts number in string to iterate on its digits and adds its factorial.     return sum(DIGIT_FACTORIAL[digit] for digit in str(number))", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef vol_hollow_circular_cylinder(\n    inner_radius: float, outer_radius: float, height: float\n) -> float:\n    # Volume - (outer_radius squared - inner_radius squared) * pi * height\n    if inner_radius < 0 or outer_radius < 0 or height < 0:\n        raise ValueError(\n            \"vol_hollow_circular_cylinder() only accepts non-negative values\"\n        )\n    if outer_radius <= inner_radius:\n        raise ValueError(\"outer_radius must be greater than inner_radius\")\n    return pi * (pow(outer_radius, 2) - pow(inner_radius, 2)) * height", "output": "Calculate the Volume of a Hollow Circular Cylinder."}
{"task": "summary", "input": "summarize code:\ndef standardization(data: list, ndigits: int = 3) -> list:\n    # variables for calculation\n    mu = mean(data)\n    sigma = stdev(data)\n    # standardize data\n    return [round((x - mu) / (sigma), ndigits) for x in data]", "output": "Return a standardized list of values."}
{"task": "summary", "input": "summarize code:\ndef alternative_string_arrange(first_str: str, second_str: str) -> str:\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)", "output": "Return the alternative arrangements of the two strings."}
{"task": "summary", "input": "summarize code:\ndef print_optimal_solution(optimal_solution: list[list[int]], i: int, j: int):\n\n    if i == j:\n        print(\"A\" + str(i), end=\" \")\n    else:\n        print(\"(\", end=\" \")\n        print_optimal_solution(optimal_solution, i, optimal_solution[i][j])\n        print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j)\n        print(\")\", end=\" \")", "output": "Print order of matrix with Ai as Matrix."}
{"task": "search", "input": "search code:\nreturn the geometric mean of series\n\nChoices:\n0: def args2sh(args, sep=' '):     ret_list = []      for arg in args:         if not arg:             ret_list.append(\"''\")             continue         if _find_sh_unsafe(arg) is None:             ret_list.append(arg)             continue         # use single quotes, and put single quotes into double quotes         # the string $'b is then quoted as '$'\"'\"'b'         ret_list.append(\"'\" + arg.replace(\"'\", \"'\\\"'\\\"'\") + \"'\")      return ' '.join(ret_list)\n1: def geometric_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 1     for value in series:         answer *= value     return pow(answer, 1 / len(series))\n2: def solution(limit: int = 100) -> int:     singles: list[int] = [*list(range(1, 21)), 25]     doubles: list[int] = [2 * x for x in range(1, 21)] + [50]     triples: list[int] = [3 * x for x in range(1, 21)]     all_values: list[int] = singles + doubles + triples + [0]      num_checkouts: int = 0     double: int     throw1: int     throw2: int     checkout_total: int      for double in doubles:         for throw1, throw2 in combinations_with_replacement(all_values, 2):             checkout_total = double + throw1 + throw2             if checkout_total < limit:                 num_checkouts += 1      return num_checkouts", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef gray_code(bit_count: int) -> list:\n\n    # bit count represents no. of bits in the gray code\n    if bit_count < 0:\n        raise ValueError(\"The given input must be positive\")\n\n    # get the generated string sequence\n    sequence = gray_code_sequence_string(bit_count)\n    #\n    # convert them to integers\n    for i in range(len(sequence)):\n        sequence[i] = int(sequence[i], 2)\n\n    return sequence", "output": "Takes in an integer n and returns a n-bit"}
{"task": "search", "input": "search code:\nConvert a frequency in the mel scale to Hertz.\n\nChoices:\n0: def mel_to_freq(mels: float) -> float:     # Use the formula to convert mel scale to frequency     return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)\n1: def split_into(iterable, sizes):     # convert the iterable argument into an iterator so its contents can     # be consumed by islice in case it is a generator     it = iter(iterable)      for size in sizes:         if size is None:             yield list(it)             return         else:             yield list(islice(it, size))\n2: def bitap_string_match(text: str, pattern: str) -> int:     if not pattern:         return 0     m = len(pattern)     if m > len(text):         return -1      # Initial state of bit string 1110     state = ~1     # Bit = 0 if character appears at index, and 1 otherwise     pattern_mask: list[int] = [~0] * 27  # 1111      for i, char in enumerate(pattern):         # For the pattern mask for this character, set the bit to 0 for each i         # the character appears.         pattern_index: int = ord(char) - ord(\"a\")         pattern_mask[pattern_index] &= ~(1 << i)      for i, char in enumerate(text):         text_index = ord(char) - ord(\"a\")         # If this character does not appear in pattern, it's pattern mask is 1111.         # Performing a bitwise OR between state and 1111 will reset the state to 1111         # and start searching the start of pattern again.         state |= pattern_mask[text_index]         state <<= 1          # If the mth bit (counting right to left) of the state is 0, then we have         # found pattern in text         if (state & (1 << m)) == 0:             return i - m + 1      return -1", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution():\n\n    return sum(\n        {\n            int(\"\".join(pandigital[5:9]))\n            for pandigital in itertools.permutations(\"123456789\")\n            if is_combination_valid(pandigital)\n        }\n    )", "output": "Finds the sum of all products whose multiplicand/multiplier/product identity"}
{"task": "search", "input": "search code:\nDivide a number of bytes into x partitions.\n\nChoices:\n0: def solution(length: int = 50) -> int:      ways_number = [1] * (length + 1)      for row_length in range(3, length + 1):         for block_length in range(3, row_length + 1):             for block_start in range(row_length - block_length):                 ways_number[row_length] += ways_number[                     row_length - block_start - block_length - 1                 ]              ways_number[row_length] += 1      return ways_number[length]\n1: def runge_kutta_gills(     func: Callable[[float, float], float],     x_initial: float,     y_initial: float,     step_size: float,     x_final: float, ) -> np.ndarray:     if x_initial >= x_final:         raise ValueError(             \"The final value of x must be greater than initial value of x.\"         )      if step_size <= 0:         raise ValueError(\"Step size must be positive.\")      n = int((x_final - x_initial) / step_size)     y = np.zeros(n + 1)     y[0] = y_initial     for i in range(n):         k1 = step_size * func(x_initial, y[i])         k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)         k3 = step_size * func(             x_initial + step_size / 2,             y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,         )         k4 = step_size * func(             x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3         )          y[i + 1] = y[i] + (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4) / 6         x_initial += step_size     return y\n2: def allocation_num(number_of_bytes: int, partitions: int) -> list[str]:     if partitions <= 0:         raise ValueError(\"partitions must be a positive number!\")     if partitions > number_of_bytes:         raise ValueError(\"partitions can not > number_of_bytes!\")     bytes_per_partition = number_of_bytes // partitions     allocation_list = []     for i in range(partitions):         start_bytes = i * bytes_per_partition + 1         end_bytes = (             number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition         )         allocation_list.append(f\"{start_bytes}-{end_bytes}\")     return allocation_list", "output": "2"}
{"task": "detection", "input": "classify code:\ndef elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReq = R1 + R2 + ... + Rn\n\nChoices:\n0: def calculate_fft(audio_windowed: np.ndarray, ftt_size: int = 1024) -> np.ndarray:     # Transpose the audio data to have time in rows and channels in columns     audio_transposed = np.transpose(audio_windowed)      # Initialize an array to store the FFT results     audio_fft = np.empty(         (int(1 + ftt_size // 2), audio_transposed.shape[1]),         dtype=np.complex64,         order=\"F\",     )      # Compute FFT for each channel     for n in range(audio_fft.shape[1]):         audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]      # Transpose the FFT results back to the original shape     return np.transpose(audio_fft)\n1: def check_bouncy(n: int) -> bool:     if not isinstance(n, int):         raise ValueError(\"check_bouncy() accepts only integer arguments\")     str_n = str(n)     sorted_str_n = \"\".join(sorted(str_n))     return str_n not in {sorted_str_n, sorted_str_n[::-1]}\n2: def resistor_series(resistors: list[float]) -> float:     sum_r = 0.00     for index, resistor in enumerate(resistors):         sum_r += resistor         if resistor < 0:             msg = f\"Resistor at index {index} has a negative value!\"             raise ValueError(msg)     return sum_r", "output": "2"}
{"task": "search", "input": "search code:\nMultiply two matrices.\n\nChoices:\n0: def bubble_sort_recursive(collection: list[Any]) -> list[Any]:     length = len(collection)     swapped = False     for i in range(length - 1):         if collection[i] > collection[i + 1]:             collection[i], collection[i + 1] = collection[i + 1], collection[i]             swapped = True      return collection if not swapped else bubble_sort_recursive(collection)\n1: def matmul(m1, m2):     n = len(m2[0])     return batched(starmap(_sumprod, product(m1, transpose(m2))), n)\n2: def max_subarray(     arr: Sequence[float], low: int, high: int ) -> tuple[int | None, int | None, float]:     if not arr:         return None, None, 0     if low == high:         return low, high, arr[low]      mid = (low + high) // 2     left_low, left_high, left_sum = max_subarray(arr, low, mid)     right_low, right_high, right_sum = max_subarray(arr, mid + 1, high)     cross_left, cross_right, cross_sum = max_cross_sum(arr, low, mid, high)     if left_sum >= right_sum and left_sum >= cross_sum:         return left_low, left_high, left_sum     elif right_sum >= left_sum and right_sum >= cross_sum:         return right_low, right_high, right_sum     return cross_left, cross_right, cross_sum", "output": "1"}
{"task": "search", "input": "search code:\nReturn the peak value of `lst`.\n\nChoices:\n0: def solution(n: int = 10000) -> int:     total = sum(         i         for i in range(1, n)         if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i     )     return total\n1: def peak(lst: list[int]) -> int:     # middle index     m = len(lst) // 2      # choose the middle 3 elements     three = lst[m - 1 : m + 2]      # if middle element is peak     if three[1] > three[0] and three[1] > three[2]:         return three[1]      # if increasing, recurse on right     elif three[0] < three[2]:         if len(lst[:m]) == 2:             m -= 1         return peak(lst[m:])      # decreasing     else:         if len(lst[:m]) == 2:             m += 1         return peak(lst[:m])\n2: def calculate_probabilities(instance_count: int, total_count: int) -> float:     # number of instances in specific class divided by number of all instances     return instance_count / total_count", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef freq_subgraphs_edge_list(paths):\n    freq_sub_el = []\n    for edges in paths:\n        el = []\n        for j in range(len(edges) - 1):\n            temp = list(edges[j])\n            for e in temp:\n                edge = (e[0], e[1])\n                el.append(edge)\n        freq_sub_el.append(el)\n    return freq_sub_el", "output": "returns Edge list for frequent subgraphs"}
{"task": "detection", "input": "classify code:\ndef sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef wiggle_sort(nums: list) -> list:\n    \"\"\"\n    Python implementation of wiggle.\n    Example:\n    >>> wiggle_sort([0, 5, 3, 2, 2])\n    [0, 5, 2, 3, 2]\n    >>> wiggle_sort([])\n    []\n    >>> wiggle_sort([-2, -5, -45])\n    [-45, -2, -5]\n    >>> wiggle_sort([-2.1, -5.68, -45.11])\n    [-45.11, -2.1, -5.68]\n    \"\"\"\n    for i, _ in enumerate(nums):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\n    return nums", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    \"\"\"\n    Implements the Damerau-Levenshtein distance algorithm that measures\n    the edit distance between two strings.\n\n    Parameters:\n        first_string: The first string to compare\n        second_string: The second string to compare\n\n    Returns:\n        distance: The edit distance between the first and second strings\n\n    >>> damerau_levenshtein_distance(\"cat\", \"cut\")\n    1\n    >>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n    3\n    >>> damerau_levenshtein_distance(\"hello\", \"world\")\n    4\n    >>> damerau_levenshtein_distance(\"book\", \"back\")\n    2\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    \"\"\"\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nYield all substrings and their positions in *seq*\n\nChoices:\n0: def substrings_indexes(seq, reverse=False):     r = range(1, len(seq) + 1)     if reverse:         r = reversed(r)     return (         (seq[i : i + L], i, i + L) for L in r for i in range(len(seq) - L + 1)     )\n1: def product_sum_array(array: list[int | list]) -> int:     return product_sum(array, 1)\n2: def naive_cut_rod_recursive(n: int, prices: list):      _enforce_args(n, prices)     if n == 0:         return 0     max_revue = float(\"-inf\")     for i in range(1, n + 1):         max_revue = max(             max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)         )      return max_revue", "output": "0"}
{"task": "search", "input": "search code:\nThis function can calculate the resonant frequency of LC circuit,\n\nChoices:\n0: def validate_matrix_content(matrix: list[str], size: int) -> None:     print(matrix)     if len(matrix) != size:         raise ValueError(\"The matrix dont match with size.\")     for row in matrix:         if len(row) != size:             msg = f\"Each row in the matrix must have exactly {size} characters.\"             raise ValueError(msg)         if not all(char.isalnum() for char in row):             raise ValueError(\"Matrix rows can only contain letters and numbers.\")\n1: def open_knight_tour_helper(     board: list[list[int]], pos: tuple[int, int], curr: int ) -> bool:      if is_complete(board):         return True      for position in get_valid_pos(pos, len(board)):         y, x = position          if board[y][x] == 0:             board[y][x] = curr + 1             if open_knight_tour_helper(board, position, curr + 1):                 return True             board[y][x] = 0      return False\n2: def resonant_frequency(inductance: float, capacitance: float) -> tuple:      if inductance <= 0:         raise ValueError(\"Inductance cannot be 0 or negative\")      elif capacitance <= 0:         raise ValueError(\"Capacitance cannot be 0 or negative\")      else:         return (             \"Resonant frequency\",             float(1 / (2 * pi * (sqrt(inductance * capacitance)))),         )", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef actual_strassen(matrix_a: list, matrix_b: list) -> list:\n    if matrix_dimensions(matrix_a) == (2, 2):\n        return default_matrix_multiplication(matrix_a, matrix_b)\n\n    a, b, c, d = split_matrix(matrix_a)\n    e, f, g, h = split_matrix(matrix_b)\n\n    t1 = actual_strassen(a, matrix_subtraction(f, h))\n    t2 = actual_strassen(matrix_addition(a, b), h)\n    t3 = actual_strassen(matrix_addition(c, d), e)\n    t4 = actual_strassen(d, matrix_subtraction(g, e))\n    t5 = actual_strassen(matrix_addition(a, d), matrix_addition(e, h))\n    t6 = actual_strassen(matrix_subtraction(b, d), matrix_addition(g, h))\n    t7 = actual_strassen(matrix_subtraction(a, c), matrix_addition(e, f))\n\n    top_left = matrix_addition(matrix_subtraction(matrix_addition(t5, t4), t2), t6)\n    top_right = matrix_addition(t1, t2)\n    bot_left = matrix_addition(t3, t4)\n    bot_right = matrix_subtraction(matrix_subtraction(matrix_addition(t1, t5), t3), t7)\n\n    # construct the new matrix from our 4 quadrants\n    new_matrix = []\n    for i in range(len(top_right)):\n        new_matrix.append(top_left[i] + top_right[i])\n    for i in range(len(bot_right)):\n        new_matrix.append(bot_left[i] + bot_right[i])\n    return new_matrix", "output": "Recursive function to calculate the product of two matrices, using the Strassen"}
{"task": "search", "input": "search code:\nApply *func* to every item of *iterable* by dictionary unpacking\n\nChoices:\n0: def doublestarmap(func, iterable):     for item in iterable:         yield func(**item)\n1: def solution(family_length: int = 8) -> int:     numbers_checked = set()      # Filter primes with less than 3 replaceable digits     primes = {         x for x in set(prime_sieve(1_000_000)) if len(str(x)) - len(set(str(x))) >= 3     }      for prime in primes:         if prime in numbers_checked:             continue          replacements = digit_replacements(prime)          for family in replacements:             numbers_checked.update(family)             primes_in_family = primes.intersection(family)              if len(primes_in_family) != family_length:                 continue              return min(primes_in_family)      return -1\n2: def rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:     if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):         raise Exception(\"Invalid upper or lower bound!\")     if high < low:         return -1     if sequence[low] == target:         return low     if sequence[high] == target:         return high     return rec_linear_search(sequence, low + 1, high - 1, target)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef find_winner(num_people: int, step_size: int) -> int:\n    return josephus_recursive(num_people, step_size) + 1", "output": "Find the winner of the Josephus problem for num_people and a step_size."}
{"task": "detection", "input": "classify code:\ndef gnome_sort(lst: list) -> list:\n    \"\"\"\n    Pure implementation of the gnome sort algorithm in Python\n\n    Take some mutable ordered collection with heterogeneous comparable items inside as\n    arguments, return the same collection ordered by ascending.\n\n    Examples:\n    >>> gnome_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> gnome_sort([])\n    []\n\n    >>> gnome_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    >>> \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\"))))\n    ' !Gadeimnoprstu'\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n\n    i = 1\n\n    while i < len(lst):\n        if lst[i - 1] <= lst[i]:\n            i += 1\n        else:\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1\n\n    return lst", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef euclidean(input_a: np.ndarray, input_b: np.ndarray) -> float:\n    return math.sqrt(sum(pow(a - b, 2) for a, b in zip(input_a, input_b)))", "output": "Calculates euclidean distance between two data."}
{"task": "summary", "input": "summarize code:\ndef document_frequency(term: str, corpus: str) -> tuple[int, int]:\n    corpus_without_punctuation = corpus.lower().translate(\n        str.maketrans(\"\", \"\", string.punctuation)\n    )  # strip all punctuation and replace it with ''\n    docs = corpus_without_punctuation.split(\"\\n\")\n    term = term.lower()\n    return (len([doc for doc in docs if term in doc]), len(docs))", "output": "Calculate the number of documents in a corpus that contain a"}
{"task": "summary", "input": "summarize code:\ndef calculate_prime_numbers(max_number: int) -> list[int]:\n\n    is_prime = [True] * max_number\n    for i in range(2, isqrt(max_number - 1) + 1):\n        if is_prime[i]:\n            for j in range(i**2, max_number, i):\n                is_prime[j] = False\n\n    return [i for i in range(2, max_number) if is_prime[i]]", "output": "Returns prime numbers below max_number"}
{"task": "summary", "input": "summarize code:\ndef evaluate_poly(poly: Sequence[float], x: float) -> float:\n    return sum(c * (x**i) for i, c in enumerate(poly))", "output": "Evaluate a polynomial f(x) at specified point x and return the value."}
{"task": "summary", "input": "summarize code:\ndef clone_graph(node: Node | None) -> Node | None:\n    if not node:\n        return None\n\n    originals_to_clones = {}  # map nodes to clones\n\n    stack = [node]\n\n    while stack:\n        original = stack.pop()\n\n        if original in originals_to_clones:\n            continue\n\n        originals_to_clones[original] = Node(original.value)\n\n        stack.extend(original.neighbors or [])\n\n    for original, clone in originals_to_clones.items():\n        for neighbor in original.neighbors or []:\n            cloned_neighbor = originals_to_clones[neighbor]\n\n            if not clone.neighbors:\n                clone.neighbors = []\n\n            clone.neighbors.append(cloned_neighbor)\n\n    return originals_to_clones[node]", "output": "This function returns a clone of a connected undirected graph."}
{"task": "detection", "input": "classify code:\ndef max_sub_array(nums: list[int]) -> int:\n    \"\"\"\n    Finds the contiguous subarray which has the largest sum and return its sum.\n\n    >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n\n    An empty (sub)array has sum 0.\n    >>> max_sub_array([])\n    0\n\n    If all elements are negative, the largest subarray would be the empty array,\n    having the sum 0.\n    >>> max_sub_array([-1, -2, -3])\n    0\n    >>> max_sub_array([5, -2, -3])\n    5\n    >>> max_sub_array([31, -41, 59, 26, -53, 58, 97, -93, -23, 84])\n    187\n    \"\"\"\n    best = 0\n    current = 0\n    for i in nums:\n        current += i\n        if current < 0:\n            current = 0\n        best = max(best, current)\n    return best", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef imply_gate(input_1: int, input_2: int) -> int:\n    return int(input_1 == 0 or input_2 == 1)", "output": "Calculate IMPLY of the input values"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    i = 1\n\n    while True:\n        if (\n            sorted(str(i))\n            == sorted(str(2 * i))\n            == sorted(str(3 * i))\n            == sorted(str(4 * i))\n            == sorted(str(5 * i))\n            == sorted(str(6 * i))\n        ):\n            return i\n\n        i += 1", "output": "Returns the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and"}
{"task": "detection", "input": "classify code:\ndef data_safety_checker(list_vote: list, actual_result: float) -> None:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2,3,4],5.0)\n    Today's data is not safe.\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe = safe + 1\n            else:\n                not_safe = not_safe + 1\n    print(f\"Today's data is {'not ' if safe <= not_safe else ''}safe.\")", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef y_generator(class_count: int, instance_count: list) -> list:\n    \"\"\"\n    Generate y values for corresponding classes\n    :param class_count: Number of classes(data groupings) in dataset\n    :param instance_count: number of instances in class\n    :return: corresponding values for data groupings in dataset\n\n    >>> y_generator(1, [10])\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    >>> y_generator(2, [5, 10])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    return [k for k in range(class_count) for _ in range(instance_count[k])]", "output": "def y_generator(class_count: int, instance_count: list) -> list:\n    \"\"\"\n    Generate y values for corresponding classes\n    :param class_count: Number of classes(data groupings) in dataset\n    :param instance_count: number of instances in class\n    :return: corresponding values for data groupings in dataset\n\n    >>> y_generator(1, [10])\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    >>> y_generator(2, [5, 10])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    return [k for k in range(class_count) for _ in range(instance_count[k])]"}
{"task": "search", "input": "search code:\nAn extension of :func:`itertools.groupby` that can apply transformations\n\nChoices:\n0: def breadth_first_search(     level: list[int],     parent: list[list[int]],     max_node: int,     graph: dict[int, list[int]],     root: int = 1, ) -> tuple[list[int], list[list[int]]]:     level[root] = 0     q: Queue[int] = Queue(maxsize=max_node)     q.put(root)     while q.qsize() != 0:         u = q.get()         for v in graph[u]:             if level[v] == -1:                 level[v] = level[u] + 1                 q.put(v)                 parent[0][v] = u     return level, parent\n1: def groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):     ret = groupby(iterable, keyfunc)     if valuefunc:         ret = ((k, map(valuefunc, g)) for k, g in ret)     if reducefunc:         ret = ((k, reducefunc(g)) for k, g in ret)      return ret\n2: def data_safety_checker(list_vote: list, actual_result: float) -> bool:     safe = 0     not_safe = 0      if not isinstance(actual_result, float):         raise TypeError(\"Actual result should be float. Value passed is a list\")      for i in list_vote:         if i > actual_result:             safe = not_safe + 1         elif abs(abs(i) - abs(actual_result)) <= 0.1:             safe += 1         else:             not_safe += 1     return safe > not_safe", "output": "1"}
{"task": "detection", "input": "classify code:\ndef create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "CORRECT"}
{"task": "search", "input": "search code:\nTake in a 32 bit integer, reverse its bits, return a 32 bit integer result\n\nChoices:\n0: def reverse_bit(number: int) -> int:     if not isinstance(number, int):         raise TypeError(\"Input value must be an 'int' type\")     if number < 0:         raise ValueError(\"The value of input must be non-negative\")      result = 0     # iterator over [0 to 31], since we are dealing with a 32 bit integer     for _ in range(32):         # left shift the bits by unity         result <<= 1         # get the end bit         end_bit = number & 1         # right shift the bits by unity         number >>= 1         # add that bit to our answer         result |= end_bit     return result\n1: def local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:     center = image[x_coordinate][y_coordinate]     powers = [1, 2, 4, 8, 16, 32, 64, 128]      # skip get_neighbors_pixel if center is null     if center is None:         return 0      # Starting from the top right, assigning value to pixels clockwise     binary_values = [         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),         get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),     ]      # Converting the binary value to decimal.     return sum(         binary_value * power for binary_value, power in zip(binary_values, powers)     )\n2: def benchmark() -> None:     from timeit import timeit      print(\"Running performance benchmarks...\")     setup = \"from string import printable ; from __main__ import atbash, atbash_slow\"     print(f\"> atbash_slow(): {timeit('atbash_slow(printable)', setup=setup)} seconds\")     print(f\">      atbash(): {timeit('atbash(printable)', setup=setup)} seconds\")", "output": "0"}
{"task": "detection", "input": "classify code:\ndef naive_pattern_search(s: str, pattern: str) -> list:\n    \"\"\"\n    >>> naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\")\n    [4, 10, 18]\n    >>> naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\")\n    []\n    >>> naive_pattern_search(\"\", \"ABC\")\n    []\n    >>> naive_pattern_search(\"TEST\", \"TEST\")\n    [0]\n    >>> naive_pattern_search(\"ABCDEGFTEST\", \"TEST\")\n    [7]\n    \"\"\"\n    pat_len = len(pattern)\n    position = []\n    for i in range(len(s) - pat_len + 1):\n        match_found = True\n        for j in range(pat_len):\n            if s[i + j] != pattern[j]:\n                match_found = False\n                break\n        if match_found:\n            position.append(i)\n    return position", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef unit_basis_vector(dimension: int, pos: int) -> Vector:\n    # precondition\n    assert isinstance(dimension, int)\n    assert isinstance(pos, int)\n    ans = [0] * dimension\n    ans[pos] = 1\n    return Vector(ans)", "output": "returns a unit basis vector with a One"}
{"task": "search", "input": "search code:\nCalculate the Surface Area of a Cuboid.\n\nChoices:\n0: def factor(n):      # Corner case reduction     if n < 2:         return      # Trial division reduction     for prime in _primes_below_211:         while not n % prime:             yield prime             n //= prime      # Pollard's rho reduction     primes = []     todo = [n] if n > 1 else []     for n in todo:         if n < 211**2 or is_prime(n):             primes.append(n)         else:             fact = _factor_pollard(n)             todo += (fact, n // fact)     yield from sorted(primes)\n1: def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:     return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2\n2: def surface_area_cuboid(length: float, breadth: float, height: float) -> float:     if length < 0 or breadth < 0 or height < 0:         raise ValueError(\"surface_area_cuboid() only accepts non-negative values\")     return 2 * ((length * breadth) + (breadth * height) + (length * height))", "output": "2"}
{"task": "search", "input": "search code:\nThis function calculates the average of the waiting & turnaround times\n\nChoices:\n0: def relu(vector: list[float]):      # compare two arrays and then return element-wise maxima.     return np.maximum(0, vector)\n1: def calculate_average_times(     waiting_time: list[int], turn_around_time: list[int], no_of_processes: int ) -> None:     total_waiting_time = 0     total_turn_around_time = 0     for i in range(no_of_processes):         total_waiting_time = total_waiting_time + waiting_time[i]         total_turn_around_time = total_turn_around_time + turn_around_time[i]     print(f\"Average waiting time = {total_waiting_time / no_of_processes:.5f}\")     print(\"Average turn around time =\", total_turn_around_time / no_of_processes)\n2: def solution() -> int:     num = 138902663      while not is_square_form(num * num):         if num % 10 == 3:             num -= 6  # (3 - 6) % 10 = 7         else:             num -= 4  # (7 - 4) % 10 = 3      return num * 10", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef first_molar_mass(\n    molar_mass: float, effusion_rate_1: float, effusion_rate_2: float\n) -> float | ValueError:\n    return (\n        round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)\n        if validate(molar_mass, effusion_rate_1, effusion_rate_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )", "output": "Input Parameters:"}
{"task": "detection", "input": "classify code:\ndef equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPure implementation of a binary search algorithm in Python\n\nChoices:\n0: def binary_search(sorted_collection: list[int], item: int) -> int:     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     left = 0     right = len(sorted_collection) - 1      while left <= right:         midpoint = left + (right - left) // 2         current_item = sorted_collection[midpoint]         if current_item == item:             return midpoint         elif item < current_item:             right = midpoint - 1         else:             left = midpoint + 1     return -1\n1: def nth_product(index, *args):     pools = list(map(tuple, reversed(args)))     ns = list(map(len, pools))      c = reduce(mul, ns)      if index < 0:         index += c      if not 0 <= index < c:         raise IndexError      result = []     for pool, n in zip(pools, ns):         result.append(pool[index % n])         index //= n      return tuple(reversed(result))\n2: def main() -> None:     kmap = [[0, 1], [1, 1]]      # Manually generate the product of [0, 1] and [0, 1]      for row in kmap:         print(row)      print(\"Simplified Expression:\")     print(simplify_kmap(kmap))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef duplicates_justseen(iterable, key=None):\n    return flatten(g for _, g in groupby(iterable, key) for _ in g)", "output": "Yields serially-duplicate elements after their first appearance."}
{"task": "summary", "input": "summarize code:\ndef procentual_proximity(\n    source_data: list[list[float]], weights: list[int]\n) -> list[list[float]]:\n\n    data_lists = get_data(source_data)\n    score_lists = calculate_each_score(data_lists, weights)\n    final_scores = generate_final_scores(score_lists)\n\n    # append scores to source data\n    for i, ele in enumerate(final_scores):\n        source_data[i].append(ele)\n\n    return source_data", "output": "| `weights` - ``int`` list"}
{"task": "summary", "input": "summarize code:\ndef lstrip_iter(iterable, strip_value=None):\n    iterator = iter(iterable)\n    for i in iterator:\n        if i != strip_value:\n            yield i\n            break\n    for i in iterator:\n        yield i", "output": "Strips values from the beginning of an iterable. Stripped items will"}
{"task": "detection", "input": "classify code:\ndef newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    Calculates force from `mass` and `acceleration`\n\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculate the Surface Area of a Conical Frustum.\n\nChoices:\n0: def area_rectangle(length: float, width: float) -> float:     if length < 0 or width < 0:         raise ValueError(\"area_rectangle() only accepts non-negative values\")     return length * width\n1: def surface_area_conical_frustum(     radius_1: float, radius_2: float, height: float ) -> float:     if radius_1 < 0 or radius_2 < 0 or height < 0:         raise ValueError(             \"surface_area_conical_frustum() only accepts non-negative values\"         )     slant_height = (height**2 + (radius_1 - radius_2) ** 2) ** 0.5     return pi * ((slant_height * (radius_1 + radius_2)) + radius_1**2 + radius_2**2)\n2: def coulombs_law(q1: float, q2: float, radius: float) -> float:     if radius <= 0:         raise ValueError(\"The radius is always a positive number\")     return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef harmonic_series(n_term: str) -> list:\n    \"\"\"Pure Python implementation of Harmonic Series algorithm\n\n    :param n_term: The last (nth) term of Harmonic Series\n    :return: The Harmonic Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> harmonic_series(5)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.0)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.1)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(-5)\n    []\n    >>> harmonic_series(0)\n    []\n    >>> harmonic_series(1)\n    ['1']\n    \"\"\"\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef print_solution(grid: Matrix) -> None:\n    for row in grid:\n        for cell in row:\n            print(cell, end=\" \")\n        print()", "output": "A function to print the solution in the form"}
{"task": "search", "input": "search code:\nCalculate the Volume of a Cuboid.\n\nChoices:\n0: def vol_cuboid(width: float, height: float, length: float) -> float:     if width < 0 or height < 0 or length < 0:         raise ValueError(\"vol_cuboid() only accepts non-negative values\")     return float(width * height * length)\n1: def insert_node(head: Node | None, data: int) -> Node:     new_node = Node(data)     # If the linked list is empty, the new_node becomes the head     if head is None:         return new_node      temp_node = head     while temp_node.next_node:         temp_node = temp_node.next_node      temp_node.next_node = new_node     return head\n2: def upper(word: str) -> str:     return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef neville_interpolate(x_points: list, y_points: list, x0: int) -> list:\n    n = len(x_points)\n    q = [[0] * n for i in range(n)]\n    for i in range(n):\n        q[i][1] = y_points[i]\n\n    for i in range(2, n):\n        for j in range(i, n):\n            q[j][i] = (\n                (x0 - x_points[j - i + 1]) * q[j][i - 1]\n                - (x0 - x_points[j]) * q[j - 1][i - 1]\n            ) / (x_points[j] - x_points[j - i + 1])\n\n    return [q[n - 1][n - 1], q]", "output": "Interpolate and evaluate a polynomial using Neville's method."}
{"task": "repair", "input": "fix bug:\ndef wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]", "output": "def wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]"}
{"task": "summary", "input": "summarize code:\ndef benchmark(input_str: str = \"\") -> None:\n    print(\"\\nFor string = \", input_str, \":\")\n    print(\n        \"> can_string_be_rearranged_as_palindrome_counter()\",\n        \"\\tans =\",\n        can_string_be_rearranged_as_palindrome_counter(input_str),\n        \"\\ttime =\",\n        timeit(\n            \"z.can_string_be_rearranged_as_palindrome_counter(z.check_str)\",\n            setup=\"import __main__ as z\",\n        ),\n        \"seconds\",\n    )\n    print(\n        \"> can_string_be_rearranged_as_palindrome()\",\n        \"\\tans =\",\n        can_string_be_rearranged_as_palindrome(input_str),\n        \"\\ttime =\",\n        timeit(\n            \"z.can_string_be_rearranged_as_palindrome(z.check_str)\",\n            setup=\"import __main__ as z\",\n        ),\n        \"seconds\",\n    )", "output": "Benchmark code for comparing above 2 functions"}
{"task": "search", "input": "search code:\nReturns the unit symbols and their values to satisfy clause.\n\nChoices:\n0: def find_unit_clauses(     clauses: list[Clause],     model: dict[str, bool | None],  # noqa: ARG001 ) -> tuple[list[str], dict[str, bool | None]]:     unit_symbols = []     for clause in clauses:         if len(clause) == 1:             unit_symbols.append(next(iter(clause.literals.keys())))         else:             f_count, n_count = 0, 0             for literal, value in clause.literals.items():                 if value is False:                     f_count += 1                 elif value is None:                     sym = literal                     n_count += 1             if f_count == len(clause) - 1 and n_count == 1:                 unit_symbols.append(sym)     assignment: dict[str, bool | None] = {}     for i in unit_symbols:         symbol = i[:2]         assignment[symbol] = len(i) == 2     unit_symbols = [i[:2] for i in unit_symbols]      return unit_symbols, assignment\n1: def fibonacci_digits_index(n: int) -> int:     digits = 0     index = 2      while digits < n:         index += 1         digits = len(str(fibonacci(index)))      return index\n2: def binary_exp_iterative(base: float, exponent: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res *= base          base *= base         exponent >>= 1      return res", "output": "0"}
{"task": "detection", "input": "classify code:\ndef calculate_turn_around_times(\r\n    burst_times: list[int], waiting_times: list[int]\r\n) -> list[int]:\r\n    \"\"\"\r\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\r\n    [1, 3, 6]\r\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\r\n    [20, 9, 18]\r\n    \"\"\"\r\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\r", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef kth_permutation(k, n):\n    \"\"\"\n    Finds k'th lexicographic permutation (in increasing order) of\n    0,1,2,...n-1 in O(n^2) time.\n\n    Examples:\n    First permutation is always 0,1,2,...n\n    >>> kth_permutation(0,5)\n    [0, 1, 2, 3, 4]\n\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n    [1,2,3,0], [1,3,0,2]\n    >>> kth_permutation(10,4)\n    [1, 3, 0, 2]\n    \"\"\"\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the biggest prime, below the celing, that can be written as the sum\n\nChoices:\n0: def heaps(arr: list) -> list:      if len(arr) <= 1:         return [tuple(arr)]      res = []      def generate(n: int, arr: list):         c = [0] * n         res.append(tuple(arr))          i = 0         while i < n:             if c[i] < i:                 if i % 2 == 0:                     arr[0], arr[i] = arr[i], arr[0]                 else:                     arr[c[i]], arr[i] = arr[i], arr[c[i]]                 res.append(tuple(arr))                 c[i] += 1                 i = 0             else:                 c[i] = 0                 i += 1      generate(len(arr), arr)     return res\n1: def add_file_length(source_path: str, compressed: str) -> str:     file_length = os.path.getsize(source_path)     file_length_binary = bin(file_length)[2:]     length_length = len(file_length_binary)      return \"0\" * (length_length - 1) + file_length_binary + compressed\n2: def solution(ceiling: int = 1_000_000) -> int:     primes = prime_sieve(ceiling)     length = 0     largest = 0      for i in range(len(primes)):         for j in range(i + length, len(primes)):             sol = sum(primes[i:j])             if sol >= ceiling:                 break              if sol in primes:                 length = j - i                 largest = sol      return largest", "output": "2"}
{"task": "search", "input": "search code:\nEquivalent to ``list(product(*args)).index(element)``\n\nChoices:\n0: def product_index(element, *args):     elements = tuple(element)     pools = tuple(map(tuple, args))     if len(elements) != len(pools):         raise ValueError('element is not a product of args')      index = 0     for elem, pool in zip(elements, pools):         index = index * len(pool) + pool.index(elem)     return index\n1: def get_all_subclasses(cls):     try:         to_check = deque(cls.__subclasses__())     except (AttributeError, TypeError):         raise TypeError('expected type object, not %r' % cls)     seen, ret = set(), []     while to_check:         cur = to_check.popleft()         if cur in seen:             continue         ret.append(cur)         seen.add(cur)         to_check.extend(cur.__subclasses__())     return ret\n2: def solution(n: int = 1000000):     total = 0      for i in range(1, n):         if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):             total += i     return total", "output": "0"}
{"task": "search", "input": "search code:\nThis value is Negative, if the model underpredicts,\n\nChoices:\n0: def merge_sort(collection: list) -> list:      def merge(left: list, right: list) -> list:         result = []         while left and right:             result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))         result.extend(left)         result.extend(right)         return result      if len(collection) <= 1:         return collection     mid_index = len(collection) // 2     return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))\n1: def mbd(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     numerator = np.sum(difference) / len(predict)     denumerator = np.sum(actual) / len(predict)     # print(numerator, denumerator)     score = float(numerator) / denumerator * 100      return score\n2: def solution(max_base: int = 10, max_power: int = 22) -> int:     bases = range(1, max_base)     powers = range(1, max_power)     return sum(         1 for power in powers for base in bases if len(str(base**power)) == power     )", "output": "1"}
{"task": "search", "input": "search code:\nReturns the n-th prime number.\n\nChoices:\n0: def chunk_ranges(input_size, chunk_size, input_offset=0, overlap_size=0, align=False):     input_size = _validate_positive_int(         input_size, 'input_size', strictly_positive=False)     chunk_size = _validate_positive_int(chunk_size, 'chunk_size')     input_offset = _validate_positive_int(         input_offset, 'input_offset', strictly_positive=False)     overlap_size = _validate_positive_int(         overlap_size, 'overlap_size', strictly_positive=False)      input_stop = input_offset + input_size      if align:         initial_chunk_len = chunk_size - \\             input_offset % (chunk_size - overlap_size)         if initial_chunk_len != overlap_size:             yield (input_offset, min(input_offset + initial_chunk_len, input_stop))             if input_offset + initial_chunk_len >= input_stop:                 return             input_offset = input_offset + initial_chunk_len - overlap_size      for i in range(input_offset, input_stop, chunk_size - overlap_size):         yield (i, min(i + chunk_size, input_stop))          if i + chunk_size >= input_stop:             return\n1: def heapify(unsorted: list[int], index: int, heap_size: int) -> None:     largest = index     left_index = 2 * index + 1     right_index = 2 * index + 2     if left_index < heap_size and unsorted[left_index] > unsorted[largest]:         largest = left_index      if right_index < heap_size and unsorted[right_index] > unsorted[largest]:         largest = right_index      if largest != index:         unsorted[largest], unsorted[index] = (unsorted[index], unsorted[largest])         heapify(unsorted, largest, heap_size)\n2: def solution(nth: int = 10001) -> int:      count = 0     number = 1     while count != nth and number < 3:         number += 1         if is_prime(number):             count += 1     while count != nth:         number += 2         if is_prime(number):             count += 1     return number", "output": "2"}
{"task": "search", "input": "search code:\nPrint octal equivalents of decimal numbers.\n\nChoices:\n0: def unzip(iterable):     head, iterable = spy(iterable)     if not head:         # empty iterable, e.g. zip([], [], [])         return ()     # spy returns a one-length iterable as head     head = head[0]     iterables = tee(iterable, len(head))      # If we have an iterable like iter([(1, 2, 3), (4, 5), (6,)]),     # the second unzipped iterable fails at the third tuple since     # it tries to access (6,)[1].     # Same with the third unzipped iterable and the second tuple.     # To support these \"improperly zipped\" iterables, we suppress     # the IndexError, which just stops the unzipped iterables at     # first length mismatch.     return tuple(         iter_suppress(map(itemgetter(i), it), IndexError)         for i, it in enumerate(iterables)     )\n1: def main() -> None:     print(\"\\n2 in octal is:\")     print(decimal_to_octal(2))  # = 2     print(\"\\n8 in octal is:\")     print(decimal_to_octal(8))  # = 10     print(\"\\n65 in octal is:\")     print(decimal_to_octal(65))  # = 101     print(\"\\n216 in octal is:\")     print(decimal_to_octal(216))  # = 330     print(\"\\n512 in octal is:\")     print(decimal_to_octal(512))  # = 1000     print(\"\\n\")\n2: def binary_exp_mod_recursive(base: float, exponent: int, modulus: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")     if modulus <= 0:         raise ValueError(\"Modulus must be a positive integer\")      if exponent == 0:         return 1      if exponent % 2 == 1:         return (binary_exp_mod_recursive(base, exponent - 1, modulus) * base) % modulus      r = binary_exp_mod_recursive(base, exponent // 2, modulus)     return (r * r) % modulus", "output": "1"}
{"task": "detection", "input": "classify code:\ndef wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef binomial_distribution(successes: int, trials: int, prob: float) -> float:\n    if successes > trials:\n    if trials < 0 or successes < 0:\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not isinstance(successes, int) or not isinstance(trials, int):\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not 0 < prob < 1:\n        raise ValueError(\"prob has to be in range of 1 - 0\")\n    probability = (prob**successes) * ((1 - prob) ** (trials - successes))\n    # Calculate the binomial coefficient: n! / k!(n-k)!\n    coefficient = float(factorial(trials))\n    coefficient /= factorial(successes) * factorial(trials - successes)\n    return probability * coefficient", "output": "Return probability of k successes out of n tries, with p probability for one"}
{"task": "summary", "input": "summarize code:\ndef build_tree() -> TreeNode:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(5)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.right = TreeNode(6)\n    return root", "output": "Build and return a sample binary tree."}
{"task": "search", "input": "search code:\nIn-order traversal visits left subtree, root node, right subtree.\n\nChoices:\n0: def is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:     for i in range(9):         if n in {grid[row][i], grid[i][column]}:             return False      for i in range(3):         for j in range(3):             if grid[(row - row % 3) + i][(column - column % 3) + j] == n:                 return False      return True\n1: def benchmark() -> None:      def do_benchmark(number: int) -> None:         setup = \"import __main__ as z\"         print(f\"Benchmark when {number = }:\")         print(f\"{get_set_bits_count_using_modulo_operator(number) = }\")         timing = timeit(             f\"z.get_set_bits_count_using_modulo_operator({number})\", setup=setup         )         print(f\"timeit() runs in {timing} seconds\")         print(f\"{get_set_bits_count_using_brian_kernighans_algorithm(number) = }\")         timing = timeit(             f\"z.get_set_bits_count_using_brian_kernighans_algorithm({number})\",             setup=setup,         )         print(f\"timeit() runs in {timing} seconds\")      for number in (25, 37, 58, 0):         do_benchmark(number)         print()\n2: def inorder(root: Node | None) -> Generator[int]:     if not root:         return     yield from inorder(root.left)     yield root.data     yield from inorder(root.right)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef is_safe(board: list[list[int]], row: int, column: int) -> bool:\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same upper column,\n    # left upper diagonal and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))\n        )\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))\n        )\n    )", "output": "This function returns a boolean value True if it is safe to place a queen there"}
{"task": "repair", "input": "fix bug:\ndef to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word", "output": "def to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word"}
{"task": "repair", "input": "fix bug:\ndef lin_search(left: int, right: int, array: List[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1", "output": "def lin_search(left: int, right: int, array: list[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1"}
{"task": "summary", "input": "summarize code:\ndef run(canvas: list[list[bool]]) -> list[list[bool]]:\n    current_canvas = np.array(canvas)\n    next_gen_canvas = np.array(create_canvas(current_canvas.shape[0]))\n    for r, row in enumerate(current_canvas):\n        for c, pt in enumerate(row):\n            next_gen_canvas[r][c] = __judge_point(\n                pt, current_canvas[r - 1 : r + 2, c - 1 : c + 2]\n            )\n\n    return next_gen_canvas.tolist()", "output": "This function runs the rules of game through all points, and changes their"}
{"task": "search", "input": "search code:\nProcesses the game logic for the given matrix and moves.\n\nChoices:\n0: def process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:      game_matrix = [list(row) for row in matrix]     total_score = 0      for move in moves:         pos_x, pos_y = move         game_matrix, score = play(game_matrix, pos_x, pos_y, size)         total_score += score      return total_score\n1: def add(first: int, second: int) -> int:     while second != 0:         c = first & second         first ^= second         second = c << 1     return first\n2: def _pgettext(msgctxt, message):     # This GNU gettext function was added in Python 3.8, so for older versions we     # reimplement it. It works by joining `msgctx` and `message` by '4' byte.     try:         # Python 3.8+         return get_translation().pgettext(msgctxt, message)     except AttributeError:         # Python 3.7 and older         key = msgctxt + \"\\x04\" + message         translation = get_translation().gettext(key)         return message if translation == key else translation", "output": "0"}
{"task": "detection", "input": "classify code:\ndef check_anagrams(first_str: str, second_str: str) -> bool:\r\n    \"\"\"\r\n    Two strings are anagrams if they are made of the same letters\r\n    arranged differently (ignoring the case).\r\n    >>> check_anagrams('Silent', 'Listen')\r\n    True\r\n    >>> check_anagrams('This is a string', 'Is this a string')\r\n    True\r\n    >>> check_anagrams('This is    a      string', 'Is     this a string')\r\n    True\r\n    >>> check_anagrams('There', 'Their')\r\n    False\r\n    \"\"\"\r\n    return (\r\n        \"\".join(sorted(first_str.lower())).strip()\r\n        == \"\".join(sorted(second_str.lower())).strip()\r\n    )\r", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True", "output": "def is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True"}
{"task": "summary", "input": "summarize code:\ndef horizontal_distance(init_velocity: float, angle: float) -> float:\n    check_args(init_velocity, angle)\n    radians = deg_to_rad(2 * angle)\n    return round(init_velocity**2 * sin(radians) / g, 2)", "output": "Returns the horizontal distance that the object cover"}
{"task": "search", "input": "search code:\nThis function calculates the turnaround time of some processes.\n\nChoices:\n0: def calculate_turnaround_times(     duration_times: list[int], waiting_times: list[int] ) -> list[int]:     return [         duration_time + waiting_times[i]         for i, duration_time in enumerate(duration_times)     ]\n1: def change_brightness(img: Image, level: float) -> Image:      def brightness(c: int) -> float:         return 128 + level + (c - 128)      if not -255.0 <= level <= 255.0:         raise ValueError(\"level must be between -255.0 (black) and 255.0 (white)\")     return img.point(brightness)\n2: def simple_moving_average(     data: Sequence[float], window_size: int ) -> list[float | None]:     if window_size < 1:         raise ValueError(\"Window size must be a positive integer\")      sma: list[float | None] = []      for i in range(len(data)):         if i < window_size - 1:             sma.append(None)  # SMA not available for early data points         else:             window = data[i - window_size + 1 : i + 1]             sma_value = sum(window) / window_size             sma.append(sma_value)     return sma", "output": "0"}
{"task": "detection", "input": "classify code:\ndef vol_cube(side_length: int | float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nRaises a matrix to the power of 'power' using binary exponentiation.\n\nChoices:\n0: def pdb_on_signal(signalnum=None):     import pdb     import signal     if not signalnum:         signalnum = signal.SIGINT      old_handler = signal.getsignal(signalnum)      def pdb_int_handler(sig, frame):         signal.signal(signalnum, old_handler)         pdb.set_trace()         pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help      signal.signal(signalnum, pdb_int_handler)     return\n1: def matrix_pow_np(m: ndarray, power: int) -> ndarray:     result = np.array([[1, 0], [0, 1]], dtype=int)  # Identity Matrix     base = m     if power < 0:  # Negative power is not allowed         raise ValueError(\"power is negative\")     while power:         if power % 2 == 1:             result = np.dot(result, base)         base = np.dot(base, base)         power //= 2     return result\n2: def calc_derivative(f: RealFunc, x: float, delta_x: float = 1e-3) -> float:     return (f(x + delta_x / 2) - f(x - delta_x / 2)) / delta_x", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef _count_cross_inversions(p, q):\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion", "output": "Counts the inversions across two sorted arrays."}
{"task": "search", "input": "search code:\nImplementation of djb2 hash algorithm that\n\nChoices:\n0: def djb2(s: str) -> int:     hash_value = 5381     for x in s:         hash_value = ((hash_value << 5) + hash_value) + ord(x)     return hash_value & 0xFFFFFFFF\n1: def union_set(x: Node, y: Node) -> None:     x, y = find_set(x), find_set(y)     if x == y:         return      elif x.rank > y.rank:         y.parent = x     else:         x.parent = y         if x.rank == y.rank:             y.rank += 1\n2: def decimal_to_ipv4(decimal_ipv4: int) -> str:      if not (0 <= decimal_ipv4 <= 4294967295):         raise ValueError(\"Invalid decimal IPv4 address\")      ip_parts = []     for _ in range(4):         ip_parts.append(str(decimal_ipv4 & 255))         decimal_ipv4 >>= 8      return \".\".join(reversed(ip_parts))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef get_set_bits_count_using_brian_kernighans_algorithm(number: int) -> int:\n    if number < 0:\n        raise ValueError(\"the value of input must not be negative\")\n    result = 0\n    while number:\n        number &= number - 1\n        result += 1\n    return result", "output": "Count the number of set bits in a 32 bit integer"}
{"task": "detection", "input": "classify code:\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef redundant(src, key=None, groups=False):\n    if key is None:\n        pass\n    elif callable(key):\n        key_func = key\n    elif isinstance(key, (str, bytes)):\n        def key_func(x): return getattr(x, key, x)\n    else:\n        raise TypeError('\"key\" expected a string or callable, not %r' % key)\n    seen = {}  # key to first seen item\n    redundant_order = []\n    redundant_groups = {}\n    for i in src:\n        k = key_func(i) if key else i\n        if k not in seen:\n            seen[k] = i\n        else:\n            if k in redundant_groups:\n                if groups:\n                    redundant_groups[k].append(i)\n            else:\n                redundant_order.append(k)\n                redundant_groups[k] = [seen[k], i]\n    if not groups:\n        ret = [redundant_groups[k][1] for k in redundant_order]\n    else:\n        ret = [redundant_groups[k] for k in redundant_order]\n    return ret", "output": "The complement of :func:`unique()`."}
{"task": "summary", "input": "summarize code:\ndef covariance_between_classes(\n    features: np.ndarray, labels: np.ndarray, classes: int\n) -> np.ndarray:\n\n    general_data_mean = features.mean(1)\n    covariance_sum = np.nan\n    for i in range(classes):\n        data = features[:, labels == i]\n        device_data = data.shape[1]\n        data_mean = data.mean(1)\n        if i > 0:\n            # If covariance_sum is not None\n            covariance_sum += device_data * np.dot(\n                column_reshape(data_mean) - column_reshape(general_data_mean),\n                (column_reshape(data_mean) - column_reshape(general_data_mean)).T,\n            )\n        else:\n            # If covariance_sum is np.nan (i.e. first loop)\n            covariance_sum = device_data * np.dot(\n                column_reshape(data_mean) - column_reshape(general_data_mean),\n                (column_reshape(data_mean) - column_reshape(general_data_mean)).T,\n            )\n\n    return covariance_sum / features.shape[1]", "output": "Function to compute the covariance matrix between multiple classes"}
{"task": "search", "input": "search code:\nArgs:\n\nChoices:\n0: def archimedes_principle(     fluid_density: float, volume: float, gravity: float = g ) -> float:      if fluid_density <= 0:         raise ValueError(\"Impossible fluid density\")     if volume <= 0:         raise ValueError(\"Impossible object volume\")     if gravity < 0:         raise ValueError(\"Impossible gravity\")      return fluid_density * gravity * volume\n1: def rotate_array(arr: list[int], steps: int) -> list[int]:      n = len(arr)     if n == 0:         return arr      steps = steps % n      if steps < 0:         steps += n      def reverse(start: int, end: int) -> None:          while start < end:             arr[start], arr[end] = arr[end], arr[start]             start += 1             end -= 1      reverse(0, n - 1)     reverse(0, steps - 1)     reverse(steps, n - 1)      return arr\n2: def prime_sieve(num: int) -> list[int]:      if num <= 0:         msg = f\"{num}: Invalid input, please enter a positive integer.\"         raise ValueError(msg)      sieve = [True] * (num + 1)     prime = []     start = 2     end = int(math.sqrt(num))      while start <= end:         # If start is a prime         if sieve[start] is True:             prime.append(start)              # Set multiples of start be False             for i in range(start * start, num + 1, start):                 if sieve[i] is True:                     sieve[i] = False          start += 1      for j in range(end + 1, num + 1):         if sieve[j] is True:             prime.append(j)      return prime", "output": "0"}
{"task": "search", "input": "search code:\nCounts the inversions across two sorted arrays.\n\nChoices:\n0: def _count_cross_inversions(p, q):      r = []     i = j = num_inversion = 0     while i < len(p) and j < len(q):         if p[i] > q[j]:             # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)             # These are all inversions. The claim emerges from the             # property that P is sorted.             num_inversion += len(p) - i             r.append(q[j])             j += 1         else:             r.append(p[i])             i += 1      if i < len(p):         r.extend(p[i:])     else:         r.extend(q[j:])      return r, num_inversion\n1: def ordinal(value, gender=\"male\"):     try:         value = int(value)     except (TypeError, ValueError):         return value     if gender == \"male\":         t = (             P_(\"0 (male)\", \"th\"),             P_(\"1 (male)\", \"st\"),             P_(\"2 (male)\", \"nd\"),             P_(\"3 (male)\", \"rd\"),             P_(\"4 (male)\", \"th\"),             P_(\"5 (male)\", \"th\"),             P_(\"6 (male)\", \"th\"),             P_(\"7 (male)\", \"th\"),             P_(\"8 (male)\", \"th\"),             P_(\"9 (male)\", \"th\"),         )     else:         t = (             P_(\"0 (female)\", \"th\"),             P_(\"1 (female)\", \"st\"),             P_(\"2 (female)\", \"nd\"),             P_(\"3 (female)\", \"rd\"),             P_(\"4 (female)\", \"th\"),             P_(\"5 (female)\", \"th\"),             P_(\"6 (female)\", \"th\"),             P_(\"7 (female)\", \"th\"),             P_(\"8 (female)\", \"th\"),             P_(\"9 (female)\", \"th\"),         )     if value % 100 in (11, 12, 13):  # special case         return f\"{value}{t[0]}\"     return f\"{value}{t[value % 10]}\"\n2: def _ngettext(message, plural, num):     return get_translation().ngettext(message, plural, num)", "output": "0"}
{"task": "search", "input": "search code:\nReturns the inverse of a square matrix using NumPy.\n\nChoices:\n0: def invert_matrix(matrix: list[list[float]]) -> list[list[float]]:     np_matrix = np.array(matrix)      try:         inv_matrix = np.linalg.inv(np_matrix)     except np.linalg.LinAlgError:         raise ValueError(\"Matrix is not invertible\")      return inv_matrix.tolist()\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def area_square(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"area_square() only accepts non-negative values\")     return side_length**2", "output": "0"}
{"task": "detection", "input": "classify code:\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef binary_or(a: int, b: int) -> str:\n    if a < 0 or b < 0:\n        raise ValueError(\"the value of both inputs must be positive\")\n    a_binary = str(bin(a))[2:]  # remove the leading \"0b\"\n    b_binary = str(bin(b))[2:]\n    max_len = max(len(a_binary), len(b_binary))\n    return \"0b\" + \"\".join(\n        str(int(\"1\" in (char_a, char_b)))\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\n    )", "output": "Take in 2 integers, convert them to binary, and return a binary number that is the"}
{"task": "search", "input": "search code:\nCalculate the waiting time of each processes\n\nChoices:\n0: def calculate_waitingtime(     arrival_time: list[int], burst_time: list[int], no_of_processes: int ) -> list[int]:     remaining_time = [0] * no_of_processes     waiting_time = [0] * no_of_processes     # Copy the burst time into remaining_time[]     for i in range(no_of_processes):         remaining_time[i] = burst_time[i]      complete = 0     increment_time = 0     minm = 999999999     short = 0     check = False      # Process until all processes are completed     while complete != no_of_processes:         for j in range(no_of_processes):             if (                 arrival_time[j] <= increment_time                 and remaining_time[j] > 0                 and remaining_time[j] < minm             ):                 minm = remaining_time[j]                 short = j                 check = True          if not check:             increment_time += 1             continue         remaining_time[short] -= 1          minm = remaining_time[short]         if minm == 0:             minm = 999999999          if remaining_time[short] == 0:             complete += 1             check = False              # Find finish time of current process             finish_time = increment_time + 1              # Calculate waiting time             finar = finish_time - arrival_time[short]             waiting_time[short] = finar - burst_time[short]              waiting_time[short] = max(waiting_time[short], 0)          # Increment time         increment_time += 1     return waiting_time\n1: def local_weight(     point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float ) -> np.ndarray:     weight_mat = weight_matrix(point, x_train, tau)     weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (         x_train.T @ weight_mat @ y_train.T     )      return weight\n2: def ceil(x: float) -> int:     return int(x) if x - int(x) <= 0 else int(x) + 1", "output": "0"}
{"task": "search", "input": "search code:\nPerforms Run Length Encoding\n\nChoices:\n0: def vol_cube(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"vol_cube() only accepts non-negative values\")     return pow(side_length, 3)\n1: def with_iter(context_manager):     with context_manager as iterable:         yield from iterable\n2: def run_length_encode(text: str) -> list:     encoded = []     count = 1      for i in range(len(text)):         if i + 1 < len(text) and text[i] == text[i + 1]:             count += 1         else:             encoded.append((text[i], count))             count = 1      return encoded", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef binary_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return None", "output": "def binary_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1"}
{"task": "summary", "input": "summarize code:\ndef valid_input(\n    input_type: Callable[[object], num],  # Usually float or int\n    input_msg: str,\n    err_msg: str,\n    condition: Callable[[num], bool] = lambda _: True,\n    default: str | None = None,\n) -> num:\n    while True:\n        try:\n            user_input = input_type(input(input_msg).strip() or default)\n            if condition(user_input):\n                return user_input\n            else:\n                print(f\"{user_input}: {err_msg}\")\n                continue\n        except ValueError:\n            print(\n                f\"{user_input}: Incorrect input type, expected {input_type.__name__!r}\"\n            )", "output": "Ask for user value and validate that it fulfill a condition."}
{"task": "search", "input": "search code:\nCount the number of reversible numbers of given length.\n\nChoices:\n0: def slow_reversible_numbers(     remaining_length: int, remainder: int, digits: list[int], length: int ) -> int:     if remaining_length == 0:         if digits[0] == 0 or digits[-1] == 0:             return 0          for i in range(length // 2 - 1, -1, -1):             remainder += digits[i] + digits[length - i - 1]              if remainder % 2 == 0:                 return 0              remainder //= 10          return 1      if remaining_length == 1:         if remainder % 2 == 0:             return 0          result = 0         for digit in range(10):             digits[length // 2] = digit             result += slow_reversible_numbers(                 0, (remainder + 2 * digit) // 10, digits, length             )         return result      result = 0     for digit1 in range(10):         digits[(length + remaining_length) // 2 - 1] = digit1          if (remainder + digit1) % 2 == 0:             other_parity_digits = ODD_DIGITS         else:             other_parity_digits = EVEN_DIGITS          for digit2 in other_parity_digits:             digits[(length - remaining_length) // 2] = digit2             result += slow_reversible_numbers(                 remaining_length - 2,                 (remainder + digit1 + digit2) // 10,                 digits,                 length,             )     return result\n1: def euclidean(input_a: np.ndarray, input_b: np.ndarray) -> float:     return math.sqrt(sum(pow(a - b, 2) for a, b in zip(input_a, input_b)))\n2: def reverse_inorder(root: Node | None) -> Generator[int]:     if not root:         return     yield from reverse_inorder(root.right)     yield root.data     yield from reverse_inorder(root.left)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef find_unique_number(arr: list[int]) -> int:\n    if not arr:\n        raise ValueError(\"input list must not be empty\")\n    if not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"all elements must be integers\")\n\n    result = 0\n    for num in arr:\n        result ^= num\n    return result", "output": "Given a list of integers where every element appears twice except for one,"}
{"task": "summary", "input": "summarize code:\ndef join_mappings(**field_to_map):\n    ret = defaultdict(dict)\n\n    for field_name, mapping in field_to_map.items():\n        for key, value in mapping.items():\n            ret[key][field_name] = value\n\n    return dict(ret)", "output": "Joins multiple mappings together using their common keys."}
{"task": "summary", "input": "summarize code:\ndef rotate_file(filename, *, keep: int = 5):\n    if keep < 1:\n        raise ValueError(f'expected \"keep\" to be >=1, not {keep}')\n    if not os.path.exists(filename):\n        return\n    if not os.path.isfile(filename):\n        raise ValueError(f'expected {filename} to be a file')\n\n    fn_root, fn_ext = os.path.splitext(filename)\n    kept_names = []\n    for i in range(1, keep + 1):\n        if fn_ext:\n            kept_names.append(f'{fn_root}.{i}{fn_ext}')\n        else:\n            kept_names.append(f'{fn_root}.{i}')\n\n    fns = [filename] + kept_names\n    for orig_name, kept_name in reversed(list(zip(fns, fns[1:]))):\n        if not os.path.exists(orig_name):\n            continue\n        os.rename(orig_name, kept_name)\n\n    if os.path.exists(kept_names[-1]):\n        os.remove(kept_names[-1])\n\n    return", "output": "If *filename.ext* exists, it will be moved to *filename.1.ext*,"}
{"task": "search", "input": "search code:\nGenerates the next generation for a given state of Conway's Game of Life.\n\nChoices:\n0: def random_derangement(iterable):     seq = tuple(iterable)     if len(seq) < 2:         if len(seq) == 0:             return ()         raise IndexError('No derangments to choose from')     perm = list(range(len(seq)))     start = tuple(perm)     while True:         shuffle(perm)         if not any(map(is_, start, perm)):             return itemgetter(*perm)(seq)\n1: def intersection(function: Callable[[float], float], x0: float, x1: float) -> float:     x_n: float = x0     x_n1: float = x1     while True:         if x_n == x_n1 or function(x_n1) == function(x_n):             raise ZeroDivisionError(\"float division by zero, could not find root\")         x_n2: float = x_n1 - (             function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))         )         if abs(x_n2 - x_n1) < 10**-5:             return x_n2         x_n = x_n1         x_n1 = x_n2\n2: def new_generation(cells: list[list[int]]) -> list[list[int]]:     next_generation = []     for i in range(len(cells)):         next_generation_row = []         for j in range(len(cells[i])):             # Get the number of live neighbours             neighbour_count = 0             if i > 0 and j > 0:                 neighbour_count += cells[i - 1][j - 1]             if i > 0:                 neighbour_count += cells[i - 1][j]             if i > 0 and j < len(cells[i]) - 1:                 neighbour_count += cells[i - 1][j + 1]             if j > 0:                 neighbour_count += cells[i][j - 1]             if j < len(cells[i]) - 1:                 neighbour_count += cells[i][j + 1]             if i < len(cells) - 1 and j > 0:                 neighbour_count += cells[i + 1][j - 1]             if i < len(cells) - 1:                 neighbour_count += cells[i + 1][j]             if i < len(cells) - 1 and j < len(cells[i]) - 1:                 neighbour_count += cells[i + 1][j + 1]              # Rules of the game of life (excerpt from Wikipedia):             # 1. Any live cell with two or three live neighbours survives.             # 2. Any dead cell with three live neighbours becomes a live cell.             # 3. All other live cells die in the next generation.             #    Similarly, all other dead cells stay dead.             alive = cells[i][j] == 1             if (alive and 2 <= neighbour_count <= 3) or (                 not alive and neighbour_count == 3             ):                 next_generation_row.append(1)             else:                 next_generation_row.append(0)          next_generation.append(next_generation_row)     return next_generation", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef get_digits(num: int) -> str:\n    return \"\".join(sorted(str(num**3)))", "output": "Computes the sorted sequence of digits of the cube of num."}
{"task": "summary", "input": "summarize code:\ndef area_triangle(base: float, height: float) -> float:\n    if base < 0 or height < 0:\n        raise ValueError(\"area_triangle() only accepts non-negative values\")\n    return (base * height) / 2", "output": "Calculate the area of a triangle given the base and height."}
{"task": "detection", "input": "classify code:\ndef generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef is_operand(c):\n    return c.isdigit()", "output": "Return True if the given char c is an operand, e.g. it is a number"}
{"task": "search", "input": "search code:\nNormalizes a 1D array, between ranges 0-cap.\n\nChoices:\n0: def find_minimum_change(denominations: list[int], value: str) -> list[int]:     total_value = int(value)      # Initialize Result     answer = []      # Traverse through all denomination     for denomination in reversed(denominations):         # Find denominations         while int(total_value) >= int(denomination):             total_value -= int(denomination)             answer.append(denomination)  # Append the \"answers\" array      return answer\n1: def zero_vector(dimension: int) -> Vector:     # precondition     assert isinstance(dimension, int)     return Vector([0] * dimension)\n2: def normalize_array(array: np.ndarray, cap: float = 1) -> np.ndarray:     diff = np.max(array) - np.min(array)     return (array - np.min(array)) / (1 if diff == 0 else diff) * cap", "output": "2"}
{"task": "detection", "input": "classify code:\ndef longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn the largest 1 to 9 pandigital 9-digital number that can be formed as the\n\nChoices:\n0: def world_covid19_stats(     url: str = \"https://www.worldometers.info/coronavirus/\", ) -> dict:     soup = BeautifulSoup(         httpx.get(url, timeout=10, follow_redirects=True).text, \"html.parser\"     )     keys = soup.find_all(\"h1\")     values = soup.find_all(\"div\", {\"class\": \"maincounter-number\"})     keys += soup.find_all(\"span\", {\"class\": \"panel-title\"})     values += soup.find_all(\"div\", {\"class\": \"number-table-main\"})     return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}\n1: def solution() -> int | None:     for base_num in range(9999, 4999, -1):         candidate = 100002 * base_num         if is_9_pandigital(candidate):             return candidate      for base_num in range(333, 99, -1):         candidate = 1002003 * base_num         if is_9_pandigital(candidate):             return candidate      return None\n2: def get_forbes_real_time_billionaires() -> list[dict[str, int | str]]:     response_json = httpx.get(API_URL, timeout=10).json()     return [         {             \"Name\": person[\"personName\"],             \"Source\": person[\"source\"],             \"Country\": person[\"countryOfCitizenship\"],             \"Gender\": person[\"gender\"],             \"Worth ($)\": f\"{person['finalWorth'] / 1000:.1f} Billion\",             \"Age\": str(years_old(person[\"birthDate\"] / 1000)),         }         for person in response_json[\"personList\"][\"personsLists\"]     ]", "output": "1"}
{"task": "search", "input": "search code:\nDynamic programming matching algorithm.\n\nChoices:\n0: def dp_match(text: str, pattern: str) -> bool:     m = len(text)     n = len(pattern)     dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]     dp[0][0] = True      for j in range(1, n + 1):         dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]      for i in range(1, m + 1):         for j in range(1, n + 1):             if pattern[j - 1] in {\".\", text[i - 1]}:                 dp[i][j] = dp[i - 1][j - 1]             elif pattern[j - 1] == \"*\":                 dp[i][j] = dp[i][j - 2]                 if pattern[j - 2] in {\".\", text[i - 1]}:                     dp[i][j] |= dp[i - 1][j]             else:                 dp[i][j] = False      return dp[m][n]\n1: def move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:      new_list = []      for row in range(size):         if matrix_g[row][column] != \"-\":             new_list.append(matrix_g[row][column])         else:             new_list.insert(0, matrix_g[row][column])     for row in range(size):         matrix_g[row][column] = new_list[row]     return matrix_g\n2: def gaussian_elimination(     coefficients: NDArray[float64], vector: NDArray[float64] ) -> NDArray[float64]:     # coefficients must to be a square matrix so we need to check first     rows, columns = np.shape(coefficients)     if rows != columns:         return np.array((), dtype=float)      # augmented matrix     augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)     augmented_mat = augmented_mat.astype(\"float64\")      # scale the matrix leaving it triangular     for row in range(rows - 1):         pivot = augmented_mat[row, row]         for col in range(row + 1, columns):             factor = augmented_mat[col, row] / pivot             augmented_mat[col, :] -= factor * augmented_mat[row, :]      x = retroactive_resolution(         augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]     )      return x", "output": "0"}
{"task": "search", "input": "search code:\nGet the distance between a car (at index car_index) and the next car\n\nChoices:\n0: def solved(values):      def unitsolved(unit):         return {values[s] for s in unit} == set(digits)      return values is not False and all(unitsolved(unit) for unit in unitlist)\n1: def solution(ratio: float = 0.1) -> int:      j = 3     primes = 3      while primes / (2 * j - 1) >= ratio:         for i in range(j * j + j + 1, (j + 2) * (j + 2), j + 1):             primes += is_prime(i)         j += 2     return j\n2: def get_distance(highway_now: list, car_index: int) -> int:      distance = 0     cells = highway_now[car_index + 1 :]     for cell in range(len(cells)):  # May need a better name for this         if cells[cell] != -1:  # If the cell is not empty then             return distance  # we have the distance we wanted         distance += 1     # Here if the car is near the end of the highway     return distance + get_distance(highway_now, -1)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times", "output": "CORRECT"}
{"task": "search", "input": "search code:\nGet a string representation of the difference between two\n\nChoices:\n0: def _construct_hull(     points: list[Point], left: Point, right: Point, convex_set: set[Point] ) -> None:     if points:         extreme_point = None         extreme_point_distance = float(\"-inf\")         candidate_points = []          for p in points:             det = _det(left, right, p)              if det > 0:                 candidate_points.append(p)                  if det > extreme_point_distance:                     extreme_point_distance = det                     extreme_point = p          if extreme_point:             _construct_hull(candidate_points, left, extreme_point, convex_set)             convex_set.add(extreme_point)             _construct_hull(candidate_points, extreme_point, right, convex_set)\n1: def relative_time(d, other=None, ndigits=0):     drt, unit = decimal_relative_time(d, other, ndigits, cardinalize=True)     phrase = 'ago'     if drt < 0:         phrase = 'from now'     return f'{abs(drt):g} {unit} {phrase}'\n2: def inorder(root: Node | None) -> None:     if not root:  # None         return     else:         inorder(root.left)         print(root.value, end=\",\")         inorder(root.right)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef binary_tree_count(node_count: int) -> int:\n    return catalan_number(node_count) * factorial(node_count)", "output": "Return the number of possible of binary trees."}
{"task": "detection", "input": "classify code:\ndef pig_latin(word: str) -> str:\n    \"\"\"Compute the piglatin of a given string.\n\n    https://en.wikipedia.org/wiki/Pig_Latin\n\n    Usage examples:\n    >>> pig_latin(\"pig\")\n    'igpay'\n    >>> pig_latin(\"latin\")\n    'atinlay'\n    >>> pig_latin(\"banana\")\n    'ananabay'\n    >>> pig_latin(\"friends\")\n    'iendsfray'\n    >>> pig_latin(\"smile\")\n    'ilesmay'\n    >>> pig_latin(\"string\")\n    'ingstray'\n    >>> pig_latin(\"eat\")\n    'eatway'\n    >>> pig_latin(\"omelet\")\n    'omeletway'\n    >>> pig_latin(\"are\")\n    'areway'\n    >>> pig_latin(\" \")\n    ''\n    >>> pig_latin(None)\n    ''\n    \"\"\"\n    if not (word or \"\").strip():\n        return \"\"\n    word = word.lower()\n    if word[0] in \"aeiou\":\n        return f\"{word}way\"\n    for i, char in enumerate(word):  # noqa: B007\n        if char in \"aeiou\":\n            break\n    return f\"{word[i:]}{word[:i]}ay\"", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef real_power(apparent_power: float, power_factor: float) -> float:\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor", "output": "Calculate real power from apparent power and power factor."}
{"task": "search", "input": "search code:\nCalculate the score for a character pair based on whether they match or mismatch.\n\nChoices:\n0: def count_vowels(s: str) -> int:     if not isinstance(s, str):         raise ValueError(\"Input must be a string\")      vowels = \"aeiouAEIOU\"     return sum(1 for char in s if char in vowels)\n1: def score_function(     source_char: str,     target_char: str,     match: int = 1,     mismatch: int = -1,     gap: int = -2, ) -> int:     if \"-\" in (source_char, target_char):         return gap     return match if source_char == target_char else mismatch\n2: def solution():      return sum(         {             int(\"\".join(pandigital[5:9]))             for pandigital in itertools.permutations(\"123456789\")             if is_combination_valid(pandigital)         }     )", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef couloumbs_law(\n    force: float, charge1: float, charge2: float, distance: float\n) -> dict[str, float]:\n\n    charge_product = abs(charge1 * charge2)\n\n    if (force, charge1, charge2, distance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if distance < 0:\n        raise ValueError(\"Distance cannot be negative\")\n    if force == 0:\n        force = COULOMBS_CONSTANT * charge_product / (distance**2)\n        return {\"force\": force}\n    elif charge1 == 0:\n        charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)\n        return {\"charge1\": charge1}\n    elif charge2 == 0:\n        charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)\n        return {\"charge2\": charge2}\n    elif distance == 0:\n        distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5\n        return {\"distance\": distance}\n    raise ValueError(\"Exactly one argument must be 0\")", "output": "Apply Coulomb's Law on any three given values. These can be force, charge1,"}
{"task": "summary", "input": "summarize code:\ndef circle_bottom_arc_integral(point: float) -> float:\n\n    return (\n        (1 - 2 * point) * sqrt(point - point**2) + 2 * point + asin(sqrt(1 - point))\n    ) / 4", "output": "Returns integral of circle bottom arc y = 1 / 2 - sqrt(1 / 4 - (x - 1 / 2) ^ 2)"}
{"task": "summary", "input": "summarize code:\ndef groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):\n    ret = groupby(iterable, keyfunc)\n    if valuefunc:\n        ret = ((k, map(valuefunc, g)) for k, g in ret)\n    if reducefunc:\n        ret = ((k, reducefunc(g)) for k, g in ret)\n\n    return ret", "output": "An extension of :func:`itertools.groupby` that can apply transformations"}
{"task": "search", "input": "search code:\nPerform bitwise NOT on given int.\n\nChoices:\n0: def not_32(i: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")      i_str = format(i, \"032b\")     new_str = \"\"     for c in i_str:         new_str += \"1\" if c == \"0\" else \"0\"     return int(new_str, 2)\n1: def term_frequency(term: str, document: str) -> int:     # strip all punctuation and newlines and replace it with ''     document_without_punctuation = document.translate(         str.maketrans(\"\", \"\", string.punctuation)     ).replace(\"\\n\", \"\")     tokenize_document = document_without_punctuation.split(\" \")  # word tokenization     return len([word for word in tokenize_document if word.lower() == term.lower()])\n2: def time_func(func, *args, **kwargs):     start = time()     output = func(*args, **kwargs)     end = time()     if int(end - start) > 0:         print(f\"{func.__name__} runtime: {(end - start):0.4f} s\")     else:         print(f\"{func.__name__} runtime: {(end - start) * 1000:0.4f} ms\")     return output", "output": "0"}
{"task": "detection", "input": "classify code:\ndef left_shift(data):\n    \"\"\"\n    >>> left_shift(\"0123456789\")\n    '1234567890'\n    \"\"\"\n    return data[1:] + data[0]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nRuns core process to find problem solution.\n\nChoices:\n0: def calculate_average_waiting_time(waiting_times: list[int]) -> float:     return sum(waiting_times) / len(waiting_times)\n1: def sentence_to_title_case(input_str: str) -> str:      return \" \".join(to_title_case(word) for word in input_str.split())\n2: def run(n: int) -> list[int]:      # Incrementor variable for our group list comprehension.     # This is the first number in each list of values     # to test.     base = 2      while True:         # Increment each value of a generated range         group = [base + i for i in range(n)]          # Run elements through the unique_prime_factors function         # Append our target number to the end.         checker = [upf_len(x) for x in group]         checker.append(n)          # If all numbers in the list are equal, return the group variable.         if equality(checker):             return group          # Increment our base variable by 1         base += 1", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef next_number(number: int) -> int:\n\n    sum_of_digits_squared = 0\n    while number:\n        # Increased Speed Slightly by checking every 5 digits together.\n        sum_of_digits_squared += DIGITS_SQUARED[number % 100000]\n        number //= 100000\n\n    return sum_of_digits_squared", "output": "Returns the next number of the chain by adding the square of each digit"}
{"task": "repair", "input": "fix bug:\ndef encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]", "output": "def encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]"}
{"task": "search", "input": "search code:\nReturns unique prime factors of n as a list.\n\nChoices:\n0: def accuracy(actual_y: list, predicted_y: list) -> float:     # iterate over one element of each list at a time (zip mode)     # prediction is correct if actual Y value equals to predicted Y value     correct = sum(1 for i, j in zip(actual_y, predicted_y) if i == j)     # percentage of accuracy equals to number of correct predictions divided by number     # of all data and multiplied by 100     return (correct / len(actual_y)) * 100\n1: def interquartile_range_checker(train_user: list) -> float:     train_user.sort()     q1 = np.percentile(train_user, 25)     q3 = np.percentile(train_user, 75)     iqr = q3 - q1     low_lim = q1 - (iqr * 0.1)     return float(low_lim)\n2: def unique_prime_factors(n: int) -> list[int]:     i = 2     factors = []     while i * i <= n:         if not n % i:             while not n % i:                 n //= i             factors.append(i)         i += 1     if n > 1:         factors.append(n)     return factors", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef ordinalize(number, ext_only=False):\n    numstr, ext = str(number), ''\n    if numstr and numstr[-1] in string.digits:\n        try:\n            # first check for teens\n            if numstr[-2] == '1':\n                ext = 'th'\n            else:\n                # all other cases\n                ext = _ORDINAL_MAP.get(numstr[-1], 'th')\n        except IndexError:\n            # single digit numbers (will reach here based on [-2] above)\n            ext = _ORDINAL_MAP.get(numstr[-1], 'th')\n    if ext_only:\n        return ext\n    else:\n        return numstr + ext", "output": "Turns *number* into its cardinal form, i.e., 1st, 2nd,"}
{"task": "summary", "input": "summarize code:\ndef sum_digits(num: int) -> int:\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum", "output": "Returns the sum of every digit in num."}
{"task": "search", "input": "search code:\nSolves the maximum subarray sum problem using Kadane's algorithm.\n\nChoices:\n0: def norm_squared(vector: ndarray) -> float:     return np.dot(vector, vector)\n1: def max_subarray_sum(     arr: Sequence[float], allow_empty_subarrays: bool = False ) -> float:     if not arr:         return 0      max_sum = 0 if allow_empty_subarrays else float(\"-inf\")     curr_sum = 0.0     for num in arr:         curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)         max_sum = max(max_sum, curr_sum)      return max_sum\n2: def solution(n: int = 1000) -> int:      return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)", "output": "1"}
{"task": "search", "input": "search code:\nEvaluate each item from *iterable* using *pred*. If the result is\n\nChoices:\n0: def map_if(iterable, pred, func, func_else=None):      if func_else is None:         for item in iterable:             yield func(item) if pred(item) else item      else:         for item in iterable:             yield func(item) if pred(item) else func_else(item)\n1: def indian_phone_validator(phone: str) -> bool:     pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")     if match := re.search(pat, phone):         return match.string == phone     return False\n2: def bell_numbers(max_set_length: int) -> list[int]:     if max_set_length < 0:         raise ValueError(\"max_set_length must be non-negative\")      bell = [0] * (max_set_length + 1)     bell[0] = 1      for i in range(1, max_set_length + 1):         for j in range(i):             bell[i] += _binomial_coefficient(i - 1, j) * bell[j]      return bell", "output": "0"}
{"task": "search", "input": "search code:\nReturns the last digit of barcode by excluding the last digit first\n\nChoices:\n0: def binary_exp_iterative(base: float, exponent: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res *= base          base *= base         exponent >>= 1      return res\n1: def solution(n: int = 1000) -> int:      return sum(e for e in range(3, n) if e % 3 == 0 or e % 5 == 0)\n2: def get_check_digit(barcode: int) -> int:     barcode //= 10  # exclude the last digit     checker = False     s = 0      # extract and check each digit     while barcode != 0:         mult = 1 if checker else 3         s += mult * (barcode % 10)         barcode //= 10         checker = not checker      return (10 - (s % 10)) % 10", "output": "2"}
{"task": "search", "input": "search code:\nGo through the number of iterations determined by the argument \"steps\".\n\nChoices:\n0: def circle_sort(collection: list) -> list:      if len(collection) < 2:         return collection      def circle_sort_util(collection: list, low: int, high: int) -> bool:          swapped = False          if low == high:             return swapped          left = low         right = high          while left < right:             if collection[left] > collection[right]:                 collection[left], collection[right] = (                     collection[right],                     collection[left],                 )                 swapped = True              left += 1             right -= 1          if left == right and collection[left] > collection[right + 1]:             collection[left], collection[right + 1] = (                 collection[right + 1],                 collection[left],             )              swapped = True          mid = low + int((high - low) / 2)         left_swap = circle_sort_util(collection, low, mid)         right_swap = circle_sort_util(collection, mid + 1, high)          return swapped or left_swap or right_swap      is_not_sorted = True      while is_not_sorted is True:         is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)      return collection\n1: def iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:     vectors = initial_vectors     for _ in range(steps):         vectors = iteration_step(vectors)     return vectors\n2: def eval_exponential(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:     return np.exp(z_values) + c_parameter", "output": "1"}
{"task": "search", "input": "search code:\nExamples(rounded for precision):\n\nChoices:\n0: def nth_prime(n, *, approximate=False):     lb, ub = _nth_prime_bounds(n + 1)      if not approximate or n <= 1_000_000:         return nth(sieve(ceil(ub)), n)      # Search from the midpoint and return the first odd prime     odd = floor((lb + ub) / 2) | 1     return first_true(count(odd, step=2), pred=is_prime)\n1: def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:     r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]     return 0.2989 * r + 0.5870 * g + 0.1140 * b\n2: def rmse(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     square_diff = np.square(difference)     mean_square_diff = square_diff.mean()     score = np.sqrt(mean_square_diff)     return score", "output": "2"}
{"task": "detection", "input": "classify code:\ndef newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    Calculates force from `mass` and `acceleration`\n\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force", "output": "BUGGY"}
{"task": "search", "input": "search code:\nRecursive Backtracking Depth First Search Algorithm\n\nChoices:\n0: def height(root: Node | None) -> int:     return (max(height(root.left), height(root.right)) + 1) if root else 0\n1: def depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:     row_length, col_length = len(grid), len(grid[0])     if (         min(row, col) < 0         or row == row_length         or col == col_length         or (row, col) in visit         or grid[row][col] == 1     ):         return 0     if row == row_length - 1 and col == col_length - 1:         return 1      visit.add((row, col))      count = 0     count += depth_first_search(grid, row + 1, col, visit)     count += depth_first_search(grid, row - 1, col, visit)     count += depth_first_search(grid, row, col + 1, visit)     count += depth_first_search(grid, row, col - 1, visit)      visit.remove((row, col))     return count\n2: def _partition(data: list, pivot) -> tuple:     less, equal, greater = [], [], []     for element in data:         if element < pivot:             less.append(element)         elif element > pivot:             greater.append(element)         else:             equal.append(element)     return less, equal, greater", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    f1, f2 = 1, 1\n    index = 2\n    while True:\n        i = 0\n        f = f1 + f2\n        f1, f2 = f2, f\n        index += 1\n        for _ in str(f):\n            i += 1\n        if i == n:\n            break\n    return index", "output": "Returns the index of the first term in the Fibonacci sequence to contain"}
{"task": "search", "input": "search code:\nYields elements in order, ignoring serial duplicates\n\nChoices:\n0: def solution() -> int:     return sum(compute_truncated_primes(11))\n1: def solution(num_turns: int = 15) -> int:     total_prob: float = 0.0     prob: float     num_blue: int     num_red: int     ind: int     col: int     series: tuple[int, ...]      for series in product(range(2), repeat=num_turns):         num_blue = series.count(1)         num_red = num_turns - num_blue         if num_red >= num_blue:             continue         prob = 1.0         for ind, col in enumerate(series, 2):             if col == 0:                 prob *= (ind - 1) / ind             else:                 prob *= 1 / ind          total_prob += prob      return int(1 / total_prob)\n2: def unique_justseen(iterable, key=None):     if key is None:         return map(itemgetter(0), groupby(iterable))      return map(next, map(itemgetter(1), groupby(iterable, key)))", "output": "2"}
{"task": "search", "input": "search code:\nReturn a shell-escaped string version of *args*, separated by\n\nChoices:\n0: def args2cmd(args, sep=' '):     # technique description from subprocess below     result = []     needquote = False     for arg in args:         bs_buf = []          # Add a space to separate this argument from the others         if result:             result.append(' ')          needquote = (\" \" in arg) or (\"\\t\" in arg) or not arg         if needquote:             result.append('\"')          for c in arg:             if c == '\\\\':                 # Don't know if we need to double yet.                 bs_buf.append(c)             elif c == '\"':                 # Double backslashes.                 result.append('\\\\' * len(bs_buf)*2)                 bs_buf = []                 result.append('\\\\\"')             else:                 # Normal char                 if bs_buf:                     result.extend(bs_buf)                     bs_buf = []                 result.append(c)          # Add remaining backslashes, if any.         if bs_buf:             result.extend(bs_buf)          if needquote:             result.extend(bs_buf)             result.append('\"')      return ''.join(result)\n1: def max_sum_in_array(array: list[int], k: int) -> int:     if len(array) < k or k < 0:         raise ValueError(\"Invalid Input\")     max_sum = current_sum = sum(array[:k])     for i in range(len(array) - k):         current_sum = current_sum - array[i] + array[i + k]         max_sum = max(max_sum, current_sum)     return max_sum\n2: def validate_initial_digits(credit_card_number: str) -> bool:     return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(start: int = 144) -> int:\n    n = start\n    num = hexagonal_num(n)\n    while not is_pentagonal(num):\n        n += 1\n        num = hexagonal_num(n)\n    return num", "output": "Returns the next number which is triangular, pentagonal and hexagonal."}
{"task": "summary", "input": "summarize code:\ndef eval_exponential(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:\n    return np.exp(z_values) + c_parameter", "output": "Evaluate $e^z + c$."}
{"task": "summary", "input": "summarize code:\ndef solution(n_limit: int = 50 * 10**6) -> int:\n    n_sol = [0] * n_limit\n\n    for delta in range(1, (n_limit + 1) // 4 + 1):\n        for y in range(4 * delta - 1, delta, -1):\n            n = y * (4 * delta - y)\n            if n >= n_limit:\n                break\n            n_sol[n] += 1\n\n    ans = 0\n    for i in range(n_limit):\n        if n_sol[i] == 1:\n            ans += 1\n\n    return ans", "output": "Define n count list and loop over delta, y to get the counts, then check"}
{"task": "search", "input": "search code:\nLet's benchmark our functions side-by-side...\n\nChoices:\n0: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n1: def main() -> None:     data_x, _data_y = collect_dataset()      # Number of principal components to retain     n_components = 2      # Apply PCA     transformed_data, variance_ratio = apply_pca(data_x, n_components)      print(\"Transformed Dataset (First 5 rows):\")     print(transformed_data[:5])      print(\"\\nExplained Variance Ratio:\")     print(variance_ratio)\n2: def benchmark():     from timeit import timeit      setup = \"from __main__ import slow_primes, primes, fast_primes\"     print(timeit(\"slow_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))     print(timeit(\"primes(1_000_000_000_000)\", setup=setup, number=1_000_000))     print(timeit(\"fast_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))", "output": "2"}
{"task": "search", "input": "search code:\nCalculate the filter points and frequencies for mel frequency filters.\n\nChoices:\n0: def get_filter_points(     sample_rate: int,     freq_min: int,     freq_high: int,     mel_filter_num: int = 10,     ftt_size: int = 1024, ) -> tuple[np.ndarray, np.ndarray]:     # Convert minimum and maximum frequencies to mel scale     fmin_mel = freq_to_mel(freq_min)     fmax_mel = freq_to_mel(freq_high)      logging.info(f\"MEL min: {fmin_mel}\")     logging.info(f\"MEL max: {fmax_mel}\")      # Generate equally spaced mel frequencies     mels = np.linspace(fmin_mel, fmax_mel, num=mel_filter_num + 2)      # Convert mel frequencies back to Hertz     freqs = mel_to_freq(mels)      # Calculate filter points as integer values     filter_points = np.floor((ftt_size + 1) / sample_rate * freqs).astype(int)      return filter_points, freqs\n1: def groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):     ret = groupby(iterable, keyfunc)     if valuefunc:         ret = ((k, map(valuefunc, g)) for k, g in ret)     if reducefunc:         ret = ((k, reducefunc(g)) for k, g in ret)      return ret\n2: def collect_dataset() -> tuple[ndarray, ndarray]:     iris_dataset = load_iris()     return np.array(iris_dataset.data), np.array(iris_dataset.target)", "output": "0"}
{"task": "search", "input": "search code:\nReturns a list of frequent itemsets and their support counts.\n\nChoices:\n0: def summation_of_cost_derivative(index, end=m):     summation_value = 0     for i in range(end):         if index == -1:             summation_value += _error(i)         else:             summation_value += _error(i) * train_data[i][0][index]     return summation_value\n1: def max_subarray(     arr: Sequence[float], low: int, high: int ) -> tuple[int | None, int | None, float]:     if not arr:         return None, None, 0     if low == high:         return low, high, arr[low]      mid = (low + high) // 2     left_low, left_high, left_sum = max_subarray(arr, low, mid)     right_low, right_high, right_sum = max_subarray(arr, mid + 1, high)     cross_left, cross_right, cross_sum = max_cross_sum(arr, low, mid, high)     if left_sum >= right_sum and left_sum >= cross_sum:         return left_low, left_high, left_sum     elif right_sum >= left_sum and right_sum >= cross_sum:         return right_low, right_high, right_sum     return cross_left, cross_right, cross_sum\n2: def apriori(data: list[list[str]], min_support: int) -> list[tuple[list[str], int]]:     itemset = [list(transaction) for transaction in data]     frequent_itemsets = []     length = 1      while itemset:         # Count itemset support         counts = [0] * len(itemset)         for transaction in data:             for j, candidate in enumerate(itemset):                 if all(item in transaction for item in candidate):                     counts[j] += 1          # Prune infrequent itemsets         itemset = [item for i, item in enumerate(itemset) if counts[i] >= min_support]          # Append frequent itemsets (as a list to maintain order)         for i, item in enumerate(itemset):             frequent_itemsets.append((sorted(item), counts[i]))          length += 1         itemset = prune(itemset, list(combinations(itemset, length)), length)      return frequent_itemsets", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef get_factors(\n    number: int, factors: Counter | None = None, factor: int = 2\n) -> Counter:\n\n    match number:\n        case int(number) if number == 1:\n            return Counter({1: 1})\n        case int(num) if number > 0:\n            number = num\n        case _:\n            raise TypeError(\"number must be integer and greater than zero\")\n\n    factors = factors or Counter()\n\n    if number == factor:  # break condition\n        # all numbers are factors of itself\n        factors[factor] += 1\n        return factors\n\n    if number % factor > 0:\n        # if it is greater than zero\n        # so it is not a factor of number and we check next number\n        return get_factors(number, factors, factor + 1)\n\n    factors[factor] += 1\n    # else we update factors (that is Counter(dict-like) type) and check again\n    return get_factors(number // factor, factors, factor)", "output": "this is a recursive function for get all factors of number"}
{"task": "search", "input": "search code:\nConvert an IPv4 address to its decimal representation.\n\nChoices:\n0: def ipv4_to_decimal(ipv4_address: str) -> int:      octets = [int(octet) for octet in ipv4_address.split(\".\")]     if len(octets) != 4:         raise ValueError(\"Invalid IPv4 address format\")      decimal_ipv4 = 0     for octet in octets:         if not 0 <= octet <= 255:             raise ValueError(f\"Invalid IPv4 octet {octet}\")  # noqa: EM102         decimal_ipv4 = (decimal_ipv4 << 8) + int(octet)      return decimal_ipv4\n1: def compute_nums(n: int) -> list[int]:     if not isinstance(n, int):         raise ValueError(\"n must be an integer\")     if n <= 0:         raise ValueError(\"n must be >= 0\")      list_nums = []     for num in range(len(odd_composites)):         i = 0         while 2 * i * i <= odd_composites[num]:             rem = odd_composites[num] - 2 * i * i             if is_prime(rem):                 break             i += 1         else:             list_nums.append(odd_composites[num])             if len(list_nums) == n:                 return list_nums      return []\n2: def triangle(     vertex1: tuple[float, float],     vertex2: tuple[float, float],     vertex3: tuple[float, float],     depth: int, ) -> None:     my_pen.up()     my_pen.goto(vertex1[0], vertex1[1])     my_pen.down()     my_pen.goto(vertex2[0], vertex2[1])     my_pen.goto(vertex3[0], vertex3[1])     my_pen.goto(vertex1[0], vertex1[1])      if depth == 0:         return      triangle(vertex1, get_mid(vertex1, vertex2), get_mid(vertex1, vertex3), depth - 1)     triangle(vertex2, get_mid(vertex1, vertex2), get_mid(vertex2, vertex3), depth - 1)     triangle(vertex3, get_mid(vertex3, vertex2), get_mid(vertex1, vertex3), depth - 1)", "output": "0"}
{"task": "search", "input": "search code:\n2 1\n\nChoices:\n0: def even_tree():     dfs(1)\n1: def armstrong_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False      # Initialization of sum and number of digits.     total = 0     number_of_digits = 0     temp = n     # Calculation of digits of the number     number_of_digits = len(str(n))     # Dividing number into separate digits and find Armstrong number     temp = n     while temp > 0:         rem = temp % 10         total += rem**number_of_digits         temp //= 10     return n == total\n2: def _suppress_lower_units(min_unit, suppress):     suppress = set(suppress)     for u in Unit:         if u == min_unit:             break         suppress.add(u)      return suppress", "output": "0"}
{"task": "detection", "input": "classify code:\ndef is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef res(x, y):\n    if 0 not in (x, y):\n        # We use the relation x^y = y*log10(x), where 10 is the base.\n        return y * math.log10(x)\n    elif x == 0:  # 0 raised to any number is 0\n        return 0\n    elif y == 0:\n        return 1  # any number raised to 0 is 1\n    raise AssertionError(\"This should never happen\")", "output": "Reduces large number to a more manageable number"}
{"task": "summary", "input": "summarize code:\ndef sort(array: list) -> list:\n    if len(array) == 0:\n        return array\n    max_depth = 2 * math.ceil(math.log2(len(array)))\n    size_threshold = 16\n    return intro_sort(array, 0, len(array), size_threshold, max_depth)", "output": "comparable items inside"}
{"task": "detection", "input": "classify code:\ndef column_based_sort(array, column=0):\n    \"\"\"\n    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\n    [(3, 0), (5, 1), (4, 2)]\n    \"\"\"\n    return sorted(array, key=lambda x: x[column])", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef decimal_to_binary(no_of_variable: int, minterms: List[float]) -> List[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    s = \"\"\n    for m in minterms:\n        for i in range(no_of_variable):\n            s = str(m % 2) + s\n            m //= 2\n        temp.append(s)\n        s = \"\"\n    return temp", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef analyze_text(text: str) -> tuple[dict, dict]:\n    single_char_strings = Counter()  # type: ignore[var-annotated]\n    two_char_strings = Counter()  # type: ignore[var-annotated]\n    single_char_strings[text[-1]] += 1\n\n    # first case when we have space at start.\n    two_char_strings[\" \" + text[0]] += 1\n    for i in range(len(text) - 1):\n        single_char_strings[text[i]] += 1\n        two_char_strings[text[i : i + 2]] += 1\n    return single_char_strings, two_char_strings", "output": "Convert text input into two dicts of counts."}
{"task": "summary", "input": "summarize code:\ndef strip(iterable, pred):\n    return rstrip(lstrip(iterable, pred), pred)", "output": "Yield the items from *iterable*, but strip any from the"}
{"task": "search", "input": "search code:\nFinds the jaccard similarity between two sets.\n\nChoices:\n0: def solution(n: int = 600851475143) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     prime = 1     i = 2     while i * i <= n:         while n % i == 0:             prime = i             n //= i         i += 1     if n > 1:         prime = n     return int(prime)\n1: def sum_of_digit_factorial(n: int) -> int:     return sum(DIGIT_FACTORIAL[d] for d in str(n))\n2: def jaccard_similarity(     set_a: set[str] | list[str] | tuple[str],     set_b: set[str] | list[str] | tuple[str],     alternative_union=False, ):      if isinstance(set_a, set) and isinstance(set_b, set):         intersection_length = len(set_a.intersection(set_b))          if alternative_union:             union_length = len(set_a) + len(set_b)         else:             union_length = len(set_a.union(set_b))          return intersection_length / union_length      elif isinstance(set_a, (list, tuple)) and isinstance(set_b, (list, tuple)):         intersection = [element for element in set_a if element in set_b]          if alternative_union:             return len(intersection) / (len(set_a) + len(set_b))         else:             # Cast set_a to list because tuples cannot be mutated             union = list(set_a) + [element for element in set_b if element not in set_a]             return len(intersection) / len(union)     raise ValueError(         \"Set a and b must either both be sets or be either a list or a tuple.\"     )", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef polynomial_derivative(coefficients):\n    n = len(coefficients)\n    powers = reversed(range(1, n))\n    return list(map(mul, coefficients, powers))", "output": "Compute the first derivative of a polynomial."}
{"task": "summary", "input": "summarize code:\ndef get_band_type_count(total_number_of_bands: int, type_of_band: str) -> int:\n    if total_number_of_bands not in band_types:\n        msg = f\"{total_number_of_bands} is not a valid number of bands\"\n        raise ValueError(msg)\n    if type_of_band not in band_types[total_number_of_bands]:\n        msg = f\"{type_of_band} is not valid for a {total_number_of_bands} band resistor\"\n        raise ValueError(msg)\n    return band_types[total_number_of_bands][type_of_band]", "output": "Function returns the number of bands of a given type in a resistor with n bands"}
{"task": "repair", "input": "fix bug:\ndef stalin_sort(sequence: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Stalin sort algorithm.\n\n    >>> stalin_sort([4, 3, 5, 2, 1, 7])\n    [4, 5, 7]\n\n    >>> stalin_sort([1, 2, 3, 4])\n    [1, 2, 3, 4]\n\n    >>> stalin_sort([4, 5, 5, 2, 3])\n    [4, 5, 5]\n\n    >>> stalin_sort([6, 11, 12, 4, 1, 5])\n    [6, 11, 12]\n\n    >>> stalin_sort([5, 0, 4, 3])\n    [5]\n\n    >>> stalin_sort([5, 4, 3, 2, 1])\n    [5]\n\n    >>> stalin_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> stalin_sort([1, 2, 8, 7, 6])\n    [1, 2, 8]\n    \"\"\"\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result", "output": "def stalin_sort(sequence: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Stalin sort algorithm.\n\n    >>> stalin_sort([4, 3, 5, 2, 1, 7])\n    [4, 5, 7]\n\n    >>> stalin_sort([1, 2, 3, 4])\n    [1, 2, 3, 4]\n\n    >>> stalin_sort([4, 5, 5, 2, 3])\n    [4, 5, 5]\n\n    >>> stalin_sort([6, 11, 12, 4, 1, 5])\n    [6, 11, 12]\n\n    >>> stalin_sort([5, 0, 4, 3])\n    [5]\n\n    >>> stalin_sort([5, 4, 3, 2, 1])\n    [5]\n\n    >>> stalin_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> stalin_sort([1, 2, 8, 7, 6])\n    [1, 2, 8]\n    \"\"\"\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result"}
{"task": "search", "input": "search code:\nCheck if a number is a perfect cube or not.\n\nChoices:\n0: def perfect_cube(n: int) -> bool:     val = n ** (1 / 3)     return (val * val * val) == n\n1: def main() -> None:      # unittest.main()      import doctest      doctest.testmod()      parser = argparse.ArgumentParser()     parser.add_argument(         \"-s\",         \"--string\",         dest=\"input_string\",         default=\"Hello World!! Welcome to Cryptography\",         help=\"Hash the string\",     )     parser.add_argument(         \"-f\", \"--file\", dest=\"input_file\", help=\"Hash contents of a file\"     )      args = parser.parse_args()      input_string = args.input_string      # hash input should be a bytestring     if args.input_file:         with open(args.input_file, \"rb\") as f:             hash_input = f.read()     else:         hash_input = bytes(input_string, \"utf-8\")      print(SHA256(hash_input).hash)\n2: def speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:      if density <= 0:         raise ValueError(\"Impossible fluid density\")     if bulk_modulus <= 0:         raise ValueError(\"Impossible bulk modulus\")      return (bulk_modulus / density) ** 0.5", "output": "0"}
{"task": "detection", "input": "classify code:\ndef calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef insert(root: Node | None, value: int) -> Node | None:\n    node = Node(value)\n    left, right = split(root, value)\n    return merge(merge(left, node), right)", "output": "Insert element"}
{"task": "search", "input": "search code:\nYield the items from *iterable*, but strip any from the\n\nChoices:\n0: def solution(nth: int = 10001) -> int:     return next(itertools.islice(prime_generator(), nth - 1, nth))\n1: def strip(iterable, pred):     return rstrip(lstrip(iterable, pred), pred)\n2: def solution(n: int = 1000000) -> int:     largest_number = 1     pre_counter = 1     counters = {1: 1}      for input1 in range(2, n):         counter = 0         number = input1          while True:             if number in counters:                 counter += counters[number]                 break             if number % 2 == 0:                 number //= 2                 counter += 1             else:                 number = (3 * number) + 1                 counter += 1          if input1 not in counters:             counters[input1] = counter          if counter > pre_counter:             largest_number = input1             pre_counter = counter     return largest_number", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef binary_tree_right_side_view(root: TreeNode) -> list[int]:\n\n    def depth_first_search(\n        root: TreeNode | None, depth: int, right_view: list[int]\n    ) -> None:\n        if not root:\n            return\n\n        if depth == len(right_view):\n            right_view.append(root.val)\n\n        depth_first_search(root.right, depth + 1, right_view)\n        depth_first_search(root.left, depth + 1, right_view)\n\n    right_view: list = []\n    if not root:\n        return right_view\n\n    depth_first_search(root, 0, right_view)\n    return right_view", "output": "Function returns the right side view of binary tree."}
{"task": "summary", "input": "summarize code:\ndef gray_code_sequence_string(bit_count: int) -> list:\n\n    # The approach is a recursive one\n    # Base case achieved when either n = 0 or n=1\n    if bit_count == 0:\n        return [\"0\"]\n\n    if bit_count == 1:\n        return [\"0\", \"1\"]\n\n    seq_len = 1 << bit_count  # defines the length of the sequence\n    # 1<< n is equivalent to 2^n\n\n    # recursive answer will generate answer for n-1 bits\n    smaller_sequence = gray_code_sequence_string(bit_count - 1)\n\n    sequence = []\n\n    # append 0 to first half of the smaller sequence generated\n    for i in range(seq_len // 2):\n        generated_no = \"0\" + smaller_sequence[i]\n        sequence.append(generated_no)\n\n    # append 1 to second half ... start from the end of the list\n    for i in reversed(range(seq_len // 2)):\n        generated_no = \"1\" + smaller_sequence[i]\n        sequence.append(generated_no)\n\n    return sequence", "output": "Will output the n-bit grey sequence as a"}
{"task": "summary", "input": "summarize code:\ndef copy_function(orig, copy_dict=True):\n    ret = FunctionType(orig.__code__,\n                       orig.__globals__,\n                       name=orig.__name__,\n                       argdefs=getattr(orig, \"__defaults__\", None),\n                       closure=getattr(orig, \"__closure__\", None))\n    if hasattr(orig, \"__kwdefaults__\"):\n        ret.__kwdefaults__ = orig.__kwdefaults__\n    if copy_dict:\n        ret.__dict__.update(orig.__dict__)\n    return ret", "output": "Returns a shallow copy of the function, including code object,"}
{"task": "repair", "input": "fix bug:\ndef elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_", "output": "def elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_"}
{"task": "search", "input": "search code:\nReturn some element of seq that is true.\n\nChoices:\n0: def collect_dataset():     response = httpx.get(         \"https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/\"         \"master/Week1/ADRvsRating.csv\",         timeout=10,     )     lines = response.text.splitlines()     data = []     for item in lines:         item = item.split(\",\")         data.append(item)     data.pop(0)  # This is for removing the labels from the list     dataset = np.matrix(data)     return dataset\n1: def some(seq):     for e in seq:         if e:             return e     return False\n2: def heapify(unsorted: list[int], index: int, heap_size: int) -> None:     largest = index     left_index = 2 * index + 1     right_index = 2 * index + 2     if left_index < heap_size and unsorted[left_index] > unsorted[largest]:         largest = left_index      if right_index < heap_size and unsorted[right_index] > unsorted[largest]:         largest = right_index      if largest != index:         unsorted[largest], unsorted[index] = (unsorted[index], unsorted[largest])         heapify(unsorted, largest, heap_size)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef format_nonexp_repr(obj, req_names=None, opt_names=None, opt_key=None):\n    cn = obj.__class__.__name__\n    req_names = req_names or []\n    opt_names = opt_names or []\n    uniq_names, all_names = set(), []\n    for name in req_names + opt_names:\n        if name in uniq_names:\n            continue\n        uniq_names.add(name)\n        all_names.append(name)\n\n    if opt_key is None:\n        opt_key = lambda v: v is None\n    assert callable(opt_key)\n\n    items = [(name, getattr(obj, name, None)) for name in all_names]\n    labels = [f'{name}={val!r}' for name, val in items\n              if not (name in opt_names and opt_key(val))]\n    if not labels:\n        labels = ['id=%s' % id(obj)]\n    ret = '<{} {}>'.format(cn, ' '.join(labels))\n    return ret", "output": "Format a non-expression-style repr"}
{"task": "search", "input": "search code:\nPure Python implementation of Geometric Series algorithm\n\nChoices:\n0: def geometric_series(     nth_term: float,     start_term_a: float,     common_ratio_r: float, ) -> list[float]:     if not all((nth_term, start_term_a, common_ratio_r)):         return []     series: list[float] = []     power = 1     multiple = common_ratio_r     for _ in range(int(nth_term)):         if not series:             series.append(start_term_a)         else:             power += 1             series.append(float(start_term_a * multiple))             multiple = pow(float(common_ratio_r), power)     return series\n1: def charging_inductor(     source_voltage: float,  # source_voltage should be in volts.     resistance: float,  # resistance should be in ohms.     inductance: float,  # inductance should be in henrys.     time: float,  # time should in seconds. ) -> float:      if source_voltage <= 0:         raise ValueError(\"Source voltage must be positive.\")     if resistance <= 0:         raise ValueError(\"Resistance must be positive.\")     if inductance <= 0:         raise ValueError(\"Inductance must be positive.\")     return round(         source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3     )\n2: def calculate_prime_numbers(max_number: int) -> list[int]:      is_prime = [True] * max_number     for i in range(2, isqrt(max_number - 1) + 1):         if is_prime[i]:             for j in range(i**2, max_number, i):                 is_prime[j] = False      return [i for i in range(2, max_number) if is_prime[i]]", "output": "0"}
{"task": "search", "input": "search code:\nCheck if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n\nChoices:\n0: def solution(n: int = 1000) -> int:     prev_numerator, prev_denominator = 1, 1     result = []     for i in range(1, n + 1):         numerator = prev_numerator + 2 * prev_denominator         denominator = prev_numerator + prev_denominator         if len(str(numerator)) > len(str(denominator)):             result.append(i)         prev_numerator = numerator         prev_denominator = denominator      return len(result)\n1: def is_right(x1: int, y1: int, x2: int, y2: int) -> bool:     if x1 == y1 == 0 or x2 == y2 == 0:         return False     a_square = x1 * x1 + y1 * y1     b_square = x2 * x2 + y2 * y2     c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)     return (         a_square + b_square == c_square         or a_square + c_square == b_square         or b_square + c_square == a_square     )\n2: def netstring_server(server_socket):     \"A basic netstring server loop, supporting a few operations\"     try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock)             while 1:                 request = client.read_ns()                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'reply4k':                     client.write_ns(b'a' * 4096)                 elif request == b'ping':                     client.write_ns(b'pong')                 elif request == b'reply128k':                     client.setmaxsize(128 * 1024)                     client.write_ns(b'huge' * 32 * 1024)  # 128kb                     client.setmaxsize(32768)  # back to default     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]", "output": "def find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]"}
{"task": "detection", "input": "classify code:\ndef get_valid_pos(position: Tuple[int], n: int) -> List[Tuple[int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "BUGGY"}
{"task": "search", "input": "search code:\nTurns *number* into its cardinal form, i.e., 1st, 2nd,\n\nChoices:\n0: def ordinalize(number, ext_only=False):     numstr, ext = str(number), ''     if numstr and numstr[-1] in string.digits:         try:             # first check for teens             if numstr[-2] == '1':                 ext = 'th'             else:                 # all other cases                 ext = _ORDINAL_MAP.get(numstr[-1], 'th')         except IndexError:             # single digit numbers (will reach here based on [-2] above)             ext = _ORDINAL_MAP.get(numstr[-1], 'th')     if ext_only:         return ext     else:         return numstr + ext\n1: def iterate(func, start):     with suppress(StopIteration):         while True:             yield start             start = func(start)\n2: def analyze_text(text: str) -> tuple[dict, dict]:     single_char_strings = Counter()  # type: ignore[var-annotated]     two_char_strings = Counter()  # type: ignore[var-annotated]     single_char_strings[text[-1]] += 1      # first case when we have space at start.     two_char_strings[\" \" + text[0]] += 1     for i in range(len(text) - 1):         single_char_strings[text[i]] += 1         two_char_strings[text[i : i + 2]] += 1     return single_char_strings, two_char_strings", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef slowsort(sequence: list, start: int | None = None, end: int | None = None) -> None:\n    if start is None:\n        start = 0\n\n    if end is None:\n        end = len(sequence) - 1\n\n    if start >= end:\n        return\n\n    mid = (start + end) // 2\n\n    slowsort(sequence, start, mid)\n    slowsort(sequence, mid + 1, end)\n\n    if sequence[end] < sequence[mid]:\n        sequence[end], sequence[mid] = sequence[mid], sequence[end]\n\n    slowsort(sequence, start, end - 1)", "output": "Sorts sequence[start..end] (both inclusive) in-place."}
{"task": "detection", "input": "classify code:\ndef is_balanced(s: str) -> bool:\n    \"\"\"\n    >>> is_balanced(\"\")\n    True\n    >>> is_balanced(\"()\")\n    True\n    >>> is_balanced(\"[]\")\n    True\n    >>> is_balanced(\"{}\")\n    True\n    >>> is_balanced(\"()[]{}\")\n    True\n    >>> is_balanced(\"(())\")\n    True\n    >>> is_balanced(\"[[\")\n    False\n    >>> is_balanced(\"([{}])\")\n    True\n    >>> is_balanced(\"(()[)]\")\n    False\n    >>> is_balanced(\"([)]\")\n    False\n    >>> is_balanced(\"[[()]]\")\n    True\n    >>> is_balanced(\"(()(()))\")\n    True\n    >>> is_balanced(\"]\")\n    False\n    >>> is_balanced(\"Life is a bowl of cherries.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che{}ies.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che}{ies.\")\n    False\n    \"\"\"\n    open_to_closed = {\"{\": \"}\", \"[\": \"]\", \"(\": \")\"}\n    stack = []\n    for symbol in s:\n        if symbol in open_to_closed:\n            stack.append(symbol)\n        elif symbol in open_to_closed.values() and (\n            not stack or open_to_closed[stack.pop()] != symbol\n        ):\n            return False\n    return not stack  # stack should be empty", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef generate_large_matrix() -> list[list[int]]:\n    \"\"\"\n    >>> generate_large_matrix() # doctest: +ELLIPSIS\n    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]\n    \"\"\"\n    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]", "output": "def generate_large_matrix() -> list[list[int]]:\n    \"\"\"\n    >>> generate_large_matrix() # doctest: +ELLIPSIS\n    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]\n    \"\"\"\n    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]"}
{"task": "summary", "input": "summarize code:\ndef has_same_digits(num1: int, num2: int) -> bool:\n    return sorted(str(num1)) == sorted(str(num2))", "output": "Return True if num1 and num2 have the same frequency of every digit, False"}
{"task": "search", "input": "search code:\nPure Python implementation of Harmonic Series algorithm\n\nChoices:\n0: def compress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         add_key_to_lexicon(lexicon, curr_string, index, last_match_id)         index += 1         curr_string = \"\"      while curr_string != \"\" and curr_string not in lexicon:         curr_string += \"0\"      if curr_string != \"\":         last_match_id = lexicon[curr_string]         result += last_match_id      return result\n1: def harmonic_series(n_term: str) -> list:     if n_term == \"\":         return []     series: list = []     for temp in range(int(n_term)):         series.append(f\"1/{temp + 1}\" if series else \"1\")     return series\n2: def solution(matrix_str: list[str] = MATRIX_2) -> int:      n = len(matrix_str)     arr = np.empty(shape=(n, n), dtype=int)     for row, matrix_row_str in enumerate(matrix_str):         matrix_row_list_str = matrix_row_str.split()         for col, elem_str in enumerate(matrix_row_list_str):             arr[row, col] = int(elem_str)      cache: dict[str, int] = {}     return solve(arr=arr, row=0, cols=set(range(n)), cache=cache)", "output": "1"}
{"task": "search", "input": "search code:\nReturns the number of possible prize strings for a particular number\n\nChoices:\n0: def encode(plaintext: str, key: str) -> str:      table = generate_table(key)     plaintext = prepare_input(plaintext)     ciphertext = \"\"      for char1, char2 in chunker(plaintext, 2):         row1, col1 = divmod(table.index(char1), 5)         row2, col2 = divmod(table.index(char2), 5)          if row1 == row2:             ciphertext += table[row1 * 5 + (col1 + 1) % 5]             ciphertext += table[row2 * 5 + (col2 + 1) % 5]         elif col1 == col2:             ciphertext += table[((row1 + 1) % 5) * 5 + col1]             ciphertext += table[((row2 + 1) % 5) * 5 + col2]         else:  # rectangle             ciphertext += table[row1 * 5 + col2]             ciphertext += table[row2 * 5 + col1]      return ciphertext\n1: def process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:      game_matrix = [list(row) for row in matrix]     total_score = 0      for move in moves:         pos_x, pos_y = move         game_matrix, score = play(game_matrix, pos_x, pos_y, size)         total_score += score      return total_score\n2: def solution(days: int = 30) -> int:      return _calculate(days, absent=0, late=0)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef try_key(ciphertext: list[int], key: tuple[int, ...]) -> str | None:\n    decoded: str = \"\"\n    keychar: int\n    cipherchar: int\n    decodedchar: int\n\n    for keychar, cipherchar in zip(cycle(key), ciphertext):\n        decodedchar = cipherchar ^ keychar\n        if decodedchar not in VALID_INTS:\n            return None\n        decoded += chr(decodedchar)\n\n    return decoded", "output": "Given an encrypted message and a possible 3-character key, decrypt the message."}
{"task": "search", "input": "search code:\nFunction description is as follows-\n\nChoices:\n0: def random_chars(number_char: int = 32) -> str:     assert number_char > 1, \"The number of character should greater than 1\"     letter_code = ascii_lowercase + digits     return \"\".join(random.choice(letter_code) for _ in range(number_char))\n1: def draw_fractal_recursive(x: float, y: float, length: float, depth: float):     if depth == 0:         draw_cross(x, y, length)         return      draw_fractal_recursive(x, y, length / 3, depth - 1)     draw_fractal_recursive(x + length / 3, y, length / 3, depth - 1)     draw_fractal_recursive(x - length / 3, y, length / 3, depth - 1)     draw_fractal_recursive(x, y + length / 3, length / 3, depth - 1)     draw_fractal_recursive(x, y - length / 3, length / 3, depth - 1)\n2: def knapsack(     weights: list, values: list, number_of_items: int, max_weight: int, index: int ) -> int:     if index == number_of_items:         return 0     ans1 = 0     ans2 = 0     ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)     if weights[index] <= max_weight:         ans2 = values[index] + knapsack(             weights, values, number_of_items, max_weight - weights[index], index + 1         )     return max(ans1, ans2)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef apply_table(inp, table):\n    \"\"\"\n    >>> apply_table(\"0123456789\", list(range(10)))\n    '9012345678'\n    >>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n    '8765432109'\n    \"\"\"\n    res = \"\"\n    for i in table:\n        res += inp[i - 1]\n    return res", "output": "BUGGY"}
{"task": "search", "input": "search code:\nstarting point or function of script\n\nChoices:\n0: def main() -> None:     lower = int(input(\"Enter lower value : \").strip())     higher = int(input(\"Enter high value : \").strip())     guess = int(input(\"Enter value to guess : \").strip())     guess_the_number(lower, higher, guess)\n1: def arithmetic_right_shift(number: int, shift_amount: int) -> str:     if number >= 0:  # Get binary representation of positive number         binary_number = \"0\" + str(bin(number)).strip(\"-\")[2:]     else:  # Get binary (2's complement) representation of negative number         binary_number_length = len(bin(number)[3:])  # Find 2's complement of number         binary_number = bin(abs(number) - (1 << binary_number_length))[3:]         binary_number = (             \"1\" + \"0\" * (binary_number_length - len(binary_number)) + binary_number         )      if shift_amount >= len(binary_number):         return \"0b\" + binary_number[0] * len(binary_number)     return (         \"0b\"         + binary_number[0] * shift_amount         + binary_number[: len(binary_number) - shift_amount]     )\n2: def solution(length: int = 50) -> int:      different_colour_ways_number = [[0] * 3 for _ in range(length + 1)]      for row_length in range(length + 1):         for tile_length in range(2, 5):             for tile_start in range(row_length - tile_length + 1):                 different_colour_ways_number[row_length][tile_length - 2] += (                     different_colour_ways_number[row_length - tile_start - tile_length][                         tile_length - 2                     ]                     + 1                 )      return sum(different_colour_ways_number[length])", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef odd_even_sort(input_list: list) -> list:\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list", "output": "Sort input with odd even sort."}
{"task": "search", "input": "search code:\nIsolates the decimal part of a number.\n\nChoices:\n0: def decimal_isolate(number: float, digit_amount: int) -> float:     if digit_amount > 0:         return round(number - int(number), digit_amount)     return number - int(number)\n1: def largest_rectangle_area(heights: list[int]) -> int:     stack: list[int] = []     max_area = 0     heights = [*heights, 0]  # make a new list by appending the sentinel 0     n = len(heights)      for i in range(n):         # make sure the stack remains in increasing order         while stack and heights[i] < heights[stack[-1]]:             h = heights[stack.pop()]  # height of the bar             # if stack is empty, it means entire width can be taken from index 0 to i-1             w = i if not stack else i - stack[-1] - 1  # calculate width             max_area = max(max_area, h * w)          stack.append(i)      return max_area\n2: def benchmark() -> None:      def do_benchmark(number: int) -> None:         setup = \"import __main__ as z\"         print(f\"Benchmark when {number = }:\")         print(f\"{get_set_bits_count_using_modulo_operator(number) = }\")         timing = timeit(             f\"z.get_set_bits_count_using_modulo_operator({number})\", setup=setup         )         print(f\"timeit() runs in {timing} seconds\")         print(f\"{get_set_bits_count_using_brian_kernighans_algorithm(number) = }\")         timing = timeit(             f\"z.get_set_bits_count_using_brian_kernighans_algorithm({number})\",             setup=setup,         )         print(f\"timeit() runs in {timing} seconds\")      for number in (25, 37, 58, 0):         do_benchmark(number)         print()", "output": "0"}
{"task": "search", "input": "search code:\nConvenience function for calling :func:`windowed` on *src*, with\n\nChoices:\n0: def pairwise(src, end=_UNSET):     return windowed(src, 2, fill=end)\n1: def bisection(function: Callable[[float], float], a: float, b: float) -> float:     start: float = a     end: float = b     if function(a) == 0:  # one of the a or b is a root for the function         return a     elif function(b) == 0:         return b     elif (         function(a) * function(b) > 0     ):  # if none of these are root and they are both positive or negative,         # then this algorithm can't find the root         raise ValueError(\"could not find root in given interval.\")     else:         mid: float = start + (end - start) / 2.0         while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7             if function(mid) == 0:                 return mid             elif function(mid) * function(start) < 0:                 end = mid             else:                 start = mid             mid = start + (end - start) / 2.0         return mid\n2: def copy_tree(src, dst, symlinks=False, ignore=None):     names = os.listdir(src)     if ignore is not None:         ignored_names = ignore(src, names)     else:         ignored_names = set()      mkdir_p(dst)     errors = []     for name in names:         if name in ignored_names:             continue         srcname = os.path.join(src, name)         dstname = os.path.join(dst, name)         try:             if symlinks and os.path.islink(srcname):                 linkto = os.readlink(srcname)                 os.symlink(linkto, dstname)             elif os.path.isdir(srcname):                 copytree(srcname, dstname, symlinks, ignore)             else:                 # Will raise a SpecialFileError for unsupported file types                 copy2(srcname, dstname)         # catch the Error from the recursive copytree so that we can         # continue with other files         except Error as e:             errors.extend(e.args[0])         except OSError as why:             errors.append((srcname, dstname, str(why)))     try:         copystat(src, dst)     except OSError as why:         errors.append((src, dst, str(why)))     if errors:         raise Error(errors)", "output": "0"}
{"task": "search", "input": "search code:\nAn extension of :func:`reversed` that supports all iterables, not\n\nChoices:\n0: def always_reversible(iterable):     try:         return reversed(iterable)     except TypeError:         return reversed(list(iterable))\n1: def inorder(curr_node: Node | None) -> list[Node]:     node_list = []     if curr_node is not None:         node_list = [*inorder(curr_node.left), curr_node, *inorder(curr_node.right)]     return node_list\n2: def _extract_labels(f, one_hot=False, num_classes=10):     print(\"Extracting\", f.name)     with gzip.GzipFile(fileobj=f) as bytestream:         magic = _read32(bytestream)         if magic != 2049:             msg = f\"Invalid magic number {magic} in MNIST label file: {f.name}\"             raise ValueError(msg)         num_items = _read32(bytestream)         buf = bytestream.read(num_items)         labels = np.frombuffer(buf, dtype=np.uint8)         if one_hot:             return _dense_to_one_hot(labels, num_classes)         return labels", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef mat_bin_search(value: int, matrix: list) -> list:\n    index = 0\n    if matrix[index][0] == value:\n        return [index, 0]\n    while index < len(matrix) and matrix[index][0] < value:\n        r = binary_search(matrix[index], 0, len(matrix[index]) - 1, value)\n        if r != -1:\n            return [index, r]\n        index += 1\n    return [-1, -1]", "output": "This function loops over a 2d matrix and calls binarySearch on"}
{"task": "repair", "input": "fix bug:\ndef is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n    Note: this doesn't check if P and Q are equal, but that's handled by the use of\n    itertools.combinations in the solution function.\n\n    >>> is_right(0, 1, 2, 0)\n    True\n    >>> is_right(1, 0, 2, 2)\n    False\n    \"\"\"\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )", "output": "def is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n    Note: this doesn't check if P and Q are equal, but that's handled by the use of\n    itertools.combinations in the solution function.\n\n    >>> is_right(0, 1, 2, 0)\n    True\n    >>> is_right(1, 0, 2, 2)\n    False\n    \"\"\"\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )"}
{"task": "detection", "input": "classify code:\ndef get_squared_primes_to_use(\n    num_to_look: int, squared_primes: List[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef distribute(n, iterable):\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    children = tee(iterable, n)\n    return [islice(it, index, None, n) for index, it in enumerate(children)]", "output": "Distribute the items from *iterable* among *n* smaller iterables."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 998001) -> int:\n\n    # fetches the next number\n    for number in range(n - 1, 9999, -1):\n        str_number = str(number)\n\n        # checks whether 'str_number' is a palindrome.\n        if str_number == str_number[::-1]:\n            divisor = 999\n\n            # if 'number' is a product of two 3-digit numbers\n            # then number is the answer otherwise fetch next number.\n            while divisor != 99:\n                if (number % divisor == 0) and (len(str(number // divisor)) == 3.0):\n                    return number\n                divisor -= 1\n    raise ValueError(\"That number is larger than our acceptable range.\")", "output": "Returns the largest palindrome made from the product of two 3-digit"}
{"task": "repair", "input": "fix bug:\ndef abbr(a: str, b: str) -> bool:\n    \"\"\"\n    >>> abbr(\"daBcd\", \"ABC\")\n    True\n    >>> abbr(\"dBcd\", \"ABC\")\n    False\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m + 1):\n            if dp[i][j]:\n                if j < m and a[i].upper() == b[j]:\n                    dp[i + 1][j + 1] = True\n                if a[i].islower():\n                    dp[i + 1][j] = True\n    return dp[n][m]", "output": "def abbr(a: str, b: str) -> bool:\n    \"\"\"\n    >>> abbr(\"daBcd\", \"ABC\")\n    True\n    >>> abbr(\"dBcd\", \"ABC\")\n    False\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m + 1):\n            if dp[i][j]:\n                if j < m and a[i].upper() == b[j]:\n                    dp[i + 1][j + 1] = True\n                if a[i].islower():\n                    dp[i + 1][j] = True\n    return dp[n][m]"}
{"task": "search", "input": "search code:\nReturn the last item of *iterable*, or *default* if *iterable* is\n\nChoices:\n0: def transform(velocity: float, event: np.ndarray | None = None) -> np.ndarray:     # Ensure event is not empty     if event is None:         event = np.array([ct, x, y, z])  # Symbolic four vector     else:         event[0] *= c  # x0 is ct (speed of light * time)      return transformation_matrix(velocity) @ event\n1: def last(iterable, default=_marker):     try:         if isinstance(iterable, Sequence):             return iterable[-1]         # Work around https://bugs.python.org/issue38525         if getattr(iterable, '__reversed__', None):             return next(reversed(iterable))         return deque(iterable, maxlen=1)[-1]     except (IndexError, TypeError, StopIteration):         if default is _marker:             raise ValueError(                 'last() was called on an empty iterable, '                 'and no default value was provided.'             )         return default\n2: def solution(nth: int = 10001) -> int:     return next(itertools.islice(prime_generator(), nth - 1, nth))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum([15, 2, 11, 7], 13)\n    [1, 2]\n    >>> two_sum([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum([7, 15, 11, 2], 18)\n    [0, 2]\n    >>> two_sum([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum([2, 7, 11, 15], 8)\n    []\n    >>> two_sum([3 * i for i in range(10)], 19)\n    []\n    \"\"\"\n    chk_map: dict[int, int] = {}\n    for index, val in enumerate(nums):\n        compl = target - val\n        if compl in chk_map:\n            return [chk_map[compl], index]\n        chk_map[val] = index\n    return []", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef get_neighbors_pixel(\n    image: np.ndarray, x_coordinate: int, y_coordinate: int, center: int\n) -> int:\n\n    try:\n        return int(image[x_coordinate][y_coordinate] >= center)\n    except (IndexError, TypeError):\n        return 0", "output": "Comparing local neighborhood pixel value with threshold value of centre pixel."}
{"task": "summary", "input": "summarize code:\ndef partition(number_to_partition: int) -> set[int]:\n    if number_to_partition < 0:\n        return set()\n    elif number_to_partition == 0:\n        return {1}\n\n    ret: set[int] = set()\n    prime: int\n    sub: int\n\n    for prime in primes:\n        if prime > number_to_partition:\n            continue\n        for sub in partition(number_to_partition - prime):\n            ret.add(sub * prime)\n\n    return ret", "output": "Return a set of integers corresponding to unique prime partitions of n."}
{"task": "detection", "input": "classify code:\ndef josephus_iterative(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size iteratively.\n\n    Args:\n        num_people (int): The number of people in the circle.\n        step_size (int): The number of steps to take before eliminating someone.\n\n    Returns:\n        int: The position of the last person standing.\n\n    Examples:\n        >>> josephus_iterative(5, 2)\n        3\n        >>> josephus_iterative(7, 3)\n        4\n    \"\"\"\n    circle = list(range(1, num_people + 1))\n    current = 0\n\n    while len(circle) > 1:\n        current = (current + step_size - 1) % len(circle)\n        circle.pop(current)\n\n    return circle[0]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nInput Parameters:\n\nChoices:\n0: def validate(*values: float) -> bool:     result = len(values) > 0 and all(value > 0.0 for value in values)     return result\n1: def calculate_signal_power(audio_fft: np.ndarray) -> np.ndarray:     # Calculate the power by squaring the absolute values of the FFT coefficients     return np.square(np.abs(audio_fft))\n2: def pluperfect_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False      # Init a \"histogram\" of the digits     digit_histogram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]     digit_total = 0     total = 0     temp = n     while temp > 0:         temp, rem = divmod(temp, 10)         digit_histogram[rem] += 1         digit_total += 1      for cnt, i in zip(digit_histogram, range(len(digit_histogram))):         total += cnt * i**digit_total      return n == total", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef wiggle_sort(nums):\n    \"\"\"Perform Wiggle Sort.\"\"\"\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]", "output": "def wiggle_sort(nums: list) -> list:\n    \"\"\"\n    Python implementation of wiggle.\n    Example:\n    >>> wiggle_sort([0, 5, 3, 2, 2])\n    [0, 5, 2, 3, 2]\n    >>> wiggle_sort([])\n    []\n    >>> wiggle_sort([-2, -5, -45])\n    [-45, -2, -5]\n    >>> wiggle_sort([-2.1, -5.68, -45.11])\n    [-45.11, -2.1, -5.68]\n    \"\"\"\n    for i, _ in enumerate(nums):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\n    return nums"}
{"task": "search", "input": "search code:\nWill convert the entire string to lowercase letters\n\nChoices:\n0: def lower(word: str) -> str:      # Converting to ASCII value, obtaining the integer representation     # and checking to see if the character is a capital letter.     # If it is a capital letter, it is shifted by 32, making it a lowercase letter.     return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)\n1: def vol_cuboid(width: float, height: float, length: float) -> float:     if width < 0 or height < 0 or length < 0:         raise ValueError(\"vol_cuboid() only accepts non-negative values\")     return float(width * height * length)\n2: def solution(length: int = 50) -> int:      ways_number = [1] * (length + 1)      for row_length in range(3, length + 1):         for block_length in range(3, row_length + 1):             for block_start in range(row_length - block_length):                 ways_number[row_length] += ways_number[                     row_length - block_start - block_length - 1                 ]              ways_number[row_length] += 1      return ways_number[length]", "output": "0"}
{"task": "detection", "input": "classify code:\ndef find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef is_isogram(string: str) -> bool:\n    if not all(x.isalpha() for x in string):\n        raise ValueError(\"String must only contain alphabetic characters.\")\n\n    letters = sorted(string.lower())\n    return len(letters) == len(set(letters))", "output": "An isogram is a word in which no letter is repeated."}
{"task": "summary", "input": "summarize code:\ndef list_truncated_nums(n: int) -> list[int]:\n    str_num = str(n)\n    list_nums = [n]\n    for i in range(1, len(str_num)):\n        list_nums.append(int(str_num[i:]))\n        list_nums.append(int(str_num[:-i]))\n    return list_nums", "output": "Returns a list of all left and right truncated numbers of n"}
{"task": "summary", "input": "summarize code:\ndef sum_of_squares(it):\n    return _sumprod(*tee(it))", "output": "Return the sum of the squares of the input values."}
{"task": "search", "input": "search code:\nReturns a list of first n odd composite numbers which do\n\nChoices:\n0: def compute_nums(n: int) -> list[int]:     if not isinstance(n, int):         raise ValueError(\"n must be an integer\")     if n <= 0:         raise ValueError(\"n must be >= 0\")      list_nums = []     for num in range(len(odd_composites)):         i = 0         while 2 * i * i <= odd_composites[num]:             rem = odd_composites[num] - 2 * i * i             if is_prime(rem):                 break             i += 1         else:             list_nums.append(odd_composites[num])             if len(list_nums) == n:                 return list_nums      return []\n1: def solution(limit: int = 50000000) -> int:     ret = set()     prime_square_limit = int((limit - 24) ** (1 / 2))      primes = set(range(3, prime_square_limit + 1, 2))     primes.add(2)     for p in range(3, prime_square_limit + 1, 2):         if p not in primes:             continue         primes.difference_update(set(range(p * p, prime_square_limit + 1, p)))      for prime1 in primes:         square = prime1 * prime1         for prime2 in primes:             cube = prime2 * prime2 * prime2             if square + cube >= limit - 16:                 break             for prime3 in primes:                 tetr = prime3 * prime3 * prime3 * prime3                 total = square + cube + tetr                 if total >= limit:                     break                 ret.add(total)      return len(ret)\n2: def is_contains_unique_chars(input_str: str) -> bool:      # Each bit will represent each unicode character     # For example 65th bit representing 'A'     # https://stackoverflow.com/a/12811293     bitmap = 0     for ch in input_str:         ch_unicode = ord(ch)         ch_bit_index_on = pow(2, ch_unicode)          # If we already turned on bit for current character's unicode         if bitmap >> ch_unicode & 1 == 1:             return False         bitmap |= ch_bit_index_on     return True", "output": "0"}
{"task": "search", "input": "search code:\nExamples:\n\nChoices:\n0: def get_files_url() -> str:     with open(os.environ[\"GITHUB_EVENT_PATH\"]) as file:         event = json.load(file)     return event[\"pull_request\"][\"url\"] + \"/files\"\n1: def print_linked_list(head: Node | None) -> None:     if head is None:         return     while head.next_node is not None:         print(head.data, end=\"->\")         head = head.next_node     print(head.data)\n2: def power(x: int, y: int, mod: int) -> int:      if y == 0:         return 1     temp = power(x, y // 2, mod) % mod     temp = (temp * temp) % mod     if y % 2 == 1:         temp = (temp * x) % mod     return temp", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef wheatstone_solver(\n    resistance_1: float, resistance_2: float, resistance_3: float\n) -> float:\n\n    if resistance_1 <= 0 or resistance_2 <= 0 or resistance_3 <= 0:\n        raise ValueError(\"All resistance values must be positive\")\n    else:\n        return float((resistance_2 / resistance_1) * resistance_3)", "output": "This function can calculate the unknown resistance in an wheatstone network,"}
{"task": "summary", "input": "summarize code:\ndef color(node: RedBlackTree | None) -> int:\n    if node is None:\n        return 0\n    else:\n        return node.color", "output": "Returns the color of a node, allowing for None leaves."}
{"task": "search", "input": "search code:\nImplements the binary step function\n\nChoices:\n0: def binary_step(vector: np.ndarray) -> np.ndarray:      return np.where(vector >= 0, 1, 0)\n1: def zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):      def is_scalar(obj):         if scalar_types and isinstance(obj, scalar_types):             return True         try:             iter(obj)         except TypeError:             return True         else:             return False      size = len(objects)     if not size:         return      new_item = [None] * size     iterables, iterable_positions = [], []     for i, obj in enumerate(objects):         if is_scalar(obj):             new_item[i] = obj         else:             iterables.append(iter(obj))             iterable_positions.append(i)      if not iterables:         yield tuple(objects)         return      for item in zip(*iterables, strict=strict):         for i, new_item[i] in zip(iterable_positions, item):             pass         yield tuple(new_item)\n2: def solution(exponent: int = 30) -> int:     # To find how many total games were lost for a given exponent x,     # we need to find the Fibonacci number F(x+2).     fibonacci_index = exponent + 2     phi = (1 + 5**0.5) / 2     fibonacci = (phi**fibonacci_index - (phi - 1) ** fibonacci_index) / 5**0.5      return int(fibonacci)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef main():\n    print(modular_exponential(3, 200, 13))", "output": "Call Modular Exponential Function."}
{"task": "summary", "input": "summarize code:\ndef binary_insertion_sort(collection: list) -> list:\n\n    n = len(collection)\n    for i in range(1, n):\n        value_to_insert = collection[i]\n        low = 0\n        high = i - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if value_to_insert < collection[mid]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        for j in range(i, low, -1):\n            collection[j] = collection[j - 1]\n        collection[low] = value_to_insert\n    return collection", "output": "Sorts a list using the binary insertion sort algorithm."}
{"task": "search", "input": "search code:\nReturn the number of integers less than limit which can be expressed as the sum\n\nChoices:\n0: def crossover(parent_1: str, parent_2: str) -> tuple[str, str]:     random_slice = random.randint(0, len(parent_1) - 1)     child_1 = parent_1[:random_slice] + parent_2[random_slice:]     child_2 = parent_2[:random_slice] + parent_1[random_slice:]     return (child_1, child_2)\n1: def perfect_square(num: int) -> bool:     return math.sqrt(num) * math.sqrt(num) == num\n2: def solution(limit: int = 50000000) -> int:     ret = set()     prime_square_limit = int((limit - 24) ** (1 / 2))      primes = set(range(3, prime_square_limit + 1, 2))     primes.add(2)     for p in range(3, prime_square_limit + 1, 2):         if p not in primes:             continue         primes.difference_update(set(range(p * p, prime_square_limit + 1, p)))      for prime1 in primes:         square = prime1 * prime1         for prime2 in primes:             cube = prime2 * prime2 * prime2             if square + cube >= limit - 16:                 break             for prime3 in primes:                 tetr = prime3 * prime3 * prime3 * prime3                 total = square + cube + tetr                 if total >= limit:                     break                 ret.add(total)      return len(ret)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef actual_power(a: int, b: int) -> int:\n    \"\"\"\n    Function using divide and conquer to calculate a^b.\n    It only works for integer a,b.\n\n    :param a: The base of the power operation, an integer.\n    :param b: The exponent of the power operation, a non-negative integer.\n    :return: The result of a^b.\n\n    Examples:\n    >>> actual_power(3, 2)\n    9\n    >>> actual_power(5, 3)\n    125\n    >>> actual_power(2, 5)\n    32\n    >>> actual_power(7, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    half = actual_power(a, b // 2)\n\n    if (b % 2) == 0:\n        return half * half\n    else:\n        return a * half * half", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef least_divisible_repunit(divisor: int) -> int:\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index", "output": "Return the least value k such that the Repunit of length k is divisible by divisor."}
{"task": "detection", "input": "classify code:\ndef levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef hexagonal_num(n: int) -> int:\n    return n * (2 * n - 1)", "output": "Returns nth hexagonal number"}
{"task": "detection", "input": "classify code:\ndef capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Create a dictionary that maps lowercase letters to uppercase letters\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    lower_to_upper = dict(zip(ascii_lowercase, ascii_uppercase))\n    return lower_to_upper.get(sentence[0], sentence[0]) + sentence[1:]", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef find_isolated_nodes(graph):\n    isolated = []\n    for node in graph:\n        if not graph[node]:\n            isolated.append(node)\n    return isolated", "output": "Find the isolated node in the graph"}
{"task": "search", "input": "search code:\nYield batches of items from *iterable* with a combined size limited by\n\nChoices:\n0: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)\n1: def slugify(text, delim='_', lower=True, ascii=False):     ret = delim.join(split_punct_ws(text)) or delim if text else ''     if ascii:         ret = asciify(ret)     if lower:         ret = ret.lower()     return ret\n2: def prim_heap(graph: list, root: Vertex) -> Iterator[tuple]:     for u in graph:         u.key = math.inf         u.pi = None     root.key = 0      h = list(graph)     hq.heapify(h)      while h:         u = hq.heappop(h)         for v in u.neighbors:             if (v in h) and (u.edges[v.id] < v.key):                 v.pi = u                 v.key = u.edges[v.id]                 hq.heapify(h)      for i in range(1, len(graph)):         yield (int(graph[i].id) + 1, int(graph[i].pi.id) + 1)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    file_path = os.path.join(os.path.dirname(__file__), \"num.txt\")\n    with open(file_path) as file_hand:\n        return str(sum(int(line) for line in file_hand))[:10]", "output": "Returns the first ten digits of the sum of the array elements"}
{"task": "detection", "input": "classify code:\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef binary_exp_iterative(base: float, exponent: int) -> float:\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n\n    res: int | float = 1\n    while exponent > 0:\n        if exponent & 1:\n            res *= base\n\n        base *= base\n        exponent >>= 1\n\n    return res", "output": "Computes a^b iteratively, where a is the base and b is the exponent"}
{"task": "summary", "input": "summarize code:\ndef solution(exponent: int = 30) -> int:\n    # To find how many total games were lost for a given exponent x,\n    # we need to find the Fibonacci number F(x+2).\n    fibonacci_index = exponent + 2\n    phi = (1 + 5**0.5) / 2\n    fibonacci = (phi**fibonacci_index - (phi - 1) ** fibonacci_index) / 5**0.5\n\n    return int(fibonacci)", "output": "For any given exponent x >= 0, 1 <= n <= 2^x."}
{"task": "summary", "input": "summarize code:\ndef lexical_order(max_number: int) -> Iterator[int]:\n\n    stack = [1]\n\n    while stack:\n        num = stack.pop()\n        if num > max_number:\n            continue\n\n        yield num\n        if (num % 10) != 9:\n            stack.append(num + 1)\n\n        stack.append(num * 10)", "output": "Generate numbers in lexical order from 1 to max_number."}
{"task": "search", "input": "search code:\nThe below tree\n\nChoices:\n0: def rmse(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     square_diff = np.square(difference)     mean_square_diff = square_diff.mean()     score = np.sqrt(mean_square_diff)     return score\n1: def check_direction(     starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int] ) -> Direction:     x0, y0 = starting     x1, y1 = via     x2, y2 = target     via_angle = degrees(atan2(y1 - y0, x1 - x0))     via_angle %= 360     target_angle = degrees(atan2(y2 - y0, x2 - x0))     target_angle %= 360     # t-     #  \\ \\     #   \\ v     #    \\|     #     s     # via_angle is always lower than target_angle, if direction is left.     # If they are same, it means they are on a same line of convex hull.     if target_angle > via_angle:         return Direction.left     elif target_angle == via_angle:         return Direction.straight     else:         return Direction.right\n2: def make_tree() -> Node | None:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     return tree", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(power: int = 1000) -> int:\n    n = 2**power\n    r = 0\n    while n:\n        r, n = r + n % 10, n // 10\n    return r", "output": "Returns the sum of the digits of the number 2^power."}
{"task": "search", "input": "search code:\nReturns the number of ways can a row of the given length be tiled\n\nChoices:\n0: def pairwise_iter(src, end=_UNSET):     return windowed_iter(src, 2, fill=end)\n1: def solution(length: int = 50) -> int:      ways_number = [1] * (length + 1)      for row_length in range(length + 1):         for tile_length in range(2, 5):             for tile_start in range(row_length - tile_length + 1):                 ways_number[row_length] += ways_number[                     row_length - tile_start - tile_length                 ]      return ways_number[length]\n2: def password_generator(length: int = 8) -> str:     chars = ascii_letters + digits + punctuation     return \"\".join(secrets.choice(chars) for _ in range(length))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef recursive_match(text: str, pattern: str) -> bool:\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False", "output": "Recursive matching algorithm."}
{"task": "summary", "input": "summarize code:\ndef root_mean_square_error(original: np.ndarray, reference: np.ndarray) -> float:\n    return float(np.sqrt(((original - reference) ** 2).mean()))", "output": "Simple implementation of Root Mean Squared Error"}
{"task": "detection", "input": "classify code:\ndef digit_sum(n: int) -> int:\n    \"\"\"\n    Returns the sum of the digits of the number.\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(456)\n    15\n    >>> digit_sum(78910)\n    25\n    \"\"\"\n    return sum(int(digit) for digit in str(n))", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef is_square_form(num: int) -> bool:\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True", "output": "Determines if num is in the form 1_2_3_4_5_6_7_8_9"}
{"task": "summary", "input": "summarize code:\ndef iequals(*iterables):\n    try:\n        return all(map(all_equal, zip(*iterables, strict=True)))\n    except ValueError:\n        return False", "output": "Return ``True`` if all given *iterables* are equal to each other,"}
{"task": "summary", "input": "summarize code:\ndef logical_right_shift(number: int, shift_amount: int) -> str:\n    if number < 0 or shift_amount < 0:\n        raise ValueError(\"both inputs must be positive integers\")\n\n    binary_number = str(bin(number))[2:]\n    if shift_amount >= len(binary_number):\n        return \"0b0\"\n    shifted_binary_number = binary_number[: len(binary_number) - shift_amount]\n    return \"0b\" + shifted_binary_number", "output": "Take in positive 2 integers."}
{"task": "search", "input": "search code:\nDisplay the flattened linked list.\n\nChoices:\n0: def solution(n: int = 1000) -> int:      return sum(e for e in range(3, n) if e % 3 == 0 or e % 5 == 0)\n1: def get_cost_derivative(index):     cost_derivative_value = summation_of_cost_derivative(index, m) / m     return cost_derivative_value\n2: def display_linked_list(root: TreeNode | None) -> None:     current = root     while current:         if current.right is None:             print(current.data, end=\"\")             break         print(current.data, end=\" \")         current = current.right", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef actual_power(a: int, b: int) -> int:\n    if b == 0:\n        return 1\n    half = actual_power(a, b // 2)\n\n    if (b % 2) == 0:\n        return half * half\n    else:\n        return a * half * half", "output": "Function using divide and conquer to calculate a^b."}
{"task": "summary", "input": "summarize code:\ndef search(values):\n    if values is False:\n        return False  ## Failed earlier\n    if all(len(values[s]) == 1 for s in squares):\n        return values  ## Solved!\n    ## Chose the unfilled square s with the fewest possibilities\n    _n, s = min((len(values[s]), s) for s in squares if len(values[s]) > 1)\n    return some(search(assign(values.copy(), s, d)) for d in values[s])", "output": "Using depth-first search and propagation, try all possible values."}
{"task": "summary", "input": "summarize code:\ndef zero_vector(dimension: int) -> Vector:\n    # precondition\n    assert isinstance(dimension, int)\n    return Vector([0] * dimension)", "output": "returns a zero-vector of size 'dimension'"}
{"task": "summary", "input": "summarize code:\ndef volume_conversion(value: float, from_type: str, to_type: str) -> float:\n    if from_type not in METRIC_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"\n            + \", \".join(METRIC_CONVERSION)\n        )\n    if to_type not in METRIC_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"\n            + \", \".join(METRIC_CONVERSION)\n        )\n    return (\n        value\n        * METRIC_CONVERSION[from_type].from_factor\n        * METRIC_CONVERSION[to_type].to_factor\n    )", "output": "Conversion between volume units."}
{"task": "search", "input": "search code:\nIterate through every possible cube and sort the cube's digits in\n\nChoices:\n0: def solution(max_base: int = 5) -> int:     freqs = defaultdict(list)     num = 0      while True:         digits = get_digits(num)         freqs[digits].append(num)          if len(freqs[digits]) == max_base:             base = freqs[digits][0] ** 3             return base          num += 1\n1: def pi_estimator_using_area_under_curve(iterations: int) -> None:      def function_to_integrate(x: float) -> float:         return sqrt(4.0 - x * x)      estimated_value = area_under_curve_estimator(         iterations, function_to_integrate, 0.0, 2.0     )      print(\"******************\")     print(\"Estimating pi using area_under_curve_estimator\")     print(f\"Estimated value is {estimated_value}\")     print(f\"Expected value is {pi}\")     print(f\"Total error is {abs(estimated_value - pi)}\")     print(\"******************\")\n2: def longest_common_subsequence(x: str, y: str):     # find the length of strings      assert x is not None     assert y is not None      m = len(x)     n = len(y)      # declaring the array for storing the dp values     dp = [[0] * (n + 1) for _ in range(m + 1)]      for i in range(1, m + 1):         for j in range(1, n + 1):             match = 1 if x[i - 1] == y[j - 1] else 0              dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)      seq = \"\"     i, j = m, n     while i > 0 and j > 0:         match = 1 if x[i - 1] == y[j - 1] else 0          if dp[i][j] == dp[i - 1][j - 1] + match:             if match == 1:                 seq = x[i - 1] + seq             i -= 1             j -= 1         elif dp[i][j] == dp[i - 1][j]:             i -= 1         else:             j -= 1      return dp[m][n], seq", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:\n\n    id_ = 0\n    n = len(graph)  # No of vertices in graph\n    low = [0] * n\n    visited = [False] * n\n\n    def dfs(at, parent, bridges, id_):\n        visited[at] = True\n        low[at] = id_\n        id_ += 1\n        for to in graph[at]:\n            if to == parent:\n                pass\n            elif not visited[to]:\n                dfs(to, at, bridges, id_)\n                low[at] = min(low[at], low[to])\n                if id_ <= low[to]:\n                    bridges.append((at, to) if at < to else (to, at))\n            else:\n                # This edge is a back edge and cannot be a bridge\n                low[at] = min(low[at], low[to])\n\n    bridges: list[tuple[int, int]] = []\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, -1, bridges, id_)\n    return bridges", "output": "Return the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi"}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def args2cmd(args, sep=' '):     # technique description from subprocess below     result = []     needquote = False     for arg in args:         bs_buf = []          # Add a space to separate this argument from the others         if result:             result.append(' ')          needquote = (\" \" in arg) or (\"\\t\" in arg) or not arg         if needquote:             result.append('\"')          for c in arg:             if c == '\\\\':                 # Don't know if we need to double yet.                 bs_buf.append(c)             elif c == '\"':                 # Double backslashes.                 result.append('\\\\' * len(bs_buf)*2)                 bs_buf = []                 result.append('\\\\\"')             else:                 # Normal char                 if bs_buf:                     result.extend(bs_buf)                     bs_buf = []                 result.append(c)          # Add remaining backslashes, if any.         if bs_buf:             result.extend(bs_buf)          if needquote:             result.extend(bs_buf)             result.append('\"')      return ''.join(result)\n1: def valid_coloring(     neighbours: list[int], colored_vertices: list[int], color: int ) -> bool:     # Does any neighbour not satisfy the constraints     return not any(         neighbour == 1 and colored_vertices[i] == color         for i, neighbour in enumerate(neighbours)     )\n2: def is_prime(number: int) -> bool:      # precondition     assert isinstance(number, int) and (number >= 0), (         \"'number' must been an int and positive\"     )      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or not number % 2:         # Negatives, 0, 1 and all even numbers are not primes         return False      odd_numbers = range(3, int(math.sqrt(number) + 1), 2)     return not any(not number % i for i in odd_numbers)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:\n\n    new_list = []\n\n    for row in range(size):\n        if matrix_g[row][column] != \"-\":\n            new_list.append(matrix_g[row][column])\n        else:\n            new_list.insert(0, matrix_g[row][column])\n    for row in range(size):\n        matrix_g[row][column] = new_list[row]\n    return matrix_g", "output": "Simulates gravity in a specific column."}
{"task": "repair", "input": "fix bug:\ndef combination_sum_iv_dp_array(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)", "output": "def combination_sum_iv_dp_array(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)"}
{"task": "search", "input": "search code:\nReturns the value of the first triangle number to have over five hundred\n\nChoices:\n0: def res(x, y):     if 0 not in (x, y):         # We use the relation x^y = y*log10(x), where 10 is the base.         return y * math.log10(x)     elif x == 0:  # 0 raised to any number is 0         return 0     elif y == 0:         return 1  # any number raised to 0 is 1     raise AssertionError(\"This should never happen\")\n1: def solution():     return next(i for i in triangle_number_generator() if count_divisors(i) > 500)\n2: def pad_none(iterable):     return chain(iterable, repeat(None))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef _ngettext(message, plural, num):\n    return get_translation().ngettext(message, plural, num)", "output": "Plural version of _gettext."}
{"task": "search", "input": "search code:\nCalculate the waiting time of each processes.\n\nChoices:\n0: def calculate_waiting_time(     process_name: list,  # noqa: ARG001     turn_around_time: list,     burst_time: list,     no_of_process: int, ) -> list:      waiting_time = [0] * no_of_process     for i in range(no_of_process):         waiting_time[i] = turn_around_time[i] - burst_time[i]     return waiting_time\n1: def archimedes_principle(     fluid_density: float, volume: float, gravity: float = g ) -> float:      if fluid_density <= 0:         raise ValueError(\"Impossible fluid density\")     if volume <= 0:         raise ValueError(\"Impossible object volume\")     if gravity < 0:         raise ValueError(\"Impossible gravity\")      return fluid_density * gravity * volume\n2: def display(values):     width = 1 + max(len(values[s]) for s in squares)     line = \"+\".join([\"-\" * (width * 3)] * 3)     for r in rows:         print(             \"\".join(                 values[r + c].center(width) + (\"|\" if c in \"36\" else \"\") for c in cols             )         )         if r in \"CF\":             print(line)     print()", "output": "0"}
{"task": "search", "input": "search code:\nExamples:\n\nChoices:\n0: def is_pangram(     input_str: str = \"The quick brown fox jumps over the lazy dog\", ) -> bool:     # Declare frequency as a set to have unique occurrences of letters     frequency = set()      # Replace all the whitespace in our sentence     input_str = input_str.replace(\" \", \"\")     for alpha in input_str:         if \"a\" <= alpha.lower() <= \"z\":             frequency.add(alpha.lower())     return len(frequency) == 26\n1: def circular_shifts(iterable, steps=1):     buffer = deque(iterable)     if steps == 0:         raise ValueError('Steps should be a non-zero integer')      buffer.rotate(steps)     steps = -steps     n = len(buffer)     n //= math.gcd(n, steps)      for _ in repeat(None, n):         buffer.rotate(steps)         yield tuple(buffer)\n2: def stooge_sort(arr: list[int]) -> list[int]:     stooge(arr, 0, len(arr) - 1)     return arr", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef surface_area_cube(side_length: float) -> float:\n    if side_length < 0:\n        raise ValueError(\"surface_area_cube() only accepts non-negative values\")\n    return 6 * side_length**2", "output": "Calculate the Surface Area of a Cube."}
{"task": "search", "input": "search code:\nReq = 1/ (1/R1 + 1/R2 + ... + 1/Rn)\n\nChoices:\n0: def resistor_parallel(resistors: list[float]) -> float:      first_sum = 0.00     for index, resistor in enumerate(resistors):         if resistor <= 0:             msg = f\"Resistor at index {index} has a negative or zero value!\"             raise ValueError(msg)         first_sum += 1 / float(resistor)     return 1 / first_sum\n1: def topological_sort(start: str, visited: list[str], sort: list[str]) -> list[str]:     current = start     # add current to visited     visited.append(current)     neighbors = edges[current]     for neighbor in neighbors:         # if neighbor not in visited, visit         if neighbor not in visited:             sort = topological_sort(neighbor, visited, sort)     # if all neighbors visited add current to sort     sort.append(current)     # if all vertices haven't been visited select a new one to visit     if len(visited) != len(vertices):         for vertice in vertices:             if vertice not in visited:                 sort = topological_sort(vertice, visited, sort)     # return sort     return sort\n2: def matmul(m1, m2):     n = len(m2[0])     return batched(starmap(_sumprod, product(m1, transpose(m2))), n)", "output": "0"}
{"task": "search", "input": "search code:\nReturn the ceiling of x as an Integral.\n\nChoices:\n0: def solution():     script_dir = os.path.dirname(os.path.realpath(__file__))     words_file_path = os.path.join(script_dir, \"words.txt\")      words = \"\"     with open(words_file_path) as f:         words = f.readline()      words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]     words = [         word         for word in [sum(ord(x) - 64 for x in word) for word in words]         if word in TRIANGULAR_NUMBERS     ]     return len(words)\n1: def ceil(x: float) -> int:     return int(x) if x - int(x) <= 0 else int(x) + 1\n2: def count_inversions_bf(arr):      num_inversions = 0     n = len(arr)      for i in range(n - 1):         for j in range(i + 1, n):             if arr[i] > arr[j]:                 num_inversions += 1      return num_inversions", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef casimir_force(force: float, area: float, distance: float) -> dict[str, float]:\n\n    if (force, area, distance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if force < 0:\n        raise ValueError(\"Magnitude of force can not be negative\")\n    if distance < 0:\n        raise ValueError(\"Distance can not be negative\")\n    if area < 0:\n        raise ValueError(\"Area can not be negative\")\n    if force == 0:\n        force = (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (\n            240 * (distance) ** 4\n        )\n        return {\"force\": force}\n    elif area == 0:\n        area = (240 * force * (distance) ** 4) / (\n            REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2\n        )\n        return {\"area\": area}\n    elif distance == 0:\n        distance = (\n            (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (240 * force)\n        ) ** (1 / 4)\n        return {\"distance\": distance}\n    raise ValueError(\"One and only one argument must be 0\")", "output": "Input Parameters"}
{"task": "summary", "input": "summarize code:\ndef knuth_morris_pratt(text: str, pattern: str) -> int:\n\n    # 1) Construct the failure array\n    failure = get_failure_array(pattern)\n\n    # 2) Step through text searching for pattern\n    i, j = 0, 0  # index into text, pattern\n    while i < len(text):\n        if pattern[j] == text[i]:\n            if j == (len(pattern) - 1):\n                return i - j\n            j += 1\n\n        # if this is a prefix in our pattern\n        # just go back far enough to continue\n        elif j > 0:\n            j = failure[j - 1]\n            continue\n        i += 1\n    return -1", "output": "The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text"}
{"task": "summary", "input": "summarize code:\ndef largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area", "output": "Function updates the largest_square_area, using bottom up"}
{"task": "summary", "input": "summarize code:\ndef minimax(\n    depth: int, node_index: int, is_max: bool, scores: list[int], height: float\n) -> int:\n\n    if depth < 0:\n        raise ValueError(\"Depth cannot be less than 0\")\n    if len(scores) == 0:\n        raise ValueError(\"Scores cannot be empty\")\n\n    # Base case: If the current depth equals the height of the tree,\n    # return the score of the current node.\n    if depth == height:\n        return scores[node_index]\n\n    # If it's the maximizer's turn, choose the maximum score\n    # between the two possible moves.\n    if is_max:\n        return max(\n            minimax(depth + 1, node_index * 2, False, scores, height),\n            minimax(depth + 1, node_index * 2 + 1, False, scores, height),\n        )\n\n    # If it's the minimizer's turn, choose the minimum score\n    # between the two possible moves.\n    return min(\n        minimax(depth + 1, node_index * 2, True, scores, height),\n        minimax(depth + 1, node_index * 2 + 1, True, scores, height),\n    )", "output": "This function implements the minimax algorithm, which helps achieve the optimal"}
{"task": "repair", "input": "fix bug:\ndef is_9_pandigital(n: int) -> bool:\n    \"\"\"\n    Checks whether n is a 9-digit 1 to 9 pandigital number.\n    >>> is_9_pandigital(12345)\n    False\n    >>> is_9_pandigital(156284973)\n    True\n    >>> is_9_pandigital(1562849733)\n    False\n    \"\"\"\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")", "output": "def is_9_pandigital(n: int) -> bool:\n    \"\"\"\n    Checks whether n is a 9-digit 1 to 9 pandigital number.\n    >>> is_9_pandigital(12345)\n    False\n    >>> is_9_pandigital(156284973)\n    True\n    >>> is_9_pandigital(1562849733)\n    False\n    \"\"\"\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")"}
{"task": "summary", "input": "summarize code:\ndef not_gate(input_1: int) -> int:\n\n    return 1 if input_1 == 0 else 0", "output": "Calculate NOT of the input values"}
{"task": "summary", "input": "summarize code:\ndef warp(\n    image: np.ndarray, horizontal_flow: np.ndarray, vertical_flow: np.ndarray\n) -> np.ndarray:\n    flow = np.stack((horizontal_flow, vertical_flow), 2)\n\n    # Create a grid of all pixel coordinates and subtract the flow to get the\n    # target pixels coordinates\n    grid = np.stack(\n        np.meshgrid(np.arange(0, image.shape[1]), np.arange(0, image.shape[0])), 2\n    )\n    grid = np.round(grid - flow).astype(np.int32)\n\n    # Find the locations outside of the original image\n    invalid = (grid < 0) | (grid >= np.array([image.shape[1], image.shape[0]]))\n    grid[invalid] = 0\n\n    warped = image[grid[:, :, 1], grid[:, :, 0]]\n\n    # Set pixels at invalid locations to 0\n    warped[invalid[:, :, 0] | invalid[:, :, 1]] = 0\n\n    return warped", "output": "Warps the pixels of an image into a new image using the horizontal and vertical"}
{"task": "summary", "input": "summarize code:\ndef surface_area_conical_frustum(\n    radius_1: float, radius_2: float, height: float\n) -> float:\n    if radius_1 < 0 or radius_2 < 0 or height < 0:\n        raise ValueError(\n            \"surface_area_conical_frustum() only accepts non-negative values\"\n        )\n    slant_height = (height**2 + (radius_1 - radius_2) ** 2) ** 0.5\n    return pi * ((slant_height * (radius_1 + radius_2)) + radius_1**2 + radius_2**2)", "output": "Calculate the Surface Area of a Conical Frustum."}
{"task": "detection", "input": "classify code:\ndef excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef get_bit(number: int, position: int) -> int:\n    return int((number & (1 << position)) != 0)", "output": "Get the bit at the given position"}
{"task": "summary", "input": "summarize code:\ndef pairwise(src, end=_UNSET):\n    return windowed(src, 2, fill=end)", "output": "Convenience function for calling :func:`windowed` on *src*, with"}
{"task": "detection", "input": "classify code:\ndef max_difference(a: List[int]) -> (int, int):\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq", "output": "def longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq"}
{"task": "summary", "input": "summarize code:\ndef scientific(value, precision=2):\n    exponents = {\n        \"0\": \"\",\n        \"1\": \"\",\n        \"2\": \"\",\n        \"3\": \"\",\n        \"4\": \"\",\n        \"5\": \"\",\n        \"6\": \"\",\n        \"7\": \"\",\n        \"8\": \"\",\n        \"9\": \"\",\n        \"+\": \"\",\n        \"-\": \"\",\n    }\n    negative = False\n    try:\n        if \"-\" in str(value):\n            value = str(value).replace(\"-\", \"\")\n            negative = True\n\n        if isinstance(value, str):\n            value = float(value)\n\n        fmt = \"{:.%se}\" % str(int(precision))\n        n = fmt.format(value)\n\n    except (ValueError, TypeError):\n        return value\n\n    part1, part2 = n.split(\"e\")\n    if \"-0\" in part2:\n        part2 = part2.replace(\"-0\", \"-\")\n\n    if \"+0\" in part2:\n        part2 = part2.replace(\"+0\", \"\")\n\n    new_part2 = []\n    if negative:\n        new_part2.append(exponents[\"-\"])\n\n    for char in part2:\n        new_part2.append(exponents[char])\n\n    final_str = part1 + \" x 10\" + \"\".join(new_part2)\n\n    return final_str", "output": "Return number in string scientific notation z.wq x 10."}
{"task": "detection", "input": "classify code:\ndef is_9_pandigital(n: int) -> bool:\n    \"\"\"\n    Checks whether n is a 9-digit 1 to 9 pandigital number.\n    >>> is_9_pandigital(12345)\n    False\n    >>> is_9_pandigital(156284973)\n    True\n    >>> is_9_pandigital(1562849733)\n    False\n    \"\"\"\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)", "output": "def decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)"}
{"task": "summary", "input": "summarize code:\ndef tribonacci(num: int) -> list[int]:\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp", "output": "Given a number, return first n Tribonacci Numbers."}
{"task": "search", "input": "search code:\nGiven a list of integers, return elements a, b, c such that a + b + c = 0.\n\nChoices:\n0: def multiplication_table(number: int, number_of_terms: int) -> str:     return \"\\n\".join(         f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)     )\n1: def find_triplets_with_0_sum(nums: list[int]) -> list[list[int]]:     return [         list(x)         for x in sorted({abc for abc in combinations(sorted(nums), 3) if not sum(abc)})     ]\n2: def solution(n: int = 1000) -> int:      total = 0     terms = (n - 1) // 3     total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.     terms = (n - 1) // 5     total += ((terms) * (10 + (terms - 1) * 5)) // 2     terms = (n - 1) // 15     total -= ((terms) * (30 + (terms - 1) * 15)) // 2     return total", "output": "1"}
{"task": "search", "input": "search code:\nsame as next_term(a_i, k, i, n) but computes terms without memoizing results.\n\nChoices:\n0: def compute(a_i, k, i, n):     if i >= n:         return 0, i     if k > len(a_i):         a_i.extend([0 for _ in range(k - len(a_i))])      # note: a_i -> b * 10^k + c     # ds_b -> digitsum(b)     # ds_c -> digitsum(c)     start_i = i     ds_b, ds_c, diff = 0, 0, 0     for j in range(len(a_i)):         if j >= k:             ds_b += a_i[j]         else:             ds_c += a_i[j]      while i < n:         i += 1         addend = ds_c + ds_b         diff += addend         ds_c = 0         for j in range(k):             s = a_i[j] + addend             addend, a_i[j] = divmod(s, 10)              ds_c += a_i[j]          if addend > 0:             break      if addend > 0:         add(a_i, k, addend)     return diff, i - start_i\n1: def open_knight_tour(n: int) -> list[list[int]]:      board = [[0 for i in range(n)] for j in range(n)]      for i in range(n):         for j in range(n):             board[i][j] = 1             if open_knight_tour_helper(board, (i, j), 1):                 return board             board[i][j] = 0      msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"     raise ValueError(msg)\n2: def extended_gcd(a: int, b: int) -> tuple[int, int, int]:     assert a >= 0     assert b >= 0      if b == 0:         d, x, y = a, 1, 0     else:         (d, p, q) = extended_gcd(b, a % b)         x = q         y = p - q * (a // b)      assert a % d == 0     assert b % d == 0     assert d == a * x + b * y      return (d, x, y)", "output": "0"}
{"task": "search", "input": "search code:\nencrypt_message\n\nChoices:\n0: def encrypt_message(     message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5 ) -> str:     message, alphabet, character_to_number, number_to_character = __prepare(         message, alphabet     )      encrypted_numeric = \"\"     for i in range(0, len(message) + 1, period):         encrypted_numeric += __encrypt_part(             message[i : i + period], character_to_number         )      encrypted = \"\"     for i in range(0, len(encrypted_numeric), 3):         encrypted += number_to_character[encrypted_numeric[i : i + 3]]     return encrypted\n1: def solution(number_unique_partitions: int = 5000) -> int | None:     for number_to_partition in range(1, NUM_PRIMES):         if len(partition(number_to_partition)) > number_unique_partitions:             return number_to_partition     return None\n2: def _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):     if max_rev[n] >= 0:         return max_rev[n]     elif n == 0:         return 0     else:         max_revenue = float(\"-inf\")         for i in range(1, n + 1):             max_revenue = max(                 max_revenue,                 prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),             )          max_rev[n] = max_revenue      return max_rev[n]", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - ord(\"a\")] = True\n    return all(flag)", "output": "def check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)"}
{"task": "summary", "input": "summarize code:\ndef print_exception(etype, value, tb, limit=None, file=None):\n\n    if file is None:\n        file = sys.stderr\n    if tb:\n        tbi = TracebackInfo.from_traceback(tb, limit)\n        print(str(tbi), end='', file=file)\n\n    for line in format_exception_only(etype, value):\n        print(line, end='', file=file)", "output": "Print exception up to 'limit' stack trace entries from 'tb' to 'file'."}
{"task": "summary", "input": "summarize code:\ndef update(highway_now: list, probability: float, max_speed: int) -> list:\n\n    number_of_cells = len(highway_now)\n    # Beforce calculations, the highway is empty\n    next_highway = [-1] * number_of_cells\n\n    for car_index in range(number_of_cells):\n        if highway_now[car_index] != -1:\n            # Add 1 to the current speed of the car and cap the speed\n            next_highway[car_index] = min(highway_now[car_index] + 1, max_speed)\n            # Number of empty cell before the next car\n            dn = get_distance(highway_now, car_index) - 1\n            # We can't have the car causing an accident\n            next_highway[car_index] = min(next_highway[car_index], dn)\n            if random() < probability:\n                # Randomly, a driver will slow down\n                next_highway[car_index] = max(next_highway[car_index] - 1, 0)\n    return next_highway", "output": "Update the speed of the cars"}
{"task": "summary", "input": "summarize code:\ndef solution(num: int = 100) -> int:\n    return sum(int(x) for x in str(factorial(num)))", "output": "Returns the sum of the digits in the factorial of num"}
{"task": "search", "input": "search code:\nFind all the valid positions a knight can move to from the current position.\n\nChoices:\n0: def linear_regression_prediction(     train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list ) -> float:     x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])     y = np.array(train_usr)     beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)     return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])\n1: def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:      y, x = position     positions = [         (y + 1, x + 2),         (y - 1, x + 2),         (y + 1, x - 2),         (y - 1, x - 2),         (y + 2, x + 1),         (y + 2, x - 1),         (y - 2, x + 1),         (y - 2, x - 1),     ]     permissible_positions = []      for inner_position in positions:         y_test, x_test = inner_position         if 0 <= y_test < n and 0 <= x_test < n:             permissible_positions.append(inner_position)      return permissible_positions\n2: def prefix_function(input_string: str) -> list:      # list for the result values     prefix_result = [0] * len(input_string)      for i in range(1, len(input_string)):         # use last results for better performance - dynamic programming         j = prefix_result[i - 1]         while j > 0 and input_string[i] != input_string[j]:             j = prefix_result[j - 1]          if input_string[i] == input_string[j]:             j += 1         prefix_result[i] = j      return prefix_result", "output": "1"}
{"task": "search", "input": "search code:\nReturn the sigmoid function of a float.\n\nChoices:\n0: def sigmoid_function(value: float, deriv: bool = False) -> float:     if deriv:         return value * (1 - value)     return 1 / (1 + math.exp(-value))\n1: def nth_combination_with_replacement(iterable, r, index):     pool = tuple(iterable)     n = len(pool)     if (r < 0) or (r > n):         raise ValueError      c = comb(n + r - 1, r)      if index < 0:         index += c      if (index < 0) or (index >= c):         raise IndexError      result = []     i = 0     while r:         r -= 1         while n >= 0:             num_combs = comb(n + r - 1, r)             if index < num_combs:                 break             n -= 1             i += 1             index -= num_combs         result.append(pool[i])      return tuple(result)\n2: def area_under_curve_estimator(     iterations: int,     function_to_integrate: Callable[[float], float],     min_value: float = 0.0,     max_value: float = 1.0, ) -> float:      return mean(         function_to_integrate(uniform(min_value, max_value)) for _ in range(iterations)     ) * (max_value - min_value)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef password_generator(length: int = 8) -> str:\n    chars = ascii_letters + digits + punctuation\n    return \"\".join(secrets.choice(chars) for _ in range(length))", "output": "Password Generator allows you to generate a random password of length N."}
{"task": "summary", "input": "summarize code:\ndef bisection(function: Callable[[float], float], a: float, b: float) -> float:\n    start: float = a\n    end: float = b\n    if function(a) == 0:  # one of the a or b is a root for the function\n        return a\n    elif function(b) == 0:\n        return b\n    elif (\n        function(a) * function(b) > 0\n    ):  # if none of these are root and they are both positive or negative,\n        # then this algorithm can't find the root\n        raise ValueError(\"could not find root in given interval.\")\n    else:\n        mid: float = start + (end - start) / 2.0\n        while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7\n            if function(mid) == 0:\n                return mid\n            elif function(mid) * function(start) < 0:\n                end = mid\n            else:\n                start = mid\n            mid = start + (end - start) / 2.0\n        return mid", "output": "finds where function becomes 0 in [a,b] using bolzano"}
{"task": "summary", "input": "summarize code:\ndef exponential_moving_average(\n    stock_prices: Iterator[float], window_size: int\n) -> Iterator[float]:\n\n    if window_size <= 0:\n        raise ValueError(\"window_size must be > 0\")\n\n    # Calculating smoothing factor\n    alpha = 2 / (1 + window_size)\n\n    # Exponential average at timestamp t\n    moving_average = 0.0\n\n    for i, stock_price in enumerate(stock_prices):\n        if i <= window_size:\n            # Assigning simple moving average till the window_size for the first time\n            # is reached\n            moving_average = (moving_average + stock_price) * 0.5 if i else stock_price\n        else:\n            # Calculating exponential moving average based on current timestamp data\n            # point and previous exponential average value\n            moving_average = (alpha * stock_price) + ((1 - alpha) * moving_average)\n        yield moving_average", "output": "Yields exponential moving averages of the given stock prices."}
{"task": "summary", "input": "summarize code:\ndef check_validity(number_of_bands: int, colors: list) -> bool:\n    if number_of_bands >= 3 and number_of_bands <= 6:\n        if number_of_bands == len(colors):\n            for color in colors:\n                if color not in valid_colors:\n                    msg = f\"{color} is not a valid color\"\n                    raise ValueError(msg)\n            return True\n        else:\n            msg = f\"Expecting {number_of_bands} colors, provided {len(colors)} colors\"\n            raise ValueError(msg)\n    else:\n        msg = \"Invalid number of bands. Resistor bands must be 3 to 6\"\n        raise ValueError(msg)", "output": "Function checks if the input provided is valid or not."}
{"task": "detection", "input": "classify code:\ndef largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up approach.\n\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n    0\n\n    \"\"\"\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCeq = C1 + C2 + ... + Cn\n\nChoices:\n0: def calculate_turn_around_time(     process_name: list, arrival_time: list, burst_time: list, no_of_process: int ) -> list:      current_time = 0     # Number of processes finished     finished_process_count = 0     # Displays the finished process.     # If it is 0, the performance is completed if it is 1, before the performance.     finished_process = [0] * no_of_process     # List to include calculation results     turn_around_time = [0] * no_of_process      # Sort by arrival time.     burst_time = [burst_time[i] for i in np.argsort(arrival_time)]     process_name = [process_name[i] for i in np.argsort(arrival_time)]     arrival_time.sort()      while no_of_process > finished_process_count:         i = 0         while finished_process[i] == 1:             i += 1         current_time = max(current_time, arrival_time[i])          response_ratio = 0         # Index showing the location of the process being performed         loc = 0         # Saves the current response ratio.         temp = 0         for i in range(no_of_process):             if finished_process[i] == 0 and arrival_time[i] <= current_time:                 temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[                     i                 ]             if response_ratio < temp:                 response_ratio = temp                 loc = i          # Calculate the turn around time         turn_around_time[loc] = current_time + burst_time[loc] - arrival_time[loc]         current_time += burst_time[loc]         # Indicates that the process has been performed.         finished_process[loc] = 1         # Increase finished_process_count by 1         finished_process_count += 1      return turn_around_time\n1: def largest_square_area_in_matrix_bottom_up(     rows: int, cols: int, mat: list[list[int]] ) -> int:     dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]     largest_square_area = 0     for row in range(rows - 1, -1, -1):         for col in range(cols - 1, -1, -1):             right = dp_array[row][col + 1]             diagonal = dp_array[row + 1][col + 1]             bottom = dp_array[row + 1][col]              if mat[row][col] == 1:                 dp_array[row][col] = 1 + min(right, diagonal, bottom)                 largest_square_area = max(dp_array[row][col], largest_square_area)             else:                 dp_array[row][col] = 0      return largest_square_area\n2: def capacitor_parallel(capacitors: list[float]) -> float:     sum_c = 0.0     for index, capacitor in enumerate(capacitors):         if capacitor < 0:             msg = f\"Capacitor at index {index} has a negative value!\"             raise ValueError(msg)         sum_c += capacitor     return sum_c", "output": "2"}
{"task": "search", "input": "search code:\nReturn a list of all primes numbers up to max.\n\nChoices:\n0: def slow_primes(max_n: int) -> Generator[int]:     numbers: Generator = (i for i in range(1, (max_n + 1)))     for i in (n for n in numbers if n > 1):         for j in range(2, i):             if (i % j) == 0:                 break         else:             yield i\n1: def parse_int_list(range_string, delim=',', range_delim='-'):     output = []      for x in range_string.strip().split(delim):          # Range         if range_delim in x:             range_limits = list(map(int, x.split(range_delim)))             output += list(range(min(range_limits), max(range_limits)+1))          # Empty String         elif not x:             continue          # Integer         else:             output.append(int(x))      return sorted(output)\n2: def solution(num: int = 100) -> int:     fact = 1     result = 0     for i in range(1, num + 1):         fact *= i      for j in str(fact):         result += int(j)      return result", "output": "0"}
{"task": "search", "input": "search code:\nYield median of values in a sliding window.\n\nChoices:\n0: def _is_scalar(value, stringlike=(str, bytes)):     \"Scalars are bytes, strings, and non-iterables.\"     try:         iter(value)     except TypeError:         return True     return isinstance(value, stringlike)\n1: def _running_median_windowed(iterator, maxlen):     \"Yield median of values in a sliding window.\"      window = deque()     ordered = []      for x in iterator:         window.append(x)         insort(ordered, x)          if len(ordered) > maxlen:             i = bisect_left(ordered, window.popleft())             del ordered[i]          n = len(ordered)         m = n // 2         yield ordered[m] if n & 1 else (ordered[m - 1] + ordered[m]) / 2\n2: def check_cycle(graph: dict) -> bool:     # Keep track of visited nodes     visited: set[int] = set()     # To detect a back edge, keep track of vertices currently in the recursion stack     rec_stk: set[int] = set()     return any(         node not in visited and depth_first_search(graph, node, visited, rec_stk)         for node in graph     )", "output": "1"}
{"task": "search", "input": "search code:\nProvides the derivative value of the sigmoid function.\n\nChoices:\n0: def sigmoid_derivative(value: np.ndarray) -> np.ndarray:     return (value) * (1 - (value))\n1: def transpose(it):     return zip(*it, strict=True)\n2: def ugly_numbers(n: int) -> int:     ugly_nums = [1]      i2, i3, i5 = 0, 0, 0     next_2 = ugly_nums[i2] * 2     next_3 = ugly_nums[i3] * 3     next_5 = ugly_nums[i5] * 5      for _ in range(1, n):         next_num = min(next_2, next_3, next_5)         ugly_nums.append(next_num)         if next_num == next_2:             i2 += 1             next_2 = ugly_nums[i2] * 2         if next_num == next_3:             i3 += 1             next_3 = ugly_nums[i3] * 3         if next_num == next_5:             i5 += 1             next_5 = ugly_nums[i5] * 5     return ugly_nums[-1]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef dilation(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:\n    output = np.zeros_like(image)\n    image_padded = np.zeros(\n        (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)\n    )\n\n    # Copy image to padded image\n    image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image\n\n    # Iterate over image & apply kernel\n    for x in range(image.shape[1]):\n        for y in range(image.shape[0]):\n            summation = (\n                kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]\n            ).sum()\n            output[y, x] = int(summation > 0)\n    return output", "output": "Return dilated image"}
{"task": "summary", "input": "summarize code:\ndef solution(num_terms: int = 60, max_start: int = 1000000) -> int:\n    return sum(1 for i in range(1, max_start) if chain_length(i) == num_terms)", "output": "Return the number of chains with a starting number below one million which"}
{"task": "summary", "input": "summarize code:\ndef from_file(filename, sep=\"\\n\"):\n    \"Parse a file into a list of strings, separated by sep.\"\n    with open(filename) as file:\n        return file.read().strip().split(sep)", "output": "Parse a file into a list of strings, separated by sep."}
{"task": "search", "input": "search code:\nGroup values in the *src* iterable by the value returned by *key*.\n\nChoices:\n0: def chunked(iterable, n, strict=False):     iterator = iter(partial(take, n, iter(iterable)), [])     if strict:         if n is None:             raise ValueError('n must not be None when using strict mode.')          def ret():             for chunk in iterator:                 if len(chunk) != n:                     raise ValueError('iterable is not divisible by n.')                 yield chunk          return ret()     else:         return iterator\n1: def bucketize(src, key=bool, value_transform=None, key_filter=None):     if not is_iterable(src):         raise TypeError('expected an iterable')     elif isinstance(key, list):         if len(key) != len(src):             raise ValueError(\"key and src have to be the same length\")         src = zip(key, src)      if isinstance(key, str):         def key_func(x): return getattr(x, key, x)     elif callable(key):         key_func = key     elif isinstance(key, list):         def key_func(x): return x[0]     else:         raise TypeError('expected key to be callable or a string or a list')      if value_transform is None:         def value_transform(x): return x     if not callable(value_transform):         raise TypeError('expected callable value transform function')     if isinstance(key, list):         f = value_transform         def value_transform(x): return f(x[1])      ret = {}     for val in src:         key_of_val = key_func(val)         if key_filter is None or key_filter(key_of_val):             ret.setdefault(key_of_val, []).append(value_transform(val))     return ret\n2: def find_set(x: Node) -> Node:     if x != x.parent:         x.parent = find_set(x.parent)     return x.parent", "output": "1"}
{"task": "detection", "input": "classify code:\ndef dp_count(S, m, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 3, 4)\n    4\n    >>> dp_count([1, 2, 3], 3, 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 4, 10)\n    5\n    >>> dp_count([10], 1, 99)\n    0\n    >>> dp_count([4, 5, 6], 3, 0)\n    1\n    \"\"\"\n\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in S:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions", "output": "def get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions"}
{"task": "search", "input": "search code:\nGenerates *size*-sized chunks from *src* iterable. Unless the\n\nChoices:\n0: def chunked_iter(src, size, **kw):     # TODO: add count kwarg?     if not is_iterable(src):         raise TypeError('expected an iterable')     size = _validate_positive_int(size, 'chunk size')     do_fill = True     try:         fill_val = kw.pop('fill')     except KeyError:         do_fill = False         fill_val = None     if kw:         raise ValueError('got unexpected keyword arguments: %r' % kw.keys())     if not src:         return      def postprocess(chk): return chk     if isinstance(src, (str, bytes)):         def postprocess(chk, _sep=type(src)()): return _sep.join(chk)         if isinstance(src, bytes):             def postprocess(chk): return bytes(chk)     src_iter = iter(src)     while True:         cur_chunk = list(itertools.islice(src_iter, size))         if not cur_chunk:             break         lc = len(cur_chunk)         if lc < size and do_fill:             cur_chunk[lc:] = [fill_val] * (size - lc)         yield postprocess(cur_chunk)     return\n1: def solution(nth: int = 10001) -> int:      try:         nth = int(nth)     except (TypeError, ValueError):         raise TypeError(\"Parameter nth must be int or castable to int.\") from None     if nth <= 0:         raise ValueError(\"Parameter nth must be greater than or equal to one.\")     primes: list[int] = []     num = 2     while len(primes) < nth:         if is_prime(num):             primes.append(num)             num += 1         else:             num += 1     return primes[len(primes) - 1]\n2: def natural_sort(input_list: list[str]) -> list[str]:      def alphanum_key(key):         return [int(s) if s.isdigit() else s.lower() for s in re.split(\"([0-9]+)\", key)]      return sorted(input_list, key=alphanum_key)", "output": "0"}
{"task": "search", "input": "search code:\nThis function creates an ordered list of n length as requested, and afterwards\n\nChoices:\n0: def hamming(n_element: int) -> list:     n_element = int(n_element)     if n_element < 1:         my_error = ValueError(\"n_element should be a positive number\")         raise my_error      hamming_list = [1]     i, j, k = (0, 0, 0)     index = 1     while index < n_element:         while hamming_list[i] * 2 <= hamming_list[-1]:             i += 1         while hamming_list[j] * 3 <= hamming_list[-1]:             j += 1         while hamming_list[k] * 5 <= hamming_list[-1]:             k += 1         hamming_list.append(             min(hamming_list[i] * 2, hamming_list[j] * 3, hamming_list[k] * 5)         )         index += 1     return hamming_list\n1: def is_magic_gon(numbers: list[int]) -> bool:     if len(numbers) % 3 != 0:         raise ValueError(\"a gon ring should have a length that is a multiple of 3\")      if min(numbers[::3]) != numbers[0]:         return False      total = sum(numbers[:3])      return all(sum(numbers[i : i + 3]) == total for i in range(3, len(numbers), 3))\n2: def digital_differential_analyzer_line(     p1: tuple[int, int], p2: tuple[int, int] ) -> list[tuple[int, int]]:     x1, y1 = p1     x2, y2 = p2     dx = x2 - x1     dy = y2 - y1     steps = max(abs(dx), abs(dy))     x_increment = dx / float(steps)     y_increment = dy / float(steps)     coordinates = []     x: float = x1     y: float = y1     for _ in range(steps):         x += x_increment         y += y_increment         coordinates.append((round(x), round(y)))     return coordinates", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway", "output": "Build the highway following the parameters given"}
{"task": "summary", "input": "summarize code:\ndef breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:\n    visited = {start}\n    result = [start]\n    queue = deque([start])\n    while queue:\n        v = queue.popleft()\n        for child in graph[v]:\n            if child not in visited:\n                visited.add(child)\n                result.append(child)\n                queue.append(child)\n    return result", "output": "Implementation of breadth first search using collection.queue."}
{"task": "search", "input": "search code:\nReturns numerical pattern of character appearances in given word\n\nChoices:\n0: def gravitational_law(     force: float, mass_1: float, mass_2: float, distance: float ) -> dict[str, float]:      product_of_mass = mass_1 * mass_2      if (force, mass_1, mass_2, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if force < 0:         raise ValueError(\"Gravitational force can not be negative\")     if distance < 0:         raise ValueError(\"Distance can not be negative\")     if mass_1 < 0 or mass_2 < 0:         raise ValueError(\"Mass can not be negative\")     if force == 0:         force = GRAVITATIONAL_CONSTANT * product_of_mass / (distance**2)         return {\"force\": force}     elif mass_1 == 0:         mass_1 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_2)         return {\"mass_1\": mass_1}     elif mass_2 == 0:         mass_2 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_1)         return {\"mass_2\": mass_2}     elif distance == 0:         distance = (GRAVITATIONAL_CONSTANT * product_of_mass / (force)) ** 0.5         return {\"distance\": distance}     raise ValueError(\"One and only one argument must be 0\")\n1: def solution(n: int = 1000) -> int:     # number of letters in zero, one, two, ..., nineteen (0 for zero since it's     # never said aloud)     ones_counts = [0, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6, 6, 8, 8, 7, 7, 9, 8, 8]     # number of letters in twenty, thirty, ..., ninety (0 for numbers less than     # 20 due to inconsistency in teens)     tens_counts = [0, 0, 6, 6, 5, 5, 5, 7, 6, 6]      count = 0      for i in range(1, n + 1):         if i < 1000:             if i >= 100:                 # add number of letters for \"n hundred\"                 count += ones_counts[i // 100] + 7                  if i % 100 != 0:                     # add number of letters for \"and\" if number is not multiple                     # of 100                     count += 3              if 0 < i % 100 < 20:                 # add number of letters for one, two, three, ..., nineteen                 # (could be combined with below if not for inconsistency in                 # teens)                 count += ones_counts[i % 100]             else:                 # add number of letters for twenty, twenty one, ..., ninety                 # nine                 count += ones_counts[i % 10]                 count += tens_counts[(i % 100 - i % 10) // 10]         else:             count += ones_counts[i // 1000] + 8     return count\n2: def get_word_pattern(word: str) -> str:     word = word.upper()     next_num = 0     letter_nums = {}     word_pattern = []      for letter in word:         if letter not in letter_nums:             letter_nums[letter] = str(next_num)             next_num += 1         word_pattern.append(letter_nums[letter])     return \".\".join(word_pattern)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway", "output": "def construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway"}
{"task": "detection", "input": "classify code:\ndef min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef audio_frames(\n    audio: np.ndarray,\n    sample_rate: int,\n    hop_length: int = 20,\n    ftt_size: int = 1024,\n) -> np.ndarray:\n\n    hop_size = np.round(sample_rate * hop_length / 1000).astype(int)\n\n    # Pad the audio signal to handle edge cases\n    audio = np.pad(audio, int(ftt_size / 2), mode=\"reflect\")\n\n    # Calculate the number of frames\n    frame_count = int((len(audio) - ftt_size) / hop_size) + 1\n\n    # Initialize an array to store the frames\n    frames = np.zeros((frame_count, ftt_size))\n\n    # Split the audio signal into frames\n    for n in range(frame_count):\n        frames[n] = audio[n * hop_size : n * hop_size + ftt_size]\n\n    return frames", "output": "Split an audio signal into overlapping frames."}
{"task": "search", "input": "search code:\nThis function returns a tuple of gas stations.\n\nChoices:\n0: def get_gas_stations(     gas_quantities: list[int], costs: list[int] ) -> tuple[GasStation, ...]:     return tuple(         GasStation(quantity, cost) for quantity, cost in zip(gas_quantities, costs)     )\n1: def pretty_print(n):     if n <= 0:         return \"       ...       ....        nothing printing :(\"     upper_half = floyd(n)  # upper half     lower_half = reverse_floyd(n)  # lower half     return upper_half + lower_half\n2: def right_rotation(node: MyNode) -> MyNode:     print(\"left rotation node:\", node.get_data())     ret = node.get_left()     assert ret is not None     node.set_left(ret.get_right())     ret.set_right(node)     h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1     node.set_height(h1)     h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1     ret.set_height(h2)     return ret", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef fib_recursive(n: int) -> list[int]:\n\n    def fib_recursive_term(i: int) -> int:\n        if i < 0:\n            raise ValueError(\"n is negative\")\n        if i < 2:\n            return i\n        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)\n\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    return [fib_recursive_term(i) for i in range(n + 1)]", "output": "Calculates the first n (0-indexed) Fibonacci numbers using recursion"}
{"task": "search", "input": "search code:\nReturns the nth number of the Fibonacci sequence that\n\nChoices:\n0: def simple_fibonacci(n, f1, f2):     # Trivial Cases     if n == 1:         return f1     elif n == 2:         return f2      n -= 2      while n > 0:         f2, f1 = f1 + f2, f2         n -= 1      return f2\n1: def hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:      # Initialize path with -1, indicating that we have not visited them yet     path = [-1] * (len(graph) + 1)     # initialize start and end of path with starting index     path[0] = path[-1] = start_index     # evaluate and if we find answer return path either return empty array     return path if util_hamilton_cycle(graph, path, 1) else []\n2: def surface_area_cube(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"surface_area_cube() only accepts non-negative values\")     return 6 * side_length**2", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef astable_duty_cycle(resistance_1: float, resistance_2: float) -> float:\n\n    if resistance_1 <= 0 or resistance_2 <= 0:\n        raise ValueError(\"All values must be positive\")\n    return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100", "output": "Usage examples:"}
{"task": "summary", "input": "summarize code:\ndef default_matrix_multiplication(a: list, b: list) -> list:\n    if len(a) != 2 or len(a[0]) != 2 or len(b) != 2 or len(b[0]) != 2:\n        raise Exception(\"Matrices are not 2x2\")\n    new_matrix = [\n        [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n        [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]],\n    ]\n    return new_matrix", "output": "Multiplication only for 2x2 matrices"}
{"task": "detection", "input": "classify code:\ndef mel_to_freq(mels: float) -> float:\n    \"\"\"\n    Convert a frequency in the mel scale to Hertz.\n\n    Args:\n        mels: The frequency in mel scale.\n\n    Returns:\n        The frequency in Hertz.\n\n    Examples:\n    >>> round(mel_to_freq(999.99), 2)\n    1000.01\n    \"\"\"\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2", "output": "CORRECT"}
{"task": "search", "input": "search code:\nUtility-function to check that two hsv-colors are approximately equal\n\nChoices:\n0: def approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:     check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2     check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002     check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002      return check_hue and check_saturation and check_value\n1: def euler_phi(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = n     for x in set(prime_factors(n)):         s *= (x - 1) / x     return int(s)\n2: def iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:     vectors = initial_vectors     for _ in range(steps):         vectors = iteration_step(vectors)     return vectors", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef is_pentagonal(n: int) -> bool:\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0", "output": "Returns True if n is pentagonal, False otherwise."}
{"task": "summary", "input": "summarize code:\ndef minimum_squares_to_represent_a_number(number: int) -> int:\n    if number != int(number):\n        raise ValueError(\"the value of input must be a natural number\")\n    if number < 0:\n        raise ValueError(\"the value of input must not be a negative number\")\n    if number == 0:\n        return 1\n    answers = [-1] * (number + 1)\n    answers[0] = 0\n    for i in range(1, number + 1):\n        answer = sys.maxsize\n        root = int(math.sqrt(i))\n        for j in range(1, root + 1):\n            current_answer = 1 + answers[i - (j**2)]\n            answer = min(answer, current_answer)\n        answers[i] = answer\n    return answers[number]", "output": "Count the number of minimum squares to represent a number"}
{"task": "summary", "input": "summarize code:\ndef sum_of_digit_factorial(n: int) -> int:\n    return sum(DIGIT_FACTORIAL[d] for d in str(n))", "output": "Returns the sum of the factorial of digits in n"}
{"task": "summary", "input": "summarize code:\ndef parse_grid(grid):\n    ## To start, every square can be any digit; then assign values from the grid.\n    values = dict.fromkeys(squares, digits)\n    for s, d in grid_values(grid).items():\n        if d in digits and not assign(values, s, d):\n            return False  ## (Fail if we can't assign d to square s.)\n    return values", "output": "Convert grid to a dict of possible values, {square: digits}, or"}
{"task": "summary", "input": "summarize code:\ndef reverse_words(input_str: str) -> str:\n    return \" \".join(input_str.split()[::-1])", "output": "Reverses words in a given string"}
{"task": "summary", "input": "summarize code:\ndef vol_cuboid(width: float, height: float, length: float) -> float:\n    if width < 0 or height < 0 or length < 0:\n        raise ValueError(\"vol_cuboid() only accepts non-negative values\")\n    return float(width * height * length)", "output": "Calculate the Volume of a Cuboid."}
{"task": "summary", "input": "summarize code:\ndef iter_splitlines(text):\n    prev_end, len_text = 0, len(text)\n    # print('last: %r' % last_idx)\n    # start, end = None, None\n    for match in _line_ending_re.finditer(text):\n        start, end = match.start(1), match.end(1)\n        # print(start, end)\n        if prev_end <= start:\n            yield text[prev_end:start]\n        if end == len_text:\n            yield ''\n        prev_end = end\n    tail = text[prev_end:]\n    if tail:\n        yield tail\n    return", "output": "Like :meth:`str.splitlines`, but returns an iterator of lines"}
{"task": "search", "input": "search code:\nReturns True if n is pentagonal, False otherwise.\n\nChoices:\n0: def is_pentagonal(n: int) -> bool:     root = (1 + 24 * n) ** 0.5     return ((1 + root) / 6) % 1 == 0\n1: def solution(num: int = 100) -> int:     fact = 1     result = 0     for i in range(1, num + 1):         fact *= i      for j in str(fact):         result += int(j)      return result\n2: def perfect_square(num: int) -> bool:     return math.sqrt(num) * math.sqrt(num) == num", "output": "0"}
{"task": "search", "input": "search code:\nLike :meth:`str.splitlines`, but returns an iterator of lines\n\nChoices:\n0: def split(root: Node | None, value: int) -> tuple[Node | None, Node | None]:     if root is None or root.value is None:  # None tree is split into 2 Nones         return None, None     elif value < root.value:         left, root.left = split(root.left, value)         return left, root     else:         root.right, right = split(root.right, value)         return root, right\n1: def outer_product(func, xs, ys, *args, **kwargs):     ys = tuple(ys)     return batched(         starmap(lambda x, y: func(x, y, *args, **kwargs), product(xs, ys)),         n=len(ys),     )\n2: def iter_splitlines(text):     prev_end, len_text = 0, len(text)     # print('last: %r' % last_idx)     # start, end = None, None     for match in _line_ending_re.finditer(text):         start, end = match.start(1), match.end(1)         # print(start, end)         if prev_end <= start:             yield text[prev_end:start]         if end == len_text:             yield ''         prev_end = end     tail = text[prev_end:]     if tail:         yield tail     return", "output": "2"}
{"task": "search", "input": "search code:\nnormalize args and raise type-error if there is a problem\n\nChoices:\n0: def snake_to_camel_case(input_str: str, use_pascal: bool = False) -> str:      if not isinstance(input_str, str):         msg = f\"Expected string as input, found {type(input_str)}\"         raise ValueError(msg)     if not isinstance(use_pascal, bool):         msg = f\"Expected boolean as use_pascal parameter, found {type(use_pascal)}\"         raise ValueError(msg)      words = input_str.split(\"_\")      start_index = 0 if use_pascal else 1      words_to_capitalize = words[start_index:]      capitalized_words = [word[0].upper() + word[1:] for word in words_to_capitalize]      initial_word = \"\" if use_pascal else words[0]      return \"\".join([initial_word, *capitalized_words])\n1: def solution(limit: int = 1000000) -> int:     answer = 0      for outer_width in range(3, (limit // 4) + 2):         if outer_width**2 > limit:             hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)         else:             hole_width_lower_bound = 1         if (outer_width - hole_width_lower_bound) % 2:             hole_width_lower_bound += 1          answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1      return answer\n2: def _norm_args_typeerror(other):     if type(other) in (set, frozenset):         inc, exc = other, None     elif type(other) is _ComplementSet:         inc, exc = other._included, other._excluded     else:         raise TypeError('argument must be another set or complement(set)')     return inc, exc", "output": "2"}
{"task": "search", "input": "search code:\nVariant of itertools.tee() but with guaranteed threading semantics.\n\nChoices:\n0: def concurrent_tee(iterable, n=2):      if n < 0:         raise ValueError     if n == 0:         return ()     iterator = _concurrent_tee(iterable)     result = [iterator]     for _ in range(n - 1):         result.append(_concurrent_tee(iterator))     return tuple(result)\n1: def mf_knapsack(i, wt, val, j):     global f  # a global dp table for knapsack     if f[i][j] < 0:         if j < wt[i - 1]:             val = mf_knapsack(i - 1, wt, val, j)         else:             val = max(                 mf_knapsack(i - 1, wt, val, j),                 mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],             )         f[i][j] = val     return f[i][j]\n2: def solution(n: int = 10000) -> int:     count_odd_periods = 0     for i in range(2, n + 1):         sr = sqrt(i)         if sr - floor(sr) != 0 and continuous_fraction_period(i) % 2 == 1:             count_odd_periods += 1     return count_odd_periods", "output": "0"}
{"task": "detection", "input": "classify code:\ndef comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef get_format_args(fstr):\n    # TODO: memoize\n    formatter = Formatter()\n    fargs, fkwargs, _dedup = [], [], set()\n\n    def _add_arg(argname, type_char='s'):\n        if argname not in _dedup:\n            _dedup.add(argname)\n            argtype = _TYPE_MAP.get(type_char, str)  # TODO: unicode\n            try:\n                fargs.append((int(argname), argtype))\n            except ValueError:\n                fkwargs.append((argname, argtype))\n\n    for lit, fname, fspec, conv in formatter.parse(fstr):\n        if fname is not None:\n            type_char = fspec[-1:]\n            fname_list = re.split('[.[]', fname)\n            if len(fname_list) > 1:\n                raise ValueError('encountered compound format arg: %r' % fname)\n            try:\n                base_fname = fname_list[0]\n                assert base_fname\n            except (IndexError, AssertionError):\n                raise ValueError('encountered anonymous positional argument')\n            _add_arg(fname, type_char)\n            for sublit, subfname, _, _ in formatter.parse(fspec):\n                # TODO: positional and anon args not allowed here.\n                if subfname is not None:\n                    _add_arg(subfname)\n    return fargs, fkwargs", "output": "Turn a format string into two lists of arguments referenced by the"}
{"task": "detection", "input": "classify code:\ndef optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit", "output": "def max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit"}
{"task": "search", "input": "search code:\nShuffles the character of a string by placing each of them\n\nChoices:\n0: def _extract_monotonic(iterator, indices):     'Non-decreasing indices, lazily consumed'     num_read = 0     for index in indices:         advance = index - num_read         try:             value = next(islice(iterator, advance, None))         except ValueError:             if advance != -1 or index < 0:                 raise ValueError(f'Invalid index: {index}') from None         except StopIteration:             raise IndexError(index) from None         else:             num_read += advance + 1         yield value\n1: def knuth_morris_pratt(text: str, pattern: str) -> int:      # 1) Construct the failure array     failure = get_failure_array(pattern)      # 2) Step through text searching for pattern     i, j = 0, 0  # index into text, pattern     while i < len(text):         if pattern[j] == text[i]:             if j == (len(pattern) - 1):                 return i - j             j += 1          # if this is a prefix in our pattern         # just go back far enough to continue         elif j > 0:             j = failure[j - 1]             continue         i += 1     return -1\n2: def encrypt(input_string: str, key: int) -> str:     temp_grid: list[list[str]] = [[] for _ in range(key)]     lowest = key - 1      if key <= 0:         raise ValueError(\"Height of grid can't be 0 or negative\")     if key == 1 or len(input_string) <= key:         return input_string      for position, character in enumerate(input_string):         num = position % (lowest * 2)  # puts it in bounds         num = min(num, lowest * 2 - num)  # creates zigzag pattern         temp_grid[num].append(character)     grid = [\"\".join(row) for row in temp_grid]     output_string = \"\".join(grid)      return output_string", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef bitap_string_match(text: str, pattern: str) -> int:\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1", "output": "Retrieves the index of the first occurrence of pattern in text."}
{"task": "detection", "input": "classify code:\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nImplements the Gaussian Error Linear Unit (GELU) function\n\nChoices:\n0: def sum_of_digits_recursion(n: int) -> int:     n = abs(n)     return n if n < 10 else n % 10 + sum_of_digits(n // 10)\n1: def avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:     arr = np.array(arr)     if arr.shape[0] != arr.shape[1]:         raise ValueError(\"The input array is not a square matrix\")     i = 0     j = 0     mat_i = 0     mat_j = 0      # compute the shape of the output matrix     avgpool_shape = (arr.shape[0] - size) // stride + 1     # initialize the output matrix with zeros of shape avgpool_shape     updated_arr = np.zeros((avgpool_shape, avgpool_shape))      while i < arr.shape[0]:         # if the end of the matrix is reached, break         if i + size > arr.shape[0]:             break         while j < arr.shape[1]:             # if the end of the matrix is reached, break             if j + size > arr.shape[1]:                 break             # compute the average of the pooling matrix             updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))             # shift the pooling matrix by stride of column pixels             j += stride             mat_j += 1          # shift the pooling matrix by stride of row pixels         i += stride         mat_i += 1         # reset the column index to 0         j = 0         mat_j = 0      return updated_arr\n2: def gaussian_error_linear_unit(vector: np.ndarray) -> np.ndarray:     return vector * sigmoid(1.702 * vector)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef y_generator(class_count: int, instance_count: list) -> list:\n    \"\"\"\n    Generate y values for corresponding classes\n    :param class_count: Number of classes(data groupings) in dataset\n    :param instance_count: number of instances in class\n    :return: corresponding values for data groupings in dataset\n\n    >>> y_generator(1, [10])\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    >>> y_generator(2, [5, 10])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    return [k for k in range(class_count) for _ in range(instance_count[k])]", "output": "BUGGY"}
{"task": "search", "input": "search code:\n``flatten()`` returns a collapsed list of all the elements from\n\nChoices:\n0: def in_static_equilibrium(     forces: NDArray[float64], location: NDArray[float64], eps: float = 10**-1 ) -> bool:     # summation of moments is zero     moments: NDArray[float64] = cross(location, forces)     sum_moments: float = sum(moments)     return bool(abs(sum_moments) < eps)\n1: def flatten(iterable):     return list(flatten_iter(iterable))\n2: def benchmark():     from timeit import timeit      setup = \"from __main__ import slow_primes, primes, fast_primes\"     print(timeit(\"slow_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))     print(timeit(\"primes(1_000_000_000_000)\", setup=setup, number=1_000_000))     print(timeit(\"fast_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef closing_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:\n    if kernel is None:\n        kernel = np.ones((3, 3))\n    return transform(transform(image, \"erosion\", kernel), \"dilation\", kernel)", "output": "Opening filter, defined as the sequence of"}
{"task": "search", "input": "search code:\nConvert class labels from scalars to one-hot vectors.\n\nChoices:\n0: def matrix_chain_multiply(arr: list[int]) -> int:     if len(arr) < 2:         return 0     # initialising 2D dp matrix     n = len(arr)     dp = [[maxsize for j in range(n)] for i in range(n)]     # we want minimum cost of multiplication of matrices     # of dimension (i*k) and (k*j). This cost is arr[i-1]*arr[k]*arr[j].     for i in range(n - 1, 0, -1):         for j in range(i, n):             if i == j:                 dp[i][j] = 0                 continue             for k in range(i, j):                 dp[i][j] = min(                     dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]                 )      return dp[1][n - 1]\n1: def _dense_to_one_hot(labels_dense, num_classes):     num_labels = labels_dense.shape[0]     index_offset = np.arange(num_labels) * num_classes     labels_one_hot = np.zeros((num_labels, num_classes))     labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1     return labels_one_hot\n2: def fibonacci(k: int) -> int:     if not isinstance(k, int):         raise TypeError(\"k must be an integer.\")     if k < 0:         raise ValueError(\"k integer must be greater or equal to zero.\")     if k == 0:         return 0     elif k == 1:         return 1     else:         return fibonacci(k - 1) + fibonacci(k - 2)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:\n    \"\"\"\n    Find the sum of n terms in an arithmetic progression.\n\n    >>> sum_of_series(1, 1, 10)\n    55.0\n    >>> sum_of_series(1, 10, 100)\n    49600.0\n    \"\"\"\n    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\n    # formula for sum of series\n    return total", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn bitcode of distinct_edge\n\nChoices:\n0: def log_difference(number: int) -> float:      log_number = math.log(2, 10) * number     difference = round((log_number - int(log_number)), 15)      return difference\n1: def freq_subgraphs_edge_list(paths):     freq_sub_el = []     for edges in paths:         el = []         for j in range(len(edges) - 1):             temp = list(edges[j])             for e in temp:                 edge = (e[0], e[1])                 el.append(edge)         freq_sub_el.append(el)     return freq_sub_el\n2: def get_bitcode(edge_array, distinct_edge):     bitcode = [\"0\"] * len(edge_array)     for i, row in enumerate(edge_array):         for item in row:             if distinct_edge in item[0]:                 bitcode[i] = \"1\"                 break     return \"\".join(bitcode)", "output": "2"}
{"task": "search", "input": "search code:\nReturn the number of chains with a starting number below one million which\n\nChoices:\n0: def base16_encode(data: bytes) -> str:     # Turn the data into a list of integers (where each integer is a byte),     # Then turn each byte into its hexadecimal representation, make sure     # it is uppercase, and then join everything together and return it.     return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])\n1: def solution(num_terms: int = 60, max_start: int = 1000000) -> int:     return sum(1 for i in range(1, max_start) if chain_length(i) == num_terms)\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef normalize_array(array: np.ndarray, cap: float = 1) -> np.ndarray:\n    diff = np.max(array) - np.min(array)\n    return (array - np.min(array)) / (1 if diff == 0 else diff) * cap", "output": "Normalizes a 1D array, between ranges 0-cap."}
{"task": "search", "input": "search code:\nA variant of :func:`takewhile` that allows complete access to the\n\nChoices:\n0: def before_and_after(predicate, it):     trues, after = tee(it)     trues = compress(takewhile(predicate, trues), zip(after))     return trues, after\n1: def reverse_letters(sentence: str, length: int = 0) -> str:     return \" \".join(         \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()     )\n2: def max_subarray_sum(     arr: Sequence[float], allow_empty_subarrays: bool = False ) -> float:     if not arr:         return 0      max_sum = 0 if allow_empty_subarrays else float(\"-inf\")     curr_sum = 0.0     for num in arr:         curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)         max_sum = max(max_sum, curr_sum)      return max_sum", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    return sum(turnaround_times) / len(turnaround_times)", "output": "This function calculates the average of the turnaround times"}
{"task": "search", "input": "search code:\nReturns the minimum cuts needed for a palindrome partitioning of string\n\nChoices:\n0: def astable_duty_cycle(resistance_1: float, resistance_2: float) -> float:      if resistance_1 <= 0 or resistance_2 <= 0:         raise ValueError(\"All values must be positive\")     return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100\n1: def find_minimum_partitions(string: str) -> int:     length = len(string)     cut = [0] * length     is_palindromic = [[False for i in range(length)] for j in range(length)]     for i, c in enumerate(string):         mincut = i         for j in range(i + 1):             if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):                 is_palindromic[j][i] = True                 mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))         cut[i] = mincut     return cut[length - 1]\n2: def _enforce_args(n: int, prices: list):     if n < 0:         msg = f\"n must be greater than or equal to 0. Got n = {n}\"         raise ValueError(msg)      if n > len(prices):         msg = (             \"Each integral piece of rod must have a corresponding price. \"             f\"Got n = {n} but length of prices = {len(prices)}\"         )         raise ValueError(msg)", "output": "1"}
{"task": "search", "input": "search code:\nPrint pre-order traversal of the tree.\n\nChoices:\n0: def unwrap_text(text, ending='\\n\\n'):     all_grafs = []     cur_graf = []     for line in text.splitlines():         line = line.strip()         if line:             cur_graf.append(line)         else:             all_grafs.append(' '.join(cur_graf))             cur_graf = []     if cur_graf:         all_grafs.append(' '.join(cur_graf))     if ending is None:         return all_grafs     return ending.join(all_grafs)\n1: def capacitor_series(capacitors: list[float]) -> float:      first_sum = 0.0     for index, capacitor in enumerate(capacitors):         if capacitor <= 0:             msg = f\"Capacitor at index {index} has a negative or zero value!\"             raise ValueError(msg)         first_sum += 1 / capacitor     return 1 / first_sum\n2: def print_preorder(root: Node | None) -> None:     if root:         print(root.value)         print_preorder(root.left)         print_preorder(root.right)", "output": "2"}
{"task": "search", "input": "search code:\nPrints all the words in a Trie\n\nChoices:\n0: def create_all_state(     increment: int,     total_number: int,     level: int,     current_list: list[int],     total_list: list[list[int]], ) -> None:     if level == 0:         total_list.append(current_list[:])         return      for i in range(increment, total_number - level + 2):         current_list.append(i)         create_all_state(i + 1, total_number, level - 1, current_list, total_list)         current_list.pop()\n1: def print_words(node: TrieNode, word: str) -> None:     if node.is_leaf:         print(word, end=\" \")      for key, value in node.nodes.items():         print_words(value, word + key)\n2: def butterfly_pattern(n: int) -> str:     result = []      # Upper part     for i in range(1, n):         left_stars = \"*\" * i         spaces = \" \" * (2 * (n - i) - 1)         right_stars = \"*\" * i         result.append(left_stars + spaces + right_stars)      # Middle part     result.append(\"*\" * (2 * n - 1))      # Lower part     for i in range(n - 1, 0, -1):         left_stars = \"*\" * i         spaces = \" \" * (2 * (n - i) - 1)         right_stars = \"*\" * i         result.append(left_stars + spaces + right_stars)      return \"\\n\".join(result)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef factorial(digit: int) -> int:\n    \"\"\"\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    >>> factorial(5)\n    120\n    \"\"\"\n\n    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))", "output": "def factorial(digit: int) -> int:\n    \"\"\"\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    >>> factorial(5)\n    120\n    \"\"\"\n\n    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))"}
{"task": "summary", "input": "summarize code:\ndef interpolation_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int | None = None\n) -> int | None:\n    if right is None:\n        right = len(sorted_collection) - 1\n    # avoid divided by 0 during interpolation\n    if sorted_collection[left] == sorted_collection[right]:\n        if sorted_collection[left] == item:\n            return left\n        return None\n\n    point = left + ((item - sorted_collection[left]) * (right - left)) // (\n        sorted_collection[right] - sorted_collection[left]\n    )\n\n    # out of range check\n    if point < 0 or point >= len(sorted_collection):\n        return None\n\n    if sorted_collection[point] == item:\n        return point\n    if point < left:\n        return interpolation_search_by_recursion(sorted_collection, item, point, left)\n    if point > right:\n        return interpolation_search_by_recursion(sorted_collection, item, right, left)\n    if sorted_collection[point] > item:\n        return interpolation_search_by_recursion(\n            sorted_collection, item, left, point - 1\n        )\n    return interpolation_search_by_recursion(sorted_collection, item, point + 1, right)", "output": "Pure implementation of interpolation search algorithm in Python by recursion"}
{"task": "summary", "input": "summarize code:\ndef distinct_combinations(iterable, r):\n    if r < 0:\n        raise ValueError('r must be non-negative')\n    elif r == 0:\n        yield ()\n        return\n    pool = tuple(iterable)\n    generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]\n    current_combo = [None] * r\n    level = 0\n    while generators:\n        try:\n            cur_idx, p = next(generators[-1])\n        except StopIteration:\n            generators.pop()\n            level -= 1\n            continue\n        current_combo[level] = p\n        if level + 1 == r:\n            yield tuple(current_combo)\n        else:\n            generators.append(\n                unique_everseen(\n                    enumerate(pool[cur_idx + 1 :], cur_idx + 1),\n                    key=itemgetter(1),\n                )\n            )\n            level += 1", "output": "Yield the distinct combinations of *r* items taken from *iterable*."}
{"task": "search", "input": "search code:\nReturn the mid-number(whole) of two integers a and b\n\nChoices:\n0: def get_avg(number_1: int, number_2: int) -> int:     return int((number_1 + number_2) / 2)\n1: def calculate_average_times(     waiting_time: list[int], turn_around_time: list[int], no_of_processes: int ) -> None:     total_waiting_time = 0     total_turn_around_time = 0     for i in range(no_of_processes):         total_waiting_time = total_waiting_time + waiting_time[i]         total_turn_around_time = total_turn_around_time + turn_around_time[i]     print(f\"Average waiting time = {total_waiting_time / no_of_processes:.5f}\")     print(\"Average turn around time =\", total_turn_around_time / no_of_processes)\n2: def interquartile_range_checker(train_user: list) -> float:     train_user.sort()     q1 = np.percentile(train_user, 25)     q3 = np.percentile(train_user, 75)     iqr = q3 - q1     low_lim = q1 - (iqr * 0.1)     return float(low_lim)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef sum_reverse(n: int) -> int:\n    \"\"\"\n    Returns the sum of n and reverse of n.\n    >>> sum_reverse(123)\n    444\n    >>> sum_reverse(3478)\n    12221\n    >>> sum_reverse(12)\n    33\n    \"\"\"\n    return int(n) + int(str(n)[::-1])", "output": "def sum_reverse(n: int) -> int:\n    \"\"\"\n    Returns the sum of n and reverse of n.\n    >>> sum_reverse(123)\n    444\n    >>> sum_reverse(3478)\n    12221\n    >>> sum_reverse(12)\n    33\n    \"\"\"\n    return int(n) + int(str(n)[::-1])"}
{"task": "search", "input": "search code:\nDeserialize a string to a binary tree.\n\nChoices:\n0: def deserialize(data: str) -> TreeNode | None:      if not data:         raise ValueError(\"Data cannot be empty.\")      # Split the serialized string by a comma to get node values     nodes = data.split(\",\")      def build_tree() -> TreeNode | None:         # Get the next value from the list         value = nodes.pop(0)          if value == \"null\":             return None          node = TreeNode(int(value))         node.left = build_tree()  # Recursively build left subtree         node.right = build_tree()  # Recursively build right subtree         return node      return build_tree()\n1: def avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:     arr = np.array(arr)     if arr.shape[0] != arr.shape[1]:         raise ValueError(\"The input array is not a square matrix\")     i = 0     j = 0     mat_i = 0     mat_j = 0      # compute the shape of the output matrix     avgpool_shape = (arr.shape[0] - size) // stride + 1     # initialize the output matrix with zeros of shape avgpool_shape     updated_arr = np.zeros((avgpool_shape, avgpool_shape))      while i < arr.shape[0]:         # if the end of the matrix is reached, break         if i + size > arr.shape[0]:             break         while j < arr.shape[1]:             # if the end of the matrix is reached, break             if j + size > arr.shape[1]:                 break             # compute the average of the pooling matrix             updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))             # shift the pooling matrix by stride of column pixels             j += stride             mat_j += 1          # shift the pooling matrix by stride of row pixels         i += stride         mat_i += 1         # reset the column index to 0         j = 0         mat_j = 0      return updated_arr\n2: def sigmoid_linear_unit(vector: np.ndarray) -> np.ndarray:     return vector * sigmoid(vector)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\n    \"\"\"\n    returns the list containing all the possible\n    combinations a string(`target`) can be constructed from\n    the given list of substrings(`word_bank`)\n\n    >>> all_construct(\"hello\", [\"he\", \"l\", \"o\"])\n    [['he', 'l', 'l', 'o']]\n    >>> all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"])\n    [['purp', 'le'], ['p', 'ur', 'p', 'le']]\n    \"\"\"\n\n    word_bank = word_bank or []\n    # create a table\n    table_size: int = len(target) + 1\n\n    table: list[list[list[str]]] = []\n    for _ in range(table_size):\n        table.append([])\n    # seed value\n    table[0] = [[]]  # because empty string has empty combination\n\n    # iterate through the indices\n    for i in range(table_size):\n        # condition\n        if table[i] != []:\n            for word in word_bank:\n                # slice condition\n                if target[i : i + len(word)] == word:\n                    new_combinations: list[list[str]] = [\n                        [word, *way] for way in table[i]\n                    ]\n                    # adds the word to every combination the current position holds\n                    # now,push that combination to the table[i+len(word)]\n                    table[i + len(word)] += new_combinations\n\n    # combinations are in reverse order so reverse for better output\n    for combination in table[len(target)]:\n        combination.reverse()\n\n    return table[len(target)]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nYield the index of each item in *iterable* for which *pred* returns\n\nChoices:\n0: def intersperse(e, iterable, n=1):     if n == 0:         raise ValueError('n must be > 0')     elif n == 1:         # interleave(repeat(e), iterable) -> e, x_0, e, x_1, e, x_2...         # islice(..., 1, None) -> x_0, e, x_1, e, x_2...         return islice(interleave(repeat(e), iterable), 1, None)     else:         # interleave(filler, chunks) -> [e], [x_0, x_1], [e], [x_2, x_3]...         # islice(..., 1, None) -> [x_0, x_1], [e], [x_2, x_3]...         # flatten(...) -> x_0, x_1, e, x_2, x_3...         filler = repeat([e])         chunks = chunked(iterable, n)         return flatten(islice(interleave(filler, chunks), 1, None))\n1: def jaccard_similarity(     set_a: set[str] | list[str] | tuple[str],     set_b: set[str] | list[str] | tuple[str],     alternative_union=False, ):      if isinstance(set_a, set) and isinstance(set_b, set):         intersection_length = len(set_a.intersection(set_b))          if alternative_union:             union_length = len(set_a) + len(set_b)         else:             union_length = len(set_a.union(set_b))          return intersection_length / union_length      elif isinstance(set_a, (list, tuple)) and isinstance(set_b, (list, tuple)):         intersection = [element for element in set_a if element in set_b]          if alternative_union:             return len(intersection) / (len(set_a) + len(set_b))         else:             # Cast set_a to list because tuples cannot be mutated             union = list(set_a) + [element for element in set_b if element not in set_a]             return len(intersection) / len(union)     raise ValueError(         \"Set a and b must either both be sets or be either a list or a tuple.\"     )\n2: def locate(iterable, pred=bool, window_size=None):     if window_size is None:         return compress(count(), map(pred, iterable))      if window_size < 1:         raise ValueError('window size must be at least 1')      it = windowed(iterable, window_size, fillvalue=_marker)     return compress(count(), starmap(pred, it))", "output": "2"}
{"task": "search", "input": "search code:\nPrim's Algorithm.\n\nChoices:\n0: def prim(graph: list, root: Vertex) -> list:     a = []     for u in graph:         u.key = math.inf         u.pi = None     root.key = 0     q = graph[:]     while q:         u = min(q)         q.remove(u)         for v in u.neighbors:             if (v in q) and (u.edges[v.id] < v.key):                 v.pi = u                 v.key = u.edges[v.id]     for i in range(1, len(graph)):         a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))     return a\n1: def geometric_series(     nth_term: float,     start_term_a: float,     common_ratio_r: float, ) -> list[float]:     if not all((nth_term, start_term_a, common_ratio_r)):         return []     series: list[float] = []     power = 1     multiple = common_ratio_r     for _ in range(int(nth_term)):         if not series:             series.append(start_term_a)         else:             power += 1             series.append(float(start_term_a * multiple))             multiple = pow(float(common_ratio_r), power)     return series\n2: def base64_decode(encoded_data: str) -> bytes:     # Make sure encoded_data is either a string or a bytes-like object     if not isinstance(encoded_data, bytes) and not isinstance(encoded_data, str):         msg = (             \"argument should be a bytes-like object or ASCII string, \"             f\"not '{encoded_data.__class__.__name__}'\"         )         raise TypeError(msg)      # In case encoded_data is a bytes-like object, make sure it contains only     # ASCII characters so we convert it to a string object     if isinstance(encoded_data, bytes):         try:             encoded_data = encoded_data.decode(\"utf-8\")         except UnicodeDecodeError:             raise ValueError(\"base64 encoded data should only contain ASCII characters\")      padding = encoded_data.count(\"=\")      # Check if the encoded string contains non base64 characters     if padding:         assert all(char in B64_CHARSET for char in encoded_data[:-padding]), (             \"Invalid base64 character(s) found.\"         )     else:         assert all(char in B64_CHARSET for char in encoded_data), (             \"Invalid base64 character(s) found.\"         )      # Check the padding     assert len(encoded_data) % 4 == 0 and padding < 3, \"Incorrect padding\"      if padding:         # Remove padding if there is one         encoded_data = encoded_data[:-padding]          binary_stream = \"\".join(             bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data         )[: -padding * 2]     else:         binary_stream = \"\".join(             bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data         )      data = [         int(binary_stream[index : index + 8], 2)         for index in range(0, len(binary_stream), 8)     ]      return bytes(data)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(days: int = 30) -> int:\n\n    return _calculate(days, absent=0, late=0)", "output": "Returns the number of possible prize strings for a particular number"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n    return sum(2 * a * ((a - 1) // 2) for a in range(3, n + 1))", "output": "Returns  r_max for 3 <= a <= n as explained above"}
{"task": "summary", "input": "summarize code:\ndef charging_inductor(\n    source_voltage: float,  # source_voltage should be in volts.\n    resistance: float,  # resistance should be in ohms.\n    inductance: float,  # inductance should be in henrys.\n    time: float,  # time should in seconds.\n) -> float:\n\n    if source_voltage <= 0:\n        raise ValueError(\"Source voltage must be positive.\")\n    if resistance <= 0:\n        raise ValueError(\"Resistance must be positive.\")\n    if inductance <= 0:\n        raise ValueError(\"Inductance must be positive.\")\n    return round(\n        source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3\n    )", "output": "Find inductor current at any nth second after initiating its charging."}
{"task": "search", "input": "search code:\nGiven a name, positional arguments, and keyword arguments, format\n\nChoices:\n0: def bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:     if length > 1:         middle = int(length / 2)         for i in range(low, low + middle):             comp_and_swap(array, i, i + middle, direction)         bitonic_merge(array, low, middle, direction)         bitonic_merge(array, low + middle, middle, direction)\n1: def format_invocation(name='', args=(), kwargs=None, **kw):     _repr = kw.pop('repr', repr)     if kw:         raise TypeError('unexpected keyword args: %r' % ', '.join(kw.keys()))     kwargs = kwargs or {}     a_text = ', '.join([_repr(a) for a in args])     if isinstance(kwargs, dict):         kwarg_items = [(k, kwargs[k]) for k in sorted(kwargs)]     else:         kwarg_items = kwargs     kw_text = ', '.join([f'{k}={_repr(v)}' for k, v in kwarg_items])      all_args_text = a_text     if all_args_text and kw_text:         all_args_text += ', '     all_args_text += kw_text      return f'{name}({all_args_text})'\n2: def count_inversions_bf(arr):      num_inversions = 0     n = len(arr)      for i in range(n - 1):         for j in range(i + 1, n):             if arr[i] > arr[j]:                 num_inversions += 1      return num_inversions", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef euclidean_distance_sqr(point1, point2):\n    \"\"\"\n    >>> euclidean_distance_sqr([1,2],[2,4])\n    5\n    \"\"\"\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2", "output": "def euclidean_distance_sqr(point1, point2):\n    \"\"\"\n    >>> euclidean_distance_sqr([1,2],[2,4])\n    5\n    \"\"\"\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2"}
{"task": "repair", "input": "fix bug:\ndef generate_parentheses_iterative(length: int) -> list:\n    \"\"\"\n    Generate all valid combinations of parentheses (Iterative Approach).\n\n    The algorithm works as follows:\n    1. Initialize an empty list to store the combinations.\n    2. Initialize a stack to keep track of partial combinations.\n    3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n    4. While the stack is not empty:\n        a. Pop a partial combination and its open and close counts from the stack.\n        b. If the combination length is equal to 2*length, add it to the result.\n        c. If open count < length, push new combination with added '(' on stack.\n        d. If close count < open count, push new combination with added ')' on stack.\n    5. Return the result containing all valid combinations.\n\n    Args:\n        length: The desired length of the parentheses combinations\n\n    Returns:\n        A list of strings representing valid combinations of parentheses\n\n    Time Complexity:\n        O(2^(2*length))\n\n    Space Complexity:\n        O(2^(2*length))\n\n    >>> generate_parentheses_iterative(3)\n    ['()()()', '()(())', '(())()', '(()())', '((()))']\n    >>> generate_parentheses_iterative(2)\n    ['()()', '(())']\n    >>> generate_parentheses_iterative(1)\n    ['()']\n    >>> generate_parentheses_iterative(0)\n    ['']\n    \"\"\"\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result", "output": "def generate_parentheses_iterative(length: int) -> list:\n    \"\"\"\n    Generate all valid combinations of parentheses (Iterative Approach).\n\n    The algorithm works as follows:\n    1. Initialize an empty list to store the combinations.\n    2. Initialize a stack to keep track of partial combinations.\n    3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n    4. While the stack is not empty:\n        a. Pop a partial combination and its open and close counts from the stack.\n        b. If the combination length is equal to 2*length, add it to the result.\n        c. If open count < length, push new combination with added '(' on stack.\n        d. If close count < open count, push new combination with added ')' on stack.\n    5. Return the result containing all valid combinations.\n\n    Args:\n        length: The desired length of the parentheses combinations\n\n    Returns:\n        A list of strings representing valid combinations of parentheses\n\n    Time Complexity:\n        O(2^(2*length))\n\n    Space Complexity:\n        O(2^(2*length))\n\n    >>> generate_parentheses_iterative(3)\n    ['()()()', '()(())', '(())()', '(()())', '((()))']\n    >>> generate_parentheses_iterative(2)\n    ['()()', '(())']\n    >>> generate_parentheses_iterative(1)\n    ['()']\n    >>> generate_parentheses_iterative(0)\n    ['']\n    \"\"\"\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result"}
{"task": "summary", "input": "summarize code:\ndef fractional(value):\n    try:\n        number = float(value)\n    except (TypeError, ValueError):\n        return value\n    whole_number = int(number)\n    frac = Fraction(number - whole_number).limit_denominator(1000)\n    numerator = frac._numerator\n    denominator = frac._denominator\n    if whole_number and not numerator and denominator == 1:\n        # this means that an integer was passed in\n        # (or variants of that integer like 1.0000)\n        return f\"{whole_number:.0f}\"\n    elif not whole_number:\n        return f\"{numerator:.0f}/{denominator:.0f}\"\n    else:\n        return f\"{whole_number:.0f} {numerator:.0f}/{denominator:.0f}\"", "output": "Convert to fractional number."}
{"task": "search", "input": "search code:\nTakes format strings with anonymous positional arguments, (e.g.,\n\nChoices:\n0: def infer_positional_format_args(fstr):     # TODO: memoize     ret, max_anon = '', 0     # look for {: or {! or {. or {[ or {}     start, end, prev_end = 0, 0, 0     for match in _pos_farg_re.finditer(fstr):         start, end, group = match.start(), match.end(), match.group()         if prev_end < start:             ret += fstr[prev_end:start]         prev_end = end         if group == '{{' or group == '}}':             ret += group             continue         ret += f'{{{max_anon}{group[1:]}'         max_anon += 1     ret += fstr[prev_end:]     return ret\n1: def covariance_between_classes(     features: np.ndarray, labels: np.ndarray, classes: int ) -> np.ndarray:      general_data_mean = features.mean(1)     covariance_sum = np.nan     for i in range(classes):         data = features[:, labels == i]         device_data = data.shape[1]         data_mean = data.mean(1)         if i > 0:             # If covariance_sum is not None             covariance_sum += device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )         else:             # If covariance_sum is np.nan (i.e. first loop)             covariance_sum = device_data * np.dot(                 column_reshape(data_mean) - column_reshape(general_data_mean),                 (column_reshape(data_mean) - column_reshape(general_data_mean)).T,             )      return covariance_sum / features.shape[1]\n2: def doublestarmap(func, iterable):     for item in iterable:         yield func(**item)", "output": "0"}
{"task": "search", "input": "search code:\nReturns the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and\n\nChoices:\n0: def column_reshape(input_array: np.ndarray) -> np.ndarray:      return input_array.reshape((input_array.size, 1))\n1: def vol_spheres_union(     radius_1: float, radius_2: float, centers_distance: float ) -> float:      if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:         raise ValueError(             \"vol_spheres_union() only accepts non-negative values, non-zero radius\"         )      if centers_distance == 0:         return vol_sphere(max(radius_1, radius_2))      return (         vol_sphere(radius_1)         + vol_sphere(radius_2)         - vol_spheres_intersect(radius_1, radius_2, centers_distance)     )\n2: def solution():     i = 1      while True:         if (             sorted(str(i))             == sorted(str(2 * i))             == sorted(str(3 * i))             == sorted(str(4 * i))             == sorted(str(5 * i))             == sorted(str(6 * i))         ):             return i          i += 1", "output": "2"}
{"task": "search", "input": "search code:\nRuns k-means on given data and initial set of centroids.\n\nChoices:\n0: def find_max_area(mat: list[list[int]]) -> int:     seen: set = set()      max_area = 0     for row, line in enumerate(mat):         for col, item in enumerate(line):             if item == 1 and (row, col) not in seen:                 # Maximizing the area                 max_area = max(max_area, depth_first_search(row, col, seen, mat))     return max_area\n1: def real_power(apparent_power: float, power_factor: float) -> float:     if (         not isinstance(power_factor, (int, float))         or power_factor < -1         or power_factor > 1     ):         raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")     return apparent_power * power_factor\n2: def kmeans(     data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False ):     centroids = initial_centroids[:]     prev_cluster_assignment = None      for itr in range(maxiter):         if verbose:             print(itr, end=\"\")          # 1. Make cluster assignments using nearest centroids         cluster_assignment = assign_clusters(data, centroids)          # 2. Compute a new centroid for each of the k clusters, averaging all data         #    points assigned to that cluster.         centroids = revise_centroids(data, k, cluster_assignment)          # Check for convergence: if none of the assignments changed, stop         if (             prev_cluster_assignment is not None             and (prev_cluster_assignment == cluster_assignment).all()         ):             break          # Print number of new assignments         if prev_cluster_assignment is not None:             num_changed = np.sum(prev_cluster_assignment != cluster_assignment)             if verbose:                 print(                     f\"    {num_changed:5d} elements changed their cluster assignment.\"                 )          # Record heterogeneity convergence metric         if record_heterogeneity is not None:             # YOUR CODE HERE             score = compute_heterogeneity(data, k, centroids, cluster_assignment)             record_heterogeneity.append(score)          prev_cluster_assignment = cluster_assignment[:]      return centroids, cluster_assignment", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]", "output": "Function updates the largest_square_area[0], if recursive call found"}
{"task": "search", "input": "search code:\nsecond method: Sarimax\n\nChoices:\n0: def euler_phi(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = n     for x in set(prime_factors(n)):         s *= (x - 1) / x     return int(s)\n1: def sarimax_predictor(train_user: list, train_match: list, test_match: list) -> float:     # Suppress the User Warning raised by SARIMAX due to insufficient observations     simplefilter(\"ignore\", UserWarning)     order = (1, 2, 1)     seasonal_order = (1, 1, 1, 7)     model = SARIMAX(         train_user, exog=train_match, order=order, seasonal_order=seasonal_order     )     model_fit = model.fit(disp=False, maxiter=600, method=\"nm\")     result = model_fit.predict(1, len(test_match), exog=[test_match])     return float(result[0])\n2: def split_punct_ws(text):     return [w for w in _punct_re.split(text) if w]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef smallest_range(nums: list[list[int]]) -> list[int]:\n\n    min_heap: list[tuple[int, int, int]] = []\n    current_max = -maxsize - 1\n\n    for i, items in enumerate(nums):\n        heappush(min_heap, (items[0], i, 0))\n        current_max = max(current_max, items[0])\n\n    # Initialize smallest_range with large integer values\n    smallest_range = [-maxsize - 1, maxsize]\n\n    while min_heap:\n        current_min, list_index, element_index = heappop(min_heap)\n\n        if current_max - current_min < smallest_range[1] - smallest_range[0]:\n            smallest_range = [current_min, current_max]\n\n        if element_index == len(nums[list_index]) - 1:\n            break\n\n        next_element = nums[list_index][element_index + 1]\n        heappush(min_heap, (next_element, list_index, element_index + 1))\n        current_max = max(current_max, next_element)\n\n    return smallest_range", "output": "Find the smallest range from each list in nums."}
{"task": "summary", "input": "summarize code:\ndef untyped_sorted(iterable, key=None, reverse=False):\n    class _Wrapper:\n        slots = ('obj',)\n\n        def __init__(self, obj):\n            self.obj = obj\n\n        def __lt__(self, other):\n            obj = key(self.obj) if key is not None else self.obj\n            other = key(other.obj) if key is not None else other.obj\n            try:\n                ret = obj < other\n            except TypeError:\n                ret = ((type(obj).__name__, id(type(obj)), obj)\n                       < (type(other).__name__, id(type(other)), other))\n            return ret\n\n    if key is not None and not callable(key):\n        raise TypeError('expected function or callable object for key, not: %r'\n                        % key)\n\n    return sorted(iterable, key=_Wrapper, reverse=reverse)", "output": "A version of :func:`sorted` which will happily sort an iterable of"}
{"task": "search", "input": "search code:\nCalculates the first n (0-indexed) Fibonacci numbers using memoization\n\nChoices:\n0: def combination_lists(n: int, k: int) -> list[list[int]]:     return [list(x) for x in combinations(range(1, n + 1), k)]\n1: def strip_iter(iterable, strip_value=None):     return rstrip_iter(lstrip_iter(iterable, strip_value), strip_value)\n2: def fib_memoization(n: int) -> list[int]:     if n < 0:         raise ValueError(\"n is negative\")     # Cache must be outside recursive function     # other it will reset every time it calls itself.     cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache      def rec_fn_memoized(num: int) -> int:         if num in cache:             return cache[num]          value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)         cache[num] = value         return value      return [rec_fn_memoized(i) for i in range(n + 1)]", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n\n    >>> split(\";abbb;;c;\", separator=';')\n    ['', 'abbb', '', 'c', '']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 100) -> int:\n\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)", "output": "Returns the difference between the sum of the squares of the first n"}
{"task": "summary", "input": "summarize code:\ndef is_contains_unique_chars(input_str: str) -> bool:\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True", "output": "Check if all characters in the string is unique or not."}
{"task": "summary", "input": "summarize code:\ndef manhattan_distance_one_liner(point_a: list, point_b: list) -> float:\n\n    _validate_point(point_a)\n    _validate_point(point_b)\n    if len(point_a) != len(point_b):\n        raise ValueError(\"Both points must be in the same n-dimensional space\")\n\n    return float(sum(abs(x - y) for x, y in zip(point_a, point_b)))", "output": "Version with one liner"}
{"task": "repair", "input": "fix bug:\ndef match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)", "output": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)"}
{"task": "detection", "input": "classify code:\ndef coulombs_law(q1: float, q2: float, radius: float) -> float:\n    \"\"\"\n    Calculate the electrostatic force of attraction or repulsion\n    between two point charges\n\n    >>> coulombs_law(15.5, 20, 15)\n    12382849136.06\n    >>> coulombs_law(1, 15, 5)\n    5392531075.38\n    >>> coulombs_law(20, -50, 15)\n    -39944674632.44\n    >>> coulombs_law(-5, -8, 10)\n    3595020716.92\n    >>> coulombs_law(50, 100, 50)\n    17975103584.6\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solve(board: list[list[int]], row: int) -> bool:\n    if row >= len(board):\n        solution.append(board)\n        printboard(board)\n        print()\n        return True\n    for i in range(len(board)):\n        if is_safe(board, row, i):\n            board[row][i] = 1\n            solve(board, row + 1)\n            board[row][i] = 0\n    return False", "output": "This function creates a state space tree and calls the safe function until it"}
{"task": "repair", "input": "fix bug:\ndef calc_profit(profit: list, weight: list, max_weight: int) -> Union[str, int]:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain", "output": "def calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain"}
{"task": "summary", "input": "summarize code:\ndef different_signs(num1: int, num2: int) -> bool:\n    return num1 ^ num2 < 0", "output": "Return True if numbers have opposite signs False otherwise."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000000) -> int:\n\n    result = max((collatz_sequence_length(i), i) for i in range(1, n))\n    return result[1]", "output": "Returns the number under n that generates the longest Collatz sequence."}
{"task": "search", "input": "search code:\nCalculates the first n (0-indexed) Fibonacci numbers using recursion\n\nChoices:\n0: def print_pascal_triangle(num_rows: int) -> None:     triangle = generate_pascal_triangle(num_rows)     for row_idx in range(num_rows):         # Print left spaces         for _ in range(num_rows - row_idx - 1):             print(end=\" \")         # Print row values         for col_idx in range(row_idx + 1):             if col_idx != row_idx:                 print(triangle[row_idx][col_idx], end=\" \")             else:                 print(triangle[row_idx][col_idx], end=\"\")         print()\n1: def fib_recursive(n: int) -> list[int]:      def fib_recursive_term(i: int) -> int:         if i < 0:             raise ValueError(\"n is negative\")         if i < 2:             return i         return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)      if n < 0:         raise ValueError(\"n is negative\")     return [fib_recursive_term(i) for i in range(n + 1)]\n2: def solution(n: int = 1000000):     total = 0      for i in range(1, n):         if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):             total += i     return total", "output": "1"}
{"task": "search", "input": "search code:\nCheck if three points are collinear or not.\n\nChoices:\n0: def main() -> None:     kmap = [[0, 1], [1, 1]]      # Manually generate the product of [0, 1] and [0, 1]      for row in kmap:         print(row)      print(\"Simplified Expression:\")     print(simplify_kmap(kmap))\n1: def are_collinear(a: Point3d, b: Point3d, c: Point3d, accuracy: int = 10) -> bool:     ab = create_vector(a, b)     ac = create_vector(a, c)     return is_zero_vector(get_3d_vectors_cross(ab, ac), accuracy)\n2: def calculate_fft(audio_windowed: np.ndarray, ftt_size: int = 1024) -> np.ndarray:     # Transpose the audio data to have time in rows and channels in columns     audio_transposed = np.transpose(audio_windowed)      # Initialize an array to store the FFT results     audio_fft = np.empty(         (int(1 + ftt_size // 2), audio_transposed.shape[1]),         dtype=np.complex64,         order=\"F\",     )      # Compute FFT for each channel     for n in range(audio_fft.shape[1]):         audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]      # Transpose the FFT results back to the original shape     return np.transpose(audio_fft)", "output": "1"}
{"task": "search", "input": "search code:\nSemi-intelligently converts an English plural *word* to its\n\nChoices:\n0: def trapezoidal_rule(boundary, steps):     h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 2.0) * f(a)     for i in x_i:         y += h * f(i)     y += (h / 2.0) * f(b)     return y\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def singularize(word):     orig_word, word = word, word.strip().lower()     if not word or word in _IRR_S2P:         return orig_word      irr_singular = _IRR_P2S.get(word)     if irr_singular:         singular = irr_singular     elif not word.endswith('s'):         return orig_word     elif len(word) == 2:         singular = word[:-1]  # or just return word?     elif word.endswith('ies') and word[-4:-3] not in 'aeiou':         singular = word[:-3] + 'y'     elif word.endswith('es') and word[-3] == 's':         singular = word[:-2]     else:         singular = word[:-1]     return _match_case(orig_word, singular)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef text_justification(word: str, max_width: int) -> list:\n    \"\"\"\n    Will format the string such that each line has exactly\n    (max_width) characters and is fully (left and right) justified,\n    and return the list of justified text.\n\n    example 1:\n    string = \"This is an example of text justification.\"\n    max_width = 16\n\n    output = ['This    is    an',\n              'example  of text',\n              'justification.  ']\n\n    >>> text_justification(\"This is an example of text justification.\", 16)\n    ['This    is    an', 'example  of text', 'justification.  ']\n\n    example 2:\n    string = \"Two roads diverged in a yellow wood\"\n    max_width = 16\n    output = ['Two        roads',\n              'diverged   in  a',\n              'yellow wood     ']\n\n    >>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n    ['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\n    Time complexity: O(m*n)\n    Space complexity: O(m*n)\n    \"\"\"\n\n    # Converting string into list of strings split by a space\n    words = word.split()\n\n    def justify(line: list, width: int, max_width: int) -> str:\n        overall_spaces_count = max_width - width\n        words_count = len(line)\n        if len(line) == 1:\n            # if there is only word in line\n            # just insert overall_spaces_count for the remainder of line\n            return line[0] + \" \" * overall_spaces_count\n        else:\n            spaces_to_insert_between_words = words_count - 1\n            # num_spaces_between_words_list[i] : tells you to insert\n            # num_spaces_between_words_list[i] spaces\n            # after word on line[i]\n            num_spaces_between_words_list = spaces_to_insert_between_words * [\n                overall_spaces_count // spaces_to_insert_between_words\n            ]\n            spaces_count_in_locations = (\n                overall_spaces_count % spaces_to_insert_between_words\n            )\n            # distribute spaces via round robin to the left words\n            for i in range(spaces_count_in_locations):\n                num_spaces_between_words_list[i] += 1\n            aligned_words_list = []\n            for i in range(spaces_to_insert_between_words):\n                # add the word\n                aligned_words_list.append(line[i])\n                # add the spaces to insert\n                aligned_words_list.append(num_spaces_between_words_list[i] * \" \")\n            # just add the last word to the sentence\n            aligned_words_list.append(line[-1])\n            # join the aligned words list to form a justified line\n            return \"\".join(aligned_words_list)\n\n    answer = []\n    line: list[str] = []\n    width = 0\n    for inner_word in words:\n        if width + len(inner_word) + len(line) <= max_width:\n            # keep adding words until we can fill out max_width\n            # width = sum of length of all words (without overall_spaces_count)\n            # len(inner_word) = length of current inner_word\n            # len(line) = number of overall_spaces_count to insert between words\n            line.append(inner_word)\n            width += len(inner_word)\n        else:\n            # justify the line and add it to result\n            answer.append(justify(line, width, max_width))\n            # reset new line and new width\n            line, width = [inner_word], len(inner_word)\n    remaining_spaces = max_width - width - len(line)\n    answer.append(\" \".join(line) + (remaining_spaces + 1) * \" \")\n    return answer", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns a triplet in the array with sum equal to target,\n\nChoices:\n0: def triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:     for triplet in permutations(arr, 3):         if sum(triplet) == target:             return tuple(sorted(triplet))     return (0, 0, 0)\n1: def generate_image(cells: list[list[int]]) -> Image.Image:     # Create the output image     img = Image.new(\"RGB\", (len(cells[0]), len(cells)))     pixels = img.load()     # Generates image     for w in range(img.width):         for h in range(img.height):             color = 255 - int(255 * cells[h][w])             pixels[w, h] = (color, color, color)     return img\n2: def dotproduct(vec1, vec2):     return sum(map(mul, vec1, vec2))", "output": "0"}
{"task": "search", "input": "search code:\nCalculate given class mean\n\nChoices:\n0: def calculate_mean(instance_count: int, items: list) -> float:     # the sum of all items divided by number of instances     return sum(items) / instance_count\n1: def evaluate(expression):     stack = []      # iterate over the string in reverse order     for c in expression.split()[::-1]:         # push operand to stack         if is_operand(c):             stack.append(int(c))          else:             # pop values from stack can calculate the result             # push the result onto the stack again             o1 = stack.pop()             o2 = stack.pop()             stack.append(operators[c](o1, o2))      return stack.pop()\n2: def make_linked_list(elements_list: Iterable[int]) -> LinkedList:     if not elements_list:         raise Exception(\"The Elements List is empty\")      linked_list = LinkedList()     linked_list.extend(elements_list)     return linked_list", "output": "0"}
{"task": "search", "input": "search code:\nRemove `prefix` from start of `text` if present.\n\nChoices:\n0: def archimedes_principle(     fluid_density: float, volume: float, gravity: float = g ) -> float:      if fluid_density <= 0:         raise ValueError(\"Impossible fluid density\")     if volume <= 0:         raise ValueError(\"Impossible object volume\")     if gravity < 0:         raise ValueError(\"Impossible gravity\")      return fluid_density * gravity * volume\n1: def rlocate(iterable, pred=bool, window_size=None):     if window_size is None:         try:             len_iter = len(iterable)             return (len_iter - i - 1 for i in locate(reversed(iterable), pred))         except TypeError:             pass      return reversed(list(locate(iterable, pred, window_size)))\n2: def removeprefix(text: str, prefix: str) -> str:     if text.startswith(prefix):         return text[len(prefix):]     return text", "output": "2"}
{"task": "search", "input": "search code:\nReturns a list of sorted array elements using merge sort.\n\nChoices:\n0: def intcomma(value, ndigits=None):     sep = thousands_separator()     try:         if isinstance(value, str):             float(value.replace(sep, \"\"))         else:             float(value)     except (TypeError, ValueError):         return value      if ndigits:         orig = \"{0:.{1}f}\".format(value, ndigits)     else:         orig = str(value)      new = re.sub(r\"^(-?\\d+)(\\d{3})\", rf\"\\g<1>{sep}\\g<2>\", orig)     if orig == new:         return new     else:         return intcomma(new)\n1: def merge_sort(array: list) -> list:     if len(array) <= 1:         return array     # the actual formula to calculate the middle element = left + (right - left) // 2     # this avoids integer overflow in case of large N     middle = 0 + (len(array) - 0) // 2      # Split the array into halves till the array length becomes equal to One     # merge the arrays of single length returned by mergeSort function and     # pass them into the merge arrays function which merges the array     left_half = array[:middle]     right_half = array[middle:]      return merge(merge_sort(left_half), merge_sort(right_half))\n2: def pythagorean_triple(max_perimeter: int) -> typing.Counter[int]:     triplets: typing.Counter[int] = Counter()     for base in range(1, max_perimeter + 1):         for perpendicular in range(base, max_perimeter + 1):             hypotenuse = (base * base + perpendicular * perpendicular) ** 0.5             if hypotenuse == int(hypotenuse):                 perimeter = int(base + perpendicular + hypotenuse)                 if perimeter > max_perimeter:                     continue                 triplets[perimeter] += 1     return triplets", "output": "1"}
{"task": "search", "input": "search code:\nImplementation of pigeon hole sort algorithm\n\nChoices:\n0: def zero_vector(dimension: int) -> Vector:     # precondition     assert isinstance(dimension, int)     return Vector([0] * dimension)\n1: def pigeon_sort(array: list[int]) -> list[int]:     if len(array) == 0:         return array      _min, _max = min(array), max(array)      # Compute the variables     holes_range = _max - _min + 1     holes, holes_repeat = [0] * holes_range, [0] * holes_range      # Make the sorting.     for i in array:         index = i - _min         holes[index] = i         holes_repeat[index] += 1      # Makes the array back by replacing the numbers.     index = 0     for i in range(holes_range):         while holes_repeat[i] > 0:             array[index] = holes[i]             index += 1             holes_repeat[i] -= 1      # Returns the sorted array.     return array\n2: def iter_merge_sort(input_list: list) -> list:     if len(input_list) <= 1:         return input_list     input_list = list(input_list)      # iteration for two-way merging     p = 2     while p <= len(input_list):         # getting low, high and middle value for merge-sort of single list         for i in range(0, len(input_list), p):             low = i             high = i + p - 1             mid = (low + high + 1) // 2             input_list = merge(input_list, low, mid, high)         # final merge of last two parts         if p * 2 >= len(input_list):             mid = i             input_list = merge(input_list, 0, mid, len(input_list) - 1)             break         p *= 2      return input_list", "output": "1"}
{"task": "detection", "input": "classify code:\ndef peak(lst: List[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef leaky_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:\n    return np.where(vector > 0, vector, alpha * vector)", "output": "Implements the LeakyReLU activation function."}
{"task": "search", "input": "search code:\nPrefix-function use case\n\nChoices:\n0: def merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:     if tree1 is None:         return tree2     if tree2 is None:         return tree1      tree1.value = tree1.value + tree2.value     tree1.left = merge_two_binary_trees(tree1.left, tree2.left)     tree1.right = merge_two_binary_trees(tree1.right, tree2.right)     return tree1\n1: def permutation_index(element, iterable):     index = 0     pool = list(iterable)     for i, x in zip(range(len(pool), -1, -1), element):         r = pool.index(x)         index = index * i + r         del pool[r]      return index\n2: def longest_prefix(input_str: str) -> int:      # just returning maximum value of the array gives us answer     return max(prefix_function(input_str))", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef parse_token(token: str | float) -> float | str:\n    if token in OPERATORS:\n        return token\n    try:\n        return float(token)\n    except ValueError:\n        msg = f\"{token} is neither a number nor a valid operator\"\n        raise ValueError(msg)", "output": "Converts the given data to the appropriate number if it is indeed a number, else"}
{"task": "search", "input": "search code:\npostOrder (left, right, self)\n\nChoices:\n0: def interquartile_range(nums: list[int | float]) -> float:     if not nums:         raise ValueError(\"The list is empty. Provide a non-empty list.\")     nums.sort()     length = len(nums)     div, mod = divmod(length, 2)     q1 = find_median(nums[:div])     half_length = sum((div, mod))     q3 = find_median(nums[half_length:length])     return q3 - q1\n1: def _norm_args_notimplemented(other):     if type(other) in (set, frozenset):         inc, exc = other, None     elif type(other) is _ComplementSet:         inc, exc = other._included, other._excluded     else:         return NotImplemented, None     return inc, exc\n2: def postorder(curr_node: Node | None) -> list[Node]:     node_list = []     if curr_node is not None:         node_list = postorder(curr_node.left) + postorder(curr_node.right) + [curr_node]     return node_list", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef is_palindrome(n: int) -> bool:\n    if n % 10 == 0:\n        return False\n    s = str(n)\n    return s == s[::-1]", "output": "Check if an integer is palindromic."}
{"task": "detection", "input": "classify code:\ndef find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculates the score for a move based on the number of elements removed.\n\nChoices:\n0: def increment_score(count: int) -> int:     return int(count * (count + 1) / 2)\n1: def _calculate(days: int, absent: int, late: int) -> int:      # if we are absent twice, or late 3 consecutive days,     # no further prize strings are possible     if late == 3 or absent == 2:         return 0      # if we have no days left, and have not failed any other rules,     # we have a prize string     if days == 0:         return 1      # No easy solution, so now we need to do the recursive calculation      # First, check if the combination is already in the cache, and     # if yes, return the stored value from there since we already     # know the number of possible prize strings from this point on     key = (days, absent, late)     if key in cache:         return cache[key]      # now we calculate the three possible ways that can unfold from     # this point on, depending on our attendance today      # 1) if we are late (but not absent), the \"absent\" counter stays as     # it is, but the \"late\" counter increases by one     state_late = _calculate(days - 1, absent, late + 1)      # 2) if we are absent, the \"absent\" counter increases by 1, and the     # \"late\" counter resets to 0     state_absent = _calculate(days - 1, absent + 1, 0)      # 3) if we are on time, this resets the \"late\" counter and keeps the     # absent counter     state_ontime = _calculate(days - 1, absent, 0)      prizestrings = state_late + state_absent + state_ontime      cache[key] = prizestrings     return prizestrings\n2: def product_index(element, *args):     elements = tuple(element)     pools = tuple(map(tuple, args))     if len(elements) != len(pools):         raise ValueError('element is not a product of args')      index = 0     for elem, pool in zip(elements, pools):         index = index * len(pool) + pool.index(elem)     return index", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef example(wav_file_path: str = \"./path-to-file/sample.wav\") -> np.ndarray:\n    from scipy.io import wavfile\n\n    # Load the audio from the WAV file\n    sample_rate, audio = wavfile.read(wav_file_path)\n\n    # Calculate MFCCs\n    return mfcc(audio, sample_rate)", "output": "Example function to calculate Mel Frequency Cepstral Coefficients"}
{"task": "summary", "input": "summarize code:\ndef unique_to_each(*iterables):\n    pool = [list(it) for it in iterables]\n    counts = Counter(chain.from_iterable(map(set, pool)))\n    uniques = {element for element in counts if counts[element] == 1}\n    return [list(filter(uniques.__contains__, it)) for it in pool]", "output": "Return the elements from each of the input iterables that aren't in the"}
{"task": "search", "input": "search code:\nYield the elements from *iterable*, followed by *fillvalue*, such that\n\nChoices:\n0: def largest_rectangle_area(heights: list[int]) -> int:     stack: list[int] = []     max_area = 0     heights = [*heights, 0]  # make a new list by appending the sentinel 0     n = len(heights)      for i in range(n):         # make sure the stack remains in increasing order         while stack and heights[i] < heights[stack[-1]]:             h = heights[stack.pop()]  # height of the bar             # if stack is empty, it means entire width can be taken from index 0 to i-1             w = i if not stack else i - stack[-1] - 1  # calculate width             max_area = max(max_area, h * w)          stack.append(i)      return max_area\n1: def fibonacci_generator() -> Generator[int]:     a, b = 0, 1     while True:         a, b = b, a + b         yield b\n2: def padded(iterable, fillvalue=None, n=None, next_multiple=False):     iterator = iter(iterable)     iterator_with_repeat = chain(iterator, repeat(fillvalue))      if n is None:         return iterator_with_repeat     elif n < 1:         raise ValueError('n must be at least 1')     elif next_multiple:          def slice_generator():             for first in iterator:                 yield (first,)                 yield islice(iterator_with_repeat, n - 1)          # While elements exist produce slices of size n         return chain.from_iterable(slice_generator())     else:         # Ensure the first batch is at least size n then iterate         return chain(islice(iterator_with_repeat, n), iterator)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Remove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    >>> remove_duplicates(\"Python   is      great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split())))", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the sum of all the multiples of 3 or 5 below n.\n\nChoices:\n0: def prepare_input(dirty: str) -> str:      dirty = \"\".join([c.upper() for c in dirty if c in string.ascii_letters])     clean = \"\"      if len(dirty) < 2:         return dirty      for i in range(len(dirty) - 1):         clean += dirty[i]          if dirty[i] == dirty[i + 1]:             clean += \"X\"      clean += dirty[-1]      if len(clean) & 1:         clean += \"X\"      return clean\n1: def solution(n: int = 1000) -> int:      return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)\n2: def binary_search(sorted_collection: list[int], item: int) -> int:     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     left = 0     right = len(sorted_collection) - 1      while left <= right:         midpoint = left + (right - left) // 2         current_item = sorted_collection[midpoint]         if current_item == item:             return midpoint         elif item < current_item:             right = midpoint - 1         else:             left = midpoint + 1     return -1", "output": "1"}
{"task": "search", "input": "search code:\nChange the shape of a *matrix*.\n\nChoices:\n0: def untyped_sorted(iterable, key=None, reverse=False):     class _Wrapper:         slots = ('obj',)          def __init__(self, obj):             self.obj = obj          def __lt__(self, other):             obj = key(self.obj) if key is not None else self.obj             other = key(other.obj) if key is not None else other.obj             try:                 ret = obj < other             except TypeError:                 ret = ((type(obj).__name__, id(type(obj)), obj)                        < (type(other).__name__, id(type(other)), other))             return ret      if key is not None and not callable(key):         raise TypeError('expected function or callable object for key, not: %r'                         % key)      return sorted(iterable, key=_Wrapper, reverse=reverse)\n1: def unique_in_window(iterable, n, key=None):     if n <= 0:         raise ValueError('n must be greater than 0')      window = deque(maxlen=n)     counts = Counter()     use_key = key is not None      for item in iterable:         if len(window) == n:             to_discard = window[0]             if counts[to_discard] == 1:                 del counts[to_discard]             else:                 counts[to_discard] -= 1          k = key(item) if use_key else item         if k not in counts:             yield item         counts[k] += 1         window.append(k)\n2: def reshape(matrix, shape):     if isinstance(shape, int):         return batched(chain.from_iterable(matrix), shape)     first_dim, *dims = shape     scalar_stream = _flatten_tensor(matrix)     reshaped = reduce(batched, reversed(dims), scalar_stream)     return islice(reshaped, first_dim)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef reverse_bit(number: int) -> int:\n    if not isinstance(number, int):\n        raise TypeError(\"Input value must be an 'int' type\")\n    if number < 0:\n        raise ValueError(\"The value of input must be non-negative\")\n\n    result = 0\n    # iterator over [0 to 31], since we are dealing with a 32 bit integer\n    for _ in range(32):\n        # left shift the bits by unity\n        result <<= 1\n        # get the end bit\n        end_bit = number & 1\n        # right shift the bits by unity\n        number >>= 1\n        # add that bit to our answer\n        result |= end_bit\n    return result", "output": "Take in a 32 bit integer, reverse its bits, return a 32 bit integer result"}
{"task": "summary", "input": "summarize code:\ndef _gettext_noop(message):\n    return message", "output": "Mark a string as a translation string without translating it."}
{"task": "detection", "input": "classify code:\ndef solution_fast() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution_fast()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(400):\n            c = 1000 - a - b\n            if a < b < c and (a**2) + (b**2) == (c**2):\n                return a * b * c\n\n    return -1", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef _hypothesis_value(data_input_tuple):\n    hyp_val = 0\n    for i in range(len(parameter_vector) - 1):\n        hyp_val += data_input_tuple[i] * parameter_vector[i + 1]\n    hyp_val += parameter_vector[0]\n    return hyp_val", "output": "Calculates hypothesis function value for a given input"}
{"task": "summary", "input": "summarize code:\ndef top_down_cut_rod(n: int, prices: list):\n    _enforce_args(n, prices)\n    max_rev = [float(\"-inf\") for _ in range(n + 1)]\n    return _top_down_cut_rod_recursive(n, prices, max_rev)", "output": "Constructs a top-down dynamic programming solution for the rod-cutting"}
{"task": "detection", "input": "classify code:\ndef simple_fibonacci(n, f1, f2):\n    \"\"\"\n    Returns the nth number of the Fibonacci sequence that\n    starts with f1 and f2\n    Uses the definition\n    >>> simple_fibonacci(1, 5, 6)\n    5\n    >>> simple_fibonacci(2, 10, 11)\n    11\n    >>> simple_fibonacci(13, 0, 1)\n    144\n    >>> simple_fibonacci(10, 5, 9)\n    411\n    >>> simple_fibonacci(9, 2, 3)\n    89\n    \"\"\"\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    n -= 2\n\n    while n > 0:\n        f2, f1 = f1 + f2, f2\n        n -= 1\n\n    return f2", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )", "output": "BUGGY"}
{"task": "search", "input": "search code:\nThis algorithm equalizes all elements of the input vector\n\nChoices:\n0: def array_equalization(vector: list[int], step_size: int) -> int:     if step_size <= 0:         raise ValueError(\"Step size must be positive and non-zero.\")     if not isinstance(step_size, int):         raise ValueError(\"Step size must be an integer.\")      unique_elements = set(vector)     min_updates = maxsize      for element in unique_elements:         elem_index = 0         updates = 0         while elem_index < len(vector):             if vector[elem_index] != element:                 updates += 1                 elem_index += step_size             else:                 elem_index += 1         min_updates = min(min_updates, updates)      return min_updates\n1: def is_safe_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return (number - 1) % 2 == 0 and is_prime(number) and is_prime((number - 1) // 2)\n2: def encode(word: str) -> str:     encoded = \"\"     for letter in word.lower():         if letter.isalpha() or letter == \" \":             encoded += encode_dict[letter]         else:             raise Exception(\"encode() accepts only letters of the alphabet and spaces\")     return encoded", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef swap(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b", "output": "def swap(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Return a tuple (b, a) when given two integers a and b\n    >>> swap(2,3)\n    (3, 2)\n    >>> swap(3,4)\n    (4, 3)\n    >>> swap(67, 12)\n    (12, 67)\n    \"\"\"\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b"}
{"task": "summary", "input": "summarize code:\ndef hamming(n_element: int) -> list:\n    n_element = int(n_element)\n    if n_element < 1:\n        my_error = ValueError(\"n_element should be a positive number\")\n        raise my_error\n\n    hamming_list = [1]\n    i, j, k = (0, 0, 0)\n    index = 1\n    while index < n_element:\n        while hamming_list[i] * 2 <= hamming_list[-1]:\n            i += 1\n        while hamming_list[j] * 3 <= hamming_list[-1]:\n            j += 1\n        while hamming_list[k] * 5 <= hamming_list[-1]:\n            k += 1\n        hamming_list.append(\n            min(hamming_list[i] * 2, hamming_list[j] * 3, hamming_list[k] * 5)\n        )\n        index += 1\n    return hamming_list", "output": "This function creates an ordered list of n length as requested, and afterwards"}
{"task": "summary", "input": "summarize code:\ndef random_puzzle(assignments=17):\n    values = dict.fromkeys(squares, digits)\n    for s in shuffled(squares):\n        if not assign(values, s, random.choice(values[s])):\n            break\n        ds = [values[s] for s in squares if len(values[s]) == 1]\n        if len(ds) >= assignments and len(set(ds)) >= 8:\n            return \"\".join(values[s] if len(values[s]) == 1 else \".\" for s in squares)\n    return random_puzzle(assignments)  ## Give up and make a new puzzle", "output": "Make a random puzzle with N or more assignments. Restart on contradictions."}
{"task": "repair", "input": "fix bug:\ndef merge(left, right):\n    \"\"\"\n    >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0][0] < right[0][0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right", "output": "def merge(left, right):\n    \"\"\"\n    >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0][0] < right[0][0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right"}
{"task": "summary", "input": "summarize code:\ndef generate_primes(max_num: int) -> list[int]:\n    are_primes = [True] * (max_num + 1)\n    are_primes[0] = are_primes[1] = False\n    for i in range(2, isqrt(max_num) + 1):\n        if are_primes[i]:\n            for j in range(i * i, max_num + 1, i):\n                are_primes[j] = False\n\n    return [prime for prime, is_prime in enumerate(are_primes) if is_prime]", "output": "Calculates the list of primes up to and including `max_num`."}
{"task": "search", "input": "search code:\nThis function returns the decimal value of a number multiplied with log(2)\n\nChoices:\n0: def log_difference(number: int) -> float:      log_number = math.log(2, 10) * number     difference = round((log_number - int(log_number)), 15)      return difference\n1: def extended_euclid(a: int, b: int) -> tuple[int, int]:     if b == 0:         return (1, 0)     (x, y) = extended_euclid(b, a % b)     k = a // b     return (y, x - k * y)\n2: def max_tasks(tasks_info: list[tuple[int, int]]) -> list[int]:     tasks = sorted(         (             Task(task_id, deadline, reward)             for task_id, (deadline, reward) in enumerate(tasks_info)         ),         key=attrgetter(\"reward\"),         reverse=True,     )     return [task.task_id for i, task in enumerate(tasks, start=1) if task.deadline >= i]", "output": "0"}
{"task": "search", "input": "search code:\nCalculate AND of the input values\n\nChoices:\n0: def interpolate(y_list: list[int]) -> Callable[[int], int]:      size: int = len(y_list)     matrix: Matrix = [[0 for _ in range(size)] for _ in range(size)]     vector: Matrix = [[0] for _ in range(size)]     coeffs: Matrix     x_val: int     y_val: int     col: int      for x_val, y_val in enumerate(y_list):         for col in range(size):             matrix[x_val][col] = (x_val + 1) ** (size - col - 1)         vector[x_val][0] = y_val      coeffs = solve(matrix, vector)      def interpolated_func(var: int) -> int:         return sum(             round(coeffs[x_val][0]) * (var ** (size - x_val - 1))             for x_val in range(size)         )      return interpolated_func\n1: def and_gate(input_1: int, input_2: int) -> int:     return int(input_1 and input_2)\n2: def postorder(root: Node | None) -> Generator[int]:     if not root:         return     yield from postorder(root.left)     yield from postorder(root.right)     yield root.data", "output": "1"}
{"task": "detection", "input": "classify code:\ndef longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nPerform topological sort on a directed acyclic graph.\n\nChoices:\n0: def binary_exp_iterative(base: float, exponent: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res *= base          base *= base         exponent >>= 1      return res\n1: def consume(iterator, n=None):     # Use functions that consume iterators at C speed.     if n is None:         # feed the entire iterator into a zero-length deque         deque(iterator, maxlen=0)     else:         # advance to the empty slice starting at position n         next(islice(iterator, n, n), None)\n2: def topological_sort(start: str, visited: list[str], sort: list[str]) -> list[str]:     current = start     # add current to visited     visited.append(current)     neighbors = edges[current]     for neighbor in neighbors:         # if neighbor not in visited, visit         if neighbor not in visited:             sort = topological_sort(neighbor, visited, sort)     # if all neighbors visited add current to sort     sort.append(current)     # if all vertices haven't been visited select a new one to visit     if len(visited) != len(vertices):         for vertice in vertices:             if vertice not in visited:                 sort = topological_sort(vertice, visited, sort)     # return sort     return sort", "output": "2"}
{"task": "detection", "input": "classify code:\ndef decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef breadth_first_search(\n    level: list[int],\n    parent: list[list[int]],\n    max_node: int,\n    graph: dict[int, list[int]],\n    root: int = 1,\n) -> tuple[list[int], list[list[int]]]:\n    level[root] = 0\n    q: Queue[int] = Queue(maxsize=max_node)\n    q.put(root)\n    while q.qsize() != 0:\n        u = q.get()\n        for v in graph[u]:\n            if level[v] == -1:\n                level[v] = level[u] + 1\n                q.put(v)\n                parent[0][v] = u\n    return level, parent", "output": "sets every nodes direct parent"}
{"task": "summary", "input": "summarize code:\ndef suppress_non_maximum(image_shape, gradient_direction, sobel_grad):\n    destination = np.zeros(image_shape)\n\n    for row in range(1, image_shape[0] - 1):\n        for col in range(1, image_shape[1] - 1):\n            direction = gradient_direction[row, col]\n\n            if (\n                0 <= direction < PI / 8\n                or 15 * PI / 8 <= direction <= 2 * PI\n                or 7 * PI / 8 <= direction <= 9 * PI / 8\n            ):\n                w = sobel_grad[row, col - 1]\n                e = sobel_grad[row, col + 1]\n                if sobel_grad[row, col] >= w and sobel_grad[row, col] >= e:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                PI / 8 <= direction < 3 * PI / 8\n                or 9 * PI / 8 <= direction < 11 * PI / 8\n            ):\n                sw = sobel_grad[row + 1, col - 1]\n                ne = sobel_grad[row - 1, col + 1]\n                if sobel_grad[row, col] >= sw and sobel_grad[row, col] >= ne:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                3 * PI / 8 <= direction < 5 * PI / 8\n                or 11 * PI / 8 <= direction < 13 * PI / 8\n            ):\n                n = sobel_grad[row - 1, col]\n                s = sobel_grad[row + 1, col]\n                if sobel_grad[row, col] >= n and sobel_grad[row, col] >= s:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                5 * PI / 8 <= direction < 7 * PI / 8\n                or 13 * PI / 8 <= direction < 15 * PI / 8\n            ):\n                nw = sobel_grad[row - 1, col - 1]\n                se = sobel_grad[row + 1, col + 1]\n                if sobel_grad[row, col] >= nw and sobel_grad[row, col] >= se:\n                    destination[row, col] = sobel_grad[row, col]\n\n    return destination", "output": "Non-maximum suppression. If the edge strength of the current pixel is the largest"}
{"task": "search", "input": "search code:\nExamples(rounded for precision):\n\nChoices:\n0: def mae(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = abs(predict - actual)     score = difference.mean()      return score\n1: def sum_of_digit_factorial(n: int) -> int:     return sum(DIGIT_FACTORIAL[d] for d in str(n))\n2: def circle_bottom_arc_integral(point: float) -> float:      return (         (1 - 2 * point) * sqrt(point - point**2) + 2 * point + asin(sqrt(1 - point))     ) / 4", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef _count_cross_inversions(p, q):\n    \"\"\"\n    Counts the inversions across two sorted arrays.\n    And combine the two arrays into one sorted array\n    For all 1<= i<=len(P) and for all 1 <= j <= len(Q),\n    if P[i] > Q[j], then (i, j) is a cross inversion\n    Parameters\n    ----------\n    P: array-like, sorted in non-decreasing order\n    Q: array-like, sorted in non-decreasing order\n    Returns\n    ------\n    R: array-like, a sorted array of the elements of `P` and `Q`\n    num_inversion: int, the number of inversions across `P` and `Q`\n    Examples\n    --------\n    >>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\n    ([0, 1, 2, 2, 3, 5], 4)\n    >>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\n    ([1, 2, 3, 3, 4, 5], 0)\n    \"\"\"\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion", "output": "def _count_cross_inversions(p, q):\n    \"\"\"\n    Counts the inversions across two sorted arrays.\n    And combine the two arrays into one sorted array\n    For all 1<= i<=len(P) and for all 1 <= j <= len(Q),\n    if P[i] > Q[j], then (i, j) is a cross inversion\n    Parameters\n    ----------\n    P: array-like, sorted in non-decreasing order\n    Q: array-like, sorted in non-decreasing order\n    Returns\n    ------\n    R: array-like, a sorted array of the elements of `P` and `Q`\n    num_inversion: int, the number of inversions across `P` and `Q`\n    Examples\n    --------\n    >>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\n    ([0, 1, 2, 2, 3, 5], 4)\n    >>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\n    ([1, 2, 3, 3, 4, 5], 0)\n    \"\"\"\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion"}
{"task": "summary", "input": "summarize code:\ndef _norm_args_typeerror(other):\n    if type(other) in (set, frozenset):\n        inc, exc = other, None\n    elif type(other) is _ComplementSet:\n        inc, exc = other._included, other._excluded\n    else:\n        raise TypeError('argument must be another set or complement(set)')\n    return inc, exc", "output": "normalize args and raise type-error if there is a problem"}
{"task": "summary", "input": "summarize code:\ndef get_gifs(query: str, api_key: str = giphy_api_key) -> list:\n    formatted_query = \"+\".join(query.split())\n    url = f\"https://api.giphy.com/v1/gifs/search?q={formatted_query}&api_key={api_key}\"\n    gifs = httpx.get(url, timeout=10).json()[\"data\"]\n    return [gif[\"url\"] for gif in gifs]", "output": "Get a list of URLs of GIFs based on a given query.."}
{"task": "search", "input": "search code:\nreturn the harmonic mean of series\n\nChoices:\n0: def interquartile_range_checker(train_user: list) -> float:     train_user.sort()     q1 = np.percentile(train_user, 25)     q3 = np.percentile(train_user, 75)     iqr = q3 - q1     low_lim = q1 - (iqr * 0.1)     return float(low_lim)\n1: def longest_common_substring(text1: str, text2: str) -> str:      if not (isinstance(text1, str) and isinstance(text2, str)):         raise ValueError(\"longest_common_substring() takes two strings for inputs\")      if not text1 or not text2:         return \"\"      text1_length = len(text1)     text2_length = len(text2)      dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]     end_pos = 0     max_length = 0      for i in range(1, text1_length + 1):         for j in range(1, text2_length + 1):             if text1[i - 1] == text2[j - 1]:                 dp[i][j] = 1 + dp[i - 1][j - 1]                 if dp[i][j] > max_length:                     end_pos = i                     max_length = dp[i][j]      return text1[end_pos - max_length : end_pos]\n2: def harmonic_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 0     for val in series:         answer += 1 / val     return len(series) / answer", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    total = 0\n    terms = (n - 1) // 3\n    total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.\n    terms = (n - 1) // 5\n    total += ((terms) * (10 + (terms - 1) * 5)) // 2\n    terms = (n - 1) // 15\n    total -= ((terms) * (30 + (terms - 1) * 15)) // 2\n    return total", "output": "Returns the sum of all the multiples of 3 or 5 below n."}
{"task": "detection", "input": "classify code:\ndef decimal_isolate(number: float, digit_amount: int) -> float:\n    \"\"\"\n    Isolates the decimal part of a number.\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\n    >>> decimal_isolate(1.53, 0)\n    0.53\n    >>> decimal_isolate(35.345, 1)\n    0.3\n    >>> decimal_isolate(35.345, 2)\n    0.34\n    >>> decimal_isolate(35.345, 3)\n    0.345\n    >>> decimal_isolate(-14.789, 3)\n    -0.789\n    >>> decimal_isolate(0, 2)\n    0\n    >>> decimal_isolate(-14.123, 1)\n    -0.1\n    >>> decimal_isolate(-14.123, 2)\n    -0.12\n    >>> decimal_isolate(-14.123, 3)\n    -0.123\n    \"\"\"\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef get_distance(highway_now: list, car_index: int) -> int:\n    \"\"\"\n    Get the distance between a car (at index car_index) and the next car\n    >>> get_distance([6, -1, 6, -1, 6], 2)\n    1\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n    3\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n    4\n    \"\"\"\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)", "output": "def get_distance(highway_now: list, car_index: int) -> int:\n    \"\"\"\n    Get the distance between a car (at index car_index) and the next car\n    >>> get_distance([6, -1, 6, -1, 6], 2)\n    1\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n    3\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n    4\n    \"\"\"\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)"}
{"task": "summary", "input": "summarize code:\ndef mel_spaced_filterbank(\n    sample_rate: int, mel_filter_num: int = 10, ftt_size: int = 1024\n) -> np.ndarray:\n    freq_min = 0\n    freq_high = sample_rate // 2\n\n    logging.info(f\"Minimum frequency: {freq_min}\")\n    logging.info(f\"Maximum frequency: {freq_high}\")\n\n    # Calculate filter points and mel frequencies\n    filter_points, mel_freqs = get_filter_points(\n        sample_rate,\n        freq_min,\n        freq_high,\n        mel_filter_num,\n        ftt_size,\n    )\n\n    filters = get_filters(filter_points, ftt_size)\n\n    # normalize filters\n    # taken from the librosa library\n    enorm = 2.0 / (mel_freqs[2 : mel_filter_num + 2] - mel_freqs[:mel_filter_num])\n    return filters * enorm[:, np.newaxis]", "output": "Create a Mel-spaced filter bank for audio processing."}
{"task": "search", "input": "search code:\nImplements the Mish activation function.\n\nChoices:\n0: def random_pivot(lst):     return choice(lst)\n1: def is_prime(n: int) -> bool:     return sieve[n]\n2: def mish(vector: np.ndarray) -> np.ndarray:     return vector * np.tanh(softplus(vector))", "output": "2"}
{"task": "search", "input": "search code:\nExtended Euclid\n\nChoices:\n0: def knuth_morris_pratt(text: str, pattern: str) -> int:      # 1) Construct the failure array     failure = get_failure_array(pattern)      # 2) Step through text searching for pattern     i, j = 0, 0  # index into text, pattern     while i < len(text):         if pattern[j] == text[i]:             if j == (len(pattern) - 1):                 return i - j             j += 1          # if this is a prefix in our pattern         # just go back far enough to continue         elif j > 0:             j = failure[j - 1]             continue         i += 1     return -1\n1: def extended_euclid(a: int, b: int) -> tuple[int, int]:     if b == 0:         return (1, 0)     (x, y) = extended_euclid(b, a % b)     k = a // b     return (y, x - k * y)\n2: def max_sum_in_array(array: list[int], k: int) -> int:     if len(array) < k or k < 0:         raise ValueError(\"Invalid Input\")     max_sum = current_sum = sum(array[:k])     for i in range(len(array) - k):         current_sum = current_sum - array[i] + array[i + k]         max_sum = max(max_sum, current_sum)     return max_sum", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef soboleva_modified_hyperbolic_tangent(\n    vector: np.ndarray, a_value: float, b_value: float, c_value: float, d_value: float\n) -> np.ndarray:\n\n    # Separate the numerator and denominator for simplicity\n    # Calculate the numerator and denominator element-wise\n    numerator = np.exp(a_value * vector) - np.exp(-b_value * vector)\n    denominator = np.exp(c_value * vector) + np.exp(-d_value * vector)\n\n    # Calculate and return the final result element-wise\n    return numerator / denominator", "output": "Implements the Soboleva Modified Hyperbolic Tangent function"}
{"task": "repair", "input": "fix bug:\ndef vol_cube(side_length: Union[int, float]) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)", "output": "def vol_cube(side_length: int | float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    \"\"\"\n    return pow(side_length, 3)"}
{"task": "search", "input": "search code:\nNon-maximum suppression. If the edge strength of the current pixel is the largest\n\nChoices:\n0: def remove_word(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> None:     for i in range(len(word)):         if vertical:             puzzle[row + i][col] = \"\"         else:             puzzle[row][col + i] = \"\"\n1: def suppress_non_maximum(image_shape, gradient_direction, sobel_grad):     destination = np.zeros(image_shape)      for row in range(1, image_shape[0] - 1):         for col in range(1, image_shape[1] - 1):             direction = gradient_direction[row, col]              if (                 0 <= direction < PI / 8                 or 15 * PI / 8 <= direction <= 2 * PI                 or 7 * PI / 8 <= direction <= 9 * PI / 8             ):                 w = sobel_grad[row, col - 1]                 e = sobel_grad[row, col + 1]                 if sobel_grad[row, col] >= w and sobel_grad[row, col] >= e:                     destination[row, col] = sobel_grad[row, col]              elif (                 PI / 8 <= direction < 3 * PI / 8                 or 9 * PI / 8 <= direction < 11 * PI / 8             ):                 sw = sobel_grad[row + 1, col - 1]                 ne = sobel_grad[row - 1, col + 1]                 if sobel_grad[row, col] >= sw and sobel_grad[row, col] >= ne:                     destination[row, col] = sobel_grad[row, col]              elif (                 3 * PI / 8 <= direction < 5 * PI / 8                 or 11 * PI / 8 <= direction < 13 * PI / 8             ):                 n = sobel_grad[row - 1, col]                 s = sobel_grad[row + 1, col]                 if sobel_grad[row, col] >= n and sobel_grad[row, col] >= s:                     destination[row, col] = sobel_grad[row, col]              elif (                 5 * PI / 8 <= direction < 7 * PI / 8                 or 13 * PI / 8 <= direction < 15 * PI / 8             ):                 nw = sobel_grad[row - 1, col - 1]                 se = sobel_grad[row + 1, col + 1]                 if sobel_grad[row, col] >= nw and sobel_grad[row, col] >= se:                     destination[row, col] = sobel_grad[row, col]      return destination\n2: def perfect_square_binary_search(n: int) -> bool:     left = 0     right = n     while left <= right:         mid = (left + right) // 2         if mid**2 == n:             return True         elif mid**2 > n:             right = mid - 1         else:             left = mid + 1     return False", "output": "1"}
{"task": "search", "input": "search code:\nCalculate predictions for each point in the training data\n\nChoices:\n0: def local_weight_regression(     x_train: np.ndarray, y_train: np.ndarray, tau: float ) -> np.ndarray:     y_pred = np.zeros(len(x_train))  # Initialize array of predictions     for i, item in enumerate(x_train):         y_pred[i] = np.dot(item, local_weight(item, x_train, y_train, tau)).item()      return y_pred\n1: def bitonic_sort(array: list[int], low: int, length: int, direction: int) -> None:     if length > 1:         middle = int(length / 2)         bitonic_sort(array, low, middle, 1)         bitonic_sort(array, low + middle, middle, 0)         bitonic_merge(array, low, length, direction)\n2: def forward_propagation(expected: int, number_propagations: int) -> float:      # Random weight     weight = float(2 * (random.randint(1, 100)) - 1)      for _ in range(number_propagations):         # Forward propagation         layer_1 = sigmoid_function(INITIAL_VALUE * weight)         # How much did we miss?         layer_1_error = (expected / 100) - layer_1         # Error delta         layer_1_delta = layer_1_error * sigmoid_function(layer_1, True)         # Update weight         weight += INITIAL_VALUE * layer_1_delta      return layer_1 * 100", "output": "0"}
{"task": "search", "input": "search code:\nReturn a list of all primes numbers up to max.\n\nChoices:\n0: def distance(city1: list[int], city2: list[int]) -> float:     return (((city1[0] - city2[0]) ** 2) + ((city1[1] - city2[1]) ** 2)) ** 0.5\n1: def fast_primes(max_n: int) -> Generator[int]:     numbers: Generator = (i for i in range(1, (max_n + 1), 2))     # It's useless to test even numbers as they will not be prime     if max_n > 2:         yield 2  # Because 2 will not be tested, it's necessary to yield it now     for i in (n for n in numbers if n > 1):         bound = int(math.sqrt(i)) + 1         for j in range(3, bound, 2):             # As we removed the even numbers, we don't need them now             if (i % j) == 0:                 break         else:             yield i\n2: def get_subreddit_data(     subreddit: str, limit: int = 1, age: str = \"new\", wanted_data: list | None = None ) -> dict:     wanted_data = wanted_data or []     if invalid_search_terms := \", \".join(sorted(set(wanted_data) - valid_terms)):         msg = f\"Invalid search term: {invalid_search_terms}\"         raise ValueError(msg)     response = httpx.get(         f\"https://www.reddit.com/r/{subreddit}/{age}.json?limit={limit}\",         headers={\"User-agent\": \"A random string\"},         timeout=10,     )     response.raise_for_status()     if response.status_code == 429:         raise httpx.HTTPError(response=response)      data = response.json()     if not wanted_data:         return {id_: data[\"data\"][\"children\"][id_] for id_ in range(limit)}      data_dict = {}     for id_ in range(limit):         data_dict[id_] = {             item: data[\"data\"][\"children\"][id_][\"data\"][item] for item in wanted_data         }     return data_dict", "output": "1"}
{"task": "detection", "input": "classify code:\ndef prime_sieve(limit: int) -> List[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit ** 0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes", "output": "BUGGY"}
{"task": "search", "input": "search code:\na mirror symmetry rotation of the left_rotation\n\nChoices:\n0: def distinct_combinations(iterable, r):     if r < 0:         raise ValueError('r must be non-negative')     elif r == 0:         yield ()         return     pool = tuple(iterable)     generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]     current_combo = [None] * r     level = 0     while generators:         try:             cur_idx, p = next(generators[-1])         except StopIteration:             generators.pop()             level -= 1             continue         current_combo[level] = p         if level + 1 == r:             yield tuple(current_combo)         else:             generators.append(                 unique_everseen(                     enumerate(pool[cur_idx + 1 :], cur_idx + 1),                     key=itemgetter(1),                 )             )             level += 1\n1: def print_binary_search_tree(root, key, i, j, parent, is_left):     if i > j or i < 0 or j > len(root) - 1:         return      node = root[i][j]     if parent == -1:  # root does not have a parent         print(f\"{key[node]} is the root of the binary search tree.\")     elif is_left:         print(f\"{key[node]} is the left child of key {parent}.\")     else:         print(f\"{key[node]} is the right child of key {parent}.\")      print_binary_search_tree(root, key, i, node - 1, key[node], True)     print_binary_search_tree(root, key, node + 1, j, key[node], False)\n2: def left_rotation(node: MyNode) -> MyNode:     print(\"right rotation node:\", node.get_data())     ret = node.get_right()     assert ret is not None     node.set_right(ret.get_left())     ret.set_left(node)     h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1     node.set_height(h1)     h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1     ret.set_height(h2)     return ret", "output": "2"}
{"task": "search", "input": "search code:\nImplementation of the hill climbling algorithm.\n\nChoices:\n0: def hill_climbing(     search_prob,     find_max: bool = True,     max_x: float = math.inf,     min_x: float = -math.inf,     max_y: float = math.inf,     min_y: float = -math.inf,     visualization: bool = False,     max_iter: int = 10000, ) -> SearchProblem:     current_state = search_prob     scores = []  # list to store the current score at each iteration     iterations = 0     solution_found = False     visited = set()     while not solution_found and iterations < max_iter:         visited.add(current_state)         iterations += 1         current_score = current_state.score()         scores.append(current_score)         neighbors = current_state.get_neighbors()         max_change = -math.inf         min_change = math.inf         next_state = None  # to hold the next best neighbor         for neighbor in neighbors:             if neighbor in visited:                 continue  # do not want to visit the same state again             if (                 neighbor.x > max_x                 or neighbor.x < min_x                 or neighbor.y > max_y                 or neighbor.y < min_y             ):                 continue  # neighbor outside our bounds             change = neighbor.score() - current_score             if find_max:  # finding max                 # going to direction with greatest ascent                 if change > max_change and change > 0:                     max_change = change                     next_state = neighbor             elif change < min_change and change < 0:  # finding min                 # to direction with greatest descent                 min_change = change                 next_state = neighbor         if next_state is not None:             # we found at least one neighbor which improved the current state             current_state = next_state         else:             # since we have no neighbor that improves the solution we stop the search             solution_found = True      if visualization:         from matplotlib import pyplot as plt          plt.plot(range(iterations), scores)         plt.xlabel(\"Iterations\")         plt.ylabel(\"Function values\")         plt.show()      return current_state\n1: def solution(n: int = 1000) -> int:     f1, f2 = 1, 1     index = 2     while True:         i = 0         f = f1 + f2         f1, f2 = f2, f         index += 1         for _ in str(f):             i += 1         if i == n:             break     return index\n2: def divide(n, iterable):     if n < 1:         raise ValueError('n must be at least 1')      try:         iterable[:0]     except TypeError:         seq = tuple(iterable)     else:         seq = iterable      q, r = divmod(len(seq), n)      ret = []     stop = 0     for i in range(1, n + 1):         start = stop         stop += q + 1 if i <= r else q         ret.append(iter(seq[start:stop]))      return ret", "output": "0"}
{"task": "search", "input": "search code:\nReturn the solution of the problem.\n\nChoices:\n0: def tf_idf(tf: int, idf: int) -> float:     return round(tf * idf, 3)\n1: def get_set_bits_count_using_brian_kernighans_algorithm(number: int) -> int:     if number < 0:         raise ValueError(\"the value of input must not be negative\")     result = 0     while number:         number &= number - 1         result += 1     return result\n2: def solution():     prime_list = [n for n in range(1001, 10000, 2) if is_prime(n)]     candidates = []      for number in prime_list:         tmp_numbers = []          for prime_member in permutations(list(str(number))):             prime = int(\"\".join(prime_member))              if prime % 2 == 0:                 continue              if search(prime, prime_list):                 tmp_numbers.append(prime)          tmp_numbers.sort()         if len(tmp_numbers) >= 3:             candidates.append(tmp_numbers)      passed = []     for candidate in candidates:         length = len(candidate)         found = False          for i in range(length):             for j in range(i + 1, length):                 for k in range(j + 1, length):                     if (                         abs(candidate[i] - candidate[j])                         == abs(candidate[j] - candidate[k])                         and len({candidate[i], candidate[j], candidate[k]}) == 3                     ):                         passed.append(                             sorted([candidate[i], candidate[j], candidate[k]])                         )                         found = True                      if found:                         break                 if found:                     break             if found:                 break      answer = set()     for seq in passed:         answer.add(\"\".join([str(i) for i in seq]))      return max(int(x) for x in answer)", "output": "2"}
{"task": "search", "input": "search code:\nReturn the maximum possible sum amongst all non - empty subsequences.\n\nChoices:\n0: def longest_subsequence(array: list[int]) -> list[int]:     n = len(array)     # The longest increasing subsequence ending at array[i]     longest_increasing_subsequence = []     for i in range(n):         longest_increasing_subsequence.append([array[i]])      for i in range(1, n):         for prev in range(i):             # If array[prev] is less than or equal to array[i], then             # longest_increasing_subsequence[prev] + array[i]             # is a valid increasing subsequence              # longest_increasing_subsequence[i] is only set to             # longest_increasing_subsequence[prev] + array[i] if the length is longer.              if array[prev] <= array[i] and len(                 longest_increasing_subsequence[prev]             ) + 1 > len(longest_increasing_subsequence[i]):                 longest_increasing_subsequence[i] = copy.copy(                     longest_increasing_subsequence[prev]                 )                 longest_increasing_subsequence[i].append(array[i])      result: list[int] = []     for i in range(n):         if len(longest_increasing_subsequence[i]) > len(result):             result = longest_increasing_subsequence[i]      return result\n1: def max_subsequence_sum(nums: Sequence[int] | None = None) -> int:     if nums is None or not nums:         raise ValueError(\"Input sequence should not be empty\")      ans = nums[0]     for i in range(1, len(nums)):         num = nums[i]         ans = max(ans, ans + num, num)      return ans\n2: def example() -> int:     # Input values.     test_input = np.array(         (             [0, 0, 0],             [0, 0, 1],             [0, 1, 0],             [0, 1, 1],             [1, 0, 0],             [1, 0, 1],             [1, 1, 0],             [1, 1, 1],         ),         dtype=np.float64,     )      # True output values for the given input values.     output = np.array(([0], [1], [1], [0], [1], [0], [0], [1]), dtype=np.float64)      # Calling neural network class.     neural_network = TwoHiddenLayerNeuralNetwork(         input_array=test_input, output_array=output     )      # Calling training function.     # Set give_loss to True if you want to see loss in every iteration.     neural_network.train(output=output, iterations=10, give_loss=False)      return neural_network.predict(np.array(([1, 1, 1]), dtype=np.float64))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef open_knight_tour(n: int) -> list[list[int]]:\n\n    board = [[0 for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 1\n            if open_knight_tour_helper(board, (i, j), 1):\n                return board\n            board[i][j] = 0\n\n    msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"\n    raise ValueError(msg)", "output": "Find the solution for the knight tour problem for a board of size n. Raises"}
{"task": "repair", "input": "fix bug:\ndef binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int, right: int\n) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n\n    \"\"\"\n    if right < left:\n        return None\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)", "output": "def binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n    -1\n    \"\"\"\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)"}
{"task": "repair", "input": "fix bug:\ndef exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False", "output": "def exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False"}
{"task": "summary", "input": "summarize code:\ndef binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res", "output": "Calculate (a * b) % c using binary multiplication and modular arithmetic."}
{"task": "repair", "input": "fix bug:\ndef pigeon_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "def pigeon_sort(array: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array"}
{"task": "summary", "input": "summarize code:\ndef solved(values):\n\n    def unitsolved(unit):\n        return {values[s] for s in unit} == set(digits)\n\n    return values is not False and all(unitsolved(unit) for unit in unitlist)", "output": "A puzzle is solved if each unit is a permutation of the digits 1 to 9."}
{"task": "search", "input": "search code:\nJust like the built-in :func:`issubclass`, this function checks\n\nChoices:\n0: def issubclass(subclass, baseclass):     try:         return _issubclass(subclass, baseclass)     except TypeError:         return False\n1: def circle_bottom_arc_integral(point: float) -> float:      return (         (1 - 2 * point) * sqrt(point - point**2) + 2 * point + asin(sqrt(1 - point))     ) / 4\n2: def bubble_sort_iterative(collection: list[Any]) -> list[Any]:     length = len(collection)     for i in reversed(range(length)):         swapped = False         for j in range(i):             if collection[j] > collection[j + 1]:                 swapped = True                 collection[j], collection[j + 1] = collection[j + 1], collection[j]         if not swapped:             break  # Stop iteration if the collection is sorted.     return collection", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef simple_fibonacci(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    fn_1 = f1\n    fn_2 = f2\n    n -= 2\n\n    while n > 0:\n        fn_1, fn_2 = fn_1 + fn_2, fn_1\n        n -= 1\n\n    return fn_1", "output": "def simple_fibonacci(n, f1, f2):\n    \"\"\"\n    Returns the nth number of the Fibonacci sequence that\n    starts with f1 and f2\n    Uses the definition\n    >>> simple_fibonacci(1, 5, 6)\n    5\n    >>> simple_fibonacci(2, 10, 11)\n    11\n    >>> simple_fibonacci(13, 0, 1)\n    144\n    >>> simple_fibonacci(10, 5, 9)\n    411\n    >>> simple_fibonacci(9, 2, 3)\n    89\n    \"\"\"\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    n -= 2\n\n    while n > 0:\n        f2, f1 = f1 + f2, f2\n        n -= 1\n\n    return f2"}
{"task": "detection", "input": "classify code:\ndef find_negative_index(array: list[int]) -> int:\n    \"\"\"\n    Find the smallest negative index\n\n    >>> find_negative_index([0,0,0,0])\n    4\n    >>> find_negative_index([4,3,2,-1])\n    3\n    >>> find_negative_index([1,0,-1,-10])\n    2\n    >>> find_negative_index([0,0,0,-1])\n    3\n    >>> find_negative_index([11,8,7,-3,-5,-9])\n    3\n    >>> find_negative_index([-1,-1,-2,-3])\n    0\n    >>> find_negative_index([5,1,0])\n    3\n    >>> find_negative_index([-5,-5,-5])\n    0\n    >>> find_negative_index([0])\n    1\n    >>> find_negative_index([])\n    0\n    \"\"\"\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for step in range(2, depth + 1):\n        coefficients_begins_one = previous_coefficients + [0]\n        coefficients_ends_one = [0] + previous_coefficients\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef filter_map(func, iterable):\n    for x in iterable:\n        y = func(x)\n        if y is not None:\n            yield y", "output": "Apply *func* to every element of *iterable*, yielding only those which"}
{"task": "search", "input": "search code:\nEdit distance algorithm is a string metric, i.e., it is a way of quantifying how\n\nChoices:\n0: def edit_distance(source: str, target: str) -> int:     if len(source) == 0:         return len(target)     elif len(target) == 0:         return len(source)      delta = int(source[-1] != target[-1])  # Substitution     return min(         edit_distance(source[:-1], target[:-1]) + delta,         edit_distance(source, target[:-1]) + 1,         edit_distance(source[:-1], target) + 1,     )\n1: def binary_step(vector: np.ndarray) -> np.ndarray:      return np.where(vector >= 0, 1, 0)\n2: def selection_sort(collection: list[int]) -> list[int]:      length = len(collection)     for i in range(length - 1):         min_index = i         for k in range(i + 1, length):             if collection[k] < collection[min_index]:                 min_index = k         if min_index != i:             collection[i], collection[min_index] = collection[min_index], collection[i]     return collection", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef sigmoid_derivative(value: np.ndarray) -> np.ndarray:\n    return (value) * (1 - (value))", "output": "Provides the derivative value of the sigmoid function."}
{"task": "search", "input": "search code:\nEvaluate a polynomial f(x) at specified point x and return the value.\n\nChoices:\n0: def hexagonal_num(n: int) -> int:     return n * (2 * n - 1)\n1: def evaluate_poly(poly: Sequence[float], x: float) -> float:     return sum(c * (x**i) for i, c in enumerate(poly))\n2: def counting_sort(collection):     # if the collection is empty, returns empty     if collection == []:         return []      # get some information about the collection     coll_len = len(collection)     coll_max = max(collection)     coll_min = min(collection)      # create the counting array     counting_arr_length = coll_max + 1 - coll_min     counting_arr = [0] * counting_arr_length      # count how much a number appears in the collection     for number in collection:         counting_arr[number - coll_min] += 1      # sum each position with it's predecessors. now, counting_arr[i] tells     # us how many elements <= i has in the collection     for i in range(1, counting_arr_length):         counting_arr[i] = counting_arr[i] + counting_arr[i - 1]      # create the output collection     ordered = [0] * coll_len      # place the elements in the output, respecting the original order (stable     # sort) from end to begin, updating counting_arr     for i in reversed(range(coll_len)):         ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]         counting_arr[collection[i] - coll_min] -= 1      return ordered", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef least_common_multiple_slow(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n\n    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple\n\n    >>> least_common_multiple_slow(5, 2)\n    10\n    >>> least_common_multiple_slow(12, 76)\n    228\n    \"\"\"\n    max_num = first_num if first_num >= second_num else second_num\n    common_mult = max_num\n    while (common_mult % first_num > 0) or (common_mult % second_num > 0):\n        common_mult += max_num\n    return common_mult", "output": "def least_common_multiple_slow(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n\n    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple\n\n    >>> least_common_multiple_slow(5, 2)\n    10\n    >>> least_common_multiple_slow(12, 76)\n    228\n    \"\"\"\n    max_num = first_num if first_num >= second_num else second_num\n    common_mult = max_num\n    while (common_mult % first_num > 0) or (common_mult % second_num > 0):\n        common_mult += max_num\n    return common_mult"}
{"task": "detection", "input": "classify code:\ndef solution():\n    \"\"\"Returns the last 10 digits of the series, 11 + 22 + 33 + ... + 10001000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in xrange(1, 1001):\n        total += i ** i\n    return str(total)[-10:]", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]", "output": "def levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]"}
{"task": "summary", "input": "summarize code:\ndef bitonic_sort(array: list[int], low: int, length: int, direction: int) -> None:\n    if length > 1:\n        middle = int(length / 2)\n        bitonic_sort(array, low, middle, 1)\n        bitonic_sort(array, low + middle, middle, 0)\n        bitonic_merge(array, low, length, direction)", "output": "This function first produces a bitonic sequence by recursively sorting its two"}
{"task": "summary", "input": "summarize code:\ndef roundrobin(*iterables):\n    # Algorithm credited to George Sakkis\n    iterators = map(iter, iterables)\n    for num_active in range(len(iterables), 0, -1):\n        iterators = cycle(islice(iterators, num_active))\n        yield from map(next, iterators)", "output": "Visit input iterables in a cycle until each is exhausted."}
{"task": "detection", "input": "classify code:\ndef decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef insertion_sort[T: Comparable](collection: MutableSequence[T]) -> MutableSequence[T]:\n\n    for insert_index in range(1, len(collection)):\n        insert_value = collection[insert_index]\n        while insert_index > 0 and insert_value < collection[insert_index - 1]:\n            collection[insert_index] = collection[insert_index - 1]\n            insert_index -= 1\n        collection[insert_index] = insert_value\n    return collection", "output": "A pure Python implementation of the insertion sort algorithm"}
{"task": "summary", "input": "summarize code:\ndef parse_file(file_path: str) -> list[Letter]:\n    chars: dict[str, int] = {}\n    with open(file_path) as f:\n        while True:\n            c = f.read(1)\n            if not c:\n                break\n            chars[c] = chars[c] + 1 if c in chars else 1\n    return sorted((Letter(c, f) for c, f in chars.items()), key=lambda x: x.freq)", "output": "Read the file and build a dict of all letters and their"}
{"task": "search", "input": "search code:\nFunction returns the number of bands of a given type in a resistor with n bands\n\nChoices:\n0: def calculate_waiting_times(burst_times: list[int]) -> list[int]:     quantum = 2     rem_burst_times = list(burst_times)     waiting_times = [0] * len(burst_times)     t = 0     while True:         done = True         for i, burst_time in enumerate(burst_times):             if rem_burst_times[i] > 0:                 done = False                 if rem_burst_times[i] > quantum:                     t += quantum                     rem_burst_times[i] -= quantum                 else:                     t += rem_burst_times[i]                     waiting_times[i] = t - burst_time                     rem_burst_times[i] = 0         if done is True:             return waiting_times\n1: def get_band_type_count(total_number_of_bands: int, type_of_band: str) -> int:     if total_number_of_bands not in band_types:         msg = f\"{total_number_of_bands} is not a valid number of bands\"         raise ValueError(msg)     if type_of_band not in band_types[total_number_of_bands]:         msg = f\"{type_of_band} is not valid for a {total_number_of_bands} band resistor\"         raise ValueError(msg)     return band_types[total_number_of_bands][type_of_band]\n2: def _hypothesis_value(data_input_tuple):     hyp_val = 0     for i in range(len(parameter_vector) - 1):         hyp_val += data_input_tuple[i] * parameter_vector[i + 1]     hyp_val += parameter_vector[0]     return hyp_val", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef permute_backtrack(nums: list[int]) -> list[list[int]]:\n\n    def backtrack(start: int) -> None:\n        if start == len(nums) - 1:\n            output.append(nums[:])\n        else:\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack\n\n    output: list[list[int]] = []\n    backtrack(0)\n    return output", "output": "Return all permutations of the given list."}
{"task": "search", "input": "search code:\nCalculate the power of the audio signal from its FFT.\n\nChoices:\n0: def solution():     days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]      day = 6     month = 1     year = 1901      sundays = 0      while year < 2001:         day += 7          if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):             if day > days_per_month[month - 1] and month != 2:                 month += 1                 day = day - days_per_month[month - 2]             elif day > 29 and month == 2:                 month += 1                 day = day - 29         elif day > days_per_month[month - 1]:             month += 1             day = day - days_per_month[month - 2]          if month > 12:             year += 1             month = 1          if year < 2001 and day == 1:             sundays += 1     return sundays\n1: def natural_sort(input_list: list[str]) -> list[str]:      def alphanum_key(key):         return [int(s) if s.isdigit() else s.lower() for s in re.split(\"([0-9]+)\", key)]      return sorted(input_list, key=alphanum_key)\n2: def calculate_signal_power(audio_fft: np.ndarray) -> np.ndarray:     # Calculate the power by squaring the absolute values of the FFT coefficients     return np.square(np.abs(audio_fft))", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2", "output": "def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2"}
{"task": "detection", "input": "classify code:\ndef moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to volume.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_volume(0.82, 3, 300)\n      90\n      >>> moles_to_volume(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (pressure)))", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution(num_picks: int = 20) -> str:\n    total = math.comb(NUM_BALLS, num_picks)\n    missing_colour = math.comb(NUM_BALLS - BALLS_PER_COLOUR, num_picks)\n\n    result = NUM_COLOURS * (1 - missing_colour / total)\n\n    return f\"{result:.9f}\"", "output": "Calculates the expected number of distinct colours"}
{"task": "search", "input": "search code:\nGenerates *chunk_size*-sized chunk ranges for an input with length *input_size*.\n\nChoices:\n0: def carrier_concentration(     electron_conc: float,     hole_conc: float,     intrinsic_conc: float, ) -> tuple:     if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:         raise ValueError(\"You cannot supply more or less than 2 values\")     elif electron_conc < 0:         raise ValueError(\"Electron concentration cannot be negative in a semiconductor\")     elif hole_conc < 0:         raise ValueError(\"Hole concentration cannot be negative in a semiconductor\")     elif intrinsic_conc < 0:         raise ValueError(             \"Intrinsic concentration cannot be negative in a semiconductor\"         )     elif electron_conc == 0:         return (             \"electron_conc\",             intrinsic_conc**2 / hole_conc,         )     elif hole_conc == 0:         return (             \"hole_conc\",             intrinsic_conc**2 / electron_conc,         )     elif intrinsic_conc == 0:         return (             \"intrinsic_conc\",             (electron_conc * hole_conc) ** 0.5,         )     else:         return (-1, -1)\n1: def chunk_ranges(input_size, chunk_size, input_offset=0, overlap_size=0, align=False):     input_size = _validate_positive_int(         input_size, 'input_size', strictly_positive=False)     chunk_size = _validate_positive_int(chunk_size, 'chunk_size')     input_offset = _validate_positive_int(         input_offset, 'input_offset', strictly_positive=False)     overlap_size = _validate_positive_int(         overlap_size, 'overlap_size', strictly_positive=False)      input_stop = input_offset + input_size      if align:         initial_chunk_len = chunk_size - \\             input_offset % (chunk_size - overlap_size)         if initial_chunk_len != overlap_size:             yield (input_offset, min(input_offset + initial_chunk_len, input_stop))             if input_offset + initial_chunk_len >= input_stop:                 return             input_offset = input_offset + initial_chunk_len - overlap_size      for i in range(input_offset, input_stop, chunk_size - overlap_size):         yield (i, min(i + chunk_size, input_stop))          if i + chunk_size >= input_stop:             return\n2: def triplewise(iterable):     # This deviates from the itertools documentation recipe - see     # https://github.com/more-itertools/more-itertools/issues/889     t1, t2, t3 = tee(iterable, 3)     next(t3, None)     next(t3, None)     next(t2, None)     return zip(t1, t2, t3)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef combination_sum_iv_dp_array(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef find_repeat(\n    matrix_g: list[list[str]], row: int, column: int, size: int\n) -> set[tuple[int, int]]:\n\n    column = size - 1 - column\n    visited = set()\n    repeated = set()\n\n    if (color := matrix_g[column][row]) != \"-\":\n\n        def dfs(row_n: int, column_n: int) -> None:\n            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:\n                return\n            if (row_n, column_n) in visited:\n                return\n            visited.add((row_n, column_n))\n            if matrix_g[row_n][column_n] == color:\n                repeated.add((row_n, column_n))\n                dfs(row_n - 1, column_n)\n                dfs(row_n + 1, column_n)\n                dfs(row_n, column_n - 1)\n                dfs(row_n, column_n + 1)\n\n        dfs(column, row)\n\n    return repeated", "output": "Finds all connected elements of the same type from a given position."}
{"task": "summary", "input": "summarize code:\ndef pythagorean_triple(max_perimeter: int) -> typing.Counter[int]:\n    triplets: typing.Counter[int] = Counter()\n    for base in range(1, max_perimeter + 1):\n        for perpendicular in range(base, max_perimeter + 1):\n            hypotenuse = (base * base + perpendicular * perpendicular) ** 0.5\n            if hypotenuse == int(hypotenuse):\n                perimeter = int(base + perpendicular + hypotenuse)\n                if perimeter > max_perimeter:\n                    continue\n                triplets[perimeter] += 1\n    return triplets", "output": "Returns a dictionary with keys as the perimeter of a right angled triangle"}
{"task": "summary", "input": "summarize code:\ndef my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:\n    kernels = {\n        1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),\n        3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),\n        5: np.array(\n            [\n                [0, 0, -1, 0, 0],\n                [0, -1, -2, -1, 0],\n                [-1, -2, 16, -2, -1],\n                [0, -1, -2, -1, 0],\n                [0, 0, -1, 0, 0],\n            ]\n        ),\n        7: np.array(\n            [\n                [0, 0, 0, -1, 0, 0, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, -2, -7, -10, -7, -2, 0],\n                [-1, -3, -10, 68, -10, -3, -1],\n                [0, -2, -7, -10, -7, -2, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, 0, 0, -1, 0, 0, 0],\n            ]\n        ),\n    }\n    if ksize not in kernels:\n        msg = f\"ksize must be in {tuple(kernels)}\"\n        raise ValueError(msg)\n\n    # Apply the Laplacian kernel using convolution\n    return filter2D(\n        src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)\n    )", "output": "which can be 1, 3, 5, or 7."}
{"task": "summary", "input": "summarize code:\ndef all_equal(iterable, key=None):\n    iterator = groupby(iterable, key)\n    for first in iterator:\n        for second in iterator:\n            return False\n        return True\n    return True", "output": "Returns ``True`` if all the elements are equal to each other."}
{"task": "detection", "input": "classify code:\ndef stalin_sort(sequence: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Stalin sort algorithm.\n\n    >>> stalin_sort([4, 3, 5, 2, 1, 7])\n    [4, 5, 7]\n\n    >>> stalin_sort([1, 2, 3, 4])\n    [1, 2, 3, 4]\n\n    >>> stalin_sort([4, 5, 5, 2, 3])\n    [4, 5, 5]\n\n    >>> stalin_sort([6, 11, 12, 4, 1, 5])\n    [6, 11, 12]\n\n    >>> stalin_sort([5, 0, 4, 3])\n    [5]\n\n    >>> stalin_sort([5, 4, 3, 2, 1])\n    [5]\n\n    >>> stalin_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> stalin_sort([1, 2, 8, 7, 6])\n    [1, 2, 8]\n    \"\"\"\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result", "output": "CORRECT"}
{"task": "search", "input": "search code:\nImplements the LeakyReLU activation function.\n\nChoices:\n0: def main():     num = int(input(\"Enter an integer to see if it is an Armstrong number: \").strip())     print(f\"{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number.\")     print(f\"{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number.\")     print(f\"{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number.\")\n1: def leaky_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:     return np.where(vector > 0, vector, alpha * vector)\n2: def multiplication_table(number: int, number_of_terms: int) -> str:     return \"\\n\".join(         f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)     )", "output": "1"}
{"task": "search", "input": "search code:\nThis function takes url and return all valid urls\n\nChoices:\n0: def _shift_to_odd(n):     'Return s, d such that 2**s * d == n'     s = ((n - 1) ^ n).bit_length() - 1     d = n >> s     assert (1 << s) * d == n and d & 1 and s >= 0     return s, d\n1: def emails_from_url(url: str = \"https://github.com\") -> list[str]:     # Get the base domain from the url     domain = get_domain_name(url)      # Initialize the parser     parser = Parser(domain)      try:         # Open URL         r = httpx.get(url, timeout=10, follow_redirects=True)          # pass the raw HTML to the parser to get links         parser.feed(r.text)          # Get links and loop through         valid_emails = set()         for link in parser.urls:             # open URL.             # Check if the link is already absolute             if not link.startswith(\"http://\") and not link.startswith(\"https://\"):                 # Prepend protocol only if link starts with domain, normalize otherwise                 if link.startswith(domain):                     link = f\"https://{link}\"                 else:                     link = parse.urljoin(f\"https://{domain}\", link)             try:                 read = httpx.get(link, timeout=10, follow_redirects=True)                 # Get the valid email.                 emails = re.findall(\"[a-zA-Z0-9]+@\" + domain, read.text)                 # If not in list then append it.                 for email in emails:                     valid_emails.add(email)             except ValueError:                 pass     except ValueError:         raise SystemExit(1)      # Finally return a sorted list of email addresses with no duplicates.     return sorted(valid_emails)\n2: def solution(limit: int = 10000) -> int:     lychrel_nums = []     for num in range(1, limit):         iterations = 0         a = num         while iterations < 50:             num = sum_reverse(num)             iterations += 1             if is_palindrome(num):                 break         else:             lychrel_nums.append(a)     return len(lychrel_nums)", "output": "1"}
{"task": "search", "input": "search code:\nWill split the string up into all the values separated by the separator\n\nChoices:\n0: def solution(n: int = 2000000) -> int:      return sum(num for num in range(3, n, 2) if is_prime(num)) + 2 if n > 2 else 0\n1: def split(string: str, separator: str = \" \") -> list:      split_words = []      last_index = 0     for index, char in enumerate(string):         if char == separator:             split_words.append(string[last_index:index])             last_index = index + 1         if index + 1 == len(string):             split_words.append(string[last_index : index + 1])     return split_words\n2: def stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):     children = tee(iterable, len(offsets))      return zip_offset(         *children, offsets=offsets, longest=longest, fillvalue=fillvalue     )", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef exactly_n(iterable, n, predicate=bool):\n    iterator = filter(predicate, iterable)\n    if n <= 0:\n        if n < 0:\n            return False\n        for _ in iterator:\n            return False\n        return True\n\n    iterator = islice(iterator, n - 1, None)\n    for _ in iterator:\n        for _ in iterator:\n            return False\n        return True\n    return False", "output": "Return ``True`` if exactly ``n`` items in the iterable are ``True``"}
{"task": "summary", "input": "summarize code:\ndef convex_hull_bf(points: list[Point]) -> list[Point]:\n\n    points = sorted(_validate_input(points))\n    n = len(points)\n    convex_set = set()\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            points_left_of_ij = points_right_of_ij = False\n            ij_part_of_convex_hull = True\n            for k in range(n):\n                if k not in {i, j}:\n                    det_k = _det(points[i], points[j], points[k])\n\n                    if det_k > 0:\n                        points_left_of_ij = True\n                    elif det_k < 0:\n                        points_right_of_ij = True\n                    # point[i], point[j], point[k] all lie on a straight line\n                    # if point[k] is to the left of point[i] or it's to the\n                    # right of point[j], then point[i], point[j] cannot be\n                    # part of the convex hull of A\n                    elif points[k] < points[i] or points[k] > points[j]:\n                        ij_part_of_convex_hull = False\n                        break\n\n                if points_left_of_ij and points_right_of_ij:\n                    ij_part_of_convex_hull = False\n                    break\n\n            if ij_part_of_convex_hull:\n                convex_set.update([points[i], points[j]])\n\n    return sorted(convex_set)", "output": "Constructs the convex hull of a set of 2D points using a brute force algorithm."}
{"task": "summary", "input": "summarize code:\ndef selection_sort(collection: list[int]) -> list[int]:\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection", "output": "Sorts a list in ascending order using the selection sort algorithm."}
{"task": "search", "input": "search code:\nPrint order of matrix with Ai as Matrix.\n\nChoices:\n0: def print_optimal_solution(optimal_solution: list[list[int]], i: int, j: int):      if i == j:         print(\"A\" + str(i), end=\" \")     else:         print(\"(\", end=\" \")         print_optimal_solution(optimal_solution, i, optimal_solution[i][j])         print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j)         print(\")\", end=\" \")\n1: def floor(x: float) -> int:     return int(x) if x - int(x) >= 0 else int(x) - 1\n2: def angle_comparer(point: tuple[int, int], minx: int, miny: int) -> float:     # sort the points accorgind to the angle from the lowest and the most left point     x, y = point     return degrees(atan2(y - miny, x - minx))", "output": "0"}
{"task": "search", "input": "search code:\nReturn a 2-tuple with a list containing the first *n* elements of\n\nChoices:\n0: def sigmoid(vector: np.ndarray) -> np.ndarray:     return 1 / (1 + np.exp(-vector))\n1: def spy(iterable, n=1):     p, q = tee(iterable)     return take(n, q), p\n2: def bell_numbers(max_set_length: int) -> list[int]:     if max_set_length < 0:         raise ValueError(\"max_set_length must be non-negative\")      bell = [0] * (max_set_length + 1)     bell[0] = 1      for i in range(1, max_set_length + 1):         for j in range(i):             bell[i] += _binomial_coefficient(i - 1, j) * bell[j]      return bell", "output": "1"}
{"task": "search", "input": "search code:\n| Plays FizzBuzz.\n\nChoices:\n0: def fizz_buzz(number: int, iterations: int) -> str:     if not isinstance(iterations, int):         raise ValueError(\"iterations must be defined as integers\")     if not isinstance(number, int) or not number >= 1:         raise ValueError(         )     if not iterations >= 1:         raise ValueError(\"Iterations must be done more than 0 times to play FizzBuzz\")      out = \"\"     while number <= iterations:         if number % 3 == 0:             out += \"Fizz\"         if number % 5 == 0:             out += \"Buzz\"         if 0 not in (number % 3, number % 5):             out += str(number)          # print(out)         number += 1         out += \" \"     return out\n1: def has_same_digits(num1: int, num2: int) -> bool:     return sorted(str(num1)) == sorted(str(num2))\n2: def prim_heap(graph: list, root: Vertex) -> Iterator[tuple]:     for u in graph:         u.key = math.inf         u.pi = None     root.key = 0      h = list(graph)     hq.heapify(h)      while h:         u = hq.heappop(h)         for v in u.neighbors:             if (v in h) and (u.edges[v.id] < v.key):                 v.pi = u                 v.key = u.edges[v.id]                 hq.heapify(h)      for i in range(1, len(graph)):         yield (int(graph[i].id) + 1, int(graph[i].pi.id) + 1)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef nand_gate(input_1: int, input_2: int) -> int:\n    return int(not (input_1 and input_2))", "output": "Calculate NAND of the input values"}
{"task": "detection", "input": "classify code:\ndef text_justification(word: str, max_width: int) -> list:\n    \"\"\"\n    Will format the string such that each line has exactly\n    (max_width) characters and is fully (left and right) justified,\n    and return the list of justified text.\n\n    example 1:\n    string = \"This is an example of text justification.\"\n    max_width = 16\n\n    output = ['This    is    an',\n              'example  of text',\n              'justification.  ']\n\n    >>> text_justification(\"This is an example of text justification.\", 16)\n    ['This    is    an', 'example  of text', 'justification.  ']\n\n    example 2:\n    string = \"Two roads diverged in a yellow wood\"\n    max_width = 16\n    output = ['Two        roads',\n              'diverged   in  a',\n              'yellow wood     ']\n\n    >>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n    ['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\n    Time complexity: O(m*n)\n    Space complexity: O(m*n)\n    \"\"\"\n\n    # Converting string into list of strings split by a space\n    words = word.split()\n\n    def justify(line: list, width: int, max_width: int) -> str:\n        overall_spaces_count = max_width - width\n        words_count = len(line)\n        if len(line) == 1:\n            # if there is only word in line\n            # just insert overall_spaces_count for the remainder of line\n            return line[0] + \" \" * overall_spaces_count\n        else:\n            spaces_to_insert_between_words = words_count - 1\n            # num_spaces_between_words_list[i] : tells you to insert\n            # num_spaces_between_words_list[i] spaces\n            # after word on line[i]\n            num_spaces_between_words_list = spaces_to_insert_between_words * [\n                overall_spaces_count // spaces_to_insert_between_words\n            ]\n            spaces_count_in_locations = (\n                overall_spaces_count % spaces_to_insert_between_words\n            )\n            # distribute spaces via round robin to the left words\n            for i in range(spaces_count_in_locations):\n                num_spaces_between_words_list[i] += 1\n            aligned_words_list = []\n            for i in range(spaces_to_insert_between_words):\n                # add the word\n                aligned_words_list.append(line[i])\n                # add the spaces to insert\n                aligned_words_list.append(num_spaces_between_words_list[i] * \" \")\n            # just add the last word to the sentence\n            aligned_words_list.append(line[-1])\n            # join the aligned words list to form a justified line\n            return \"\".join(aligned_words_list)\n\n    answer = []\n    line: list[str] = []\n    width = 0\n    for inner_word in words:\n        if width + len(inner_word) + len(line) <= max_width:\n            # keep adding words until we can fill out max_width\n            # width = sum of length of all words (without overall_spaces_count)\n            # len(inner_word) = length of current inner_word\n            # len(line) = number of overall_spaces_count to insert between words\n            line.append(inner_word)\n            width += len(inner_word)\n        else:\n            # justify the line and add it to result\n            answer.append(justify(line, width, max_width))\n            # reset new line and new width\n            line, width = [inner_word], len(inner_word)\n    remaining_spaces = max_width - width - len(line)\n    answer.append(\" \".join(line) + (remaining_spaces + 1) * \" \")\n    return answer", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:\n    output = np.zeros_like(image)\n    image_padded = np.zeros(\n        (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)\n    )\n\n    # Copy image to padded image\n    image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image\n\n    # Iterate over image & apply kernel\n    for x in range(image.shape[1]):\n        for y in range(image.shape[0]):\n            summation = (\n                kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]\n            ).sum()\n            output[y, x] = int(summation == 5)\n    return output", "output": "Return eroded image"}
{"task": "search", "input": "search code:\nReturns a list of all left and right truncated numbers of n\n\nChoices:\n0: def list_truncated_nums(n: int) -> list[int]:     str_num = str(n)     list_nums = [n]     for i in range(1, len(str_num)):         list_nums.append(int(str_num[i:]))         list_nums.append(int(str_num[:-i]))     return list_nums\n1: def get_files_url() -> str:     with open(os.environ[\"GITHUB_EVENT_PATH\"]) as file:         event = json.load(file)     return event[\"pull_request\"][\"url\"] + \"/files\"\n2: def fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:      try:         # Has user provided both inputs?         if not drug_name or not zip_code:             return None          request_url = BASE_URL.format(drug_name, zip_code)         response = httpx.get(request_url, timeout=10).raise_for_status()          # Scrape the data using bs4         soup = BeautifulSoup(response.text, \"html.parser\")          # This list will store the name and price.         pharmacy_price_list = []          # Fetch all the grids that contain the items.         grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})         if grid_list and len(grid_list) > 0:             for grid in grid_list:                 # Get the pharmacy price.                 pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text                  # Get the price of the drug.                 price = grid.find(\"span\", {\"p\", \"price price-large\"}).text                  pharmacy_price_list.append(                     {                         \"pharmacy_name\": pharmacy_name,                         \"price\": price,                     }                 )          return pharmacy_price_list      except (httpx.HTTPError, ValueError):         return None", "output": "0"}
{"task": "detection", "input": "classify code:\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\"", "output": "Calculates the work required to move an object from one orbit to another in a"}
{"task": "detection", "input": "classify code:\ndef moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to volume.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_volume(0.82, 3, 300)\n      90\n      >>> moles_to_volume(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (pressure)))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\nChoices:\n0: def solution(number_unique_partitions: int = 5000) -> int | None:     for number_to_partition in range(1, NUM_PRIMES):         if len(partition(number_to_partition)) > number_unique_partitions:             return number_to_partition     return None\n1: def get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:     coefficients = {1}     previous_coefficients = [1]     for _ in range(2, depth + 1):         coefficients_begins_one = [*previous_coefficients, 0]         coefficients_ends_one = [0, *previous_coefficients]         previous_coefficients = []         for x, y in zip(coefficients_begins_one, coefficients_ends_one):             coefficients.add(x + y)             previous_coefficients.append(x + y)     return coefficients\n2: def logical_left_shift(number: int, shift_amount: int) -> str:     if number < 0 or shift_amount < 0:         raise ValueError(\"both inputs must be positive integers\")      binary_number = str(bin(number))     binary_number += \"0\" * shift_amount     return binary_number", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef equilibrium_index(arr: list[int], size: int) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr : The input array of integers.\n        size : The size of the array.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0], 7)\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5], 5)\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1], 5)\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3], 6)\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i in range(size):\n        total_sum -= arr[i]\n        if left_sum == total_sum:\n            return i\n        left_sum += arr[i]\n\n    return -1", "output": "def equilibrium_index(arr: list[int]) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5])\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1])\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3])\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i, value in enumerate(arr):\n        total_sum -= value\n        if left_sum == total_sum:\n            return i\n        left_sum += value\n\n    return -1"}
{"task": "search", "input": "search code:\nWrites given to_write string (should only consist of 0's and 1's) as bytes in the\n\nChoices:\n0: def write_file_binary(file_path: str, to_write: str) -> None:     byte_length = 8     try:         with open(file_path, \"wb\") as opened_file:             result_byte_array = [                 to_write[i : i + byte_length]                 for i in range(0, len(to_write), byte_length)             ]              if len(result_byte_array[-1]) % byte_length == 0:                 result_byte_array.append(\"10000000\")             else:                 result_byte_array[-1] += \"1\" + \"0\" * (                     byte_length - len(result_byte_array[-1]) - 1                 )              for elem in result_byte_array:                 opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))     except OSError:         print(\"File not accessible\")         sys.exit()\n1: def groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):     ret = groupby(iterable, keyfunc)     if valuefunc:         ret = ((k, map(valuefunc, g)) for k, g in ret)     if reducefunc:         ret = ((k, reducefunc(g)) for k, g in ret)      return ret\n2: def procentual_proximity(     source_data: list[list[float]], weights: list[int] ) -> list[list[float]]:      data_lists = get_data(source_data)     score_lists = calculate_each_score(data_lists, weights)     final_scores = generate_final_scores(score_lists)      # append scores to source data     for i, ele in enumerate(final_scores):         source_data[i].append(ele)      return source_data", "output": "0"}
{"task": "search", "input": "search code:\nGiven a list of integers where every element appears twice except for one,\n\nChoices:\n0: def swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:     return vector * sigmoid(trainable_parameter * vector)\n1: def find_unique_number(arr: list[int]) -> int:     if not arr:         raise ValueError(\"input list must not be empty\")     if not all(isinstance(x, int) for x in arr):         raise TypeError(\"all elements must be integers\")      result = 0     for num in arr:         result ^= num     return result\n2: def solution(max_perimeter: int = 10**9) -> int:      prev_value = 1     value = 2      perimeters_sum = 0     i = 0     perimeter = 0     while perimeter <= max_perimeter:         perimeters_sum += perimeter          prev_value += 2 * value         value += prev_value          perimeter = 2 * value + 2 if i % 2 == 0 else 2 * value - 2         i += 1      return perimeters_sum", "output": "1"}
{"task": "search", "input": "search code:\nTreats curve as a collection of linear lines and sums the area of the\n\nChoices:\n0: def sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:     total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)     # formula for sum of series     return total\n1: def trapezoidal_area(     fnc: Callable[[float], float],     x_start: float,     x_end: float,     steps: int = 100, ) -> float:     x1 = x_start     fx1 = fnc(x_start)     area = 0.0     for _ in range(steps):         # Approximates small segments of curve as linear and solve         # for trapezoidal area         x2 = (x_end - x_start) / steps + x1         fx2 = fnc(x2)         area += abs(fx2 + fx1) * (x2 - x1) / 2         # Increment step         x1 = x2         fx1 = fx2     return area\n2: def sentence_to_title_case(input_str: str) -> str:      return \" \".join(to_title_case(word) for word in input_str.split())", "output": "1"}
{"task": "detection", "input": "classify code:\ndef three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef filter_except(validator, iterable, *exceptions):\n    for item in iterable:\n        try:\n            validator(item)\n        except exceptions:\n            pass\n        else:\n            yield item", "output": "Yield the items from *iterable* for which the *validator* function does"}
{"task": "summary", "input": "summarize code:\ndef draw_vicsek_fractal(x: float, y: float, length: float, depth: float, color=\"blue\"):\n    turtle.speed(0)\n    turtle.hideturtle()\n    set_color(color)\n    draw_fractal_recursive(x, y, length, depth)\n    turtle.Screen().update()", "output": "Draw the Vicsek fractal at the specified position, with the specified"}
{"task": "search", "input": "search code:\nRemove duplicates from sentence\n\nChoices:\n0: def remove_duplicates(sentence: str) -> str:     return \" \".join(sorted(set(sentence.split())))\n1: def from_file(filename, sep=\"\\n\"):     \"Parse a file into a list of strings, separated by sep.\"     with open(filename) as file:         return file.read().strip().split(sep)\n2: def leaky_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:     return np.where(vector > 0, vector, alpha * vector)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef number_of_divisors(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    div = 1\n    temp = 1\n    while n % 2 == 0:\n        temp += 1\n        n = int(n / 2)\n    div *= temp\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        temp = 1\n        while n % i == 0:\n            temp += 1\n            n = int(n / i)\n        div *= temp\n    if n > 1:\n        div *= 2\n    return div", "output": "Calculate Number of Divisors of an Integer."}
{"task": "summary", "input": "summarize code:\ndef reverse_letters(sentence: str, length: int = 0) -> str:\n    return \" \".join(\n        \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()\n    )", "output": "Reverse all words that are longer than the given length of characters in a sentence."}
{"task": "summary", "input": "summarize code:\ndef relative_time(d, other=None, ndigits=0):\n    drt, unit = decimal_relative_time(d, other, ndigits, cardinalize=True)\n    phrase = 'ago'\n    if drt < 0:\n        phrase = 'from now'\n    return f'{abs(drt):g} {unit} {phrase}'", "output": "Get a string representation of the difference between two"}
{"task": "summary", "input": "summarize code:\ndef my_dfs(graph, start, end, path=None):\n    path = (path or []) + [start]\n    if start == end:\n        paths.append(path)\n    for node in graph[start]:\n        if tuple(node) not in path:\n            my_dfs(graph, tuple(node), end, path)", "output": "find different DFS walk from given node to Header node"}
{"task": "summary", "input": "summarize code:\ndef area_under_curve_estimator(\n    iterations: int,\n    function_to_integrate: Callable[[float], float],\n    min_value: float = 0.0,\n    max_value: float = 1.0,\n) -> float:\n\n    return mean(\n        function_to_integrate(uniform(min_value, max_value)) for _ in range(iterations)\n    ) * (max_value - min_value)", "output": "An implementation of the Monte Carlo method to find area under"}
{"task": "detection", "input": "classify code:\ndef scalar_multiply(matrix: List[list], n: int) -> List[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef left_rotate_32(i: int, shift: int) -> int:\n    if i < 0:\n        raise ValueError(\"Input must be non-negative\")\n    if shift < 0:\n        raise ValueError(\"Shift must be non-negative\")\n    return ((i << shift) ^ (i >> (32 - shift))) % 2**32", "output": "Rotate the bits of a given int left by a given amount."}
{"task": "search", "input": "search code:\nReturn True if it's possible to search the word suffix\n\nChoices:\n0: def encipher(message: str, cipher_map: dict[str, str]) -> str:     return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())\n1: def encode(plaintext: str, key: str) -> str:      table = generate_table(key)     plaintext = prepare_input(plaintext)     ciphertext = \"\"      for char1, char2 in chunker(plaintext, 2):         row1, col1 = divmod(table.index(char1), 5)         row2, col2 = divmod(table.index(char2), 5)          if row1 == row2:             ciphertext += table[row1 * 5 + (col1 + 1) % 5]             ciphertext += table[row2 * 5 + (col2 + 1) % 5]         elif col1 == col2:             ciphertext += table[((row1 + 1) % 5) * 5 + col1]             ciphertext += table[((row2 + 1) % 5) * 5 + col2]         else:  # rectangle             ciphertext += table[row1 * 5 + col2]             ciphertext += table[row2 * 5 + col1]      return ciphertext\n2: def exits_word(     board: list[list[str]],     word: str,     row: int,     column: int,     word_index: int,     visited_points_set: set[int], ) -> bool:      if board[row][column] != word[word_index]:         return False      if word_index == len(word) - 1:         return True      traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]     len_board = len(board)     len_board_column = len(board[0])     for direction in traverts_directions:         next_i = row + direction[0]         next_j = column + direction[1]         if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):             continue          key = get_point_key(len_board, len_board_column, next_i, next_j)         if key in visited_points_set:             continue          visited_points_set.add(key)         if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):             return True          visited_points_set.remove(key)      return False", "output": "2"}
{"task": "detection", "input": "classify code:\ndef find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solve(matrix: Matrix, vector: Matrix) -> Matrix:\n    size: int = len(matrix)\n    augmented: Matrix = [[0 for _ in range(size + 1)] for _ in range(size)]\n    row: int\n    row2: int\n    col: int\n    col2: int\n    pivot_row: int\n    ratio: float\n\n    for row in range(size):\n        for col in range(size):\n            augmented[row][col] = matrix[row][col]\n\n        augmented[row][size] = vector[row][0]\n\n    row = 0\n    col = 0\n    while row < size and col < size:\n        # pivoting\n        pivot_row = max((abs(augmented[row2][col]), row2) for row2 in range(col, size))[\n            1\n        ]\n        if augmented[pivot_row][col] == 0:\n            col += 1\n            continue\n        else:\n            augmented[row], augmented[pivot_row] = augmented[pivot_row], augmented[row]\n\n        for row2 in range(row + 1, size):\n            ratio = augmented[row2][col] / augmented[row][col]\n            augmented[row2][col] = 0\n            for col2 in range(col + 1, size + 1):\n                augmented[row2][col2] -= augmented[row][col2] * ratio\n\n        row += 1\n        col += 1\n\n    # back substitution\n    for col in range(1, size):\n        for row in range(col):\n            ratio = augmented[row][col] / augmented[col][col]\n            for col2 in range(col, size + 1):\n                augmented[row][col2] -= augmented[col][col2] * ratio\n\n    # round to get rid of numbers like 2.000000000000004\n    return [\n        [round(augmented[row][size] / augmented[row][row], 10)] for row in range(size)\n    ]", "output": "Solve the linear system of equations Ax = b (A = \"matrix\", b = \"vector\")"}
{"task": "search", "input": "search code:\nCompresses given data_bits using Lempel-Ziv-Welch compression algorithm\n\nChoices:\n0: def compress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         add_key_to_lexicon(lexicon, curr_string, index, last_match_id)         index += 1         curr_string = \"\"      while curr_string != \"\" and curr_string not in lexicon:         curr_string += \"0\"      if curr_string != \"\":         last_match_id = lexicon[curr_string]         result += last_match_id      return result\n1: def sum_of_digits(num: int, base: int) -> str:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      num_str = int_to_base(num, base)     res = sum(int(char, base) for char in num_str)     res_str = int_to_base(res, base)     return res_str\n2: def split_after(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         buf.append(item)         if pred(item) and buf:             yield buf             if maxsplit == 1:                 buf = list(it)                 if buf:                     yield buf                 return             buf = []             maxsplit -= 1     if buf:         yield buf", "output": "0"}
{"task": "search", "input": "search code:\nComputes the Fibonacci number for input n by iterating through n numbers\n\nChoices:\n0: def merge(input_list: list, low: int, mid: int, high: int) -> list:     result = []     left, right = input_list[low:mid], input_list[mid : high + 1]     while left and right:         result.append((left if left[0] <= right[0] else right).pop(0))     input_list[low : high + 1] = result + left + right     return input_list\n1: def fibonacci(n: int) -> int:     if n == 1 or not isinstance(n, int):         return 0     elif n == 2:         return 1     else:         sequence = [0, 1]         for i in range(2, n + 1):             sequence.append(sequence[i - 1] + sequence[i - 2])          return sequence[n]\n2: def is_9_pandigital(n: int) -> bool:     s = str(n)     return len(s) == 9 and set(s) == set(\"123456789\")", "output": "1"}
{"task": "search", "input": "search code:\nPerforms a nearest neighbor search in a KD-Tree for a given query point.\n\nChoices:\n0: def list_truncated_nums(n: int) -> list[int]:     str_num = str(n)     list_nums = [n]     for i in range(1, len(str_num)):         list_nums.append(int(str_num[i:]))         list_nums.append(int(str_num[:-i]))     return list_nums\n1: def nearest_neighbour_search(     root: KDNode | None, query_point: list[float] ) -> tuple[list[float] | None, float, int]:     nearest_point: list[float] | None = None     nearest_dist: float = float(\"inf\")     nodes_visited: int = 0      def search(node: KDNode | None, depth: int = 0) -> None:         nonlocal nearest_point, nearest_dist, nodes_visited         if node is None:             return          nodes_visited += 1          # Calculate the current distance (squared distance)         current_point = node.point         current_dist = sum(             (query_coord - point_coord) ** 2             for query_coord, point_coord in zip(query_point, current_point)         )          # Update nearest point if the current node is closer         if nearest_point is None or current_dist < nearest_dist:             nearest_point = current_point             nearest_dist = current_dist          # Determine which subtree to search first (based on axis and query point)         k = len(query_point)  # Dimensionality of points         axis = depth % k          if query_point[axis] <= current_point[axis]:             nearer_subtree = node.left             further_subtree = node.right         else:             nearer_subtree = node.right             further_subtree = node.left          # Search the nearer subtree first         search(nearer_subtree, depth + 1)          # If the further subtree has a closer point         if (query_point[axis] - current_point[axis]) ** 2 < nearest_dist:             search(further_subtree, depth + 1)      search(root, 0)     return nearest_point, nearest_dist, nodes_visited\n2: def gunzip_bytes(bytestring):     return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef permutation_index(element, iterable):\n    index = 0\n    pool = list(iterable)\n    for i, x in zip(range(len(pool), -1, -1), element):\n        r = pool.index(x)\n        index = index * i + r\n        del pool[r]\n\n    return index", "output": "Equivalent to ``list(permutations(iterable, r)).index(element)```"}
{"task": "search", "input": "search code:\nCalculate the distance between the two endpoints of two vectors without numpy.\n\nChoices:\n0: def while_solution(max_number: int = 10**8) -> int:      prime_numbers = calculate_prime_numbers(max_number // 2)      semiprimes_count = 0     left = 0     right = len(prime_numbers) - 1     while left <= right:         while prime_numbers[left] * prime_numbers[right] >= max_number:             right -= 1         semiprimes_count += right - left + 1         left += 1      return semiprimes_count\n1: def locate(iterable, pred=bool, window_size=None):     if window_size is None:         return compress(count(), map(pred, iterable))      if window_size < 1:         raise ValueError('window size must be at least 1')      it = windowed(iterable, window_size, fillvalue=_marker)     return compress(count(), starmap(pred, it))\n2: def euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:     return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef util_color(\n    graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int\n) -> bool:\n\n    # Base Case\n    if index == len(graph):\n        return True\n\n    # Recursive Step\n    for i in range(max_colors):\n        if valid_coloring(graph[index], colored_vertices, i):\n            # Color current vertex\n            colored_vertices[index] = i\n            # Validate coloring\n            if util_color(graph, max_colors, colored_vertices, index + 1):\n                return True\n            # Backtrack\n            colored_vertices[index] = -1\n    return False", "output": "Pseudo-Code"}
{"task": "detection", "input": "classify code:\ndef simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set", "output": "CORRECT"}
{"task": "search", "input": "search code:\nSolve the Josephus problem for num_people and a step_size recursively.\n\nChoices:\n0: def remove_digit(num: int) -> int:      if not isinstance(num, int):         raise TypeError(\"only integers accepted as input\")     else:         num_str = str(abs(num))         num_transpositions = [list(num_str) for char in range(len(num_str))]         for index in range(len(num_str)):             num_transpositions[index].pop(index)         return max(             int(\"\".join(list(transposition))) for transposition in num_transpositions         )\n1: def josephus_recursive(num_people: int, step_size: int) -> int:     if (         not isinstance(num_people, int)         or not isinstance(step_size, int)         or num_people <= 0         or step_size <= 0     ):         raise ValueError(\"num_people or step_size is not a positive integer.\")      if num_people == 1:         return 0      return (josephus_recursive(num_people - 1, step_size) + step_size) % num_people\n2: def zero_vector(dimension: int) -> Vector:     # precondition     assert isinstance(dimension, int)     return Vector([0] * dimension)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef decimal_to_negative_base_2(num: int) -> int:\n    \"\"\"\n    This function returns the number negative base 2\n        of the decimal number of the input data.\n\n    Args:\n        int: The decimal number to convert.\n\n    Returns:\n        int: The negative base 2 number.\n\n    Examples:\n        >>> decimal_to_negative_base_2(0)\n        0\n        >>> decimal_to_negative_base_2(-19)\n        111101\n        >>> decimal_to_negative_base_2(4)\n        100\n        >>> decimal_to_negative_base_2(7)\n        11011\n    \"\"\"\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef concave_triangle_area(circles_number: int) -> float:\n\n    intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (\n        2 * (circles_number**2 + 1)\n    )\n    intersection_x = circles_number * intersection_y\n\n    triangle_area = intersection_x * intersection_y / 2\n    concave_region_area = circle_bottom_arc_integral(\n        1 / 2\n    ) - circle_bottom_arc_integral(intersection_x)\n\n    return triangle_area + concave_region_area", "output": "Returns area of concave triangle"}
{"task": "detection", "input": "classify code:\ndef djb2(s: str) -> int:\n    \"\"\"\n    Implementation of djb2 hash algorithm that\n    is popular because of it's magic constants.\n\n    >>> djb2('Algorithms')\n    3782405311\n\n    >>> djb2('scramble bits')\n    1609059040\n    \"\"\"\n    hash_value = 5381\n    for x in s:\n        hash_value = ((hash_value << 5) + hash_value) + ord(x)\n    return hash_value & 0xFFFFFFFF", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef equality(iterable: list) -> bool:\n    \"\"\"\n    Check the equality of ALL elements in an iterable\n    >>> equality([1, 2, 3, 4])\n    False\n    >>> equality([2, 2, 2, 2])\n    True\n    >>> equality([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    return len(set(iterable)) in (0, 1)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nBreak *iterable* into lists of approximately length *n*.\n\nChoices:\n0: def swap_odd_even_bits(num: int) -> int:     # Get all even bits - 0xAAAAAAAA is a 32-bit number with all even bits set to 1     even_bits = num & 0xAAAAAAAA      # Get all odd bits - 0x55555555 is a 32-bit number with all odd bits set to 1     odd_bits = num & 0x55555555      # Right shift even bits and left shift odd bits and swap them     return even_bits >> 1 | odd_bits << 1\n1: def chunked_even(iterable, n):     iterator = iter(iterable)      # Initialize a buffer to process the chunks while keeping     # some back to fill any underfilled chunks     min_buffer = (n - 1) * (n - 2)     buffer = list(islice(iterator, min_buffer))      # Append items until we have a completed chunk     for _ in islice(map(buffer.append, iterator), n, None, n):         yield buffer[:n]         del buffer[:n]      # Check if any chunks need addition processing     if not buffer:         return     length = len(buffer)      # Chunks are either size `full_size <= n` or `partial_size = full_size - 1`     q, r = divmod(length, n)     num_lists = q + (1 if r > 0 else 0)     q, r = divmod(length, num_lists)     full_size = q + (1 if r > 0 else 0)     partial_size = full_size - 1     num_full = length - partial_size * num_lists      # Yield chunks of full size     partial_start_idx = num_full * full_size     if full_size > 0:         for i in range(0, partial_start_idx, full_size):             yield buffer[i : i + full_size]      # Yield chunks of partial size     if partial_size > 0:         for i in range(partial_start_idx, length, partial_size):             yield buffer[i : i + partial_size]\n2: def reverse_words(input_str: str) -> str:     return \" \".join(input_str.split()[::-1])", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef binary_exp_recursive(base: float, exponent: int) -> float:\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n\n    if exponent == 0:\n        return 1\n\n    if exponent % 2 == 1:\n        return binary_exp_recursive(base, exponent - 1) * base\n\n    b = binary_exp_recursive(base, exponent // 2)\n    return b * b", "output": "Computes a^b recursively, where a is the base and b is the exponent"}
{"task": "summary", "input": "summarize code:\ndef snake_to_camel_case(input_str: str, use_pascal: bool = False) -> str:\n\n    if not isinstance(input_str, str):\n        msg = f\"Expected string as input, found {type(input_str)}\"\n        raise ValueError(msg)\n    if not isinstance(use_pascal, bool):\n        msg = f\"Expected boolean as use_pascal parameter, found {type(use_pascal)}\"\n        raise ValueError(msg)\n\n    words = input_str.split(\"_\")\n\n    start_index = 0 if use_pascal else 1\n\n    words_to_capitalize = words[start_index:]\n\n    capitalized_words = [word[0].upper() + word[1:] for word in words_to_capitalize]\n\n    initial_word = \"\" if use_pascal else words[0]\n\n    return \"\".join([initial_word, *capitalized_words])", "output": "Transforms a snake_case given string to camelCase (or PascalCase if indicated)"}
{"task": "summary", "input": "summarize code:\ndef djb2(s: str) -> int:\n    hash_value = 5381\n    for x in s:\n        hash_value = ((hash_value << 5) + hash_value) + ord(x)\n    return hash_value & 0xFFFFFFFF", "output": "Implementation of djb2 hash algorithm that"}
{"task": "summary", "input": "summarize code:\ndef median_filter(gray_img, mask=3):\n    # set image borders\n    bd = int(mask / 2)\n    # copy image size\n    median_img = zeros_like(gray_img)\n    for i in range(bd, gray_img.shape[0] - bd):\n        for j in range(bd, gray_img.shape[1] - bd):\n            # get mask according with mask\n            kernel = ravel(gray_img[i - bd : i + bd + 1, j - bd : j + bd + 1])\n            # calculate mask median\n            median = sort(kernel)[int8(divide((multiply(mask, mask)), 2) + 1)]\n            median_img[i, j] = median\n    return median_img", "output": ":param gray_img: gray image"}
{"task": "summary", "input": "summarize code:\ndef activate(locale, path=None):\n    if path is None:\n        path = _get_default_locale_path()\n\n    if path is None:\n        raise Exception(\n            \"Humanize cannot determinate the default location of the 'locale' folder. \"\n            \"You need to pass the path explicitly.\"\n        )\n    if locale not in _TRANSLATIONS:\n        translation = gettext_module.translation(\"humanize\", path, [locale])\n        _TRANSLATIONS[locale] = translation\n    _CURRENT.locale = locale\n    return _TRANSLATIONS[locale]", "output": "Activate internationalisation."}
{"task": "summary", "input": "summarize code:\ndef distance(city1: list[int], city2: list[int]) -> float:\n    return (((city1[0] - city2[0]) ** 2) + ((city1[1] - city2[1]) ** 2)) ** 0.5", "output": "Calculate the distance between two coordinate points"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 7) -> int:\n    pandigital_str = \"\".join(str(i) for i in range(1, n + 1))\n    perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]\n    pandigitals = [num for num in perm_list if is_prime(num)]\n    return max(pandigitals) if pandigitals else 0", "output": "Returns the maximum pandigital prime number of length n."}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 10000) -> int:\n    total = sum(\n        i\n        for i in range(1, n)\n        if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i\n    )\n    return total", "output": "Returns the sum of all the amicable numbers under n."}
{"task": "search", "input": "search code:\nReturns frequency distribution of total\n\nChoices:\n0: def solution(max_d: int = 12_000) -> int:      fractions_number = 0     for d in range(max_d + 1):         n_start = d // 3 + 1         n_step = 1         if d % 2 == 0:             n_start += 1 - n_start % 2             n_step = 2         for n in range(n_start, (d + 1) // 2, n_step):             if gcd(n, d) == 1:                 fractions_number += 1     return fractions_number\n1: def sum_digits(num: int) -> int:     digit_sum = 0     while num > 0:         digit_sum += num % 10         num //= 10     return digit_sum\n2: def total_frequency_distribution(sides_number: int, dice_number: int) -> list[int]:      max_face_number = sides_number     max_total = max_face_number * dice_number     totals_frequencies = [0] * (max_total + 1)      min_face_number = 1     faces_numbers = range(min_face_number, max_face_number + 1)     for dice_numbers in product(faces_numbers, repeat=dice_number):         total = sum(dice_numbers)         totals_frequencies[total] += 1      return totals_frequencies", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef primes(max_n: int) -> Generator[int]:\n    numbers: Generator = (i for i in range(1, (max_n + 1)))\n    for i in (n for n in numbers if n > 1):\n        # only need to check for factors up to sqrt(i)\n        bound = int(math.sqrt(i)) + 1\n        for j in range(2, bound):\n            if (i % j) == 0:\n                break\n        else:\n            yield i", "output": "Return a list of all primes numbers up to max."}
{"task": "summary", "input": "summarize code:\ndef nth_combination_with_replacement(iterable, r, index):\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = comb(n + r - 1, r)\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    i = 0\n    while r:\n        r -= 1\n        while n >= 0:\n            num_combs = comb(n + r - 1, r)\n            if index < num_combs:\n                break\n            n -= 1\n            i += 1\n            index -= num_combs\n        result.append(pool[i])\n\n    return tuple(result)", "output": "Equivalent to"}
{"task": "summary", "input": "summarize code:\ndef calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "This function calculates the turnaround time of some processes."}
{"task": "search", "input": "search code:\nFind the sum of digits of a number\n\nChoices:\n0: def method_2(boundary: list[int], steps: int) -> float:     # \"Simpson Rule\"     # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)     if steps <= 0:         raise ZeroDivisionError(\"Number of steps must be greater than zero\")      h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 3.0) * f(a)     cnt = 2     for i in x_i:         y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)         cnt += 1     y += (h / 3.0) * f(b)     return y\n1: def sum_of_digits_compact(n: int) -> int:     return sum(int(c) for c in str(abs(n)))\n2: def map_except(function, iterable, *exceptions):     for item in iterable:         try:             yield function(item)         except exceptions:             pass", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "def calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]"}
{"task": "repair", "input": "fix bug:\ndef molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\n    \"\"\"\n    Convert molarity to normality.\n      Volume is taken in litres.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n      >>> molarity_to_normality(2, 3.1, 0.31)\n      20\n      >>> molarity_to_normality(4, 11.4, 5.7)\n      8\n    \"\"\"\n    return round(float(moles / volume) * nfactor)", "output": "def molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\n    \"\"\"\n    Convert molarity to normality.\n      Volume is taken in litres.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n      >>> molarity_to_normality(2, 3.1, 0.31)\n      20\n      >>> molarity_to_normality(4, 11.4, 5.7)\n      8\n    \"\"\"\n    return round(float(moles / volume) * nfactor)"}
{"task": "search", "input": "search code:\nDemonstrates the use of KD-Tree by building it from random points\n\nChoices:\n0: def main() -> None:     num_points: int = 5000     cube_size: float = 10.0  # Size of the hypercube (edge length)     num_dimensions: int = 10      # Generate random points within the hypercube     points: np.ndarray = hypercube_points(num_points, cube_size, num_dimensions)     hypercube_kdtree = build_kdtree(points.tolist())      # Generate a random query point within the same space     rng = np.random.default_rng()     query_point: list[float] = rng.random(num_dimensions).tolist()      # Perform nearest neighbor search     nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(         hypercube_kdtree, query_point     )      # Print the results     print(f\"Query point: {query_point}\")     print(f\"Nearest point: {nearest_point}\")     print(f\"Distance: {nearest_dist:.4f}\")     print(f\"Nodes visited: {nodes_visited}\")\n1: def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:     arr.sort()     n = len(arr)     for i in range(n - 1):         left, right = i + 1, n - 1         while left < right:             if arr[i] + arr[left] + arr[right] == target:                 return (arr[i], arr[left], arr[right])             elif arr[i] + arr[left] + arr[right] < target:                 left += 1             elif arr[i] + arr[left] + arr[right] > target:                 right -= 1     return (0, 0, 0)\n2: def iter_merge_sort(input_list: list) -> list:     if len(input_list) <= 1:         return input_list     input_list = list(input_list)      # iteration for two-way merging     p = 2     while p <= len(input_list):         # getting low, high and middle value for merge-sort of single list         for i in range(0, len(input_list), p):             low = i             high = i + p - 1             mid = (low + high + 1) // 2             input_list = merge(input_list, low, mid, high)         # final merge of last two parts         if p * 2 >= len(input_list):             mid = i             input_list = merge(input_list, 0, mid, len(input_list) - 1)             break         p *= 2      return input_list", "output": "0"}
{"task": "search", "input": "search code:\nExamples(rounded for precision):\n\nChoices:\n0: def rmsle(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      log_predict = np.log(predict + 1)     log_actual = np.log(actual + 1)      difference = log_predict - log_actual     square_diff = np.square(difference)     mean_square_diff = square_diff.mean()      score = np.sqrt(mean_square_diff)      return score\n1: def rmse(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     square_diff = np.square(difference)     mean_square_diff = square_diff.mean()     score = np.sqrt(mean_square_diff)     return score\n2: def sum_of_digits_compact(n: int) -> int:     return sum(int(c) for c in str(abs(n)))", "output": "0"}
{"task": "search", "input": "search code:\nFind the sum of digits of a number using recursion\n\nChoices:\n0: def sum_of_digits_recursion(n: int) -> int:     n = abs(n)     return n if n < 10 else n % 10 + sum_of_digits(n // 10)\n1: def transform(velocity: float, event: np.ndarray | None = None) -> np.ndarray:     # Ensure event is not empty     if event is None:         event = np.array([ct, x, y, z])  # Symbolic four vector     else:         event[0] *= c  # x0 is ct (speed of light * time)      return transformation_matrix(velocity) @ event\n2: def breadth_first_search(     level: list[int],     parent: list[list[int]],     max_node: int,     graph: dict[int, list[int]],     root: int = 1, ) -> tuple[list[int], list[list[int]]]:     level[root] = 0     q: Queue[int] = Queue(maxsize=max_node)     q.put(root)     while q.qsize() != 0:         u = q.get()         for v in graph[u]:             if level[v] == -1:                 level[v] = level[u] + 1                 q.put(v)                 parent[0][v] = u     return level, parent", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef oct_to_decimal(oct_string: str) -> int:\n    oct_string = str(oct_string).strip()\n    if not oct_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = oct_string[0] == \"-\"\n    if is_negative:\n        oct_string = oct_string[1:]\n    if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):\n        raise ValueError(\"Non-octal value was passed to the function\")\n    decimal_number = 0\n    for char in oct_string:\n        decimal_number = 8 * decimal_number + int(char)\n    if is_negative:\n        decimal_number = -decimal_number\n    return decimal_number", "output": "Convert a octal value to its decimal equivalent"}
{"task": "search", "input": "search code:\nReturns an integer, the solution to the problem\n\nChoices:\n0: def solution(limit: int = 1_000_000) -> int:      # generating an array from -1 to limit     phi = np.arange(-1, limit)      for i in range(2, limit + 1):         if phi[i] == i - 1:             ind = np.arange(2 * i, limit + 1, i)  # indexes for selection             phi[ind] -= phi[ind] // i      return int(np.sum(phi[2 : limit + 1]))\n1: def odd_even_sort(input_list: list) -> list:     is_sorted = False     while is_sorted is False:  # Until all the indices are traversed keep looping         is_sorted = True         for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices             if input_list[i] > input_list[i + 1]:                 input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]                 # swapping if elements not in order                 is_sorted = False          for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices             if input_list[i] > input_list[i + 1]:                 input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]                 # swapping if elements not in order                 is_sorted = False     return input_list\n2: def decimal_relative_time(d, other=None, ndigits=0, cardinalize=True):     if other is None:         other = datetime.now(timezone.utc).replace(tzinfo=None)     diff = other - d     diff_seconds = timedelta.total_seconds(diff)     abs_diff = abs(diff)     b_idx = bisect.bisect(_BOUND_DELTAS, abs_diff) - 1     bbound, bunit, bname = _BOUNDS[b_idx]     f_diff = diff_seconds / timedelta.total_seconds(bunit)     rounded_diff = round(f_diff, ndigits)     if cardinalize:         return rounded_diff, _cardinalize_time_unit(bname, abs(rounded_diff))     return rounded_diff, bname", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef interpolate(y_list: list[int]) -> Callable[[int], int]:\n\n    size: int = len(y_list)\n    matrix: Matrix = [[0 for _ in range(size)] for _ in range(size)]\n    vector: Matrix = [[0] for _ in range(size)]\n    coeffs: Matrix\n    x_val: int\n    y_val: int\n    col: int\n\n    for x_val, y_val in enumerate(y_list):\n        for col in range(size):\n            matrix[x_val][col] = (x_val + 1) ** (size - col - 1)\n        vector[x_val][0] = y_val\n\n    coeffs = solve(matrix, vector)\n\n    def interpolated_func(var: int) -> int:\n        return sum(\n            round(coeffs[x_val][0]) * (var ** (size - x_val - 1))\n            for x_val in range(size)\n        )\n\n    return interpolated_func", "output": "Given a list of data points (1,y0),(2,y1), ..., return a function that"}
{"task": "search", "input": "search code:\n- bits of information merged with parity bits\n\nChoices:\n0: def binary_tree_right_side_view(root: TreeNode) -> list[int]:      def depth_first_search(         root: TreeNode | None, depth: int, right_view: list[int]     ) -> None:         if not root:             return          if depth == len(right_view):             right_view.append(root.val)          depth_first_search(root.right, depth + 1, right_view)         depth_first_search(root.left, depth + 1, right_view)      right_view: list = []     if not root:         return right_view      depth_first_search(root, 0, right_view)     return right_view\n1: def emitter_converter(size_par, data):     if size_par + len(data) <= 2**size_par - (len(data) - 1):         raise ValueError(\"size of parity don't match with size of data\")      data_out = []     parity = []     bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]      # sorted information data for the size of the output data     data_ord = []     # data position template + parity     data_out_gab = []     # parity bit counter     qtd_bp = 0     # counter position of data bits     cont_data = 0      for x in range(1, size_par + len(data) + 1):         # Performs a template of bit positions - who should be given,         # and who should be parity         if qtd_bp < size_par:             if (np.log(x) / np.log(2)).is_integer():                 data_out_gab.append(\"P\")                 qtd_bp = qtd_bp + 1             else:                 data_out_gab.append(\"D\")         else:             data_out_gab.append(\"D\")          # Sorts the data to the new output size         if data_out_gab[-1] == \"D\":             data_ord.append(data[cont_data])             cont_data += 1         else:             data_ord.append(None)      # Calculates parity     qtd_bp = 0  # parity bit counter     for bp in range(1, size_par + 1):         # Bit counter one for a given parity         cont_bo = 0         # counter to control the loop reading         for cont_loop, x in enumerate(data_ord):             if x is not None:                 try:                     aux = (bin_pos[cont_loop])[-1 * (bp)]                 except IndexError:                     aux = \"0\"                 if aux == \"1\" and x == \"1\":                     cont_bo += 1         parity.append(cont_bo % 2)          qtd_bp += 1      # Mount the message     cont_bp = 0  # parity bit counter     for x in range(size_par + len(data)):         if data_ord[x] is None:             data_out.append(str(parity[cont_bp]))             cont_bp += 1         else:             data_out.append(data_ord[x])      return data_out\n2: def luhn_validation(credit_card_number: str) -> bool:     cc_number = credit_card_number     total = 0     half_len = len(cc_number) - 2     for i in range(half_len, -1, -2):         #  double the value of every second digit         digit = int(cc_number[i])         digit *= 2         # If doubling of a number results in a two digit number         # i.e greater than 9(e.g., 6 x 2 = 12),         # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),         # to get a single digit number.         if digit > 9:             digit %= 10             digit += 1         cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]         total += digit      # Sum up the remaining digits     for i in range(len(cc_number) - 1, -1, -2):         total += int(cc_number[i])      return total % 10 == 0", "output": "1"}
{"task": "search", "input": "search code:\nFunction returns the bottom side view of binary tree\n\nChoices:\n0: def binary_tree_bottom_side_view(root: TreeNode) -> list[int]:     from collections import defaultdict      def breadth_first_search(root: TreeNode, bottom_view: list[int]) -> None:         queue = [(root, 0)]         lookup = defaultdict(list)          while queue:             first = queue.pop(0)             node, hd = first             lookup[hd].append(node.val)              if node.left:                 queue.append((node.left, hd - 1))             if node.right:                 queue.append((node.right, hd + 1))          for pair in sorted(lookup.items(), key=lambda each: each[0]):             bottom_view.append(pair[1][-1])      bottom_view: list = []     if not root:         return bottom_view      breadth_first_search(root, bottom_view)     return bottom_view\n1: def arithmetic_right_shift(number: int, shift_amount: int) -> str:     if number >= 0:  # Get binary representation of positive number         binary_number = \"0\" + str(bin(number)).strip(\"-\")[2:]     else:  # Get binary (2's complement) representation of negative number         binary_number_length = len(bin(number)[3:])  # Find 2's complement of number         binary_number = bin(abs(number) - (1 << binary_number_length))[3:]         binary_number = (             \"1\" + \"0\" * (binary_number_length - len(binary_number)) + binary_number         )      if shift_amount >= len(binary_number):         return \"0b\" + binary_number[0] * len(binary_number)     return (         \"0b\"         + binary_number[0] * shift_amount         + binary_number[: len(binary_number) - shift_amount]     )\n2: def download_image(url: str) -> str:     try:         response = httpx.get(url, timeout=10)         response.raise_for_status()     except httpx.RequestError as e:         return f\"An error occurred during the HTTP request to {url}: {e!r}\"      soup = BeautifulSoup(response.text, \"html.parser\")     image_meta_tag = soup.find(\"meta\", {\"property\": \"og:image\"})     if not image_meta_tag:         return \"No meta tag with property 'og:image' was found.\"      image_url = image_meta_tag.get(\"content\")     if not image_url:         return f\"Image URL not found in meta tag {image_meta_tag}.\"      try:         image_data = httpx.get(image_url, timeout=10).content     except httpx.RequestError as e:         return f\"An error occurred during the HTTP request to {image_url}: {e!r}\"     if not image_data:         return f\"Failed to download the image from {image_url}.\"      file_name = f\"{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H-%M-%S}.jpg\"     with open(file_name, \"wb\") as out_file:         out_file.write(image_data)     return f\"Image downloaded and saved in the file {file_name}\"", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef merge_sort(array: list) -> list:\n    if len(array) <= 1:\n        return array\n    # the actual formula to calculate the middle element = left + (right - left) // 2\n    # this avoids integer overflow in case of large N\n    middle = 0 + (len(array) - 0) // 2\n\n    # Split the array into halves till the array length becomes equal to One\n    # merge the arrays of single length returned by mergeSort function and\n    # pass them into the merge arrays function which merges the array\n    left_half = array[:middle]\n    right_half = array[middle:]\n\n    return merge(merge_sort(left_half), merge_sort(right_half))", "output": "Returns a list of sorted array elements using merge sort."}
{"task": "summary", "input": "summarize code:\ndef is_safe_prime(number: int) -> bool:\n    if not isinstance(number, int) or number < 1:\n        msg = f\"Input value must be a positive integer. Input value: {number}\"\n        raise TypeError(msg)\n\n    return (number - 1) % 2 == 0 and is_prime(number) and is_prime((number - 1) // 2)", "output": "Checks if input number and (number - 1)/2 are prime."}
{"task": "summary", "input": "summarize code:\ndef bogo_sort(collection):\n\n    def is_sorted(collection):\n        for i in range(len(collection) - 1):\n            if collection[i] > collection[i + 1]:\n                return False\n        return True\n\n    while not is_sorted(collection):\n        random.shuffle(collection)\n    return collection", "output": "Pure implementation of the bogosort algorithm in Python"}
{"task": "search", "input": "search code:\nValidates that the number of elements in the matrix matches the given size.\n\nChoices:\n0: def binary_and(a: int, b: int) -> str:     if a < 0 or b < 0:         raise ValueError(\"the value of both inputs must be positive\")      a_binary = format(a, \"b\")     b_binary = format(b, \"b\")      max_len = max(len(a_binary), len(b_binary))      return \"0b\" + \"\".join(         str(int(char_a == \"1\" and char_b == \"1\"))         for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))     )\n1: def validate_matrix_content(matrix: list[str], size: int) -> None:     print(matrix)     if len(matrix) != size:         raise ValueError(\"The matrix dont match with size.\")     for row in matrix:         if len(row) != size:             msg = f\"Each row in the matrix must have exactly {size} characters.\"             raise ValueError(msg)         if not all(char.isalnum() for char in row):             raise ValueError(\"Matrix rows can only contain letters and numbers.\")\n2: def preprocess(edge_array):     for i in range(len(edge_array)):         for j in range(len(edge_array[i])):             t = edge_array[i][j].split(\"-\")             edge_array[i][j] = t", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: float = 1e10) -> int:\n    primes = sieve()\n\n    n = 1\n    while True:\n        prime = next(primes)\n        if (2 * prime * n) > limit:\n            return n\n        # Ignore the next prime as the reminder will be 2.\n        next(primes)\n        n += 2", "output": "Returns the least value of n for which the remainder first exceeds 10^10."}
{"task": "search", "input": "search code:\nReturn circular primes below limit.\n\nChoices:\n0: def find_circular_primes(limit: int = 1000000) -> list[int]:     result = [2]  # result already includes the number 2.     for num in range(3, limit + 1, 2):         if is_prime(num) and not contains_an_even_digit(num):             str_num = str(num)             list_nums = [int(str_num[j:] + str_num[:j]) for j in range(len(str_num))]             if all(is_prime(i) for i in list_nums):                 result.append(num)     return result\n1: def zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):      def is_scalar(obj):         if scalar_types and isinstance(obj, scalar_types):             return True         try:             iter(obj)         except TypeError:             return True         else:             return False      size = len(objects)     if not size:         return      new_item = [None] * size     iterables, iterable_positions = [], []     for i, obj in enumerate(objects):         if is_scalar(obj):             new_item[i] = obj         else:             iterables.append(iter(obj))             iterable_positions.append(i)      if not iterables:         yield tuple(objects)         return      for item in zip(*iterables, strict=strict):         for i, new_item[i] in zip(iterable_positions, item):             pass         yield tuple(new_item)\n2: def solution(limit: int = 50) -> int:     return sum(         1         for pt1, pt2 in combinations(product(range(limit + 1), repeat=2), 2)         if is_right(*pt1, *pt2)     )", "output": "0"}
{"task": "search", "input": "search code:\nImplements the relu function\n\nChoices:\n0: def validate_initial_digits(credit_card_number: str) -> bool:     return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))\n1: def generate_neighbours(path):      dict_of_neighbours = {}      with open(path) as f:         for line in f:             if line.split()[0] not in dict_of_neighbours:                 _list = []                 _list.append([line.split()[1], line.split()[2]])                 dict_of_neighbours[line.split()[0]] = _list             else:                 dict_of_neighbours[line.split()[0]].append(                     [line.split()[1], line.split()[2]]                 )             if line.split()[1] not in dict_of_neighbours:                 _list = []                 _list.append([line.split()[0], line.split()[2]])                 dict_of_neighbours[line.split()[1]] = _list             else:                 dict_of_neighbours[line.split()[1]].append(                     [line.split()[0], line.split()[2]]                 )      return dict_of_neighbours\n2: def relu(vector: list[float]):      # compare two arrays and then return element-wise maxima.     return np.maximum(0, vector)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef get_squarefrees(unique_coefficients: set[int]) -> set[int]:\n    \"\"\"\n    Calculates the squarefree numbers inside unique_coefficients.\n\n    Based on the definition of a non-squarefree number, then any non-squarefree\n    n can be decomposed as n = p*p*r, where p is positive prime number and r\n    is a positive integer.\n\n    Under the previous formula, any coefficient that is lower than p*p is\n    squarefree as r cannot be negative. On the contrary, if any r exists such\n    that n = p*p*r, then the number is non-squarefree.\n\n    >>> get_squarefrees({1})\n    {1}\n    >>> get_squarefrees({1, 2})\n    {1, 2}\n    >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})\n    {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}\n    \"\"\"\n\n    non_squarefrees = set()\n    for number in unique_coefficients:\n        divisor = 2\n        copy_number = number\n        while divisor**2 <= copy_number:\n            multiplicity = 0\n            while copy_number % divisor == 0:\n                copy_number //= divisor\n                multiplicity += 1\n            if multiplicity >= 2:\n                non_squarefrees.add(number)\n                break\n            divisor += 1\n\n    return unique_coefficients.difference(non_squarefrees)", "output": "def get_squarefrees(unique_coefficients: set[int]) -> set[int]:\n    \"\"\"\n    Calculates the squarefree numbers inside unique_coefficients.\n\n    Based on the definition of a non-squarefree number, then any non-squarefree\n    n can be decomposed as n = p*p*r, where p is positive prime number and r\n    is a positive integer.\n\n    Under the previous formula, any coefficient that is lower than p*p is\n    squarefree as r cannot be negative. On the contrary, if any r exists such\n    that n = p*p*r, then the number is non-squarefree.\n\n    >>> get_squarefrees({1})\n    {1}\n    >>> get_squarefrees({1, 2})\n    {1, 2}\n    >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})\n    {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}\n    \"\"\"\n\n    non_squarefrees = set()\n    for number in unique_coefficients:\n        divisor = 2\n        copy_number = number\n        while divisor**2 <= copy_number:\n            multiplicity = 0\n            while copy_number % divisor == 0:\n                copy_number //= divisor\n                multiplicity += 1\n            if multiplicity >= 2:\n                non_squarefrees.add(number)\n                break\n            divisor += 1\n\n    return unique_coefficients.difference(non_squarefrees)"}
{"task": "search", "input": "search code:\nStrips values from the beginning of an iterable. Stripped items will\n\nChoices:\n0: def lstrip(iterable, strip_value=None):     return list(lstrip_iter(iterable, strip_value))\n1: def solution(a: int = 100, b: int = 100) -> int:      # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of     # BASE raised to the POWER     return max(         sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)     )\n2: def throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:     dices = [Dice() for i in range(num_dice)]     count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)     for _ in range(num_throws):         count_of_sum[sum(dice.roll() for dice in dices)] += 1     probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]     return probability[num_dice:]  # remove probability of sums that never appear", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef always_reversible(iterable):\n    try:\n        return reversed(iterable)\n    except TypeError:\n        return reversed(list(iterable))", "output": "An extension of :func:`reversed` that supports all iterables, not"}
{"task": "search", "input": "search code:\nA convenience function to get standard summary statistics useful\n\nChoices:\n0: def describe(data, quantiles=None, format=None):     return Stats(data).describe(quantiles=quantiles, format=format)\n1: def erase(root: Node | None, value: int) -> Node | None:     left, right = split(root, value - 1)     _, right = split(right, value)     return merge(left, right)\n2: def second_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef mps_speed_of_molecule(temperature: float, molar_mass: float) -> float:\n\n    if temperature < 0:\n        raise Exception(\"Absolute temperature cannot be less than 0 K\")\n    if molar_mass <= 0:\n        raise Exception(\"Molar mass should be greater than 0 kg/mol\")\n    return (2 * R * temperature / molar_mass) ** 0.5", "output": "Takes the temperature (in K) and molar mass (in kg/mol) of a gas"}
{"task": "summary", "input": "summarize code:\ndef chain_length(n: int, previous: set | None = None) -> int:\n    previous = previous or set()\n    if n in CHAIN_LENGTH_CACHE:\n        return CHAIN_LENGTH_CACHE[n]\n    next_number = sum_digit_factorials(n)\n    if next_number in previous:\n        CHAIN_LENGTH_CACHE[n] = 0\n        return 0\n    else:\n        previous.add(n)\n        ret = 1 + chain_length(next_number, previous)\n        CHAIN_LENGTH_CACHE[n] = ret\n        return ret", "output": "Calculate the length of the chain of non-repeating terms starting with n."}
{"task": "search", "input": "search code:\nReturns the sum of every digit in num.\n\nChoices:\n0: def sum_digits(num: int) -> int:     digit_sum = 0     while num > 0:         digit_sum += num % 10         num //= 10     return digit_sum\n1: def sigmoid(value: np.ndarray) -> np.ndarray:     return 1 / (1 + np.exp(-value))\n2: def solution(n: int = 7) -> int:     pandigital_str = \"\".join(str(i) for i in range(1, n + 1))     perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]     pandigitals = [num for num in perm_list if is_prime(num)]     return max(pandigitals) if pandigitals else 0", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef _msd_radix_sort_inplace(\n    list_of_ints: list[int], bit_position: int, begin_index: int, end_index: int\n):\n    if bit_position == 0 or end_index - begin_index <= 1:\n        return\n\n    bit_position -= 1\n\n    i = begin_index\n    j = end_index - 1\n    while i <= j:\n        changed = False\n        if not (list_of_ints[i] >> bit_position) & 1:\n            # found zero at the beginning\n            i += 1\n            changed = True\n        if (list_of_ints[j] >> bit_position) & 1:\n            # found one at the end\n            j -= 1\n            changed = True\n\n        if changed:\n            continue\n\n        list_of_ints[i], list_of_ints[j] = list_of_ints[j], list_of_ints[i]\n        j -= 1\n        if j != i:\n            i += 1\n\n    _msd_radix_sort_inplace(list_of_ints, bit_position, begin_index, i)\n    _msd_radix_sort_inplace(list_of_ints, bit_position, i, end_index)", "output": "Sort the given list based on the bit at bit_position. Numbers with a"}
{"task": "detection", "input": "classify code:\ndef encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]", "output": "BUGGY"}
{"task": "search", "input": "search code:\nPrints the elements of the given Linked List in reverse order\n\nChoices:\n0: def can_string_be_rearranged_as_palindrome(input_str: str = \"\") -> bool:     if len(input_str) == 0:         return True     lower_case_input_str = input_str.replace(\" \", \"\").lower()     # character_freq_dict: Stores the frequency of every character in the input string     character_freq_dict: dict[str, int] = {}      for character in lower_case_input_str:         character_freq_dict[character] = character_freq_dict.get(character, 0) + 1     odd_char = 0      for character_count in character_freq_dict.values():         if character_count % 2:             odd_char += 1     return not odd_char > 1\n1: def example() -> int:     # Input values.     test_input = np.array(         (             [0, 0, 0],             [0, 0, 1],             [0, 1, 0],             [0, 1, 1],             [1, 0, 0],             [1, 0, 1],             [1, 1, 0],             [1, 1, 1],         ),         dtype=np.float64,     )      # True output values for the given input values.     output = np.array(([0], [1], [1], [0], [1], [0], [0], [1]), dtype=np.float64)      # Calling neural network class.     neural_network = TwoHiddenLayerNeuralNetwork(         input_array=test_input, output_array=output     )      # Calling training function.     # Set give_loss to True if you want to see loss in every iteration.     neural_network.train(output=output, iterations=10, give_loss=False)      return neural_network.predict(np.array(([1, 1, 1]), dtype=np.float64))\n2: def in_reverse(linked_list: LinkedList) -> str:     return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))", "output": "2"}
{"task": "search", "input": "search code:\nHelper function to solve knight tour problem.\n\nChoices:\n0: def remove_digit(num: int) -> int:      if not isinstance(num, int):         raise TypeError(\"only integers accepted as input\")     else:         num_str = str(abs(num))         num_transpositions = [list(num_str) for char in range(len(num_str))]         for index in range(len(num_str)):             num_transpositions[index].pop(index)         return max(             int(\"\".join(list(transposition))) for transposition in num_transpositions         )\n1: def synchronized(func):      @wraps(func)     def inner(*args, **kwargs):         iterator = func(*args, **kwargs)         return serialize(iterator)      return inner\n2: def open_knight_tour_helper(     board: list[list[int]], pos: tuple[int, int], curr: int ) -> bool:      if is_complete(board):         return True      for position in get_valid_pos(pos, len(board)):         y, x = position          if board[y][x] == 0:             board[y][x] = curr + 1             if open_knight_tour_helper(board, position, curr + 1):                 return True             board[y][x] = 0      return False", "output": "2"}
{"task": "detection", "input": "classify code:\ndef solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution(100)\n    25164150\n    \"\"\"\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection", "output": "BUGGY"}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def lstrip(iterable, strip_value=None):     return list(lstrip_iter(iterable, strip_value))\n1: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True\n2: def mae(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = abs(predict - actual)     score = difference.mean()      return score", "output": "1"}
{"task": "search", "input": "search code:\nCalculate the Lorentz transformation matrix for movement in the x direction:\n\nChoices:\n0: def tail(n, iterable):     try:         size = len(iterable)     except TypeError:         return iter(deque(iterable, maxlen=n))     else:         return islice(iterable, max(0, size - n), None)\n1: def solution(a: int = 100, b: int = 100) -> int:      # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of     # BASE raised to the POWER     return max(         sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)     )\n2: def transformation_matrix(velocity: float) -> np.ndarray:     return np.array(         [             [gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],             [-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],             [0, 0, 1, 0],             [0, 0, 0, 1],         ]     )", "output": "2"}
{"task": "search", "input": "search code:\nTurn a format string into two lists of arguments referenced by the\n\nChoices:\n0: def unquote(string, encoding='utf-8', errors='replace'):     if '%' not in string:         string.split         return string     if encoding is None:         encoding = 'utf-8'     if errors is None:         errors = 'replace'     bits = _ASCII_RE.split(string)     res = [bits[0]]     append = res.append     for i in range(1, len(bits), 2):         append(unquote_to_bytes(bits[i]).decode(encoding, errors))         append(bits[i + 1])     return ''.join(res)\n1: def get_format_args(fstr):     # TODO: memoize     formatter = Formatter()     fargs, fkwargs, _dedup = [], [], set()      def _add_arg(argname, type_char='s'):         if argname not in _dedup:             _dedup.add(argname)             argtype = _TYPE_MAP.get(type_char, str)  # TODO: unicode             try:                 fargs.append((int(argname), argtype))             except ValueError:                 fkwargs.append((argname, argtype))      for lit, fname, fspec, conv in formatter.parse(fstr):         if fname is not None:             type_char = fspec[-1:]             fname_list = re.split('[.[]', fname)             if len(fname_list) > 1:                 raise ValueError('encountered compound format arg: %r' % fname)             try:                 base_fname = fname_list[0]                 assert base_fname             except (IndexError, AssertionError):                 raise ValueError('encountered anonymous positional argument')             _add_arg(fname, type_char)             for sublit, subfname, _, _ in formatter.parse(fspec):                 # TODO: positional and anon args not allowed here.                 if subfname is not None:                     _add_arg(subfname)     return fargs, fkwargs\n2: def arithmetic_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 0     for val in series:         answer += val     return answer / len(series)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef pigeon_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "BUGGY"}
{"task": "search", "input": "search code:\nfind edges of multiple frequent subgraphs\n\nChoices:\n0: def find_repeat(     matrix_g: list[list[str]], row: int, column: int, size: int ) -> set[tuple[int, int]]:      column = size - 1 - column     visited = set()     repeated = set()      if (color := matrix_g[column][row]) != \"-\":          def dfs(row_n: int, column_n: int) -> None:             if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:                 return             if (row_n, column_n) in visited:                 return             visited.add((row_n, column_n))             if matrix_g[row_n][column_n] == color:                 repeated.add((row_n, column_n))                 dfs(row_n - 1, column_n)                 dfs(row_n + 1, column_n)                 dfs(row_n, column_n - 1)                 dfs(row_n, column_n + 1)          dfs(column, row)      return repeated\n1: def find_freq_subgraph_given_support(s, cluster, graph):     k = int(s / 100 * (len(cluster) - 1))     for i in cluster[k]:         my_dfs(graph, tuple(cluster[k][i]), ([\"Header\"],))\n2: def is_prime(number: int) -> bool:      # precondition     assert isinstance(number, int) and (number >= 0), (         \"'number' must been an int and positive\"     )      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or not number % 2:         # Negatives, 0, 1 and all even numbers are not primes         return False      odd_numbers = range(3, int(math.sqrt(number) + 1), 2)     return not any(not number % i for i in odd_numbers)", "output": "1"}
{"task": "search", "input": "search code:\nCheck if the solution set is a magic n-gon ring\n\nChoices:\n0: def is_magic_gon(numbers: list[int]) -> bool:     if len(numbers) % 3 != 0:         raise ValueError(\"a gon ring should have a length that is a multiple of 3\")      if min(numbers[::3]) != numbers[0]:         return False      total = sum(numbers[:3])      return all(sum(numbers[i : i + 3]) == total for i in range(3, len(numbers), 3))\n1: def validate_adjacency_list(graph: list[list[int | None]]) -> None:     if not isinstance(graph, list):         raise ValueError(\"Graph should be a list of lists.\")      for node_index, neighbors in enumerate(graph):         if not isinstance(neighbors, list):             no_neighbors_message: str = (                 f\"Node {node_index} should have a list of neighbors.\"             )             raise ValueError(no_neighbors_message)         for neighbor_index in neighbors:             if (                 not isinstance(neighbor_index, int)                 or neighbor_index < 0                 or neighbor_index >= len(graph)             ):                 invalid_neighbor_message: str = (                     f\"Invalid neighbor {neighbor_index} in node {node_index} \"                     f\"adjacency list.\"                 )                 raise ValueError(invalid_neighbor_message)\n2: def linear_search(sequence: list, target: int) -> int:     for index, item in enumerate(sequence):         if item == target:             return index     return -1", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef random_derangement(iterable):\n    seq = tuple(iterable)\n    if len(seq) < 2:\n        if len(seq) == 0:\n            return ()\n        raise IndexError('No derangments to choose from')\n    perm = list(range(len(seq)))\n    start = tuple(perm)\n    while True:\n        shuffle(perm)\n        if not any(map(is_, start, perm)):\n            return itemgetter(*perm)(seq)", "output": "Return a random derangement of elements in the iterable."}
{"task": "search", "input": "search code:\nSort input with odd even sort.\n\nChoices:\n0: def odd_even_sort(input_list: list) -> list:     is_sorted = False     while is_sorted is False:  # Until all the indices are traversed keep looping         is_sorted = True         for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices             if input_list[i] > input_list[i + 1]:                 input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]                 # swapping if elements not in order                 is_sorted = False          for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices             if input_list[i] > input_list[i + 1]:                 input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]                 # swapping if elements not in order                 is_sorted = False     return input_list\n1: def dft(xarr):     N = len(xarr)     roots_of_unity = [e ** (n / N * tau * -1j) for n in range(N)]     for k in range(N):         coeffs = [roots_of_unity[k * n % N] for n in range(N)]         yield _complex_sumprod(xarr, coeffs)\n2: def reversible_numbers(     remaining_length: int, remainder: int, digits: list[int], length: int ) -> int:     # There exist no reversible 1, 5, 9, 13 (ie. 4k+1) digit numbers     if (length - 1) % 4 == 0:         return 0      return slow_reversible_numbers(remaining_length, remainder, digits, length)", "output": "0"}
{"task": "search", "input": "search code:\nApplies sigmoid activation function.\n\nChoices:\n0: def total_frequency_distribution(sides_number: int, dice_number: int) -> list[int]:      max_face_number = sides_number     max_total = max_face_number * dice_number     totals_frequencies = [0] * (max_total + 1)      min_face_number = 1     faces_numbers = range(min_face_number, max_face_number + 1)     for dice_numbers in product(faces_numbers, repeat=dice_number):         total = sum(dice_numbers)         totals_frequencies[total] += 1      return totals_frequencies\n1: def sigmoid(value: np.ndarray) -> np.ndarray:     return 1 / (1 + np.exp(-value))\n2: def encode(plaintext: str, key: str) -> str:      table = generate_table(key)     plaintext = prepare_input(plaintext)     ciphertext = \"\"      for char1, char2 in chunker(plaintext, 2):         row1, col1 = divmod(table.index(char1), 5)         row2, col2 = divmod(table.index(char2), 5)          if row1 == row2:             ciphertext += table[row1 * 5 + (col1 + 1) % 5]             ciphertext += table[row2 * 5 + (col2 + 1) % 5]         elif col1 == col2:             ciphertext += table[((row1 + 1) % 5) * 5 + col1]             ciphertext += table[((row2 + 1) % 5) * 5 + col2]         else:  # rectangle             ciphertext += table[row1 * 5 + col2]             ciphertext += table[row2 * 5 + col1]      return ciphertext", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef _ngettext_noop(singular, plural):\n    return (singular, plural)", "output": "Mark two strings as pluralized translations without translating them."}
{"task": "summary", "input": "summarize code:\ndef compute_geometric_mean(*args: int) -> float:\n    product = 1\n    for number in args:\n        if not isinstance(number, int) and not isinstance(number, float):\n            raise TypeError(\"Not a Number\")\n        product *= number\n    # Cannot calculate the even root for negative product.\n    # Frequently they are restricted to being positive.\n    if product < 0 and len(args) % 2 == 0:\n        raise ArithmeticError(\"Cannot Compute Geometric Mean for these numbers.\")\n    mean = abs(product) ** (1 / len(args))\n    # Since python calculates complex roots for negative products with odd roots.\n    if product < 0:\n        mean = -mean\n    # Since it does floating point arithmetic, it gives 64**(1/3) as 3.99999996\n    possible_mean = float(round(mean))\n    # To check if the rounded number is actually the mean.\n    if possible_mean ** len(args) == product:\n        mean = possible_mean\n    return mean", "output": "Return the geometric mean of the argument numbers."}
{"task": "summary", "input": "summarize code:\ndef interquartile_range(nums: list[int | float]) -> float:\n    if not nums:\n        raise ValueError(\"The list is empty. Provide a non-empty list.\")\n    nums.sort()\n    length = len(nums)\n    div, mod = divmod(length, 2)\n    q1 = find_median(nums[:div])\n    half_length = sum((div, mod))\n    q3 = find_median(nums[half_length:length])\n    return q3 - q1", "output": "Return the interquartile range for a list of numeric values."}
{"task": "summary", "input": "summarize code:\ndef netstring_server(server_socket):\n    \"A basic netstring server loop, supporting a few operations\"\n    try:\n        while True:\n            clientsock, addr = server_socket.accept()\n            client = NetstringSocket(clientsock)\n            while 1:\n                request = client.read_ns()\n                if request == b'close':\n                    clientsock.close()\n                    break\n                elif request == b'shutdown':\n                    return\n                elif request == b'reply4k':\n                    client.write_ns(b'a' * 4096)\n                elif request == b'ping':\n                    client.write_ns(b'pong')\n                elif request == b'reply128k':\n                    client.setmaxsize(128 * 1024)\n                    client.write_ns(b'huge' * 32 * 1024)  # 128kb\n                    client.setmaxsize(32768)  # back to default\n    except Exception as e:\n        print('netstring_server exiting with error: %r' % e)\n        raise", "output": "A basic netstring server loop, supporting a few operations"}
{"task": "detection", "input": "classify code:\ndef is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    A Pangram String contains all the alphabets at least once.\n    >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram(\"My name is Unknown\")\n    False\n    >>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram()\n    True\n    \"\"\"\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x", "output": "def equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x"}
{"task": "search", "input": "search code:\nConstructs the convex hull of a set of 2D points using a brute force algorithm.\n\nChoices:\n0: def convex_hull_bf(points: list[Point]) -> list[Point]:      points = sorted(_validate_input(points))     n = len(points)     convex_set = set()      for i in range(n - 1):         for j in range(i + 1, n):             points_left_of_ij = points_right_of_ij = False             ij_part_of_convex_hull = True             for k in range(n):                 if k not in {i, j}:                     det_k = _det(points[i], points[j], points[k])                      if det_k > 0:                         points_left_of_ij = True                     elif det_k < 0:                         points_right_of_ij = True                     # point[i], point[j], point[k] all lie on a straight line                     # if point[k] is to the left of point[i] or it's to the                     # right of point[j], then point[i], point[j] cannot be                     # part of the convex hull of A                     elif points[k] < points[i] or points[k] > points[j]:                         ij_part_of_convex_hull = False                         break                  if points_left_of_ij and points_right_of_ij:                     ij_part_of_convex_hull = False                     break              if ij_part_of_convex_hull:                 convex_set.update([points[i], points[j]])      return sorted(convex_set)\n1: def ordinal(value, gender=\"male\"):     try:         value = int(value)     except (TypeError, ValueError):         return value     if gender == \"male\":         t = (             P_(\"0 (male)\", \"th\"),             P_(\"1 (male)\", \"st\"),             P_(\"2 (male)\", \"nd\"),             P_(\"3 (male)\", \"rd\"),             P_(\"4 (male)\", \"th\"),             P_(\"5 (male)\", \"th\"),             P_(\"6 (male)\", \"th\"),             P_(\"7 (male)\", \"th\"),             P_(\"8 (male)\", \"th\"),             P_(\"9 (male)\", \"th\"),         )     else:         t = (             P_(\"0 (female)\", \"th\"),             P_(\"1 (female)\", \"st\"),             P_(\"2 (female)\", \"nd\"),             P_(\"3 (female)\", \"rd\"),             P_(\"4 (female)\", \"th\"),             P_(\"5 (female)\", \"th\"),             P_(\"6 (female)\", \"th\"),             P_(\"7 (female)\", \"th\"),             P_(\"8 (female)\", \"th\"),             P_(\"9 (female)\", \"th\"),         )     if value % 100 in (11, 12, 13):  # special case         return f\"{value}{t[0]}\"     return f\"{value}{t[value % 10]}\"\n2: def idft(Xarr):     N = len(Xarr)     roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]     for k in range(N):         coeffs = [roots_of_unity[k * n % N] for n in range(N)]         yield _complex_sumprod(Xarr, coeffs) / N", "output": "0"}
{"task": "search", "input": "search code:\nAnt colony algorithm main function\n\nChoices:\n0: def main(     cities: dict[int, list[int]],     ants_num: int,     iterations_num: int,     pheromone_evaporation: float,     alpha: float,     beta: float,     q: float,  # Pheromone system parameters Q, which is a constant ) -> tuple[list[int], float]:     # Initialize the pheromone matrix     cities_num = len(cities)     pheromone = [[1.0] * cities_num] * cities_num      best_path: list[int] = []     best_distance = float(\"inf\")     for _ in range(iterations_num):         ants_route = []         for _ in range(ants_num):             unvisited_cities = copy.deepcopy(cities)             current_city = {next(iter(cities.keys())): next(iter(cities.values()))}             del unvisited_cities[next(iter(current_city.keys()))]             ant_route = [next(iter(current_city.keys()))]             while unvisited_cities:                 current_city, unvisited_cities = city_select(                     pheromone, current_city, unvisited_cities, alpha, beta                 )                 ant_route.append(next(iter(current_city.keys())))             ant_route.append(0)             ants_route.append(ant_route)          pheromone, best_path, best_distance = pheromone_update(             pheromone,             cities,             pheromone_evaporation,             ants_route,             q,             best_path,             best_distance,         )     return best_path, best_distance\n1: def unquote_to_bytes(string):     # Note: strings are encoded as UTF-8. This is only an issue if it contains     # unescaped non-ASCII characters, which URIs should not.     if not string:         # Is it a string-like object?         string.split         return b''     if isinstance(string, str):         string = string.encode('utf-8')     bits = string.split(b'%')     if len(bits) == 1:         return string     # import pdb;pdb.set_trace()     res = [bits[0]]     append = res.append      for item in bits[1:]:         try:             append(_HEX_CHAR_MAP[item[:2]])             append(item[2:])         except KeyError:             append(b'%')             append(item)     return b''.join(res)\n2: def make_linked_list(elements_list: list | tuple) -> Node:      # if elements_list is empty     if not elements_list:         raise ValueError(\"The Elements List is empty\")      # Set first element as Head     head = Node(elements_list[0])     current = head     # Loop through elements from position 1     for data in elements_list[1:]:         current.next = Node(data)         current = current.next     return head", "output": "0"}
{"task": "search", "input": "search code:\nCheck if a number is perfect square number or not\n\nChoices:\n0: def solution(n: int = 1000) -> int:      return sum(e for e in range(3, n) if e % 3 == 0 or e % 5 == 0)\n1: def power(a: int, b: int) -> float:     if b < 0:         return 1 / actual_power(a, -b)     return actual_power(a, b)\n2: def perfect_square(num: int) -> bool:     return math.sqrt(num) * math.sqrt(num) == num", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef naive_cut_rod_recursive(n: int, prices: list):\n\n    _enforce_args(n, prices)\n    if n == 0:\n        return 0\n    max_revue = float(\"-inf\")\n    for i in range(1, n + 1):\n        max_revue = max(\n            max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)\n        )\n\n    return max_revue", "output": "Solves the rod-cutting problem via naively without using the benefit of dynamic"}
{"task": "repair", "input": "fix bug:\ndef combination_sum_iv(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)", "output": "def combination_sum_iv(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)"}
{"task": "repair", "input": "fix bug:\ndef combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations with using bottom up approach,\n    and returns the count of possible combination in O(N^2) Time Complexity\n    as we are using Dynamic programming array here.\n\n    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    dp_array = [0] * (target + 1)\n    dp_array[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - array[j] >= 0:\n                dp_array[i] += dp_array[i - array[j]]\n\n    return dp_array[target]", "output": "def combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations with using bottom up approach,\n    and returns the count of possible combination in O(N^2) Time Complexity\n    as we are using Dynamic programming array here.\n\n    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    dp_array = [0] * (target + 1)\n    dp_array[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - array[j] >= 0:\n                dp_array[i] += dp_array[i - array[j]]\n\n    return dp_array[target]"}
{"task": "search", "input": "search code:\nReturns the difference between the sum of the squares of the first n\n\nChoices:\n0: def nimply_gate(input_1: int, input_2: int) -> int:     return int(input_1 == 1 and input_2 == 0)\n1: def solution(n: int = 100) -> int:      sum_of_squares = 0     sum_of_ints = 0     for i in range(1, n + 1):         sum_of_squares += i**2         sum_of_ints += i     return sum_of_ints**2 - sum_of_squares\n2: def solution() -> int:     return compute_nums(1)[0]", "output": "1"}
{"task": "search", "input": "search code:\n``flatten_iter()`` yields all the elements from *iterable* while\n\nChoices:\n0: def flatten_iter(iterable):     for item in iterable:         if isinstance(item, Iterable) and not isinstance(item, (str, bytes)):             yield from flatten_iter(item)         else:             yield item\n1: def get_black_and_white_rgb(distance: float) -> tuple:     if distance == 1:         return (0, 0, 0)     else:         return (255, 255, 255)\n2: def go_next(i: int, z_result: list[int], s: str) -> bool:     return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef recursive_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Recursive matching algorithm.\n\n    | Time complexity: O(2^(\\|text\\| + \\|pattern\\|))\n    | Space complexity: Recursion depth is O(\\|text\\| + \\|pattern\\|).\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> recursive_match('abc', 'a.c')\n    True\n    >>> recursive_match('abc', 'af*.c')\n    True\n    >>> recursive_match('abc', 'a.c*')\n    True\n    >>> recursive_match('abc', 'a.c*d')\n    False\n    >>> recursive_match('aa', '.*')\n    True\n    \"\"\"\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False", "output": "def recursive_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Recursive matching algorithm.\n\n    | Time complexity: O(2^(\\|text\\| + \\|pattern\\|))\n    | Space complexity: Recursion depth is O(\\|text\\| + \\|pattern\\|).\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> recursive_match('abc', 'a.c')\n    True\n    >>> recursive_match('abc', 'af*.c')\n    True\n    >>> recursive_match('abc', 'a.c*')\n    True\n    >>> recursive_match('abc', 'a.c*d')\n    False\n    >>> recursive_match('aa', '.*')\n    True\n    \"\"\"\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False"}
{"task": "detection", "input": "classify code:\ndef kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is mv\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn the product of a,b,c which are Pythagorean Triplet that satisfies\n\nChoices:\n0: def mean_absolute_error(predicted_y, original_y):     total = sum(abs(y - predicted_y[i]) for i, y in enumerate(original_y))     return total / len(original_y)\n1: def solution(n: int = 1000) -> int:      product = -1     candidate = 0     for a in range(1, n // 3):         # Solving the two equations a**2+b**2=c**2 and a+b+c=N eliminating c         b = (n * n - 2 * a * n) // (2 * n - 2 * a)         c = n - a - b         if c * c == (a * a + b * b):             candidate = a * b * c             product = max(product, candidate)     return product\n2: def upper(word: str) -> str:     return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)", "output": "1"}
{"task": "search", "input": "search code:\nReturn a list of all primes numbers up to max.\n\nChoices:\n0: def krusk(e_and_n):     (e, n) = e_and_n     e.sort(reverse=True, key=lambda x: x[2])     s = [{i} for i in range(1, n + 1)]     while True:         if len(s) == 1:             break         print(s)         x = e.pop()         for i in range(len(s)):             if x[0] in s[i]:                 break         for j in range(len(s)):             if x[1] in s[j]:                 if i == j:                     break                 s[j].update(s[i])                 s.pop(i)                 break\n1: def get_nodes_from_left_to_right(root: Node | None, level: int) -> Generator[int]:      def populate_output(root: Node | None, level: int) -> Generator[int]:         if not root:             return         if level == 1:             yield root.data         elif level > 1:             yield from populate_output(root.left, level - 1)             yield from populate_output(root.right, level - 1)      yield from populate_output(root, level)\n2: def primes(max_n: int) -> Generator[int]:     numbers: Generator = (i for i in range(1, (max_n + 1)))     for i in (n for n in numbers if n > 1):         # only need to check for factors up to sqrt(i)         bound = int(math.sqrt(i)) + 1         for j in range(2, bound):             if (i % j) == 0:                 break         else:             yield i", "output": "2"}
{"task": "search", "input": "search code:\nReturn the median of the input list\n\nChoices:\n0: def split_before(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         if pred(item) and buf:             yield buf             if maxsplit == 1:                 yield [item, *it]                 return             buf = []             maxsplit -= 1         buf.append(item)     if buf:         yield buf\n1: def median_of_five(arr: list) -> int:     arr = sorted(arr)     return arr[len(arr) // 2]\n2: def median_filter(gray_img, mask=3):     # set image borders     bd = int(mask / 2)     # copy image size     median_img = zeros_like(gray_img)     for i in range(bd, gray_img.shape[0] - bd):         for j in range(bd, gray_img.shape[1] - bd):             # get mask according with mask             kernel = ravel(gray_img[i - bd : i + bd + 1, j - bd : j + bd + 1])             # calculate mask median             median = sort(kernel)[int8(divide((multiply(mask, mask)), 2) + 1)]             median_img[i, j] = median     return median_img", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef split(string: str, separator: str = \" \") -> list:\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        if index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words", "output": "Will split the string up into all the values separated by the separator"}
{"task": "summary", "input": "summarize code:\ndef encipher(message: str, cipher_map: dict[str, str]) -> str:\n    return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())", "output": "Enciphers a message given a cipher map."}
{"task": "detection", "input": "classify code:\ndef sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the product of a,b,c which are Pythagorean Triplet that satisfies\n\nChoices:\n0: def valid_connection(     graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int] ) -> bool:      # 1. Validate that path exists between current and next vertices     if graph[path[curr_ind - 1]][next_ver] == 0:         return False      # 2. Validate that next vertex is not already in path     return not any(vertex == next_ver for vertex in path)\n1: def solution_fast() -> int:      for a in range(300):         for b in range(400):             c = 1000 - a - b             if a < b < c and (a**2) + (b**2) == (c**2):                 return a * b * c      return -1\n2: def rotate_array(arr: list[int], steps: int) -> list[int]:      n = len(arr)     if n == 0:         return arr      steps = steps % n      if steps < 0:         steps += n      def reverse(start: int, end: int) -> None:          while start < end:             arr[start], arr[end] = arr[end], arr[start]             start += 1             end -= 1      reverse(0, n - 1)     reverse(0, steps - 1)     reverse(steps, n - 1)      return arr", "output": "1"}
{"task": "search", "input": "search code:\nTakes a type and returns an iterator over all class variables\n\nChoices:\n0: def score_function(     source_char: str,     target_char: str,     match: int = 1,     mismatch: int = -1,     gap: int = -2, ) -> int:     if \"-\" in (source_char, target_char):         return gap     return match if source_char == target_char else mismatch\n1: def map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):      ret = defaultdict(list)      if valuefunc is None:         for item in iterable:             key = keyfunc(item)             ret[key].append(item)      else:         for item in iterable:             key = keyfunc(item)             value = valuefunc(item)             ret[key].append(value)      if reducefunc is not None:         for key, value_list in ret.items():             ret[key] = reducefunc(value_list)      ret.default_factory = None     return ret\n2: def mro_items(type_obj):     # TODO: handle slots?     return itertools.chain.from_iterable(ct.__dict__.items()                                          for ct in type_obj.__mro__)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef max_subarray(\n    arr: Sequence[float], low: int, high: int\n) -> tuple[int | None, int | None, float]:\n    if not arr:\n        return None, None, 0\n    if low == high:\n        return low, high, arr[low]\n\n    mid = (low + high) // 2\n    left_low, left_high, left_sum = max_subarray(arr, low, mid)\n    right_low, right_high, right_sum = max_subarray(arr, mid + 1, high)\n    cross_left, cross_right, cross_sum = max_cross_sum(arr, low, mid, high)\n    if left_sum >= right_sum and left_sum >= cross_sum:\n        return left_low, left_high, left_sum\n    elif right_sum >= left_sum and right_sum >= cross_sum:\n        return right_low, right_high, right_sum\n    return cross_left, cross_right, cross_sum", "output": "Solves the maximum subarray problem using divide and conquer."}
{"task": "search", "input": "search code:\nValidates the adjacency list format for the graph.\n\nChoices:\n0: def validate_adjacency_list(graph: list[list[int | None]]) -> None:     if not isinstance(graph, list):         raise ValueError(\"Graph should be a list of lists.\")      for node_index, neighbors in enumerate(graph):         if not isinstance(neighbors, list):             no_neighbors_message: str = (                 f\"Node {node_index} should have a list of neighbors.\"             )             raise ValueError(no_neighbors_message)         for neighbor_index in neighbors:             if (                 not isinstance(neighbor_index, int)                 or neighbor_index < 0                 or neighbor_index >= len(graph)             ):                 invalid_neighbor_message: str = (                     f\"Invalid neighbor {neighbor_index} in node {node_index} \"                     f\"adjacency list.\"                 )                 raise ValueError(invalid_neighbor_message)\n1: def get_rotation(     img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int ) -> np.ndarray:     matrix = cv2.getAffineTransform(pt1, pt2)     return cv2.warpAffine(img, matrix, (rows, cols))\n2: def eval_exponential(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:     return np.exp(z_values) + c_parameter", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef pi_estimator_using_area_under_curve(iterations: int) -> None:\n\n    def function_to_integrate(x: float) -> float:\n        return sqrt(4.0 - x * x)\n\n    estimated_value = area_under_curve_estimator(\n        iterations, function_to_integrate, 0.0, 2.0\n    )\n\n    print(\"******************\")\n    print(\"Estimating pi using area_under_curve_estimator\")\n    print(f\"Estimated value is {estimated_value}\")\n    print(f\"Expected value is {pi}\")\n    print(f\"Total error is {abs(estimated_value - pi)}\")\n    print(\"******************\")", "output": "Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi"}
{"task": "summary", "input": "summarize code:\ndef sarimax_predictor(train_user: list, train_match: list, test_match: list) -> float:\n    # Suppress the User Warning raised by SARIMAX due to insufficient observations\n    simplefilter(\"ignore\", UserWarning)\n    order = (1, 2, 1)\n    seasonal_order = (1, 1, 1, 7)\n    model = SARIMAX(\n        train_user, exog=train_match, order=order, seasonal_order=seasonal_order\n    )\n    model_fit = model.fit(disp=False, maxiter=600, method=\"nm\")\n    result = model_fit.predict(1, len(test_match), exog=[test_match])\n    return float(result[0])", "output": "second method: Sarimax"}
{"task": "search", "input": "search code:\nDecorator factory to apply update_wrapper() to a wrapper function.\n\nChoices:\n0: def solution() -> int:     num = 138902663      while not is_square_form(num * num):         if num % 10 == 3:             num -= 6  # (3 - 6) % 10 = 7         else:             num -= 4  # (7 - 4) % 10 = 3      return num * 10\n1: def wraps(func, injected=None, expected=None, **kw):     return partial(update_wrapper, func=func, build_from=None,                    injected=injected, expected=expected, **kw)\n2: def shell_sort(collection: list) -> list:      # Choose an initial gap value     gap = len(collection)      # Set the gap value to be decreased by a factor of 1.3     # after each iteration     shrink = 1.3      # Continue sorting until the gap is 1     while gap > 1:         # Decrease the gap value         gap = int(gap / shrink)          # Sort the elements using insertion sort         for i in range(gap, len(collection)):             temp = collection[i]             j = i             while j >= gap and collection[j - gap] > temp:                 collection[j] = collection[j - gap]                 j -= gap             collection[j] = temp      return collection", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef catalan_number(node_count: int) -> int:\n    return binomial_coefficient(2 * node_count, node_count) // (node_count + 1)", "output": "We can find Catalan number many ways but here we use Binomial Coefficient because it"}
{"task": "summary", "input": "summarize code:\ndef is_monotonic(nums: list[int]) -> bool:\n    return all(nums[i] <= nums[i + 1] for i in range(len(nums) - 1)) or all(\n        nums[i] >= nums[i + 1] for i in range(len(nums) - 1)\n    )", "output": "Check if a list is monotonic."}
{"task": "search", "input": "search code:\nGiven Open Library book data, return a summary as a Python dict.\n\nChoices:\n0: def summarize_book(ol_book_data: dict) -> dict:     desired_keys = {         \"title\": \"Title\",         \"publish_date\": \"Publish date\",         \"authors\": \"Authors\",         \"number_of_pages\": \"Number of pages\",         \"isbn_10\": \"ISBN (10)\",         \"isbn_13\": \"ISBN (13)\",     }     data = {better_key: ol_book_data[key] for key, better_key in desired_keys.items()}     data[\"Authors\"] = [         get_openlibrary_data(author[\"key\"])[\"name\"] for author in data[\"Authors\"]     ]     for key, value in data.items():         if isinstance(value, list):             data[key] = \", \".join(value)     return data\n1: def solution(n: int = 1000000):     total = 0      for i in range(1, n):         if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):             total += i     return total\n2: def avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:     arr = np.array(arr)     if arr.shape[0] != arr.shape[1]:         raise ValueError(\"The input array is not a square matrix\")     i = 0     j = 0     mat_i = 0     mat_j = 0      # compute the shape of the output matrix     avgpool_shape = (arr.shape[0] - size) // stride + 1     # initialize the output matrix with zeros of shape avgpool_shape     updated_arr = np.zeros((avgpool_shape, avgpool_shape))      while i < arr.shape[0]:         # if the end of the matrix is reached, break         if i + size > arr.shape[0]:             break         while j < arr.shape[1]:             # if the end of the matrix is reached, break             if j + size > arr.shape[1]:                 break             # compute the average of the pooling matrix             updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))             # shift the pooling matrix by stride of column pixels             j += stride             mat_j += 1          # shift the pooling matrix by stride of row pixels         i += stride         mat_i += 1         # reset the column index to 0         j = 0         mat_j = 0      return updated_arr", "output": "0"}
{"task": "search", "input": "search code:\nThis function finds an empty location so that we can assign a number\n\nChoices:\n0: def compute_transform_tables(     source_string: str,     destination_string: str,     copy_cost: int,     replace_cost: int,     delete_cost: int,     insert_cost: int, ) -> tuple[list[list[int]], list[list[str]]]:     source_seq = list(source_string)     destination_seq = list(destination_string)     len_source_seq = len(source_seq)     len_destination_seq = len(destination_seq)     costs = [         [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]     ops = [         [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]      for i in range(1, len_source_seq + 1):         costs[i][0] = i * delete_cost         ops[i][0] = f\"D{source_seq[i - 1]}\"      for i in range(1, len_destination_seq + 1):         costs[0][i] = i * insert_cost         ops[0][i] = f\"I{destination_seq[i - 1]}\"      for i in range(1, len_source_seq + 1):         for j in range(1, len_destination_seq + 1):             if source_seq[i - 1] == destination_seq[j - 1]:                 costs[i][j] = costs[i - 1][j - 1] + copy_cost                 ops[i][j] = f\"C{source_seq[i - 1]}\"             else:                 costs[i][j] = costs[i - 1][j - 1] + replace_cost                 ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])              if costs[i - 1][j] + delete_cost < costs[i][j]:                 costs[i][j] = costs[i - 1][j] + delete_cost                 ops[i][j] = f\"D{source_seq[i - 1]}\"              if costs[i][j - 1] + insert_cost < costs[i][j]:                 costs[i][j] = costs[i][j - 1] + insert_cost                 ops[i][j] = f\"I{destination_seq[j - 1]}\"      return costs, ops\n1: def while_solution(max_number: int = 10**8) -> int:      prime_numbers = calculate_prime_numbers(max_number // 2)      semiprimes_count = 0     left = 0     right = len(prime_numbers) - 1     while left <= right:         while prime_numbers[left] * prime_numbers[right] >= max_number:             right -= 1         semiprimes_count += right - left + 1         left += 1      return semiprimes_count\n2: def find_empty_location(grid: Matrix) -> tuple[int, int] | None:     for i in range(9):         for j in range(9):             if grid[i][j] == 0:                 return i, j     return None", "output": "2"}
{"task": "search", "input": "search code:\nReturns the nth lucas number\n\nChoices:\n0: def recursive_lucas_number(n_th_number: int) -> int:     if not isinstance(n_th_number, int):         raise TypeError(\"recursive_lucas_number accepts only integer arguments.\")     if n_th_number == 0:         return 2     if n_th_number == 1:         return 1      return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(         n_th_number - 2     )\n1: def alternative_string_arrange(first_str: str, second_str: str) -> str:     first_str_length: int = len(first_str)     second_str_length: int = len(second_str)     abs_length: int = (         first_str_length if first_str_length > second_str_length else second_str_length     )     output_list: list = []     for char_count in range(abs_length):         if char_count < first_str_length:             output_list.append(first_str[char_count])         if char_count < second_str_length:             output_list.append(second_str[char_count])     return \"\".join(output_list)\n2: def _norm_args_notimplemented(other):     if type(other) in (set, frozenset):         inc, exc = other, None     elif type(other) is _ComplementSet:         inc, exc = other._included, other._excluded     else:         return NotImplemented, None     return inc, exc", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef indent(text, margin, newline='\\n', key=bool):\n    indented_lines = [(margin + line if key(line) else line)\n                      for line in iter_splitlines(text)]\n    return newline.join(indented_lines)", "output": "The missing counterpart to the built-in :func:`textwrap.dedent`."}
{"task": "summary", "input": "summarize code:\ndef digit_sum(n: int) -> int:\n    return sum(int(digit) for digit in str(n))", "output": "Returns the sum of the digits of the number."}
{"task": "summary", "input": "summarize code:\ndef sumset(set_a: set, set_b: set) -> set:\n    assert isinstance(set_a, set), f\"The input value of [set_a={set_a}] is not a set\"\n    assert isinstance(set_b, set), f\"The input value of [set_b={set_b}] is not a set\"\n\n    return {a + b for a in set_a for b in set_b}", "output": ":param first set: a set of numbers"}
{"task": "repair", "input": "fix bug:\ndef find_negative_index(array: list[int]) -> int:\n    \"\"\"\n    Find the smallest negative index\n\n    >>> find_negative_index([0,0,0,0])\n    4\n    >>> find_negative_index([4,3,2,-1])\n    3\n    >>> find_negative_index([1,0,-1,-10])\n    2\n    >>> find_negative_index([0,0,0,-1])\n    3\n    >>> find_negative_index([11,8,7,-3,-5,-9])\n    3\n    >>> find_negative_index([-1,-1,-2,-3])\n    0\n    >>> find_negative_index([5,1,0])\n    3\n    >>> find_negative_index([-5,-5,-5])\n    0\n    >>> find_negative_index([0])\n    1\n    >>> find_negative_index([])\n    0\n    \"\"\"\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)", "output": "def find_negative_index(array: list[int]) -> int:\n    \"\"\"\n    Find the smallest negative index\n\n    >>> find_negative_index([0,0,0,0])\n    4\n    >>> find_negative_index([4,3,2,-1])\n    3\n    >>> find_negative_index([1,0,-1,-10])\n    2\n    >>> find_negative_index([0,0,0,-1])\n    3\n    >>> find_negative_index([11,8,7,-3,-5,-9])\n    3\n    >>> find_negative_index([-1,-1,-2,-3])\n    0\n    >>> find_negative_index([5,1,0])\n    3\n    >>> find_negative_index([-5,-5,-5])\n    0\n    >>> find_negative_index([0])\n    1\n    >>> find_negative_index([])\n    0\n    \"\"\"\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)"}
{"task": "summary", "input": "summarize code:\ndef max_sum_bst(root: TreeNode | None) -> int:\n    ans: int = 0\n\n    def solver(node: TreeNode | None) -> tuple[bool, int, int, int]:\n        nonlocal ans\n\n        if not node:\n            return True, INT_MAX, INT_MIN, 0  # Valid BST, min, max, sum\n\n        is_left_valid, min_left, max_left, sum_left = solver(node.left)\n        is_right_valid, min_right, max_right, sum_right = solver(node.right)\n\n        if is_left_valid and is_right_valid and max_left < node.val < min_right:\n            total_sum = sum_left + sum_right + node.val\n            ans = max(ans, total_sum)\n            return True, min(min_left, node.val), max(max_right, node.val), total_sum\n\n        return False, -1, -1, -1  # Not a valid BST\n\n    solver(root)\n    return ans", "output": "The solution traverses a binary tree to find the maximum sum of"}
{"task": "repair", "input": "fix bug:\ndef double_linear_search(array: List[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r", "output": "def double_linear_search(array: list[int], search_item: int) -> int:\r\n    \"\"\"\r\n    Iterate through the array from both sides to find the index of search_item.\r\n\r\n    :param array: the array to be searched\r\n    :param search_item: the item to be searched\r\n    :return the index of search_item, if search_item is in array, else -1\r\n\r\n    Examples:\r\n    >>> double_linear_search([1, 5, 5, 10], 1)\r\n    0\r\n    >>> double_linear_search([1, 5, 5, 10], 5)\r\n    1\r\n    >>> double_linear_search([1, 5, 5, 10], 100)\r\n    -1\r\n    >>> double_linear_search([1, 5, 5, 10], 10)\r\n    3\r\n    \"\"\"\r\n    # define the start and end index of the given array\r\n    start_ind, end_ind = 0, len(array) - 1\r\n    while start_ind <= end_ind:\r\n        if array[start_ind] == search_item:\r\n            return start_ind\r\n        elif array[end_ind] == search_item:\r\n            return end_ind\r\n        else:\r\n            start_ind += 1\r\n            end_ind -= 1\r\n    # returns -1 if search_item is not found in array\r\n    return -1\r"}
{"task": "repair", "input": "fix bug:\ndef bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1", "output": "def bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1"}
{"task": "search", "input": "search code:\nReturn the sum of the factorial of the digits of n.\n\nChoices:\n0: def unquote(string, encoding='utf-8', errors='replace'):     if '%' not in string:         string.split         return string     if encoding is None:         encoding = 'utf-8'     if errors is None:         errors = 'replace'     bits = _ASCII_RE.split(string)     res = [bits[0]]     append = res.append     for i in range(1, len(bits), 2):         append(unquote_to_bytes(bits[i]).decode(encoding, errors))         append(bits[i + 1])     return ''.join(res)\n1: def sum_digit_factorials(n: int) -> int:     if n in CACHE_SUM_DIGIT_FACTORIALS:         return CACHE_SUM_DIGIT_FACTORIALS[n]     ret = sum(DIGIT_FACTORIALS[let] for let in str(n))     CACHE_SUM_DIGIT_FACTORIALS[n] = ret     return ret\n2: def generate_pascal_triangle_optimized(num_rows: int) -> list[list[int]]:      if not isinstance(num_rows, int):         raise TypeError(\"The input value of 'num_rows' should be 'int'\")      if num_rows == 0:         return []     elif num_rows < 0:         raise ValueError(             \"The input value of 'num_rows' should be greater than or equal to 0\"         )      result: list[list[int]] = [[1]]      for row_index in range(1, num_rows):         temp_row = [0] + result[-1] + [0]         row_length = row_index + 1         # Calculate the number of distinct elements in a row         distinct_elements = sum(divmod(row_length, 2))         row_first_half = [             temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)         ]         row_second_half = row_first_half[: (row_index + 1) // 2]         row_second_half.reverse()         row = row_first_half + row_second_half         result.append(row)      return result", "output": "1"}
{"task": "search", "input": "search code:\nReturns the sum of all even fibonacci sequence elements that are lower\n\nChoices:\n0: def solution(n: int = 4000000) -> int:      even_fibs = []     a, b = 0, 1     while b <= n:         if b % 2 == 0:             even_fibs.append(b)         a, b = b, a + b     return sum(even_fibs)\n1: def simple_moving_average(     data: Sequence[float], window_size: int ) -> list[float | None]:     if window_size < 1:         raise ValueError(\"Window size must be a positive integer\")      sma: list[float | None] = []      for i in range(len(data)):         if i < window_size - 1:             sma.append(None)  # SMA not available for early data points         else:             window = data[i - window_size + 1 : i + 1]             sma_value = sum(window) / window_size             sma.append(sma_value)     return sma\n2: def height(root: Node | None) -> int:     return (max(height(root.left), height(root.right)) + 1) if root else 0", "output": "0"}
{"task": "search", "input": "search code:\nReturn the least value of n for which least_divisible_repunit(n)\n\nChoices:\n0: def mel_to_freq(mels: float) -> float:     # Use the formula to convert mel scale to frequency     return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)\n1: def make_tree_nine() -> Node:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     tree.right.right = Node(6)     tree.left.left.left = Node(7)     tree.left.left.right = Node(8)     tree.left.right.right = Node(9)     return tree\n2: def solution(limit: int = 1000000) -> int:     divisor = limit - 1     if divisor % 2 == 0:         divisor += 1     while least_divisible_repunit(divisor) <= limit:         divisor += 2     return divisor", "output": "2"}
{"task": "search", "input": "search code:\nSort Array with Pancake Sort.\n\nChoices:\n0: def pancake_sort(arr):     cur = len(arr)     while cur > 1:         # Find the maximum number in arr         mi = arr.index(max(arr[0:cur]))         # Reverse from 0 to mi         arr = arr[mi::-1] + arr[mi + 1 : len(arr)]         # Reverse whole list         arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]         cur -= 1     return arr\n1: def get_cost_derivative(index):     cost_derivative_value = summation_of_cost_derivative(index, m) / m     return cost_derivative_value\n2: def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:     r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]     return 0.2989 * r + 0.5870 * g + 0.1140 * b", "output": "0"}
{"task": "search", "input": "search code:\nWe split current tree into 2 trees with value:\n\nChoices:\n0: def transformation_matrix(velocity: float) -> np.ndarray:     return np.array(         [             [gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],             [-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],             [0, 0, 1, 0],             [0, 0, 0, 1],         ]     )\n1: def split(root: Node | None, value: int) -> tuple[Node | None, Node | None]:     if root is None or root.value is None:  # None tree is split into 2 Nones         return None, None     elif value < root.value:         left, root.left = split(root.left, value)         return left, root     else:         root.right, right = split(root.right, value)         return root, right\n2: def calculate_fft(audio_windowed: np.ndarray, ftt_size: int = 1024) -> np.ndarray:     # Transpose the audio data to have time in rows and channels in columns     audio_transposed = np.transpose(audio_windowed)      # Initialize an array to store the FFT results     audio_fft = np.empty(         (int(1 + ftt_size // 2), audio_transposed.shape[1]),         dtype=np.complex64,         order=\"F\",     )      # Compute FFT for each channel     for n in range(audio_fft.shape[1]):         audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]      # Transpose the FFT results back to the original shape     return np.transpose(audio_fft)", "output": "1"}
{"task": "detection", "input": "classify code:\ndef get_squared_primes_to_use(\n    num_to_look: int, squared_primes: list[int], previous_index: int\n) -> int:\n    \"\"\"\n    Returns an int indicating the last index on which squares of primes\n    in primes are lower than num_to_look.\n\n    This method supposes that squared_primes is sorted in ascending order and that\n    each num_to_look is provided in ascending order as well. Under these\n    assumptions, it needs a previous_index parameter that tells what was\n    the index returned by the method for the previous num_to_look.\n\n    If all the elements in squared_primes are greater than num_to_look, then the\n    method returns -1.\n\n    >>> get_squared_primes_to_use(1, [4, 9, 16, 25], 0)\n    -1\n    >>> get_squared_primes_to_use(4, [4, 9, 16, 25], 0)\n    1\n    >>> get_squared_primes_to_use(16, [4, 9, 16, 25], 1)\n    3\n    \"\"\"\n    idx = max(previous_index, 0)\n\n    while idx < len(squared_primes) and squared_primes[idx] <= num_to_look:\n        idx += 1\n\n    if idx == 0 and squared_primes[idx] > num_to_look:\n        return -1\n\n    if idx == len(squared_primes) and squared_primes[-1] > num_to_look:\n        return -1\n\n    return idx", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef match_pattern(input_string: str, pattern: str) -> bool:\n    \"\"\"\n    uses bottom-up dynamic programming solution for matching the input\n    string with a given pattern.\n\n    Runtime: O(len(input_string)*len(pattern))\n\n    Arguments\n    --------\n    input_string: str, any string which should be compared with the pattern\n    pattern: str, the string that represents a pattern and may contain\n    '.' for single character matches and '*' for zero or more of preceding character\n    matches\n\n    Note\n    ----\n    the pattern cannot start with a '*',\n    because there should be at least one character before *\n\n    Returns\n    -------\n    A Boolean denoting whether the given string follows the pattern\n\n    Examples\n    -------\n    >>> match_pattern(\"aab\", \"c*a*b\")\n    True\n    >>> match_pattern(\"dabc\", \"*abc\")\n    False\n    >>> match_pattern(\"aaa\", \"aa\")\n    False\n    >>> match_pattern(\"aaa\", \"a.a\")\n    True\n    >>> match_pattern(\"aaab\", \"aa*\")\n    False\n    >>> match_pattern(\"aaab\", \".*\")\n    True\n    >>> match_pattern(\"a\", \"bbbb\")\n    False\n    >>> match_pattern(\"\", \"bbbb\")\n    False\n    >>> match_pattern(\"a\", \"\")\n    False\n    >>> match_pattern(\"\", \"\")\n    True\n    \"\"\"\n\n    len_string = len(input_string) + 1\n    len_pattern = len(pattern) + 1\n\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\n    # length i of input_string matches with prefix string of length j of\n    # given pattern.\n    # \"dp\" stands for dynamic programming.\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\n\n    # since string of zero length match pattern of zero length\n    dp[0][0] = 1\n\n    # since pattern of zero length will never match with string of non-zero length\n    for i in range(1, len_string):\n        dp[i][0] = 0\n\n    # since string of zero length will match with pattern where there\n    # is at least one * alternatively\n    for j in range(1, len_pattern):\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \"*\" else 0\n\n    # now using bottom-up approach to find for all remaining lengths\n    for i in range(1, len_string):\n        for j in range(1, len_pattern):\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \".\":\n                dp[i][j] = dp[i - 1][j - 1]\n\n            elif pattern[j - 1] == \"*\":\n                if dp[i][j - 2] == 1:\n                    dp[i][j] = 1\n                elif pattern[j - 2] in (input_string[i - 1], \".\"):\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n\n    return bool(dp[-1][-1])", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFirst method: linear regression\n\nChoices:\n0: def linear_regression_prediction(     train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list ) -> float:     x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])     y = np.array(train_usr)     beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)     return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])\n1: def maxpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:     arr = np.array(arr)     if arr.shape[0] != arr.shape[1]:         raise ValueError(\"The input array is not a square matrix\")     i = 0     j = 0     mat_i = 0     mat_j = 0      # compute the shape of the output matrix     maxpool_shape = (arr.shape[0] - size) // stride + 1     # initialize the output matrix with zeros of shape maxpool_shape     updated_arr = np.zeros((maxpool_shape, maxpool_shape))      while i < arr.shape[0]:         if i + size > arr.shape[0]:             # if the end of the matrix is reached, break             break         while j < arr.shape[1]:             # if the end of the matrix is reached, break             if j + size > arr.shape[1]:                 break             # compute the maximum of the pooling matrix             updated_arr[mat_i][mat_j] = np.max(arr[i : i + size, j : j + size])             # shift the pooling matrix by stride of column pixels             j += stride             mat_j += 1          # shift the pooling matrix by stride of row pixels         i += stride         mat_i += 1          # reset the column index to 0         j = 0         mat_j = 0      return updated_arr\n2: def check_partition_perfect(positive_integer: int) -> bool:      exponent = math.log2(math.sqrt(4 * positive_integer + 1) / 2 + 1 / 2)      return exponent == int(exponent)", "output": "0"}
{"task": "search", "input": "search code:\nPrune candidate itemsets that are not frequent.\n\nChoices:\n0: def prune(itemset: list, candidates: list, length: int) -> list:     itemset_counter = Counter(tuple(item) for item in itemset)     pruned = []     for candidate in candidates:         is_subsequence = True         for item in candidate:             item_tuple = tuple(item)             if (                 item_tuple not in itemset_counter                 or itemset_counter[item_tuple] < length - 1             ):                 is_subsequence = False                 break         if is_subsequence:             pruned.append(candidate)     return pruned\n1: def infer_positional_format_args(fstr):     # TODO: memoize     ret, max_anon = '', 0     # look for {: or {! or {. or {[ or {}     start, end, prev_end = 0, 0, 0     for match in _pos_farg_re.finditer(fstr):         start, end, group = match.start(), match.end(), match.group()         if prev_end < start:             ret += fstr[prev_end:start]         prev_end = end         if group == '{{' or group == '}}':             ret += group             continue         ret += f'{{{max_anon}{group[1:]}'         max_anon += 1     ret += fstr[prev_end:]     return ret\n2: def unique_in_window(iterable, n, key=None):     if n <= 0:         raise ValueError('n must be greater than 0')      window = deque(maxlen=n)     counts = Counter()     use_key = key is not None      for item in iterable:         if len(window) == n:             to_discard = window[0]             if counts[to_discard] == 1:                 del counts[to_discard]             else:                 counts[to_discard] -= 1          k = key(item) if use_key else item         if k not in counts:             yield item         counts[k] += 1         window.append(k)", "output": "0"}
{"task": "search", "input": "search code:\nCalculates the expected number of distinct colours\n\nChoices:\n0: def solution(max_base: int = 10, max_power: int = 22) -> int:     bases = range(1, max_base)     powers = range(1, max_power)     return sum(         1 for power in powers for base in bases if len(str(base**power)) == power     )\n1: def solution(num_picks: int = 20) -> str:     total = math.comb(NUM_BALLS, num_picks)     missing_colour = math.comb(NUM_BALLS - BALLS_PER_COLOUR, num_picks)      result = NUM_COLOURS * (1 - missing_colour / total)      return f\"{result:.9f}\"\n2: def validate_initial_digits(credit_card_number: str) -> bool:     return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))", "output": "1"}
{"task": "search", "input": "search code:\nCreate ngrams from a sentence\n\nChoices:\n0: def print_optimal_solution(optimal_solution: list[list[int]], i: int, j: int):      if i == j:         print(\"A\" + str(i), end=\" \")     else:         print(\"(\", end=\" \")         print_optimal_solution(optimal_solution, i, optimal_solution[i][j])         print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j)         print(\")\", end=\" \")\n1: def create_ngram(sentence: str, ngram_size: int) -> list[str]:     return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]\n2: def tail(n, iterable):     try:         size = len(iterable)     except TypeError:         return iter(deque(iterable, maxlen=n))     else:         return islice(iterable, max(0, size - n), None)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 100) -> int:\n    collect_powers = set()\n\n    current_pow = 0\n\n    n = n + 1  # maximum limit\n\n    for a in range(2, n):\n        for b in range(2, n):\n            current_pow = a**b  # calculates the current power\n            collect_powers.add(current_pow)  # adds the result to the set\n    return len(collect_powers)", "output": "Returns the number of distinct terms in the sequence generated by a^b"}
{"task": "search", "input": "search code:\nDecompresses given data_bits using Lempel-Ziv-Welch compression algorithm\n\nChoices:\n0: def decompress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         lexicon[curr_string] = last_match_id + \"0\"          if math.log2(index).is_integer():             new_lex = {}             for curr_key in list(lexicon):                 new_lex[\"0\" + curr_key] = lexicon.pop(curr_key)             lexicon = new_lex          lexicon[bin(index)[2:]] = last_match_id + \"1\"         index += 1         curr_string = \"\"     return result\n1: def solution(percent: float = 99) -> int:     if not 0 < percent < 100:         raise ValueError(\"solution() only accepts values from 0 to 100\")     bouncy_num = 0     num = 1      while True:         if check_bouncy(num):             bouncy_num += 1         if (bouncy_num / num) * 100 >= percent:             return num         num += 1\n2: def solution(max_n: int = 10000000) -> int:      min_numerator = 1  # i     min_denominator = 0  # (i)     totients = get_totients(max_n + 1)      for i in range(2, max_n + 1):         t = totients[i]          if i * min_denominator < min_numerator * t and has_same_digits(i, t):             min_numerator = i             min_denominator = t      return min_numerator", "output": "0"}
{"task": "search", "input": "search code:\nCheck if number is a perfect square.\n\nChoices:\n0: def is_sq(number: int) -> bool:     sq: int = int(number**0.5)     return number == sq * sq\n1: def double_sort(collection: list[Any]) -> list[Any]:     no_of_elements = len(collection)     for _ in range(         int(((no_of_elements - 1) / 2) + 1)     ):  # we don't need to traverse to end of list as         for j in range(no_of_elements - 1):             # apply the bubble sort algorithm from left to right (or forwards)             if collection[j + 1] < collection[j]:                 collection[j], collection[j + 1] = collection[j + 1], collection[j]             # apply the bubble sort algorithm from right to left (or backwards)             if collection[no_of_elements - 1 - j] < collection[no_of_elements - 2 - j]:                 (                     collection[no_of_elements - 1 - j],                     collection[no_of_elements - 2 - j],                 ) = (                     collection[no_of_elements - 2 - j],                     collection[no_of_elements - 1 - j],                 )     return collection\n2: def process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:      game_matrix = [list(row) for row in matrix]     total_score = 0      for move in moves:         pos_x, pos_y = move         game_matrix, score = play(game_matrix, pos_x, pos_y, size)         total_score += score      return total_score", "output": "0"}
{"task": "search", "input": "search code:\nYield *value*, followed by the elements in *iterator*.\n\nChoices:\n0: def gunzip_bytes(bytestring):     return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)\n1: def tribonacci(num: int) -> list[int]:     dp = [0] * num     dp[2] = 1      for i in range(3, num):         dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]      return dp\n2: def prepend(value, iterator):     return chain([value], iterator)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef solve(nums: list[int], goal: int, depth: int) -> bool:\n    \"\"\"\n    Checks if nums can have a sum equal to goal, given that length of nums does\n    not exceed depth.\n\n    >>> solve([1], 2, 2)\n    True\n    >>> solve([1], 2, 0)\n    False\n    \"\"\"\n    if len(nums) > depth:\n        return False\n    for el in nums:\n        if el + nums[-1] == goal:\n            return True\n        nums.append(el + nums[-1])\n        if solve(nums=nums, goal=goal, depth=depth):\n            return True\n        del nums[-1]\n    return False", "output": "BUGGY"}
{"task": "search", "input": "search code:\nSolves the rod-cutting problem via naively without using the benefit of dynamic\n\nChoices:\n0: def naive_cut_rod_recursive(n: int, prices: list):      _enforce_args(n, prices)     if n == 0:         return 0     max_revue = float(\"-inf\")     for i in range(1, n + 1):         max_revue = max(             max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)         )      return max_revue\n1: def _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):     if max_rev[n] >= 0:         return max_rev[n]     elif n == 0:         return 0     else:         max_revenue = float(\"-inf\")         for i in range(1, n + 1):             max_revenue = max(                 max_revenue,                 prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),             )          max_rev[n] = max_revenue      return max_rev[n]\n2: def _running_median_windowed(iterator, maxlen):     \"Yield median of values in a sliding window.\"      window = deque()     ordered = []      for x in iterator:         window.append(x)         insort(ordered, x)          if len(ordered) > maxlen:             i = bisect_left(ordered, window.popleft())             del ordered[i]          n = len(ordered)         m = n // 2         yield ordered[m] if n & 1 else (ordered[m - 1] + ordered[m]) / 2", "output": "0"}
{"task": "search", "input": "search code:\nTo evaluate the solution, use solution()\n\nChoices:\n0: def slow_solution(max_power: int = 9) -> int:     result = 0     for length in range(1, max_power + 1):         result += slow_reversible_numbers(length, 0, [0] * length, length)     return result\n1: def not_32(i: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")      i_str = format(i, \"032b\")     new_str = \"\"     for c in i_str:         new_str += \"1\" if c == \"0\" else \"0\"     return int(new_str, 2)\n2: def random_vector(n: int, a: int, b: int) -> Vector:     random.seed(None)     ans = [random.randint(a, b) for _ in range(n)]     return Vector(ans)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef equilibrium_index(arr: list[int]) -> int:\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i, value in enumerate(arr):\n        total_sum -= value\n        if left_sum == total_sum:\n            return i\n        left_sum += value\n\n    return -1", "output": "Find the equilibrium index of an array."}
{"task": "detection", "input": "classify code:\ndef is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    A Pangram String contains all the alphabets at least once.\n    >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram(\"My name is Unknown\")\n    False\n    >>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram()\n    True\n    \"\"\"\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef median_of_five(arr: list) -> int:\n    \"\"\"\n    Return the median of the input list\n    :param arr: Array to find median of\n    :return: median of arr\n\n    >>> median_of_five([2, 4, 5, 7, 899])\n    5\n    >>> median_of_five([5, 7, 899, 54, 32])\n    32\n    >>> median_of_five([5, 4, 3, 2])\n    4\n    >>> median_of_five([3, 5, 7, 10, 2])\n    5\n    \"\"\"\n    arr = sorted(arr)\n    return arr[len(arr) // 2]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef flatten(root: TreeNode | None) -> None:\n    if not root:\n        return\n\n    # Flatten the left subtree\n    flatten(root.left)\n\n    # Save the right subtree\n    right_subtree = root.right\n\n    # Make the left subtree the new right subtree\n    root.right = root.left\n    root.left = None\n\n    # Find the end of the new right subtree\n    current = root\n    while current.right:\n        current = current.right\n\n    # Append the original right subtree to the end\n    current.right = right_subtree\n\n    # Flatten the updated right subtree\n    flatten(right_subtree)", "output": "Flatten a binary tree into a linked list in-place, where the linked list is"}
{"task": "search", "input": "search code:\nFunction to change contrast\n\nChoices:\n0: def is_valid(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> bool:     for i in range(len(word)):         if vertical:             if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":                 return False         elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":             return False     return True\n1: def change_contrast(img: Image, level: int) -> Image:     factor = (259 * (level + 255)) / (255 * (259 - level))      def contrast(c: int) -> int:         return int(128 + factor * (c - 128))      return img.point(contrast)\n2: def solution(num: int = 100) -> int:     nfact = factorial(num)     result = split_and_add(nfact)     return result", "output": "1"}
{"task": "search", "input": "search code:\nA A Br\n\nChoices:\n0: def first_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )\n1: def triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:     for triplet in permutations(arr, 3):         if sum(triplet) == target:             return tuple(sorted(triplet))     return (0, 0, 0)\n2: def lr_rotation(node: MyNode) -> MyNode:     left_child = node.get_left()     assert left_child is not None     node.set_left(left_rotation(left_child))     return right_rotation(node)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef kth_permutation(k, n):\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation", "output": "Finds k'th lexicographic permutation (in increasing order) of"}
{"task": "search", "input": "search code:\nThe opposite of :func:`is_scalar`. Returns ``True`` if an object\n\nChoices:\n0: def is_collection(obj):     return is_iterable(obj) and not isinstance(obj, (str, bytes))\n1: def md_prefix(indent: int) -> str:     return f\"{indent * '  '}*\" if indent else \"\\n##\"\n2: def grid_values(grid):     chars = [c for c in grid if c in digits or c in \"0.\"]     assert len(chars) == 81     return dict(zip(squares, chars))", "output": "0"}
{"task": "search", "input": "search code:\nConversion between length units.\n\nChoices:\n0: def factorial(number: int) -> int:     if number != int(number):         raise ValueError(\"factorial() only accepts integral values\")     if number < 0:         raise ValueError(\"factorial() not defined for negative values\")     value = 1     for i in range(1, number + 1):         value *= i     return value\n1: def _batched(iterable, n, *, strict=False):  # pragma: no cover     if n < 1:         raise ValueError('n must be at least one')     iterator = iter(iterable)     while batch := tuple(islice(iterator, n)):         if strict and len(batch) != n:             raise ValueError('batched(): incomplete batch')         yield batch\n2: def length_conversion(value: float, from_type: str, to_type: str) -> float:     new_from = from_type.lower().rstrip(\"s\")     new_from = TYPE_CONVERSION.get(new_from, new_from)     new_to = to_type.lower().rstrip(\"s\")     new_to = TYPE_CONVERSION.get(new_to, new_to)     if new_from not in METRIC_CONVERSION:         msg = (             f\"Invalid 'from_type' value: {from_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     if new_to not in METRIC_CONVERSION:         msg = (             f\"Invalid 'to_type' value: {to_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     return (         value         * METRIC_CONVERSION[new_from].from_factor         * METRIC_CONVERSION[new_to].to_factor     )", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef center_of_mass(particles: list[Particle]) -> Coord3D:\n    if not particles:\n        raise ValueError(\"No particles provided\")\n\n    if any(particle.mass <= 0 for particle in particles):\n        raise ValueError(\"Mass of all particles must be greater than 0\")\n\n    total_mass = sum(particle.mass for particle in particles)\n\n    center_of_mass_x = round(\n        sum(particle.x * particle.mass for particle in particles) / total_mass, 2\n    )\n    center_of_mass_y = round(\n        sum(particle.y * particle.mass for particle in particles) / total_mass, 2\n    )\n    center_of_mass_z = round(\n        sum(particle.z * particle.mass for particle in particles) / total_mass, 2\n    )\n    return Coord3D(center_of_mass_x, center_of_mass_y, center_of_mass_z)", "output": "Input Parameters"}
{"task": "search", "input": "search code:\nThis function can calculate any one of the three (voltage, current, power),\n\nChoices:\n0: def electric_power(voltage: float, current: float, power: float) -> tuple:     if (voltage, current, power).count(0) != 1:         raise ValueError(\"Exactly one argument must be 0\")     elif power < 0:         raise ValueError(             \"Power cannot be negative in any electrical/electronics system\"         )     elif voltage == 0:         return Result(\"voltage\", power / current)     elif current == 0:         return Result(\"current\", power / voltage)     elif power == 0:         return Result(\"power\", float(round(abs(voltage * current), 2)))     else:         raise AssertionError\n1: def main() -> None:     lower = int(input(\"Enter lower value : \").strip())     higher = int(input(\"Enter high value : \").strip())     guess = int(input(\"Enter value to guess : \").strip())     guess_the_number(lower, higher, guess)\n2: def open_knight_tour(n: int) -> list[list[int]]:      board = [[0 for i in range(n)] for j in range(n)]      for i in range(n):         for j in range(n):             board[i][j] = 1             if open_knight_tour_helper(board, (i, j), 1):                 return board             board[i][j] = 0      msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"     raise ValueError(msg)", "output": "0"}
{"task": "search", "input": "search code:\nCalculates the squarefree numbers inside unique_coefficients.\n\nChoices:\n0: def get_squarefrees(unique_coefficients: set[int]) -> set[int]:      non_squarefrees = set()     for number in unique_coefficients:         divisor = 2         copy_number = number         while divisor**2 <= copy_number:             multiplicity = 0             while copy_number % divisor == 0:                 copy_number //= divisor                 multiplicity += 1             if multiplicity >= 2:                 non_squarefrees.add(number)                 break             divisor += 1      return unique_coefficients.difference(non_squarefrees)\n1: def solution(limit: float = 1e10) -> int:     primes = sieve()      n = 1     while True:         prime = next(primes)         if (2 * prime * n) > limit:             return n         # Ignore the next prime as the reminder will be 2.         next(primes)         n += 2\n2: def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:     right = right or len(list_data) - 1     if left > right:         return -1     elif list_data[left] == key:         return left     elif list_data[right] == key:         return right     else:         return search(list_data, key, left + 1, right - 1)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef _msd_radix_sort(list_of_ints: List[int], bit_position: int) -> List[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = list()\n    ones = list()\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:\n    \"\"\"\n    Shifts all columns leftward when an entire column becomes empty.\n\n    >>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2)\n    [['A', '-'], ['-', '-'], ['-', 'C']]\n    \"\"\"\n\n    empty_columns = []\n\n    for column in range(size - 1, -1, -1):\n        if all(matrix_g[row][column] == \"-\" for row in range(size)):\n            empty_columns.append(column)\n\n    for column in empty_columns:\n        for col in range(column + 1, size):\n            for row in range(size):\n                matrix_g[row][col - 1] = matrix_g[row][col]\n        for row in range(size):\n            matrix_g[row][-1] = \"-\"\n\n    return matrix_g", "output": "BUGGY"}
{"task": "search", "input": "search code:\nMark two strings as pluralized translations without translating them.\n\nChoices:\n0: def int_ranges_from_int_list(range_string, delim=',', range_delim='-'):     int_tuples = []     # Normalize the range string to our internal format for processing.     range_string = format_int_list(         parse_int_list(range_string, delim, range_delim))     if range_string:         for bounds in range_string.split(','):             if '-' in bounds:                 start, end = bounds.split('-')             else:                 start, end = bounds, bounds             int_tuples.append((int(start), int(end)))     return tuple(int_tuples)\n1: def _ngettext_noop(singular, plural):     return (singular, plural)\n2: def solution():     file_path = os.path.join(os.path.dirname(__file__), \"num.txt\")     with open(file_path) as file_hand:         return str(sum(int(line) for line in file_hand))[:10]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef increment_score(count: int) -> int:\n    return int(count * (count + 1) / 2)", "output": "Calculates the score for a move based on the number of elements removed."}
{"task": "detection", "input": "classify code:\ndef bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1", "output": "CORRECT"}
{"task": "search", "input": "search code:\n1. We use bitwise AND operations to separate the even bits (0, 2, 4, 6, etc.) and\n\nChoices:\n0: def swap_odd_even_bits(num: int) -> int:     # Get all even bits - 0xAAAAAAAA is a 32-bit number with all even bits set to 1     even_bits = num & 0xAAAAAAAA      # Get all odd bits - 0x55555555 is a 32-bit number with all odd bits set to 1     odd_bits = num & 0x55555555      # Right shift even bits and left shift odd bits and swap them     return even_bits >> 1 | odd_bits << 1\n1: def solution(a: int = 100, b: int = 100) -> int:      # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of     # BASE raised to the POWER     return max(         sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)     )\n2: def linear_regression_prediction(     train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list ) -> float:     x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])     y = np.array(train_usr)     beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)     return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])", "output": "0"}
{"task": "search", "input": "search code:\nPure implementation of the gnome sort algorithm in Python\n\nChoices:\n0: def gnome_sort(lst: list) -> list:     if len(lst) <= 1:         return lst      i = 1      while i < len(lst):         if lst[i - 1] <= lst[i]:             i += 1         else:             lst[i - 1], lst[i] = lst[i], lst[i - 1]             i -= 1             if i == 0:                 i = 1      return lst\n1: def kth_number(lst: list[int], k: int) -> int:     # pick a pivot and separate into list based on pivot.     pivot = random_pivot(lst)      # partition based on pivot     # linear time     small = [e for e in lst if e < pivot]     big = [e for e in lst if e > pivot]      # if we get lucky, pivot might be the element we want.     # we can easily see this:     # small (elements smaller than k)     # + pivot (kth element)     # + big (elements larger than k)     if len(small) == k - 1:         return pivot     # pivot is in elements bigger than k     elif len(small) < k - 1:         return kth_number(big, k - len(small) - 1)     # pivot is in elements smaller than k     else:         return kth_number(small, k)\n2: def perfect(number: int) -> bool:     if not isinstance(number, int):         raise ValueError(\"number must be an integer\")     if number <= 0:         return False     return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number", "output": "0"}
{"task": "search", "input": "search code:\nReturns for given minimum block length the least value of n\n\nChoices:\n0: def longest_subsequence(array: list[int]) -> list[int]:     n = len(array)     # The longest increasing subsequence ending at array[i]     longest_increasing_subsequence = []     for i in range(n):         longest_increasing_subsequence.append([array[i]])      for i in range(1, n):         for prev in range(i):             # If array[prev] is less than or equal to array[i], then             # longest_increasing_subsequence[prev] + array[i]             # is a valid increasing subsequence              # longest_increasing_subsequence[i] is only set to             # longest_increasing_subsequence[prev] + array[i] if the length is longer.              if array[prev] <= array[i] and len(                 longest_increasing_subsequence[prev]             ) + 1 > len(longest_increasing_subsequence[i]):                 longest_increasing_subsequence[i] = copy.copy(                     longest_increasing_subsequence[prev]                 )                 longest_increasing_subsequence[i].append(array[i])      result: list[int] = []     for i in range(n):         if len(longest_increasing_subsequence[i]) > len(result):             result = longest_increasing_subsequence[i]      return result\n1: def solution(min_block_length: int = 50) -> int:      fill_count_functions = [1] * min_block_length      for n in count(min_block_length):         fill_count_functions.append(1)          for block_length in range(min_block_length, n + 1):             for block_start in range(n - block_length):                 fill_count_functions[n] += fill_count_functions[                     n - block_start - block_length - 1                 ]              fill_count_functions[n] += 1          if fill_count_functions[n] > 1_000_000:             break      return n\n2: def get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:      return len_board * len_board_column * row + column", "output": "1"}
{"task": "search", "input": "search code:\nMemoize upf() length results for a given value.\n\nChoices:\n0: def upf_len(num: int) -> int:     return len(unique_prime_factors(num))\n1: def compress(source_path: str, destination_path: str) -> None:     data_bits = read_file_binary(source_path)     compressed = compress_data(data_bits)     compressed = add_file_length(source_path, compressed)     write_file_binary(destination_path, compressed)\n2: def permute_backtrack(nums: list[int]) -> list[list[int]]:      def backtrack(start: int) -> None:         if start == len(nums) - 1:             output.append(nums[:])         else:             for i in range(start, len(nums)):                 nums[start], nums[i] = nums[i], nums[start]                 backtrack(start + 1)                 nums[start], nums[i] = nums[i], nums[start]  # backtrack      output: list[list[int]] = []     backtrack(0)     return output", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef wraps(func, injected=None, expected=None, **kw):\n    return partial(update_wrapper, func=func, build_from=None,\n                   injected=injected, expected=expected, **kw)", "output": "Decorator factory to apply update_wrapper() to a wrapper function."}
{"task": "search", "input": "search code:\nCalculate NAND of the input values\n\nChoices:\n0: def extended_gcd(a: int, b: int) -> tuple[int, int, int]:     assert a >= 0     assert b >= 0      if b == 0:         d, x, y = a, 1, 0     else:         (d, p, q) = extended_gcd(b, a % b)         x = q         y = p - q * (a // b)      assert a % d == 0     assert b % d == 0     assert d == a * x + b * y      return (d, x, y)\n1: def nand_gate(input_1: int, input_2: int) -> int:     return int(not (input_1 and input_2))\n2: def filter_common_word(possibles: list[str], common_word: str) -> list[str]:     return [possible for possible in possibles if common_word in possible.lower()]", "output": "1"}
{"task": "detection", "input": "classify code:\ndef alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef method_2(boundary: list[int], steps: int) -> float:\n    # \"Simpson Rule\"\n    # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)\n    if steps <= 0:\n        raise ZeroDivisionError(\"Number of steps must be greater than zero\")\n\n    h = (boundary[1] - boundary[0]) / steps\n    a = boundary[0]\n    b = boundary[1]\n    x_i = make_points(a, b, h)\n    y = 0.0\n    y += (h / 3.0) * f(a)\n    cnt = 2\n    for i in x_i:\n        y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)\n        cnt += 1\n    y += (h / 3.0) * f(b)\n    return y", "output": "Calculate the definite integral of a function using Simpson's Rule."}
{"task": "search", "input": "search code:\nSome examples\n\nChoices:\n0: def gray_code_sequence_string(bit_count: int) -> list:      # The approach is a recursive one     # Base case achieved when either n = 0 or n=1     if bit_count == 0:         return [\"0\"]      if bit_count == 1:         return [\"0\", \"1\"]      seq_len = 1 << bit_count  # defines the length of the sequence     # 1<< n is equivalent to 2^n      # recursive answer will generate answer for n-1 bits     smaller_sequence = gray_code_sequence_string(bit_count - 1)      sequence = []      # append 0 to first half of the smaller sequence generated     for i in range(seq_len // 2):         generated_no = \"0\" + smaller_sequence[i]         sequence.append(generated_no)      # append 1 to second half ... start from the end of the list     for i in reversed(range(seq_len // 2)):         generated_no = \"1\" + smaller_sequence[i]         sequence.append(generated_no)      return sequence\n1: def msd_radix_sort_inplace(list_of_ints: list[int]):      length = len(list_of_ints)     if not list_of_ints or length == 1:         return      if min(list_of_ints) < 0:         raise ValueError(\"All numbers must be positive\")      most_bits = max(len(bin(x)[2:]) for x in list_of_ints)     _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)\n2: def longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive     array_length = len(array)     # If the array contains only one element, we return it (it's the stop condition of     # recursion)     if array_length <= 1:         return array         # Else     pivot = array[0]     is_found = False     i = 1     longest_subseq: list[int] = []     while not is_found and i < array_length:         if array[i] < pivot:             is_found = True             temp_array = array[i:]             temp_array = longest_subsequence(temp_array)             if len(temp_array) > len(longest_subseq):                 longest_subseq = temp_array         else:             i += 1      temp_array = [element for element in array[1:] if element >= pivot]     temp_array = [pivot, *longest_subsequence(temp_array)]     if len(temp_array) > len(longest_subseq):         return temp_array     else:         return longest_subseq", "output": "2"}
{"task": "search", "input": "search code:\nSlice and combine two strings at a random point.\n\nChoices:\n0: def crossover(parent_1: str, parent_2: str) -> tuple[str, str]:     random_slice = random.randint(0, len(parent_1) - 1)     child_1 = parent_1[:random_slice] + parent_2[random_slice:]     child_2 = parent_2[:random_slice] + parent_1[random_slice:]     return (child_1, child_2)\n1: def armstrong_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False      # Initialization of sum and number of digits.     total = 0     number_of_digits = 0     temp = n     # Calculation of digits of the number     number_of_digits = len(str(n))     # Dividing number into separate digits and find Armstrong number     temp = n     while temp > 0:         rem = temp % 10         total += rem**number_of_digits         temp //= 10     return n == total\n2: def comb_sort(data: list) -> list:     shrink_factor = 1.3     gap = len(data)     completed = False      while not completed:         # Update the gap value for a next comb         gap = int(gap / shrink_factor)         if gap <= 1:             completed = True          index = 0         while index + gap < len(data):             if data[index] > data[index + gap]:                 # Swap values                 data[index], data[index + gap] = data[index + gap], data[index]                 completed = False             index += 1      return data", "output": "0"}
{"task": "detection", "input": "classify code:\ndef largest_divisible_subset(items: list[int]) -> list[int]:\n    \"\"\"\n    Algorithm to find the biggest subset in the given array such that for any 2 elements\n    x and y in the subset, either x divides y or y divides x.\n    >>> largest_divisible_subset([1, 16, 7, 8, 4])\n    [16, 8, 4, 1]\n    >>> largest_divisible_subset([1, 2, 3])\n    [2, 1]\n    >>> largest_divisible_subset([-1, -2, -3])\n    [-3]\n    >>> largest_divisible_subset([1, 2, 4, 8])\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset((1, 2, 4, 8))\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset([1, 1, 1])\n    [1, 1, 1]\n    >>> largest_divisible_subset([0, 0, 0])\n    [0, 0, 0]\n    >>> largest_divisible_subset([-1, -1, -1])\n    [-1, -1, -1]\n    >>> largest_divisible_subset([])\n    []\n    \"\"\"\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result", "output": "BUGGY"}
{"task": "search", "input": "search code:\nImplements the Softplus activation function.\n\nChoices:\n0: def softplus(vector: np.ndarray) -> np.ndarray:     return np.log(1 + np.exp(vector))\n1: def mps_speed_of_molecule(temperature: float, molar_mass: float) -> float:      if temperature < 0:         raise Exception(\"Absolute temperature cannot be less than 0 K\")     if molar_mass <= 0:         raise Exception(\"Molar mass should be greater than 0 kg/mol\")     return (2 * R * temperature / molar_mass) ** 0.5\n2: def surface_area_cube(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"surface_area_cube() only accepts non-negative values\")     return 6 * side_length**2", "output": "0"}
{"task": "search", "input": "search code:\nConvert a frequency in Hertz to the mel scale.\n\nChoices:\n0: def freq_to_mel(freq: float) -> float:     # Use the formula to convert frequency to the mel scale     return 2595.0 * np.log10(1.0 + freq / 700.0)\n1: def permute_backtrack(nums: list[int]) -> list[list[int]]:      def backtrack(start: int) -> None:         if start == len(nums) - 1:             output.append(nums[:])         else:             for i in range(start, len(nums)):                 nums[start], nums[i] = nums[i], nums[start]                 backtrack(start + 1)                 nums[start], nums[i] = nums[i], nums[start]  # backtrack      output: list[list[int]] = []     backtrack(0)     return output\n2: def split(string: str, separator: str = \" \") -> list:      split_words = []      last_index = 0     for index, char in enumerate(string):         if char == separator:             split_words.append(string[last_index:index])             last_index = index + 1         if index + 1 == len(string):             split_words.append(string[last_index : index + 1])     return split_words", "output": "0"}
{"task": "search", "input": "search code:\nChecks whether it is possible to add next into path by validating 2 statements\n\nChoices:\n0: def f(x: float) -> float:     return math.pow(x, 3) - (2 * x) - 5\n1: def find_isolated_nodes(graph):     isolated = []     for node in graph:         if not graph[node]:             isolated.append(node)     return isolated\n2: def valid_connection(     graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int] ) -> bool:      # 1. Validate that path exists between current and next vertices     if graph[path[curr_ind - 1]][next_ver] == 0:         return False      # 2. Validate that next vertex is not already in path     return not any(vertex == next_ver for vertex in path)", "output": "2"}
{"task": "search", "input": "search code:\nSaves the image of anime character\n\nChoices:\n0: def match_word_pattern(pattern: str, input_string: str) -> bool:      def backtrack(pattern_index: int, str_index: int) -> bool:         if pattern_index == len(pattern) and str_index == len(input_string):             return True         if pattern_index == len(pattern) or str_index == len(input_string):             return False         char = pattern[pattern_index]         if char in pattern_map:             mapped_str = pattern_map[char]             if input_string.startswith(mapped_str, str_index):                 return backtrack(pattern_index + 1, str_index + len(mapped_str))             else:                 return False         for end in range(str_index + 1, len(input_string) + 1):             substr = input_string[str_index:end]             if substr in str_map:                 continue             pattern_map[char] = substr             str_map[substr] = char             if backtrack(pattern_index + 1, end):                 return True             del pattern_map[char]             del str_map[substr]         return False      pattern_map: dict[str, str] = {}     str_map: dict[str, str] = {}     return backtrack(0, 0)\n1: def save_image(image_url: str, image_title: str) -> None:     image = httpx.get(image_url, headers=headers, timeout=10)     with open(image_title, \"wb\") as file:         file.write(image.content)\n2: def standardization(data: list, ndigits: int = 3) -> list:     # variables for calculation     mu = mean(data)     sigma = stdev(data)     # standardize data     return [round((x - mu) / (sigma), ndigits) for x in data]", "output": "1"}
{"task": "search", "input": "search code:\nSorts a list using the merge sort algorithm.\n\nChoices:\n0: def power_of_4(number: int) -> bool:     if not isinstance(number, int):         raise TypeError(\"number must be an integer\")     if number <= 0:         raise ValueError(\"number must be positive\")     if number & (number - 1) == 0:         c = 0         while number:             c += 1             number >>= 1         return c % 2 == 1     else:         return False\n1: def merge_sort(collection: list) -> list:      def merge(left: list, right: list) -> list:         result = []         while left and right:             result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))         result.extend(left)         result.extend(right)         return result      if len(collection) <= 1:         return collection     mid_index = len(collection) // 2     return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))\n2: def get_set_bits_count_using_modulo_operator(number: int) -> int:     if number < 0:         raise ValueError(\"the value of input must not be negative\")     result = 0     while number:         if number % 2 == 1:             result += 1         number >>= 1     return result", "output": "1"}
{"task": "search", "input": "search code:\nReturn the parent of x\n\nChoices:\n0: def accuracy(actual_y: list, predicted_y: list) -> float:     # iterate over one element of each list at a time (zip mode)     # prediction is correct if actual Y value equals to predicted Y value     correct = sum(1 for i, j in zip(actual_y, predicted_y) if i == j)     # percentage of accuracy equals to number of correct predictions divided by number     # of all data and multiplied by 100     return (correct / len(actual_y)) * 100\n1: def find_set(x: Node) -> Node:     if x != x.parent:         x.parent = find_set(x.parent)     return x.parent\n2: def second_effusion_rate(     effusion_rate: float, molar_mass_1: float, molar_mass_2: float ) -> float | ValueError:     return (         round(effusion_rate / sqrt(molar_mass_2 / molar_mass_1), 6)         if validate(effusion_rate, molar_mass_1, molar_mass_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef z_function(input_str: str) -> list[int]:\n    z_result = [0 for i in range(len(input_str))]\n\n    # initialize interval's left pointer and right pointer\n    left_pointer, right_pointer = 0, 0\n\n    for i in range(1, len(input_str)):\n        # case when current index is inside the interval\n        if i <= right_pointer:\n            min_edge = min(right_pointer - i + 1, z_result[i - left_pointer])\n            z_result[i] = min_edge\n\n        while go_next(i, z_result, input_str):\n            z_result[i] += 1\n\n        # if new index's result gives us more right interval,\n        # we've to update left_pointer and right_pointer\n        if i + z_result[i] - 1 > right_pointer:\n            left_pointer, right_pointer = i, i + z_result[i] - 1\n\n    return z_result", "output": "For the given string this function computes value for each index,"}
{"task": "repair", "input": "fix bug:\ndef search(target: int, prime_list: list) -> bool:\n    \"\"\"\n    function to search a number in a list using Binary Search.\n    >>> search(3, [1, 2, 3])\n    True\n    >>> search(4, [1, 2, 3])\n    False\n    >>> search(101, list(range(-100, 100)))\n    False\n    \"\"\"\n\n    left, right = 0, len(prime_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if prime_list[middle] == target:\n            return True\n        elif prime_list[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return False", "output": "def search(target: int, prime_list: list) -> bool:\n    \"\"\"\n    function to search a number in a list using Binary Search.\n    >>> search(3, [1, 2, 3])\n    True\n    >>> search(4, [1, 2, 3])\n    False\n    >>> search(101, list(range(-100, 100)))\n    False\n    \"\"\"\n\n    left, right = 0, len(prime_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if prime_list[middle] == target:\n            return True\n        elif prime_list[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return False"}
{"task": "search", "input": "search code:\nCommands:\n\nChoices:\n0: def interact_treap(root: Node | None, args: str) -> Node | None:     for arg in args.split():         if arg[0] == \"+\":             root = insert(root, int(arg[1:]))          elif arg[0] == \"-\":             root = erase(root, int(arg[1:]))          else:             print(\"Unknown command\")      return root\n1: def stooge_sort(arr: list[int]) -> list[int]:     stooge(arr, 0, len(arr) - 1)     return arr\n2: def decode(coded: str) -> str:     if set(coded) - {\"A\", \"B\", \" \"} != set():         raise Exception(\"decode() accepts only 'A', 'B' and spaces\")     decoded = \"\"     for word in coded.split():         while len(word) != 0:             decoded += decode_dict[word[:5]]             word = word[5:]         decoded += \" \"     return decoded.strip()", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef logical_left_shift(number: int, shift_amount: int) -> str:\n    if number < 0 or shift_amount < 0:\n        raise ValueError(\"both inputs must be positive integers\")\n\n    binary_number = str(bin(number))\n    binary_number += \"0\" * shift_amount\n    return binary_number", "output": "Take in 2 positive integers."}
{"task": "detection", "input": "classify code:\ndef merge(left, right):\n    \"\"\"\n    >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0][0] < right[0][0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef largest_divisible_subset(items: list[int]) -> list[int]:\n    \"\"\"\n    Algorithm to find the biggest subset in the given array such that for any 2 elements\n    x and y in the subset, either x divides y or y divides x.\n    >>> largest_divisible_subset([1, 16, 7, 8, 4])\n    [16, 8, 4, 1]\n    >>> largest_divisible_subset([1, 2, 3])\n    [2, 1]\n    >>> largest_divisible_subset([-1, -2, -3])\n    [-3]\n    >>> largest_divisible_subset([1, 2, 4, 8])\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset((1, 2, 4, 8))\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset([1, 1, 1])\n    [1, 1, 1]\n    >>> largest_divisible_subset([0, 0, 0])\n    [0, 0, 0]\n    >>> largest_divisible_subset([-1, -1, -1])\n    [-1, -1, -1]\n    >>> largest_divisible_subset([])\n    []\n    \"\"\"\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef valid_coloring(\n    neighbours: list[int], colored_vertices: list[int], color: int\n) -> bool:\n    # Does any neighbour not satisfy the constraints\n    return not any(\n        neighbour == 1 and colored_vertices[i] == color\n        for i, neighbour in enumerate(neighbours)\n    )", "output": "For each neighbour check if the coloring constraint is satisfied"}
{"task": "search", "input": "search code:\nDepth-first iterator over scalars in a tensor.\n\nChoices:\n0: def _flatten_tensor(tensor):     \"Depth-first iterator over scalars in a tensor.\"     iterator = iter(tensor)     while True:         try:             value = next(iterator)         except StopIteration:             return iterator         iterator = chain((value,), iterator)         if _is_scalar(value):             return iterator         iterator = chain.from_iterable(iterator)\n1: def perfect(number: int) -> bool:     if not isinstance(number, int):         raise ValueError(\"number must be an integer\")     if number <= 0:         return False     return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number\n2: def breadth_first_search(graph: dict, start: str) -> list[str]:     explored = {start}     result = [start]     queue: Queue = Queue()     queue.put(start)     while not queue.empty():         v = queue.get()         for w in graph[v]:             if w not in explored:                 explored.add(w)                 result.append(w)                 queue.put(w)     return result", "output": "0"}
{"task": "search", "input": "search code:\nPure implementation of generating a dictionary of neighbors and the cost with each\n\nChoices:\n0: def random_matrix(width: int, height: int, a: int, b: int) -> Matrix:     random.seed(None)     matrix: list[list[float]] = [         [random.randint(a, b) for _ in range(width)] for _ in range(height)     ]     return Matrix(matrix, width, height)\n1: def triangle(     vertex1: tuple[float, float],     vertex2: tuple[float, float],     vertex3: tuple[float, float],     depth: int, ) -> None:     my_pen.up()     my_pen.goto(vertex1[0], vertex1[1])     my_pen.down()     my_pen.goto(vertex2[0], vertex2[1])     my_pen.goto(vertex3[0], vertex3[1])     my_pen.goto(vertex1[0], vertex1[1])      if depth == 0:         return      triangle(vertex1, get_mid(vertex1, vertex2), get_mid(vertex1, vertex3), depth - 1)     triangle(vertex2, get_mid(vertex1, vertex2), get_mid(vertex2, vertex3), depth - 1)     triangle(vertex3, get_mid(vertex3, vertex2), get_mid(vertex1, vertex3), depth - 1)\n2: def generate_neighbours(path):      dict_of_neighbours = {}      with open(path) as f:         for line in f:             if line.split()[0] not in dict_of_neighbours:                 _list = []                 _list.append([line.split()[1], line.split()[2]])                 dict_of_neighbours[line.split()[0]] = _list             else:                 dict_of_neighbours[line.split()[0]].append(                     [line.split()[1], line.split()[2]]                 )             if line.split()[1] not in dict_of_neighbours:                 _list = []                 _list.append([line.split()[0], line.split()[2]])                 dict_of_neighbours[line.split()[1]] = _list             else:                 dict_of_neighbours[line.split()[1]].append(                     [line.split()[0], line.split()[2]]                 )      return dict_of_neighbours", "output": "2"}
{"task": "search", "input": "search code:\nChoose a random pivot for the list.\n\nChoices:\n0: def random_pivot(lst):     return choice(lst)\n1: def solution(num_terms: int = 60, max_start: int = 1000000) -> int:     return sum(1 for i in range(1, max_start) if chain_length(i) == num_terms)\n2: def calculate_waitingtime(     arrival_time: list[int], burst_time: list[int], no_of_processes: int ) -> list[int]:     remaining_time = [0] * no_of_processes     waiting_time = [0] * no_of_processes     # Copy the burst time into remaining_time[]     for i in range(no_of_processes):         remaining_time[i] = burst_time[i]      complete = 0     increment_time = 0     minm = 999999999     short = 0     check = False      # Process until all processes are completed     while complete != no_of_processes:         for j in range(no_of_processes):             if (                 arrival_time[j] <= increment_time                 and remaining_time[j] > 0                 and remaining_time[j] < minm             ):                 minm = remaining_time[j]                 short = j                 check = True          if not check:             increment_time += 1             continue         remaining_time[short] -= 1          minm = remaining_time[short]         if minm == 0:             minm = 999999999          if remaining_time[short] == 0:             complete += 1             check = False              # Find finish time of current process             finish_time = increment_time + 1              # Calculate waiting time             finar = finish_time - arrival_time[short]             waiting_time[short] = finar - burst_time[short]              waiting_time[short] = max(waiting_time[short], 0)          # Increment time         increment_time += 1     return waiting_time", "output": "0"}
{"task": "search", "input": "search code:\nUsage examples:\n\nChoices:\n0: def quantum_fourier_transform(number_of_qubits: int = 3) -> qiskit.result.counts.Counts:     if isinstance(number_of_qubits, str):         raise TypeError(\"number of qubits must be a integer.\")     if number_of_qubits <= 0:         raise ValueError(\"number of qubits must be > 0.\")     if math.floor(number_of_qubits) != number_of_qubits:         raise ValueError(\"number of qubits must be exact integer.\")     if number_of_qubits > 10:         raise ValueError(\"number of qubits too large to simulate(>10).\")      qr = QuantumRegister(number_of_qubits, \"qr\")     cr = ClassicalRegister(number_of_qubits, \"cr\")      quantum_circuit = QuantumCircuit(qr, cr)      counter = number_of_qubits      for i in range(counter):         quantum_circuit.h(number_of_qubits - i - 1)         counter -= 1         for j in range(counter):             quantum_circuit.cp(np.pi / 2 ** (counter - j), j, counter)      for k in range(number_of_qubits // 2):         quantum_circuit.swap(k, number_of_qubits - k - 1)      # measure all the qubits     quantum_circuit.measure(qr, cr)     # simulate with 10000 shots     backend = Aer.get_backend(\"qasm_simulator\")     job = execute(quantum_circuit, backend, shots=10000)      return job.result().get_counts(quantum_circuit)\n1: def astable_duty_cycle(resistance_1: float, resistance_2: float) -> float:      if resistance_1 <= 0 or resistance_2 <= 0:         raise ValueError(\"All values must be positive\")     return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100\n2: def is_arithmetic_series(series: list) -> bool:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     if len(series) == 1:         return True     common_diff = series[1] - series[0]     for index in range(len(series) - 1):         if series[index + 1] - series[index] != common_diff:             return False     return True", "output": "1"}
{"task": "search", "input": "search code:\nFunction to compute the covariance matrix inside each class.\n\nChoices:\n0: def covariance_within_classes(     features: np.ndarray, labels: np.ndarray, classes: int ) -> np.ndarray:      covariance_sum = np.nan     for i in range(classes):         data = features[:, labels == i]         data_mean = data.mean(1)         # Centralize the data of class i         centered_data = data - column_reshape(data_mean)         if i > 0:             # If covariance_sum is not None             covariance_sum += np.dot(centered_data, centered_data.T)         else:             # If covariance_sum is np.nan (i.e. first loop)             covariance_sum = np.dot(centered_data, centered_data.T)      return covariance_sum / features.shape[1]\n1: def is_collection(obj):     return is_iterable(obj) and not isinstance(obj, (str, bytes))\n2: def abs_val(num: float) -> float:     return -num if num < 0 else num", "output": "0"}
{"task": "search", "input": "search code:\nCalculate the distance between the two endpoints of two vectors.\n\nChoices:\n0: def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:     return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))\n1: def find_median(nums: list[int | float]) -> float:     div, mod = divmod(len(nums), 2)     if mod:         return nums[div]     return (nums[div] + nums[(div) - 1]) / 2\n2: def solution(first_x_coord: float = 1.4, first_y_coord: float = -9.6) -> int:     num_reflections: int = 0     point_x: float = first_x_coord     point_y: float = first_y_coord     gradient: float = (10.1 - point_y) / (0.0 - point_x)      while not (-0.01 <= point_x <= 0.01 and point_y > 0):         point_x, point_y, gradient = next_point(point_x, point_y, gradient)         num_reflections += 1      return num_reflections", "output": "0"}
{"task": "search", "input": "search code:\nFunction returns the left side view of binary tree.\n\nChoices:\n0: def prepend(value, iterator):     return chain([value], iterator)\n1: def binary_tree_left_side_view(root: TreeNode) -> list[int]:      def depth_first_search(         root: TreeNode | None, depth: int, left_view: list[int]     ) -> None:         if not root:             return          if depth == len(left_view):             left_view.append(root.val)          depth_first_search(root.left, depth + 1, left_view)         depth_first_search(root.right, depth + 1, left_view)      left_view: list = []     if not root:         return left_view      depth_first_search(root, 0, left_view)     return left_view\n2: def find_unit_clauses(     clauses: list[Clause],     model: dict[str, bool | None],  # noqa: ARG001 ) -> tuple[list[str], dict[str, bool | None]]:     unit_symbols = []     for clause in clauses:         if len(clause) == 1:             unit_symbols.append(next(iter(clause.literals.keys())))         else:             f_count, n_count = 0, 0             for literal, value in clause.literals.items():                 if value is False:                     f_count += 1                 elif value is None:                     sym = literal                     n_count += 1             if f_count == len(clause) - 1 and n_count == 1:                 unit_symbols.append(sym)     assignment: dict[str, bool | None] = {}     for i in unit_symbols:         symbol = i[:2]         assignment[symbol] = len(i) == 2     unit_symbols = [i[:2] for i in unit_symbols]      return unit_symbols, assignment", "output": "1"}
{"task": "search", "input": "search code:\nCalculate the power of a base raised to an exponent.\n\nChoices:\n0: def flatten(root: TreeNode | None) -> None:     if not root:         return      # Flatten the left subtree     flatten(root.left)      # Save the right subtree     right_subtree = root.right      # Make the left subtree the new right subtree     root.right = root.left     root.left = None      # Find the end of the new right subtree     current = root     while current.right:         current = current.right      # Append the original right subtree to the end     current.right = right_subtree      # Flatten the updated right subtree     flatten(right_subtree)\n1: def capture_area(capture_radius: float) -> float:      if capture_radius < 0:         raise ValueError(\"Cannot have a capture radius less than 0\")     sigma = pi * pow(capture_radius, 2)     return round(sigma, 0)\n2: def power(base: int, exponent: int) -> float:     return base * power(base, (exponent - 1)) if exponent else 1", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef binary_exp_mod_recursive(base: float, exponent: int, modulus: int) -> float:\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer\")\n\n    if exponent == 0:\n        return 1\n\n    if exponent % 2 == 1:\n        return (binary_exp_mod_recursive(base, exponent - 1, modulus) * base) % modulus\n\n    r = binary_exp_mod_recursive(base, exponent // 2, modulus)\n    return (r * r) % modulus", "output": "Computes a^b % c recursively, where a is the base, b is the exponent, and c is the"}
{"task": "repair", "input": "fix bug:\ndef lomuto_partition(sorting: list, left: int, right: int) -> int:\n    \"\"\"\n    Example:\n    >>> lomuto_partition([1,5,7,6], 0, 3)\n    2\n    \"\"\"\n    pivot = sorting[right]\n    store_index = left\n    for i in range(left, right):\n        if sorting[i] < pivot:\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\n            store_index += 1\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\n    return store_index", "output": "def lomuto_partition(sorting: list, left: int, right: int) -> int:\n    \"\"\"\n    Example:\n    >>> lomuto_partition([1,5,7,6], 0, 3)\n    2\n    \"\"\"\n    pivot = sorting[right]\n    store_index = left\n    for i in range(left, right):\n        if sorting[i] < pivot:\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\n            store_index += 1\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\n    return store_index"}
{"task": "summary", "input": "summarize code:\ndef is_even(number: int) -> bool:\n    return number & 1 == 0", "output": "return true if the input integer is even"}
{"task": "summary", "input": "summarize code:\ndef is_palindrome(n: int) -> bool:\n    return str(n) == str(n)[::-1]", "output": "Returns True if a number is palindrome."}
{"task": "repair", "input": "fix bug:\ndef calculate_probabilities(instance_count: int, total_count: int) -> float:\n    \"\"\"\n    Calculate the probability that a given instance will belong to which class\n    :param instance_count: number of instances in class\n    :param total_count: the number of all instances\n    :return: value of probability for considered class\n\n    >>> calculate_probabilities(20, 60)\n    0.3333333333333333\n    >>> calculate_probabilities(30, 100)\n    0.3\n    \"\"\"\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count", "output": "def calculate_probabilities(instance_count: int, total_count: int) -> float:\n    \"\"\"\n    Calculate the probability that a given instance will belong to which class\n    :param instance_count: number of instances in class\n    :param total_count: the number of all instances\n    :return: value of probability for considered class\n\n    >>> calculate_probabilities(20, 60)\n    0.3333333333333333\n    >>> calculate_probabilities(30, 100)\n    0.3\n    \"\"\"\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count"}
{"task": "summary", "input": "summarize code:\ndef evaluate(expression):\n    stack = []\n\n    # iterate over the string in reverse order\n    for c in expression.split()[::-1]:\n        # push operand to stack\n        if is_operand(c):\n            stack.append(int(c))\n\n        else:\n            # pop values from stack can calculate the result\n            # push the result onto the stack again\n            o1 = stack.pop()\n            o2 = stack.pop()\n            stack.append(operators[c](o1, o2))\n\n    return stack.pop()", "output": "Evaluate a given expression in prefix notation."}
{"task": "summary", "input": "summarize code:\ndef narcissistic_number(n: int) -> bool:\n    if not isinstance(n, int) or n < 1:\n        return False\n    expo = len(str(n))  # the power that all digits will be raised to\n    # check if sum of each digit multiplied expo times is equal to number\n    return n == sum(int(i) ** expo for i in str(n))", "output": "Return True if n is a narcissistic number or False if it is not."}
{"task": "summary", "input": "summarize code:\ndef solution(limit=28123):\n    sum_divs = [1] * (limit + 1)\n\n    for i in range(2, int(limit**0.5) + 1):\n        sum_divs[i * i] += i\n        for k in range(i + 1, limit // i + 1):\n            sum_divs[k * i] += k + i\n\n    abundants = set()\n    res = 0\n\n    for n in range(1, limit + 1):\n        if sum_divs[n] > n:\n            abundants.add(n)\n\n        if not any((n - a in abundants) for a in abundants):\n            res += n\n\n    return res", "output": "Finds the sum of all the positive integers which cannot be written as"}
{"task": "repair", "input": "fix bug:\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "def extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)"}
{"task": "search", "input": "search code:\nCalculate the area of a square.\n\nChoices:\n0: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         # print(f\"{call:38} = {func(value)} -- {timing:.4f} seconds\")         print(f\"{call:38} -- {timing:.4f} seconds\")      for value in range(15):  # (1, 7, 14):         for func in (generate_pascal_triangle, generate_pascal_triangle_optimized):             benchmark_a_function(func, value)         print()\n1: def area_square(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"area_square() only accepts non-negative values\")     return side_length**2\n2: def solution(n: int = 15) -> int:     total = 0     for m in range(2, n + 1):         x1 = 2 / (m + 1)         p = 1.0         for i in range(1, m + 1):             xi = i * x1             p *= xi**i         total += int(p)     return total", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef select(\n    parent_1: tuple[str, float],\n    population_score: list[tuple[str, float]],\n    genes: list[str],\n) -> list[str]:\n    pop = []\n    # Generate more children proportionally to the fitness score.\n    child_n = int(parent_1[1] * 100) + 1\n    child_n = 10 if child_n >= 10 else child_n\n    for _ in range(child_n):\n        parent_2 = population_score[random.randint(0, N_SELECTED)][0]\n\n        child_1, child_2 = crossover(parent_1[0], parent_2)\n        # Append new string to the population list.\n        pop.append(mutate(child_1, genes))\n        pop.append(mutate(child_2, genes))\n    return pop", "output": "Select the second parent and generate new population"}
{"task": "search", "input": "search code:\nCreate a grid of complex values of size nb_pixels*nb_pixels with real and\n\nChoices:\n0: def prepare_grid(window_size: float, nb_pixels: int) -> np.ndarray:     x = np.linspace(-window_size, window_size, nb_pixels)     x = x.reshape((nb_pixels, 1))     y = np.linspace(-window_size, window_size, nb_pixels)     y = y.reshape((1, nb_pixels))     return x + 1.0j * y\n1: def _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:     if bit_position == 0 or len(list_of_ints) in [0, 1]:         return list_of_ints      zeros = []     ones = []     # Split numbers based on bit at bit_position from the right     for number in list_of_ints:         if (number >> (bit_position - 1)) & 1:             # number has a one at bit bit_position             ones.append(number)         else:             # number has a zero at bit bit_position             zeros.append(number)      # recursively split both lists further     zeros = _msd_radix_sort(zeros, bit_position - 1)     ones = _msd_radix_sort(ones, bit_position - 1)      # recombine lists     res = zeros     res.extend(ones)      return res\n2: def find_triplets_with_0_sum(nums: list[int]) -> list[list[int]]:     return [         list(x)         for x in sorted({abc for abc in combinations(sorted(nums), 3) if not sum(abc)})     ]", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef is_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)", "output": "def is_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)"}
{"task": "summary", "input": "summarize code:\ndef get_tolerance(color: str) -> float:\n    if color not in tolerance_color_values:\n        msg = f\"{color} is not a valid color for tolerance band\"\n        raise ValueError(msg)\n    return tolerance_color_values[color]", "output": "Function returns the tolerance value associated with the color."}
{"task": "detection", "input": "classify code:\ndef check_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> check_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> check_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> check_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> check_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> check_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFind the equilibrium index of an array.\n\nChoices:\n0: def equilibrium_index(arr: list[int]) -> int:     total_sum = sum(arr)     left_sum = 0      for i, value in enumerate(arr):         total_sum -= value         if left_sum == total_sum:             return i         left_sum += value      return -1\n1: def parse_timedelta(text):     td_kwargs = {}     for match in _PARSE_TD_RE.finditer(text):         value, unit = match.group('value'), match.group('unit')         try:             unit_key = _PARSE_TD_KW_MAP[unit]         except KeyError:             raise ValueError('invalid time unit %r, expected one of %r'                              % (unit, _PARSE_TD_KW_MAP.keys()))         try:             value = float(value)         except ValueError:             raise ValueError('invalid time value for unit %r: %r'                              % (unit, value))         td_kwargs[unit_key] = value     return timedelta(**td_kwargs)\n2: def insert_node(head: Node | None, data: int) -> Node:     new_node = Node(data)     # If the linked list is empty, the new_node becomes the head     if head is None:         return new_node      temp_node = head     while temp_node.next_node:         temp_node = temp_node.next_node      temp_node.next_node = new_node     return head", "output": "0"}
{"task": "detection", "input": "classify code:\ndef validate(*values: float) -> bool:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> validate(2.016, 4.002)\n    True\n    >>> validate(-2.016, 4.002)\n    False\n    >>> validate()\n    False\n    \"\"\"\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    >>> is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same upper column,\n    # left upper diagonal and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))\n        )\n        and all(\n            board[i][j] != 1\n            for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))\n        )\n    )", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\n    \"\"\"\n    Convert molarity to normality.\n      Volume is taken in litres.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n      >>> molarity_to_normality(2, 3.1, 0.31)\n      20\n      >>> molarity_to_normality(4, 11.4, 5.7)\n      8\n    \"\"\"\n    return round(float(moles / volume) * nfactor)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef perfect_cube_binary_search(n: int) -> bool:\n    if not isinstance(n, int):\n        raise TypeError(\"perfect_cube_binary_search() only accepts integers\")\n    if n < 0:\n        n = -n\n    left = 0\n    right = n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid * mid == n:\n            return True\n        elif mid * mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False", "output": "Check if a number is a perfect cube or not using binary search."}
{"task": "repair", "input": "fix bug:\ndef hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]", "output": "def hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]"}
{"task": "search", "input": "search code:\nFlatten an iterable with multiple levels of nesting (e.g., a list of\n\nChoices:\n0: def collapse(iterable, base_type=None, levels=None):     stack = deque()     # Add our first node group, treat the iterable as a single node     stack.appendleft((0, repeat(iterable, 1)))      while stack:         node_group = stack.popleft()         level, nodes = node_group          # Check if beyond max level         if levels is not None and level > levels:             yield from nodes             continue          for node in nodes:             # Check if done iterating             if isinstance(node, (str, bytes)) or (                 (base_type is not None) and isinstance(node, base_type)             ):                 yield node             # Otherwise try to create child nodes             else:                 try:                     tree = iter(node)                 except TypeError:                     yield node                 else:                     # Save our current location                     stack.appendleft(node_group)                     # Append the new child node                     stack.appendleft((level + 1, tree))                     # Break to process child node                     break\n1: def outer_product(func, xs, ys, *args, **kwargs):     ys = tuple(ys)     return batched(         starmap(lambda x, y: func(x, y, *args, **kwargs), product(xs, ys)),         n=len(ys),     )\n2: def binary_tree_count(node_count: int) -> int:     return catalan_number(node_count) * factorial(node_count)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef josephus_iterative(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size iteratively.\n\n    Args:\n        num_people (int): The number of people in the circle.\n        step_size (int): The number of steps to take before eliminating someone.\n\n    Returns:\n        int: The position of the last person standing.\n\n    Examples:\n        >>> josephus_iterative(5, 2)\n        3\n        >>> josephus_iterative(7, 3)\n        4\n    \"\"\"\n    circle = list(range(1, num_people + 1))\n    current = 0\n\n    while len(circle) > 1:\n        current = (current + step_size - 1) % len(circle)\n        circle.pop(current)\n\n    return circle[0]", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations with using bottom up approach,\n    and returns the count of possible combination in O(N^2) Time Complexity\n    as we are using Dynamic programming array here.\n\n    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    dp_array = [0] * (target + 1)\n    dp_array[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - array[j] >= 0:\n                dp_array[i] += dp_array[i - array[j]]\n\n    return dp_array[target]", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef calculate_turnaround_times(\n    duration_times: List[int], waiting_times: List[int]\n) -> List[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef show_frequency_response(filter_type: FilterType, samplerate: int) -> None:\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\n\n    filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.abs(np.fft.fft(outputs))\n    fft_db = 20 * np.log10(fft_out)\n\n    # Frequencies on log scale from 24 to nyquist frequency\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\n\n    # Display within reasonable bounds\n    bounds = get_bounds(fft_db, samplerate)\n    plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))\n    plt.ylabel(\"Gain (dB)\")\n\n    plt.plot(fft_db)\n    plt.show()", "output": "Show frequency response of a filter"}
{"task": "search", "input": "search code:\nReturn the relative distance (= step/max_step) after which the complex number\n\nChoices:\n0: def always_iterable(obj, base_type=(str, bytes)):     if obj is None:         return iter(())      if (base_type is not None) and isinstance(obj, base_type):         return iter((obj,))      try:         return iter(obj)     except TypeError:         return iter((obj,))\n1: def solution(n: int = 4) -> int | None:     results = run(n)     return results[0] if len(results) else None\n2: def get_distance(x: float, y: float, max_step: int) -> float:     a = x     b = y     for step in range(max_step):  # noqa: B007         a_new = a * a - b * b + x         b = 2 * a * b + y         a = a_new          # divergence happens for all complex number with an absolute value         # greater than 4         if a * a + b * b > 4:             break     return step / (max_step - 1)", "output": "2"}
{"task": "search", "input": "search code:\nGet a tuple representing the relative time difference between two\n\nChoices:\n0: def decimal_relative_time(d, other=None, ndigits=0, cardinalize=True):     if other is None:         other = datetime.now(timezone.utc).replace(tzinfo=None)     diff = other - d     diff_seconds = timedelta.total_seconds(diff)     abs_diff = abs(diff)     b_idx = bisect.bisect(_BOUND_DELTAS, abs_diff) - 1     bbound, bunit, bname = _BOUNDS[b_idx]     f_diff = diff_seconds / timedelta.total_seconds(bunit)     rounded_diff = round(f_diff, ndigits)     if cardinalize:         return rounded_diff, _cardinalize_time_unit(bname, abs(rounded_diff))     return rounded_diff, bname\n1: def get_rotation(     img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int ) -> np.ndarray:     matrix = cv2.getAffineTransform(pt1, pt2)     return cv2.warpAffine(img, matrix, (rows, cols))\n2: def equilibrium_index(arr: list[int]) -> int:     total_sum = sum(arr)     left_sum = 0      for i, value in enumerate(arr):         total_sum -= value         if left_sum == total_sum:             return i         left_sum += value      return -1", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))", "output": "def evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))"}
{"task": "search", "input": "search code:\nFunction checks the all possible combinations, and returns the count\n\nChoices:\n0: def transformation_matrix(velocity: float) -> np.ndarray:     return np.array(         [             [gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],             [-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],             [0, 0, 1, 0],             [0, 0, 0, 1],         ]     )\n1: def newton_raphson(     f: RealFunc,     x0: float = 0,     max_iter: int = 100,     step: float = 1e-6,     max_error: float = 1e-6,     log_steps: bool = False, ) -> tuple[float, float, list[float]]:      def f_derivative(x: float) -> float:         return calc_derivative(f, x, step)      a = x0  # Set initial guess     steps = []     for _ in range(max_iter):         if log_steps:  # Log intermediate steps             steps.append(a)          error = abs(f(a))         if error < max_error:             return a, error, steps          if f_derivative(a) == 0:             raise ZeroDivisionError(\"No converging solution found, zero derivative\")         a -= f(a) / f_derivative(a)  # Calculate next estimate     raise ArithmeticError(\"No converging solution found, iteration limit reached\")\n2: def combination_sum_iv_dp_array(array: list[int], target: int) -> int:      def count_of_possible_combinations_with_dp_array(         target: int, dp_array: list[int]     ) -> int:         if target < 0:             return 0         if target == 0:             return 1         if dp_array[target] != -1:             return dp_array[target]         answer = sum(             count_of_possible_combinations_with_dp_array(target - item, dp_array)             for item in array         )         dp_array[target] = answer         return answer      dp_array = [-1] * (target + 1)     return count_of_possible_combinations_with_dp_array(target, dp_array)", "output": "2"}
{"task": "search", "input": "search code:\nthis is a recursive function for get all factors of number\n\nChoices:\n0: def largest_square_area_in_matrix_top_down_approch_with_dp(     rows: int, cols: int, mat: list[list[int]] ) -> int:      def update_area_of_max_square_using_dp_array(         row: int, col: int, dp_array: list[list[int]]     ) -> int:         if row >= rows or col >= cols:             return 0         if dp_array[row][col] != -1:             return dp_array[row][col]          right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)         diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)         down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)          if mat[row][col]:             sub_problem_sol = 1 + min([right, diagonal, down])             largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)             dp_array[row][col] = sub_problem_sol             return sub_problem_sol         else:             return 0      largest_square_area = [0]     dp_array = [[-1] * cols for _ in range(rows)]     update_area_of_max_square_using_dp_array(0, 0, dp_array)      return largest_square_area[0]\n1: def always_reversible(iterable):     try:         return reversed(iterable)     except TypeError:         return reversed(list(iterable))\n2: def get_factors(     number: int, factors: Counter | None = None, factor: int = 2 ) -> Counter:      match number:         case int(number) if number == 1:             return Counter({1: 1})         case int(num) if number > 0:             number = num         case _:             raise TypeError(\"number must be integer and greater than zero\")      factors = factors or Counter()      if number == factor:  # break condition         # all numbers are factors of itself         factors[factor] += 1         return factors      if number % factor > 0:         # if it is greater than zero         # so it is not a factor of number and we check next number         return get_factors(number, factors, factor + 1)      factors[factor] += 1     # else we update factors (that is Counter(dict-like) type) and check again     return get_factors(number // factor, factors, factor)", "output": "2"}
{"task": "search", "input": "search code:\nCalculate real power from apparent power and power factor.\n\nChoices:\n0: def max_height(init_velocity: float, angle: float) -> float:     check_args(init_velocity, angle)     radians = deg_to_rad(angle)     return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)\n1: def real_power(apparent_power: float, power_factor: float) -> float:     if (         not isinstance(power_factor, (int, float))         or power_factor < -1         or power_factor > 1     ):         raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")     return apparent_power * power_factor\n2: def area_under_line_estimator_check(     iterations: int, min_value: float = 0.0, max_value: float = 1.0 ) -> None:      def identity_function(x: float) -> float:         return x      estimated_value = area_under_curve_estimator(         iterations, identity_function, min_value, max_value     )     expected_value = (max_value * max_value - min_value * min_value) / 2      print(\"******************\")     print(f\"Estimating area under y=x where x varies from {min_value} to {max_value}\")     print(f\"Estimated value is {estimated_value}\")     print(f\"Expected value is {expected_value}\")     print(f\"Total error is {abs(estimated_value - expected_value)}\")     print(\"******************\")", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef _gettext(message):\n    return get_translation().gettext(message)", "output": "Get translation."}
{"task": "search", "input": "search code:\nFinds the most cost efficient sequence\n\nChoices:\n0: def bin_to_decimal(bin_string: str) -> int:     bin_string = str(bin_string).strip()     if not bin_string:         raise ValueError(\"Empty string was passed to the function\")     is_negative = bin_string[0] == \"-\"     if is_negative:         bin_string = bin_string[1:]     if not all(char in \"01\" for char in bin_string):         raise ValueError(\"Non-binary value was passed to the function\")     decimal_number = 0     for char in bin_string:         decimal_number = 2 * decimal_number + int(char)     return -decimal_number if is_negative else decimal_number\n1: def pheromone_update(     pheromone: list[list[float]],     cities: dict[int, list[int]],     pheromone_evaporation: float,     ants_route: list[list[int]],     q: float,  # Pheromone system parameters Q, which is a constant     best_path: list[int],     best_distance: float, ) -> tuple[list[list[float]], list[int], float]:     for a in range(len(cities)):  # Update the volatilization of pheromone on all routes         for b in range(len(cities)):             pheromone[a][b] *= pheromone_evaporation     for ant_route in ants_route:         total_distance = 0.0         for i in range(len(ant_route) - 1):  # Calculate total distance             total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])         delta_pheromone = q / total_distance         for i in range(len(ant_route) - 1):  # Update pheromones             pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone             pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][                 ant_route[i + 1]             ]          if total_distance < best_distance:             best_path = ant_route             best_distance = total_distance      return pheromone, best_path, best_distance\n2: def compute_transform_tables(     source_string: str,     destination_string: str,     copy_cost: int,     replace_cost: int,     delete_cost: int,     insert_cost: int, ) -> tuple[list[list[int]], list[list[str]]]:     source_seq = list(source_string)     destination_seq = list(destination_string)     len_source_seq = len(source_seq)     len_destination_seq = len(destination_seq)     costs = [         [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]     ops = [         [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]      for i in range(1, len_source_seq + 1):         costs[i][0] = i * delete_cost         ops[i][0] = f\"D{source_seq[i - 1]}\"      for i in range(1, len_destination_seq + 1):         costs[0][i] = i * insert_cost         ops[0][i] = f\"I{destination_seq[i - 1]}\"      for i in range(1, len_source_seq + 1):         for j in range(1, len_destination_seq + 1):             if source_seq[i - 1] == destination_seq[j - 1]:                 costs[i][j] = costs[i - 1][j - 1] + copy_cost                 ops[i][j] = f\"C{source_seq[i - 1]}\"             else:                 costs[i][j] = costs[i - 1][j - 1] + replace_cost                 ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])              if costs[i - 1][j] + delete_cost < costs[i][j]:                 costs[i][j] = costs[i - 1][j] + delete_cost                 ops[i][j] = f\"D{source_seq[i - 1]}\"              if costs[i][j - 1] + insert_cost < costs[i][j]:                 costs[i][j] = costs[i][j - 1] + insert_cost                 ops[i][j] = f\"I{destination_seq[j - 1]}\"      return costs, ops", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]", "output": "def fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]"}
{"task": "summary", "input": "summarize code:\ndef _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):\n    if max_rev[n] >= 0:\n        return max_rev[n]\n    elif n == 0:\n        return 0\n    else:\n        max_revenue = float(\"-inf\")\n        for i in range(1, n + 1):\n            max_revenue = max(\n                max_revenue,\n                prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),\n            )\n\n        max_rev[n] = max_revenue\n\n    return max_rev[n]", "output": "Constructs a top-down dynamic programming solution for the rod-cutting problem"}
{"task": "summary", "input": "summarize code:\ndef decimal_to_binary_recursive_helper(decimal: int) -> str:\n    decimal = int(decimal)\n    if decimal in (0, 1):  # Exit cases for the recursion\n        return str(decimal)\n    div, mod = divmod(decimal, 2)\n    return decimal_to_binary_recursive_helper(div) + str(mod)", "output": "Take a positive integer value and return its binary equivalent."}
{"task": "summary", "input": "summarize code:\ndef depth_first_search(row: int, col: int, seen: set, mat: list[list[int]]) -> int:\n    rows = len(mat)\n    cols = len(mat[0])\n    if is_safe(row, col, rows, cols) and (row, col) not in seen and mat[row][col] == 1:\n        seen.add((row, col))\n        return (\n            1\n            + depth_first_search(row + 1, col, seen, mat)\n            + depth_first_search(row - 1, col, seen, mat)\n            + depth_first_search(row, col + 1, seen, mat)\n            + depth_first_search(row, col - 1, seen, mat)\n        )\n    else:\n        return 0", "output": "Returns the current area of the island"}
{"task": "detection", "input": "classify code:\ndef alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    \"\"\"\n    The method arranges two lists as one list in alternative forms of the list elements.\n    :param first_input_list:\n    :param second_input_list:\n    :return: List\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\n    >>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\n    >>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list", "output": "CORRECT"}
{"task": "search", "input": "search code:\nImplements the tanh function\n\nChoices:\n0: def tangent_hyperbolic(vector: np.ndarray) -> np.ndarray:      return (2 / (1 + np.exp(-2 * vector))) - 1\n1: def erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:     output = np.zeros_like(image)     image_padded = np.zeros(         (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)     )      # Copy image to padded image     image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image      # Iterate over image & apply kernel     for x in range(image.shape[1]):         for y in range(image.shape[0]):             summation = (                 kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]             ).sum()             output[y, x] = int(summation == 5)     return output\n2: def tribonacci(num: int) -> list[int]:     dp = [0] * num     dp[2] = 1      for i in range(3, num):         dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]      return dp", "output": "0"}
{"task": "detection", "input": "classify code:\ndef fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area", "output": "Function updates the largest_square_area, using bottom up approach."}
{"task": "detection", "input": "classify code:\ndef num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    >>> num_digits(0)\n    1\n    >>> num_digits(-1)\n    1\n    >>> num_digits(-123456)\n    6\n    \"\"\"\n    digits = 0\n    n = abs(n)\n    while True:\n        n = n // 10\n        digits += 1\n        if n == 0:\n            break\n    return digits", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReads given file as bytes and returns them as a long string\n\nChoices:\n0: def naive_cut_rod_recursive(n: int, prices: list):      _enforce_args(n, prices)     if n == 0:         return 0     max_revue = float(\"-inf\")     for i in range(1, n + 1):         max_revue = max(             max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)         )      return max_revue\n1: def read_file_binary(file_path: str) -> str:     result = \"\"     try:         with open(file_path, \"rb\") as binary_file:             data = binary_file.read()         for dat in data:             curr_byte = f\"{dat:08b}\"             result += curr_byte         return result     except OSError:         print(\"File not accessible\")         sys.exit()\n2: def rstrip(iterable, pred):     cache = []     cache_append = cache.append     cache_clear = cache.clear     for x in iterable:         if pred(x):             cache_append(x)         else:             yield from cache             cache_clear()             yield x", "output": "1"}
{"task": "detection", "input": "classify code:\ndef exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef create_sparse(max_node: int, parent: list[list[int]]) -> list[list[int]]:\n    j = 1\n    while (1 << j) < max_node:\n        for i in range(1, max_node + 1):\n            parent[j][i] = parent[j - 1][parent[j - 1][i]]\n        j += 1\n    return parent", "output": "creating sparse table which saves each nodes 2^i-th parent"}
{"task": "search", "input": "search code:\nof Gabor function.\n\nChoices:\n0: def gamma(velocity: float) -> float:     return 1 / sqrt(1 - beta(velocity) ** 2)\n1: def gabor_filter_kernel(     ksize: int, sigma: int, theta: int, lambd: int, gamma: int, psi: int ) -> np.ndarray:      # prepare kernel     # the kernel size have to be odd     if (ksize % 2) == 0:         ksize = ksize + 1     gabor = np.zeros((ksize, ksize), dtype=np.float32)      # each value     for y in range(ksize):         for x in range(ksize):             # distance from center             px = x - ksize // 2             py = y - ksize // 2              # degree to radiant             _theta = theta / 180 * np.pi             cos_theta = np.cos(_theta)             sin_theta = np.sin(_theta)              # get kernel x             _x = cos_theta * px + sin_theta * py              # get kernel y             _y = -sin_theta * px + cos_theta * py              # fill kernel             gabor[y, x] = np.exp(-(_x**2 + gamma**2 * _y**2) / (2 * sigma**2)) * np.cos(                 2 * np.pi * _x / lambd + psi             )      return gabor\n2: def sdbm(plain_text: str) -> int:     hash_value = 0     for plain_chr in plain_text:         hash_value = (             ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value         )     return hash_value", "output": "1"}
{"task": "search", "input": "search code:\nConverts an integer to its ordinal as a string.\n\nChoices:\n0: def decimal_relative_time(d, other=None, ndigits=0, cardinalize=True):     if other is None:         other = datetime.now(timezone.utc).replace(tzinfo=None)     diff = other - d     diff_seconds = timedelta.total_seconds(diff)     abs_diff = abs(diff)     b_idx = bisect.bisect(_BOUND_DELTAS, abs_diff) - 1     bbound, bunit, bname = _BOUNDS[b_idx]     f_diff = diff_seconds / timedelta.total_seconds(bunit)     rounded_diff = round(f_diff, ndigits)     if cardinalize:         return rounded_diff, _cardinalize_time_unit(bname, abs(rounded_diff))     return rounded_diff, bname\n1: def ordinal(value, gender=\"male\"):     try:         value = int(value)     except (TypeError, ValueError):         return value     if gender == \"male\":         t = (             P_(\"0 (male)\", \"th\"),             P_(\"1 (male)\", \"st\"),             P_(\"2 (male)\", \"nd\"),             P_(\"3 (male)\", \"rd\"),             P_(\"4 (male)\", \"th\"),             P_(\"5 (male)\", \"th\"),             P_(\"6 (male)\", \"th\"),             P_(\"7 (male)\", \"th\"),             P_(\"8 (male)\", \"th\"),             P_(\"9 (male)\", \"th\"),         )     else:         t = (             P_(\"0 (female)\", \"th\"),             P_(\"1 (female)\", \"st\"),             P_(\"2 (female)\", \"nd\"),             P_(\"3 (female)\", \"rd\"),             P_(\"4 (female)\", \"th\"),             P_(\"5 (female)\", \"th\"),             P_(\"6 (female)\", \"th\"),             P_(\"7 (female)\", \"th\"),             P_(\"8 (female)\", \"th\"),             P_(\"9 (female)\", \"th\"),         )     if value % 100 in (11, 12, 13):  # special case         return f\"{value}{t[0]}\"     return f\"{value}{t[value % 10]}\"\n2: def collect_dataset():     response = httpx.get(         \"https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/\"         \"master/Week1/ADRvsRating.csv\",         timeout=10,     )     lines = response.text.splitlines()     data = []     for item in lines:         item = item.split(\",\")         data.append(item)     data.pop(0)  # This is for removing the labels from the list     dataset = np.matrix(data)     return dataset", "output": "1"}
{"task": "search", "input": "search code:\nGenerate valid combinations of balanced parentheses for a given n.\n\nChoices:\n0: def generate_parenthesis(n: int) -> list[str]:      result: list[str] = []     backtrack(\"\", 0, 0, n, result)     return result\n1: def different_signs(num1: int, num2: int) -> bool:     return num1 ^ num2 < 0\n2: def sum_of_geometric_progression(     first_term: int, common_ratio: int, num_of_terms: int ) -> float:     if common_ratio == 1:         # Formula for sum if common ratio is 1         return num_of_terms * first_term      # Formula for finding sum of n terms of a GeometricProgression     return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef stalin_sort(sequence: list[int]) -> list[int]:\n    result = [sequence[0]]\n    for element in sequence[1:]:\n        if element >= result[-1]:\n            result.append(element)\n\n    return result", "output": "Sorts a list using the Stalin sort algorithm."}
{"task": "summary", "input": "summarize code:\ndef jaccard_similarity(\n    set_a: set[str] | list[str] | tuple[str],\n    set_b: set[str] | list[str] | tuple[str],\n    alternative_union=False,\n):\n\n    if isinstance(set_a, set) and isinstance(set_b, set):\n        intersection_length = len(set_a.intersection(set_b))\n\n        if alternative_union:\n            union_length = len(set_a) + len(set_b)\n        else:\n            union_length = len(set_a.union(set_b))\n\n        return intersection_length / union_length\n\n    elif isinstance(set_a, (list, tuple)) and isinstance(set_b, (list, tuple)):\n        intersection = [element for element in set_a if element in set_b]\n\n        if alternative_union:\n            return len(intersection) / (len(set_a) + len(set_b))\n        else:\n            # Cast set_a to list because tuples cannot be mutated\n            union = list(set_a) + [element for element in set_b if element not in set_a]\n            return len(intersection) / len(union)\n    raise ValueError(\n        \"Set a and b must either both be sets or be either a list or a tuple.\"\n    )", "output": "Finds the jaccard similarity between two sets."}
{"task": "search", "input": "search code:\nclosest pair of points in strip\n\nChoices:\n0: def run_length_encode(text: str) -> list:     encoded = []     count = 1      for i in range(len(text)):         if i + 1 < len(text) and text[i] == text[i + 1]:             count += 1         else:             encoded.append((text[i], count))             count = 1      return encoded\n1: def dis_between_closest_in_strip(points, points_counts, min_dis=float(\"inf\")):      for i in range(min(6, points_counts - 1), points_counts):         for j in range(max(0, i - 6), i):             current_dis = euclidean_distance_sqr(points[i], points[j])             min_dis = min(min_dis, current_dis)     return min_dis\n2: def main():     num = int(input(\"Enter an integer to see if it is an Armstrong number: \").strip())     print(f\"{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number.\")     print(f\"{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number.\")     print(f\"{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number.\")", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef astar(world, start, goal):\n    _open = []\n    _closed = []\n    _open.append(start)\n\n    while _open:\n        min_f = np.argmin([n.f for n in _open])\n        current = _open[min_f]\n        _closed.append(_open.pop(min_f))\n        if current == goal:\n            break\n        for n in world.get_neighbours(current):\n            for c in _closed:\n                if c == n:\n                    continue\n            n.g = current.g + 1\n            x1, y1 = n.position\n            x2, y2 = goal.position\n            n.h = (y2 - y1) ** 2 + (x2 - x1) ** 2\n            n.f = n.h + n.g\n\n            for c in _open:\n                if c == n and c.f < n.f:\n                    continue\n            _open.append(n)\n    path = []\n    while current.parent is not None:\n        path.append(current.position)\n        current = current.parent\n    path.append(current.position)\n    return path[::-1]", "output": "Implementation of a start algorithm."}
{"task": "search", "input": "search code:\nSort the given list of strings in the way that humans expect.\n\nChoices:\n0: def natural_sort(input_list: list[str]) -> list[str]:      def alphanum_key(key):         return [int(s) if s.isdigit() else s.lower() for s in re.split(\"([0-9]+)\", key)]      return sorted(input_list, key=alphanum_key)\n1: def search(values):     if values is False:         return False  ## Failed earlier     if all(len(values[s]) == 1 for s in squares):         return values  ## Solved!     ## Chose the unfilled square s with the fewest possibilities     _n, s = min((len(values[s]), s) for s in squares if len(values[s]) > 1)     return some(search(assign(values.copy(), s, d)) for d in values[s])\n2: def nth_or_last(iterable, n, default=_marker):     return last(islice(iterable, n + 1), default=default)", "output": "0"}
{"task": "search", "input": "search code:\nReturn a tuple (b, a) when given two integers a and b\n\nChoices:\n0: def split_before(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         if pred(item) and buf:             yield buf             if maxsplit == 1:                 yield [item, *it]                 return             buf = []             maxsplit -= 1         buf.append(item)     if buf:         yield buf\n1: def swap(a: int, b: int) -> tuple[int, int]:     a ^= b     b ^= a     a ^= b     return a, b\n2: def normalization(data: list, ndigits: int = 3) -> list:     # variables for calculation     x_min = min(data)     x_max = max(data)     # normalize data     return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef running_key_encrypt(key: str, plaintext: str) -> str:\n    plaintext = plaintext.replace(\" \", \"\").upper()\n    key = key.replace(\" \", \"\").upper()\n    key_length = len(key)\n    ciphertext = []\n    ord_a = ord(\"A\")\n\n    for i, char in enumerate(plaintext):\n        p = ord(char) - ord_a\n        k = ord(key[i % key_length]) - ord_a\n        c = (p + k) % 26\n        ciphertext.append(chr(c + ord_a))\n\n    return \"\".join(ciphertext)", "output": "Encrypts the plaintext using the Running Key Cipher."}
{"task": "summary", "input": "summarize code:\ndef triangle(\n    vertex1: tuple[float, float],\n    vertex2: tuple[float, float],\n    vertex3: tuple[float, float],\n    depth: int,\n) -> None:\n    my_pen.up()\n    my_pen.goto(vertex1[0], vertex1[1])\n    my_pen.down()\n    my_pen.goto(vertex2[0], vertex2[1])\n    my_pen.goto(vertex3[0], vertex3[1])\n    my_pen.goto(vertex1[0], vertex1[1])\n\n    if depth == 0:\n        return\n\n    triangle(vertex1, get_mid(vertex1, vertex2), get_mid(vertex1, vertex3), depth - 1)\n    triangle(vertex2, get_mid(vertex1, vertex2), get_mid(vertex2, vertex3), depth - 1)\n    triangle(vertex3, get_mid(vertex3, vertex2), get_mid(vertex1, vertex3), depth - 1)", "output": "Recursively draw the Sierpinski triangle given the vertices of the triangle"}
{"task": "search", "input": "search code:\nCalculate the area of a rhombus.\n\nChoices:\n0: def area_rhombus(diagonal_1: float, diagonal_2: float) -> float:     if diagonal_1 < 0 or diagonal_2 < 0:         raise ValueError(\"area_rhombus() only accepts non-negative values\")     return 1 / 2 * diagonal_1 * diagonal_2\n1: def quick_sort_3partition(sorting: list, left: int, right: int) -> None:     if right <= left:         return     a = i = left     b = right     pivot = sorting[left]     while i <= b:         if sorting[i] < pivot:             sorting[a], sorting[i] = sorting[i], sorting[a]             a += 1             i += 1         elif sorting[i] > pivot:             sorting[b], sorting[i] = sorting[i], sorting[b]             b -= 1         else:             i += 1     quick_sort_3partition(sorting, left, a - 1)     quick_sort_3partition(sorting, b + 1, right)\n2: def find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:     if len(nums) == 0:         raise ValueError(\"find_max_recursive() arg is an empty sequence\")     if (         left >= len(nums)         or left < -len(nums)         or right >= len(nums)         or right < -len(nums)     ):         raise IndexError(\"list index out of range\")     if left == right:         return nums[left]     mid = (left + right) >> 1  # the middle     left_max = find_max_recursive(nums, left, mid)  # find max in range[left, mid]     right_max = find_max_recursive(         nums, mid + 1, right     )  # find max in range[mid + 1, right]      return left_max if left_max >= right_max else right_max", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef mro_items(type_obj):\n    # TODO: handle slots?\n    return itertools.chain.from_iterable(ct.__dict__.items()\n                                         for ct in type_obj.__mro__)", "output": "Takes a type and returns an iterator over all class variables"}
{"task": "repair", "input": "fix bug:\ndef move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:\n    \"\"\"\n    Shifts all columns leftward when an entire column becomes empty.\n\n    >>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2)\n    [['A', '-'], ['-', '-'], ['-', 'C']]\n    \"\"\"\n\n    empty_columns = []\n\n    for column in range(size - 1, -1, -1):\n        if all(matrix_g[row][column] == \"-\" for row in range(size)):\n            empty_columns.append(column)\n\n    for column in empty_columns:\n        for col in range(column + 1, size):\n            for row in range(size):\n                matrix_g[row][col - 1] = matrix_g[row][col]\n        for row in range(size):\n            matrix_g[row][-1] = \"-\"\n\n    return matrix_g", "output": "def move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:\n    \"\"\"\n    Shifts all columns leftward when an entire column becomes empty.\n\n    >>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2)\n    [['A', '-'], ['-', '-'], ['-', 'C']]\n    \"\"\"\n\n    empty_columns = []\n\n    for column in range(size - 1, -1, -1):\n        if all(matrix_g[row][column] == \"-\" for row in range(size)):\n            empty_columns.append(column)\n\n    for column in empty_columns:\n        for col in range(column + 1, size):\n            for row in range(size):\n                matrix_g[row][col - 1] = matrix_g[row][col]\n        for row in range(size):\n            matrix_g[row][-1] = \"-\"\n\n    return matrix_g"}
{"task": "summary", "input": "summarize code:\ndef prime_sieve(num: int) -> list[int]:\n\n    if num <= 0:\n        msg = f\"{num}: Invalid input, please enter a positive integer.\"\n        raise ValueError(msg)\n\n    sieve = [True] * (num + 1)\n    prime = []\n    start = 2\n    end = int(math.sqrt(num))\n\n    while start <= end:\n        # If start is a prime\n        if sieve[start] is True:\n            prime.append(start)\n\n            # Set multiples of start be False\n            for i in range(start * start, num + 1, start):\n                if sieve[i] is True:\n                    sieve[i] = False\n\n        start += 1\n\n    for j in range(end + 1, num + 1):\n        if sieve[j] is True:\n            prime.append(j)\n\n    return prime", "output": "Returns a list with all prime numbers up to n."}
{"task": "summary", "input": "summarize code:\ndef get_color_coded_rgb(distance: float) -> tuple:\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return tuple(round(i * 255) for i in colorsys.hsv_to_rgb(distance, 1, 1))", "output": "Color-coding taking the relative distance into account. The Mandelbrot set"}
{"task": "search", "input": "search code:\nReturn the alternative arrangements of the two strings.\n\nChoices:\n0: def ugly_numbers(n: int) -> int:     ugly_nums = [1]      i2, i3, i5 = 0, 0, 0     next_2 = ugly_nums[i2] * 2     next_3 = ugly_nums[i3] * 3     next_5 = ugly_nums[i5] * 5      for _ in range(1, n):         next_num = min(next_2, next_3, next_5)         ugly_nums.append(next_num)         if next_num == next_2:             i2 += 1             next_2 = ugly_nums[i2] * 2         if next_num == next_3:             i3 += 1             next_3 = ugly_nums[i3] * 3         if next_num == next_5:             i5 += 1             next_5 = ugly_nums[i5] * 5     return ugly_nums[-1]\n1: def solution(power: int = 1000) -> int:     num = 2**power     string_num = str(num)     list_num = list(string_num)     sum_of_num = 0      for i in list_num:         sum_of_num += int(i)      return sum_of_num\n2: def alternative_string_arrange(first_str: str, second_str: str) -> str:     first_str_length: int = len(first_str)     second_str_length: int = len(second_str)     abs_length: int = (         first_str_length if first_str_length > second_str_length else second_str_length     )     output_list: list = []     for char_count in range(abs_length):         if char_count < first_str_length:             output_list.append(first_str[char_count])         if char_count < second_str_length:             output_list.append(second_str[char_count])     return \"\".join(output_list)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef octal_to_binary(octal_number: str) -> str:\n    if not octal_number:\n        raise ValueError(\"Empty string was passed to the function\")\n\n    binary_number = \"\"\n    octal_digits = \"01234567\"\n    for digit in octal_number:\n        if digit not in octal_digits:\n            raise ValueError(\"Non-octal value was passed to the function\")\n\n        binary_digit = \"\"\n        value = int(digit)\n        for _ in range(3):\n            binary_digit = str(value % 2) + binary_digit\n            value //= 2\n        binary_number += binary_digit\n\n    return binary_number", "output": "Convert an Octal number to Binary."}
{"task": "search", "input": "search code:\nCreates a state space tree to iterate through each branch using DFS.\n\nChoices:\n0: def mbd(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     numerator = np.sum(difference) / len(predict)     denumerator = np.sum(actual) / len(predict)     # print(numerator, denumerator)     score = float(numerator) / denumerator * 100      return score\n1: def create_state_space_tree(     nums: list[int],     max_sum: int,     num_index: int,     path: list[int],     result: list[list[int]],     remaining_nums_sum: int, ) -> None:      if sum(path) > max_sum or (remaining_nums_sum + sum(path)) < max_sum:         return     if sum(path) == max_sum:         result.append(path)         return     for index in range(num_index, len(nums)):         create_state_space_tree(             nums,             max_sum,             index + 1,             [*path, nums[index]],             result,             remaining_nums_sum - nums[index],         )\n2: def covariance_within_classes(     features: np.ndarray, labels: np.ndarray, classes: int ) -> np.ndarray:      covariance_sum = np.nan     for i in range(classes):         data = features[:, labels == i]         data_mean = data.mean(1)         # Centralize the data of class i         centered_data = data - column_reshape(data_mean)         if i > 0:             # If covariance_sum is not None             covariance_sum += np.dot(centered_data, centered_data.T)         else:             # If covariance_sum is np.nan (i.e. first loop)             covariance_sum = np.dot(centered_data, centered_data.T)      return covariance_sum / features.shape[1]", "output": "1"}
{"task": "detection", "input": "classify code:\ndef perfect_cube(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not.\n\n    >>> perfect_cube(27)\n    True\n    >>> perfect_cube(4)\n    False\n    \"\"\"\n    val = n ** (1 / 3)\n    return (val * val * val) == n", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef max_difference(a: List[int]) -> (int, int):\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second", "output": "def max_difference(a: list[int]) -> tuple[int, int]:\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second"}
{"task": "summary", "input": "summarize code:\ndef coulombs_law(q1: float, q2: float, radius: float) -> float:\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)", "output": "Calculate the electrostatic force of attraction or repulsion"}
{"task": "summary", "input": "summarize code:\ndef multi_replace(text, sub_map, **kwargs):\n    m = MultiReplace(sub_map, **kwargs)\n    return m.sub(text)", "output": "Shortcut function to invoke MultiReplace in a single call."}
{"task": "summary", "input": "summarize code:\ndef binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)", "output": "Pure implementation of a binary search algorithm in Python by recursion"}
{"task": "summary", "input": "summarize code:\ndef add_key_to_lexicon(\n    lexicon: dict[str, str], curr_string: str, index: int, last_match_id: str\n) -> None:\n    lexicon.pop(curr_string)\n    lexicon[curr_string + \"0\"] = last_match_id\n\n    if math.log2(index).is_integer():\n        for curr_key, value in lexicon.items():\n            lexicon[curr_key] = f\"0{value}\"\n\n    lexicon[curr_string + \"1\"] = bin(index)[2:]", "output": "Adds new strings (curr_string + \"0\", curr_string + \"1\") to the lexicon"}
{"task": "detection", "input": "classify code:\ndef match_pattern(input_string: str, pattern: str) -> bool:\n    \"\"\"\n    uses bottom-up dynamic programming solution for matching the input\n    string with a given pattern.\n\n    Runtime: O(len(input_string)*len(pattern))\n\n    Arguments\n    --------\n    input_string: str, any string which should be compared with the pattern\n    pattern: str, the string that represents a pattern and may contain\n    '.' for single character matches and '*' for zero or more of preceding character\n    matches\n\n    Note\n    ----\n    the pattern cannot start with a '*',\n    because there should be at least one character before *\n\n    Returns\n    -------\n    A Boolean denoting whether the given string follows the pattern\n\n    Examples\n    -------\n    >>> match_pattern(\"aab\", \"c*a*b\")\n    True\n    >>> match_pattern(\"dabc\", \"*abc\")\n    False\n    >>> match_pattern(\"aaa\", \"aa\")\n    False\n    >>> match_pattern(\"aaa\", \"a.a\")\n    True\n    >>> match_pattern(\"aaab\", \"aa*\")\n    False\n    >>> match_pattern(\"aaab\", \".*\")\n    True\n    >>> match_pattern(\"a\", \"bbbb\")\n    False\n    >>> match_pattern(\"\", \"bbbb\")\n    False\n    >>> match_pattern(\"a\", \"\")\n    False\n    >>> match_pattern(\"\", \"\")\n    True\n    \"\"\"\n\n    len_string = len(input_string) + 1\n    len_pattern = len(pattern) + 1\n\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\n    # length i of input_string matches with prefix string of length j of\n    # given pattern.\n    # \"dp\" stands for dynamic programming.\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\n\n    # since string of zero length match pattern of zero length\n    dp[0][0] = 1\n\n    # since pattern of zero length will never match with string of non-zero length\n    for i in range(1, len_string):\n        dp[i][0] = 0\n\n    # since string of zero length will match with pattern where there\n    # is at least one * alternatively\n    for j in range(1, len_pattern):\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \"*\" else 0\n\n    # now using bottom-up approach to find for all remaining lengths\n    for i in range(1, len_string):\n        for j in range(1, len_pattern):\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \".\":\n                dp[i][j] = dp[i - 1][j - 1]\n\n            elif pattern[j - 1] == \"*\":\n                if dp[i][j - 2] == 1:\n                    dp[i][j] = 1\n                elif pattern[j - 2] in (input_string[i - 1], \".\"):\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n\n    return bool(dp[-1][-1])", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef bucketize(src, key=bool, value_transform=None, key_filter=None):\n    if not is_iterable(src):\n        raise TypeError('expected an iterable')\n    elif isinstance(key, list):\n        if len(key) != len(src):\n            raise ValueError(\"key and src have to be the same length\")\n        src = zip(key, src)\n\n    if isinstance(key, str):\n        def key_func(x): return getattr(x, key, x)\n    elif callable(key):\n        key_func = key\n    elif isinstance(key, list):\n        def key_func(x): return x[0]\n    else:\n        raise TypeError('expected key to be callable or a string or a list')\n\n    if value_transform is None:\n        def value_transform(x): return x\n    if not callable(value_transform):\n        raise TypeError('expected callable value transform function')\n    if isinstance(key, list):\n        f = value_transform\n        def value_transform(x): return f(x[1])\n\n    ret = {}\n    for val in src:\n        key_of_val = key_func(val)\n        if key_filter is None or key_filter(key_of_val):\n            ret.setdefault(key_of_val, []).append(value_transform(val))\n    return ret", "output": "Group values in the *src* iterable by the value returned by *key*."}
{"task": "summary", "input": "summarize code:\ndef get_initial_centroids(data, k, seed=None):\n    # useful for obtaining consistent results\n    rng = np.random.default_rng(seed)\n    n = data.shape[0]  # number of data points\n\n    # Pick K indices from range [0, N).\n    rand_indices = rng.integers(0, n, k)\n\n    # Keep centroids as dense format, as many entries will be nonzero due to averaging.\n    # As long as at least one document in a cluster contains a word,\n    # it will carry a nonzero weight in the TF-IDF vector of the centroid.\n    centroids = data[rand_indices, :]\n\n    return centroids", "output": "Randomly choose k data points as initial centroids"}
{"task": "search", "input": "search code:\nThis function takes a list of query times and returns the minimum waiting time\n\nChoices:\n0: def solution(num: int = 100) -> int:     nfact = factorial(num)     result = split_and_add(nfact)     return result\n1: def minimum_waiting_time(queries: list[int]) -> int:     n = len(queries)     if n in (0, 1):         return 0     return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))\n2: def solution(n: int = 998001) -> int:      answer = 0     for i in range(999, 99, -1):  # 3 digit numbers range from 999 down to 100         for j in range(999, 99, -1):             product_string = str(i * j)             if product_string == product_string[::-1] and i * j < n:                 answer = max(answer, i * j)     return answer", "output": "1"}
{"task": "search", "input": "search code:\nGiven a number, return first n Tribonacci Numbers.\n\nChoices:\n0: def tribonacci(num: int) -> list[int]:     dp = [0] * num     dp[2] = 1      for i in range(3, num):         dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]      return dp\n1: def is_safe_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return (number - 1) % 2 == 0 and is_prime(number) and is_prime((number - 1) // 2)\n2: def freq_subgraphs_edge_list(paths):     freq_sub_el = []     for edges in paths:         el = []         for j in range(len(edges) - 1):             temp = list(edges[j])             for e in temp:                 edge = (e[0], e[1])                 el.append(edge)         freq_sub_el.append(el)     return freq_sub_el", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef perfect_square(num: int) -> bool:\n    return math.sqrt(num) * math.sqrt(num) == num", "output": "Check if a number is perfect square number or not"}
{"task": "detection", "input": "classify code:\ndef encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturn eroded image\n\nChoices:\n0: def erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:     output = np.zeros_like(image)     image_padded = np.zeros(         (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)     )      # Copy image to padded image     image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image      # Iterate over image & apply kernel     for x in range(image.shape[1]):         for y in range(image.shape[0]):             summation = (                 kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]             ).sum()             output[y, x] = int(summation == 5)     return output\n1: def is_safe(row: int, col: int, rows: int, cols: int) -> bool:     return 0 <= row < rows and 0 <= col < cols\n2: def make_linked_list(elements_list: list | tuple) -> Node:      # if elements_list is empty     if not elements_list:         raise ValueError(\"The Elements List is empty\")      # Set first element as Head     head = Node(elements_list[0])     current = head     # Loop through elements from position 1     for data in elements_list[1:]:         current.next = Node(data)         current = current.next     return head", "output": "0"}
{"task": "detection", "input": "classify code:\ndef load_data() -> list[list[str]]:\n    \"\"\"\n    Returns a sample transaction dataset.\n\n    >>> load_data()\n    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]\n    \"\"\"\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef count_inversions_bf(arr):\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions", "output": "Counts the number of inversions using a naive brute-force algorithm"}
{"task": "summary", "input": "summarize code:\ndef area_ellipse(radius_x: float, radius_y: float) -> float:\n    if radius_x < 0 or radius_y < 0:\n        raise ValueError(\"area_ellipse() only accepts non-negative values\")\n    return pi * radius_x * radius_y", "output": "Calculate the area of a ellipse."}
{"task": "search", "input": "search code:\nTake an integer value and raise ValueError for wrong inputs,\n\nChoices:\n0: def remove_word(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> None:     for i in range(len(word)):         if vertical:             puzzle[row + i][col] = \"\"         else:             puzzle[row][col + i] = \"\"\n1: def decimal_to_binary_recursive(number: str) -> str:     number = str(number).strip()     if not number:         raise ValueError(\"No input value was provided\")     negative = \"-\" if number.startswith(\"-\") else \"\"     number = number.lstrip(\"-\")     if not number.isnumeric():         raise ValueError(\"Input value is not an integer\")     return f\"{negative}0b{decimal_to_binary_recursive_helper(int(number))}\"\n2: def encipher(message: str, cipher_map: dict[str, str]) -> str:     return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution():\n    total = 0\n    for i in range(1, 1001):\n        total += i**i\n    return str(total)[-10:]", "output": "Returns the last 10 digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000."}
{"task": "summary", "input": "summarize code:\ndef first_effusion_rate(\n    effusion_rate: float, molar_mass_1: float, molar_mass_2: float\n) -> float | ValueError:\n    return (\n        round(effusion_rate * sqrt(molar_mass_2 / molar_mass_1), 6)\n        if validate(effusion_rate, molar_mass_1, molar_mass_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )", "output": "Input Parameters:"}
{"task": "search", "input": "search code:\nCheck if we have to move forward to the next characters or not\n\nChoices:\n0: def summation_of_cost_derivative(index, end=m):     summation_value = 0     for i in range(end):         if index == -1:             summation_value += _error(i)         else:             summation_value += _error(i) * train_data[i][0][index]     return summation_value\n1: def go_next(i: int, z_result: list[int], s: str) -> bool:     return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]\n2: def apnumber(value):     try:         value = int(value)     except (TypeError, ValueError):         return value     if not 0 <= value < 10:         return str(value)     return (         _(\"zero\"),         _(\"one\"),         _(\"two\"),         _(\"three\"),         _(\"four\"),         _(\"five\"),         _(\"six\"),         _(\"seven\"),         _(\"eight\"),         _(\"nine\"),     )[value]", "output": "1"}
{"task": "detection", "input": "classify code:\ndef question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef mobius(n: int) -> int:\n    factors = prime_factors(n)\n    if is_square_free(factors):\n        return -1 if len(factors) % 2 else 1\n    return 0", "output": "Mobius function"}
{"task": "summary", "input": "summarize code:\ndef preprocess(edge_array):\n    for i in range(len(edge_array)):\n        for j in range(len(edge_array[i])):\n            t = edge_array[i][j].split(\"-\")\n            edge_array[i][j] = t", "output": "Preprocess the edge array"}
{"task": "search", "input": "search code:\nCounts the number of inversions using a naive brute-force algorithm\n\nChoices:\n0: def count_inversions_bf(arr):      num_inversions = 0     n = len(arr)      for i in range(n - 1):         for j in range(i + 1, n):             if arr[i] > arr[j]:                 num_inversions += 1      return num_inversions\n1: def permutation_index(element, iterable):     index = 0     pool = list(iterable)     for i, x in zip(range(len(pool), -1, -1), element):         r = pool.index(x)         index = index * i + r         del pool[r]      return index\n2: def _subsum(     digit_pos_to_extract: int, denominator_addend: int, precision: int ) -> float:     # only care about first digit of fractional part; don't need decimal     total = 0.0     for sum_index in range(digit_pos_to_extract + precision):         denominator = 8 * sum_index + denominator_addend         if sum_index < digit_pos_to_extract:             # if the exponential term is an integer and we mod it by the denominator             # before dividing, only the integer part of the sum will change;             # the fractional part will not             exponential_term = pow(                 16, digit_pos_to_extract - 1 - sum_index, denominator             )         else:             exponential_term = pow(16, digit_pos_to_extract - 1 - sum_index)         total += exponential_term / denominator     return total", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef kmeans(\n    data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False\n):\n    centroids = initial_centroids[:]\n    prev_cluster_assignment = None\n\n    for itr in range(maxiter):\n        if verbose:\n            print(itr, end=\"\")\n\n        # 1. Make cluster assignments using nearest centroids\n        cluster_assignment = assign_clusters(data, centroids)\n\n        # 2. Compute a new centroid for each of the k clusters, averaging all data\n        #    points assigned to that cluster.\n        centroids = revise_centroids(data, k, cluster_assignment)\n\n        # Check for convergence: if none of the assignments changed, stop\n        if (\n            prev_cluster_assignment is not None\n            and (prev_cluster_assignment == cluster_assignment).all()\n        ):\n            break\n\n        # Print number of new assignments\n        if prev_cluster_assignment is not None:\n            num_changed = np.sum(prev_cluster_assignment != cluster_assignment)\n            if verbose:\n                print(\n                    f\"    {num_changed:5d} elements changed their cluster assignment.\"\n                )\n\n        # Record heterogeneity convergence metric\n        if record_heterogeneity is not None:\n            # YOUR CODE HERE\n            score = compute_heterogeneity(data, k, centroids, cluster_assignment)\n            record_heterogeneity.append(score)\n\n        prev_cluster_assignment = cluster_assignment[:]\n\n    return centroids, cluster_assignment", "output": "Runs k-means on given data and initial set of centroids."}
{"task": "search", "input": "search code:\nReturns the number of distinct terms in the sequence generated by a^b\n\nChoices:\n0: def largest_pow_of_two_le_num(number: int) -> int:     if isinstance(number, float):         raise TypeError(\"Input value must be a 'int' type\")     if number <= 0:         return 0     res = 1     while (res << 1) <= number:         res <<= 1     return res\n1: def solution(n: int = 100) -> int:     collect_powers = set()      current_pow = 0      n = n + 1  # maximum limit      for a in range(2, n):         for b in range(2, n):             current_pow = a**b  # calculates the current power             collect_powers.add(current_pow)  # adds the result to the set     return len(collect_powers)\n2: def solution(n: int = 1000) -> int:     answer = 1     gen = fibonacci_generator()     while len(str(next(gen))) < n:         answer += 1     return answer + 1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef match_word_pattern(pattern: str, input_string: str) -> bool:\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)", "output": "Determine if a given pattern matches a string using backtracking."}
{"task": "summary", "input": "summarize code:\ndef huffman(file_path: str) -> None:\n    letters_list = parse_file(file_path)\n    root = build_tree(letters_list)\n    letters = {\n        k: v for letter in traverse_tree(root, \"\") for k, v in letter.bitstring.items()\n    }\n    print(f\"Huffman Coding  of {file_path}: \")\n    with open(file_path) as f:\n        while True:\n            c = f.read(1)\n            if not c:\n                break\n            print(letters[c], end=\" \")\n    print()", "output": "Parse the file, build the tree, then run through the file"}
{"task": "search", "input": "search code:\nAfter the *iterable* is exhausted, keep yielding its last element.\n\nChoices:\n0: def repeat_last(iterable, default=None):     item = _marker     for item in iterable:         yield item     final = default if item is _marker else item     yield from repeat(final)\n1: def softmax(vector):      # Calculate e^x for each x in your vector where e is Euler's     # number (approximately 2.718)     exponent_vector = np.exp(vector)      # Add up the all the exponentials     sum_of_exponents = np.sum(exponent_vector)      # Divide every exponent by the sum of all exponents     softmax_vector = exponent_vector / sum_of_exponents      return softmax_vector\n2: def check(number: int) -> bool:      check_last = [0] * 11     check_front = [0] * 11      # mark last 9 numbers     for _ in range(9):         check_last[int(number % 10)] = 1         number = number // 10     # flag     f = True      # check last 9 numbers for pandigitality      for x in range(9):         if not check_last[x + 1]:             f = False     if not f:         return f      # mark first 9 numbers     number = int(str(number)[:9])      for _ in range(9):         check_front[int(number % 10)] = 1         number = number // 10      # check first 9 numbers for pandigitality      for x in range(9):         if not check_front[x + 1]:             f = False     return f", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef windowed(src, size, fill=_UNSET):\n    return list(windowed_iter(src, size, fill=fill))", "output": "Returns tuples with exactly length *size*. If *fill* is unset"}
{"task": "search", "input": "search code:\nReturn a dictionary of attribute names to values for a given\n\nChoices:\n0: def dir_dict(obj, raise_exc=False):     # TODO: separate function for handling descriptors on types?     ret = {}     for k in dir(obj):         try:             ret[k] = getattr(obj, k)         except Exception:             if raise_exc:                 raise     return ret\n1: def largest_divisible_subset(items: list[int]) -> list[int]:     # Sort the array in ascending order as the sequence does not matter we only have to     # pick up a subset.     items = sorted(items)      number_of_items = len(items)      # Initialize memo with 1s and hash with increasing numbers     memo = [1] * number_of_items     hash_array = list(range(number_of_items))      # Iterate through the array     for i, item in enumerate(items):         for prev_index in range(i):             if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (                 (1 + memo[prev_index]) > memo[i]             ):                 memo[i] = 1 + memo[prev_index]                 hash_array[i] = prev_index      ans = -1     last_index = -1      # Find the maximum length and its corresponding index     for i, memo_item in enumerate(memo):         if memo_item > ans:             ans = memo_item             last_index = i      # Reconstruct the divisible subset     if last_index == -1:         return []     result = [items[last_index]]     while hash_array[last_index] != last_index:         last_index = hash_array[last_index]         result.append(items[last_index])      return result\n2: def inverse_document_frequency(df: int, n: int, smoothing=False) -> float:     if smoothing:         if n == 0:             raise ValueError(\"log10(0) is undefined.\")         return round(1 + log10(n / (1 + df)), 3)      if df == 0:         raise ZeroDivisionError(\"df must be > 0\")     elif n == 0:         raise ValueError(\"log10(0) is undefined.\")     return round(log10(n / df), 3)", "output": "0"}
{"task": "search", "input": "search code:\nDecodes from Baconian cipher\n\nChoices:\n0: def trapezoidal_rule(boundary, steps):     h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 2.0) * f(a)     for i in x_i:         y += h * f(i)     y += (h / 2.0) * f(b)     return y\n1: def decode(coded: str) -> str:     if set(coded) - {\"A\", \"B\", \" \"} != set():         raise Exception(\"decode() accepts only 'A', 'B' and spaces\")     decoded = \"\"     for word in coded.split():         while len(word) != 0:             decoded += decode_dict[word[:5]]             word = word[5:]         decoded += \" \"     return decoded.strip()\n2: def largest_square_area_in_matrix_top_down_approch(     rows: int, cols: int, mat: list[list[int]] ) -> int:      def update_area_of_max_square(row: int, col: int) -> int:         # BASE CASE         if row >= rows or col >= cols:             return 0          right = update_area_of_max_square(row, col + 1)         diagonal = update_area_of_max_square(row + 1, col + 1)         down = update_area_of_max_square(row + 1, col)          if mat[row][col]:             sub_problem_sol = 1 + min([right, diagonal, down])             largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)             return sub_problem_sol         else:             return 0      largest_square_area = [0]     update_area_of_max_square(0, 0)     return largest_square_area[0]", "output": "1"}
{"task": "search", "input": "search code:\nConsidering any range can be provided,\n\nChoices:\n0: def comp_and_swap(array: list[int], index1: int, index2: int, direction: int) -> None:     if (direction == 1 and array[index1] > array[index2]) or (         direction == 0 and array[index1] < array[index2]     ):         array[index1], array[index2] = array[index2], array[index1]\n1: def solution(numerator: int = 1, digit: int = 1000) -> int:     the_digit = 1     longest_list_length = 0      for divide_by_number in range(numerator, digit + 1):         has_been_divided: list[int] = []         now_divide = numerator         for _ in range(1, digit + 1):             if now_divide in has_been_divided:                 if longest_list_length < len(has_been_divided):                     longest_list_length = len(has_been_divided)                     the_digit = divide_by_number             else:                 has_been_divided.append(now_divide)                 now_divide = now_divide * 10 % divide_by_number      return the_digit\n2: def tarjan(g: list[list[int]]) -> list[list[int]]:      n = len(g)     stack: deque[int] = deque()     on_stack = [False for _ in range(n)]     index_of = [-1 for _ in range(n)]     lowlink_of = index_of[:]      def strong_connect(v: int, index: int, components: list[list[int]]) -> int:         index_of[v] = index  # the number when this node is seen         lowlink_of[v] = index  # lowest rank node reachable from here         index += 1         stack.append(v)         on_stack[v] = True          for w in g[v]:             if index_of[w] == -1:                 index = strong_connect(w, index, components)                 lowlink_of[v] = (                     lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]                 )             elif on_stack[w]:                 lowlink_of[v] = (                     lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]                 )          if lowlink_of[v] == index_of[v]:             component = []             w = stack.pop()             on_stack[w] = False             component.append(w)             while w != v:                 w = stack.pop()                 on_stack[w] = False                 component.append(w)             components.append(component)         return index      components: list[list[int]] = []     for v in range(n):         if index_of[v] == -1:             strong_connect(v, 0, components)      return components", "output": "1"}
{"task": "search", "input": "search code:\nFunction calculates the total resistance of the resistor using the color codes.\n\nChoices:\n0: def calculate_resistance(number_of_bands: int, color_code_list: list) -> dict:     is_valid = check_validity(number_of_bands, color_code_list)     if is_valid:         number_of_significant_bands = get_band_type_count(             number_of_bands, \"significant\"         )         significant_colors = color_code_list[:number_of_significant_bands]         significant_digits = int(get_significant_digits(significant_colors))         multiplier_color = color_code_list[number_of_significant_bands]         multiplier = get_multiplier(multiplier_color)         if number_of_bands == 3:             tolerance_color = None         else:             tolerance_color = color_code_list[number_of_significant_bands + 1]         tolerance = (             20 if tolerance_color is None else get_tolerance(str(tolerance_color))         )         if number_of_bands != 6:             temperature_coeffecient_color = None         else:             temperature_coeffecient_color = color_code_list[                 number_of_significant_bands + 2             ]         temperature_coeffecient = (             0             if temperature_coeffecient_color is None             else get_temperature_coeffecient(str(temperature_coeffecient_color))         )         resisitance = significant_digits * multiplier         if temperature_coeffecient == 0:             answer = f\"{resisitance} {tolerance}% \"         else:             answer = f\"{resisitance} {tolerance}% {temperature_coeffecient} ppm/K\"         return {\"resistance\": answer}     else:         raise ValueError(\"Input is invalid\")\n1: def xnor_gate(input_1: int, input_2: int) -> int:     return 1 if input_1 == input_2 else 0\n2: def straight_line_depreciation(     useful_years: int,     purchase_value: float,     residual_value: float = 0.0, ) -> list[float]:      if not isinstance(useful_years, int):         raise TypeError(\"Useful years must be an integer\")      if useful_years < 1:         raise ValueError(\"Useful years cannot be less than 1\")      if not isinstance(purchase_value, (float, int)):         raise TypeError(\"Purchase value must be numeric\")      if not isinstance(residual_value, (float, int)):         raise TypeError(\"Residual value must be numeric\")      if purchase_value < 0.0:         raise ValueError(\"Purchase value cannot be less than zero\")      if purchase_value < residual_value:         raise ValueError(\"Purchase value cannot be less than residual value\")      # Calculate annual depreciation expense     depreciable_cost = purchase_value - residual_value     annual_depreciation_expense = depreciable_cost / useful_years      # List of annual depreciation expenses     list_of_depreciation_expenses = []     accumulated_depreciation_expense = 0.0     for period in range(useful_years):         if period != useful_years - 1:             accumulated_depreciation_expense += annual_depreciation_expense             list_of_depreciation_expenses.append(annual_depreciation_expense)         else:             depreciation_expense_in_end_year = (                 depreciable_cost - accumulated_depreciation_expense             )             list_of_depreciation_expenses.append(depreciation_expense_in_end_year)      return list_of_depreciation_expenses", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef iteration_step(vectors: list[np.ndarray]) -> list[np.ndarray]:\n    new_vectors = []\n    for i, start_vector in enumerate(vectors[:-1]):\n        end_vector = vectors[i + 1]\n        new_vectors.append(start_vector)\n        difference_vector = end_vector - start_vector\n        new_vectors.append(start_vector + difference_vector / 3)\n        new_vectors.append(\n            start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)\n        )\n        new_vectors.append(start_vector + difference_vector * 2 / 3)\n    new_vectors.append(vectors[-1])\n    return new_vectors", "output": "Loops through each pair of adjacent vectors. Each line between two adjacent"}
{"task": "summary", "input": "summarize code:\ndef iter_index(iterable, value, start=0, stop=None):\n    seq_index = getattr(iterable, 'index', None)\n    if seq_index is None:\n        # Slow path for general iterables\n        iterator = islice(iterable, start, stop)\n        for i, element in enumerate(iterator, start):\n            if element is value or element == value:\n                yield i\n    else:\n        # Fast path for sequences\n        stop = len(iterable) if stop is None else stop\n        i = start - 1\n        with suppress(ValueError):\n            while True:\n                yield (i := seq_index(value, i + 1, stop))", "output": "Yield the index of each place in *iterable* that *value* occurs,"}
{"task": "search", "input": "search code:\nInput Param:\n\nChoices:\n0: def capture_area(capture_radius: float) -> float:      if capture_radius < 0:         raise ValueError(\"Cannot have a capture radius less than 0\")     sigma = pi * pow(capture_radius, 2)     return round(sigma, 0)\n1: def collapse(iterable, base_type=None, levels=None):     stack = deque()     # Add our first node group, treat the iterable as a single node     stack.appendleft((0, repeat(iterable, 1)))      while stack:         node_group = stack.popleft()         level, nodes = node_group          # Check if beyond max level         if levels is not None and level > levels:             yield from nodes             continue          for node in nodes:             # Check if done iterating             if isinstance(node, (str, bytes)) or (                 (base_type is not None) and isinstance(node, base_type)             ):                 yield node             # Otherwise try to create child nodes             else:                 try:                     tree = iter(node)                 except TypeError:                     yield node                 else:                     # Save our current location                     stack.appendleft(node_group)                     # Append the new child node                     stack.appendleft((level + 1, tree))                     # Break to process child node                     break\n2: def iteration_step(vectors: list[np.ndarray]) -> list[np.ndarray]:     new_vectors = []     for i, start_vector in enumerate(vectors[:-1]):         end_vector = vectors[i + 1]         new_vectors.append(start_vector)         difference_vector = end_vector - start_vector         new_vectors.append(start_vector + difference_vector / 3)         new_vectors.append(             start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)         )         new_vectors.append(start_vector + difference_vector * 2 / 3)     new_vectors.append(vectors[-1])     return new_vectors", "output": "0"}
{"task": "detection", "input": "classify code:\ndef partition(m):\n    \"\"\"Returns the number of different ways one hundred can be written as a sum\n    of at least two positive integers.\n\n    >>> partition(100)\n    190569291\n    >>> partition(50)\n    204225\n    >>> partition(30)\n    5603\n    >>> partition(10)\n    41\n    >>> partition(5)\n    6\n    >>> partition(3)\n    2\n    >>> partition(2)\n    1\n    >>> partition(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1", "output": "CORRECT"}
{"task": "search", "input": "search code:\nBenchmark code for comparing above 2 functions\n\nChoices:\n0: def solution(power: int = 1000) -> int:     num = 2**power     string_num = str(num)     list_num = list(string_num)     sum_of_num = 0      for i in list_num:         sum_of_num += int(i)      return sum_of_num\n1: def sum_of_digits(n: int) -> int:     n = abs(n)     res = 0     while n > 0:         res += n % 10         n //= 10     return res\n2: def benchmark(input_str: str = \"\") -> None:     print(\"\\nFor string = \", input_str, \":\")     print(         \"> can_string_be_rearranged_as_palindrome_counter()\",         \"\\tans =\",         can_string_be_rearranged_as_palindrome_counter(input_str),         \"\\ttime =\",         timeit(             \"z.can_string_be_rearranged_as_palindrome_counter(z.check_str)\",             setup=\"import __main__ as z\",         ),         \"seconds\",     )     print(         \"> can_string_be_rearranged_as_palindrome()\",         \"\\tans =\",         can_string_be_rearranged_as_palindrome(input_str),         \"\\ttime =\",         timeit(             \"z.can_string_be_rearranged_as_palindrome(z.check_str)\",             setup=\"import __main__ as z\",         ),         \"seconds\",     )", "output": "2"}
{"task": "detection", "input": "classify code:\ndef merge_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Time Complexity: O(n log n)\n    Space Complexity: O(n)\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def merge(left: list, right: list) -> list:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n\n        :param left: Left collection\n        :param right: Right collection\n        :return: Merged result\n        \"\"\"\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef equilibrium_index(arr: list[int], size: int) -> int:\n    \"\"\"\n    Find the equilibrium index of an array.\n\n    Args:\n        arr : The input array of integers.\n        size : The size of the array.\n\n    Returns:\n        int: The equilibrium index or -1 if no equilibrium index exists.\n\n    Examples:\n        >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0], 7)\n        3\n        >>> equilibrium_index([1, 2, 3, 4, 5], 5)\n        -1\n        >>> equilibrium_index([1, 1, 1, 1, 1], 5)\n        2\n        >>> equilibrium_index([2, 4, 6, 8, 10, 3], 6)\n        -1\n    \"\"\"\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i in range(size):\n        total_sum -= arr[i]\n        if left_sum == total_sum:\n            return i\n        left_sum += arr[i]\n\n    return -1", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef is_bit_set(number: int, position: int) -> bool:\n    return ((number >> position) & 1) == 1", "output": "Is the bit at position set?"}
{"task": "summary", "input": "summarize code:\ndef encrypt(plaintext: str, key: str) -> str:\n    if not isinstance(plaintext, str):\n        raise TypeError(\"plaintext must be a string\")\n    if not isinstance(key, str):\n        raise TypeError(\"key must be a string\")\n\n    if not plaintext:\n        raise ValueError(\"plaintext is empty\")\n    if not key:\n        raise ValueError(\"key is empty\")\n\n    key += plaintext\n    plaintext = plaintext.lower()\n    key = key.lower()\n    plaintext_iterator = 0\n    key_iterator = 0\n    ciphertext = \"\"\n    while plaintext_iterator < len(plaintext):\n        if (\n            ord(plaintext[plaintext_iterator]) < 97\n            or ord(plaintext[plaintext_iterator]) > 122\n        ):\n            ciphertext += plaintext[plaintext_iterator]\n            plaintext_iterator += 1\n        elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:\n            key_iterator += 1\n        else:\n            ciphertext += chr(\n                (\n                    (ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))\n                    - 97\n                )\n                % 26\n                + 97\n            )\n            key_iterator += 1\n            plaintext_iterator += 1\n    return ciphertext", "output": "Encrypt a given `plaintext` (string) and `key` (string), returning the"}
{"task": "detection", "input": "classify code:\ndef is_match(string: str, pattern: str) -> bool:\n    \"\"\"\n    >>> is_match(\"\", \"\")\n    True\n    >>> is_match(\"aa\", \"a\")\n    False\n    >>> is_match(\"abc\", \"abc\")\n    True\n    >>> is_match(\"abc\", \"*c\")\n    True\n    >>> is_match(\"abc\", \"a*\")\n    True\n    >>> is_match(\"abc\", \"*a*\")\n    True\n    >>> is_match(\"abc\", \"?b?\")\n    True\n    >>> is_match(\"abc\", \"*?\")\n    True\n    >>> is_match(\"abc\", \"a*d\")\n    False\n    >>> is_match(\"abc\", \"a*c?\")\n    False\n    >>> is_match('baaabab','*****ba*****ba')\n    False\n    >>> is_match('baaabab','*****ba*****ab')\n    True\n    >>> is_match('aa','*')\n    True\n    \"\"\"\n    dp = [[False] * (len(pattern) + 1) for _ in string + \"1\"]\n    dp[0][0] = True\n    # Fill in the first row\n    for j, char in enumerate(pattern, 1):\n        if char == \"*\":\n            dp[0][j] = dp[0][j - 1]\n    # Fill in the rest of the DP table\n    for i, s_char in enumerate(string, 1):\n        for j, p_char in enumerate(pattern, 1):\n            if p_char in (s_char, \"?\"):\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[len(string)][len(pattern)]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef pi_estimator(iterations: int) -> None:\n\n    # A local function to see if a dot lands in the circle.\n    def is_in_circle(x: float, y: float) -> bool:\n        distance_from_centre = sqrt((x**2) + (y**2))\n        # Our circle has a radius of 1, so a distance\n        # greater than 1 would land outside the circle.\n        return distance_from_centre <= 1\n\n    # The proportion of guesses that landed in the circle\n    proportion = mean(\n        int(is_in_circle(uniform(-1.0, 1.0), uniform(-1.0, 1.0)))\n        for _ in range(iterations)\n    )\n    # The ratio of the area for circle to square is pi/4.\n    pi_estimate = proportion * 4\n    print(f\"The estimated value of pi is {pi_estimate}\")\n    print(f\"The numpy value of pi is {pi}\")\n    print(f\"The total error is {abs(pi - pi_estimate)}\")", "output": "An implementation of the Monte Carlo method used to find pi."}
{"task": "summary", "input": "summarize code:\ndef make_tree_nine() -> Node:\n    tree = Node(1)\n    tree.left = Node(2)\n    tree.right = Node(3)\n    tree.left.left = Node(4)\n    tree.left.right = Node(5)\n    tree.right.right = Node(6)\n    tree.left.left.left = Node(7)\n    tree.left.left.right = Node(8)\n    tree.left.right.right = Node(9)\n    return tree", "output": "Return a binary tree with 9 nodes that looks like this:"}
{"task": "search", "input": "search code:\nReturns nodes\n\nChoices:\n0: def discrete_cosine_transform(dct_filter_num: int, filter_num: int) -> np.ndarray:     basis = np.empty((dct_filter_num, filter_num))     basis[0, :] = 1.0 / np.sqrt(filter_num)      samples = np.arange(1, 2 * filter_num, 2) * np.pi / (2.0 * filter_num)      for i in range(1, dct_filter_num):         basis[i, :] = np.cos(i * samples) * np.sqrt(2.0 / filter_num)      return basis\n1: def get_nodes(frequency_table):     nodes = {}     for _, item in enumerate(frequency_table):         nodes.setdefault(item[2], []).append(item[0])     return nodes\n2: def duplicates_justseen(iterable, key=None):     return flatten(g for _, g in groupby(iterable, key) for _ in g)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef depth_first_search(graph: dict, start: str) -> set[str]:\n    explored, stack = set(start), [start]\n\n    while stack:\n        v = stack.pop()\n        explored.add(v)\n        # Differences from BFS:\n        # 1) pop last element instead of first one\n        # 2) add adjacent elements to stack without exploring them\n        for adj in reversed(graph[v]):\n            if adj not in explored:\n                stack.append(adj)\n    return explored", "output": "Depth First Search on Graph"}
{"task": "repair", "input": "fix bug:\ndef extended_euclidean_algorithm(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b", "output": "def extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b"}
{"task": "repair", "input": "fix bug:\ndef sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))", "output": "def sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))"}
{"task": "search", "input": "search code:\n:param gray_img: gray image\n\nChoices:\n0: def median_filter(gray_img, mask=3):     # set image borders     bd = int(mask / 2)     # copy image size     median_img = zeros_like(gray_img)     for i in range(bd, gray_img.shape[0] - bd):         for j in range(bd, gray_img.shape[1] - bd):             # get mask according with mask             kernel = ravel(gray_img[i - bd : i + bd + 1, j - bd : j + bd + 1])             # calculate mask median             median = sort(kernel)[int8(divide((multiply(mask, mask)), 2) + 1)]             median_img[i, j] = median     return median_img\n1: def decode(ciphertext: str, key: str) -> str:      table = generate_table(key)     plaintext = \"\"      for char1, char2 in chunker(ciphertext, 2):         row1, col1 = divmod(table.index(char1), 5)         row2, col2 = divmod(table.index(char2), 5)          if row1 == row2:             plaintext += table[row1 * 5 + (col1 - 1) % 5]             plaintext += table[row2 * 5 + (col2 - 1) % 5]         elif col1 == col2:             plaintext += table[((row1 - 1) % 5) * 5 + col1]             plaintext += table[((row2 - 1) % 5) * 5 + col2]         else:  # rectangle             plaintext += table[row1 * 5 + col2]             plaintext += table[row2 * 5 + col1]      return plaintext\n2: def double_linear_search(array: list[int], search_item: int) -> int:     # define the start and end index of the given array     start_ind, end_ind = 0, len(array) - 1     while start_ind <= end_ind:         if array[start_ind] == search_item:             return start_ind         elif array[end_ind] == search_item:             return end_ind         else:             start_ind += 1             end_ind -= 1     # returns -1 if search_item is not found in array     return -1", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef create_cipher_map(key: str) -> dict[str, str]:\n    # Create a list of the letters in the alphabet\n    alphabet = [chr(i + 65) for i in range(26)]\n    # Remove duplicate characters from key\n    key = remove_duplicates(key.upper())\n    offset = len(key)\n    # First fill cipher with key characters\n    cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}\n    # Then map remaining characters in alphabet to\n    # the alphabet from the beginning\n    for i in range(len(cipher_alphabet), 26):\n        char = alphabet[i - offset]\n        # Ensure we are not mapping letters to letters previously mapped\n        while char in key:\n            offset -= 1\n            char = alphabet[i - offset]\n        cipher_alphabet[alphabet[i]] = char\n    return cipher_alphabet", "output": "Returns a cipher map given a keyword."}
{"task": "summary", "input": "summarize code:\ndef area_rectangle(length: float, width: float) -> float:\n    if length < 0 or width < 0:\n        raise ValueError(\"area_rectangle() only accepts non-negative values\")\n    return length * width", "output": "Calculate the area of a rectangle."}
{"task": "detection", "input": "classify code:\ndef tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculates cosine similarity between two data.\n\nChoices:\n0: def cosine_similarity(input_a: np.ndarray, input_b: np.ndarray) -> float:     return float(np.dot(input_a, input_b) / (norm(input_a) * norm(input_b)))\n1: def knapsack(     weights: list, values: list, number_of_items: int, max_weight: int, index: int ) -> int:     if index == number_of_items:         return 0     ans1 = 0     ans2 = 0     ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)     if weights[index] <= max_weight:         ans2 = values[index] + knapsack(             weights, values, number_of_items, max_weight - weights[index], index + 1         )     return max(ans1, ans2)\n2: def binary_count_trailing_zeros(a: int) -> int:     if a < 0:         raise ValueError(\"Input value must be a positive integer\")     elif isinstance(a, float):         raise TypeError(\"Input value must be a 'int' type\")     return 0 if (a == 0) else int(log2(a & -a))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef local_weight_regression(\n    x_train: np.ndarray, y_train: np.ndarray, tau: float\n) -> np.ndarray:\n    y_pred = np.zeros(len(x_train))  # Initialize array of predictions\n    for i, item in enumerate(x_train):\n        y_pred[i] = np.dot(item, local_weight(item, x_train, y_train, tau)).item()\n\n    return y_pred", "output": "Calculate predictions for each point in the training data"}
{"task": "search", "input": "search code:\nConvert grid to a dict of possible values, {square: digits}, or\n\nChoices:\n0: def electrical_impedance(     resistance: float, reactance: float, impedance: float ) -> dict[str, float]:     if (resistance, reactance, impedance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance == 0:         return {\"resistance\": sqrt(pow(impedance, 2) - pow(reactance, 2))}     elif reactance == 0:         return {\"reactance\": sqrt(pow(impedance, 2) - pow(resistance, 2))}     elif impedance == 0:         return {\"impedance\": sqrt(pow(resistance, 2) + pow(reactance, 2))}     else:         raise ValueError(\"Exactly one argument must be 0\")\n1: def parse_grid(grid):     ## To start, every square can be any digit; then assign values from the grid.     values = dict.fromkeys(squares, digits)     for s, d in grid_values(grid).items():         if d in digits and not assign(values, s, d):             return False  ## (Fail if we can't assign d to square s.)     return values\n2: def take(n, iterable):     return list(islice(iterable, n))", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef recursive_lucas_number(n_th_number: int) -> int:\n    if not isinstance(n_th_number, int):\n        raise TypeError(\"recursive_lucas_number accepts only integer arguments.\")\n    if n_th_number == 0:\n        return 2\n    if n_th_number == 1:\n        return 1\n\n    return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(\n        n_th_number - 2\n    )", "output": "Returns the nth lucas number"}
{"task": "summary", "input": "summarize code:\ndef lanczos_iteration(\n    graph: list[list[int | None]], num_eigenvectors: int\n) -> tuple[np.ndarray, np.ndarray]:\n    num_nodes: int = len(graph)\n    if not (1 <= num_eigenvectors <= num_nodes):\n        raise ValueError(\n            \"Number of eigenvectors must be between 1 and the number of \"\n            \"nodes in the graph.\"\n        )\n\n    orthonormal_basis: np.ndarray = np.zeros((num_nodes, num_eigenvectors))\n    tridiagonal_matrix: np.ndarray = np.zeros((num_eigenvectors, num_eigenvectors))\n\n    rng = np.random.default_rng()\n    initial_vector: np.ndarray = rng.random(num_nodes)\n    initial_vector /= np.sqrt(np.dot(initial_vector, initial_vector))\n    orthonormal_basis[:, 0] = initial_vector\n\n    prev_beta: float = 0.0\n    for iter_index in range(num_eigenvectors):\n        result_vector: np.ndarray = multiply_matrix_vector(\n            graph, orthonormal_basis[:, iter_index]\n        )\n        if iter_index > 0:\n            result_vector -= prev_beta * orthonormal_basis[:, iter_index - 1]\n        alpha_value: float = np.dot(orthonormal_basis[:, iter_index], result_vector)\n        result_vector -= alpha_value * orthonormal_basis[:, iter_index]\n\n        prev_beta = np.sqrt(np.dot(result_vector, result_vector))\n        if iter_index < num_eigenvectors - 1 and prev_beta > 1e-10:\n            orthonormal_basis[:, iter_index + 1] = result_vector / prev_beta\n        tridiagonal_matrix[iter_index, iter_index] = alpha_value\n        if iter_index < num_eigenvectors - 1:\n            tridiagonal_matrix[iter_index, iter_index + 1] = prev_beta\n            tridiagonal_matrix[iter_index + 1, iter_index] = prev_beta\n    return tridiagonal_matrix, orthonormal_basis", "output": "Constructs the tridiagonal matrix and orthonormal basis vectors using the"}
{"task": "summary", "input": "summarize code:\ndef in_reverse(linked_list: LinkedList) -> str:\n    return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))", "output": "Prints the elements of the given Linked List in reverse order"}
{"task": "summary", "input": "summarize code:\ndef kth_number(lst: list[int], k: int) -> int:\n    # pick a pivot and separate into list based on pivot.\n    pivot = random_pivot(lst)\n\n    # partition based on pivot\n    # linear time\n    small = [e for e in lst if e < pivot]\n    big = [e for e in lst if e > pivot]\n\n    # if we get lucky, pivot might be the element we want.\n    # we can easily see this:\n    # small (elements smaller than k)\n    # + pivot (kth element)\n    # + big (elements larger than k)\n    if len(small) == k - 1:\n        return pivot\n    # pivot is in elements bigger than k\n    elif len(small) < k - 1:\n        return kth_number(big, k - len(small) - 1)\n    # pivot is in elements smaller than k\n    else:\n        return kth_number(small, k)", "output": "Return the kth smallest number in lst."}
{"task": "summary", "input": "summarize code:\ndef calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times", "output": "This function calculates the waiting time of some processes that have a"}
{"task": "summary", "input": "summarize code:\ndef centripetal(mass: float, velocity: float, radius: float) -> float:\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius", "output": "The Centripetal Force formula is given as: (m*v*v)/r"}
{"task": "summary", "input": "summarize code:\ndef zigzag(root: Node | None) -> Generator[int]:\n    if root is None:\n        return\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        if not flag:\n            yield from get_nodes_from_left_to_right(root, h)\n            flag = 1\n        else:\n            yield from get_nodes_from_right_to_left(root, h)\n            flag = 0", "output": "ZigZag traverse:"}
{"task": "repair", "input": "fix bug:\ndef get_check_digit(barcode: int) -> int:\n    \"\"\"\n    Returns the last digit of barcode by excluding the last digit first\n    and then computing to reach the actual last digit from the remaining\n    12 digits.\n\n    >>> get_check_digit(8718452538119)\n    9\n    >>> get_check_digit(87184523)\n    5\n    >>> get_check_digit(87193425381086)\n    9\n    >>> [get_check_digit(x) for x in range(0, 100, 10)]\n    [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]\n    \"\"\"\n    barcode //= 10  # exclude the last digit\n    checker = False\n    s = 0\n\n    # extract and check each digit\n    while barcode != 0:\n        mult = 1 if checker else 3\n        s += mult * (barcode % 10)\n        barcode //= 10\n        checker = not checker\n\n    return (10 - (s % 10)) % 10", "output": "def get_check_digit(barcode: int) -> int:\n    \"\"\"\n    Returns the last digit of barcode by excluding the last digit first\n    and then computing to reach the actual last digit from the remaining\n    12 digits.\n\n    >>> get_check_digit(8718452538119)\n    9\n    >>> get_check_digit(87184523)\n    5\n    >>> get_check_digit(87193425381086)\n    9\n    >>> [get_check_digit(x) for x in range(0, 100, 10)]\n    [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]\n    \"\"\"\n    barcode //= 10  # exclude the last digit\n    checker = False\n    s = 0\n\n    # extract and check each digit\n    while barcode != 0:\n        mult = 1 if checker else 3\n        s += mult * (barcode % 10)\n        barcode //= 10\n        checker = not checker\n\n    return (10 - (s % 10)) % 10"}
{"task": "search", "input": "search code:\nRun over all prime combinations to generate non-prime numbers.\n\nChoices:\n0: def multiply(     chain: list[int],     primes: list[int],     min_prime_idx: int,     prev_num: int,     max_num: int,     prev_sum: int,     primes_degrees: dict[int, int], ) -> None:      min_prime = primes[min_prime_idx]     num = prev_num * min_prime      min_prime_degree = primes_degrees.get(min_prime, 0)     min_prime_degree += 1     primes_degrees[min_prime] = min_prime_degree      new_sum = prev_sum * min_prime + (prev_sum + prev_num) * (min_prime - 1) // (         min_prime**min_prime_degree - 1     )     chain[num] = new_sum      for prime_idx in range(min_prime_idx, len(primes)):         if primes[prime_idx] * num > max_num:             break          multiply(             chain=chain,             primes=primes,             min_prime_idx=prime_idx,             prev_num=num,             max_num=max_num,             prev_sum=new_sum,             primes_degrees=primes_degrees.copy(),         )\n1: def astable_duty_cycle(resistance_1: float, resistance_2: float) -> float:      if resistance_1 <= 0 or resistance_2 <= 0:         raise ValueError(\"All values must be positive\")     return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100\n2: def insertion_sort[T: Comparable](collection: MutableSequence[T]) -> MutableSequence[T]:      for insert_index in range(1, len(collection)):         insert_value = collection[insert_index]         while insert_index > 0 and insert_value < collection[insert_index - 1]:             collection[insert_index] = collection[insert_index - 1]             insert_index -= 1         collection[insert_index] = insert_value     return collection", "output": "0"}
{"task": "search", "input": "search code:\nReturns the number of letters used to write all numbers from 1 to n.\n\nChoices:\n0: def different_signs(num1: int, num2: int) -> bool:     return num1 ^ num2 < 0\n1: def solution(n: int = 1000) -> int:     # number of letters in zero, one, two, ..., nineteen (0 for zero since it's     # never said aloud)     ones_counts = [0, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6, 6, 8, 8, 7, 7, 9, 8, 8]     # number of letters in twenty, thirty, ..., ninety (0 for numbers less than     # 20 due to inconsistency in teens)     tens_counts = [0, 0, 6, 6, 5, 5, 5, 7, 6, 6]      count = 0      for i in range(1, n + 1):         if i < 1000:             if i >= 100:                 # add number of letters for \"n hundred\"                 count += ones_counts[i // 100] + 7                  if i % 100 != 0:                     # add number of letters for \"and\" if number is not multiple                     # of 100                     count += 3              if 0 < i % 100 < 20:                 # add number of letters for one, two, three, ..., nineteen                 # (could be combined with below if not for inconsistency in                 # teens)                 count += ones_counts[i % 100]             else:                 # add number of letters for twenty, twenty one, ..., ninety                 # nine                 count += ones_counts[i % 10]                 count += tens_counts[(i % 100 - i % 10) // 10]         else:             count += ones_counts[i // 1000] + 8     return count\n2: def permutation_index(element, iterable):     index = 0     pool = list(iterable)     for i, x in zip(range(len(pool), -1, -1), element):         r = pool.index(x)         index = index * i + r         del pool[r]      return index", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:\n    dices = [Dice() for i in range(num_dice)]\n    count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)\n    for _ in range(num_throws):\n        count_of_sum[sum(dice.roll() for dice in dices)] += 1\n    probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]\n    return probability[num_dice:]  # remove probability of sums that never appear", "output": "Return probability list of all possible sums when throwing dice."}
{"task": "search", "input": "search code:\nBounds for the nth prime (counting from 1): lb < p_n < ub.\n\nChoices:\n0: def _nth_prime_bounds(n):     # At and above 688,383, the lb/ub spread is under 0.003 * p_n.      if n < 1:         raise ValueError      if n < 6:         return (n, 2.25 * n)      # https://en.wikipedia.org/wiki/Prime-counting_function#Inequalities     upper_bound = n * log(n * log(n))     lower_bound = upper_bound - n     if n >= 688_383:         upper_bound -= n * (1.0 - (log(log(n)) - 2.0) / log(n))      return lower_bound, upper_bound\n1: def solution(n: int = 600851475143) -> int:      try:         n = int(n)     except (TypeError, ValueError):         raise TypeError(\"Parameter n must be int or castable to int.\")     if n <= 0:         raise ValueError(\"Parameter n must be greater than or equal to one.\")     i = 2     ans = 0     if n == 2:         return 2     while n > 2:         while n % i != 0:             i += 1         ans = i         while n % i == 0:             n = n // i         i += 1     return int(ans)\n2: def solution(n: int = 10000) -> int:     total = sum(         i         for i in range(1, n)         if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i     )     return total", "output": "0"}
{"task": "search", "input": "search code:\nYield lists of items from *iterable*, where each list ends just before\n\nChoices:\n0: def split_before(iterable, pred, maxsplit=-1):     if maxsplit == 0:         yield list(iterable)         return      buf = []     it = iter(iterable)     for item in it:         if pred(item) and buf:             yield buf             if maxsplit == 1:                 yield [item, *it]                 return             buf = []             maxsplit -= 1         buf.append(item)     if buf:         yield buf\n1: def validate_initial_digits(credit_card_number: str) -> bool:     return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))\n2: def download_image(url: str) -> str:     try:         response = httpx.get(url, timeout=10)         response.raise_for_status()     except httpx.RequestError as e:         return f\"An error occurred during the HTTP request to {url}: {e!r}\"      soup = BeautifulSoup(response.text, \"html.parser\")     image_meta_tag = soup.find(\"meta\", {\"property\": \"og:image\"})     if not image_meta_tag:         return \"No meta tag with property 'og:image' was found.\"      image_url = image_meta_tag.get(\"content\")     if not image_url:         return f\"Image URL not found in meta tag {image_meta_tag}.\"      try:         image_data = httpx.get(image_url, timeout=10).content     except httpx.RequestError as e:         return f\"An error occurred during the HTTP request to {image_url}: {e!r}\"     if not image_data:         return f\"Failed to download the image from {image_url}.\"      file_name = f\"{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H-%M-%S}.jpg\"     with open(file_name, \"wb\") as out_file:         out_file.write(image_data)     return f\"Image downloaded and saved in the file {file_name}\"", "output": "0"}
{"task": "search", "input": "search code:\nCalculation Gregorian easter date for given year\n\nChoices:\n0: def sliding_window(iterable, n):     if n > 20:         return _sliding_window_deque(iterable, n)     elif n > 2:         return _sliding_window_islice(iterable, n)     elif n == 2:         return pairwise(iterable)     elif n == 1:         return zip(iterable)     else:         raise ValueError(f'n should be at least one, not {n}')\n1: def integer_square_root(num: int) -> int:     if not isinstance(num, int) or num < 0:         raise ValueError(\"num must be non-negative integer\")      if num < 2:         return num      left_bound = 0     right_bound = num // 2      while left_bound <= right_bound:         mid = left_bound + (right_bound - left_bound) // 2         mid_squared = mid * mid         if mid_squared == num:             return mid          if mid_squared < num:             left_bound = mid + 1         else:             right_bound = mid - 1      return right_bound\n2: def gauss_easter(year: int) -> datetime:     metonic_cycle = year % 19     julian_leap_year = year % 4     non_leap_year = year % 7     leap_day_inhibits = math.floor(year / 100)     lunar_orbit_correction = math.floor((13 + 8 * leap_day_inhibits) / 25)     leap_day_reinstall_number = leap_day_inhibits / 4     secular_moon_shift = (         15 - lunar_orbit_correction + leap_day_inhibits - leap_day_reinstall_number     ) % 30     century_starting_point = (4 + leap_day_inhibits - leap_day_reinstall_number) % 7      # days to be added to March 21     days_to_add = (19 * metonic_cycle + secular_moon_shift) % 30      # PHM -> Paschal Full Moon     days_from_phm_to_sunday = (         2 * julian_leap_year         + 4 * non_leap_year         + 6 * days_to_add         + century_starting_point     ) % 7      if days_to_add == 29 and days_from_phm_to_sunday == 6:         return datetime(year, 4, 19, tzinfo=UTC)     elif days_to_add == 28 and days_from_phm_to_sunday == 6:         return datetime(year, 4, 18, tzinfo=UTC)     else:         return datetime(year, 3, 22, tzinfo=UTC) + timedelta(             days=int(days_to_add + days_from_phm_to_sunday)         )", "output": "2"}
{"task": "search", "input": "search code:\nImplement sin function.\n\nChoices:\n0: def inspect_formatargspec(         args, varargs=None, varkw=None, defaults=None,         kwonlyargs=(), kwonlydefaults={}, annotations={},         formatarg=str,         formatvarargs=lambda name: '*' + name,         formatvarkw=lambda name: '**' + name,         formatvalue=lambda value: '=' + repr(value),         formatreturns=lambda text: ' -> ' + text,         formatannotation=formatannotation):      def formatargandannotation(arg):         result = formatarg(arg)         if arg in annotations:             result += ': ' + formatannotation(annotations[arg])         return result     specs = []     if defaults:         firstdefault = len(args) - len(defaults)     for i, arg in enumerate(args):         spec = formatargandannotation(arg)         if defaults and i >= firstdefault:             spec = spec + formatvalue(defaults[i - firstdefault])         specs.append(spec)     if varargs is not None:         specs.append(formatvarargs(formatargandannotation(varargs)))     else:         if kwonlyargs:             specs.append('*')     if kwonlyargs:         for kwonlyarg in kwonlyargs:             spec = formatargandannotation(kwonlyarg)             if kwonlydefaults and kwonlyarg in kwonlydefaults:                 spec += formatvalue(kwonlydefaults[kwonlyarg])             specs.append(spec)     if varkw is not None:         specs.append(formatvarkw(formatargandannotation(varkw)))     result = '(' + ', '.join(specs) + ')'     if 'return' in annotations:         result += formatreturns(formatannotation(annotations['return']))     return result\n1: def find_min_iterative(nums: list[int | float]) -> int | float:     if len(nums) == 0:         raise ValueError(\"find_min_iterative() arg is an empty sequence\")     min_num = nums[0]     for num in nums:         min_num = min(min_num, num)     return min_num\n2: def sin(     angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10 ) -> float:     # Simplify the angle to be between 360 and -360 degrees.     angle_in_degrees = angle_in_degrees - ((angle_in_degrees // 360.0) * 360.0)      # Converting from degrees to radians     angle_in_radians = radians(angle_in_degrees)      result = angle_in_radians     a = 3     b = -1      for _ in range(accuracy):         result += (b * (angle_in_radians**a)) / factorial(a)          b = -b  # One positive term and the next will be negative and so on...         a += 2  # Increased by 2 for every term.      return round(result, rounded_values_count)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef get_totients(max_one: int) -> list[int]:\n    totients = np.arange(max_one)\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            x = np.arange(i, max_one, i)  # array of indexes to select\n            totients[x] -= totients[x] // i\n\n    return totients.tolist()", "output": "Calculates a list of totients from 0 to max_one exclusive, using the"}
{"task": "detection", "input": "classify code:\ndef choose(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n    >>> choose(4,2)\n    6\n    >>> choose(5,3)\n    10\n    >>> choose(20,6)\n    38760\n    \"\"\"\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns the sum of squarefrees for a given Pascal's Triangle of depth n.\n\nChoices:\n0: def solution(n: int = 51) -> int:     unique_coefficients = get_pascal_triangle_unique_coefficients(n)     squarefrees = get_squarefrees(unique_coefficients)     return sum(squarefrees)\n1: def rec_insertion_sort(collection: list, n: int):     # Checks if the entire collection has been sorted     if len(collection) <= 1 or n <= 1:         return      insert_next(collection, n - 1)     rec_insertion_sort(collection, n - 1)\n2: def base16_decode(data: str) -> bytes:     # Check data validity, following RFC3548     # https://www.ietf.org/rfc/rfc3548.txt     if (len(data) % 2) != 0:         raise ValueError(         )     # Check the character set - the standard base16 alphabet     # is uppercase according to RFC3548 section 6     if not set(data) <= set(\"0123456789ABCDEF\"):         raise ValueError(         )     # For every two hexadecimal digits (= a byte), turn it into an integer.     # Then, string the result together into bytes, and return it.     return bytes(int(data[i] + data[i + 1], 16) for i in range(0, len(data), 2))", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef track_edge(image_shape, destination, weak, strong):\n    for row in range(1, image_shape[0]):\n        for col in range(1, image_shape[1]):\n            if destination[row, col] == weak:\n                if 255 in (\n                    destination[row, col + 1],\n                    destination[row, col - 1],\n                    destination[row - 1, col],\n                    destination[row + 1, col],\n                    destination[row - 1, col - 1],\n                    destination[row + 1, col - 1],\n                    destination[row - 1, col + 1],\n                    destination[row + 1, col + 1],\n                ):\n                    destination[row, col] = strong\n                else:\n                    destination[row, col] = 0", "output": "Edge tracking. Usually a weak edge pixel caused from true edges will be connected"}
{"task": "detection", "input": "classify code:\ndef dp_match(text: str, pattern: str) -> bool:\n    r\"\"\"\n    Dynamic programming matching algorithm.\n\n    | Time complexity: O(\\|text\\| * \\|pattern\\|)\n    | Space complexity: O(\\|text\\| * \\|pattern\\|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef equated_monthly_installments(\n    principal: float, rate_per_annum: float, years_to_repay: int\n) -> float:\n    if principal <= 0:\n        raise Exception(\"Principal borrowed must be > 0\")\n    if rate_per_annum < 0:\n        raise Exception(\"Rate of interest must be >= 0\")\n    if years_to_repay <= 0 or not isinstance(years_to_repay, int):\n        raise Exception(\"Years to repay must be an integer > 0\")\n\n    # Yearly rate is divided by 12 to get monthly rate\n    rate_per_month = rate_per_annum / 12\n\n    # Years to repay is multiplied by 12 to get number of payments as payment is monthly\n    number_of_payments = years_to_repay * 12\n\n    return (\n        principal\n        * rate_per_month\n        * (1 + rate_per_month) ** number_of_payments\n        / ((1 + rate_per_month) ** number_of_payments - 1)\n    )", "output": "Formula for amortization amount per month:"}
{"task": "detection", "input": "classify code:\ndef lin_search(left: int, right: int, array: List[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef sdbm(plain_text: str) -> int:\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value", "output": "Function implements sdbm hash, easy to use, great for bits scrambling."}
{"task": "summary", "input": "summarize code:\ndef build_kdtree(points: list[list[float]], depth: int = 0) -> KDNode | None:\n    if not points:\n        return None\n\n    k = len(points[0])  # Dimensionality of the points\n    axis = depth % k\n\n    # Sort point list and choose median as pivot element\n    points.sort(key=lambda point: point[axis])\n    median_idx = len(points) // 2\n\n    # Create node and construct subtrees\n    left_points = points[:median_idx]\n    right_points = points[median_idx + 1 :]\n\n    return KDNode(\n        point=points[median_idx],\n        left=build_kdtree(left_points, depth + 1),\n        right=build_kdtree(right_points, depth + 1),\n    )", "output": "Builds a KD-Tree from a list of points."}
{"task": "summary", "input": "summarize code:\ndef consumer(func):\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        gen = func(*args, **kwargs)\n        next(gen)\n        return gen\n\n    return wrapper", "output": "Decorator that automatically advances a PEP-342-style \"reverse iterator\""}
{"task": "summary", "input": "summarize code:\ndef solution():\n    days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    day = 6\n    month = 1\n    year = 1901\n\n    sundays = 0\n\n    while year < 2001:\n        day += 7\n\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            if day > days_per_month[month - 1] and month != 2:\n                month += 1\n                day = day - days_per_month[month - 2]\n            elif day > 29 and month == 2:\n                month += 1\n                day = day - 29\n        elif day > days_per_month[month - 1]:\n            month += 1\n            day = day - days_per_month[month - 2]\n\n        if month > 12:\n            year += 1\n            month = 1\n\n        if year < 2001 and day == 1:\n            sundays += 1\n    return sundays", "output": "Returns the number of mondays that fall on the first of the month during"}
{"task": "search", "input": "search code:\nunquote_to_bytes('abc%20def') -> b'abc def'.\n\nChoices:\n0: def solution():     total_sum = 0     temp_sum = 0     with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:         name = str(file.readlines()[0])         name = name.replace('\"', \"\").split(\",\")      name.sort()     for i in range(len(name)):         for j in name[i]:             temp_sum += ord(j) - ord(\"A\") + 1         total_sum += (i + 1) * temp_sum         temp_sum = 0     return total_sum\n1: def unquote_to_bytes(string):     # Note: strings are encoded as UTF-8. This is only an issue if it contains     # unescaped non-ASCII characters, which URIs should not.     if not string:         # Is it a string-like object?         string.split         return b''     if isinstance(string, str):         string = string.encode('utf-8')     bits = string.split(b'%')     if len(bits) == 1:         return string     # import pdb;pdb.set_trace()     res = [bits[0]]     append = res.append      for item in bits[1:]:         try:             append(_HEX_CHAR_MAP[item[:2]])             append(item[2:])         except KeyError:             append(b'%')             append(item)     return b''.join(res)\n2: def generate_first_solution(path, dict_of_neighbours):      with open(path) as f:         start_node = f.read(1)     end_node = start_node      first_solution = []      visiting = start_node      distance_of_first_solution = 0     while visiting not in first_solution:         minim = 10000         for k in dict_of_neighbours[visiting]:             if int(k[1]) < int(minim) and k[0] not in first_solution:                 minim = k[1]                 best_node = k[0]          first_solution.append(visiting)         distance_of_first_solution = distance_of_first_solution + int(minim)         visiting = best_node      first_solution.append(end_node)      position = 0     for k in dict_of_neighbours[first_solution[-2]]:         if k[0] == start_node:             break         position += 1      distance_of_first_solution = (         distance_of_first_solution         + int(dict_of_neighbours[first_solution[-2]][position][1])         - 10000     )     return first_solution, distance_of_first_solution", "output": "1"}
{"task": "detection", "input": "classify code:\ndef pigeon_sort(array):\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if(len(array) == 0):\n        return array\n\n    # Manually finds the minimum and maximum of the array.\n    min = array[0]\n    max = array[0]\n\n    for i in range(len(array)):\n        if(array[i] < min): min = array[i]\n        elif(array[i] > max): max = array[i]\n\n    # Compute the variables\n    holes_range = max-min + 1\n    holes = [0 for _ in range(holes_range)]\n    holes_repeat = [0 for _ in range(holes_range)]\n\n    # Make the sorting.\n    for i in range(len(array)):\n        index = array[i] - min\n        if(holes[index] != array[i]):\n            holes[index] = array[i]\n            holes_repeat[index] += 1\n        else: holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while(holes_repeat[i] > 0):\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nPrint the Results of Various Volume Calculations.\n\nChoices:\n0: def running_key_decrypt(key: str, ciphertext: str) -> str:     ciphertext = ciphertext.replace(\" \", \"\").upper()     key = key.replace(\" \", \"\").upper()     key_length = len(key)     plaintext = []     ord_a = ord(\"A\")      for i, char in enumerate(ciphertext):         c = ord(char) - ord_a         k = ord(key[i % key_length]) - ord_a         p = (c - k) % 26         plaintext.append(chr(p + ord_a))      return \"\".join(plaintext)\n1: def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:     r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]     return 0.2989 * r + 0.5870 * g + 0.1140 * b\n2: def main():     print(\"Volumes:\")     print(f\"Cube: {vol_cube(2) = }\")  # = 8     print(f\"Cuboid: {vol_cuboid(2, 2, 2) = }\")  # = 8     print(f\"Cone: {vol_cone(2, 2) = }\")  # ~= 1.33     print(f\"Right Circular Cone: {vol_right_circ_cone(2, 2) = }\")  # ~= 8.38     print(f\"Prism: {vol_prism(2, 2) = }\")  # = 4     print(f\"Pyramid: {vol_pyramid(2, 2) = }\")  # ~= 1.33     print(f\"Sphere: {vol_sphere(2) = }\")  # ~= 33.5     print(f\"Hemisphere: {vol_hemisphere(2) = }\")  # ~= 16.75     print(f\"Circular Cylinder: {vol_circular_cylinder(2, 2) = }\")  # ~= 25.1     print(f\"Torus: {vol_torus(2, 2) = }\")  # ~= 157.9     print(f\"Conical Frustum: {vol_conical_frustum(2, 2, 4) = }\")  # ~= 58.6     print(f\"Spherical cap: {vol_spherical_cap(1, 2) = }\")  # ~= 5.24     print(f\"Spheres intersection: {vol_spheres_intersect(2, 2, 1) = }\")  # ~= 21.21     print(f\"Spheres union: {vol_spheres_union(2, 2, 1) = }\")  # ~= 45.81     print(         f\"Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }\"     )  # ~= 28.3     print(f\"Icosahedron: {vol_icosahedron(2.5) = }\")  # ~=34.09", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef upf_len(num: int) -> int:\n    return len(unique_prime_factors(num))", "output": "Memoize upf() length results for a given value."}
{"task": "detection", "input": "classify code:\ndef gnome_sort(unsorted):\n    \"\"\"Pure implementation of the gnome sort algorithm in Python.\"\"\"\n    if len(unsorted) <= 1:\n        return unsorted\n\n    i = 1\n\n    while i < len(unsorted):\n        if unsorted[i - 1] <= unsorted[i]:\n            i += 1\n        else:\n            unsorted[i - 1], unsorted[i] = unsorted[i], unsorted[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = array[i:]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "Some examples"}
{"task": "search", "input": "search code:\nReturns number with the specified format, clamped between floor and ceil.\n\nChoices:\n0: def count_inversions_bf(arr):      num_inversions = 0     n = len(arr)      for i in range(n - 1):         for j in range(i + 1, n):             if arr[i] > arr[j]:                 num_inversions += 1      return num_inversions\n1: def clamp(value, format=\"{:}\", floor=None, ceil=None, floor_token=\"<\", ceil_token=\">\"):     if value is None:         return None      if floor is not None and value < floor:         value = floor         token = floor_token     elif ceil is not None and value > ceil:         value = ceil         token = ceil_token     else:         token = \"\"      if isinstance(format, str):         return token + format.format(value)     elif callable(format):         return token + format(value)     else:         raise ValueError(             \"Invalid format. Must be either a valid formatting string, or a function \"             \"that accepts value and returns a string.\"         )\n2: def xnor_gate(input_1: int, input_2: int) -> int:     return 1 if input_1 == input_2 else 0", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef _running_median_windowed(iterator, maxlen):\n    \"Yield median of values in a sliding window.\"\n\n    window = deque()\n    ordered = []\n\n    for x in iterator:\n        window.append(x)\n        insort(ordered, x)\n\n        if len(ordered) > maxlen:\n            i = bisect_left(ordered, window.popleft())\n            del ordered[i]\n\n        n = len(ordered)\n        m = n // 2\n        yield ordered[m] if n & 1 else (ordered[m - 1] + ordered[m]) / 2", "output": "Yield median of values in a sliding window."}
{"task": "summary", "input": "summarize code:\ndef polynomial_from_roots(roots):\n\n    # This recipe differs from the one in itertools docs in that it\n    # applies list() after each call to convolve().  This avoids\n    # hitting stack limits with nested generators.\n\n    poly = [1]\n    for root in roots:\n        poly = list(convolve(poly, (1, -root)))\n    return poly", "output": "Compute a polynomial's coefficients from its roots."}
{"task": "search", "input": "search code:\nCalculate the turn around time of each Processes\n\nChoices:\n0: def wave(txt: str) -> list:      return [         txt[:a] + txt[a].upper() + txt[a + 1 :]         for a in range(len(txt))         if txt[a].isalpha()     ]\n1: def chain_length(n: int, previous: set | None = None) -> int:     previous = previous or set()     if n in CHAIN_LENGTH_CACHE:         return CHAIN_LENGTH_CACHE[n]     next_number = sum_digit_factorials(n)     if next_number in previous:         CHAIN_LENGTH_CACHE[n] = 0         return 0     else:         previous.add(n)         ret = 1 + chain_length(next_number, previous)         CHAIN_LENGTH_CACHE[n] = ret         return ret\n2: def calculate_turnaroundtime(     burst_time: list[int], no_of_processes: int, waiting_time: list[int] ) -> list[int]:     turn_around_time = [0] * no_of_processes     for i in range(no_of_processes):         turn_around_time[i] = burst_time[i] + waiting_time[i]     return turn_around_time", "output": "2"}
{"task": "search", "input": "search code:\nReturns the count of all lychrel numbers below limit.\n\nChoices:\n0: def _abs_timedelta(delta):     if delta.days < 0:         now = _now()         return now - (now + delta)     return delta\n1: def solution(num: int = 100) -> int:     nfact = factorial(num)     result = split_and_add(nfact)     return result\n2: def solution(limit: int = 10000) -> int:     lychrel_nums = []     for num in range(1, limit):         iterations = 0         a = num         while iterations < 50:             num = sum_reverse(num)             iterations += 1             if is_palindrome(num):                 break         else:             lychrel_nums.append(a)     return len(lychrel_nums)", "output": "2"}
{"task": "search", "input": "search code:\nA Palindrome is a String that reads the same forward as it does backwards.\n\nChoices:\n0: def can_string_be_rearranged_as_palindrome(input_str: str = \"\") -> bool:     if len(input_str) == 0:         return True     lower_case_input_str = input_str.replace(\" \", \"\").lower()     # character_freq_dict: Stores the frequency of every character in the input string     character_freq_dict: dict[str, int] = {}      for character in lower_case_input_str:         character_freq_dict[character] = character_freq_dict.get(character, 0) + 1     odd_char = 0      for character_count in character_freq_dict.values():         if character_count % 2:             odd_char += 1     return not odd_char > 1\n1: def cramers_rule_2x2(equation1: list[int], equation2: list[int]) -> tuple[float, float]:      # Check if the input is valid     if not len(equation1) == len(equation2) == 3:         raise ValueError(\"Please enter a valid equation.\")     if equation1[0] == equation1[1] == equation2[0] == equation2[1] == 0:         raise ValueError(\"Both a & b of two equations can't be zero.\")      # Extract the coefficients     a1, b1, c1 = equation1     a2, b2, c2 = equation2      # Calculate the determinants of the matrices     determinant = a1 * b2 - a2 * b1     determinant_x = c1 * b2 - c2 * b1     determinant_y = a1 * c2 - a2 * c1      # Check if the system of linear equations has a solution (using Cramer's rule)     if determinant == 0:         if determinant_x == determinant_y == 0:             raise ValueError(\"Infinite solutions. (Consistent system)\")         else:             raise ValueError(\"No solution. (Inconsistent system)\")     elif determinant_x == determinant_y == 0:         # Trivial solution (Inconsistent system)         return (0.0, 0.0)     else:         x = determinant_x / determinant         y = determinant_y / determinant         # Non-Trivial Solution (Consistent system)         return (x, y)\n2: def is_carmichael_number(n: int) -> bool:      if n <= 0 or not isinstance(n, int):         msg = f\"Number {n} must instead be a positive integer\"         raise ValueError(msg)      return all(         power(b, n - 1, n) == 1         for b in range(2, n)         if greatest_common_divisor(b, n) == 1     )", "output": "0"}
{"task": "search", "input": "search code:\nPre-order traversal visits root node, left subtree, right subtree.\n\nChoices:\n0: def partitions(iterable):     sequence = list(iterable)     n = len(sequence)     for i in powerset(range(1, n)):         yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]\n1: def mbd(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     numerator = np.sum(difference) / len(predict)     denumerator = np.sum(actual) / len(predict)     # print(numerator, denumerator)     score = float(numerator) / denumerator * 100      return score\n2: def preorder(root: Node | None) -> Generator[int]:     if not root:         return     yield root.data     yield from preorder(root.left)     yield from preorder(root.right)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef base16_encode(data: bytes) -> str:\n    # Turn the data into a list of integers (where each integer is a byte),\n    # Then turn each byte into its hexadecimal representation, make sure\n    # it is uppercase, and then join everything together and return it.\n    return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])", "output": "Encodes the given bytes into base16."}
{"task": "search", "input": "search code:\nDecode the input string using the provided key.\n\nChoices:\n0: def decode(ciphertext: str, key: str) -> str:      table = generate_table(key)     plaintext = \"\"      for char1, char2 in chunker(ciphertext, 2):         row1, col1 = divmod(table.index(char1), 5)         row2, col2 = divmod(table.index(char2), 5)          if row1 == row2:             plaintext += table[row1 * 5 + (col1 - 1) % 5]             plaintext += table[row2 * 5 + (col2 - 1) % 5]         elif col1 == col2:             plaintext += table[((row1 - 1) % 5) * 5 + col1]             plaintext += table[((row2 - 1) % 5) * 5 + col2]         else:  # rectangle             plaintext += table[row1 * 5 + col2]             plaintext += table[row2 * 5 + col1]      return plaintext\n1: def bisection(function: Callable[[float], float], a: float, b: float) -> float:     start: float = a     end: float = b     if function(a) == 0:  # one of the a or b is a root for the function         return a     elif function(b) == 0:         return b     elif (         function(a) * function(b) > 0     ):  # if none of these are root and they are both positive or negative,         # then this algorithm can't find the root         raise ValueError(\"could not find root in given interval.\")     else:         mid: float = start + (end - start) / 2.0         while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7             if function(mid) == 0:                 return mid             elif function(mid) * function(start) < 0:                 end = mid             else:                 start = mid             mid = start + (end - start) / 2.0         return mid\n2: def pretty_print(n):     if n <= 0:         return \"       ...       ....        nothing printing :(\"     upper_half = floyd(n)  # upper half     lower_half = reverse_floyd(n)  # lower half     return upper_half + lower_half", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef pluralize(word):\n    orig_word, word = word, word.strip().lower()\n    if not word or word in _IRR_P2S:\n        return orig_word\n    irr_plural = _IRR_S2P.get(word)\n    if irr_plural:\n        plural = irr_plural\n    elif word.endswith('y') and word[-2:-1] not in 'aeiou':\n        plural = word[:-1] + 'ies'\n    elif word[-1] == 's' or word.endswith('ch') or word.endswith('sh'):\n        plural = word if word.endswith('es') else word + 'es'\n    else:\n        plural = word + 's'\n    return _match_case(orig_word, plural)", "output": "Semi-intelligently converts an English *word* from singular form to"}
{"task": "detection", "input": "classify code:\ndef edit_distance(source: str, target: str) -> int:\n    \"\"\"\n    Edit distance algorithm is a string metric, i.e., it is a way of quantifying how\n    dissimilar two strings are to one another. It is measured by counting the minimum\n    number of operations required to transform one string into another.\n\n    This implementation assumes that the cost of operations (insertion, deletion and\n    substitution) is always 1\n\n    Args:\n    source: the initial string with respect to which we are calculating the edit\n        distance for the target\n    target: the target string, formed after performing n operations on the source string\n\n    >>> edit_distance(\"GATTIC\", \"GALTIC\")\n    1\n    >>> edit_distance(\"NUM3\", \"HUM2\")\n    2\n    >>> edit_distance(\"cap\", \"CAP\")\n    3\n    >>> edit_distance(\"Cat\", \"\")\n    3\n    >>> edit_distance(\"cat\", \"cat\")\n    0\n    >>> edit_distance(\"\", \"123456789\")\n    9\n    >>> edit_distance(\"Be@uty\", \"Beautyyyy!\")\n    5\n    >>> edit_distance(\"lstring\", \"lsstring\")\n    1\n    \"\"\"\n    if len(source) == 0:\n        return len(target)\n    elif len(target) == 0:\n        return len(source)\n\n    delta = int(source[-1] != target[-1])  # Substitution\n    return min(\n        edit_distance(source[:-1], target[:-1]) + delta,\n        edit_distance(source, target[:-1]) + 1,\n        edit_distance(source[:-1], target) + 1,\n    )", "output": "BUGGY"}
{"task": "search", "input": "search code:\nApproximate the derivative of a function f(x) at a point x using the finite\n\nChoices:\n0: def solution(ratio: float = 0.1) -> int:      j = 3     primes = 3      while primes / (2 * j - 1) >= ratio:         for i in range(j * j + j + 1, (j + 2) * (j + 2), j + 1):             primes += is_prime(i)         j += 2     return j\n1: def calc_derivative(f: RealFunc, x: float, delta_x: float = 1e-3) -> float:     return (f(x + delta_x / 2) - f(x - delta_x / 2)) / delta_x\n2: def solution():     i = 1      while True:         if (             sorted(str(i))             == sorted(str(2 * i))             == sorted(str(3 * i))             == sorted(str(4 * i))             == sorted(str(5 * i))             == sorted(str(6 * i))         ):             return i          i += 1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef change_contrast(img: Image, level: int) -> Image:\n    factor = (259 * (level + 255)) / (255 * (259 - level))\n\n    def contrast(c: int) -> int:\n        return int(128 + factor * (c - 128))\n\n    return img.point(contrast)", "output": "Function to change contrast"}
{"task": "search", "input": "search code:\nCompute a polynomial's coefficients from its roots.\n\nChoices:\n0: def power_of_4(number: int) -> bool:     if not isinstance(number, int):         raise TypeError(\"number must be an integer\")     if number <= 0:         raise ValueError(\"number must be positive\")     if number & (number - 1) == 0:         c = 0         while number:             c += 1             number >>= 1         return c % 2 == 1     else:         return False\n1: def polynomial_from_roots(roots):      # This recipe differs from the one in itertools docs in that it     # applies list() after each call to convolve().  This avoids     # hitting stack limits with nested generators.      poly = [1]     for root in roots:         poly = list(convolve(poly, (1, -root)))     return poly\n2: def solution(base: int = 800800, degree: int = 800800) -> int:      upper_bound = degree * log2(base)     max_prime = int(upper_bound)     prime_numbers = calculate_prime_numbers(max_prime)      hybrid_integers_count = 0     left = 0     right = len(prime_numbers) - 1     while left < right:         while (             prime_numbers[right] * log2(prime_numbers[left])             + prime_numbers[left] * log2(prime_numbers[right])             > upper_bound         ):             right -= 1         hybrid_integers_count += right - left         left += 1      return hybrid_integers_count", "output": "1"}
{"task": "search", "input": "search code:\nDownload the data from source url, unless it's already here.\n\nChoices:\n0: def _date_and_delta(value, *, now=None):     if not now:         now = _now()     if isinstance(value, dt.datetime):         date = value         delta = now - value     elif isinstance(value, dt.timedelta):         date = now - value         delta = value     else:         try:             value = int(value)             delta = dt.timedelta(seconds=value)             date = now - delta         except (ValueError, TypeError):             return None, value     return date, _abs_timedelta(delta)\n1: def _maybe_download(filename, work_directory, source_url):     if not gfile.Exists(work_directory):         gfile.MakeDirs(work_directory)     filepath = os.path.join(work_directory, filename)     if not gfile.Exists(filepath):         urllib.request.urlretrieve(source_url, filepath)  # noqa: S310         with gfile.GFile(filepath) as f:             size = f.size()         print(\"Successfully downloaded\", filename, size, \"bytes.\")     return filepath\n2: def swap_odd_even_bits(num: int) -> int:     # Get all even bits - 0xAAAAAAAA is a 32-bit number with all even bits set to 1     even_bits = num & 0xAAAAAAAA      # Get all odd bits - 0x55555555 is a 32-bit number with all odd bits set to 1     odd_bits = num & 0x55555555      # Right shift even bits and left shift odd bits and swap them     return even_bits >> 1 | odd_bits << 1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef quick_sort_3partition(sorting: list, left: int, right: int) -> None:\n    if right <= left:\n        return\n    a = i = left\n    b = right\n    pivot = sorting[left]\n    while i <= b:\n        if sorting[i] < pivot:\n            sorting[a], sorting[i] = sorting[i], sorting[a]\n            a += 1\n            i += 1\n        elif sorting[i] > pivot:\n            sorting[b], sorting[i] = sorting[i], sorting[b]\n            b -= 1\n        else:\n            i += 1\n    quick_sort_3partition(sorting, left, a - 1)\n    quick_sort_3partition(sorting, b + 1, right)", "output": "\""}
{"task": "search", "input": "search code:\nReturns the number of different ways can the grey tiles in a row\n\nChoices:\n0: def _construct_points(     list_of_tuples: list[Point] | list[list[float]] | Iterable[list[float]], ) -> list[Point]:      points: list[Point] = []     if list_of_tuples:         for p in list_of_tuples:             if isinstance(p, Point):                 points.append(p)             else:                 try:                     points.append(Point(p[0], p[1]))                 except (IndexError, TypeError):                     print(                         f\"Ignoring deformed point {p}. All points\"                         \" must have at least 2 coordinates.\"                     )     return points\n1: def solution(n_limit: int = 50 * 10**6) -> int:     n_sol = [0] * n_limit      for delta in range(1, (n_limit + 1) // 4 + 1):         for y in range(4 * delta - 1, delta, -1):             n = y * (4 * delta - y)             if n >= n_limit:                 break             n_sol[n] += 1      ans = 0     for i in range(n_limit):         if n_sol[i] == 1:             ans += 1      return ans\n2: def solution(length: int = 50) -> int:      different_colour_ways_number = [[0] * 3 for _ in range(length + 1)]      for row_length in range(length + 1):         for tile_length in range(2, 5):             for tile_start in range(row_length - tile_length + 1):                 different_colour_ways_number[row_length][tile_length - 2] += (                     different_colour_ways_number[row_length - tile_start - tile_length][                         tile_length - 2                     ]                     + 1                 )      return sum(different_colour_ways_number[length])", "output": "2"}
{"task": "search", "input": "search code:\nA B\n\nChoices:\n0: def example(wav_file_path: str = \"./path-to-file/sample.wav\") -> np.ndarray:     from scipy.io import wavfile      # Load the audio from the WAV file     sample_rate, audio = wavfile.read(wav_file_path)      # Calculate MFCCs     return mfcc(audio, sample_rate)\n1: def solution():     total_sum = 0     temp_sum = 0     with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:         name = str(file.readlines()[0])         name = name.replace('\"', \"\").split(\",\")      name.sort()     for i in range(len(name)):         for j in name[i]:             temp_sum += ord(j) - ord(\"A\") + 1         total_sum += (i + 1) * temp_sum         temp_sum = 0     return total_sum\n2: def right_rotation(node: MyNode) -> MyNode:     print(\"left rotation node:\", node.get_data())     ret = node.get_left()     assert ret is not None     node.set_left(ret.get_right())     ret.set_right(node)     h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1     node.set_height(h1)     h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1     ret.set_height(h2)     return ret", "output": "2"}
{"task": "search", "input": "search code:\nSets the default exception hook :func:`sys.excepthook` to the\n\nChoices:\n0: def solution():     total = 0     for i in range(1, 1001):         total += i**i     return str(total)[-10:]\n1: def solution(numerator: int = 3, denominator: int = 7, limit: int = 1000000) -> int:     max_numerator = 0     max_denominator = 1      for current_denominator in range(1, limit + 1):         current_numerator = current_denominator * numerator // denominator         if current_denominator % denominator == 0:             current_numerator -= 1         if current_numerator * max_denominator > current_denominator * max_numerator:             max_numerator = current_numerator             max_denominator = current_denominator     return max_numerator\n2: def fix_print_exception():     sys.excepthook = print_exception", "output": "2"}
{"task": "search", "input": "search code:\nConvert a given positive decimal integer to base 'base'.\n\nChoices:\n0: def validate(n: int) -> bool:     return not (         len(str(n)) > 3         and (not is_prime(int(str(n)[-3:])) or not is_prime(int(str(n)[:3])))     )\n1: def solution() -> int:     limit = 7 * factorial(9) + 1     return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)\n2: def int_to_base(number: int, base: int) -> str:      if base < 2 or base > 36:         raise ValueError(\"'base' must be between 2 and 36 inclusive\")      digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"     result = \"\"      if number < 0:         raise ValueError(\"number must be a positive integer\")      while number > 0:         number, remainder = divmod(number, base)         result = digits[remainder] + result      if result == \"\":         result = \"0\"      return result", "output": "2"}
{"task": "search", "input": "search code:\nImplements the extended trapezoidal rule for numerical integration.\n\nChoices:\n0: def actual_power(a: int, b: int) -> int:     if b == 0:         return 1     half = actual_power(a, b // 2)      if (b % 2) == 0:         return half * half     else:         return a * half * half\n1: def make_tree_seven() -> Node:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     tree.right.left = Node(6)     tree.right.right = Node(7)     return tree\n2: def trapezoidal_rule(boundary, steps):     h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 2.0) * f(a)     for i in x_i:         y += h * f(i)     y += (h / 2.0) * f(b)     return y", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef closest_pair_of_points_sqr(points_sorted_on_x, points_sorted_on_y, points_counts):\n\n    # base case\n    if points_counts <= 3:\n        return dis_between_closest_pair(points_sorted_on_x, points_counts)\n\n    # recursion\n    mid = points_counts // 2\n    closest_in_left = closest_pair_of_points_sqr(\n        points_sorted_on_x, points_sorted_on_y[:mid], mid\n    )\n    closest_in_right = closest_pair_of_points_sqr(\n        points_sorted_on_y, points_sorted_on_y[mid:], points_counts - mid\n    )\n    closest_pair_dis = min(closest_in_left, closest_in_right)\n\n\n    cross_strip = []\n    for point in points_sorted_on_x:\n        if abs(point[0] - points_sorted_on_x[mid][0]) < closest_pair_dis:\n            cross_strip.append(point)\n\n    closest_in_strip = dis_between_closest_in_strip(\n        cross_strip, len(cross_strip), closest_pair_dis\n    )\n    return min(closest_pair_dis, closest_in_strip)", "output": "divide and conquer approach"}
{"task": "summary", "input": "summarize code:\ndef int_to_base(number: int, base: int) -> str:\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    result = \"\"\n\n    if number < 0:\n        raise ValueError(\"number must be a positive integer\")\n\n    while number > 0:\n        number, remainder = divmod(number, base)\n        result = digits[remainder] + result\n\n    if result == \"\":\n        result = \"0\"\n\n    return result", "output": "Convert a given positive decimal integer to base 'base'."}
{"task": "summary", "input": "summarize code:\ndef euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:\n    return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))", "output": "Calculate the distance between the two endpoints of two vectors."}
{"task": "summary", "input": "summarize code:\ndef kinetic_energy(mass: float, velocity: float) -> float:\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)", "output": "Calculate kinetic energy."}
{"task": "summary", "input": "summarize code:\ndef matrix_chain_multiply(arr: list[int]) -> int:\n    if len(arr) < 2:\n        return 0\n    # initialising 2D dp matrix\n    n = len(arr)\n    dp = [[maxsize for j in range(n)] for i in range(n)]\n    # we want minimum cost of multiplication of matrices\n    # of dimension (i*k) and (k*j). This cost is arr[i-1]*arr[k]*arr[j].\n    for i in range(n - 1, 0, -1):\n        for j in range(i, n):\n            if i == j:\n                dp[i][j] = 0\n                continue\n            for k in range(i, j):\n                dp[i][j] = min(\n                    dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]\n                )\n\n    return dp[1][n - 1]", "output": "Find the minimum number of multiplcations required to multiply the chain of matrices"}
{"task": "detection", "input": "classify code:\ndef generate_key(message: str, key: str) -> str:\n    \"\"\"\n    >>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n    'SECRETSECRETSECRE'\n    \"\"\"\n    x = len(message)\n    i = 0\n    while True:\n        if x == i:\n            i = 0\n        if len(key) == len(message):\n            break\n        key += key[i]\n        i += 1\n    return key", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef actual_power(a: int, b: int) -> int:\n    \"\"\"\n    Function using divide and conquer to calculate a^b.\n    It only works for integer a,b.\n\n    :param a: The base of the power operation, an integer.\n    :param b: The exponent of the power operation, a non-negative integer.\n    :return: The result of a^b.\n\n    Examples:\n    >>> actual_power(3, 2)\n    9\n    >>> actual_power(5, 3)\n    125\n    >>> actual_power(2, 5)\n    32\n    >>> actual_power(7, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    half = actual_power(a, b // 2)\n\n    if (b % 2) == 0:\n        return half * half\n    else:\n        return a * half * half", "output": "def actual_power(a: int, b: int) -> int:\n    \"\"\"\n    Function using divide and conquer to calculate a^b.\n    It only works for integer a,b.\n\n    :param a: The base of the power operation, an integer.\n    :param b: The exponent of the power operation, a non-negative integer.\n    :return: The result of a^b.\n\n    Examples:\n    >>> actual_power(3, 2)\n    9\n    >>> actual_power(5, 3)\n    125\n    >>> actual_power(2, 5)\n    32\n    >>> actual_power(7, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    half = actual_power(a, b // 2)\n\n    if (b % 2) == 0:\n        return half * half\n    else:\n        return a * half * half"}
{"task": "search", "input": "search code:\nReturns the current area of the island\n\nChoices:\n0: def depth_first_search(row: int, col: int, seen: set, mat: list[list[int]]) -> int:     rows = len(mat)     cols = len(mat[0])     if is_safe(row, col, rows, cols) and (row, col) not in seen and mat[row][col] == 1:         seen.add((row, col))         return (             1             + depth_first_search(row + 1, col, seen, mat)             + depth_first_search(row - 1, col, seen, mat)             + depth_first_search(row, col + 1, seen, mat)             + depth_first_search(row, col - 1, seen, mat)         )     else:         return 0\n1: def xfrange(stop, start=None, step=1.0):     if not step:         raise ValueError('step must be non-zero')     if start is None:         start, stop = 0.0, stop * 1.0     else:         # swap when all args are used         stop, start = start * 1.0, stop * 1.0     cur = start     while cur < stop:         yield cur         cur += step\n2: def charging_capacitor(     source_voltage: float,  # voltage in volts.     resistance: float,  # resistance in ohms.     capacitance: float,  # capacitance in farads.     time_sec: float,  # time in seconds after charging initiation of capacitor. ) -> float:      if source_voltage <= 0:         raise ValueError(\"Source voltage must be positive.\")     if resistance <= 0:         raise ValueError(\"Resistance must be positive.\")     if capacitance <= 0:         raise ValueError(\"Capacitance must be positive.\")     return round(source_voltage * (1 - exp(-time_sec / (resistance * capacitance))), 3)", "output": "0"}
{"task": "search", "input": "search code:\nReturn True if n contains an even digit.\n\nChoices:\n0: def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:     return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))\n1: def get_factors(     number: int, factors: Counter | None = None, factor: int = 2 ) -> Counter:      match number:         case int(number) if number == 1:             return Counter({1: 1})         case int(num) if number > 0:             number = num         case _:             raise TypeError(\"number must be integer and greater than zero\")      factors = factors or Counter()      if number == factor:  # break condition         # all numbers are factors of itself         factors[factor] += 1         return factors      if number % factor > 0:         # if it is greater than zero         # so it is not a factor of number and we check next number         return get_factors(number, factors, factor + 1)      factors[factor] += 1     # else we update factors (that is Counter(dict-like) type) and check again     return get_factors(number // factor, factors, factor)\n2: def contains_an_even_digit(n: int) -> bool:     return any(digit in \"02468\" for digit in str(n))", "output": "2"}
{"task": "search", "input": "search code:\nRecursively traverse the Huffman Tree to set each\n\nChoices:\n0: def locate(iterable, pred=bool, window_size=None):     if window_size is None:         return compress(count(), map(pred, iterable))      if window_size < 1:         raise ValueError('window size must be at least 1')      it = windowed(iterable, window_size, fillvalue=_marker)     return compress(count(), starmap(pred, it))\n1: def md_prefix(indent: int) -> str:     return f\"{indent * '  '}*\" if indent else \"\\n##\"\n2: def traverse_tree(root: Letter | TreeNode, bitstring: str) -> list[Letter]:     if isinstance(root, Letter):         root.bitstring[root.letter] = bitstring         return [root]     treenode: TreeNode = root     letters = []     letters += traverse_tree(treenode.left, bitstring + \"0\")     letters += traverse_tree(treenode.right, bitstring + \"1\")     return letters", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(number_unique_partitions: int = 5000) -> int | None:\n    for number_to_partition in range(1, NUM_PRIMES):\n        if len(partition(number_to_partition)) > number_unique_partitions:\n            return number_to_partition\n    return None", "output": "Return the smallest integer that can be written as the sum of primes in over"}
{"task": "search", "input": "search code:\nGiven a string column_title that represents\n\nChoices:\n0: def pairwise_iter(src, end=_UNSET):     return windowed_iter(src, 2, fill=end)\n1: def excel_title_to_column(column_title: str) -> int:     assert column_title.isupper()     answer = 0     index = len(column_title) - 1     power = 0      while index >= 0:         value = (ord(column_title[index]) - 64) * pow(26, power)         answer += value         power += 1         index -= 1      return answer\n2: def unique_prime_factors(n: int) -> list[int]:     i = 2     factors = []     while i * i <= n:         if not n % i:             while not n % i:                 n //= i             factors.append(i)         i += 1     if n > 1:         factors.append(n)     return factors", "output": "1"}
{"task": "search", "input": "search code:\nreturn the arithmetic mean of series\n\nChoices:\n0: def bruteforce(input_string: str) -> dict[int, str]:     results = {}     for key_guess in range(1, len(input_string)):  # tries every key         results[key_guess] = decrypt(input_string, key_guess)     return results\n1: def random_matrix(width: int, height: int, a: int, b: int) -> Matrix:     random.seed(None)     matrix: list[list[float]] = [         [random.randint(a, b) for _ in range(width)] for _ in range(height)     ]     return Matrix(matrix, width, height)\n2: def arithmetic_mean(series: list) -> float:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     answer = 0     for val in series:         answer += val     return answer / len(series)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef intword(value, format=\"%.1f\"):\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n\n    if value < powers[0]:\n        return str(value)\n    for ordinal, power in enumerate(powers[1:], 1):\n        if value < power:\n            chopped = value / float(powers[ordinal - 1])\n            if float(format % chopped) == float(10**3):\n                chopped = value / float(powers[ordinal])\n                singular, plural = human_powers[ordinal]\n                return (\n                    \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])\n                ) % chopped\n            else:\n                singular, plural = human_powers[ordinal - 1]\n                return (\n                    \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])\n                ) % chopped\n    return str(value)", "output": "Converts a large integer to a friendly text representation."}
{"task": "search", "input": "search code:\nCreate Pascal's triangle for different number of rows\n\nChoices:\n0: def singularize(word):     orig_word, word = word, word.strip().lower()     if not word or word in _IRR_S2P:         return orig_word      irr_singular = _IRR_P2S.get(word)     if irr_singular:         singular = irr_singular     elif not word.endswith('s'):         return orig_word     elif len(word) == 2:         singular = word[:-1]  # or just return word?     elif word.endswith('ies') and word[-4:-3] not in 'aeiou':         singular = word[:-3] + 'y'     elif word.endswith('es') and word[-3] == 's':         singular = word[:-2]     else:         singular = word[:-1]     return _match_case(orig_word, singular)\n1: def generate_pascal_triangle(num_rows: int) -> list[list[int]]:      if not isinstance(num_rows, int):         raise TypeError(\"The input value of 'num_rows' should be 'int'\")      if num_rows == 0:         return []     elif num_rows < 0:         raise ValueError(             \"The input value of 'num_rows' should be greater than or equal to 0\"         )      triangle: list[list[int]] = []     for current_row_idx in range(num_rows):         current_row = populate_current_row(triangle, current_row_idx)         triangle.append(current_row)     return triangle\n2: def assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:     if i == 0 and j == 0:         return []     elif ops[i][j][0] in {\"C\", \"R\"}:         seq = assemble_transformation(ops, i - 1, j - 1)         seq.append(ops[i][j])         return seq     elif ops[i][j][0] == \"D\":         seq = assemble_transformation(ops, i - 1, j)         seq.append(ops[i][j])         return seq     else:         seq = assemble_transformation(ops, i, j - 1)         seq.append(ops[i][j])         return seq", "output": "1"}
{"task": "search", "input": "search code:\nCombine the term frequency\n\nChoices:\n0: def breadth_first_search(     level: list[int],     parent: list[list[int]],     max_node: int,     graph: dict[int, list[int]],     root: int = 1, ) -> tuple[list[int], list[list[int]]]:     level[root] = 0     q: Queue[int] = Queue(maxsize=max_node)     q.put(root)     while q.qsize() != 0:         u = q.get()         for v in graph[u]:             if level[v] == -1:                 level[v] = level[u] + 1                 q.put(v)                 parent[0][v] = u     return level, parent\n1: def tf_idf(tf: int, idf: int) -> float:     return round(tf * idf, 3)\n2: def factorial(number: int) -> int:     if number != int(number):         raise ValueError(\"factorial() only accepts integral values\")     if number < 0:         raise ValueError(\"factorial() not defined for negative values\")     value = 1     for i in range(1, number + 1):         value *= i     return value", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef iterate(func, start):\n    with suppress(StopIteration):\n        while True:\n            yield start\n            start = func(start)", "output": "Return ``start``, ``func(start)``, ``func(func(start))``, ..."}
{"task": "detection", "input": "classify code:\ndef apply_table(inp, table):\n    \"\"\"\n    >>> apply_table(\"0123456789\", list(range(10)))\n    '9012345678'\n    >>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n    '8765432109'\n    \"\"\"\n    res = \"\"\n    for i in table:\n        res += inp[i - 1]\n    return res", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef unquote_to_bytes(string):\n    # Note: strings are encoded as UTF-8. This is only an issue if it contains\n    # unescaped non-ASCII characters, which URIs should not.\n    if not string:\n        # Is it a string-like object?\n        string.split\n        return b''\n    if isinstance(string, str):\n        string = string.encode('utf-8')\n    bits = string.split(b'%')\n    if len(bits) == 1:\n        return string\n    # import pdb;pdb.set_trace()\n    res = [bits[0]]\n    append = res.append\n\n    for item in bits[1:]:\n        try:\n            append(_HEX_CHAR_MAP[item[:2]])\n            append(item[2:])\n        except KeyError:\n            append(b'%')\n            append(item)\n    return b''.join(res)", "output": "unquote_to_bytes('abc%20def') -> b'abc def'."}
{"task": "search", "input": "search code:\nReturns a list of nodes value from a whole binary tree in Level Order Traverse.\n\nChoices:\n0: def pairwise_iter(src, end=_UNSET):     return windowed_iter(src, 2, fill=end)\n1: def my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:     kernels = {         1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),         3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),         5: np.array(             [                 [0, 0, -1, 0, 0],                 [0, -1, -2, -1, 0],                 [-1, -2, 16, -2, -1],                 [0, -1, -2, -1, 0],                 [0, 0, -1, 0, 0],             ]         ),         7: np.array(             [                 [0, 0, 0, -1, 0, 0, 0],                 [0, 0, -2, -3, -2, 0, 0],                 [0, -2, -7, -10, -7, -2, 0],                 [-1, -3, -10, 68, -10, -3, -1],                 [0, -2, -7, -10, -7, -2, 0],                 [0, 0, -2, -3, -2, 0, 0],                 [0, 0, 0, -1, 0, 0, 0],             ]         ),     }     if ksize not in kernels:         msg = f\"ksize must be in {tuple(kernels)}\"         raise ValueError(msg)      # Apply the Laplacian kernel using convolution     return filter2D(         src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)     )\n2: def level_order(root: Node | None) -> Generator[int]:      if root is None:         return      process_queue = deque([root])      while process_queue:         node = process_queue.popleft()         yield node.data          if node.left:             process_queue.append(node.left)         if node.right:             process_queue.append(node.right)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef rmsle(predict, actual):\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    log_predict = np.log(predict + 1)\n    log_actual = np.log(actual + 1)\n\n    difference = log_predict - log_actual\n    square_diff = np.square(difference)\n    mean_square_diff = square_diff.mean()\n\n    score = np.sqrt(mean_square_diff)\n\n    return score", "output": "Examples(rounded for precision):"}
{"task": "summary", "input": "summarize code:\ndef calculate_waiting_time(\n    process_name: list,  # noqa: ARG001\n    turn_around_time: list,\n    burst_time: list,\n    no_of_process: int,\n) -> list:\n\n    waiting_time = [0] * no_of_process\n    for i in range(no_of_process):\n        waiting_time[i] = turn_around_time[i] - burst_time[i]\n    return waiting_time", "output": "Calculate the waiting time of each processes."}
{"task": "detection", "input": "classify code:\ndef check(binary: list[str]) -> list[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while 1:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k != \"X\":\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(k)\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef remove_duplicates(key: str) -> str:\n\n    key_no_dups = \"\"\n    for ch in key:\n        if ch == \" \" or (ch not in key_no_dups and ch.isalpha()):\n            key_no_dups += ch\n    return key_no_dups", "output": "Removes duplicate alphabetic characters in a keyword (letter is ignored after its"}
{"task": "summary", "input": "summarize code:\ndef deserialize(data: str) -> TreeNode | None:\n\n    if not data:\n        raise ValueError(\"Data cannot be empty.\")\n\n    # Split the serialized string by a comma to get node values\n    nodes = data.split(\",\")\n\n    def build_tree() -> TreeNode | None:\n        # Get the next value from the list\n        value = nodes.pop(0)\n\n        if value == \"null\":\n            return None\n\n        node = TreeNode(int(value))\n        node.left = build_tree()  # Recursively build left subtree\n        node.right = build_tree()  # Recursively build right subtree\n        return node\n\n    return build_tree()", "output": "Deserialize a string to a binary tree."}
{"task": "summary", "input": "summarize code:\ndef iter_except(func, exception, first=None):\n    with suppress(exception):\n        if first is not None:\n            yield first()\n        while True:\n            yield func()", "output": "Yields results from a function repeatedly until an exception is raised."}
{"task": "detection", "input": "classify code:\ndef approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    root = None\n    print(\n        \"enter numbers to create a tree, + value to add value into treap, \"\n        \"- value to erase all nodes with value. 'q' to quit. \"\n    )\n\n    args = input()\n    while args != \"q\":\n        root = interact_treap(root, args)\n        print(root)\n        args = input()\n\n    print(\"good by!\")", "output": "After each command, program prints treap"}
{"task": "search", "input": "search code:\nGenerate filters for audio processing.\n\nChoices:\n0: def binary_search_by_recursion(     sorted_collection: list[int], item: int, left: int = 0, right: int = -1 ) -> int:     if right < 0:         right = len(sorted_collection) - 1     if list(sorted_collection) != sorted(sorted_collection):         raise ValueError(\"sorted_collection must be sorted in ascending order\")     if right < left:         return -1      midpoint = left + (right - left) // 2      if sorted_collection[midpoint] == item:         return midpoint     elif sorted_collection[midpoint] > item:         return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)     else:         return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)\n1: def calculate_span(price: list[int]) -> list[int]:     n = len(price)     s = [0] * n     # Create a stack and push index of fist element to it     st = []     st.append(0)      # Span value of first element is always 1     s[0] = 1      # Calculate span values for rest of the elements     for i in range(1, n):         # Pop elements from stack while stack is not         # empty and top of stack is smaller than price[i]         while len(st) > 0 and price[st[-1]] <= price[i]:             st.pop()          # If stack becomes empty, then price[i] is greater         # than all elements on left of it, i.e. price[0],         # price[1], ..price[i-1]. Else the price[i]  is         # greater than elements after top of stack         s[i] = i + 1 if len(st) <= 0 else (i - st[-1])          # Push this element to stack         st.append(i)      return s\n2: def get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:     num_filters = len(filter_points) - 2     filters = np.zeros((num_filters, int(ftt_size / 2) + 1))      for n in range(num_filters):         start = filter_points[n]         mid = filter_points[n + 1]         end = filter_points[n + 2]          # Linearly increase values from 0 to 1         filters[n, start:mid] = np.linspace(0, 1, mid - start)          # Linearly decrease values from 1 to 0         filters[n, mid:end] = np.linspace(1, 0, end - mid)      return filters", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef unique_in_window(iterable, n, key=None):\n    if n <= 0:\n        raise ValueError('n must be greater than 0')\n\n    window = deque(maxlen=n)\n    counts = Counter()\n    use_key = key is not None\n\n    for item in iterable:\n        if len(window) == n:\n            to_discard = window[0]\n            if counts[to_discard] == 1:\n                del counts[to_discard]\n            else:\n                counts[to_discard] -= 1\n\n        k = key(item) if use_key else item\n        if k not in counts:\n            yield item\n        counts[k] += 1\n        window.append(k)", "output": "Yield the items from *iterable* that haven't been seen recently."}
{"task": "detection", "input": "classify code:\ndef binary_multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply 'a' and 'b' using bitwise multiplication.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: a * b\n\n    Examples:\n    >>> binary_multiply(2, 3)\n    6\n    >>> binary_multiply(5, 0)\n    0\n    >>> binary_multiply(3, 4)\n    12\n    >>> binary_multiply(10, 5)\n    50\n    >>> binary_multiply(0, 5)\n    0\n    >>> binary_multiply(2, 1)\n    2\n    >>> binary_multiply(1, 10)\n    10\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000000):\n    total = 0\n\n    for i in range(1, n):\n        if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):\n            total += i\n    return total", "output": "Return the sum of all numbers, less than n , which are palindromic in"}
{"task": "search", "input": "search code:\nFunction using divide and conquer to calculate a^b.\n\nChoices:\n0: def actual_power(a: int, b: int) -> int:     if b == 0:         return 1     half = actual_power(a, b // 2)      if (b % 2) == 0:         return half * half     else:         return a * half * half\n1: def main() -> None:     lower = int(input(\"Enter lower value : \").strip())     higher = int(input(\"Enter high value : \").strip())     guess = int(input(\"Enter value to guess : \").strip())     guess_the_number(lower, higher, guess)\n2: def surface_area_cube(side_length: float) -> float:     if side_length < 0:         raise ValueError(\"surface_area_cube() only accepts non-negative values\")     return 6 * side_length**2", "output": "0"}
{"task": "detection", "input": "classify code:\ndef sum_of_harmonic_progression(\n    first_term: float, common_difference: float, number_of_terms: int\n) -> float:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)\n\n    Find the sum of n terms in an harmonic progression.  The calculation starts with the\n    first_term and loops adding the common difference of Arithmetic Progression by which\n    the given Harmonic Progression is linked.\n\n    >>> sum_of_harmonic_progression(1 / 2, 2, 2)\n    0.75\n    >>> sum_of_harmonic_progression(1 / 5, 5, 5)\n    0.45666666666666667\n    \"\"\"\n    arithmetic_progression = [1 / first_term]\n    first_term = 1 / first_term\n    for _ in range(number_of_terms - 1):\n        first_term += common_difference\n        arithmetic_progression.append(first_term)\n    harmonic_series = [1 / step for step in arithmetic_progression]\n    return sum(harmonic_series)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nPrecomputing squares and checking if a^2 + b^2 is the square by set look-up.\n\nChoices:\n0: def solution(max_n: int = 10000000) -> int:      min_numerator = 1  # i     min_denominator = 0  # (i)     totients = get_totients(max_n + 1)      for i in range(2, max_n + 1):         t = totients[i]          if i * min_denominator < min_numerator * t and has_same_digits(i, t):             min_numerator = i             min_denominator = t      return min_numerator\n1: def solution(n: int = 1000) -> int:      squares = get_squares(n)     squares_set = set(squares)     for a in range(1, n // 3):         for b in range(a + 1, (n - a) // 2 + 1):             if (                 squares[a] + squares[b] in squares_set                 and squares[n - a - b] == squares[a] + squares[b]             ):                 return a * b * (n - a - b)      return -1\n2: def _pgettext(msgctxt, message):     # This GNU gettext function was added in Python 3.8, so for older versions we     # reimplement it. It works by joining `msgctx` and `message` by '4' byte.     try:         # Python 3.8+         return get_translation().pgettext(msgctxt, message)     except AttributeError:         # Python 3.7 and older         key = msgctxt + \"\\x04\" + message         translation = get_translation().gettext(key)         return message if translation == key else translation", "output": "1"}
{"task": "search", "input": "search code:\nYields exponential moving averages of the given stock prices.\n\nChoices:\n0: def solution(max_d: int = 12_000) -> int:      fractions_number = 0     for d in range(max_d + 1):         n_start = d // 3 + 1         n_step = 1         if d % 2 == 0:             n_start += 1 - n_start % 2             n_step = 2         for n in range(n_start, (d + 1) // 2, n_step):             if gcd(n, d) == 1:                 fractions_number += 1     return fractions_number\n1: def _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:     if bit_position == 0 or len(list_of_ints) in [0, 1]:         return list_of_ints      zeros = []     ones = []     # Split numbers based on bit at bit_position from the right     for number in list_of_ints:         if (number >> (bit_position - 1)) & 1:             # number has a one at bit bit_position             ones.append(number)         else:             # number has a zero at bit bit_position             zeros.append(number)      # recursively split both lists further     zeros = _msd_radix_sort(zeros, bit_position - 1)     ones = _msd_radix_sort(ones, bit_position - 1)      # recombine lists     res = zeros     res.extend(ones)      return res\n2: def exponential_moving_average(     stock_prices: Iterator[float], window_size: int ) -> Iterator[float]:      if window_size <= 0:         raise ValueError(\"window_size must be > 0\")      # Calculating smoothing factor     alpha = 2 / (1 + window_size)      # Exponential average at timestamp t     moving_average = 0.0      for i, stock_price in enumerate(stock_prices):         if i <= window_size:             # Assigning simple moving average till the window_size for the first time             # is reached             moving_average = (moving_average + stock_price) * 0.5 if i else stock_price         else:             # Calculating exponential moving average based on current timestamp data             # point and previous exponential average value             moving_average = (alpha * stock_price) + ((1 - alpha) * moving_average)         yield moving_average", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef show_phase_response(filter_type: FilterType, samplerate: int) -> None:\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\n\n    filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.angle(np.fft.fft(outputs))\n\n    # Frequencies on log scale from 24 to nyquist frequency\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\n\n    plt.ylim(-2 * pi, 2 * pi)\n    plt.ylabel(\"Phase shift (Radians)\")\n    plt.plot(np.unwrap(fft_out, -2 * pi))\n    plt.show()", "output": "Show phase response of a filter"}
{"task": "summary", "input": "summarize code:\ndef quote_userinfo_part(text, full_quote=True):\n    if full_quote:\n        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')\n        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])\n    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS\n                     else t for t in text])", "output": "Quote special characters in either the username or password"}
{"task": "summary", "input": "summarize code:\ndef total_time(init_velocity: float, angle: float) -> float:\n    check_args(init_velocity, angle)\n    radians = deg_to_rad(angle)\n    return round(2 * init_velocity * sin(radians) / g, 2)", "output": "Returns total time of the motion"}
{"task": "summary", "input": "summarize code:\ndef harmonic_series(n_term: str) -> list:\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series", "output": "Pure Python implementation of Harmonic Series algorithm"}
{"task": "search", "input": "search code:\nIf *filename.ext* exists, it will be moved to *filename.1.ext*,\n\nChoices:\n0: def rotate_file(filename, *, keep: int = 5):     if keep < 1:         raise ValueError(f'expected \"keep\" to be >=1, not {keep}')     if not os.path.exists(filename):         return     if not os.path.isfile(filename):         raise ValueError(f'expected {filename} to be a file')      fn_root, fn_ext = os.path.splitext(filename)     kept_names = []     for i in range(1, keep + 1):         if fn_ext:             kept_names.append(f'{fn_root}.{i}{fn_ext}')         else:             kept_names.append(f'{fn_root}.{i}')      fns = [filename] + kept_names     for orig_name, kept_name in reversed(list(zip(fns, fns[1:]))):         if not os.path.exists(orig_name):             continue         os.rename(orig_name, kept_name)      if os.path.exists(kept_names[-1]):         os.remove(kept_names[-1])      return\n1: def get_module_callables(mod, ignore=None):     if isinstance(mod, str):         mod = sys.modules[mod]     types, funcs = {}, {}     for attr_name in dir(mod):         if ignore and ignore(attr_name):             continue         try:             attr = getattr(mod, attr_name)         except Exception:             continue         try:             attr_mod_name = attr.__module__         except AttributeError:             continue         if attr_mod_name != mod.__name__:             continue         if isinstance(attr, type):             types[attr_name] = attr         elif callable(attr):             funcs[attr_name] = attr     return types, funcs\n2: def xnor_gate(input_1: int, input_2: int) -> int:     return 1 if input_1 == input_2 else 0", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef fibonacci_with_matrix_exponentiation(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n    matrix = Matrix([[1, 1], [1, 0]])\n    matrix = modular_exponentiation(matrix, n - 2)\n    return f2 * matrix.t[0][0] + f1 * matrix.t[0][1]", "output": "Returns the nth number of the Fibonacci sequence that"}
{"task": "summary", "input": "summarize code:\ndef archimedes_principle(\n    fluid_density: float, volume: float, gravity: float = g\n) -> float:\n\n    if fluid_density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if volume <= 0:\n        raise ValueError(\"Impossible object volume\")\n    if gravity < 0:\n        raise ValueError(\"Impossible gravity\")\n\n    return fluid_density * gravity * volume", "output": "Args:"}
{"task": "search", "input": "search code:\nChecks to see if a number is a prime in O(sqrt(n)).\n\nChoices:\n0: def calculate_waiting_times(burst_times: list[int]) -> list[int]:     quantum = 2     rem_burst_times = list(burst_times)     waiting_times = [0] * len(burst_times)     t = 0     while True:         done = True         for i, burst_time in enumerate(burst_times):             if rem_burst_times[i] > 0:                 done = False                 if rem_burst_times[i] > quantum:                     t += quantum                     rem_burst_times[i] -= quantum                 else:                     t += rem_burst_times[i]                     waiting_times[i] = t - burst_time                     rem_burst_times[i] = 0         if done is True:             return waiting_times\n1: def windowed_iter(src, size, fill=_UNSET):     tees = itertools.tee(src, size)     if fill is _UNSET:         try:             for i, t in enumerate(tees):                 for _ in range(i):                     next(t)         except StopIteration:             return zip([])         return zip(*tees)      for i, t in enumerate(tees):         for _ in range(i):             try:                 next(t)             except StopIteration:                 continue     return zip_longest(*tees, fillvalue=fill)\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef go_next(i: int, z_result: list[int], s: str) -> bool:\n    return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]", "output": "Check if we have to move forward to the next characters or not"}
{"task": "summary", "input": "summarize code:\ndef merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:\n    if tree1 is None:\n        return tree2\n    if tree2 is None:\n        return tree1\n\n    tree1.value = tree1.value + tree2.value\n    tree1.left = merge_two_binary_trees(tree1.left, tree2.left)\n    tree1.right = merge_two_binary_trees(tree1.right, tree2.right)\n    return tree1", "output": "Returns root node of the merged tree."}
{"task": "summary", "input": "summarize code:\ndef solution(max_number: int = 10**8) -> int:\n\n    prime_numbers = calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    right = len(prime_numbers) - 1\n    for left in range(len(prime_numbers)):\n        if left > right:\n            break\n        for r in range(right, left - 2, -1):\n            if prime_numbers[left] * prime_numbers[r] < max_number:\n                break\n        right = r\n        semiprimes_count += right - left + 1\n\n    return semiprimes_count", "output": "Returns the number of composite integers below max_number have precisely two,"}
{"task": "search", "input": "search code:\nDoes very basic splitting of a format string, returns a list of\n\nChoices:\n0: def consume(iterator, n=None):     # Use functions that consume iterators at C speed.     if n is None:         # feed the entire iterator into a zero-length deque         deque(iterator, maxlen=0)     else:         # advance to the empty slice starting at position n         next(islice(iterator, n, n), None)\n1: def random_graph(     vertices_number: int, probability: float, directed: bool = False ) -> dict:     graph: dict = {i: [] for i in range(vertices_number)}      # if probability is greater or equal than 1, then generate a complete graph     if probability >= 1:         return complete_graph(vertices_number)     # if probability is lower or equal than 0, then return a graph without edges     if probability <= 0:         return graph      # for each couple of nodes, add an edge from u to v     # if the number randomly generated is greater than probability probability     for i in range(vertices_number):         for j in range(i + 1, vertices_number):             if random.random() < probability:                 graph[i].append(j)                 if not directed:                     # if the graph is undirected, add an edge in from j to i, either                     graph[j].append(i)     return graph\n2: def split_format_str(fstr):     ret = []      for lit, fname, fspec, conv in Formatter().parse(fstr):         if fname is None:             ret.append((lit, None))             continue         field_str = construct_format_field_str(fname, fspec, conv)         ret.append((lit, field_str))     return ret", "output": "2"}
{"task": "detection", "input": "classify code:\ndef is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef _enforce_args(n: int, prices: list):\n    if n < 0:\n        msg = f\"n must be greater than or equal to 0. Got n = {n}\"\n        raise ValueError(msg)\n\n    if n > len(prices):\n        msg = (\n            \"Each integral piece of rod must have a corresponding price. \"\n            f\"Got n = {n} but length of prices = {len(prices)}\"\n        )\n        raise ValueError(msg)", "output": "Basic checks on the arguments to the rod-cutting algorithms"}
{"task": "summary", "input": "summarize code:\ndef calc_derivative(f: RealFunc, x: float, delta_x: float = 1e-3) -> float:\n    return (f(x + delta_x / 2) - f(x - delta_x / 2)) / delta_x", "output": "Approximate the derivative of a function f(x) at a point x using the finite"}
{"task": "summary", "input": "summarize code:\ndef find_triplets_with_0_sum(nums: list[int]) -> list[list[int]]:\n    return [\n        list(x)\n        for x in sorted({abc for abc in combinations(sorted(nums), 3) if not sum(abc)})\n    ]", "output": "Given a list of integers, return elements a, b, c such that a + b + c = 0."}
{"task": "search", "input": "search code:\nreturns the biggest possible result\n\nChoices:\n0: def freq_to_mel(freq: float) -> float:     # Use the formula to convert frequency to the mel scale     return 2595.0 * np.log10(1.0 + freq / 700.0)\n1: def dir_dict(obj, raise_exc=False):     # TODO: separate function for handling descriptors on types?     ret = {}     for k in dir(obj):         try:             ret[k] = getattr(obj, k)         except Exception:             if raise_exc:                 raise     return ret\n2: def remove_digit(num: int) -> int:      if not isinstance(num, int):         raise TypeError(\"only integers accepted as input\")     else:         num_str = str(abs(num))         num_transpositions = [list(num_str) for char in range(len(num_str))]         for index in range(len(num_str)):             num_transpositions[index].pop(index)         return max(             int(\"\".join(list(transposition))) for transposition in num_transpositions         )", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef binary_multiply(a: int, b: int) -> int:\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res", "output": "Multiply 'a' and 'b' using bitwise multiplication."}
{"task": "detection", "input": "classify code:\ndef median(nums: list) -> int | float:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    sorted_list = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )", "output": "CORRECT"}
{"task": "search", "input": "search code:\nSolve the Josephus problem for num_people and a step_size iteratively.\n\nChoices:\n0: def from_file(filename, sep=\"\\n\"):     \"Parse a file into a list of strings, separated by sep.\"     with open(filename) as file:         return file.read().strip().split(sep)\n1: def nth_product(index, *args):     pools = list(map(tuple, reversed(args)))     ns = list(map(len, pools))      c = reduce(mul, ns)      if index < 0:         index += c      if not 0 <= index < c:         raise IndexError      result = []     for pool, n in zip(pools, ns):         result.append(pool[index % n])         index //= n      return tuple(reversed(result))\n2: def josephus_iterative(num_people: int, step_size: int) -> int:     circle = list(range(1, num_people + 1))     current = 0      while len(circle) > 1:         current = (current + step_size - 1) % len(circle)         circle.pop(current)      return circle[0]", "output": "2"}
{"task": "search", "input": "search code:\nGet bounds for printing fft results\n\nChoices:\n0: def get_bounds(     fft_results: np.ndarray, samplerate: int ) -> tuple[int | float, int | float]:     lowest = min([-20, np.min(fft_results[1 : samplerate // 2 - 1])])     highest = max([20, np.max(fft_results[1 : samplerate // 2 - 1])])     return lowest, highest\n1: def _date_and_delta(value, *, now=None):     if not now:         now = _now()     if isinstance(value, dt.datetime):         date = value         delta = now - value     elif isinstance(value, dt.timedelta):         date = now - value         delta = value     else:         try:             value = int(value)             delta = dt.timedelta(seconds=value)             date = now - delta         except (ValueError, TypeError):             return None, value     return date, _abs_timedelta(delta)\n2: def bin_to_hexadecimal(binary_str: str) -> str:     # Sanitising parameter     binary_str = str(binary_str).strip()      # Exceptions     if not binary_str:         raise ValueError(\"Empty string was passed to the function\")     is_negative = binary_str[0] == \"-\"     binary_str = binary_str[1:] if is_negative else binary_str     if not all(char in \"01\" for char in binary_str):         raise ValueError(\"Non-binary value was passed to the function\")      binary_str = (         \"0\" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str     )      hexadecimal = []     for x in range(0, len(binary_str), 4):         hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])     hexadecimal_str = \"0x\" + \"\".join(hexadecimal)      return \"-\" + hexadecimal_str if is_negative else hexadecimal_str", "output": "0"}
{"task": "search", "input": "search code:\nImplementation of shell sort algorithm in Python\n\nChoices:\n0: def shell_sort(collection: list) -> list:      # Choose an initial gap value     gap = len(collection)      # Set the gap value to be decreased by a factor of 1.3     # after each iteration     shrink = 1.3      # Continue sorting until the gap is 1     while gap > 1:         # Decrease the gap value         gap = int(gap / shrink)          # Sort the elements using insertion sort         for i in range(gap, len(collection)):             temp = collection[i]             j = i             while j >= gap and collection[j - gap] > temp:                 collection[j] = collection[j - gap]                 j -= gap             collection[j] = temp      return collection\n1: def sum_of_digits(n: int) -> int:     n = abs(n)     res = 0     while n > 0:         res += n % 10         n //= 10     return res\n2: def peak(lst: list[int]) -> int:     # middle index     m = len(lst) // 2      # choose the middle 3 elements     three = lst[m - 1 : m + 2]      # if middle element is peak     if three[1] > three[0] and three[1] > three[2]:         return three[1]      # if increasing, recurse on right     elif three[0] < three[2]:         if len(lst[:m]) == 2:             m -= 1         return peak(lst[m:])      # decreasing     else:         if len(lst[:m]) == 2:             m += 1         return peak(lst[:m])", "output": "0"}
{"task": "detection", "input": "classify code:\ndef longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([28, 26, 12, 23, 35, 39])\n    [12, 23, 35, 39]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [5, 7]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = array[i:]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef ilen(iterable):\n    # This is the \"most beautiful of the fast variants\" of this function.\n    # If you think you can improve on it, please ensure that your version\n    # is both 10x faster and 10x more beautiful.\n    return sum(compress(repeat(1), zip(iterable)))", "output": "Return the number of items in *iterable*."}
{"task": "summary", "input": "summarize code:\ndef rayleigh_quotient(a: np.ndarray, v: np.ndarray) -> Any:\n    v_star = v.conjugate().T\n    v_star_dot = v_star.dot(a)\n    assert isinstance(v_star_dot, np.ndarray)\n    return (v_star_dot.dot(v)) / (v_star.dot(v))", "output": "Returns the Rayleigh quotient of a Hermitian matrix A and"}
{"task": "detection", "input": "classify code:\ndef unique_prime_factors(n: int) -> set:\n    \"\"\"\n    Find unique prime factors of an integer.\n    Tests include sorting because only the set matters,\n    not the order in which it is produced.\n    >>> sorted(set(unique_prime_factors(14)))\n    [2, 7]\n    >>> sorted(set(unique_prime_factors(644)))\n    [2, 7, 23]\n    >>> sorted(set(unique_prime_factors(646)))\n    [2, 17, 19]\n    \"\"\"\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef geometric_series(nth_term: int, start_term_a: int, common_ratio_r: int) -> list:\n    \"\"\"Pure Python implementation of Geometric Series algorithm\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, '4.0', '8.0', '16.0']\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, '4.41', '9.261000000000001', '19.448100000000004']\n    >>> geometric_series(4, 2, -2)\n    [2, '-4.0', '8.0', '-16.0']\n    >>> geometric_series(4, -2, 2)\n    [-2, '-4.0', '-8.0', '-16.0']\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if \"\" in (nth_term, start_term_a, common_ratio_r):\n        return \"\"\n    series = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if series == []:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(str(float(start_term_a) * float(multiple)))\n            multiple = pow(float(common_ratio_r), power)\n    return series", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef example() -> int:\n    # Input values.\n    test_input = np.array(\n        (\n            [0, 0, 0],\n            [0, 0, 1],\n            [0, 1, 0],\n            [0, 1, 1],\n            [1, 0, 0],\n            [1, 0, 1],\n            [1, 1, 0],\n            [1, 1, 1],\n        ),\n        dtype=np.float64,\n    )\n\n    # True output values for the given input values.\n    output = np.array(([0], [1], [1], [0], [1], [0], [0], [1]), dtype=np.float64)\n\n    # Calling neural network class.\n    neural_network = TwoHiddenLayerNeuralNetwork(\n        input_array=test_input, output_array=output\n    )\n\n    # Calling training function.\n    # Set give_loss to True if you want to see loss in every iteration.\n    neural_network.train(output=output, iterations=10, give_loss=False)\n\n    return neural_network.predict(np.array(([1, 1, 1]), dtype=np.float64))", "output": "Example for \"how to use the neural network class and use the"}
{"task": "search", "input": "search code:\nCheck if a linked list is a palindrome using a stack.\n\nChoices:\n0: def is_palindrome_stack(head: ListNode | None) -> bool:     if not head or not head.next_node:         return True      # 1. Get the midpoint (slow)     slow: ListNode | None = head     fast: ListNode | None = head     while fast and fast.next_node:         fast = fast.next_node.next_node         slow = slow.next_node if slow else None      # slow will always be defined,     # adding this check to resolve mypy static check     if slow:         stack = [slow.val]          # 2. Push the second half into the stack         while slow.next_node:             slow = slow.next_node             stack.append(slow.val)          # 3. Comparison         cur: ListNode | None = head         while stack and cur:             if stack.pop() != cur.val:                 return False             cur = cur.next_node      return True\n1: def maxpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:     arr = np.array(arr)     if arr.shape[0] != arr.shape[1]:         raise ValueError(\"The input array is not a square matrix\")     i = 0     j = 0     mat_i = 0     mat_j = 0      # compute the shape of the output matrix     maxpool_shape = (arr.shape[0] - size) // stride + 1     # initialize the output matrix with zeros of shape maxpool_shape     updated_arr = np.zeros((maxpool_shape, maxpool_shape))      while i < arr.shape[0]:         if i + size > arr.shape[0]:             # if the end of the matrix is reached, break             break         while j < arr.shape[1]:             # if the end of the matrix is reached, break             if j + size > arr.shape[1]:                 break             # compute the maximum of the pooling matrix             updated_arr[mat_i][mat_j] = np.max(arr[i : i + size, j : j + size])             # shift the pooling matrix by stride of column pixels             j += stride             mat_j += 1          # shift the pooling matrix by stride of row pixels         i += stride         mat_i += 1          # reset the column index to 0         j = 0         mat_j = 0      return updated_arr\n2: def _norm_args_typeerror(other):     if type(other) in (set, frozenset):         inc, exc = other, None     elif type(other) is _ComplementSet:         inc, exc = other._included, other._excluded     else:         raise TypeError('argument must be another set or complement(set)')     return inc, exc", "output": "0"}
{"task": "detection", "input": "classify code:\ndef speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20C: bulk_modulus= 2.15MPa, density=998kg/m\n    Example 2 --> Mercury 20C: bulk_modulus= 28.5MPa, density=13600kg/m\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5", "output": "BUGGY"}
{"task": "search", "input": "search code:\nNo relation to :meth:`str.partition`, ``partition`` is like\n\nChoices:\n0: def all_unique(iterable, key=None):     seenset = set()     seenset_add = seenset.add     seenlist = []     seenlist_add = seenlist.append     for element in map(key, iterable) if key else iterable:         try:             if element in seenset:                 return False             seenset_add(element)         except TypeError:             if element in seenlist:                 return False             seenlist_add(element)     return True\n1: def generate_pascal_triangle_optimized(num_rows: int) -> list[list[int]]:      if not isinstance(num_rows, int):         raise TypeError(\"The input value of 'num_rows' should be 'int'\")      if num_rows == 0:         return []     elif num_rows < 0:         raise ValueError(             \"The input value of 'num_rows' should be greater than or equal to 0\"         )      result: list[list[int]] = [[1]]      for row_index in range(1, num_rows):         temp_row = [0] + result[-1] + [0]         row_length = row_index + 1         # Calculate the number of distinct elements in a row         distinct_elements = sum(divmod(row_length, 2))         row_first_half = [             temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)         ]         row_second_half = row_first_half[: (row_index + 1) // 2]         row_second_half.reverse()         row = row_first_half + row_second_half         result.append(row)      return result\n2: def partition(src, key=bool):     bucketized = bucketize(src, key)     return bucketized.get(True, []), bucketized.get(False, [])", "output": "2"}
{"task": "search", "input": "search code:\nTarjan's algo for finding strongly connected components in a directed graph\n\nChoices:\n0: def inspect_formatargspec(         args, varargs=None, varkw=None, defaults=None,         kwonlyargs=(), kwonlydefaults={}, annotations={},         formatarg=str,         formatvarargs=lambda name: '*' + name,         formatvarkw=lambda name: '**' + name,         formatvalue=lambda value: '=' + repr(value),         formatreturns=lambda text: ' -> ' + text,         formatannotation=formatannotation):      def formatargandannotation(arg):         result = formatarg(arg)         if arg in annotations:             result += ': ' + formatannotation(annotations[arg])         return result     specs = []     if defaults:         firstdefault = len(args) - len(defaults)     for i, arg in enumerate(args):         spec = formatargandannotation(arg)         if defaults and i >= firstdefault:             spec = spec + formatvalue(defaults[i - firstdefault])         specs.append(spec)     if varargs is not None:         specs.append(formatvarargs(formatargandannotation(varargs)))     else:         if kwonlyargs:             specs.append('*')     if kwonlyargs:         for kwonlyarg in kwonlyargs:             spec = formatargandannotation(kwonlyarg)             if kwonlydefaults and kwonlyarg in kwonlydefaults:                 spec += formatvalue(kwonlydefaults[kwonlyarg])             specs.append(spec)     if varkw is not None:         specs.append(formatvarkw(formatargandannotation(varkw)))     result = '(' + ', '.join(specs) + ')'     if 'return' in annotations:         result += formatreturns(formatannotation(annotations['return']))     return result\n1: def compute_geometric_mean(*args: int) -> float:     product = 1     for number in args:         if not isinstance(number, int) and not isinstance(number, float):             raise TypeError(\"Not a Number\")         product *= number     # Cannot calculate the even root for negative product.     # Frequently they are restricted to being positive.     if product < 0 and len(args) % 2 == 0:         raise ArithmeticError(\"Cannot Compute Geometric Mean for these numbers.\")     mean = abs(product) ** (1 / len(args))     # Since python calculates complex roots for negative products with odd roots.     if product < 0:         mean = -mean     # Since it does floating point arithmetic, it gives 64**(1/3) as 3.99999996     possible_mean = float(round(mean))     # To check if the rounded number is actually the mean.     if possible_mean ** len(args) == product:         mean = possible_mean     return mean\n2: def tarjan(g: list[list[int]]) -> list[list[int]]:      n = len(g)     stack: deque[int] = deque()     on_stack = [False for _ in range(n)]     index_of = [-1 for _ in range(n)]     lowlink_of = index_of[:]      def strong_connect(v: int, index: int, components: list[list[int]]) -> int:         index_of[v] = index  # the number when this node is seen         lowlink_of[v] = index  # lowest rank node reachable from here         index += 1         stack.append(v)         on_stack[v] = True          for w in g[v]:             if index_of[w] == -1:                 index = strong_connect(w, index, components)                 lowlink_of[v] = (                     lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]                 )             elif on_stack[w]:                 lowlink_of[v] = (                     lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]                 )          if lowlink_of[v] == index_of[v]:             component = []             w = stack.pop()             on_stack[w] = False             component.append(w)             while w != v:                 w = stack.pop()                 on_stack[w] = False                 component.append(w)             components.append(component)         return index      components: list[list[int]] = []     for v in range(n):         if index_of[v] == -1:             strong_connect(v, 0, components)      return components", "output": "2"}
{"task": "search", "input": "search code:\nMutate a random gene of a child with another one from the list.\n\nChoices:\n0: def solution(n: int = 998001) -> int:      answer = 0     for i in range(999, 99, -1):  # 3 digit numbers range from 999 down to 100         for j in range(999, 99, -1):             product_string = str(i * j)             if product_string == product_string[::-1] and i * j < n:                 answer = max(answer, i * j)     return answer\n1: def term_frequency(term: str, document: str) -> int:     # strip all punctuation and newlines and replace it with ''     document_without_punctuation = document.translate(         str.maketrans(\"\", \"\", string.punctuation)     ).replace(\"\\n\", \"\")     tokenize_document = document_without_punctuation.split(\" \")  # word tokenization     return len([word for word in tokenize_document if word.lower() == term.lower()])\n2: def mutate(child: str, genes: list[str]) -> str:     child_list = list(child)     if random.uniform(0, 1) < MUTATION_PROBABILITY:         child_list[random.randint(0, len(child)) - 1] = random.choice(genes)     return \"\".join(child_list)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef format_exception_only(etype, value):\n    # Gracefully handle (the way Python 2.4 and earlier did) the case of\n    # being called with (None, None).\n    if etype is None:\n        return [_format_final_exc_line(etype, value)]\n\n    stype = etype.__name__\n    smod = etype.__module__\n    if smod not in (\"__main__\", \"builtins\", \"exceptions\"):\n        stype = smod + '.' + stype\n\n    if not issubclass(etype, SyntaxError):\n        return [_format_final_exc_line(stype, value)]\n\n    # It was a syntax error; show exactly where the problem was found.\n    lines = []\n    filename = value.filename or \"<string>\"\n    lineno = str(value.lineno) or '?'\n    lines.append(f'  File \"{filename}\", line {lineno}\\n')\n    badline = value.text\n    offset = value.offset\n    if badline is not None:\n        lines.append('    %s\\n' % badline.strip())\n        if offset is not None:\n            caretspace = badline.rstrip('\\n')[:offset].lstrip()\n            # non-space whitespace (likes tabs) must be kept for alignment\n            caretspace = ((c.isspace() and c or ' ') for c in caretspace)\n            # only three spaces to account for offset1 == pos 0\n            lines.append('   %s^\\n' % ''.join(caretspace))\n    msg = value.msg or \"<no detail available>\"\n    lines.append(f\"{stype}: {msg}\\n\")\n    return lines", "output": "Format the exception part of a traceback."}
{"task": "summary", "input": "summarize code:\ndef format_invocation(name='', args=(), kwargs=None, **kw):\n    _repr = kw.pop('repr', repr)\n    if kw:\n        raise TypeError('unexpected keyword args: %r' % ', '.join(kw.keys()))\n    kwargs = kwargs or {}\n    a_text = ', '.join([_repr(a) for a in args])\n    if isinstance(kwargs, dict):\n        kwarg_items = [(k, kwargs[k]) for k in sorted(kwargs)]\n    else:\n        kwarg_items = kwargs\n    kw_text = ', '.join([f'{k}={_repr(v)}' for k, v in kwarg_items])\n\n    all_args_text = a_text\n    if all_args_text and kw_text:\n        all_args_text += ', '\n    all_args_text += kw_text\n\n    return f'{name}({all_args_text})'", "output": "Given a name, positional arguments, and keyword arguments, format"}
{"task": "search", "input": "search code:\nIf the binary search tree is empty, make a new node and declare it as root.\n\nChoices:\n0: def mse(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     square_diff = np.square(difference)      score = square_diff.mean()     return score\n1: def insert(node: BinaryTreeNode | None, new_value: int) -> BinaryTreeNode | None:     if node is None:         node = BinaryTreeNode(new_value)         return node      # binary search tree is not empty,     # so we will insert it into the tree     # if new_value is less than value of data in node,     #  add it to left subtree and proceed recursively     if new_value < node.data:         node.left_child = insert(node.left_child, new_value)     else:         # if new_value is greater than value of data in node,         #  add it to right subtree and proceed recursively         node.right_child = insert(node.right_child, new_value)     return node\n2: def change_contrast(img: Image, level: int) -> Image:     factor = (259 * (level + 255)) / (255 * (259 - level))      def contrast(c: int) -> int:         return int(128 + factor * (c - 128))      return img.point(contrast)", "output": "1"}
{"task": "search", "input": "search code:\nYields results from a function repeatedly until an exception is raised.\n\nChoices:\n0: def fibonacci(k: int) -> int:     if not isinstance(k, int):         raise TypeError(\"k must be an integer.\")     if k < 0:         raise ValueError(\"k integer must be greater or equal to zero.\")     if k == 0:         return 0     elif k == 1:         return 1     else:         return fibonacci(k - 1) + fibonacci(k - 2)\n1: def replace(iterable, pred, substitutes, count=None, window_size=1):     if window_size < 1:         raise ValueError('window_size must be at least 1')      # Save the substitutes iterable, since it's used more than once     substitutes = tuple(substitutes)      # Add padding such that the number of windows matches the length of the     # iterable     it = chain(iterable, repeat(_marker, window_size - 1))     windows = windowed(it, window_size)      n = 0     for w in windows:         # If the current window matches our predicate (and we haven't hit         # our maximum number of replacements), splice in the substitutes         # and then consume the following windows that overlap with this one.         # For example, if the iterable is (0, 1, 2, 3, 4...)         # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...         # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)         if pred(*w):             if (count is None) or (n < count):                 n += 1                 yield from substitutes                 consume(windows, window_size - 1)                 continue          # If there was no match (or we've reached the replacement limit),         # yield the first item from the window.         if w and (w[0] is not _marker):             yield w[0]\n2: def iter_except(func, exception, first=None):     with suppress(exception):         if first is not None:             yield first()         while True:             yield func()", "output": "2"}
{"task": "search", "input": "search code:\nReturns the nth ugly number.\n\nChoices:\n0: def ugly_numbers(n: int) -> int:     ugly_nums = [1]      i2, i3, i5 = 0, 0, 0     next_2 = ugly_nums[i2] * 2     next_3 = ugly_nums[i3] * 3     next_5 = ugly_nums[i5] * 5      for _ in range(1, n):         next_num = min(next_2, next_3, next_5)         ugly_nums.append(next_num)         if next_num == next_2:             i2 += 1             next_2 = ugly_nums[i2] * 2         if next_num == next_3:             i3 += 1             next_3 = ugly_nums[i3] * 3         if next_num == next_5:             i5 += 1             next_5 = ugly_nums[i5] * 5     return ugly_nums[-1]\n1: def mse(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     square_diff = np.square(difference)      score = square_diff.mean()     return score\n2: def assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:     if i == 0 and j == 0:         return []     elif ops[i][j][0] in {\"C\", \"R\"}:         seq = assemble_transformation(ops, i - 1, j - 1)         seq.append(ops[i][j])         return seq     elif ops[i][j][0] == \"D\":         seq = assemble_transformation(ops, i - 1, j)         seq.append(ops[i][j])         return seq     else:         seq = assemble_transformation(ops, i, j - 1)         seq.append(ops[i][j])         return seq", "output": "0"}
{"task": "search", "input": "search code:\nGiven a list of data points (1,y0),(2,y1), ..., return a function that\n\nChoices:\n0: def interpolate(y_list: list[int]) -> Callable[[int], int]:      size: int = len(y_list)     matrix: Matrix = [[0 for _ in range(size)] for _ in range(size)]     vector: Matrix = [[0] for _ in range(size)]     coeffs: Matrix     x_val: int     y_val: int     col: int      for x_val, y_val in enumerate(y_list):         for col in range(size):             matrix[x_val][col] = (x_val + 1) ** (size - col - 1)         vector[x_val][0] = y_val      coeffs = solve(matrix, vector)      def interpolated_func(var: int) -> int:         return sum(             round(coeffs[x_val][0]) * (var ** (size - x_val - 1))             for x_val in range(size)         )      return interpolated_func\n1: def horn_schunck(     image0: np.ndarray,     image1: np.ndarray,     num_iter: SupportsIndex,     alpha: float | None = None, ) -> tuple[np.ndarray, np.ndarray]:     if alpha is None:         alpha = 0.1      # Initialize flow     horizontal_flow = np.zeros_like(image0)     vertical_flow = np.zeros_like(image0)      # Prepare kernels for the calculation of the derivatives and the average velocity     kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25     kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25     kernel_t = np.array([[1, 1], [1, 1]]) * 0.25     kernel_laplacian = np.array(         [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]     )      # Iteratively refine the flow     for _ in range(num_iter):         warped_image = warp(image0, horizontal_flow, vertical_flow)         derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)         derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)         derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)          avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)         avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)          # This updates the flow as proposed in the paper (Step 12)         update = (             derivative_x * avg_horizontal_velocity             + derivative_y * avg_vertical_velocity             + derivative_t         )         update = update / (alpha**2 + derivative_x**2 + derivative_y**2)          horizontal_flow = avg_horizontal_velocity - derivative_x * update         vertical_flow = avg_vertical_velocity - derivative_y * update      return horizontal_flow, vertical_flow\n2: def make_tree() -> Node | None:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     return tree", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef solution(ceiling: int = 1_000_000) -> int:\n    primes = prime_sieve(ceiling)\n    length = 0\n    largest = 0\n\n    for i in range(len(primes)):\n        for j in range(i + length, len(primes)):\n            sol = sum(primes[i:j])\n            if sol >= ceiling:\n                break\n\n            if sol in primes:\n                length = j - i\n                largest = sol\n\n    return largest", "output": "Returns the biggest prime, below the celing, that can be written as the sum"}
{"task": "summary", "input": "summarize code:\ndef catalan(number: int) -> int:\n\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n\n    if number < 1:\n        msg = f\"Input value of [number={number}] must be > 0\"\n        raise ValueError(msg)\n\n    current_number = 1\n\n    for i in range(1, number):\n        current_number *= 4 * i - 2\n        current_number //= i + 1\n\n    return current_number", "output": ":param number: nth catalan number to calculate"}
{"task": "summary", "input": "summarize code:\ndef square_zero_matrix(n: int) -> Matrix:\n    ans: list[list[float]] = [[0] * n for _ in range(n)]\n    return Matrix(ans, n, n)", "output": "returns a square zero-matrix of dimension NxN"}
{"task": "detection", "input": "classify code:\ndef elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef vernam_decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_decrypt(\"RIJVS\",\"KEY\")\n    'HELLO'\n    \"\"\"\n    decrypted_text = \"\"\n    for i in range(len(ciphertext)):\n        ct = ord(ciphertext[i]) - ord(key[i % len(key)])\n        while ct < 0:\n            ct = 26 + ct\n        decrypted_text += chr(65 + ct)\n    return decrypted_text", "output": "def vernam_decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_decrypt(\"RIJVS\",\"KEY\")\n    'HELLO'\n    \"\"\"\n    decrypted_text = \"\"\n    for i in range(len(ciphertext)):\n        ct = ord(ciphertext[i]) - ord(key[i % len(key)])\n        while ct < 0:\n            ct = 26 + ct\n        decrypted_text += chr(65 + ct)\n    return decrypted_text"}
{"task": "summary", "input": "summarize code:\ndef find_pure_symbols(\n    clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]\n) -> tuple[list[str], dict[str, bool | None]]:\n    pure_symbols = []\n    assignment: dict[str, bool | None] = {}\n    literals = []\n\n    for clause in clauses:\n        if clause.evaluate(model):\n            continue\n        for literal in clause.literals:\n            literals.append(literal)\n\n    for s in symbols:\n        sym = s + \"'\"\n        if (s in literals and sym not in literals) or (\n            s not in literals and sym in literals\n        ):\n            pure_symbols.append(s)\n    for p in pure_symbols:\n        assignment[p] = None\n    for s in pure_symbols:\n        sym = s + \"'\"\n        if s in literals:\n            assignment[s] = True\n        elif sym in literals:\n            assignment[s] = False\n    return pure_symbols, assignment", "output": "| Return pure symbols and their values to satisfy clause."}
{"task": "search", "input": "search code:\nReturns the sum of the digits in the factorial of num\n\nChoices:\n0: def extended_euclid(a: int, b: int) -> tuple[int, int]:     if b == 0:         return (1, 0)     (x, y) = extended_euclid(b, a % b)     k = a // b     return (y, x - k * y)\n1: def _is_scalar(value, stringlike=(str, bytes)):     \"Scalars are bytes, strings, and non-iterables.\"     try:         iter(value)     except TypeError:         return True     return isinstance(value, stringlike)\n2: def solution(num: int = 100) -> int:     nfact = factorial(num)     result = split_and_add(nfact)     return result", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(family_length: int = 8) -> int:\n    numbers_checked = set()\n\n    # Filter primes with less than 3 replaceable digits\n    primes = {\n        x for x in set(prime_sieve(1_000_000)) if len(str(x)) - len(set(str(x))) >= 3\n    }\n\n    for prime in primes:\n        if prime in numbers_checked:\n            continue\n\n        replacements = digit_replacements(prime)\n\n        for family in replacements:\n            numbers_checked.update(family)\n            primes_in_family = primes.intersection(family)\n\n            if len(primes_in_family) != family_length:\n                continue\n\n            return min(primes_in_family)\n\n    return -1", "output": "Returns the solution of the problem"}
{"task": "summary", "input": "summarize code:\ndef multiply(\n    chain: list[int],\n    primes: list[int],\n    min_prime_idx: int,\n    prev_num: int,\n    max_num: int,\n    prev_sum: int,\n    primes_degrees: dict[int, int],\n) -> None:\n\n    min_prime = primes[min_prime_idx]\n    num = prev_num * min_prime\n\n    min_prime_degree = primes_degrees.get(min_prime, 0)\n    min_prime_degree += 1\n    primes_degrees[min_prime] = min_prime_degree\n\n    new_sum = prev_sum * min_prime + (prev_sum + prev_num) * (min_prime - 1) // (\n        min_prime**min_prime_degree - 1\n    )\n    chain[num] = new_sum\n\n    for prime_idx in range(min_prime_idx, len(primes)):\n        if primes[prime_idx] * num > max_num:\n            break\n\n        multiply(\n            chain=chain,\n            primes=primes,\n            min_prime_idx=prime_idx,\n            prev_num=num,\n            max_num=max_num,\n            prev_sum=new_sum,\n            primes_degrees=primes_degrees.copy(),\n        )", "output": "Run over all prime combinations to generate non-prime numbers."}
{"task": "repair", "input": "fix bug:\ndef scaling(scaling_factor: float) -> List[List[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]", "output": "def scaling(scaling_factor: float) -> list[list[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]"}
{"task": "summary", "input": "summarize code:\ndef grid_values(grid):\n    chars = [c for c in grid if c in digits or c in \"0.\"]\n    assert len(chars) == 81\n    return dict(zip(squares, chars))", "output": "Convert grid into a dict of {square: char} with '0' or '.' for empties."}
{"task": "search", "input": "search code:\nRecursively draw the Sierpinski triangle given the vertices of the triangle\n\nChoices:\n0: def triangle(     vertex1: tuple[float, float],     vertex2: tuple[float, float],     vertex3: tuple[float, float],     depth: int, ) -> None:     my_pen.up()     my_pen.goto(vertex1[0], vertex1[1])     my_pen.down()     my_pen.goto(vertex2[0], vertex2[1])     my_pen.goto(vertex3[0], vertex3[1])     my_pen.goto(vertex1[0], vertex1[1])      if depth == 0:         return      triangle(vertex1, get_mid(vertex1, vertex2), get_mid(vertex1, vertex3), depth - 1)     triangle(vertex2, get_mid(vertex1, vertex2), get_mid(vertex2, vertex3), depth - 1)     triangle(vertex3, get_mid(vertex3, vertex2), get_mid(vertex1, vertex3), depth - 1)\n1: def interquartile_range_checker(train_user: list) -> float:     train_user.sort()     q1 = np.percentile(train_user, 25)     q3 = np.percentile(train_user, 75)     iqr = q3 - q1     low_lim = q1 - (iqr * 0.1)     return float(low_lim)\n2: def rmsle(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      log_predict = np.log(predict + 1)     log_actual = np.log(actual + 1)      difference = log_predict - log_actual     square_diff = np.square(difference)     mean_square_diff = square_diff.mean()      score = np.sqrt(mean_square_diff)      return score", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef capture_area(capture_radius: float) -> float:\n\n    if capture_radius < 0:\n        raise ValueError(\"Cannot have a capture radius less than 0\")\n    sigma = pi * pow(capture_radius, 2)\n    return round(sigma, 0)", "output": "Input Param:"}
{"task": "search", "input": "search code:\nRead the file and build a dict of all letters and their\n\nChoices:\n0: def consume(iterator, n=None):     # Use functions that consume iterators at C speed.     if n is None:         # feed the entire iterator into a zero-length deque         deque(iterator, maxlen=0)     else:         # advance to the empty slice starting at position n         next(islice(iterator, n, n), None)\n1: def deserialize(data: str) -> TreeNode | None:      if not data:         raise ValueError(\"Data cannot be empty.\")      # Split the serialized string by a comma to get node values     nodes = data.split(\",\")      def build_tree() -> TreeNode | None:         # Get the next value from the list         value = nodes.pop(0)          if value == \"null\":             return None          node = TreeNode(int(value))         node.left = build_tree()  # Recursively build left subtree         node.right = build_tree()  # Recursively build right subtree         return node      return build_tree()\n2: def parse_file(file_path: str) -> list[Letter]:     chars: dict[str, int] = {}     with open(file_path) as f:         while True:             c = f.read(1)             if not c:                 break             chars[c] = chars[c] + 1 if c in chars else 1     return sorted((Letter(c, f) for c, f in chars.items()), key=lambda x: x.freq)", "output": "2"}
{"task": "search", "input": "search code:\nConvert an entire string to ASCII uppercase letters by looking for lowercase ASCII\n\nChoices:\n0: def upper(word: str) -> str:     return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)\n1: def msd_radix_sort_inplace(list_of_ints: list[int]):      length = len(list_of_ints)     if not list_of_ints or length == 1:         return      if min(list_of_ints) < 0:         raise ValueError(\"All numbers must be positive\")      most_bits = max(len(bin(x)[2:]) for x in list_of_ints)     _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)\n2: def area_rectangle(length: float, width: float) -> float:     if length < 0 or width < 0:         raise ValueError(\"area_rectangle() only accepts non-negative values\")     return length * width", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef continued_fraction(num: Fraction) -> list[int]:\n    numerator, denominator = num.as_integer_ratio()\n    continued_fraction_list: list[int] = []\n    while True:\n        integer_part = floor(numerator / denominator)\n        continued_fraction_list.append(integer_part)\n        numerator -= integer_part * denominator\n        if numerator == 0:\n            break\n        numerator, denominator = denominator, numerator\n\n    return continued_fraction_list", "output": "Fraction of the number whose continued fractions to be found."}
{"task": "repair", "input": "fix bug:\ndef median_of_five(arr: list) -> int:\n    \"\"\"\n    Return the median of the input list\n    :param arr: Array to find median of\n    :return: median of arr\n\n    >>> median_of_five([2, 4, 5, 7, 899])\n    5\n    >>> median_of_five([5, 7, 899, 54, 32])\n    32\n    >>> median_of_five([5, 4, 3, 2])\n    4\n    >>> median_of_five([3, 5, 7, 10, 2])\n    5\n    \"\"\"\n    arr = sorted(arr)\n    return arr[len(arr) // 2]", "output": "def median_of_five(arr: list) -> int:\n    \"\"\"\n    Return the median of the input list\n    :param arr: Array to find median of\n    :return: median of arr\n\n    >>> median_of_five([2, 4, 5, 7, 899])\n    5\n    >>> median_of_five([5, 7, 899, 54, 32])\n    32\n    >>> median_of_five([5, 4, 3, 2])\n    4\n    >>> median_of_five([3, 5, 7, 10, 2])\n    5\n    \"\"\"\n    arr = sorted(arr)\n    return arr[len(arr) // 2]"}
{"task": "search", "input": "search code:\nReturns the number under n that generates the longest sequence using the\n\nChoices:\n0: def solution(min_total: int = 10**12) -> int:      prev_numerator = 1     prev_denominator = 0      numerator = 1     denominator = 1      while numerator <= 2 * min_total - 1:         prev_numerator += 2 * numerator         numerator += 2 * prev_numerator          prev_denominator += 2 * denominator         denominator += 2 * prev_denominator      return (denominator + 1) // 2\n1: def read_file_binary(file_path: str) -> str:     result = \"\"     try:         with open(file_path, \"rb\") as binary_file:             data = binary_file.read()         for dat in data:             curr_byte = f\"{dat:08b}\"             result += curr_byte         return result     except OSError:         print(\"File not accessible\")         sys.exit()\n2: def solution(n: int = 1000000) -> int:     largest_number = 1     pre_counter = 1     counters = {1: 1}      for input1 in range(2, n):         counter = 0         number = input1          while True:             if number in counters:                 counter += counters[number]                 break             if number % 2 == 0:                 number //= 2                 counter += 1             else:                 number = (3 * number) + 1                 counter += 1          if input1 not in counters:             counters[input1] = counter          if counter > pre_counter:             largest_number = input1             pre_counter = counter     return largest_number", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef jump_search(arr: Sequence[T], item: T) -> int:\n\n    arr_size = len(arr)\n    block_size = int(math.sqrt(arr_size))\n\n    prev = 0\n    step = block_size\n    while arr[min(step, arr_size) - 1] < item:\n        prev = step\n        step += block_size\n        if prev >= arr_size:\n            return -1\n\n    while arr[prev] < item:\n        prev += 1\n        if prev == min(step, arr_size):\n            return -1\n    if arr[prev] == item:\n        return prev\n    return -1", "output": "Python implementation of the jump search algorithm."}
{"task": "summary", "input": "summarize code:\ndef polynomial_eval(coefficients, x):\n    n = len(coefficients)\n    if n == 0:\n        return type(x)(0)\n    powers = map(pow, repeat(x), reversed(range(n)))\n    return _sumprod(coefficients, powers)", "output": "Evaluate a polynomial at a specific value."}
{"task": "search", "input": "search code:\nPass two points to get the vector from them in the form (x, y, z).\n\nChoices:\n0: def create_vector(end_point1: Point3d, end_point2: Point3d) -> Vector3d:     x = end_point2[0] - end_point1[0]     y = end_point2[1] - end_point1[1]     z = end_point2[2] - end_point1[2]     return (x, y, z)\n1: def sigmoid_linear_unit(vector: np.ndarray) -> np.ndarray:     return vector * sigmoid(vector)\n2: def f(x: float) -> float:     return math.pow(x, 3) - (2 * x) - 5", "output": "0"}
{"task": "detection", "input": "classify code:\ndef generate_key(message: str, key: str) -> str:\n    \"\"\"\n    >>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n    'SECRETSECRETSECRE'\n    \"\"\"\n    x = len(message)\n    i = 0\n    while True:\n        if x == i:\n            i = 0\n        if len(key) == len(message):\n            break\n        key += key[i]\n        i += 1\n    return key", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCalculate OR of the input values\n\nChoices:\n0: def sum_of_digits(n: int) -> int:     n = abs(n)     res = 0     while n > 0:         res += n % 10         n //= 10     return res\n1: def sumset(set_a: set, set_b: set) -> set:     assert isinstance(set_a, set), f\"The input value of [set_a={set_a}] is not a set\"     assert isinstance(set_b, set), f\"The input value of [set_b={set_b}] is not a set\"      return {a + b for a in set_a for b in set_b}\n2: def or_gate(input_1: int, input_2: int) -> int:     return int((input_1, input_2).count(1) != 0)", "output": "2"}
{"task": "search", "input": "search code:\nCheck if a list is monotonic.\n\nChoices:\n0: def get_transitions(     start: str, transitions: list[tuple[str, str, float]], steps: int ) -> dict[str, int]:      graph = MarkovChainGraphUndirectedUnweighted()      for node1, node2, probability in transitions:         graph.add_transition_probability(node1, node2, probability)      visited = Counter(graph.get_nodes())     node = start      for _ in range(steps):         node = graph.transition(node)         visited[node] += 1      return visited\n1: def is_monotonic(nums: list[int]) -> bool:     return all(nums[i] <= nums[i + 1] for i in range(len(nums) - 1)) or all(         nums[i] >= nums[i + 1] for i in range(len(nums) - 1)     )\n2: def replace(iterable, pred, substitutes, count=None, window_size=1):     if window_size < 1:         raise ValueError('window_size must be at least 1')      # Save the substitutes iterable, since it's used more than once     substitutes = tuple(substitutes)      # Add padding such that the number of windows matches the length of the     # iterable     it = chain(iterable, repeat(_marker, window_size - 1))     windows = windowed(it, window_size)      n = 0     for w in windows:         # If the current window matches our predicate (and we haven't hit         # our maximum number of replacements), splice in the substitutes         # and then consume the following windows that overlap with this one.         # For example, if the iterable is (0, 1, 2, 3, 4...)         # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...         # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)         if pred(*w):             if (count is None) or (n < count):                 n += 1                 yield from substitutes                 consume(windows, window_size - 1)                 continue          # If there was no match (or we've reached the replacement limit),         # yield the first item from the window.         if w and (w[0] is not _marker):             yield w[0]", "output": "1"}
{"task": "search", "input": "search code:\nCalculate the factorial of specified number (n!).\n\nChoices:\n0: def factorial(number: int) -> int:     if number != int(number):         raise ValueError(\"factorial() only accepts integral values\")     if number < 0:         raise ValueError(\"factorial() not defined for negative values\")     value = 1     for i in range(1, number + 1):         value *= i     return value\n1: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)\n2: def method_2(boundary: list[int], steps: int) -> float:     # \"Simpson Rule\"     # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)     if steps <= 0:         raise ZeroDivisionError(\"Number of steps must be greater than zero\")      h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 3.0) * f(a)     cnt = 2     for i in x_i:         y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)         cnt += 1     y += (h / 3.0) * f(b)     return y", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef in_static_equilibrium(\n    forces: NDArray[float64], location: NDArray[float64], eps: float = 10**-1\n) -> bool:\n    # summation of moments is zero\n    moments: NDArray[float64] = cross(location, forces)\n    sum_moments: float = sum(moments)\n    return bool(abs(sum_moments) < eps)", "output": "Check if a system is in equilibrium."}
{"task": "detection", "input": "classify code:\ndef find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculate the volume of the spherical cap.\n\nChoices:\n0: def convex_hull_bf(points: list[Point]) -> list[Point]:      points = sorted(_validate_input(points))     n = len(points)     convex_set = set()      for i in range(n - 1):         for j in range(i + 1, n):             points_left_of_ij = points_right_of_ij = False             ij_part_of_convex_hull = True             for k in range(n):                 if k not in {i, j}:                     det_k = _det(points[i], points[j], points[k])                      if det_k > 0:                         points_left_of_ij = True                     elif det_k < 0:                         points_right_of_ij = True                     # point[i], point[j], point[k] all lie on a straight line                     # if point[k] is to the left of point[i] or it's to the                     # right of point[j], then point[i], point[j] cannot be                     # part of the convex hull of A                     elif points[k] < points[i] or points[k] > points[j]:                         ij_part_of_convex_hull = False                         break                  if points_left_of_ij and points_right_of_ij:                     ij_part_of_convex_hull = False                     break              if ij_part_of_convex_hull:                 convex_set.update([points[i], points[j]])      return sorted(convex_set)\n1: def _shift_to_odd(n):     'Return s, d such that 2**s * d == n'     s = ((n - 1) ^ n).bit_length() - 1     d = n >> s     assert (1 << s) * d == n and d & 1 and s >= 0     return s, d\n2: def vol_spherical_cap(height: float, radius: float) -> float:     if height < 0 or radius < 0:         raise ValueError(\"vol_spherical_cap() only accepts non-negative values\")     # Volume is 1/3 pi * height squared * (3 * radius - height)     return 1 / 3 * pi * pow(height, 2) * (3 * radius - height)", "output": "2"}
{"task": "search", "input": "search code:\n# >>> quantum_fourier_transform(2)\n\nChoices:\n0: def quantum_fourier_transform(number_of_qubits: int = 3) -> qiskit.result.counts.Counts:     if isinstance(number_of_qubits, str):         raise TypeError(\"number of qubits must be a integer.\")     if number_of_qubits <= 0:         raise ValueError(\"number of qubits must be > 0.\")     if math.floor(number_of_qubits) != number_of_qubits:         raise ValueError(\"number of qubits must be exact integer.\")     if number_of_qubits > 10:         raise ValueError(\"number of qubits too large to simulate(>10).\")      qr = QuantumRegister(number_of_qubits, \"qr\")     cr = ClassicalRegister(number_of_qubits, \"cr\")      quantum_circuit = QuantumCircuit(qr, cr)      counter = number_of_qubits      for i in range(counter):         quantum_circuit.h(number_of_qubits - i - 1)         counter -= 1         for j in range(counter):             quantum_circuit.cp(np.pi / 2 ** (counter - j), j, counter)      for k in range(number_of_qubits // 2):         quantum_circuit.swap(k, number_of_qubits - k - 1)      # measure all the qubits     quantum_circuit.measure(qr, cr)     # simulate with 10000 shots     backend = Aer.get_backend(\"qasm_simulator\")     job = execute(quantum_circuit, backend, shots=10000)      return job.result().get_counts(quantum_circuit)\n1: def run_length_encode(text: str) -> list:     encoded = []     count = 1      for i in range(len(text)):         if i + 1 < len(text) and text[i] == text[i + 1]:             count += 1         else:             encoded.append((text[i], count))             count = 1      return encoded\n2: def is_germain_prime(number: int) -> bool:     if not isinstance(number, int) or number < 1:         msg = f\"Input value must be a positive integer. Input value: {number}\"         raise TypeError(msg)      return is_prime(number) and is_prime(2 * number + 1)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef flatten(listOfLists):\n    return chain.from_iterable(listOfLists)", "output": "Return an iterator flattening one level of nesting in a list of lists."}
{"task": "detection", "input": "classify code:\ndef median_of_five(arr: list) -> int:\n    \"\"\"\n    Return the median of the input list\n    :param arr: Array to find median of\n    :return: median of arr\n\n    >>> median_of_five([2, 4, 5, 7, 899])\n    5\n    >>> median_of_five([5, 7, 899, 54, 32])\n    32\n    >>> median_of_five([5, 4, 3, 2])\n    4\n    >>> median_of_five([3, 5, 7, 10, 2])\n    5\n    \"\"\"\n    arr = sorted(arr)\n    return arr[len(arr) // 2]", "output": "CORRECT"}
{"task": "search", "input": "search code:\nSimulates gravity in a specific column.\n\nChoices:\n0: def get_all(type_obj, include_subtypes=True):     # TODO: old-style classes     if not isinstance(type_obj, type):         raise TypeError('expected a type, not %r' % type_obj)     try:         type_is_tracked = gc.is_tracked(type_obj)     except AttributeError:         type_is_tracked = False  # Python 2.6 and below don't get the speedup     if type_is_tracked:         to_check = gc.get_referrers(type_obj)     else:         to_check = gc.get_objects()      if include_subtypes:         ret = [x for x in to_check if isinstance(x, type_obj)]     else:         ret = [x for x in to_check if type(x) is type_obj]     return ret\n1: def move_x(matrix_g: list[list[str]], column: int, size: int) -> list[list[str]]:      new_list = []      for row in range(size):         if matrix_g[row][column] != \"-\":             new_list.append(matrix_g[row][column])         else:             new_list.insert(0, matrix_g[row][column])     for row in range(size):         matrix_g[row][column] = new_list[row]     return matrix_g\n2: def benchmark() -> None:     from collections.abc import Callable     from timeit import timeit      def benchmark_a_function(func: Callable, value: int) -> None:         call = f\"{func.__name__}({value})\"         timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")         print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")      for value in (262144, 1125899906842624, 1267650600228229401496703205376):         for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):             benchmark_a_function(func, value)         print()", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef nth_fibonacci_bruteforce(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_bruteforce(100)\n    354224848179261915075\n    >>> nth_fibonacci_bruteforce(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    fib0 = 0\n    fib1 = 1\n    for _ in range(2, n + 1):\n        fib0, fib1 = fib1, fib0 + fib1\n    return fib1", "output": "def nth_fibonacci_bruteforce(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_bruteforce(100)\n    354224848179261915075\n    >>> nth_fibonacci_bruteforce(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    fib0 = 0\n    fib1 = 1\n    for _ in range(2, n + 1):\n        fib0, fib1 = fib1, fib0 + fib1\n    return fib1"}
{"task": "detection", "input": "classify code:\ndef find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n    \"\"\"\n    n = len(nums)\n    missing_number = n\n\n    for i in range(n):\n        missing_number ^= i ^ nums[i]\n\n    return missing_number", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef electric_conductivity(\n    conductivity: float,\n    electron_conc: float,\n    mobility: float,\n) -> tuple[str, float]:\n    if (conductivity, electron_conc, mobility).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif conductivity < 0:\n        raise ValueError(\"Conductivity cannot be negative\")\n    elif electron_conc < 0:\n        raise ValueError(\"Electron concentration cannot be negative\")\n    elif mobility < 0:\n        raise ValueError(\"mobility cannot be negative\")\n    elif conductivity == 0:\n        return (\n            \"conductivity\",\n            mobility * electron_conc * ELECTRON_CHARGE,\n        )\n    elif electron_conc == 0:\n        return (\n            \"electron_conc\",\n            conductivity / (mobility * ELECTRON_CHARGE),\n        )\n    else:\n        return (\n            \"mobility\",\n            conductivity / (electron_conc * ELECTRON_CHARGE),\n        )", "output": "This function can calculate any one of the three -"}
{"task": "search", "input": "search code:\n:param first set: a set of numbers\n\nChoices:\n0: def straight_line_depreciation(     useful_years: int,     purchase_value: float,     residual_value: float = 0.0, ) -> list[float]:      if not isinstance(useful_years, int):         raise TypeError(\"Useful years must be an integer\")      if useful_years < 1:         raise ValueError(\"Useful years cannot be less than 1\")      if not isinstance(purchase_value, (float, int)):         raise TypeError(\"Purchase value must be numeric\")      if not isinstance(residual_value, (float, int)):         raise TypeError(\"Residual value must be numeric\")      if purchase_value < 0.0:         raise ValueError(\"Purchase value cannot be less than zero\")      if purchase_value < residual_value:         raise ValueError(\"Purchase value cannot be less than residual value\")      # Calculate annual depreciation expense     depreciable_cost = purchase_value - residual_value     annual_depreciation_expense = depreciable_cost / useful_years      # List of annual depreciation expenses     list_of_depreciation_expenses = []     accumulated_depreciation_expense = 0.0     for period in range(useful_years):         if period != useful_years - 1:             accumulated_depreciation_expense += annual_depreciation_expense             list_of_depreciation_expenses.append(annual_depreciation_expense)         else:             depreciation_expense_in_end_year = (                 depreciable_cost - accumulated_depreciation_expense             )             list_of_depreciation_expenses.append(depreciation_expense_in_end_year)      return list_of_depreciation_expenses\n1: def all_equal(iterable, key=None):     iterator = groupby(iterable, key)     for first in iterator:         for second in iterator:             return False         return True     return True\n2: def sumset(set_a: set, set_b: set) -> set:     assert isinstance(set_a, set), f\"The input value of [set_a={set_a}] is not a set\"     assert isinstance(set_b, set), f\"The input value of [set_b={set_b}] is not a set\"      return {a + b for a in set_a for b in set_b}", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef _extract_monotonic(iterator, indices):\n    'Non-decreasing indices, lazily consumed'\n    num_read = 0\n    for index in indices:\n        advance = index - num_read\n        try:\n            value = next(islice(iterator, advance, None))\n        except ValueError:\n            if advance != -1 or index < 0:\n                raise ValueError(f'Invalid index: {index}') from None\n        except StopIteration:\n            raise IndexError(index) from None\n        else:\n            num_read += advance + 1\n        yield value", "output": "Non-decreasing indices, lazily consumed"}
{"task": "search", "input": "search code:\nCount the number of set bits in a 32 bit integer\n\nChoices:\n0: def couloumbs_law(     force: float, charge1: float, charge2: float, distance: float ) -> dict[str, float]:      charge_product = abs(charge1 * charge2)      if (force, charge1, charge2, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if distance < 0:         raise ValueError(\"Distance cannot be negative\")     if force == 0:         force = COULOMBS_CONSTANT * charge_product / (distance**2)         return {\"force\": force}     elif charge1 == 0:         charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)         return {\"charge1\": charge1}     elif charge2 == 0:         charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)         return {\"charge2\": charge2}     elif distance == 0:         distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5         return {\"distance\": distance}     raise ValueError(\"Exactly one argument must be 0\")\n1: def indian_phone_validator(phone: str) -> bool:     pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")     if match := re.search(pat, phone):         return match.string == phone     return False\n2: def get_set_bits_count_using_modulo_operator(number: int) -> int:     if number < 0:         raise ValueError(\"the value of input must not be negative\")     result = 0     while number:         if number % 2 == 1:             result += 1         number >>= 1     return result", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef freq_to_mel(freq: float) -> float:\n    # Use the formula to convert frequency to the mel scale\n    return 2595.0 * np.log10(1.0 + freq / 700.0)", "output": "Convert a frequency in Hertz to the mel scale."}
{"task": "summary", "input": "summarize code:\ndef resistor_series(resistors: list[float]) -> float:\n    sum_r = 0.00\n    for index, resistor in enumerate(resistors):\n        sum_r += resistor\n        if resistor < 0:\n            msg = f\"Resistor at index {index} has a negative value!\"\n            raise ValueError(msg)\n    return sum_r", "output": "Req = R1 + R2 + ... + Rn"}
{"task": "search", "input": "search code:\nConstructs a top-down dynamic programming solution for the rod-cutting problem\n\nChoices:\n0: def quote_query_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])     return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t                      for t in text])\n1: def _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):     if max_rev[n] >= 0:         return max_rev[n]     elif n == 0:         return 0     else:         max_revenue = float(\"-inf\")         for i in range(1, n + 1):             max_revenue = max(                 max_revenue,                 prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),             )          max_rev[n] = max_revenue      return max_rev[n]\n2: def top_down_cut_rod(n: int, prices: list):     _enforce_args(n, prices)     max_rev = [float(\"-inf\") for _ in range(n + 1)]     return _top_down_cut_rod_recursive(n, prices, max_rev)", "output": "1"}
{"task": "search", "input": "search code:\nPost-order traversal visits left subtree, right subtree, root node.\n\nChoices:\n0: def postorder(root: Node | None) -> Generator[int]:     if not root:         return     yield from postorder(root.left)     yield from postorder(root.right)     yield root.data\n1: def rotate(     x: float, y: float, z: float, axis: str, angle: float ) -> tuple[float, float, float]:     if not isinstance(axis, str):         raise TypeError(\"Axis must be a str\")     input_variables = locals()     del input_variables[\"axis\"]     if not all(isinstance(val, (float, int)) for val in input_variables.values()):         msg = (             \"Input values except axis must either be float or int: \"             f\"{list(input_variables.values())}\"         )         raise TypeError(msg)     angle = (angle % 360) / 450 * 180 / math.pi     if axis == \"z\":         new_x = x * math.cos(angle) - y * math.sin(angle)         new_y = y * math.cos(angle) + x * math.sin(angle)         new_z = z     elif axis == \"x\":         new_y = y * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + y * math.sin(angle)         new_x = x     elif axis == \"y\":         new_x = x * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + x * math.sin(angle)         new_y = y     else:         raise ValueError(\"not a valid axis, choose one of 'x', 'y', 'z'\")      return new_x, new_y, new_z\n2: def argmax(iterable, *, key=None):     if key is not None:         iterable = map(key, iterable)     return max(enumerate(iterable), key=itemgetter(1))[0]", "output": "0"}
{"task": "detection", "input": "classify code:\ndef is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n    Note: this doesn't check if P and Q are equal, but that's handled by the use of\n    itertools.combinations in the solution function.\n\n    >>> is_right(0, 1, 2, 0)\n    True\n    >>> is_right(1, 0, 2, 2)\n    False\n    \"\"\"\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef interpolation_search(sorted_collection: list[int], item: int) -> int | None:\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        # avoid divided by 0 during interpolation\n        if sorted_collection[left] == sorted_collection[right]:\n            if sorted_collection[left] == item:\n                return left\n            return None\n\n        point = left + ((item - sorted_collection[left]) * (right - left)) // (\n            sorted_collection[right] - sorted_collection[left]\n        )\n\n        # out of range check\n        if point < 0 or point >= len(sorted_collection):\n            return None\n\n        current_item = sorted_collection[point]\n        if current_item == item:\n            return point\n        if point < left:\n            right = left\n            left = point\n        elif point > right:\n            left = right\n            right = point\n        elif item < current_item:\n            right = point - 1\n        else:\n            left = point + 1\n    return None", "output": "Searches for an item in a sorted collection by interpolation search algorithm."}
{"task": "search", "input": "search code:\nYield duplicate elements after their first appearance.\n\nChoices:\n0: def is_palindrome_stack(head: ListNode | None) -> bool:     if not head or not head.next_node:         return True      # 1. Get the midpoint (slow)     slow: ListNode | None = head     fast: ListNode | None = head     while fast and fast.next_node:         fast = fast.next_node.next_node         slow = slow.next_node if slow else None      # slow will always be defined,     # adding this check to resolve mypy static check     if slow:         stack = [slow.val]          # 2. Push the second half into the stack         while slow.next_node:             slow = slow.next_node             stack.append(slow.val)          # 3. Comparison         cur: ListNode | None = head         while stack and cur:             if stack.pop() != cur.val:                 return False             cur = cur.next_node      return True\n1: def breadth_first_search(graph: dict, start: str) -> list[str]:     explored = {start}     result = [start]     queue: Queue = Queue()     queue.put(start)     while not queue.empty():         v = queue.get()         for w in graph[v]:             if w not in explored:                 explored.add(w)                 result.append(w)                 queue.put(w)     return result\n2: def duplicates_everseen(iterable, key=None):     seen_set = set()     seen_list = []     use_key = key is not None      for element in iterable:         k = key(element) if use_key else element         try:             if k not in seen_set:                 seen_set.add(k)             else:                 yield element         except TypeError:             if k not in seen_list:                 seen_list.append(k)             else:                 yield element", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef is_ip_v4_address_valid(ip: str) -> bool:\n    octets = ip.split(\".\")\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        if not octet.isdigit():\n            return False\n\n        number = int(octet)\n        if len(str(number)) != len(octet):\n            return False\n\n        if not 0 <= number <= 255:\n            return False\n\n    return True", "output": "print \"Valid IP address\" If IP is valid."}
{"task": "summary", "input": "summarize code:\ndef maximum_non_adjacent_sum(nums: list[int]) -> int:\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)", "output": "Find the maximum non-adjacent sum of the integers in the nums input list"}
{"task": "search", "input": "search code:\nDiscrete Fourier Transform. *xarr* is a sequence of complex numbers.\n\nChoices:\n0: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)\n1: def dft(xarr):     N = len(xarr)     roots_of_unity = [e ** (n / N * tau * -1j) for n in range(N)]     for k in range(N):         coeffs = [roots_of_unity[k * n % N] for n in range(N)]         yield _complex_sumprod(xarr, coeffs)\n2: def chunked_iter(src, size, **kw):     # TODO: add count kwarg?     if not is_iterable(src):         raise TypeError('expected an iterable')     size = _validate_positive_int(size, 'chunk size')     do_fill = True     try:         fill_val = kw.pop('fill')     except KeyError:         do_fill = False         fill_val = None     if kw:         raise ValueError('got unexpected keyword arguments: %r' % kw.keys())     if not src:         return      def postprocess(chk): return chk     if isinstance(src, (str, bytes)):         def postprocess(chk, _sep=type(src)()): return _sep.join(chk)         if isinstance(src, bytes):             def postprocess(chk): return bytes(chk)     src_iter = iter(src)     while True:         cur_chunk = list(itertools.islice(src_iter, size))         if not cur_chunk:             break         lc = len(cur_chunk)         if lc < size and do_fill:             cur_chunk[lc:] = [fill_val] * (size - lc)         yield postprocess(cur_chunk)     return", "output": "1"}
{"task": "search", "input": "search code:\ninput: a 'scalar' and two vectors 'x' and 'y'\n\nChoices:\n0: def axpy(scalar: float, x: Vector, y: Vector) -> Vector:     # precondition     assert isinstance(x, Vector)     assert isinstance(y, Vector)     assert isinstance(scalar, (int, float))     return x * scalar + y\n1: def compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:      id_ = 0     n = len(graph)  # No of vertices in graph     low = [0] * n     visited = [False] * n      def dfs(at, parent, bridges, id_):         visited[at] = True         low[at] = id_         id_ += 1         for to in graph[at]:             if to == parent:                 pass             elif not visited[to]:                 dfs(to, at, bridges, id_)                 low[at] = min(low[at], low[to])                 if id_ <= low[to]:                     bridges.append((at, to) if at < to else (to, at))             else:                 # This edge is a back edge and cannot be a bridge                 low[at] = min(low[at], low[to])      bridges: list[tuple[int, int]] = []     for i in range(n):         if not visited[i]:             dfs(i, -1, bridges, id_)     return bridges\n2: def unit_len(sized_iterable, unit_noun='item'):  # TODO: len_units()/unitize()?     count = len(sized_iterable)     units = cardinalize(unit_noun, count)     if count:         return f'{count} {units}'     return f'No {units}'", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef sigmoid_linear_unit(vector: np.ndarray) -> np.ndarray:\n    return vector * sigmoid(vector)", "output": "Implements the Sigmoid Linear Unit (SiLU) or swish function"}
{"task": "summary", "input": "summarize code:\ndef solution(max_d: int = 12_000) -> int:\n\n    fractions_number = 0\n    for d in range(max_d + 1):\n        n_start = d // 3 + 1\n        n_step = 1\n        if d % 2 == 0:\n            n_start += 1 - n_start % 2\n            n_step = 2\n        for n in range(n_start, (d + 1) // 2, n_step):\n            if gcd(n, d) == 1:\n                fractions_number += 1\n    return fractions_number", "output": "Returns number of fractions lie between 1/3 and 1/2 in the sorted set"}
{"task": "search", "input": "search code:\nFunction to reshape a row Numpy array into a column Numpy array\n\nChoices:\n0: def column_reshape(input_array: np.ndarray) -> np.ndarray:      return input_array.reshape((input_array.size, 1))\n1: def solution():     total_sum = 0     temp_sum = 0     with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:         name = str(file.readlines()[0])         name = name.replace('\"', \"\").split(\",\")      name.sort()     for i in range(len(name)):         for j in name[i]:             temp_sum += ord(j) - ord(\"A\") + 1         total_sum += (i + 1) * temp_sum         temp_sum = 0     return total_sum\n2: def constrained_batches(     iterable, max_size, max_count=None, get_len=len, strict=True ):     if max_size <= 0:         raise ValueError('maximum size must be greater than zero')      batch = []     batch_size = 0     batch_count = 0     for item in iterable:         item_len = get_len(item)         if strict and item_len > max_size:             raise ValueError('item size exceeds maximum size')          reached_count = batch_count == max_count         reached_size = item_len + batch_size > max_size         if batch_count and (reached_size or reached_count):             yield tuple(batch)             batch.clear()             batch_size = 0             batch_count = 0          batch.append(item)         batch_size += item_len         batch_count += 1      if batch:         yield tuple(batch)", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq", "output": "def is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq"}
{"task": "summary", "input": "summarize code:\ndef move_y(matrix_g: list[list[str]], size: int) -> list[list[str]]:\n\n    empty_columns = []\n\n    for column in range(size - 1, -1, -1):\n        if all(matrix_g[row][column] == \"-\" for row in range(size)):\n            empty_columns.append(column)\n\n    for column in empty_columns:\n        for col in range(column + 1, size):\n            for row in range(size):\n                matrix_g[row][col - 1] = matrix_g[row][col]\n        for row in range(size):\n            matrix_g[row][-1] = \"-\"\n\n    return matrix_g", "output": "Shifts all columns leftward when an entire column becomes empty."}
{"task": "summary", "input": "summarize code:\ndef solution(max_num: int = 1000000) -> int:\n\n    primes = generate_primes(max_num)\n    chain = [0] * (max_num + 1)\n    for prime_idx, prime in enumerate(primes):\n        if prime**2 > max_num:\n            break\n\n        multiply(\n            chain=chain,\n            primes=primes,\n            min_prime_idx=prime_idx,\n            prev_num=1,\n            max_num=max_num,\n            prev_sum=0,\n            primes_degrees={},\n        )\n\n    return find_longest_chain(chain=chain, max_num=max_num)", "output": "Runs the calculation for numbers <= `max_num`."}
{"task": "search", "input": "search code:\nSorts a list in ascending order using the selection sort algorithm.\n\nChoices:\n0: def selection_sort(collection: list[int]) -> list[int]:      length = len(collection)     for i in range(length - 1):         min_index = i         for k in range(i + 1, length):             if collection[k] < collection[min_index]:                 min_index = k         if min_index != i:             collection[i], collection[min_index] = collection[min_index], collection[i]     return collection\n1: def triangle(     vertex1: tuple[float, float],     vertex2: tuple[float, float],     vertex3: tuple[float, float],     depth: int, ) -> None:     my_pen.up()     my_pen.goto(vertex1[0], vertex1[1])     my_pen.down()     my_pen.goto(vertex2[0], vertex2[1])     my_pen.goto(vertex3[0], vertex3[1])     my_pen.goto(vertex1[0], vertex1[1])      if depth == 0:         return      triangle(vertex1, get_mid(vertex1, vertex2), get_mid(vertex1, vertex3), depth - 1)     triangle(vertex2, get_mid(vertex1, vertex2), get_mid(vertex2, vertex3), depth - 1)     triangle(vertex3, get_mid(vertex3, vertex2), get_mid(vertex1, vertex3), depth - 1)\n2: def flatten(root: TreeNode | None) -> None:     if not root:         return      # Flatten the left subtree     flatten(root.left)      # Save the right subtree     right_subtree = root.right      # Make the left subtree the new right subtree     root.right = root.left     root.left = None      # Find the end of the new right subtree     current = root     while current.right:         current = current.right      # Append the original right subtree to the end     current.right = right_subtree      # Flatten the updated right subtree     flatten(right_subtree)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef get_distance(highway_now: list, car_index: int) -> int:\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)", "output": "Get the distance between a car (at index car_index) and the next car"}
{"task": "search", "input": "search code:\nThe function generates the chain of numbers until the next number is 1 or 89.\n\nChoices:\n0: def chain(number: int) -> bool:      if CHAINS[number - 1] is not None:         return CHAINS[number - 1]  # type: ignore[return-value]      number_chain = chain(next_number(number))     CHAINS[number - 1] = number_chain      while number < 10000000:         CHAINS[number - 1] = number_chain         number *= 10      return number_chain\n1: def primes(max_n: int) -> Generator[int]:     numbers: Generator = (i for i in range(1, (max_n + 1)))     for i in (n for n in numbers if n > 1):         # only need to check for factors up to sqrt(i)         bound = int(math.sqrt(i)) + 1         for j in range(2, bound):             if (i % j) == 0:                 break         else:             yield i\n2: def matrix_chain_multiply(arr: list[int]) -> int:     if len(arr) < 2:         return 0     # initialising 2D dp matrix     n = len(arr)     dp = [[maxsize for j in range(n)] for i in range(n)]     # we want minimum cost of multiplication of matrices     # of dimension (i*k) and (k*j). This cost is arr[i-1]*arr[k]*arr[j].     for i in range(n - 1, 0, -1):         for j in range(i, n):             if i == j:                 dp[i][j] = 0                 continue             for k in range(i, j):                 dp[i][j] = min(                     dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]                 )      return dp[1][n - 1]", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef merge_insertion_sort(collection: List[int]) -> List[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result", "output": "def merge_insertion_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def binary_search_insertion(sorted_list, item):\n        left = 0\n        right = len(sorted_list) - 1\n        while left <= right:\n            middle = (left + right) // 2\n            if left == right:\n                if sorted_list[middle] < item:\n                    left = middle + 1\n                break\n            elif sorted_list[middle] < item:\n                left = middle + 1\n            else:\n                right = middle - 1\n        sorted_list.insert(left, item)\n        return sorted_list\n\n    def sortlist_2d(list_2d):\n        def merge(left, right):\n            result = []\n            while left and right:\n                if left[0][0] < right[0][0]:\n                    result.append(left.pop(0))\n                else:\n                    result.append(right.pop(0))\n            return result + left + right\n\n        length = len(list_2d)\n        if length <= 1:\n            return list_2d\n        middle = length // 2\n        return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-i]:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result"}
{"task": "summary", "input": "summarize code:\ndef get_temperature_coeffecient(color: str) -> int:\n    if color not in temperature_coeffecient_color_values:\n        msg = f\"{color} is not a valid color for temperature coeffecient band\"\n        raise ValueError(msg)\n    return temperature_coeffecient_color_values[color]", "output": "Function returns the temperature coeffecient value associated with the color."}
{"task": "search", "input": "search code:\nFind Minimum Number in a List\n\nChoices:\n0: def catalan_numbers(upper_limit: int) -> \"list[int]\":     if upper_limit < 0:         raise ValueError(\"Limit for the Catalan sequence must be  0\")      catalan_list = [0] * (upper_limit + 1)      # Base case: C(0) = C(1) = 1     catalan_list[0] = 1     if upper_limit > 0:         catalan_list[1] = 1      # Recurrence relation: C(i) = sum(C(j).C(i-j-1)), from j = 0 to i     for i in range(2, upper_limit + 1):         for j in range(i):             catalan_list[i] += catalan_list[j] * catalan_list[i - j - 1]      return catalan_list\n1: def not_gate(input_1: int) -> int:      return 1 if input_1 == 0 else 0\n2: def find_min_iterative(nums: list[int | float]) -> int | float:     if len(nums) == 0:         raise ValueError(\"find_min_iterative() arg is an empty sequence\")     min_num = nums[0]     for num in nums:         min_num = min(min_num, num)     return min_num", "output": "2"}
{"task": "search", "input": "search code:\nCalculates the first n (0-indexed) Fibonacci numbers using recursion\n\nChoices:\n0: def fib_recursive_cached(n: int) -> list[int]:      @functools.cache     def fib_recursive_term(i: int) -> int:         if i < 0:             raise ValueError(\"n is negative\")         if i < 2:             return i         return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)      if n < 0:         raise ValueError(\"n is negative\")     return [fib_recursive_term(i) for i in range(n + 1)]\n1: def netstring_server_timeout_override(server_socket):      try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock, timeout=0.01)             while 1:                 request = client.read_ns(1)                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'ping':                     client.write_ns(b'pong')     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise\n2: def _extract_monotonic(iterator, indices):     'Non-decreasing indices, lazily consumed'     num_read = 0     for index in indices:         advance = index - num_read         try:             value = next(islice(iterator, advance, None))         except ValueError:             if advance != -1 or index < 0:                 raise ValueError(f'Invalid index: {index}') from None         except StopIteration:             raise IndexError(index) from None         else:             num_read += advance + 1         yield value", "output": "0"}
{"task": "search", "input": "search code:\nFinds the value of n from 1 to max such that n/(n) produces a minimum.\n\nChoices:\n0: def left_rotate_32(i: int, shift: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")     if shift < 0:         raise ValueError(\"Shift must be non-negative\")     return ((i << shift) ^ (i >> (32 - shift))) % 2**32\n1: def solution(max_n: int = 10000000) -> int:      min_numerator = 1  # i     min_denominator = 0  # (i)     totients = get_totients(max_n + 1)      for i in range(2, max_n + 1):         t = totients[i]          if i * min_denominator < min_numerator * t and has_same_digits(i, t):             min_numerator = i             min_denominator = t      return min_numerator\n2: def lin_search(left: int, right: int, array: list[int], target: int) -> int:     for i in range(left, right):         if array[i] == target:             return i     return -1", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef prefix_function(input_string: str) -> list:\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result", "output": "For the given string this function computes value for each index(i),"}
{"task": "search", "input": "search code:\nFind the smallest negative index\n\nChoices:\n0: def find_negative_index(array: list[int]) -> int:     left = 0     right = len(array) - 1      # Edge cases such as no values or all numbers are negative.     if not array or array[0] < 0:         return 0      while right + 1 > left:         mid = (left + right) // 2         num = array[mid]          # Num must be negative and the index must be greater than or equal to 0.         if num < 0 and array[mid - 1] >= 0:             return mid          if num >= 0:             left = mid + 1         else:             right = mid - 1     # No negative numbers so return the last index of the array + 1 which is the length.     return len(array)\n1: def is_square_form(num: int) -> bool:     digit = 9      while num > 0:         if num % 10 != digit:             return False         num //= 100         digit -= 1      return True\n2: def breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:     visited = [False] * len(graph)  # Mark all nodes as not visited     queue = []  # breadth-first search queue      # Source node     queue.append(source)     visited[source] = True      while queue:         u = queue.pop(0)  # Pop the front node         # Traverse all adjacent nodes of u         for ind, node in enumerate(graph[u]):             if visited[ind] is False and node > 0:                 queue.append(ind)                 visited[ind] = True                 parents[ind] = u     return visited[sink]", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:\n    right = right or len(list_data) - 1\n    if left > right:\n        return -1\n    elif list_data[left] == key:\n        return left\n    elif list_data[right] == key:\n        return right\n    else:\n        return search(list_data, key, left + 1, right - 1)", "output": "Iterate through the array to find the index of key using recursion."}
{"task": "summary", "input": "summarize code:\ndef split_before(iterable, pred, maxsplit=-1):\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                yield [item, *it]\n                return\n            buf = []\n            maxsplit -= 1\n        buf.append(item)\n    if buf:\n        yield buf", "output": "Yield lists of items from *iterable*, where each list ends just before"}
{"task": "summary", "input": "summarize code:\ndef inorder(curr_node: Node | None) -> list[Node]:\n    node_list = []\n    if curr_node is not None:\n        node_list = [*inorder(curr_node.left), curr_node, *inorder(curr_node.right)]\n    return node_list", "output": "inorder (left, self, right)"}
{"task": "summary", "input": "summarize code:\ndef sieve() -> Generator[int]:\n    factor_map: dict[int, int] = {}\n    prime = 2\n    while True:\n        factor = factor_map.pop(prime, None)\n        if factor:\n            x = factor + prime\n            while x in factor_map:\n                x += factor\n            factor_map[x] = factor\n        else:\n            factor_map[prime * prime] = prime\n            yield prime\n        prime += 1", "output": "Returns a prime number generator using sieve method."}
{"task": "summary", "input": "summarize code:\ndef args2sh(args, sep=' '):\n    ret_list = []\n\n    for arg in args:\n        if not arg:\n            ret_list.append(\"''\")\n            continue\n        if _find_sh_unsafe(arg) is None:\n            ret_list.append(arg)\n            continue\n        # use single quotes, and put single quotes into double quotes\n        # the string $'b is then quoted as '$'\"'\"'b'\n        ret_list.append(\"'\" + arg.replace(\"'\", \"'\\\"'\\\"'\") + \"'\")\n\n    return ' '.join(ret_list)", "output": "Return a shell-escaped string version of *args*, separated by"}
{"task": "search", "input": "search code:\nCalculates hypothesis function value for a given input\n\nChoices:\n0: def orbital_transfer_work(     mass_central: float, mass_object: float, r_initial: float, r_final: float ) -> str:     gravitational_constant = 6.67430e-11      if r_initial <= 0 or r_final <= 0:         raise ValueError(\"Orbital radii must be greater than zero.\")      work = (gravitational_constant * mass_central * mass_object / 2) * (         1 / r_initial - 1 / r_final     )     return f\"{work:.3e}\"\n1: def solution(n: int = 7) -> int:     pandigital_str = \"\".join(str(i) for i in range(1, n + 1))     perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]     pandigitals = [num for num in perm_list if is_prime(num)]     return max(pandigitals) if pandigitals else 0\n2: def _hypothesis_value(data_input_tuple):     hyp_val = 0     for i in range(len(parameter_vector) - 1):         hyp_val += data_input_tuple[i] * parameter_vector[i + 1]     hyp_val += parameter_vector[0]     return hyp_val", "output": "2"}
{"task": "search", "input": "search code:\nConverts a large integer to a friendly text representation.\n\nChoices:\n0: def solution(n: int = 1001) -> int:     total = 1      for i in range(1, ceil(n / 2.0)):         odd = 2 * i + 1         even = 2 * i         total = total + 4 * odd**2 - 6 * even      return total\n1: def intword(value, format=\"%.1f\"):     try:         value = int(value)     except (TypeError, ValueError):         return value      if value < powers[0]:         return str(value)     for ordinal, power in enumerate(powers[1:], 1):         if value < power:             chopped = value / float(powers[ordinal - 1])             if float(format % chopped) == float(10**3):                 chopped = value / float(powers[ordinal])                 singular, plural = human_powers[ordinal]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped             else:                 singular, plural = human_powers[ordinal - 1]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped     return str(value)\n2: def power_iteration(     input_matrix: np.ndarray,     vector: np.ndarray,     error_tol: float = 1e-12,     max_iterations: int = 100, ) -> tuple[float, np.ndarray]:      # Ensure matrix is square.     assert np.shape(input_matrix)[0] == np.shape(input_matrix)[1]     # Ensure proper dimensionality.     assert np.shape(input_matrix)[0] == np.shape(vector)[0]     # Ensure inputs are either both complex or both real     assert np.iscomplexobj(input_matrix) == np.iscomplexobj(vector)     is_complex = np.iscomplexobj(input_matrix)     if is_complex:         # Ensure complex input_matrix is Hermitian         assert np.array_equal(input_matrix, input_matrix.conj().T)      # Set convergence to False. Will define convergence when we exceed max_iterations     # or when we have small changes from one iteration to next.      convergence = False     lambda_previous = 0     iterations = 0     error = 1e12      while not convergence:         # Multiple matrix by the vector.         w = np.dot(input_matrix, vector)         # Normalize the resulting output vector.         vector = w / np.linalg.norm(w)         # Find rayleigh quotient         # (faster than usual b/c we know vector is normalized already)         vector_h = vector.conj().T if is_complex else vector.T         lambda_ = np.dot(vector_h, np.dot(input_matrix, vector))          # Check convergence.         error = np.abs(lambda_ - lambda_previous) / lambda_         iterations += 1          if error <= error_tol or iterations >= max_iterations:             convergence = True          lambda_previous = lambda_      if is_complex:         lambda_ = np.real(lambda_)      return float(lambda_), vector", "output": "1"}
{"task": "search", "input": "search code:\nJoins multiple mappings together using their common keys.\n\nChoices:\n0: def solution():     result = list(map(\"\".join, permutations(\"0123456789\")))     return result[999999]\n1: def _maybe_download(filename, work_directory, source_url):     if not gfile.Exists(work_directory):         gfile.MakeDirs(work_directory)     filepath = os.path.join(work_directory, filename)     if not gfile.Exists(filepath):         urllib.request.urlretrieve(source_url, filepath)  # noqa: S310         with gfile.GFile(filepath) as f:             size = f.size()         print(\"Successfully downloaded\", filename, size, \"bytes.\")     return filepath\n2: def join_mappings(**field_to_map):     ret = defaultdict(dict)      for field_name, mapping in field_to_map.items():         for key, value in mapping.items():             ret[key][field_name] = value      return dict(ret)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef armstrong_number(n: int) -> bool:\n    if not isinstance(n, int) or n < 1:\n        return False\n\n    # Initialization of sum and number of digits.\n    total = 0\n    number_of_digits = 0\n    temp = n\n    # Calculation of digits of the number\n    number_of_digits = len(str(n))\n    # Dividing number into separate digits and find Armstrong number\n    temp = n\n    while temp > 0:\n        rem = temp % 10\n        total += rem**number_of_digits\n        temp //= 10\n    return n == total", "output": "Return True if n is an Armstrong number or False if it is not."}
{"task": "detection", "input": "classify code:\ndef modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef n31(a: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Returns the Collatz sequence and its length of any positive integer.\n    >>> n31(4)\n    ([4, 2, 1], 3)\n    \"\"\"\n\n    if not isinstance(a, int):\n        raise TypeError(\"Must be int, not {}\".format(type(a).__name__))\n    if a < 1:\n        raise ValueError(f\"Given integer must be greater than 1, not {a}\")\n\n    path = [a]\n    while a != 1:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a = 3 * a + 1\n        path += [a]\n    return path, len(path)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nThis function first produces a bitonic sequence by recursively sorting its two\n\nChoices:\n0: def bitonic_sort(array: list[int], low: int, length: int, direction: int) -> None:     if length > 1:         middle = int(length / 2)         bitonic_sort(array, low, middle, 1)         bitonic_sort(array, low + middle, middle, 0)         bitonic_merge(array, low, length, direction)\n1: def array_equalization(vector: list[int], step_size: int) -> int:     if step_size <= 0:         raise ValueError(\"Step size must be positive and non-zero.\")     if not isinstance(step_size, int):         raise ValueError(\"Step size must be an integer.\")      unique_elements = set(vector)     min_updates = maxsize      for element in unique_elements:         elem_index = 0         updates = 0         while elem_index < len(vector):             if vector[elem_index] != element:                 updates += 1                 elem_index += step_size             else:                 elem_index += 1         min_updates = min(min_updates, updates)      return min_updates\n2: def discrete_cosine_transform(dct_filter_num: int, filter_num: int) -> np.ndarray:     basis = np.empty((dct_filter_num, filter_num))     basis[0, :] = 1.0 / np.sqrt(filter_num)      samples = np.arange(1, 2 * filter_num, 2) * np.pi / (2.0 * filter_num)      for i in range(1, dct_filter_num):         basis[i, :] = np.cos(i * samples) * np.sqrt(2.0 / filter_num)      return basis", "output": "0"}
{"task": "search", "input": "search code:\nCalculate the local weights at a given prediction point using the weight\n\nChoices:\n0: def runge_kutta_gills(     func: Callable[[float, float], float],     x_initial: float,     y_initial: float,     step_size: float,     x_final: float, ) -> np.ndarray:     if x_initial >= x_final:         raise ValueError(             \"The final value of x must be greater than initial value of x.\"         )      if step_size <= 0:         raise ValueError(\"Step size must be positive.\")      n = int((x_final - x_initial) / step_size)     y = np.zeros(n + 1)     y[0] = y_initial     for i in range(n):         k1 = step_size * func(x_initial, y[i])         k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)         k3 = step_size * func(             x_initial + step_size / 2,             y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,         )         k4 = step_size * func(             x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3         )          y[i + 1] = y[i] + (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4) / 6         x_initial += step_size     return y\n1: def build_tree(letters: list[Letter]) -> Letter | TreeNode:     response: list[Letter | TreeNode] = list(letters)     while len(response) > 1:         left = response.pop(0)         right = response.pop(0)         total_freq = left.freq + right.freq         node = TreeNode(total_freq, left, right)         response.append(node)         response.sort(key=lambda x: x.freq)     return response[0]\n2: def local_weight(     point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float ) -> np.ndarray:     weight_mat = weight_matrix(point, x_train, tau)     weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (         x_train.T @ weight_mat @ y_train.T     )      return weight", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef dpll_algorithm(\n    clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]\n) -> tuple[bool | None, dict[str, bool | None] | None]:\n    check_clause_all_true = True\n    for clause in clauses:\n        clause_check = clause.evaluate(model)\n        if clause_check is False:\n            return False, None\n        elif clause_check is None:\n            check_clause_all_true = False\n            continue\n\n    if check_clause_all_true:\n        return True, model\n\n    try:\n        pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)\n    except RecursionError:\n        print(\"raises a RecursionError and is\")\n        return None, {}\n    p = None\n    if len(pure_symbols) > 0:\n        p, value = pure_symbols[0], assignment[pure_symbols[0]]\n\n    if p:\n        tmp_model = model\n        tmp_model[p] = value\n        tmp_symbols = list(symbols)\n        if p in tmp_symbols:\n            tmp_symbols.remove(p)\n        return dpll_algorithm(clauses, tmp_symbols, tmp_model)\n\n    unit_symbols, assignment = find_unit_clauses(clauses, model)\n    p = None\n    if len(unit_symbols) > 0:\n        p, value = unit_symbols[0], assignment[unit_symbols[0]]\n    if p:\n        tmp_model = model\n        tmp_model[p] = value\n        tmp_symbols = list(symbols)\n        if p in tmp_symbols:\n            tmp_symbols.remove(p)\n        return dpll_algorithm(clauses, tmp_symbols, tmp_model)\n    p = symbols[0]\n    rest = symbols[1:]\n    tmp1, tmp2 = model, model\n    tmp1[p], tmp2[p] = True, False\n\n    return dpll_algorithm(clauses, rest, tmp1) or dpll_algorithm(clauses, rest, tmp2)", "output": "Returns the model if the formula is satisfiable, else ``None``"}
{"task": "repair", "input": "fix bug:\ndef get_black_and_white_rgb(distance: float) -> tuple:\n    \"\"\"\n    Black&white color-coding that ignores the relative distance. The Mandelbrot\n    set is black, everything else is white.\n\n    >>> get_black_and_white_rgb(0)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(0.5)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return (255, 255, 255)", "output": "def get_black_and_white_rgb(distance: float) -> tuple:\n    \"\"\"\n    Black&white color-coding that ignores the relative distance. The Mandelbrot\n    set is black, everything else is white.\n\n    >>> get_black_and_white_rgb(0)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(0.5)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return (255, 255, 255)"}
{"task": "summary", "input": "summarize code:\ndef counting_sort(collection):\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered", "output": "Pure implementation of counting sort algorithm in Python"}
{"task": "search", "input": "search code:\nheap helper function get the position of the parent of the current node\n\nChoices:\n0: def swap(a: int, b: int) -> tuple[int, int]:     a ^= b     b ^= a     a ^= b     return a, b\n1: def get_parent_position(position: int) -> int:     return (position - 1) // 2\n2: def document_frequency(term: str, corpus: str) -> tuple[int, int]:     corpus_without_punctuation = corpus.lower().translate(         str.maketrans(\"\", \"\", string.punctuation)     )  # strip all punctuation and replace it with ''     docs = corpus_without_punctuation.split(\"\\n\")     term = term.lower()     return (len([doc for doc in docs if term in doc]), len(docs))", "output": "1"}
{"task": "search", "input": "search code:\nStrips values from the end of an iterable. Stripped items will\n\nChoices:\n0: def unique_in_window(iterable, n, key=None):     if n <= 0:         raise ValueError('n must be greater than 0')      window = deque(maxlen=n)     counts = Counter()     use_key = key is not None      for item in iterable:         if len(window) == n:             to_discard = window[0]             if counts[to_discard] == 1:                 del counts[to_discard]             else:                 counts[to_discard] -= 1          k = key(item) if use_key else item         if k not in counts:             yield item         counts[k] += 1         window.append(k)\n1: def _gettext(message):     return get_translation().gettext(message)\n2: def rstrip(iterable, strip_value=None):     return list(rstrip_iter(iterable, strip_value))", "output": "2"}
{"task": "search", "input": "search code:\nThree way partition the data into smaller, equal and greater lists,\n\nChoices:\n0: def _construct_points(     list_of_tuples: list[Point] | list[list[float]] | Iterable[list[float]], ) -> list[Point]:      points: list[Point] = []     if list_of_tuples:         for p in list_of_tuples:             if isinstance(p, Point):                 points.append(p)             else:                 try:                     points.append(Point(p[0], p[1]))                 except (IndexError, TypeError):                     print(                         f\"Ignoring deformed point {p}. All points\"                         \" must have at least 2 coordinates.\"                     )     return points\n1: def is_pangram(     input_str: str = \"The quick brown fox jumps over the lazy dog\", ) -> bool:     # Declare frequency as a set to have unique occurrences of letters     frequency = set()      # Replace all the whitespace in our sentence     input_str = input_str.replace(\" \", \"\")     for alpha in input_str:         if \"a\" <= alpha.lower() <= \"z\":             frequency.add(alpha.lower())     return len(frequency) == 26\n2: def _partition(data: list, pivot) -> tuple:     less, equal, greater = [], [], []     for element in data:         if element < pivot:             less.append(element)         elif element > pivot:             greater.append(element)         else:             equal.append(element)     return less, equal, greater", "output": "2"}
{"task": "detection", "input": "classify code:\ndef bisect_right(\n    sorted_collection: List[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef solution(max_base: int = 10, max_power: int = 22) -> int:\n    bases = range(1, max_base)\n    powers = range(1, max_power)\n    return sum(\n        1 for power in powers for base in bases if len(str(base**power)) == power\n    )", "output": "Returns the count of all n-digit numbers which are nth power"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    triangle_path = os.path.join(script_dir, \"triangle.txt\")\n\n    with open(triangle_path) as in_file:\n        triangle = [[int(i) for i in line.split()] for line in in_file]\n\n    while len(triangle) != 1:\n        last_row = triangle.pop()\n        curr_row = triangle[-1]\n        for j in range(len(last_row) - 1):\n            curr_row[j] += max(last_row[j], last_row[j + 1])\n    return triangle[0][0]", "output": "Finds the maximum total in a triangle as described by the problem statement"}
{"task": "search", "input": "search code:\nGiven a list of possible decoded messages, narrow down the possibilities\n\nChoices:\n0: def polynomial_derivative(coefficients):     n = len(coefficients)     powers = reversed(range(1, n))     return list(map(mul, coefficients, powers))\n1: def filter_common_word(possibles: list[str], common_word: str) -> list[str]:     return [possible for possible in possibles if common_word in possible.lower()]\n2: def first_molar_mass(     molar_mass: float, effusion_rate_1: float, effusion_rate_2: float ) -> float | ValueError:     return (         round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)         if validate(molar_mass, effusion_rate_1, effusion_rate_2)         else ValueError(             \"Input Error: Molar mass and effusion rate values must greater than 0.\"         )     )", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef sigmoid_function(value: float, deriv: bool = False) -> float:\n    if deriv:\n        return value * (1 - value)\n    return 1 / (1 + math.exp(-value))", "output": "Return the sigmoid function of a float."}
{"task": "search", "input": "search code:\nCalculate the Lorentz factor y = 1 / (1 - v/c) for a given velocity\n\nChoices:\n0: def gamma(velocity: float) -> float:     return 1 / sqrt(1 - beta(velocity) ** 2)\n1: def heap_sort(unsorted: list[int]) -> list[int]:     n = len(unsorted)     for i in range(n // 2 - 1, -1, -1):         heapify(unsorted, i, n)     for i in range(n - 1, 0, -1):         unsorted[0], unsorted[i] = unsorted[i], unsorted[0]         heapify(unsorted, 0, i)     return unsorted\n2: def newtons_second_law_of_motion(mass: float, acceleration: float) -> float:     force = 0.0     try:         force = mass * acceleration     except Exception:         return -0.0     return force", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef get_cost_derivative(index):\n    cost_derivative_value = summation_of_cost_derivative(index, m) / m\n    return cost_derivative_value", "output": ":param index: index of the parameter vector wrt to derivative is to be calculated"}
{"task": "search", "input": "search code:\nInput Parameters\n\nChoices:\n0: def quick_sort(collection: list) -> list:     # Base case: if the collection has 0 or 1 elements, it is already sorted     if len(collection) < 2:         return collection      # Randomly select a pivot index and remove the pivot element from the collection     pivot_index = randrange(len(collection))     pivot = collection.pop(pivot_index)      # Partition the remaining elements into two groups: lesser or equal, and greater     lesser = [item for item in collection if item <= pivot]     greater = [item for item in collection if item > pivot]      # Recursively sort the lesser and greater groups, and combine with the pivot     return [*quick_sort(lesser), pivot, *quick_sort(greater)]\n1: def ind_reactance(     inductance: float, frequency: float, reactance: float ) -> dict[str, float]:      if (inductance, frequency, reactance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if inductance < 0:         raise ValueError(\"Inductance cannot be negative\")     if frequency < 0:         raise ValueError(\"Frequency cannot be negative\")     if reactance < 0:         raise ValueError(\"Inductive reactance cannot be negative\")     if inductance == 0:         return {\"inductance\": reactance / (2 * pi * frequency)}     elif frequency == 0:         return {\"frequency\": reactance / (2 * pi * inductance)}     elif reactance == 0:         return {\"reactance\": 2 * pi * frequency * inductance}     else:         raise ValueError(\"Exactly one argument must be 0\")\n2: def gravitational_law(     force: float, mass_1: float, mass_2: float, distance: float ) -> dict[str, float]:      product_of_mass = mass_1 * mass_2      if (force, mass_1, mass_2, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if force < 0:         raise ValueError(\"Gravitational force can not be negative\")     if distance < 0:         raise ValueError(\"Distance can not be negative\")     if mass_1 < 0 or mass_2 < 0:         raise ValueError(\"Mass can not be negative\")     if force == 0:         force = GRAVITATIONAL_CONSTANT * product_of_mass / (distance**2)         return {\"force\": force}     elif mass_1 == 0:         mass_1 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_2)         return {\"mass_1\": mass_1}     elif mass_2 == 0:         mass_2 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_1)         return {\"mass_2\": mass_2}     elif distance == 0:         distance = (GRAVITATIONAL_CONSTANT * product_of_mass / (force)) ** 0.5         return {\"distance\": distance}     raise ValueError(\"One and only one argument must be 0\")", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef get_anime_episode(episode_endpoint: str) -> list:\n\n    episode_page_url = f\"{BASE_URL}{episode_endpoint}\"\n\n    response = httpx.get(\n        url=episode_page_url, headers={\"User-Agent\": UserAgent().chrome}, timeout=10\n    )\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    url = soup.find(\"iframe\", {\"id\": \"playerframe\"})\n    if url is None or isinstance(url, NavigableString):\n        msg = f\"Could not find url and download url from {episode_endpoint}\"\n        raise RuntimeError(msg)\n\n    episode_url = url[\"src\"]\n    if not isinstance(episode_url, str):\n        msg = f\"Could not find url and download url from {episode_endpoint}\"\n        raise RuntimeError(msg)\n    download_url = episode_url.replace(\"/embed/\", \"/playlist/\") + \".m3u8\"\n\n    return [f\"{BASE_URL}{episode_url}\", f\"{BASE_URL}{download_url}\"]", "output": "[summary]"}
{"task": "search", "input": "search code:\nReturn the squared second norm of vector\n\nChoices:\n0: def norm_squared(vector: ndarray) -> float:     return np.dot(vector, vector)\n1: def f(x: float) -> float:     return math.pow(x, 3) - (2 * x) - 5\n2: def partition(arr: list[int], low: int, high: int) -> int:     pivot = arr[high]     i = low - 1     for j in range(low, high):         if arr[j] >= pivot:             i += 1             arr[i], arr[j] = arr[j], arr[i]     arr[i + 1], arr[high] = arr[high], arr[i + 1]     return i + 1", "output": "0"}
{"task": "detection", "input": "classify code:\ndef construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway", "output": "CORRECT"}
{"task": "search", "input": "search code:\nCreates a butterfly pattern of size n and returns it as a string.\n\nChoices:\n0: def subslices(iterable):     seq = list(iterable)     slices = starmap(slice, combinations(range(len(seq) + 1), 2))     return map(getitem, repeat(seq), slices)\n1: def convert_small_number(num: int) -> str:     if num < 0:         raise ValueError(\"This function only accepts non-negative integers\")     if num >= 100:         raise ValueError(\"This function only converts numbers less than 100\")     tens, ones = divmod(num, 10)     if tens == 0:         return NumberWords.ONES.value[ones] or \"zero\"     if tens == 1:         return NumberWords.TEENS.value[ones]     return (         NumberWords.TENS.value[tens]         + (\"-\" if NumberWords.ONES.value[ones] else \"\")         + NumberWords.ONES.value[ones]     )\n2: def butterfly_pattern(n: int) -> str:     result = []      # Upper part     for i in range(1, n):         left_stars = \"*\" * i         spaces = \" \" * (2 * (n - i) - 1)         right_stars = \"*\" * i         result.append(left_stars + spaces + right_stars)      # Middle part     result.append(\"*\" * (2 * n - 1))      # Lower part     for i in range(n - 1, 0, -1):         left_stars = \"*\" * i         spaces = \" \" * (2 * (n - i) - 1)         right_stars = \"*\" * i         result.append(left_stars + spaces + right_stars)      return \"\\n\".join(result)", "output": "2"}
{"task": "search", "input": "search code:\nSolve the linear system of equations Ax = b (A = \"matrix\", b = \"vector\")\n\nChoices:\n0: def concave_triangle_area(circles_number: int) -> float:      intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (         2 * (circles_number**2 + 1)     )     intersection_x = circles_number * intersection_y      triangle_area = intersection_x * intersection_y / 2     concave_region_area = circle_bottom_arc_integral(         1 / 2     ) - circle_bottom_arc_integral(intersection_x)      return triangle_area + concave_region_area\n1: def effusion_ratio(molar_mass_1: float, molar_mass_2: float) -> float | ValueError:     return (         round(sqrt(molar_mass_2 / molar_mass_1), 6)         if validate(molar_mass_1, molar_mass_2)         else ValueError(\"Input Error: Molar mass values must greater than 0.\")     )\n2: def solve(matrix: Matrix, vector: Matrix) -> Matrix:     size: int = len(matrix)     augmented: Matrix = [[0 for _ in range(size + 1)] for _ in range(size)]     row: int     row2: int     col: int     col2: int     pivot_row: int     ratio: float      for row in range(size):         for col in range(size):             augmented[row][col] = matrix[row][col]          augmented[row][size] = vector[row][0]      row = 0     col = 0     while row < size and col < size:         # pivoting         pivot_row = max((abs(augmented[row2][col]), row2) for row2 in range(col, size))[             1         ]         if augmented[pivot_row][col] == 0:             col += 1             continue         else:             augmented[row], augmented[pivot_row] = augmented[pivot_row], augmented[row]          for row2 in range(row + 1, size):             ratio = augmented[row2][col] / augmented[row][col]             augmented[row2][col] = 0             for col2 in range(col + 1, size + 1):                 augmented[row2][col2] -= augmented[row][col2] * ratio          row += 1         col += 1      # back substitution     for col in range(1, size):         for row in range(col):             ratio = augmented[row][col] / augmented[col][col]             for col2 in range(col, size + 1):                 augmented[row][col2] -= augmented[col][col2] * ratio      # round to get rid of numbers like 2.000000000000004     return [         [round(augmented[row][size] / augmented[row][row], 10)] for row in range(size)     ]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef rlocate(iterable, pred=bool, window_size=None):\n    if window_size is None:\n        try:\n            len_iter = len(iterable)\n            return (len_iter - i - 1 for i in locate(reversed(iterable), pred))\n        except TypeError:\n            pass\n\n    return reversed(list(locate(iterable, pred, window_size)))", "output": "Yield the index of each item in *iterable* for which *pred* returns"}
{"task": "search", "input": "search code:\nCalculates Spearman's rank correlation coefficient.\n\nChoices:\n0: def calculate_spearman_rank_correlation(     variable_1: Sequence[float], variable_2: Sequence[float] ) -> float:     n = len(variable_1)     rank_var1 = assign_ranks(variable_1)     rank_var2 = assign_ranks(variable_2)      # Calculate differences of ranks     d = [rx - ry for rx, ry in zip(rank_var1, rank_var2)]      # Calculate the sum of squared differences     d_squared = sum(di**2 for di in d)      # Calculate the Spearman's rank correlation coefficient     rho = 1 - (6 * d_squared) / (n * (n**2 - 1))      return rho\n1: def get_child_left_position(position: int) -> int:     return (2 * position) + 1\n2: def pdb_on_exception(limit=100):     import pdb     import sys     import traceback      def pdb_excepthook(exc_type, exc_val, exc_tb):         traceback.print_tb(exc_tb, limit=limit)         pdb.post_mortem(exc_tb)      sys.excepthook = pdb_excepthook     return", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef pay(hours_worked: float, pay_rate: float, hours: float = 40) -> float:\n    # Check that all input parameters are float or integer\n    assert isinstance(hours_worked, (float, int)), (\n        \"Parameter 'hours_worked' must be of type 'int' or 'float'\"\n    )\n    assert isinstance(pay_rate, (float, int)), (\n        \"Parameter 'pay_rate' must be of type 'int' or 'float'\"\n    )\n    assert isinstance(hours, (float, int)), (\n        \"Parameter 'hours' must be of type 'int' or 'float'\"\n    )\n\n    normal_pay = hours_worked * pay_rate\n    over_time = max(0, hours_worked - hours)\n    over_time_pay = over_time * pay_rate / 2\n    return normal_pay + over_time_pay", "output": "hours_worked = The total hours worked"}
{"task": "search", "input": "search code:\nReturn the number of different square laminae that can be formed using up to\n\nChoices:\n0: def solution(filename: str = \"matrix.txt\") -> int:     with open(os.path.join(os.path.dirname(__file__), filename)) as in_file:         data = in_file.read()      grid = [[int(cell) for cell in row.split(\",\")] for row in data.strip().splitlines()]     dp = [[0 for cell in row] for row in grid]     n = len(grid[0])      dp = [[0 for i in range(n)] for j in range(n)]     dp[0][0] = grid[0][0]     for i in range(1, n):         dp[0][i] = grid[0][i] + dp[0][i - 1]     for i in range(1, n):         dp[i][0] = grid[i][0] + dp[i - 1][0]      for i in range(1, n):         for j in range(1, n):             dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])      return dp[-1][-1]\n1: def display_billionaires(forbes_billionaires: list[dict[str, int | str]]) -> None:      table = rich_table.Table(         title=f\"Forbes Top {LIMIT} Real-Time Billionaires at {TODAY:%Y-%m-%d %H:%M}\",         style=\"green\",         highlight=True,         box=box.SQUARE,     )     for key in forbes_billionaires[0]:         table.add_column(key)      for billionaire in forbes_billionaires:         table.add_row(*billionaire.values())      rich_console.Console().print(table)\n2: def solution(limit: int = 1000000) -> int:     answer = 0      for outer_width in range(3, (limit // 4) + 2):         if outer_width**2 > limit:             hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)         else:             hole_width_lower_bound = 1         if (outer_width - hole_width_lower_bound) % 2:             hole_width_lower_bound += 1          answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1      return answer", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef backtrack(\n    candidates: list, path: list, answer: list, target: int, previous_index: int\n) -> None:\n    if target == 0:\n        answer.append(path.copy())\n    else:\n        for index in range(previous_index, len(candidates)):\n            if target >= candidates[index]:\n                path.append(candidates[index])\n                backtrack(candidates, path, answer, target - candidates[index], index)\n                path.pop(len(path) - 1)", "output": "A recursive function that searches for possible combinations. Backtracks in case"}
{"task": "repair", "input": "fix bug:\ndef decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)", "output": "def decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)"}
{"task": "search", "input": "search code:\nCalculate the binomial coefficient C(total_elements, elements_to_choose)\n\nChoices:\n0: def solution(limit: int = 10000) -> int:     lychrel_nums = []     for num in range(1, limit):         iterations = 0         a = num         while iterations < 50:             num = sum_reverse(num)             iterations += 1             if is_palindrome(num):                 break         else:             lychrel_nums.append(a)     return len(lychrel_nums)\n1: def merge_two_binary_trees(tree1: Node | None, tree2: Node | None) -> Node | None:     if tree1 is None:         return tree2     if tree2 is None:         return tree1      tree1.value = tree1.value + tree2.value     tree1.left = merge_two_binary_trees(tree1.left, tree2.left)     tree1.right = merge_two_binary_trees(tree1.right, tree2.right)     return tree1\n2: def _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:     if elements_to_choose in {0, total_elements}:         return 1      elements_to_choose = min(elements_to_choose, total_elements - elements_to_choose)      coefficient = 1     for i in range(elements_to_choose):         coefficient *= total_elements - i         coefficient //= i + 1      return coefficient", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef mbd(predict, actual):\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    numerator = np.sum(difference) / len(predict)\n    denumerator = np.sum(actual) / len(predict)\n    # print(numerator, denumerator)\n    score = float(numerator) / denumerator * 100\n\n    return score", "output": "This value is Negative, if the model underpredicts,"}
{"task": "search", "input": "search code:\nBlack&white color-coding that ignores the relative distance. The Mandelbrot\n\nChoices:\n0: def not_32(i: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")      i_str = format(i, \"032b\")     new_str = \"\"     for c in i_str:         new_str += \"1\" if c == \"0\" else \"0\"     return int(new_str, 2)\n1: def is_isogram(string: str) -> bool:     if not all(x.isalpha() for x in string):         raise ValueError(\"String must only contain alphabetic characters.\")      letters = sorted(string.lower())     return len(letters) == len(set(letters))\n2: def get_black_and_white_rgb(distance: float) -> tuple:     if distance == 1:         return (0, 0, 0)     else:         return (255, 255, 255)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef make_set(x: Node) -> None:\n    # rank is the distance from x to its' parent\n    # root's rank is 0\n    x.rank = 0\n    x.parent = x", "output": "Make x as a set."}
{"task": "search", "input": "search code:\nThis function runs the rules of game through all points, and changes their\n\nChoices:\n0: def ordinal(value, gender=\"male\"):     try:         value = int(value)     except (TypeError, ValueError):         return value     if gender == \"male\":         t = (             P_(\"0 (male)\", \"th\"),             P_(\"1 (male)\", \"st\"),             P_(\"2 (male)\", \"nd\"),             P_(\"3 (male)\", \"rd\"),             P_(\"4 (male)\", \"th\"),             P_(\"5 (male)\", \"th\"),             P_(\"6 (male)\", \"th\"),             P_(\"7 (male)\", \"th\"),             P_(\"8 (male)\", \"th\"),             P_(\"9 (male)\", \"th\"),         )     else:         t = (             P_(\"0 (female)\", \"th\"),             P_(\"1 (female)\", \"st\"),             P_(\"2 (female)\", \"nd\"),             P_(\"3 (female)\", \"rd\"),             P_(\"4 (female)\", \"th\"),             P_(\"5 (female)\", \"th\"),             P_(\"6 (female)\", \"th\"),             P_(\"7 (female)\", \"th\"),             P_(\"8 (female)\", \"th\"),             P_(\"9 (female)\", \"th\"),         )     if value % 100 in (11, 12, 13):  # special case         return f\"{value}{t[0]}\"     return f\"{value}{t[value % 10]}\"\n1: def min_path_sum(grid: list) -> int:      if not grid or not grid[0]:         raise TypeError(\"The grid does not contain the appropriate information\")      for cell_n in range(1, len(grid[0])):         grid[0][cell_n] += grid[0][cell_n - 1]     row_above = grid[0]      for row_n in range(1, len(grid)):         current_row = grid[row_n]         grid[row_n] = fill_row(current_row, row_above)         row_above = grid[row_n]      return grid[-1][-1]\n2: def run(canvas: list[list[bool]]) -> list[list[bool]]:     current_canvas = np.array(canvas)     next_gen_canvas = np.array(create_canvas(current_canvas.shape[0]))     for r, row in enumerate(current_canvas):         for c, pt in enumerate(row):             next_gen_canvas[r][c] = __judge_point(                 pt, current_canvas[r - 1 : r + 2, c - 1 : c + 2]             )      return next_gen_canvas.tolist()", "output": "2"}
{"task": "search", "input": "search code:\nFinds k'th lexicographic permutation (in increasing order) of\n\nChoices:\n0: def kth_permutation(k, n):     # Factorails from 1! to (n-1)!     factorials = [1]     for i in range(2, n):         factorials.append(factorials[-1] * i)     assert 0 <= k < factorials[-1] * n, \"k out of bounds\"      permutation = []     elements = list(range(n))      # Find permutation     while factorials:         factorial = factorials.pop()         number, k = divmod(k, factorial)         permutation.append(elements[number])         elements.remove(elements[number])     permutation.append(elements[0])      return permutation\n1: def show_frequency_response(filter_type: FilterType, samplerate: int) -> None:      size = 512     inputs = [1] + [0] * (size - 1)     outputs = [filter_type.process(item) for item in inputs]      filler = [0] * (samplerate - size)  # zero-padding     outputs += filler     fft_out = np.abs(np.fft.fft(outputs))     fft_db = 20 * np.log10(fft_out)      # Frequencies on log scale from 24 to nyquist frequency     plt.xlim(24, samplerate / 2 - 1)     plt.xlabel(\"Frequency (Hz)\")     plt.xscale(\"log\")      # Display within reasonable bounds     bounds = get_bounds(fft_db, samplerate)     plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))     plt.ylabel(\"Gain (dB)\")      plt.plot(fft_db)     plt.show()\n2: def solution(n: int = 10000) -> int:     count_odd_periods = 0     for i in range(2, n + 1):         sr = sqrt(i)         if sr - floor(sr) != 0 and continuous_fraction_period(i) % 2 == 1:             count_odd_periods += 1     return count_odd_periods", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result", "output": "def generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result"}
{"task": "summary", "input": "summarize code:\ndef capitalize(sentence: str) -> str:\n    if not sentence:\n        return \"\"\n\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    return sentence[0].upper() + sentence[1:]", "output": "Capitalizes the first letter of a sentence or word."}
{"task": "search", "input": "search code:\nRemoves size prefix, that compressed file should have\n\nChoices:\n0: def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:     arr.sort()     n = len(arr)     for i in range(n - 1):         left, right = i + 1, n - 1         while left < right:             if arr[i] + arr[left] + arr[right] == target:                 return (arr[i], arr[left], arr[right])             elif arr[i] + arr[left] + arr[right] < target:                 left += 1             elif arr[i] + arr[left] + arr[right] > target:                 right -= 1     return (0, 0, 0)\n1: def remove_prefix(data_bits: str) -> str:     counter = 0     for letter in data_bits:         if letter == \"1\":             break         counter += 1      data_bits = data_bits[counter:]     data_bits = data_bits[counter + 1 :]     return data_bits\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "1"}
{"task": "detection", "input": "classify code:\ndef xor(a, b):\n    \"\"\"\n    >>> xor(\"01010101\", \"00001111\")\n    '01011010'\n    \"\"\"\n    res = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            res += \"0\"\n        else:\n            res += \"1\"\n    return res", "output": "CORRECT"}
{"task": "search", "input": "search code:\nReturns cluster\n\nChoices:\n0: def _count_cross_inversions(p, q):      r = []     i = j = num_inversion = 0     while i < len(p) and j < len(q):         if p[i] > q[j]:             # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)             # These are all inversions. The claim emerges from the             # property that P is sorted.             num_inversion += len(p) - i             r.append(q[j])             j += 1         else:             r.append(p[i])             i += 1      if i < len(p):         r.extend(p[i:])     else:         r.extend(q[j:])      return r, num_inversion\n1: def get_cluster(nodes):     cluster = {}     for key, value in nodes.items():         cluster.setdefault(key.count(\"1\"), {})[key] = value     return cluster\n2: def intword(value, format=\"%.1f\"):     try:         value = int(value)     except (TypeError, ValueError):         return value      if value < powers[0]:         return str(value)     for ordinal, power in enumerate(powers[1:], 1):         if value < power:             chopped = value / float(powers[ordinal - 1])             if float(format % chopped) == float(10**3):                 chopped = value / float(powers[ordinal])                 singular, plural = human_powers[ordinal]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped             else:                 singular, plural = human_powers[ordinal - 1]                 return (                     \" \".join([format, _ngettext(singular, plural, math.ceil(chopped))])                 ) % chopped     return str(value)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef counting_sort(collection):\n    \"\"\"Pure implementation of counting sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> counting_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> counting_sort([])\n    []\n    >>> counting_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered", "output": "def counting_sort(collection):\n    \"\"\"Pure implementation of counting sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> counting_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> counting_sort([])\n    []\n    >>> counting_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered"}
{"task": "search", "input": "search code:\nBenchmark our functions next to each other\n\nChoices:\n0: def benchmark() -> None:     from timeit import timeit      print(\"Running benchmarks\")     setup = (         \"from __main__ import count_negatives_binary_search, \"         \"count_negatives_brute_force, count_negatives_brute_force_with_break, grid\"     )     for func in (         \"count_negatives_binary_search\",  # took 0.7727 seconds         \"count_negatives_brute_force_with_break\",  # took 4.6505 seconds         \"count_negatives_brute_force\",  # took 12.8160 seconds     ):         time = timeit(f\"{func}(grid=grid)\", setup=setup, number=500)         print(f\"{func}() took {time:0.4f} seconds\")\n1: def running_key_decrypt(key: str, ciphertext: str) -> str:     ciphertext = ciphertext.replace(\" \", \"\").upper()     key = key.replace(\" \", \"\").upper()     key_length = len(key)     plaintext = []     ord_a = ord(\"A\")      for i, char in enumerate(ciphertext):         c = ord(char) - ord_a         k = ord(key[i % key_length]) - ord_a         p = (c - k) % 26         plaintext.append(chr(p + ord_a))      return \"\".join(plaintext)\n2: def reverse_words(input_str: str) -> str:     return \" \".join(input_str.split()[::-1])", "output": "0"}
{"task": "search", "input": "search code:\nWrapper function to call subroutine called util_color\n\nChoices:\n0: def identity(n: int) -> list[list[int]]:     n = int(n)     return [[int(row == column) for column in range(n)] for row in range(n)]\n1: def color(graph: list[list[int]], max_colors: int) -> list[int]:     colored_vertices = [-1] * len(graph)      if util_color(graph, max_colors, colored_vertices, 0):         return colored_vertices      return []\n2: def is_ip_v4_address_valid(ip: str) -> bool:     octets = ip.split(\".\")     if len(octets) != 4:         return False      for octet in octets:         if not octet.isdigit():             return False          number = int(octet)         if len(str(number)) != len(octet):             return False          if not 0 <= number <= 255:             return False      return True", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef is_combination_valid(combination):\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )", "output": "Checks if a combination (a tuple of 9 digits)"}
{"task": "summary", "input": "summarize code:\ndef astable_frequency(\n    resistance_1: float, resistance_2: float, capacitance: float\n) -> float:\n\n    if resistance_1 <= 0 or resistance_2 <= 0 or capacitance <= 0:\n        raise ValueError(\"All values must be positive\")\n    return (1.44 / ((resistance_1 + 2 * resistance_2) * capacitance)) * 10**6", "output": "Usage examples:"}
{"task": "summary", "input": "summarize code:\ndef extended_euclid(a: int, b: int) -> tuple[int, int]:\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)", "output": "Extended Euclid"}
{"task": "search", "input": "search code:\nNon-decreasing indices, lazily consumed\n\nChoices:\n0: def world_covid19_stats(     url: str = \"https://www.worldometers.info/coronavirus/\", ) -> dict:     soup = BeautifulSoup(         httpx.get(url, timeout=10, follow_redirects=True).text, \"html.parser\"     )     keys = soup.find_all(\"h1\")     values = soup.find_all(\"div\", {\"class\": \"maincounter-number\"})     keys += soup.find_all(\"span\", {\"class\": \"panel-title\"})     values += soup.find_all(\"div\", {\"class\": \"number-table-main\"})     return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}\n1: def _running_median_minheap_only(iterator):  # pragma: no cover     \"Backport of non-windowed running_median() for Python 3.13 and prior.\"      read = iterator.__next__     lo = []  # max-heap (actually a minheap with negated values)     hi = []  # min-heap (same size as or one smaller than lo)      with suppress(StopIteration):         while True:             heappush(lo, -heappushpop(hi, read()))             yield -lo[0]              heappush(hi, -heappushpop(lo, -read()))             yield (hi[0] - lo[0]) / 2\n2: def _extract_monotonic(iterator, indices):     'Non-decreasing indices, lazily consumed'     num_read = 0     for index in indices:         advance = index - num_read         try:             value = next(islice(iterator, advance, None))         except ValueError:             if advance != -1 or index < 0:                 raise ValueError(f'Invalid index: {index}') from None         except StopIteration:             raise IndexError(index) from None         else:             num_read += advance + 1         yield value", "output": "2"}
{"task": "search", "input": "search code:\nchecking whether the input series is arithmetic series or not\n\nChoices:\n0: def is_arithmetic_series(series: list) -> bool:     if not isinstance(series, list):         raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")     if len(series) == 0:         raise ValueError(\"Input list must be a non empty list\")     if len(series) == 1:         return True     common_diff = series[1] - series[0]     for index in range(len(series) - 1):         if series[index + 1] - series[index] != common_diff:             return False     return True\n1: def unit_len(sized_iterable, unit_noun='item'):  # TODO: len_units()/unitize()?     count = len(sized_iterable)     units = cardinalize(unit_noun, count)     if count:         return f'{count} {units}'     return f'No {units}'\n2: def sigmoid_linear_unit(vector: np.ndarray) -> np.ndarray:     return vector * sigmoid(vector)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef gnome_sort(lst: list) -> list:\n    if len(lst) <= 1:\n        return lst\n\n    i = 1\n\n    while i < len(lst):\n        if lst[i - 1] <= lst[i]:\n            i += 1\n        else:\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1\n\n    return lst", "output": "Pure implementation of the gnome sort algorithm in Python"}
{"task": "search", "input": "search code:\nMinimum steps to 1 implemented using tabulation.\n\nChoices:\n0: def interpolate(y_list: list[int]) -> Callable[[int], int]:      size: int = len(y_list)     matrix: Matrix = [[0 for _ in range(size)] for _ in range(size)]     vector: Matrix = [[0] for _ in range(size)]     coeffs: Matrix     x_val: int     y_val: int     col: int      for x_val, y_val in enumerate(y_list):         for col in range(size):             matrix[x_val][col] = (x_val + 1) ** (size - col - 1)         vector[x_val][0] = y_val      coeffs = solve(matrix, vector)      def interpolated_func(var: int) -> int:         return sum(             round(coeffs[x_val][0]) * (var ** (size - x_val - 1))             for x_val in range(size)         )      return interpolated_func\n1: def find_max_area(mat: list[list[int]]) -> int:     seen: set = set()      max_area = 0     for row, line in enumerate(mat):         for col, item in enumerate(line):             if item == 1 and (row, col) not in seen:                 # Maximizing the area                 max_area = max(max_area, depth_first_search(row, col, seen, mat))     return max_area\n2: def min_steps_to_one(number: int) -> int:      if number <= 0:         msg = f\"n must be greater than 0. Got n = {number}\"         raise ValueError(msg)      table = [number + 1] * (number + 1)      # starting position     table[1] = 0     for i in range(1, number):         table[i + 1] = min(table[i + 1], table[i] + 1)         # check if out of bounds         if i * 2 <= number:             table[i * 2] = min(table[i * 2], table[i] + 1)         # check if out of bounds         if i * 3 <= number:             table[i * 3] = min(table[i * 3], table[i] + 1)     return table[number]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef and_gate(input_1: int, input_2: int) -> int:\n    return int(input_1 and input_2)", "output": "Calculate AND of the input values"}
{"task": "detection", "input": "classify code:\ndef has_same_digits(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if num1 and num2 have the same frequency of every digit, False\n    otherwise.\n\n    >>> has_same_digits(123456789, 987654321)\n    True\n\n    >>> has_same_digits(123, 23)\n    False\n\n    >>> has_same_digits(1234566, 123456)\n    False\n    \"\"\"\n    return sorted(str(num1)) == sorted(str(num2))", "output": "CORRECT"}
{"task": "search", "input": "search code:\nFinds the sum of all products whose multiplicand/multiplier/product identity\n\nChoices:\n0: def password_generator(length: int = 8) -> str:     chars = ascii_letters + digits + punctuation     return \"\".join(secrets.choice(chars) for _ in range(length))\n1: def ordinal(value, gender=\"male\"):     try:         value = int(value)     except (TypeError, ValueError):         return value     if gender == \"male\":         t = (             P_(\"0 (male)\", \"th\"),             P_(\"1 (male)\", \"st\"),             P_(\"2 (male)\", \"nd\"),             P_(\"3 (male)\", \"rd\"),             P_(\"4 (male)\", \"th\"),             P_(\"5 (male)\", \"th\"),             P_(\"6 (male)\", \"th\"),             P_(\"7 (male)\", \"th\"),             P_(\"8 (male)\", \"th\"),             P_(\"9 (male)\", \"th\"),         )     else:         t = (             P_(\"0 (female)\", \"th\"),             P_(\"1 (female)\", \"st\"),             P_(\"2 (female)\", \"nd\"),             P_(\"3 (female)\", \"rd\"),             P_(\"4 (female)\", \"th\"),             P_(\"5 (female)\", \"th\"),             P_(\"6 (female)\", \"th\"),             P_(\"7 (female)\", \"th\"),             P_(\"8 (female)\", \"th\"),             P_(\"9 (female)\", \"th\"),         )     if value % 100 in (11, 12, 13):  # special case         return f\"{value}{t[0]}\"     return f\"{value}{t[value % 10]}\"\n2: def solution():      return sum(         {             int(\"\".join(pandigital[5:9]))             for pandigital in itertools.permutations(\"123456789\")             if is_combination_valid(pandigital)         }     )", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef encode(word: str) -> str:\n    encoded = \"\"\n    for letter in word.lower():\n        if letter.isalpha() or letter == \" \":\n            encoded += encode_dict[letter]\n        else:\n            raise Exception(\"encode() accepts only letters of the alphabet and spaces\")\n    return encoded", "output": "Encodes to Baconian cipher"}
{"task": "repair", "input": "fix bug:\ndef palindromic_string(input_string: str) -> str:\n    \"\"\"\n    >>> palindromic_string('abbbaba')\n    'abbba'\n    >>> palindromic_string('ababa')\n    'ababa'\n\n    Manacher's algorithm which finds Longest palindromic Substring in linear time.\n\n    1. first this convert input_string(\"xyx\") into new_string(\"x|y|x\") where odd\n        positions are actual input characters.\n    2. for each character in new_string it find corresponding length and\n        store the length and left,right to store previously calculated info.\n        (please look the explanation for details)\n\n    3. return corresponding output_string by removing all \"|\"\n    \"\"\"\n    max_length = 0\n\n    # if input_string is \"aba\" than new_input_string become \"a|b|a\"\n    new_input_string = \"\"\n    output_string = \"\"\n\n    # append each character + \"|\" in new_string for range(0, length-1)\n    for i in input_string[: len(input_string) - 1]:\n        new_input_string += i + \"|\"\n    # append last character\n    new_input_string += input_string[-1]\n\n    # we will store the starting and ending of previous furthest ending palindromic\n    # substring\n    left, right = 0, 0\n\n    # length[i] shows the length of palindromic substring with center i\n    length = [1 for i in range(len(new_input_string))]\n\n    # for each character in new_string find corresponding palindromic string\n    start = 0\n    for j in range(len(new_input_string)):\n        k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)\n        while (\n            j - k >= 0\n            and j + k < len(new_input_string)\n            and new_input_string[k + j] == new_input_string[j - k]\n        ):\n            k += 1\n\n        length[j] = 2 * k - 1\n\n        # does this string is ending after the previously explored end (that is right) ?\n        # if yes the update the new right to the last index of this\n        if j + k - 1 > right:\n            left = j - k + 1\n            right = j + k - 1\n\n        # update max_length and start position\n        if max_length < length[j]:\n            max_length = length[j]\n            start = j\n\n    # create that string\n    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]\n    for i in s:\n        if i != \"|\":\n            output_string += i\n\n    return output_string", "output": "def palindromic_string(input_string: str) -> str:\n    \"\"\"\n    >>> palindromic_string('abbbaba')\n    'abbba'\n    >>> palindromic_string('ababa')\n    'ababa'\n\n    Manacher's algorithm which finds Longest palindromic Substring in linear time.\n\n    1. first this convert input_string(\"xyx\") into new_string(\"x|y|x\") where odd\n        positions are actual input characters.\n    2. for each character in new_string it find corresponding length and\n        store the length and left,right to store previously calculated info.\n        (please look the explanation for details)\n\n    3. return corresponding output_string by removing all \"|\"\n    \"\"\"\n    max_length = 0\n\n    # if input_string is \"aba\" than new_input_string become \"a|b|a\"\n    new_input_string = \"\"\n    output_string = \"\"\n\n    # append each character + \"|\" in new_string for range(0, length-1)\n    for i in input_string[: len(input_string) - 1]:\n        new_input_string += i + \"|\"\n    # append last character\n    new_input_string += input_string[-1]\n\n    # we will store the starting and ending of previous furthest ending palindromic\n    # substring\n    left, right = 0, 0\n\n    # length[i] shows the length of palindromic substring with center i\n    length = [1 for i in range(len(new_input_string))]\n\n    # for each character in new_string find corresponding palindromic string\n    start = 0\n    for j in range(len(new_input_string)):\n        k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)\n        while (\n            j - k >= 0\n            and j + k < len(new_input_string)\n            and new_input_string[k + j] == new_input_string[j - k]\n        ):\n            k += 1\n\n        length[j] = 2 * k - 1\n\n        # does this string is ending after the previously explored end (that is right) ?\n        # if yes the update the new right to the last index of this\n        if j + k - 1 > right:\n            left = j - k + 1\n            right = j + k - 1\n\n        # update max_length and start position\n        if max_length < length[j]:\n            max_length = length[j]\n            start = j\n\n    # create that string\n    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]\n    for i in s:\n        if i != \"|\":\n            output_string += i\n\n    return output_string"}
{"task": "search", "input": "search code:\nReturn Distinct edges from edge array of multiple graphs\n\nChoices:\n0: def build_kdtree(points: list[list[float]], depth: int = 0) -> KDNode | None:     if not points:         return None      k = len(points[0])  # Dimensionality of the points     axis = depth % k      # Sort point list and choose median as pivot element     points.sort(key=lambda point: point[axis])     median_idx = len(points) // 2      # Create node and construct subtrees     left_points = points[:median_idx]     right_points = points[median_idx + 1 :]      return KDNode(         point=points[median_idx],         left=build_kdtree(left_points, depth + 1),         right=build_kdtree(right_points, depth + 1),     )\n1: def get_distinct_edge(edge_array):     distinct_edge = set()     for row in edge_array:         for item in row:             distinct_edge.add(item[0])     return list(distinct_edge)\n2: def area_rectangle(length: float, width: float) -> float:     if length < 0 or width < 0:         raise ValueError(\"area_rectangle() only accepts non-negative values\")     return length * width", "output": "1"}
{"task": "search", "input": "search code:\nFunction returns the temperature coeffecient value associated with the color.\n\nChoices:\n0: def is_pentagonal(n: int) -> bool:     root = (1 + 24 * n) ** 0.5     return ((1 + root) / 6) % 1 == 0\n1: def solution():     i = 1      while True:         if (             sorted(str(i))             == sorted(str(2 * i))             == sorted(str(3 * i))             == sorted(str(4 * i))             == sorted(str(5 * i))             == sorted(str(6 * i))         ):             return i          i += 1\n2: def get_temperature_coeffecient(color: str) -> int:     if color not in temperature_coeffecient_color_values:         msg = f\"{color} is not a valid color for temperature coeffecient band\"         raise ValueError(msg)     return temperature_coeffecient_color_values[color]", "output": "2"}
{"task": "search", "input": "search code:\nPython implementation of the jump search algorithm.\n\nChoices:\n0: def solution(n: int = 2) -> int:     result = 1.0     for fraction in fraction_list(n):         frac = Fraction(fraction)         result *= frac.denominator / frac.numerator     return int(result)\n1: def jump_search(arr: Sequence[T], item: T) -> int:      arr_size = len(arr)     block_size = int(math.sqrt(arr_size))      prev = 0     step = block_size     while arr[min(step, arr_size) - 1] < item:         prev = step         step += block_size         if prev >= arr_size:             return -1      while arr[prev] < item:         prev += 1         if prev == min(step, arr_size):             return -1     if arr[prev] == item:         return prev     return -1\n2: def norm_squared(vector: ndarray) -> float:     return np.dot(vector, vector)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)", "output": "\""}
{"task": "search", "input": "search code:\nReverse all words that are longer than the given length of characters in a sentence.\n\nChoices:\n0: def reverse_letters(sentence: str, length: int = 0) -> str:     return \" \".join(         \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()     )\n1: def generate_clause() -> Clause:     literals = []     no_of_literals = random.randint(1, 5)     base_var = \"A\"     i = 0     while i < no_of_literals:         var_no = random.randint(1, 5)         var_name = base_var + str(var_no)         var_complement = random.randint(0, 1)         if var_complement == 1:             var_name += \"'\"         if var_name in literals:             i -= 1         else:             literals.append(var_name)         i += 1     return Clause(literals)\n2: def get_distance(x: float, y: float, max_step: int) -> float:     a = x     b = y     for step in range(max_step):  # noqa: B007         a_new = a * a - b * b + x         b = 2 * a * b + y         a = a_new          # divergence happens for all complex number with an absolute value         # greater than 4         if a * a + b * b > 4:             break     return step / (max_step - 1)", "output": "0"}
{"task": "search", "input": "search code:\nReturns the count of all n-digit numbers which are nth power\n\nChoices:\n0: def find_freq_subgraph_given_support(s, cluster, graph):     k = int(s / 100 * (len(cluster) - 1))     for i in cluster[k]:         my_dfs(graph, tuple(cluster[k][i]), ([\"Header\"],))\n1: def solution(max_base: int = 10, max_power: int = 22) -> int:     bases = range(1, max_base)     powers = range(1, max_power)     return sum(         1 for power in powers for base in bases if len(str(base**power)) == power     )\n2: def get_format_args(fstr):     # TODO: memoize     formatter = Formatter()     fargs, fkwargs, _dedup = [], [], set()      def _add_arg(argname, type_char='s'):         if argname not in _dedup:             _dedup.add(argname)             argtype = _TYPE_MAP.get(type_char, str)  # TODO: unicode             try:                 fargs.append((int(argname), argtype))             except ValueError:                 fkwargs.append((argname, argtype))      for lit, fname, fspec, conv in formatter.parse(fstr):         if fname is not None:             type_char = fspec[-1:]             fname_list = re.split('[.[]', fname)             if len(fname_list) > 1:                 raise ValueError('encountered compound format arg: %r' % fname)             try:                 base_fname = fname_list[0]                 assert base_fname             except (IndexError, AssertionError):                 raise ValueError('encountered anonymous positional argument')             _add_arg(fname, type_char)             for sublit, subfname, _, _ in formatter.parse(fspec):                 # TODO: positional and anon args not allowed here.                 if subfname is not None:                     _add_arg(subfname)     return fargs, fkwargs", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef scalar_multiply(matrix: List[list], n: int) -> List[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]", "output": "def scalar_multiply(matrix: list[list], n: int) -> list[list]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]"}
{"task": "search", "input": "search code:\nReturns the sum of the numbers on the diagonals in a n by n spiral\n\nChoices:\n0: def solution(n: int = 1001) -> int:     total = 1      for i in range(1, ceil(n / 2.0)):         odd = 2 * i + 1         even = 2 * i         total = total + 4 * odd**2 - 6 * even      return total\n1: def process_game(size: int, matrix: list[str], moves: list[tuple[int, int]]) -> int:      game_matrix = [list(row) for row in matrix]     total_score = 0      for move in moves:         pos_x, pos_y = move         game_matrix, score = play(game_matrix, pos_x, pos_y, size)         total_score += score      return total_score\n2: def left_rotate_32(i: int, shift: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")     if shift < 0:         raise ValueError(\"Shift must be non-negative\")     return ((i << shift) ^ (i >> (32 - shift))) % 2**32", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef median(matrix: list[list[int]]) -> int:\n    # Flatten the matrix into a sorted 1D list\n    linear = sorted(num for row in matrix for num in row)\n\n    # Calculate the middle index\n    mid = (len(linear) - 1) // 2\n\n    # Return the median\n    return linear[mid]", "output": "Calculate the median of a sorted matrix."}
{"task": "summary", "input": "summarize code:\ndef unquote(string, encoding='utf-8', errors='replace'):\n    if '%' not in string:\n        string.split\n        return string\n    if encoding is None:\n        encoding = 'utf-8'\n    if errors is None:\n        errors = 'replace'\n    bits = _ASCII_RE.split(string)\n    res = [bits[0]]\n    append = res.append\n    for i in range(1, len(bits), 2):\n        append(unquote_to_bytes(bits[i]).decode(encoding, errors))\n        append(bits[i + 1])\n    return ''.join(res)", "output": "Percent-decode a string, by replacing %xx escapes with their"}
{"task": "detection", "input": "classify code:\ndef contains_an_even_digit(n: int) -> bool:\n    \"\"\"\n    Return True if n contains an even digit.\n    >>> contains_an_even_digit(0)\n    True\n    >>> contains_an_even_digit(975317933)\n    False\n    >>> contains_an_even_digit(-245679)\n    True\n    \"\"\"\n    return any(digit in \"02468\" for digit in str(n))", "output": "CORRECT"}
{"task": "detection", "input": "classify code:\ndef largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up approach.\n\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n    0\n\n    \"\"\"\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturns the Rayleigh quotient of a Hermitian matrix A and\n\nChoices:\n0: def diophantine_all_soln(a: int, b: int, c: int, n: int = 2) -> None:     (x0, y0) = diophantine(a, b, c)  # Initial value     d = greatest_common_divisor(a, b)     p = a // d     q = b // d      for i in range(n):         x = x0 + i * q         y = y0 - i * p         print(x, y)\n1: def rayleigh_quotient(a: np.ndarray, v: np.ndarray) -> Any:     v_star = v.conjugate().T     v_star_dot = v_star.dot(a)     assert isinstance(v_star_dot, np.ndarray)     return (v_star_dot.dot(v)) / (v_star.dot(v))\n2: def inverse_document_frequency(df: int, n: int, smoothing=False) -> float:     if smoothing:         if n == 0:             raise ValueError(\"log10(0) is undefined.\")         return round(1 + log10(n / (1 + df)), 3)      if df == 0:         raise ZeroDivisionError(\"df must be > 0\")     elif n == 0:         raise ValueError(\"log10(0) is undefined.\")     return round(log10(n / df), 3)", "output": "1"}
{"task": "search", "input": "search code:\nComputes a^b iteratively, where a is the base and b is the exponent\n\nChoices:\n0: def closest_pair_of_points_sqr(points_sorted_on_x, points_sorted_on_y, points_counts):      # base case     if points_counts <= 3:         return dis_between_closest_pair(points_sorted_on_x, points_counts)      # recursion     mid = points_counts // 2     closest_in_left = closest_pair_of_points_sqr(         points_sorted_on_x, points_sorted_on_y[:mid], mid     )     closest_in_right = closest_pair_of_points_sqr(         points_sorted_on_y, points_sorted_on_y[mid:], points_counts - mid     )     closest_pair_dis = min(closest_in_left, closest_in_right)       cross_strip = []     for point in points_sorted_on_x:         if abs(point[0] - points_sorted_on_x[mid][0]) < closest_pair_dis:             cross_strip.append(point)      closest_in_strip = dis_between_closest_in_strip(         cross_strip, len(cross_strip), closest_pair_dis     )     return min(closest_pair_dis, closest_in_strip)\n1: def binary_exp_iterative(base: float, exponent: int) -> float:     if exponent < 0:         raise ValueError(\"Exponent must be a non-negative integer\")      res: int | float = 1     while exponent > 0:         if exponent & 1:             res *= base          base *= base         exponent >>= 1      return res\n2: def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:     arr.sort()     n = len(arr)     for i in range(n - 1):         left, right = i + 1, n - 1         while left < right:             if arr[i] + arr[left] + arr[right] == target:                 return (arr[i], arr[left], arr[right])             elif arr[i] + arr[left] + arr[right] < target:                 left += 1             elif arr[i] + arr[left] + arr[right] > target:                 right -= 1     return (0, 0, 0)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef decimal_to_binary_recursive(number: str) -> str:\n    number = str(number).strip()\n    if not number:\n        raise ValueError(\"No input value was provided\")\n    negative = \"-\" if number.startswith(\"-\") else \"\"\n    number = number.lstrip(\"-\")\n    if not number.isnumeric():\n        raise ValueError(\"Input value is not an integer\")\n    return f\"{negative}0b{decimal_to_binary_recursive_helper(int(number))}\"", "output": "Take an integer value and raise ValueError for wrong inputs,"}
{"task": "detection", "input": "classify code:\ndef shell_sort(collection: list) -> list:\n    \"\"\"Implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([3, 2, 1])\n    [1, 2, 3]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([1])\n    [1]\n    \"\"\"\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)", "output": "CORRECT"}
{"task": "search", "input": "search code:\n:param number: nth number to calculate in the sequence\n\nChoices:\n0: def decrypt_message(     message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5 ) -> str:     message, alphabet, character_to_number, number_to_character = __prepare(         message, alphabet     )      decrypted_numeric = []     for i in range(0, len(message), period):         a, b, c = __decrypt_part(message[i : i + period], character_to_number)          for j in range(len(a)):             decrypted_numeric.append(a[j] + b[j] + c[j])      return \"\".join(number_to_character[each] for each in decrypted_numeric)\n1: def proth(number: int) -> int:      if not isinstance(number, int):         msg = f\"Input value of [number={number}] must be an integer\"         raise TypeError(msg)      if number < 1:         msg = f\"Input value of [number={number}] must be > 0\"         raise ValueError(msg)     elif number == 1:         return 3     elif number == 2:         return 5     else:         block_index = int(math.log(number // 3, 2)) + 2          proth_list = [3, 5]         proth_index = 2         increment = 3         for block in range(1, block_index):             for _ in range(increment):                 proth_list.append(2 ** (block + 1) + proth_list[proth_index - 1])                 proth_index += 1             increment *= 2      return proth_list[number - 1]\n2: def get_forbes_real_time_billionaires() -> list[dict[str, int | str]]:     response_json = httpx.get(API_URL, timeout=10).json()     return [         {             \"Name\": person[\"personName\"],             \"Source\": person[\"source\"],             \"Country\": person[\"countryOfCitizenship\"],             \"Gender\": person[\"gender\"],             \"Worth ($)\": f\"{person['finalWorth'] / 1000:.1f} Billion\",             \"Age\": str(years_old(person[\"birthDate\"] / 1000)),         }         for person in response_json[\"personList\"][\"personsLists\"]     ]", "output": "1"}
{"task": "search", "input": "search code:\nReturns the index of the first term in the Fibonacci sequence to contain\n\nChoices:\n0: def solution(n: int = 1000) -> int:     return fibonacci_digits_index(n)\n1: def generate_parentheses_iterative(length: int) -> list:     result = []     stack = []      # Each element in stack is a tuple (current_combination, open_count, close_count)     stack.append((\"\", 0, 0))      while stack:         current_combination, open_count, close_count = stack.pop()          if len(current_combination) == 2 * length:             result.append(current_combination)          if open_count < length:             stack.append((current_combination + \"(\", open_count + 1, close_count))          if close_count < open_count:             stack.append((current_combination + \")\", open_count, close_count + 1))      return result\n2: def quick_sort(collection: list) -> list:     # Base case: if the collection has 0 or 1 elements, it is already sorted     if len(collection) < 2:         return collection      # Randomly select a pivot index and remove the pivot element from the collection     pivot_index = randrange(len(collection))     pivot = collection.pop(pivot_index)      # Partition the remaining elements into two groups: lesser or equal, and greater     lesser = [item for item in collection if item <= pivot]     greater = [item for item in collection if item > pivot]      # Recursively sort the lesser and greater groups, and combine with the pivot     return [*quick_sort(lesser), pivot, *quick_sort(greater)]", "output": "0"}
{"task": "search", "input": "search code:\nReturn the floor of x as an Integral.\n\nChoices:\n0: def floor(x: float) -> int:     return int(x) if x - int(x) >= 0 else int(x) - 1\n1: def apnumber(value):     try:         value = int(value)     except (TypeError, ValueError):         return value     if not 0 <= value < 10:         return str(value)     return (         _(\"zero\"),         _(\"one\"),         _(\"two\"),         _(\"three\"),         _(\"four\"),         _(\"five\"),         _(\"six\"),         _(\"seven\"),         _(\"eight\"),         _(\"nine\"),     )[value]\n2: def euler_phi(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     s = n     for x in set(prime_factors(n)):         s *= (x - 1) / x     return int(s)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef lin_search(left: int, right: int, array: list[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):\n\n    def is_scalar(obj):\n        if scalar_types and isinstance(obj, scalar_types):\n            return True\n        try:\n            iter(obj)\n        except TypeError:\n            return True\n        else:\n            return False\n\n    size = len(objects)\n    if not size:\n        return\n\n    new_item = [None] * size\n    iterables, iterable_positions = [], []\n    for i, obj in enumerate(objects):\n        if is_scalar(obj):\n            new_item[i] = obj\n        else:\n            iterables.append(iter(obj))\n            iterable_positions.append(i)\n\n    if not iterables:\n        yield tuple(objects)\n        return\n\n    for item in zip(*iterables, strict=strict):\n        for i, new_item[i] in zip(iterable_positions, item):\n            pass\n        yield tuple(new_item)", "output": "A version of :func:`zip` that \"broadcasts\" any scalar"}
{"task": "search", "input": "search code:\nreturns a square zero-matrix of dimension NxN\n\nChoices:\n0: def plot_partition_boundary(     model, train_data, ax, resolution=100, colors=(\"b\", \"k\", \"r\") ):     train_data_x = train_data[:, 1]     train_data_y = train_data[:, 2]     train_data_tags = train_data[:, 0]     xrange = np.linspace(train_data_x.min(), train_data_x.max(), resolution)     yrange = np.linspace(train_data_y.min(), train_data_y.max(), resolution)     test_samples = np.array([(x, y) for x in xrange for y in yrange]).reshape(         resolution * resolution, 2     )      test_tags = model.predict(test_samples, classify=False)     grid = test_tags.reshape((len(xrange), len(yrange)))      # Plot contour map which represents the partition boundary     ax.contour(         xrange,         yrange,         np.asmatrix(grid).T,         levels=(-1, 0, 1),         linestyles=(\"--\", \"-\", \"--\"),         linewidths=(1, 1, 1),         colors=colors,     )     # Plot all train samples     ax.scatter(         train_data_x,         train_data_y,         c=train_data_tags,         cmap=plt.cm.Dark2,         lw=0,         alpha=0.5,     )      # Plot support vectors     support = model.support     ax.scatter(         train_data_x[support],         train_data_y[support],         c=train_data_tags[support],         cmap=plt.cm.Dark2,     )\n1: def square_zero_matrix(n: int) -> Matrix:     ans: list[list[float]] = [[0] * n for _ in range(n)]     return Matrix(ans, n, n)\n2: def solution(num: int = 100) -> int:     fact = 1     result = 0     for i in range(1, num + 1):         fact *= i      for j in str(fact):         result += int(j)      return result", "output": "1"}
{"task": "search", "input": "search code:\nThe ``copy_tree`` function is an exact copy of the built-in\n\nChoices:\n0: def copy_tree(src, dst, symlinks=False, ignore=None):     names = os.listdir(src)     if ignore is not None:         ignored_names = ignore(src, names)     else:         ignored_names = set()      mkdir_p(dst)     errors = []     for name in names:         if name in ignored_names:             continue         srcname = os.path.join(src, name)         dstname = os.path.join(dst, name)         try:             if symlinks and os.path.islink(srcname):                 linkto = os.readlink(srcname)                 os.symlink(linkto, dstname)             elif os.path.isdir(srcname):                 copytree(srcname, dstname, symlinks, ignore)             else:                 # Will raise a SpecialFileError for unsupported file types                 copy2(srcname, dstname)         # catch the Error from the recursive copytree so that we can         # continue with other files         except Error as e:             errors.extend(e.args[0])         except OSError as why:             errors.append((srcname, dstname, str(why)))     try:         copystat(src, dst)     except OSError as why:         errors.append((src, dst, str(why)))     if errors:         raise Error(errors)\n1: def make_tree() -> Node | None:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     return tree\n2: def f(x):     return x**2", "output": "0"}
{"task": "search", "input": "search code:\nThe generating function u as specified in the question.\n\nChoices:\n0: def pressure_conversion(value: float, from_type: str, to_type: str) -> float:     if from_type not in PRESSURE_CONVERSION:         raise ValueError(             f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"             + \", \".join(PRESSURE_CONVERSION)         )     if to_type not in PRESSURE_CONVERSION:         raise ValueError(             f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"             + \", \".join(PRESSURE_CONVERSION)         )     return (         value         * PRESSURE_CONVERSION[from_type].from_factor         * PRESSURE_CONVERSION[to_type].to_factor     )\n1: def sieve(n):     # This implementation comes from an older version of the itertools     # documentation.  The newer implementation is easier to read but is     # less lazy.     if n > 2:         yield 2     start = 3     data = bytearray((0, 1)) * (n // 2)     for p in iter_index(data, 1, start, stop=isqrt(n) + 1):         yield from iter_index(data, 1, start, p * p)         data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))         start = p * p     yield from iter_index(data, 1, start)\n2: def question_function(variable: int) -> int:     return (         1         - variable         + variable**2         - variable**3         + variable**4         - variable**5         + variable**6         - variable**7         + variable**8         - variable**9         + variable**10     )", "output": "2"}
{"task": "search", "input": "search code:\nFind a primitive root modulo modulus, if one exists.\n\nChoices:\n0: def decimal_isolate(number: float, digit_amount: int) -> float:     if digit_amount > 0:         return round(number - int(number), digit_amount)     return number - int(number)\n1: def find_primitive(modulus: int) -> int | None:     for r in range(1, modulus):         li = []         for x in range(modulus - 1):             val = pow(r, x, modulus)             if val in li:                 break             li.append(val)         else:             return r     return None\n2: def pi_estimator(iterations: int) -> None:      # A local function to see if a dot lands in the circle.     def is_in_circle(x: float, y: float) -> bool:         distance_from_centre = sqrt((x**2) + (y**2))         # Our circle has a radius of 1, so a distance         # greater than 1 would land outside the circle.         return distance_from_centre <= 1      # The proportion of guesses that landed in the circle     proportion = mean(         int(is_in_circle(uniform(-1.0, 1.0), uniform(-1.0, 1.0)))         for _ in range(iterations)     )     # The ratio of the area for circle to square is pi/4.     pi_estimate = proportion * 4     print(f\"The estimated value of pi is {pi_estimate}\")     print(f\"The numpy value of pi is {pi}\")     print(f\"The total error is {abs(pi - pi_estimate)}\")", "output": "1"}
{"task": "search", "input": "search code:\nCalculate Number of Divisors of an Integer.\n\nChoices:\n0: def number_of_divisors(n: int) -> int:     if n <= 0:         raise ValueError(\"Only positive numbers are accepted\")     div = 1     temp = 1     while n % 2 == 0:         temp += 1         n = int(n / 2)     div *= temp     for i in range(3, int(math.sqrt(n)) + 1, 2):         temp = 1         while n % i == 0:             temp += 1             n = int(n / i)         div *= temp     if n > 1:         div *= 2     return div\n1: def iter_index(iterable, value, start=0, stop=None):     seq_index = getattr(iterable, 'index', None)     if seq_index is None:         # Slow path for general iterables         iterator = islice(iterable, start, stop)         for i, element in enumerate(iterator, start):             if element is value or element == value:                 yield i     else:         # Fast path for sequences         stop = len(iterable) if stop is None else stop         i = start - 1         with suppress(ValueError):             while True:                 yield (i := seq_index(value, i + 1, stop))\n2: def solution():     script_dir = os.path.dirname(os.path.realpath(__file__))     words_file_path = os.path.join(script_dir, \"words.txt\")      words = \"\"     with open(words_file_path) as f:         words = f.readline()      words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]     words = [         word         for word in [sum(ord(x) - 64 for x in word) for word in words]         if word in TRIANGULAR_NUMBERS     ]     return len(words)", "output": "0"}
{"task": "detection", "input": "classify code:\ndef optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef get_black_and_white_rgb(distance: float) -> tuple:\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return (255, 255, 255)", "output": "Black&white color-coding that ignores the relative distance. The Mandelbrot"}
{"task": "search", "input": "search code:\nReturns the largest palindrome made from the product of two 3-digit\n\nChoices:\n0: def logical_right_shift(number: int, shift_amount: int) -> str:     if number < 0 or shift_amount < 0:         raise ValueError(\"both inputs must be positive integers\")      binary_number = str(bin(number))[2:]     if shift_amount >= len(binary_number):         return \"0b0\"     shifted_binary_number = binary_number[: len(binary_number) - shift_amount]     return \"0b\" + shifted_binary_number\n1: def solution(n: int = 998001) -> int:      # fetches the next number     for number in range(n - 1, 9999, -1):         str_number = str(number)          # checks whether 'str_number' is a palindrome.         if str_number == str_number[::-1]:             divisor = 999              # if 'number' is a product of two 3-digit numbers             # then number is the answer otherwise fetch next number.             while divisor != 99:                 if (number % divisor == 0) and (len(str(number // divisor)) == 3.0):                     return number                 divisor -= 1     raise ValueError(\"That number is larger than our acceptable range.\")\n2: def crossover(parent_1: str, parent_2: str) -> tuple[str, str]:     random_slice = random.randint(0, len(parent_1) - 1)     child_1 = parent_1[:random_slice] + parent_2[random_slice:]     child_2 = parent_2[:random_slice] + parent_1[random_slice:]     return (child_1, child_2)", "output": "1"}
{"task": "search", "input": "search code:\nConvert a octal value to its decimal equivalent\n\nChoices:\n0: def value_chain(*args):     scalar_types = (str, bytes)     for value in args:         if isinstance(value, scalar_types):             yield value             continue         try:             yield from value         except TypeError:             yield value\n1: def slow_primes(max_n: int) -> Generator[int]:     numbers: Generator = (i for i in range(1, (max_n + 1)))     for i in (n for n in numbers if n > 1):         for j in range(2, i):             if (i % j) == 0:                 break         else:             yield i\n2: def oct_to_decimal(oct_string: str) -> int:     oct_string = str(oct_string).strip()     if not oct_string:         raise ValueError(\"Empty string was passed to the function\")     is_negative = oct_string[0] == \"-\"     if is_negative:         oct_string = oct_string[1:]     if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):         raise ValueError(\"Non-octal value was passed to the function\")     decimal_number = 0     for char in oct_string:         decimal_number = 8 * decimal_number + int(char)     if is_negative:         decimal_number = -decimal_number     return decimal_number", "output": "2"}
{"task": "search", "input": "search code:\nFunction implements sdbm hash, easy to use, great for bits scrambling.\n\nChoices:\n0: def is_palindrome(n: int | str) -> bool:     n = str(n)     return n == n[::-1]\n1: def sdbm(plain_text: str) -> int:     hash_value = 0     for plain_chr in plain_text:         hash_value = (             ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value         )     return hash_value\n2: def join_mappings(**field_to_map):     ret = defaultdict(dict)      for field_name, mapping in field_to_map.items():         for key, value in mapping.items():             ret[key][field_name] = value      return dict(ret)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef shell_sort(collection: list[int]) -> list[int]:\n    # Marcin Ciura's gap sequence\n\n    gaps = [701, 301, 132, 57, 23, 10, 4, 1]\n    for gap in gaps:\n        for i in range(gap, len(collection)):\n            insert_value = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > insert_value:\n                collection[j] = collection[j - gap]\n                j -= gap\n            if j != i:\n                collection[j] = insert_value\n    return collection", "output": "Pure implementation of shell sort algorithm in Python"}
{"task": "summary", "input": "summarize code:\ndef _dense_to_one_hot(labels_dense, num_classes):\n    num_labels = labels_dense.shape[0]\n    index_offset = np.arange(num_labels) * num_classes\n    labels_one_hot = np.zeros((num_labels, num_classes))\n    labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1\n    return labels_one_hot", "output": "Convert class labels from scalars to one-hot vectors."}
{"task": "search", "input": "search code:\nThis function performs a retroactive linear system resolution\n\nChoices:\n0: def retroactive_resolution(     coefficients: NDArray[float64], vector: NDArray[float64] ) -> NDArray[float64]:      rows, _columns = np.shape(coefficients)      x: NDArray[float64] = np.zeros((rows, 1), dtype=float)     for row in reversed(range(rows)):         total = np.dot(coefficients[row, row + 1 :], x[row + 1 :])         x[row, 0] = (vector[row][0] - total[0]) / coefficients[row, row]      return x\n1: def filter_common_word(possibles: list[str], common_word: str) -> list[str]:     return [possible for possible in possibles if common_word in possible.lower()]\n2: def twos_complement(number: int) -> str:     if number > 0:         raise ValueError(\"input must be a negative integer\")     binary_number_length = len(bin(number)[3:])     twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]     twos_complement_number = (         (             \"1\"             + \"0\" * (binary_number_length - len(twos_complement_number))             + twos_complement_number         )         if number < 0         else \"0\"     )     return \"0b\" + twos_complement_number", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef squareplus(vector: np.ndarray, beta: float) -> np.ndarray:\n    return (vector + np.sqrt(vector**2 + beta)) / 2", "output": "Implements the SquarePlus activation function."}
{"task": "detection", "input": "classify code:\ndef reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> sentence = \"I love Python\"\n    >>> reverse_words(sentence) == \" \".join(sentence.split()[::-1])\n    True\n    >>> reverse_words(sentence)\n    'Python love I'\n    \"\"\"\n    return \" \".join(reversed(input_str.split(\" \")))", "output": "BUGGY"}
{"task": "search", "input": "search code:\nCalculate the simple moving average (SMA) for some given time series data.\n\nChoices:\n0: def compute_transform_tables(     source_string: str,     destination_string: str,     copy_cost: int,     replace_cost: int,     delete_cost: int,     insert_cost: int, ) -> tuple[list[list[int]], list[list[str]]]:     source_seq = list(source_string)     destination_seq = list(destination_string)     len_source_seq = len(source_seq)     len_destination_seq = len(destination_seq)     costs = [         [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]     ops = [         [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)     ]      for i in range(1, len_source_seq + 1):         costs[i][0] = i * delete_cost         ops[i][0] = f\"D{source_seq[i - 1]}\"      for i in range(1, len_destination_seq + 1):         costs[0][i] = i * insert_cost         ops[0][i] = f\"I{destination_seq[i - 1]}\"      for i in range(1, len_source_seq + 1):         for j in range(1, len_destination_seq + 1):             if source_seq[i - 1] == destination_seq[j - 1]:                 costs[i][j] = costs[i - 1][j - 1] + copy_cost                 ops[i][j] = f\"C{source_seq[i - 1]}\"             else:                 costs[i][j] = costs[i - 1][j - 1] + replace_cost                 ops[i][j] = f\"R{source_seq[i - 1]}\" + str(destination_seq[j - 1])              if costs[i - 1][j] + delete_cost < costs[i][j]:                 costs[i][j] = costs[i - 1][j] + delete_cost                 ops[i][j] = f\"D{source_seq[i - 1]}\"              if costs[i][j - 1] + insert_cost < costs[i][j]:                 costs[i][j] = costs[i][j - 1] + insert_cost                 ops[i][j] = f\"I{destination_seq[j - 1]}\"      return costs, ops\n1: def simple_moving_average(     data: Sequence[float], window_size: int ) -> list[float | None]:     if window_size < 1:         raise ValueError(\"Window size must be a positive integer\")      sma: list[float | None] = []      for i in range(len(data)):         if i < window_size - 1:             sma.append(None)  # SMA not available for early data points         else:             window = data[i - window_size + 1 : i + 1]             sma_value = sum(window) / window_size             sma.append(sma_value)     return sma\n2: def solution(n: int = 4000000) -> int:      if n <= 1:         return 0     a = 0     b = 2     count = 0     while 4 * b + a <= n:         a, b = b, 4 * b + a         count += a     return count + b", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(limit: int = 1000000) -> int:\n    answer = 0\n\n    for outer_width in range(3, (limit // 4) + 2):\n        if outer_width**2 > limit:\n            hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)\n        else:\n            hole_width_lower_bound = 1\n        if (outer_width - hole_width_lower_bound) % 2:\n            hole_width_lower_bound += 1\n\n        answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1\n\n    return answer", "output": "Return the number of different square laminae that can be formed using up to"}
{"task": "repair", "input": "fix bug:\ndef backtrack(input_string: str, word_dict: set[str], start: int) -> bool:\n    \"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\n\n    # Base case: if the starting index has reached the end of the string\n    if start == len(input_string):\n        return True\n\n    # Try every possible substring from 'start' to 'end'\n    for end in range(start + 1, len(input_string) + 1):\n        if input_string[start:end] in word_dict and backtrack(\n            input_string, word_dict, end\n        ):\n            return True\n\n    return False", "output": "def backtrack(input_string: str, word_dict: set[str], start: int) -> bool:\n    \"\"\"\n    Helper function that uses backtracking to determine if a valid\n    word segmentation is possible starting from index 'start'.\n\n    Parameters:\n    input_string (str): The input string to be segmented.\n    word_dict (set[str]): A set of valid dictionary words.\n    start (int): The starting index of the substring to be checked.\n\n    Returns:\n    bool: True if a valid segmentation is possible, otherwise False.\n\n    Example:\n    >>> backtrack(\"leetcode\", {\"leet\", \"code\"}, 0)\n    True\n\n    >>> backtrack(\"applepenapple\", {\"apple\", \"pen\"}, 0)\n    True\n\n    >>> backtrack(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}, 0)\n    False\n    \"\"\"\n\n    # Base case: if the starting index has reached the end of the string\n    if start == len(input_string):\n        return True\n\n    # Try every possible substring from 'start' to 'end'\n    for end in range(start + 1, len(input_string) + 1):\n        if input_string[start:end] in word_dict and backtrack(\n            input_string, word_dict, end\n        ):\n            return True\n\n    return False"}
{"task": "search", "input": "search code:\nTake in positive 2 integers.\n\nChoices:\n0: def logical_right_shift(number: int, shift_amount: int) -> str:     if number < 0 or shift_amount < 0:         raise ValueError(\"both inputs must be positive integers\")      binary_number = str(bin(number))[2:]     if shift_amount >= len(binary_number):         return \"0b0\"     shifted_binary_number = binary_number[: len(binary_number) - shift_amount]     return \"0b\" + shifted_binary_number\n1: def sigmoid(vector: np.ndarray) -> np.ndarray:     return 1 / (1 + np.exp(-vector))\n2: def left_rotate_32(i: int, shift: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")     if shift < 0:         raise ValueError(\"Shift must be non-negative\")     return ((i << shift) ^ (i >> (32 - shift))) % 2**32", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):\n\n    ret = defaultdict(list)\n\n    if valuefunc is None:\n        for item in iterable:\n            key = keyfunc(item)\n            ret[key].append(item)\n\n    else:\n        for item in iterable:\n            key = keyfunc(item)\n            value = valuefunc(item)\n            ret[key].append(value)\n\n    if reducefunc is not None:\n        for key, value_list in ret.items():\n            ret[key] = reducefunc(value_list)\n\n    ret.default_factory = None\n    return ret", "output": "Return a dictionary that maps the items in *iterable* to categories"}
{"task": "repair", "input": "fix bug:\ndef f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2", "output": "def f(x):\n    \"\"\"\n    This is the function to integrate, f(x) = (x - 0)^2 = x^2.\n\n    :param x: The input value\n    :return: The value of f(x)\n\n    >>> f(0)\n    0\n    >>> f(1)\n    1\n    >>> f(0.5)\n    0.25\n    \"\"\"\n    return x**2"}
{"task": "detection", "input": "classify code:\ndef maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef is_prime(number: int) -> bool:\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True", "output": "Checks to see if a number is a prime in O(sqrt(n))."}
{"task": "search", "input": "search code:\nCheck the equality of ALL elements in an iterable\n\nChoices:\n0: def merge(arr: list[int]) -> list[int]:     if len(arr) > 1:         middle_length = len(arr) // 2  # Finds the middle of the array         left_array = arr[             :middle_length         ]  # Creates an array of the elements in the first half.         right_array = arr[             middle_length:         ]  # Creates an array of the elements in the second half.         left_size = len(left_array)         right_size = len(right_array)         merge(left_array)  # Starts sorting the left.         merge(right_array)  # Starts sorting the right         left_index = 0  # Left Counter         right_index = 0  # Right Counter         index = 0  # Position Counter         while (             left_index < left_size and right_index < right_size         ):  # Runs until the lowers size of the left and right are sorted.             if left_array[left_index] < right_array[right_index]:                 arr[index] = left_array[left_index]                 left_index += 1             else:                 arr[index] = right_array[right_index]                 right_index += 1             index += 1         while (             left_index < left_size         ):  # Adds the left over elements in the left half of the array             arr[index] = left_array[left_index]             left_index += 1             index += 1         while (             right_index < right_size         ):  # Adds the left over elements in the right half of the array             arr[index] = right_array[right_index]             right_index += 1             index += 1     return arr\n1: def equality(iterable: list) -> bool:     return len(set(iterable)) in (0, 1)\n2: def sum_32(a: int, b: int) -> int:     return (a + b) % 2**32", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef parse_timedelta(text):\n    td_kwargs = {}\n    for match in _PARSE_TD_RE.finditer(text):\n        value, unit = match.group('value'), match.group('unit')\n        try:\n            unit_key = _PARSE_TD_KW_MAP[unit]\n        except KeyError:\n            raise ValueError('invalid time unit %r, expected one of %r'\n                             % (unit, _PARSE_TD_KW_MAP.keys()))\n        try:\n            value = float(value)\n        except ValueError:\n            raise ValueError('invalid time value for unit %r: %r'\n                             % (unit, value))\n        td_kwargs[unit_key] = value\n    return timedelta(**td_kwargs)", "output": "Robustly parses a short text description of a time period into a"}
{"task": "search", "input": "search code:\nReturns nth hexagonal number\n\nChoices:\n0: def hexagonal_num(n: int) -> int:     return n * (2 * n - 1)\n1: def all_equal(iterable, key=None):     iterator = groupby(iterable, key)     for first in iterator:         for second in iterator:             return False         return True     return True\n2: def is_valid(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> bool:     for i in range(len(word)):         if vertical:             if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":                 return False         elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":             return False     return True", "output": "0"}
{"task": "search", "input": "search code:\nCount the number of reversible numbers of given length.\n\nChoices:\n0: def is_right(x1: int, y1: int, x2: int, y2: int) -> bool:     if x1 == y1 == 0 or x2 == y2 == 0:         return False     a_square = x1 * x1 + y1 * y1     b_square = x2 * x2 + y2 * y2     c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)     return (         a_square + b_square == c_square         or a_square + c_square == b_square         or b_square + c_square == a_square     )\n1: def reversible_numbers(     remaining_length: int, remainder: int, digits: list[int], length: int ) -> int:     # There exist no reversible 1, 5, 9, 13 (ie. 4k+1) digit numbers     if (length - 1) % 4 == 0:         return 0      return slow_reversible_numbers(remaining_length, remainder, digits, length)\n2: def inspect_formatargspec(         args, varargs=None, varkw=None, defaults=None,         kwonlyargs=(), kwonlydefaults={}, annotations={},         formatarg=str,         formatvarargs=lambda name: '*' + name,         formatvarkw=lambda name: '**' + name,         formatvalue=lambda value: '=' + repr(value),         formatreturns=lambda text: ' -> ' + text,         formatannotation=formatannotation):      def formatargandannotation(arg):         result = formatarg(arg)         if arg in annotations:             result += ': ' + formatannotation(annotations[arg])         return result     specs = []     if defaults:         firstdefault = len(args) - len(defaults)     for i, arg in enumerate(args):         spec = formatargandannotation(arg)         if defaults and i >= firstdefault:             spec = spec + formatvalue(defaults[i - firstdefault])         specs.append(spec)     if varargs is not None:         specs.append(formatvarargs(formatargandannotation(varargs)))     else:         if kwonlyargs:             specs.append('*')     if kwonlyargs:         for kwonlyarg in kwonlyargs:             spec = formatargandannotation(kwonlyarg)             if kwonlydefaults and kwonlyarg in kwonlydefaults:                 spec += formatvalue(kwonlydefaults[kwonlyarg])             specs.append(spec)     if varkw is not None:         specs.append(formatvarkw(formatargandannotation(varkw)))     result = '(' + ', '.join(specs) + ')'     if 'return' in annotations:         result += formatreturns(formatannotation(annotations['return']))     return result", "output": "1"}
{"task": "search", "input": "search code:\nfinds where function becomes 0 in [a,b] using bolzano\n\nChoices:\n0: def vol_spheres_union(     radius_1: float, radius_2: float, centers_distance: float ) -> float:      if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:         raise ValueError(             \"vol_spheres_union() only accepts non-negative values, non-zero radius\"         )      if centers_distance == 0:         return vol_sphere(max(radius_1, radius_2))      return (         vol_sphere(radius_1)         + vol_sphere(radius_2)         - vol_spheres_intersect(radius_1, radius_2, centers_distance)     )\n1: def bisection(function: Callable[[float], float], a: float, b: float) -> float:     start: float = a     end: float = b     if function(a) == 0:  # one of the a or b is a root for the function         return a     elif function(b) == 0:         return b     elif (         function(a) * function(b) > 0     ):  # if none of these are root and they are both positive or negative,         # then this algorithm can't find the root         raise ValueError(\"could not find root in given interval.\")     else:         mid: float = start + (end - start) / 2.0         while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7             if function(mid) == 0:                 return mid             elif function(mid) * function(start) < 0:                 end = mid             else:                 start = mid             mid = start + (end - start) / 2.0         return mid\n2: def fibonacci(n: int) -> int:     if n == 1 or not isinstance(n, int):         return 0     elif n == 2:         return 1     else:         sequence = [0, 1]         for i in range(2, n + 1):             sequence.append(sequence[i - 1] + sequence[i - 2])          return sequence[n]", "output": "1"}
{"task": "search", "input": "search code:\nCompute the \"subdictionary\" of a dict, *d*.\n\nChoices:\n0: def gunzip_bytes(bytestring):     return zlib.decompress(bytestring, 16 + zlib.MAX_WBITS)\n1: def cardinalize(unit_noun, count):     if count == 1:         return unit_noun     return pluralize(unit_noun)\n2: def subdict(d, keep=None, drop=None):     if keep is None:         keep = d.keys()     if drop is None:         drop = []      keys = set(keep) - set(drop)      return type(d)([(k, v) for k, v in d.items() if k in keys])", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef selection(chart: List[List[int]], prime_implicants: List[str]) -> List[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0", "output": "def selection(chart: list[list[int]], prime_implicants: list[str]) -> list[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = 0\n        rem = -1\n        for j in range(len(chart)):\n            if chart[j][i] == 1:\n                count += 1\n                rem = j\n        if count == 1:\n            select[rem] = 1\n    for i in range(len(select)):\n        if select[i] == 1:\n            for j in range(len(chart[0])):\n                if chart[i][j] == 1:\n                    for k in range(len(chart)):\n                        chart[k][j] = 0\n            temp.append(prime_implicants[i])\n    while 1:\n        max_n = 0\n        rem = -1\n        count_n = 0\n        for i in range(len(chart)):\n            count_n = chart[i].count(1)\n            if count_n > max_n:\n                max_n = count_n\n                rem = i\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for i in range(len(chart[0])):\n            if chart[rem][i] == 1:\n                for j in range(len(chart)):\n                    chart[j][i] = 0"}
{"task": "search", "input": "search code:\nArgs:\n\nChoices:\n0: def iter_suppress(iterable, *exceptions):     try:         yield from iterable     except exceptions:         return\n1: def harmonic_series(n_term: str) -> list:     if n_term == \"\":         return []     series: list = []     for temp in range(int(n_term)):         series.append(f\"1/{temp + 1}\" if series else \"1\")     return series\n2: def simpson_integration(function, a: float, b: float, precision: int = 4) -> float:     assert callable(function), (         f\"the function(object) passed should be callable your input : {function}\"     )     assert isinstance(a, (float, int)), f\"a should be float or integer your input : {a}\"     assert isinstance(function(a), (float, int)), (         \"the function should return integer or float return type of your function, \"         f\"{type(a)}\"     )     assert isinstance(b, (float, int)), f\"b should be float or integer your input : {b}\"     assert isinstance(precision, int) and precision > 0, (         f\"precision should be positive integer your input : {precision}\"     )      # just applying the formula of simpson for approximate integration written in     # mentioned article in first comment of this file and above this function      h = (b - a) / N_STEPS     result = function(a) + function(b)      for i in range(1, N_STEPS):         a1 = a + h * i         result += function(a1) * (4 if i % 2 else 2)      result *= h / 3     return round(result, precision)", "output": "2"}
{"task": "search", "input": "search code:\nGiven a collection of numbers and its length, sorts the collections\n\nChoices:\n0: def armstrong_number(n: int) -> bool:     if not isinstance(n, int) or n < 1:         return False      # Initialization of sum and number of digits.     total = 0     number_of_digits = 0     temp = n     # Calculation of digits of the number     number_of_digits = len(str(n))     # Dividing number into separate digits and find Armstrong number     temp = n     while temp > 0:         rem = temp % 10         total += rem**number_of_digits         temp //= 10     return n == total\n1: def solution(limit: int = 1000000) -> int:     answer = 0      for outer_width in range(3, (limit // 4) + 2):         if outer_width**2 > limit:             hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)         else:             hole_width_lower_bound = 1         if (outer_width - hole_width_lower_bound) % 2:             hole_width_lower_bound += 1          answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1      return answer\n2: def rec_insertion_sort(collection: list, n: int):     # Checks if the entire collection has been sorted     if len(collection) <= 1 or n <= 1:         return      insert_next(collection, n - 1)     rec_insertion_sort(collection, n - 1)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef sum_32(a: int, b: int) -> int:\n    return (a + b) % 2**32", "output": "Add two numbers as 32-bit ints."}
{"task": "search", "input": "search code:\nPrint a complete diamond pattern with '*' characters.\n\nChoices:\n0: def pretty_print(n):     if n <= 0:         return \"       ...       ....        nothing printing :(\"     upper_half = floyd(n)  # upper half     lower_half = reverse_floyd(n)  # lower half     return upper_half + lower_half\n1: def find_components(     reversed_graph: dict[int, list[int]], vert: int, visited: list[bool] ) -> list[int]:      visited[vert] = True     component = [vert]      for neighbour in reversed_graph[vert]:         if not visited[neighbour]:             component += find_components(reversed_graph, neighbour, visited)      return component\n2: def xfrange(stop, start=None, step=1.0):     if not step:         raise ValueError('step must be non-zero')     if start is None:         start, stop = 0.0, stop * 1.0     else:         # swap when all args are used         stop, start = start * 1.0, stop * 1.0     cur = start     while cur < stop:         yield cur         cur += step", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area", "output": "def largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area"}
{"task": "summary", "input": "summarize code:\ndef insert_next(collection: list, index: int):\n    # Checks order between adjacent elements\n    if index >= len(collection) or collection[index - 1] <= collection[index]:\n        return\n\n    # Swaps adjacent elements since they are not in ascending order\n    collection[index - 1], collection[index] = (\n        collection[index],\n        collection[index - 1],\n    )\n\n    insert_next(collection, index + 1)", "output": "Inserts the '(index-1)th' element into place"}
{"task": "search", "input": "search code:\nThis function can calculate the Builtin Voltage of a pn junction diode.\n\nChoices:\n0: def builtin_voltage(     donor_conc: float,  # donor concentration     acceptor_conc: float,  # acceptor concentration     intrinsic_conc: float,  # intrinsic concentration ) -> float:      if donor_conc <= 0:         raise ValueError(\"Donor concentration should be positive\")     elif acceptor_conc <= 0:         raise ValueError(\"Acceptor concentration should be positive\")     elif intrinsic_conc <= 0:         raise ValueError(\"Intrinsic concentration should be positive\")     elif donor_conc <= intrinsic_conc:         raise ValueError(             \"Donor concentration should be greater than intrinsic concentration\"         )     elif acceptor_conc <= intrinsic_conc:         raise ValueError(             \"Acceptor concentration should be greater than intrinsic concentration\"         )     else:         return (             Boltzmann             * T             * log((donor_conc * acceptor_conc) / intrinsic_conc**2)             / physical_constants[\"electron volt\"][0]         )\n1: def nand_gate(input_1: int, input_2: int) -> int:     return int(not (input_1 and input_2))\n2: def factorial(num: int) -> int:     fact = 1     for i in range(1, num + 1):         fact *= i     return fact", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)", "output": "Pure implementation of binary search algorithm in Python using recursion"}
{"task": "repair", "input": "fix bug:\ndef alt_ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    >>> alt_ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> alt_ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    \"\"\"\n    return int(\"0x\" + \"\".join(f\"{int(i):02x}\" for i in ipv4_address.split(\".\")), 16)", "output": "def alt_ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    >>> alt_ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> alt_ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    \"\"\"\n    return int(\"0x\" + \"\".join(f\"{int(i):02x}\" for i in ipv4_address.split(\".\")), 16)"}
{"task": "search", "input": "search code:\nCalculates the product sum of an array.\n\nChoices:\n0: def product_sum_array(array: list[int | list]) -> int:     return product_sum(array, 1)\n1: def bitonic_sort(array: list[int], low: int, length: int, direction: int) -> None:     if length > 1:         middle = int(length / 2)         bitonic_sort(array, low, middle, 1)         bitonic_sort(array, low + middle, middle, 0)         bitonic_merge(array, low, length, direction)\n2: def solution(fraction: float = 1 / 1000) -> int:      l_section_area = (1 - pi / 4) / 4      for n in count(1):         if concave_triangle_area(n) / l_section_area < fraction:             return n      return -1", "output": "0"}
{"task": "detection", "input": "classify code:\ndef binary_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return None", "output": "BUGGY"}
{"task": "summary", "input": "summarize code:\ndef intersection(function: Callable[[float], float], x0: float, x1: float) -> float:\n    x_n: float = x0\n    x_n1: float = x1\n    while True:\n        if x_n == x_n1 or function(x_n1) == function(x_n):\n            raise ZeroDivisionError(\"float division by zero, could not find root\")\n        x_n2: float = x_n1 - (\n            function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))\n        )\n        if abs(x_n2 - x_n1) < 10**-5:\n            return x_n2\n        x_n = x_n1\n        x_n1 = x_n2", "output": "function is the f we want to find its root"}
{"task": "summary", "input": "summarize code:\ndef solution(t_limit: int = 1000000, n_limit: int = 10) -> int:\n    count: defaultdict = defaultdict(int)\n\n    for outer_width in range(3, (t_limit // 4) + 2):\n        if outer_width * outer_width > t_limit:\n            hole_width_lower_bound = max(\n                ceil(sqrt(outer_width * outer_width - t_limit)), 1\n            )\n        else:\n            hole_width_lower_bound = 1\n\n        hole_width_lower_bound += (outer_width - hole_width_lower_bound) % 2\n\n        for hole_width in range(hole_width_lower_bound, outer_width - 1, 2):\n            count[outer_width * outer_width - hole_width * hole_width] += 1\n\n    return sum(1 for n in count.values() if 1 <= n <= n_limit)", "output": "Return the sum of N(n) for 1 <= n <= n_limit."}
{"task": "detection", "input": "classify code:\ndef longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    >>> longest_common_subsequence(\"\", \"abc\")  # One string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"\")  # Other string is empty\n    (0, '')\n    >>> longest_common_subsequence(\"\", \"\")  # Both strings are empty\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"def\")  # No common subsequence\n    (0, '')\n    >>> longest_common_subsequence(\"abc\", \"abc\")  # Identical strings\n    (3, 'abc')\n    >>> longest_common_subsequence(\"a\", \"a\")  # Single character match\n    (1, 'a')\n    >>> longest_common_subsequence(\"a\", \"b\")  # Single character no match\n    (0, '')\n    >>> longest_common_subsequence(\"abcdef\", \"ace\")  # Interleaved subsequence\n    (3, 'ace')\n    >>> longest_common_subsequence(\"ABCD\", \"ACBD\")  # No repeated characters\n    (3, 'ABD')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:\n    visited = [False] * len(graph)  # Mark all nodes as not visited\n    queue = []  # breadth-first search queue\n\n    # Source node\n    queue.append(source)\n    visited[source] = True\n\n    while queue:\n        u = queue.pop(0)  # Pop the front node\n        # Traverse all adjacent nodes of u\n        for ind, node in enumerate(graph[u]):\n            if visited[ind] is False and node > 0:\n                queue.append(ind)\n                visited[ind] = True\n                parents[ind] = u\n    return visited[sink]", "output": "This function returns True if there is a node that has not iterated."}
{"task": "search", "input": "search code:\nRetrieves the index of the first occurrence of pattern in text.\n\nChoices:\n0: def minimum_cost_path(matrix: list[list[int]]) -> int:      # preprocessing the first row     for i in range(1, len(matrix[0])):         matrix[0][i] += matrix[0][i - 1]      # preprocessing the first column     for i in range(1, len(matrix)):         matrix[i][0] += matrix[i - 1][0]      # updating the path cost for current position     for i in range(1, len(matrix)):         for j in range(1, len(matrix[0])):             matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])      return matrix[-1][-1]\n1: def bitap_string_match(text: str, pattern: str) -> int:     if not pattern:         return 0     m = len(pattern)     if m > len(text):         return -1      # Initial state of bit string 1110     state = ~1     # Bit = 0 if character appears at index, and 1 otherwise     pattern_mask: list[int] = [~0] * 27  # 1111      for i, char in enumerate(pattern):         # For the pattern mask for this character, set the bit to 0 for each i         # the character appears.         pattern_index: int = ord(char) - ord(\"a\")         pattern_mask[pattern_index] &= ~(1 << i)      for i, char in enumerate(text):         text_index = ord(char) - ord(\"a\")         # If this character does not appear in pattern, it's pattern mask is 1111.         # Performing a bitwise OR between state and 1111 will reset the state to 1111         # and start searching the start of pattern again.         state |= pattern_mask[text_index]         state <<= 1          # If the mth bit (counting right to left) of the state is 0, then we have         # found pattern in text         if (state & (1 << m)) == 0:             return i - m + 1      return -1\n2: def in_reverse(linked_list: LinkedList) -> str:     return \" <- \".join(str(line) for line in reversed(tuple(linked_list)))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef find_negative_index(array: list[int]) -> int:\n    \"\"\"\n    Find the smallest negative index\n\n    >>> find_negative_index([0,0,0,0])\n    4\n    >>> find_negative_index([4,3,2,-1])\n    3\n    >>> find_negative_index([1,0,-1,-10])\n    2\n    >>> find_negative_index([0,0,0,-1])\n    3\n    >>> find_negative_index([11,8,7,-3,-5,-9])\n    3\n    >>> find_negative_index([-1,-1,-2,-3])\n    0\n    >>> find_negative_index([5,1,0])\n    3\n    >>> find_negative_index([-5,-5,-5])\n    0\n    >>> find_negative_index([0])\n    1\n    >>> find_negative_index([])\n    0\n    \"\"\"\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef are_collinear(a: Point3d, b: Point3d, c: Point3d, accuracy: int = 10) -> bool:\n    ab = create_vector(a, b)\n    ac = create_vector(a, c)\n    return is_zero_vector(get_3d_vectors_cross(ab, ac), accuracy)", "output": "Check if three points are collinear or not."}
{"task": "search", "input": "search code:\nReturns the number of different ways can n pence be made using any number of\n\nChoices:\n0: def solution(num_picks: int = 20) -> str:     total = math.comb(NUM_BALLS, num_picks)     missing_colour = math.comb(NUM_BALLS - BALLS_PER_COLOUR, num_picks)      result = NUM_COLOURS * (1 - missing_colour / total)      return f\"{result:.9f}\"\n1: def get_all(type_obj, include_subtypes=True):     # TODO: old-style classes     if not isinstance(type_obj, type):         raise TypeError('expected a type, not %r' % type_obj)     try:         type_is_tracked = gc.is_tracked(type_obj)     except AttributeError:         type_is_tracked = False  # Python 2.6 and below don't get the speedup     if type_is_tracked:         to_check = gc.get_referrers(type_obj)     else:         to_check = gc.get_objects()      if include_subtypes:         ret = [x for x in to_check if isinstance(x, type_obj)]     else:         ret = [x for x in to_check if type(x) is type_obj]     return ret\n2: def solution(n: int = 200) -> int:     return two_pound(n)", "output": "2"}
{"task": "search", "input": "search code:\nRotate the bits of a given int left by a given amount.\n\nChoices:\n0: def left_rotate_32(i: int, shift: int) -> int:     if i < 0:         raise ValueError(\"Input must be non-negative\")     if shift < 0:         raise ValueError(\"Shift must be non-negative\")     return ((i << shift) ^ (i >> (32 - shift))) % 2**32\n1: def find_unit_clauses(     clauses: list[Clause],     model: dict[str, bool | None],  # noqa: ARG001 ) -> tuple[list[str], dict[str, bool | None]]:     unit_symbols = []     for clause in clauses:         if len(clause) == 1:             unit_symbols.append(next(iter(clause.literals.keys())))         else:             f_count, n_count = 0, 0             for literal, value in clause.literals.items():                 if value is False:                     f_count += 1                 elif value is None:                     sym = literal                     n_count += 1             if f_count == len(clause) - 1 and n_count == 1:                 unit_symbols.append(sym)     assignment: dict[str, bool | None] = {}     for i in unit_symbols:         symbol = i[:2]         assignment[symbol] = len(i) == 2     unit_symbols = [i[:2] for i in unit_symbols]      return unit_symbols, assignment\n2: def ichunked(iterable, n):     iterator = iter(iterable)     while True:         # Create new chunk         chunk, materialize_next = _ichunk(iterator, n)          # Check to see whether we're at the end of the source iterable         if not materialize_next():             return          yield chunk          # Fill previous chunk's cache         materialize_next(None)", "output": "0"}
{"task": "search", "input": "search code:\nUsing depth-first search and propagation, try all possible values.\n\nChoices:\n0: def search(values):     if values is False:         return False  ## Failed earlier     if all(len(values[s]) == 1 for s in squares):         return values  ## Solved!     ## Chose the unfilled square s with the fewest possibilities     _n, s = min((len(values[s]), s) for s in squares if len(values[s]) > 1)     return some(search(assign(values.copy(), s, d)) for d in values[s])\n1: def question_function(variable: int) -> int:     return (         1         - variable         + variable**2         - variable**3         + variable**4         - variable**5         + variable**6         - variable**7         + variable**8         - variable**9         + variable**10     )\n2: def sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:     total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)     # formula for sum of series     return total", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef double_sort(collection: list[Any]) -> list[Any]:\n    no_of_elements = len(collection)\n    for _ in range(\n        int(((no_of_elements - 1) / 2) + 1)\n    ):  # we don't need to traverse to end of list as\n        for j in range(no_of_elements - 1):\n            # apply the bubble sort algorithm from left to right (or forwards)\n            if collection[j + 1] < collection[j]:\n                collection[j], collection[j + 1] = collection[j + 1], collection[j]\n            # apply the bubble sort algorithm from right to left (or backwards)\n            if collection[no_of_elements - 1 - j] < collection[no_of_elements - 2 - j]:\n                (\n                    collection[no_of_elements - 1 - j],\n                    collection[no_of_elements - 2 - j],\n                ) = (\n                    collection[no_of_elements - 2 - j],\n                    collection[no_of_elements - 1 - j],\n                )\n    return collection", "output": "This sorting algorithm sorts an array using the principle of bubble sort,"}
{"task": "search", "input": "search code:\nHelper function to recursively build all combinations.\n\nChoices:\n0: def not_gate(input_1: int) -> int:      return 1 if input_1 == 0 else 0\n1: def create_all_state(     increment: int,     total_number: int,     level: int,     current_list: list[int],     total_list: list[list[int]], ) -> None:     if level == 0:         total_list.append(current_list[:])         return      for i in range(increment, total_number - level + 2):         current_list.append(i)         create_all_state(i + 1, total_number, level - 1, current_list, total_list)         current_list.pop()\n2: def to_title_case(word: str) -> str:      if \"a\" <= word[0] <= \"z\":         word = chr(ord(word[0]) - 32) + word[1:]      for i in range(1, len(word)):         if \"A\" <= word[i] <= \"Z\":             word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]      return word", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef sieve(n):\n    # This implementation comes from an older version of the itertools\n    # documentation.  The newer implementation is easier to read but is\n    # less lazy.\n    if n > 2:\n        yield 2\n    start = 3\n    data = bytearray((0, 1)) * (n // 2)\n    for p in iter_index(data, 1, start, stop=isqrt(n) + 1):\n        yield from iter_index(data, 1, start, p * p)\n        data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))\n        start = p * p\n    yield from iter_index(data, 1, start)", "output": "Yield the primes less than n."}
{"task": "search", "input": "search code:\nReturn a new iterable yielding from each iterable in turn,\n\nChoices:\n0: def coulombs_law(q1: float, q2: float, radius: float) -> float:     if radius <= 0:         raise ValueError(\"The radius is always a positive number\")     return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)\n1: def interleave_longest(*iterables):     for xs in zip_longest(*iterables, fillvalue=_marker):         for x in xs:             if x is not _marker:                 yield x\n2: def binary_search(array: list, lower_bound: int, upper_bound: int, value: int) -> int:      r = int((lower_bound + upper_bound) // 2)     if array[r] == value:         return r     if lower_bound >= upper_bound:         return -1     if array[r] < value:         return binary_search(array, r + 1, upper_bound, value)     else:         return binary_search(array, lower_bound, r - 1, value)", "output": "1"}
{"task": "search", "input": "search code:\nFind the isolated node in the graph\n\nChoices:\n0: def solution(n: int = 1000) -> int:     return fibonacci_digits_index(n)\n1: def find_isolated_nodes(graph):     isolated = []     for node in graph:         if not graph[node]:             isolated.append(node)     return isolated\n2: def solution() -> int:     script_dir = os.path.dirname(os.path.realpath(__file__))     triangle_path = os.path.join(script_dir, \"triangle.txt\")      with open(triangle_path) as in_file:         triangle = [[int(i) for i in line.split()] for line in in_file]      while len(triangle) != 1:         last_row = triangle.pop()         curr_row = triangle[-1]         for j in range(len(last_row) - 1):             curr_row[j] += max(last_row[j], last_row[j + 1])     return triangle[0][0]", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef reverse_floyd(n):\n    result = \"\"\n    for i in range(n, 0, -1):\n        for _ in range(i, 0, -1):  # printing stars\n            result += \"* \"\n        result += \"\\n\"\n        for _ in range(n - i + 1, 0, -1):  # printing spaces\n            result += \" \"\n    return result", "output": "Print the lower half of a diamond pattern with '*' characters."}
{"task": "summary", "input": "summarize code:\ndef perfect_square_binary_search(n: int) -> bool:\n    left = 0\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        if mid**2 == n:\n            return True\n        elif mid**2 > n:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False", "output": "Check if a number is perfect square using binary search."}
{"task": "repair", "input": "fix bug:\ndef orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    \"\"\"\n    Calculates the work required to move an object from one orbit to another in a\n    gravitational field based on the change in total mechanical energy.\n\n    The formula used is:\n        W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\n    where:\n        W = work done (Joules)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the central body (kg)\n        m = mass of the orbiting object (kg)\n        r_initial = initial orbit radius (m)\n        r_final = final orbit radius (m)\n\n    Args:\n        mass_central (float): Mass of the central body (kg)\n        mass_object (float): Mass of the object being moved (kg)\n        r_initial (float): Initial orbital radius (m)\n        r_final (float): Final orbital radius (m)\n\n    Returns:\n        str: Work done in Joules as a string in scientific notation (3 decimals)\n\n    Examples:\n        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n        '2.811e+09'\n        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n        '-1.405e+09'\n        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n        '1.514e+11'\n    \"\"\"\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\"", "output": "def orbital_transfer_work(\n    mass_central: float, mass_object: float, r_initial: float, r_final: float\n) -> str:\n    \"\"\"\n    Calculates the work required to move an object from one orbit to another in a\n    gravitational field based on the change in total mechanical energy.\n\n    The formula used is:\n        W = (G * M * m / 2) * (1/r_initial - 1/r_final)\n\n    where:\n        W = work done (Joules)\n        G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)\n        M = mass of the central body (kg)\n        m = mass of the orbiting object (kg)\n        r_initial = initial orbit radius (m)\n        r_final = final orbit radius (m)\n\n    Args:\n        mass_central (float): Mass of the central body (kg)\n        mass_object (float): Mass of the object being moved (kg)\n        r_initial (float): Initial orbital radius (m)\n        r_final (float): Final orbital radius (m)\n\n    Returns:\n        str: Work done in Joules as a string in scientific notation (3 decimals)\n\n    Examples:\n        >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)\n        '2.811e+09'\n        >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)\n        '-1.405e+09'\n        >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)\n        '1.514e+11'\n    \"\"\"\n    gravitational_constant = 6.67430e-11\n\n    if r_initial <= 0 or r_final <= 0:\n        raise ValueError(\"Orbital radii must be greater than zero.\")\n\n    work = (gravitational_constant * mass_central * mass_object / 2) * (\n        1 / r_initial - 1 / r_final\n    )\n    return f\"{work:.3e}\""}
{"task": "search", "input": "search code:\nReturns the sum of all numbers whose\n\nChoices:\n0: def sum_of_geometric_progression(     first_term: int, common_ratio: int, num_of_terms: int ) -> float:     if common_ratio == 1:         # Formula for sum if common ratio is 1         return num_of_terms * first_term      # Formula for finding sum of n terms of a GeometricProgression     return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)\n1: def solution() -> int:     limit = 7 * factorial(9) + 1     return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)\n2: def generate_clause() -> Clause:     literals = []     no_of_literals = random.randint(1, 5)     base_var = \"A\"     i = 0     while i < no_of_literals:         var_no = random.randint(1, 5)         var_name = base_var + str(var_no)         var_complement = random.randint(0, 1)         if var_complement == 1:             var_name += \"'\"         if var_name in literals:             i -= 1         else:             literals.append(var_name)         i += 1     return Clause(literals)", "output": "1"}
{"task": "search", "input": "search code:\nReturns the Collatz sequence length for n.\n\nChoices:\n0: def collatz_sequence_length(n: int) -> int:     if n in COLLATZ_SEQUENCE_LENGTHS:         return COLLATZ_SEQUENCE_LENGTHS[n]     next_n = n // 2 if n % 2 == 0 else 3 * n + 1     sequence_length = collatz_sequence_length(next_n) + 1     COLLATZ_SEQUENCE_LENGTHS[n] = sequence_length     return sequence_length\n1: def decompress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         lexicon[curr_string] = last_match_id + \"0\"          if math.log2(index).is_integer():             new_lex = {}             for curr_key in list(lexicon):                 new_lex[\"0\" + curr_key] = lexicon.pop(curr_key)             lexicon = new_lex          lexicon[bin(index)[2:]] = last_match_id + \"1\"         index += 1         curr_string = \"\"     return result\n2: def mps_speed_of_molecule(temperature: float, molar_mass: float) -> float:      if temperature < 0:         raise Exception(\"Absolute temperature cannot be less than 0 K\")     if molar_mass <= 0:         raise Exception(\"Molar mass should be greater than 0 kg/mol\")     return (2 * R * temperature / molar_mass) ** 0.5", "output": "0"}
{"task": "search", "input": "search code:\nPassword Generator allows you to generate a random password of length N.\n\nChoices:\n0: def password_generator(length: int = 8) -> str:     chars = ascii_letters + digits + punctuation     return \"\".join(secrets.choice(chars) for _ in range(length))\n1: def match_word_pattern(pattern: str, input_string: str) -> bool:      def backtrack(pattern_index: int, str_index: int) -> bool:         if pattern_index == len(pattern) and str_index == len(input_string):             return True         if pattern_index == len(pattern) or str_index == len(input_string):             return False         char = pattern[pattern_index]         if char in pattern_map:             mapped_str = pattern_map[char]             if input_string.startswith(mapped_str, str_index):                 return backtrack(pattern_index + 1, str_index + len(mapped_str))             else:                 return False         for end in range(str_index + 1, len(input_string) + 1):             substr = input_string[str_index:end]             if substr in str_map:                 continue             pattern_map[char] = substr             str_map[substr] = char             if backtrack(pattern_index + 1, end):                 return True             del pattern_map[char]             del str_map[substr]         return False      pattern_map: dict[str, str] = {}     str_map: dict[str, str] = {}     return backtrack(0, 0)\n2: def build_tree() -> TreeNode:     root = TreeNode(1)     root.left = TreeNode(2)     root.right = TreeNode(5)     root.left.left = TreeNode(3)     root.left.right = TreeNode(4)     root.right.right = TreeNode(6)     return root", "output": "0"}
{"task": "search", "input": "search code:\nA generalized outer product that applies a binary function to all\n\nChoices:\n0: def outer_product(func, xs, ys, *args, **kwargs):     ys = tuple(ys)     return batched(         starmap(lambda x, y: func(x, y, *args, **kwargs), product(xs, ys)),         n=len(ys),     )\n1: def optimal_merge_pattern(files: list) -> float:     optimal_merge_cost = 0     while len(files) > 1:         temp = 0         # Consider two files with minimum cost to be merged         for _ in range(2):             min_index = files.index(min(files))             temp += files[min_index]             files.pop(min_index)         files.append(temp)         optimal_merge_cost += temp     return optimal_merge_cost\n2: def gray_to_binary(gray: np.ndarray) -> np.ndarray:     return (gray > 127) & (gray <= 255)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef decode(ciphertext: str, key: str) -> str:\n\n    table = generate_table(key)\n    plaintext = \"\"\n\n    for char1, char2 in chunker(ciphertext, 2):\n        row1, col1 = divmod(table.index(char1), 5)\n        row2, col2 = divmod(table.index(char2), 5)\n\n        if row1 == row2:\n            plaintext += table[row1 * 5 + (col1 - 1) % 5]\n            plaintext += table[row2 * 5 + (col2 - 1) % 5]\n        elif col1 == col2:\n            plaintext += table[((row1 - 1) % 5) * 5 + col1]\n            plaintext += table[((row2 - 1) % 5) * 5 + col2]\n        else:  # rectangle\n            plaintext += table[row1 * 5 + col2]\n            plaintext += table[row2 * 5 + col1]\n\n    return plaintext", "output": "Decode the input string using the provided key."}
{"task": "summary", "input": "summarize code:\ndef heaps(arr: list) -> list:\n\n    if len(arr) <= 1:\n        return [tuple(arr)]\n\n    res = []\n\n    def generate(k: int, arr: list):\n        if k == 1:\n            res.append(tuple(arr[:]))\n            return\n\n        generate(k - 1, arr)\n\n        for i in range(k - 1):\n            if k % 2 == 0:  # k is even\n                arr[i], arr[k - 1] = arr[k - 1], arr[i]\n            else:  # k is odd\n                arr[0], arr[k - 1] = arr[k - 1], arr[0]\n            generate(k - 1, arr)\n\n    generate(len(arr), arr)\n    return res", "output": "Pure python implementation of the Heap's algorithm (recursive version),"}
{"task": "search", "input": "search code:\nsets every nodes direct parent\n\nChoices:\n0: def breadth_first_search(     level: list[int],     parent: list[list[int]],     max_node: int,     graph: dict[int, list[int]],     root: int = 1, ) -> tuple[list[int], list[list[int]]]:     level[root] = 0     q: Queue[int] = Queue(maxsize=max_node)     q.put(root)     while q.qsize() != 0:         u = q.get()         for v in graph[u]:             if level[v] == -1:                 level[v] = level[u] + 1                 q.put(v)                 parent[0][v] = u     return level, parent\n1: def solution(matrix_str: list[str] = MATRIX_2) -> int:      n = len(matrix_str)     arr = np.empty(shape=(n, n), dtype=int)     for row, matrix_row_str in enumerate(matrix_str):         matrix_row_list_str = matrix_row_str.split()         for col, elem_str in enumerate(matrix_row_list_str):             arr[row, col] = int(elem_str)      cache: dict[str, int] = {}     return solve(arr=arr, row=0, cols=set(range(n)), cache=cache)\n2: def create_cipher_map(key: str) -> dict[str, str]:     # Create a list of the letters in the alphabet     alphabet = [chr(i + 65) for i in range(26)]     # Remove duplicate characters from key     key = remove_duplicates(key.upper())     offset = len(key)     # First fill cipher with key characters     cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}     # Then map remaining characters in alphabet to     # the alphabet from the beginning     for i in range(len(cipher_alphabet), 26):         char = alphabet[i - offset]         # Ensure we are not mapping letters to letters previously mapped         while char in key:             offset -= 1             char = alphabet[i - offset]         cipher_alphabet[alphabet[i]] = char     return cipher_alphabet", "output": "0"}
{"task": "search", "input": "search code:\nA small helper function for the recursion, mainly to have\n\nChoices:\n0: def _calculate(days: int, absent: int, late: int) -> int:      # if we are absent twice, or late 3 consecutive days,     # no further prize strings are possible     if late == 3 or absent == 2:         return 0      # if we have no days left, and have not failed any other rules,     # we have a prize string     if days == 0:         return 1      # No easy solution, so now we need to do the recursive calculation      # First, check if the combination is already in the cache, and     # if yes, return the stored value from there since we already     # know the number of possible prize strings from this point on     key = (days, absent, late)     if key in cache:         return cache[key]      # now we calculate the three possible ways that can unfold from     # this point on, depending on our attendance today      # 1) if we are late (but not absent), the \"absent\" counter stays as     # it is, but the \"late\" counter increases by one     state_late = _calculate(days - 1, absent, late + 1)      # 2) if we are absent, the \"absent\" counter increases by 1, and the     # \"late\" counter resets to 0     state_absent = _calculate(days - 1, absent + 1, 0)      # 3) if we are on time, this resets the \"late\" counter and keeps the     # absent counter     state_ontime = _calculate(days - 1, absent, 0)      prizestrings = state_late + state_absent + state_ontime      cache[key] = prizestrings     return prizestrings\n1: def solved(values):      def unitsolved(unit):         return {values[s] for s in unit} == set(digits)      return values is not False and all(unitsolved(unit) for unit in unitlist)\n2: def trapezoidal_rule(boundary, steps):     h = (boundary[1] - boundary[0]) / steps     a = boundary[0]     b = boundary[1]     x_i = make_points(a, b, h)     y = 0.0     y += (h / 2.0) * f(a)     for i in x_i:         y += h * f(i)     y += (h / 2.0) * f(b)     return y", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef kth_largest_element(arr: list[int], position: int) -> int:\n    if not arr:\n        return -1\n    if not isinstance(position, int):\n        raise ValueError(\"The position should be an integer\")\n    if not 1 <= position <= len(arr):\n        raise ValueError(\"Invalid value of 'position'\")\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        if low > len(arr) - 1 or high < 0:\n            return -1\n        pivot_index = partition(arr, low, high)\n        if pivot_index == position - 1:\n            return arr[pivot_index]\n        elif pivot_index > position - 1:\n            high = pivot_index - 1\n        else:\n            low = pivot_index + 1\n    return -1", "output": "Finds the kth largest element in a list."}
{"task": "summary", "input": "summarize code:\ndef count_cycle(iterable, n=None):\n    if n is not None:\n        return product(range(n), iterable)\n    seq = tuple(iterable)\n    if not seq:\n        return iter(())\n    counter = count() if n is None else range(n)\n    return zip(repeat_each(counter, len(seq)), cycle(seq))", "output": "Cycle through the items from *iterable* up to *n* times, yielding"}
{"task": "search", "input": "search code:\nReturn a binary tree with 7 nodes that looks like this:\n\nChoices:\n0: def make_tree_seven() -> Node:     tree = Node(1)     tree.left = Node(2)     tree.right = Node(3)     tree.left.left = Node(4)     tree.left.right = Node(5)     tree.right.left = Node(6)     tree.right.right = Node(7)     return tree\n1: def quote_path_part(text, full_quote=True):     if full_quote:         bytestr = normalize('NFC', to_unicode(text)).encode('utf8')         return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])     return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t                      for t in text])\n2: def compress_data(data_bits: str) -> str:     lexicon = {\"0\": \"0\", \"1\": \"1\"}     result, curr_string = \"\", \"\"     index = len(lexicon)      for i in range(len(data_bits)):         curr_string += data_bits[i]         if curr_string not in lexicon:             continue          last_match_id = lexicon[curr_string]         result += last_match_id         add_key_to_lexicon(lexicon, curr_string, index, last_match_id)         index += 1         curr_string = \"\"      while curr_string != \"\" and curr_string not in lexicon:         curr_string += \"0\"      if curr_string != \"\":         last_match_id = lexicon[curr_string]         result += last_match_id      return result", "output": "0"}
{"task": "search", "input": "search code:\nCalculate XOR of the input values\n\nChoices:\n0: def xnor_gate(input_1: int, input_2: int) -> int:     return 1 if input_1 == input_2 else 0\n1: def rec_insertion_sort(collection: list, n: int):     # Checks if the entire collection has been sorted     if len(collection) <= 1 or n <= 1:         return      insert_next(collection, n - 1)     rec_insertion_sort(collection, n - 1)\n2: def _extract_monotonic(iterator, indices):     'Non-decreasing indices, lazily consumed'     num_read = 0     for index in indices:         advance = index - num_read         try:             value = next(islice(iterator, advance, None))         except ValueError:             if advance != -1 or index < 0:                 raise ValueError(f'Invalid index: {index}') from None         except StopIteration:             raise IndexError(index) from None         else:             num_read += advance + 1         yield value", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef find_repeat(\n    matrix_g: list[list[str]], row: int, column: int, size: int\n) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all connected elements of the same type from a given position.\n\n    >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)\n    {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}\n    >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)\n    set()\n    \"\"\"\n\n    column = size - 1 - column\n    visited = set()\n    repeated = set()\n\n    if (color := matrix_g[column][row]) != \"-\":\n\n        def dfs(row_n: int, column_n: int) -> None:\n            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:\n                return\n            if (row_n, column_n) in visited:\n                return\n            visited.add((row_n, column_n))\n            if matrix_g[row_n][column_n] == color:\n                repeated.add((row_n, column_n))\n                dfs(row_n - 1, column_n)\n                dfs(row_n + 1, column_n)\n                dfs(row_n, column_n - 1)\n                dfs(row_n, column_n + 1)\n\n        dfs(column, row)\n\n    return repeated", "output": "def find_repeat(\n    matrix_g: list[list[str]], row: int, column: int, size: int\n) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all connected elements of the same type from a given position.\n\n    >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3)\n    {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)}\n    >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3)\n    set()\n    \"\"\"\n\n    column = size - 1 - column\n    visited = set()\n    repeated = set()\n\n    if (color := matrix_g[column][row]) != \"-\":\n\n        def dfs(row_n: int, column_n: int) -> None:\n            if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:\n                return\n            if (row_n, column_n) in visited:\n                return\n            visited.add((row_n, column_n))\n            if matrix_g[row_n][column_n] == color:\n                repeated.add((row_n, column_n))\n                dfs(row_n - 1, column_n)\n                dfs(row_n + 1, column_n)\n                dfs(row_n, column_n - 1)\n                dfs(row_n, column_n + 1)\n\n        dfs(column, row)\n\n    return repeated"}
{"task": "summary", "input": "summarize code:\ndef display_linked_list(root: TreeNode | None) -> None:\n    current = root\n    while current:\n        if current.right is None:\n            print(current.data, end=\"\")\n            break\n        print(current.data, end=\" \")\n        current = current.right", "output": "Display the flattened linked list."}
{"task": "search", "input": "search code:\nReturns the maximum sum of k consecutive elements\n\nChoices:\n0: def run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta):     n = len_data      prod = np.dot(theta, data_x.transpose())     prod -= data_y.transpose()     sum_grad = np.dot(prod, data_x)     theta = theta - (alpha / n) * sum_grad     return theta\n1: def max_sum_in_array(array: list[int], k: int) -> int:     if len(array) < k or k < 0:         raise ValueError(\"Invalid Input\")     max_sum = current_sum = sum(array[:k])     for i in range(len(array) - k):         current_sum = current_sum - array[i] + array[i + k]         max_sum = max(max_sum, current_sum)     return max_sum\n2: def solution(n: int = 1000000) -> int:     largest_number = 1     pre_counter = 1     counters = {1: 1}      for input1 in range(2, n):         counter = 0         number = input1          while True:             if number in counters:                 counter += counters[number]                 break             if number % 2 == 0:                 number //= 2                 counter += 1             else:                 number = (3 * number) + 1                 counter += 1          if input1 not in counters:             counters[input1] = counter          if counter > pre_counter:             largest_number = input1             pre_counter = counter     return largest_number", "output": "1"}
{"task": "detection", "input": "classify code:\ndef prefix_function(input_string: str) -> list:\n    \"\"\"\n    For the given string this function computes value for each index(i),\n    which represents the longest coincidence of prefix and suffix\n    for given substring (input_str[0...i])\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> prefix_function(\"aabcdaabc\")\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\n    >>> prefix_function(\"asdasdad\")\n    [0, 0, 0, 1, 2, 3, 4, 0]\n    \"\"\"\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result", "output": "BUGGY"}
{"task": "detection", "input": "classify code:\ndef extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef find_triplets_with_0_sum_hashing(arr: list[int]) -> list[list[int]]:\n    target_sum = 0\n\n    # Initialize the final output array with blank.\n    output_arr = []\n\n    # Set the initial element as arr[i].\n    for index, item in enumerate(arr[:-2]):\n        # to store second elements that can complement the final sum.\n        set_initialize = set()\n\n        # current sum needed for reaching the target sum\n        current_sum = target_sum - item\n\n        # Traverse the subarray arr[i+1:].\n        for other_item in arr[index + 1 :]:\n            # required value for the second element\n            required_value = current_sum - other_item\n\n            # Verify if the desired value exists in the set.\n            if required_value in set_initialize:\n                # finding triplet elements combination.\n                combination_array = sorted([item, other_item, required_value])\n                if combination_array not in output_arr:\n                    output_arr.append(combination_array)\n\n            # Include the current element in the set\n            # for subsequent complement verification.\n            set_initialize.add(other_item)\n\n    # Return all the triplet combinations.\n    return output_arr", "output": "Function for finding the triplets with a given sum in the array using hashing."}
{"task": "search", "input": "search code:\nReturn a dictionary that maps the items in *iterable* to categories\n\nChoices:\n0: def solution(matrix_str: list[str] = MATRIX_2) -> int:      n = len(matrix_str)     arr = np.empty(shape=(n, n), dtype=int)     for row, matrix_row_str in enumerate(matrix_str):         matrix_row_list_str = matrix_row_str.split()         for col, elem_str in enumerate(matrix_row_list_str):             arr[row, col] = int(elem_str)      cache: dict[str, int] = {}     return solve(arr=arr, row=0, cols=set(range(n)), cache=cache)\n1: def map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):      ret = defaultdict(list)      if valuefunc is None:         for item in iterable:             key = keyfunc(item)             ret[key].append(item)      else:         for item in iterable:             key = keyfunc(item)             value = valuefunc(item)             ret[key].append(value)      if reducefunc is not None:         for key, value_list in ret.items():             ret[key] = reducefunc(value_list)      ret.default_factory = None     return ret\n2: def filter_except(validator, iterable, *exceptions):     for item in iterable:         try:             validator(item)         except exceptions:             pass         else:             yield item", "output": "1"}
{"task": "search", "input": "search code:\nConvert speed from one unit to another using the speed_chart above.\n\nChoices:\n0: def postorder(root: Node | None) -> Generator[int]:     if not root:         return     yield from postorder(root.left)     yield from postorder(root.right)     yield root.data\n1: def get_transitions(     start: str, transitions: list[tuple[str, str, float]], steps: int ) -> dict[str, int]:      graph = MarkovChainGraphUndirectedUnweighted()      for node1, node2, probability in transitions:         graph.add_transition_probability(node1, node2, probability)      visited = Counter(graph.get_nodes())     node = start      for _ in range(steps):         node = graph.transition(node)         visited[node] += 1      return visited\n2: def convert_speed(speed: float, unit_from: str, unit_to: str) -> float:     if unit_to not in speed_chart or unit_from not in speed_chart_inverse:         msg = (             f\"Incorrect 'from_type' or 'to_type' value: {unit_from!r}, {unit_to!r}\\n\"             f\"Valid values are: {', '.join(speed_chart_inverse)}\"         )         raise ValueError(msg)     return round(speed * speed_chart[unit_from] * speed_chart_inverse[unit_to], 3)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef flatten_iter(iterable):\n    for item in iterable:\n        if isinstance(item, Iterable) and not isinstance(item, (str, bytes)):\n            yield from flatten_iter(item)\n        else:\n            yield item", "output": "``flatten_iter()`` yields all the elements from *iterable* while"}
{"task": "detection", "input": "classify code:\ndef standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5", "output": "CORRECT"}
{"task": "repair", "input": "fix bug:\ndef longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]", "output": "def longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]"}
{"task": "search", "input": "search code:\nTake in 2 integers.\n\nChoices:\n0: def arithmetic_right_shift(number: int, shift_amount: int) -> str:     if number >= 0:  # Get binary representation of positive number         binary_number = \"0\" + str(bin(number)).strip(\"-\")[2:]     else:  # Get binary (2's complement) representation of negative number         binary_number_length = len(bin(number)[3:])  # Find 2's complement of number         binary_number = bin(abs(number) - (1 << binary_number_length))[3:]         binary_number = (             \"1\" + \"0\" * (binary_number_length - len(binary_number)) + binary_number         )      if shift_amount >= len(binary_number):         return \"0b\" + binary_number[0] * len(binary_number)     return (         \"0b\"         + binary_number[0] * shift_amount         + binary_number[: len(binary_number) - shift_amount]     )\n1: def solution() -> float:      peter_totals_frequencies = total_frequency_distribution(         sides_number=4, dice_number=9     )     colin_totals_frequencies = total_frequency_distribution(         sides_number=6, dice_number=6     )      peter_wins_count = 0     min_peter_total = 9     max_peter_total = 4 * 9     min_colin_total = 6     for peter_total in range(min_peter_total, max_peter_total + 1):         peter_wins_count += peter_totals_frequencies[peter_total] * sum(             colin_totals_frequencies[min_colin_total:peter_total]         )      total_games_number = (4**9) * (6**6)     peter_win_probability = peter_wins_count / total_games_number      rounded_peter_win_probability = round(peter_win_probability, ndigits=7)      return rounded_peter_win_probability\n2: def invert_modulo(a: int, n: int) -> int:     (b, _x) = extended_euclid(a, n)  # Implemented below     if b < 0:         b = (b % n + n) % n     return b", "output": "0"}
{"task": "search", "input": "search code:\nEncode the given plaintext using the Playfair cipher.\n\nChoices:\n0: def encode(plaintext: str, key: str) -> str:      table = generate_table(key)     plaintext = prepare_input(plaintext)     ciphertext = \"\"      for char1, char2 in chunker(plaintext, 2):         row1, col1 = divmod(table.index(char1), 5)         row2, col2 = divmod(table.index(char2), 5)          if row1 == row2:             ciphertext += table[row1 * 5 + (col1 + 1) % 5]             ciphertext += table[row2 * 5 + (col2 + 1) % 5]         elif col1 == col2:             ciphertext += table[((row1 + 1) % 5) * 5 + col1]             ciphertext += table[((row2 + 1) % 5) * 5 + col2]         else:  # rectangle             ciphertext += table[row1 * 5 + col2]             ciphertext += table[row2 * 5 + col1]      return ciphertext\n1: def linear_regression_prediction(     train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list ) -> float:     x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])     y = np.array(train_usr)     beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)     return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])\n2: def solution(num_terms: int = 60, max_start: int = 1000000) -> int:     return sum(1 for i in range(1, max_start) if chain_length(i) == num_terms)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef int_ranges_from_int_list(range_string, delim=',', range_delim='-'):\n    int_tuples = []\n    # Normalize the range string to our internal format for processing.\n    range_string = format_int_list(\n        parse_int_list(range_string, delim, range_delim))\n    if range_string:\n        for bounds in range_string.split(','):\n            if '-' in bounds:\n                start, end = bounds.split('-')\n            else:\n                start, end = bounds, bounds\n            int_tuples.append((int(start), int(end)))\n    return tuple(int_tuples)", "output": "Transform a string of ranges (*range_string*) into a tuple of tuples."}
{"task": "search", "input": "search code:\nCalculate the number of non-bouncy numbers with at most n digits.\n\nChoices:\n0: def non_bouncy_upto(n: int) -> int:     return sum(non_bouncy_exact(i) for i in range(1, n + 1))\n1: def harmonic_series(n_term: str) -> list:     if n_term == \"\":         return []     series: list = []     for temp in range(int(n_term)):         series.append(f\"1/{temp + 1}\" if series else \"1\")     return series\n2: def increment_score(count: int) -> int:     return int(count * (count + 1) / 2)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef sum_of_digits_recursion(n: int) -> int:\n    n = abs(n)\n    return n if n < 10 else n % 10 + sum_of_digits(n // 10)", "output": "Find the sum of digits of a number using recursion"}
{"task": "summary", "input": "summarize code:\ndef random_chars(number_char: int = 32) -> str:\n    assert number_char > 1, \"The number of character should greater than 1\"\n    letter_code = ascii_lowercase + digits\n    return \"\".join(random.choice(letter_code) for _ in range(number_char))", "output": "Automatic generate random 32 characters."}
{"task": "repair", "input": "fix bug:\ndef cycle_sort(array):\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return ans", "output": "def cycle_sort(array: list) -> list:\n    \"\"\"\n    >>> cycle_sort([4, 3, 2, 1])\n    [1, 2, 3, 4]\n\n    >>> cycle_sort([-4, 20, 0, -50, 100, -1])\n    [-50, -4, -1, 0, 20, 100]\n\n    >>> cycle_sort([-.1, -.2, 1.3, -.8])\n    [-0.8, -0.2, -0.1, 1.3]\n\n    >>> cycle_sort([])\n    []\n    \"\"\"\n    ans = 0\n\n    # Pass through the array to find cycles to rotate.\n    for cycleStart in range(0, len(array) - 1):\n        item = array[cycleStart]\n\n        # finding the position for putting the item.\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(array)):\n            if array[i] < item:\n                pos += 1\n\n        # If the item is already present-not a cycle.\n        if pos == cycleStart:\n            continue\n\n        # Otherwise, put the item there or right after any duplicates.\n        while item == array[pos]:\n            pos += 1\n        array[pos], item = item, array[pos]\n        ans += 1\n\n        # Rotate the rest of the cycle.\n        while pos != cycleStart:\n\n            # Find where to put the item.\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(array)):\n                if array[i] < item:\n                    pos += 1\n\n            # Put the item there or right after any duplicates.\n            while item == array[pos]:\n                pos += 1\n            array[pos], item = item, array[pos]\n            ans += 1\n\n    return array"}
{"task": "search", "input": "search code:\nConversion between astronomical length units.\n\nChoices:\n0: def generate_neighbours(path):      dict_of_neighbours = {}      with open(path) as f:         for line in f:             if line.split()[0] not in dict_of_neighbours:                 _list = []                 _list.append([line.split()[1], line.split()[2]])                 dict_of_neighbours[line.split()[0]] = _list             else:                 dict_of_neighbours[line.split()[0]].append(                     [line.split()[1], line.split()[2]]                 )             if line.split()[1] not in dict_of_neighbours:                 _list = []                 _list.append([line.split()[0], line.split()[2]])                 dict_of_neighbours[line.split()[1]] = _list             else:                 dict_of_neighbours[line.split()[1]].append(                     [line.split()[0], line.split()[2]]                 )      return dict_of_neighbours\n1: def length_conversion(value: float, from_type: str, to_type: str) -> float:      from_sanitized = from_type.lower().strip(\"s\")     to_sanitized = to_type.lower().strip(\"s\")      from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)     to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)      if from_sanitized not in METRIC_CONVERSION:         msg = (             f\"Invalid 'from_type' value: {from_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     if to_sanitized not in METRIC_CONVERSION:         msg = (             f\"Invalid 'to_type' value: {to_type!r}.\\n\"             f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"         )         raise ValueError(msg)     from_exponent = METRIC_CONVERSION[from_sanitized]     to_exponent = METRIC_CONVERSION[to_sanitized]     exponent = 1      if from_exponent > to_exponent:         exponent = from_exponent - to_exponent     else:         exponent = -(to_exponent - from_exponent)      return value * pow(10, exponent)\n2: def solution(n: int = 4000000) -> int:      i = 1     j = 2     total = 0     while j <= n:         if j % 2 == 0:             total += j         i, j = j, i + j      return total", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef print_words(node: TrieNode, word: str) -> None:\n    if node.is_leaf:\n        print(word, end=\" \")\n\n    for key, value in node.nodes.items():\n        print_words(value, word + key)", "output": "Prints all the words in a Trie"}
{"task": "summary", "input": "summarize code:\ndef solution(func: Callable[[int], int] = question_function, order: int = 10) -> int:\n    data_points: list[int] = [func(x_val) for x_val in range(1, order + 1)]\n\n    polynomials: list[Callable[[int], int]] = [\n        interpolate(data_points[:max_coeff]) for max_coeff in range(1, order + 1)\n    ]\n\n    ret: int = 0\n    poly: Callable[[int], int]\n    x_val: int\n\n    for poly in polynomials:\n        x_val = 1\n        while func(x_val) == poly(x_val):\n            x_val += 1\n\n        ret += poly(x_val)\n\n    return ret", "output": "Find the sum of the FITs of the BOPS. For each interpolating polynomial of order"}
{"task": "summary", "input": "summarize code:\ndef unique_everseen(iterable, key=None):\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seenset:\n                seenset_add(k)\n                yield element\n        except TypeError:\n            if k not in seenlist:\n                seenlist_add(k)\n                yield element", "output": "Yield unique elements, preserving order."}
{"task": "search", "input": "search code:\nReturn the number of possible of binary trees.\n\nChoices:\n0: def binary_tree_count(node_count: int) -> int:     return catalan_number(node_count) * factorial(node_count)\n1: def combination_lists(n: int, k: int) -> list[list[int]]:     return [list(x) for x in combinations(range(1, n + 1), k)]\n2: def all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:      word_bank = word_bank or []     # create a table     table_size: int = len(target) + 1      table: list[list[list[str]]] = []     for _ in range(table_size):         table.append([])     # seed value     table[0] = [[]]  # because empty string has empty combination      # iterate through the indices     for i in range(table_size):         # condition         if table[i] != []:             for word in word_bank:                 # slice condition                 if target[i : i + len(word)] == word:                     new_combinations: list[list[str]] = [                         [word, *way] for way in table[i]                     ]                     # adds the word to every combination the current position holds                     # now,push that combination to the table[i+len(word)]                     table[i + len(word)] += new_combinations      # combinations are in reverse order so reverse for better output     for combination in table[len(target)]:         combination.reverse()      return table[len(target)]", "output": "0"}
{"task": "search", "input": "search code:\nYield unique elements, preserving order.\n\nChoices:\n0: def unique_everseen(iterable, key=None):     seenset = set()     seenset_add = seenset.add     seenlist = []     seenlist_add = seenlist.append     use_key = key is not None      for element in iterable:         k = key(element) if use_key else element         try:             if k not in seenset:                 seenset_add(k)                 yield element         except TypeError:             if k not in seenlist:                 seenlist_add(k)                 yield element\n1: def solution(max_base: int = 10, max_power: int = 22) -> int:     bases = range(1, max_base)     powers = range(1, max_power)     return sum(         1 for power in powers for base in bases if len(str(base**power)) == power     )\n2: def astable_frequency(     resistance_1: float, resistance_2: float, capacitance: float ) -> float:      if resistance_1 <= 0 or resistance_2 <= 0 or capacitance <= 0:         raise ValueError(\"All values must be positive\")     return (1.44 / ((resistance_1 + 2 * resistance_2) * capacitance)) * 10**6", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef upper(word: str) -> str:\n    \"\"\"\n    Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII\n    letters and subtracting 32 from their integer representation to get the uppercase\n    letter.\n\n    >>> upper(\"wow\")\n    'WOW'\n    >>> upper(\"Hello\")\n    'HELLO'\n    >>> upper(\"WHAT\")\n    'WHAT'\n    >>> upper(\"wh[]32\")\n    'WH[]32'\n    \"\"\"\n    return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)", "output": "def upper(word: str) -> str:\n    \"\"\"\n    Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII\n    letters and subtracting 32 from their integer representation to get the uppercase\n    letter.\n\n    >>> upper(\"wow\")\n    'WOW'\n    >>> upper(\"Hello\")\n    'HELLO'\n    >>> upper(\"WHAT\")\n    'WHAT'\n    >>> upper(\"wh[]32\")\n    'WH[]32'\n    \"\"\"\n    return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)"}
{"task": "search", "input": "search code:\nReturns  r_max for 3 <= a <= n as explained above\n\nChoices:\n0: def solution(n: int = 1000) -> int:     return sum(2 * a * ((a - 1) // 2) for a in range(3, n + 1))\n1: def largest_pow_of_two_le_num(number: int) -> int:     if isinstance(number, float):         raise TypeError(\"Input value must be a 'int' type\")     if number <= 0:         return 0     res = 1     while (res << 1) <= number:         res <<= 1     return res\n2: def calculate_waitingtime(     arrival_time: list[int], burst_time: list[int], no_of_processes: int ) -> list[int]:     remaining_time = [0] * no_of_processes     waiting_time = [0] * no_of_processes     # Copy the burst time into remaining_time[]     for i in range(no_of_processes):         remaining_time[i] = burst_time[i]      complete = 0     increment_time = 0     minm = 999999999     short = 0     check = False      # Process until all processes are completed     while complete != no_of_processes:         for j in range(no_of_processes):             if (                 arrival_time[j] <= increment_time                 and remaining_time[j] > 0                 and remaining_time[j] < minm             ):                 minm = remaining_time[j]                 short = j                 check = True          if not check:             increment_time += 1             continue         remaining_time[short] -= 1          minm = remaining_time[short]         if minm == 0:             minm = 999999999          if remaining_time[short] == 0:             complete += 1             check = False              # Find finish time of current process             finish_time = increment_time + 1              # Calculate waiting time             finar = finish_time - arrival_time[short]             waiting_time[short] = finar - burst_time[short]              waiting_time[short] = max(waiting_time[short], 0)          # Increment time         increment_time += 1     return waiting_time", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef luhn_validation(credit_card_number: str) -> bool:\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0", "output": "Function to luhn algorithm validation for a given credit card number."}
{"task": "search", "input": "search code:\nBuild and return a sample binary tree.\n\nChoices:\n0: def solution(percent: float = 99) -> int:     if not 0 < percent < 100:         raise ValueError(\"solution() only accepts values from 0 to 100\")     bouncy_num = 0     num = 1      while True:         if check_bouncy(num):             bouncy_num += 1         if (bouncy_num / num) * 100 >= percent:             return num         num += 1\n1: def build_tree() -> TreeNode:     root = TreeNode(1)     root.left = TreeNode(2)     root.right = TreeNode(5)     root.left.left = TreeNode(3)     root.left.right = TreeNode(4)     root.right.right = TreeNode(6)     return root\n2: def subdict(d, keep=None, drop=None):     if keep is None:         keep = d.keys()     if drop is None:         drop = []      keys = set(keep) - set(drop)      return type(d)([(k, v) for k, v in d.items() if k in keys])", "output": "1"}
{"task": "search", "input": "search code:\nPure implementation of the bogosort algorithm in Python\n\nChoices:\n0: def bogo_sort(collection):      def is_sorted(collection):         for i in range(len(collection) - 1):             if collection[i] > collection[i + 1]:                 return False         return True      while not is_sorted(collection):         random.shuffle(collection)     return collection\n1: def hexagonal_num(n: int) -> int:     return n * (2 * n - 1)\n2: def exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:     return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))", "output": "0"}
{"task": "search", "input": "search code:\nCalculate the area of a trapezium.\n\nChoices:\n0: def clamp(value, format=\"{:}\", floor=None, ceil=None, floor_token=\"<\", ceil_token=\">\"):     if value is None:         return None      if floor is not None and value < floor:         value = floor         token = floor_token     elif ceil is not None and value > ceil:         value = ceil         token = ceil_token     else:         token = \"\"      if isinstance(format, str):         return token + format.format(value)     elif callable(format):         return token + format(value)     else:         raise ValueError(             \"Invalid format. Must be either a valid formatting string, or a function \"             \"that accepts value and returns a string.\"         )\n1: def area_trapezium(base1: float, base2: float, height: float) -> float:     if base1 < 0 or base2 < 0 or height < 0:         raise ValueError(\"area_trapezium() only accepts non-negative values\")     return 1 / 2 * (base1 + base2) * height\n2: def digit_sum(n: int) -> int:     return sum(int(digit) for digit in str(n))", "output": "1"}
{"task": "search", "input": "search code:\nInput Parameters\n\nChoices:\n0: def is_safe(board: list[list[int]], row: int, column: int) -> bool:      n = len(board)  # Size of the board      # Check if there is any queen in the same upper column,     # left upper diagonal and right upper diagonal     return (         all(board[i][j] != 1 for i, j in zip(range(row), [column] * row))         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column - 1, -1, -1))         )         and all(             board[i][j] != 1             for i, j in zip(range(row - 1, -1, -1), range(column + 1, n))         )     )\n1: def casimir_force(force: float, area: float, distance: float) -> dict[str, float]:      if (force, area, distance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if force < 0:         raise ValueError(\"Magnitude of force can not be negative\")     if distance < 0:         raise ValueError(\"Distance can not be negative\")     if area < 0:         raise ValueError(\"Area can not be negative\")     if force == 0:         force = (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (             240 * (distance) ** 4         )         return {\"force\": force}     elif area == 0:         area = (240 * force * (distance) ** 4) / (             REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2         )         return {\"area\": area}     elif distance == 0:         distance = (             (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (240 * force)         ) ** (1 / 4)         return {\"distance\": distance}     raise ValueError(\"One and only one argument must be 0\")\n2: def solution(n: int = 1000) -> int:      total = 0     terms = (n - 1) // 3     total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.     terms = (n - 1) // 5     total += ((terms) * (10 + (terms - 1) * 5)) // 2     terms = (n - 1) // 15     total -= ((terms) * (30 + (terms - 1) * 15)) // 2     return total", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 1000) -> int:\n\n    total = 0\n    num = 0\n    while 1:\n        num += 3\n        if num >= n:\n            break\n        total += num\n        num += 2\n        if num >= n:\n            break\n        total += num\n        num += 1\n        if num >= n:\n            break\n        total += num\n        num += 3\n        if num >= n:\n            break\n        total += num\n        num += 1\n        if num >= n:\n            break\n        total += num\n        num += 2\n        if num >= n:\n            break\n        total += num\n        num += 3\n        if num >= n:\n            break\n        total += num\n    return total", "output": "This solution is based on the pattern that the successive numbers in the"}
{"task": "summary", "input": "summarize code:\ndef find_circular_primes(limit: int = 1000000) -> list[int]:\n    result = [2]  # result already includes the number 2.\n    for num in range(3, limit + 1, 2):\n        if is_prime(num) and not contains_an_even_digit(num):\n            str_num = str(num)\n            list_nums = [int(str_num[j:] + str_num[:j]) for j in range(len(str_num))]\n            if all(is_prime(i) for i in list_nums):\n                result.append(num)\n    return result", "output": "Return circular primes below limit."}
{"task": "search", "input": "search code:\nThe main function, it will simulate the evolution of the highway\n\nChoices:\n0: def simulate(     highway: list, number_of_update: int, probability: float, max_speed: int ) -> list:      number_of_cells = len(highway[0])      for i in range(number_of_update):         next_speeds_calculated = update(highway[i], probability, max_speed)         real_next_speeds = [-1] * number_of_cells          for car_index in range(number_of_cells):             speed = next_speeds_calculated[car_index]             if speed != -1:                 # Change the position based on the speed (with % to create the loop)                 index = (car_index + speed) % number_of_cells                 # Commit the change of position                 real_next_speeds[index] = speed         highway.append(real_next_speeds)      return highway\n1: def binary_xor(a: int, b: int) -> str:     if a < 0 or b < 0:         raise ValueError(\"the value of both inputs must be positive\")      a_binary = str(bin(a))[2:]  # remove the leading \"0b\"     b_binary = str(bin(b))[2:]  # remove the leading \"0b\"      max_len = max(len(a_binary), len(b_binary))      return \"0b\" + \"\".join(         str(int(char_a != char_b))         for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))     )\n2: def generate_parenthesis(n: int) -> list[str]:      result: list[str] = []     backtrack(\"\", 0, 0, n, result)     return result", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef upper(word: str) -> str:\n    return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)", "output": "Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII"}
{"task": "summary", "input": "summarize code:\ndef frange(stop, start=None, step=1.0):\n    if not step:\n        raise ValueError('step must be non-zero')\n    if start is None:\n        start, stop = 0.0, stop * 1.0\n    else:\n        # swap when all args are used\n        stop, start = start * 1.0, stop * 1.0\n    count = int(math.ceil((stop - start) / step))\n    ret = [None] * count\n    if not ret:\n        return ret\n    ret[0] = start\n    for i in range(1, count):\n        ret[i] = ret[i - 1] + step\n    return ret", "output": "A :func:`range` clone for float-based ranges."}
{"task": "repair", "input": "fix bug:\ndef two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []", "output": "def two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []"}
{"task": "repair", "input": "fix bug:\ndef three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )", "output": "def three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )"}
{"task": "search", "input": "search code:\nPerforms Run Length Decoding\n\nChoices:\n0: def get_citation(base_url: str, params: dict) -> str:     soup = BeautifulSoup(         httpx.get(base_url, params=params, timeout=10).content, \"html.parser\"     )     div = soup.find(\"div\", attrs={\"class\": \"gs_ri\"})     anchors = div.find(\"div\", attrs={\"class\": \"gs_fl\"}).find_all(\"a\")     return anchors[2].get_text()\n1: def run_length_decode(encoded: list) -> str:     return \"\".join(char * length for char, length in encoded)\n2: def filter_except(validator, iterable, *exceptions):     for item in iterable:         try:             validator(item)         except exceptions:             pass         else:             yield item", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef angle_comparer(point: tuple[int, int], minx: int, miny: int) -> float:\n    # sort the points accorgind to the angle from the lowest and the most left point\n    x, y = point\n    return degrees(atan2(y - miny, x - minx))", "output": "Return the angle toward to point from (minx, miny)"}
{"task": "summary", "input": "summarize code:\ndef minimum_waiting_time(queries: list[int]) -> int:\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))", "output": "This function takes a list of query times and returns the minimum waiting time"}
{"task": "search", "input": "search code:\nMultiplication only for 2x2 matrices\n\nChoices:\n0: def default_matrix_multiplication(a: list, b: list) -> list:     if len(a) != 2 or len(a[0]) != 2 or len(b) != 2 or len(b[0]) != 2:         raise Exception(\"Matrices are not 2x2\")     new_matrix = [         [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],         [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]],     ]     return new_matrix\n1: def idft(Xarr):     N = len(Xarr)     roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]     for k in range(N):         coeffs = [roots_of_unity[k * n % N] for n in range(N)]         yield _complex_sumprod(Xarr, coeffs) / N\n2: def place_word(     puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool ) -> None:     for i, char in enumerate(word):         if vertical:             puzzle[row + i][col] = char         else:             puzzle[row][col + i] = char", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is mv\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)", "output": "def kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is mv\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)"}
{"task": "summary", "input": "summarize code:\ndef dis_between_closest_pair(points, points_counts, min_dis=float(\"inf\")):\n\n    for i in range(points_counts - 1):\n        for j in range(i + 1, points_counts):\n            current_dis = euclidean_distance_sqr(points[i], points[j])\n            min_dis = min(min_dis, current_dis)\n    return min_dis", "output": "brute force approach to find distance between closest pair points"}
{"task": "summary", "input": "summarize code:\ndef calculate_signal_power(audio_fft: np.ndarray) -> np.ndarray:\n    # Calculate the power by squaring the absolute values of the FFT coefficients\n    return np.square(np.abs(audio_fft))", "output": "Calculate the power of the audio signal from its FFT."}
{"task": "search", "input": "search code:\nThis method is recursive starting from (i, j) and going in one of four directions:\n\nChoices:\n0: def run_maze(     maze: list[list[int]],     i: int,     j: int,     destination_row: int,     destination_column: int,     solutions: list[list[int]], ) -> bool:     size = len(maze)     # Final check point.     if i == destination_row and j == destination_column and maze[i][j] == 0:         solutions[i][j] = 0         return True      lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds     upper_flag = (i < size) and (j < size)  # Check upper bounds      if lower_flag and upper_flag:         # check for already visited and block points.         block_flag = (solutions[i][j]) and (not maze[i][j])         if block_flag:             # check visited             solutions[i][j] = 0              # check for directions             if (                 run_maze(maze, i + 1, j, destination_row, destination_column, solutions)                 or run_maze(                     maze, i, j + 1, destination_row, destination_column, solutions                 )                 or run_maze(                     maze, i - 1, j, destination_row, destination_column, solutions                 )                 or run_maze(                     maze, i, j - 1, destination_row, destination_column, solutions                 )             ):                 return True              solutions[i][j] = 1             return False     return False\n1: def catalan_number(node_count: int) -> int:     return binomial_coefficient(2 * node_count, node_count) // (node_count + 1)\n2: def solution(limit: int = 1000000) -> int:     answer = 0      for outer_width in range(3, (limit // 4) + 2):         if outer_width**2 > limit:             hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)         else:             hole_width_lower_bound = 1         if (outer_width - hole_width_lower_bound) % 2:             hole_width_lower_bound += 1          answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1      return answer", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef check_bouncy(n: int) -> bool:\n    if not isinstance(n, int):\n        raise ValueError(\"check_bouncy() accepts only integer arguments\")\n    str_n = str(n)\n    sorted_str_n = \"\".join(sorted(str_n))\n    return str_n not in {sorted_str_n, sorted_str_n[::-1]}", "output": "Returns True if number is bouncy, False otherwise"}
{"task": "search", "input": "search code:\nFind the midpoint of two points\n\nChoices:\n0: def root_mean_square_error(original: np.ndarray, reference: np.ndarray) -> float:     return float(np.sqrt(((original - reference) ** 2).mean()))\n1: def find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:     if len(nums) == 0:         raise ValueError(\"find_max_recursive() arg is an empty sequence\")     if (         left >= len(nums)         or left < -len(nums)         or right >= len(nums)         or right < -len(nums)     ):         raise IndexError(\"list index out of range\")     if left == right:         return nums[left]     mid = (left + right) >> 1  # the middle     left_max = find_max_recursive(nums, left, mid)  # find max in range[left, mid]     right_max = find_max_recursive(         nums, mid + 1, right     )  # find max in range[mid + 1, right]      return left_max if left_max >= right_max else right_max\n2: def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:     return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef get_distance(x: float, y: float, max_step: int) -> float:\n    a = x\n    b = y\n    for step in range(max_step):  # noqa: B007\n        a_new = a * a - b * b + x\n        b = 2 * a * b + y\n        a = a_new\n\n        # divergence happens for all complex number with an absolute value\n        # greater than 4\n        if a * a + b * b > 4:\n            break\n    return step / (max_step - 1)", "output": "Return the relative distance (= step/max_step) after which the complex number"}
{"task": "summary", "input": "summarize code:\ndef _running_median_minheap_and_maxheap(iterator):  # pragma: no cover\n    \"Non-windowed running_median() for Python 3.14+\"\n\n    read = iterator.__next__\n    lo = []  # max-heap\n    hi = []  # min-heap (same size as or one smaller than lo)\n\n    with suppress(StopIteration):\n        while True:\n            heappush_max(lo, heappushpop(hi, read()))\n            yield lo[0]\n\n            heappush(hi, heappushpop_max(lo, read()))\n            yield (lo[0] + hi[0]) / 2", "output": "Non-windowed running_median() for Python 3.14+"}
{"task": "detection", "input": "classify code:\ndef choose(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n    >>> choose(4,2)\n    6\n    >>> choose(5,3)\n    10\n    >>> choose(20,6)\n    38760\n    \"\"\"\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)", "output": "BUGGY"}
{"task": "search", "input": "search code:\nFor 2 <= n <= 1000000, return True if n is prime.\n\nChoices:\n0: def swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:     return vector * sigmoid(trainable_parameter * vector)\n1: def calculate_waiting_times(burst_times: list[int]) -> list[int]:     quantum = 2     rem_burst_times = list(burst_times)     waiting_times = [0] * len(burst_times)     t = 0     while True:         done = True         for i, burst_time in enumerate(burst_times):             if rem_burst_times[i] > 0:                 done = False                 if rem_burst_times[i] > quantum:                     t += quantum                     rem_burst_times[i] -= quantum                 else:                     t += rem_burst_times[i]                     waiting_times[i] = t - burst_time                     rem_burst_times[i] = 0         if done is True:             return waiting_times\n2: def is_prime(n: int) -> bool:     return sieve[n]", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef normalization(data: list, ndigits: int = 3) -> list:\n    # variables for calculation\n    x_min = min(data)\n    x_max = max(data)\n    # normalize data\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]", "output": "Return a normalized list of values."}
{"task": "search", "input": "search code:\nCalculate the Surface Area of a Hemisphere.\n\nChoices:\n0: def closing_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:     if kernel is None:         kernel = np.ones((3, 3))     return transform(transform(image, \"erosion\", kernel), \"dilation\", kernel)\n1: def surface_area_hemisphere(radius: float) -> float:     if radius < 0:         raise ValueError(\"surface_area_hemisphere() only accepts non-negative values\")     return 3 * pi * radius**2\n2: def reshape(matrix, shape):     if isinstance(shape, int):         return batched(chain.from_iterable(matrix), shape)     first_dim, *dims = shape     scalar_stream = _flatten_tensor(matrix)     reshaped = reduce(batched, reversed(dims), scalar_stream)     return islice(reshaped, first_dim)", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef synchronized(func):\n\n    @wraps(func)\n    def inner(*args, **kwargs):\n        iterator = func(*args, **kwargs)\n        return serialize(iterator)\n\n    return inner", "output": "Wrap an iterator-returning callable to make its iterators thread-safe."}
{"task": "summary", "input": "summarize code:\ndef get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for inner_position in positions:\n        y_test, x_test = inner_position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(inner_position)\n\n    return permissible_positions", "output": "Find all the valid positions a knight can move to from the current position."}
{"task": "summary", "input": "summarize code:\ndef transform(velocity: float, event: np.ndarray | None = None) -> np.ndarray:\n    # Ensure event is not empty\n    if event is None:\n        event = np.array([ct, x, y, z])  # Symbolic four vector\n    else:\n        event[0] *= c  # x0 is ct (speed of light * time)\n\n    return transformation_matrix(velocity) @ event", "output": "Calculate a Lorentz transformation for movement in the x direction given a"}
{"task": "summary", "input": "summarize code:\ndef get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:\n    num_filters = len(filter_points) - 2\n    filters = np.zeros((num_filters, int(ftt_size / 2) + 1))\n\n    for n in range(num_filters):\n        start = filter_points[n]\n        mid = filter_points[n + 1]\n        end = filter_points[n + 2]\n\n        # Linearly increase values from 0 to 1\n        filters[n, start:mid] = np.linspace(0, 1, mid - start)\n\n        # Linearly decrease values from 1 to 0\n        filters[n, mid:end] = np.linspace(1, 0, end - mid)\n\n    return filters", "output": "Generate filters for audio processing."}
{"task": "summary", "input": "summarize code:\ndef generate_all_combinations(n: int, k: int) -> list[list[int]]:\n    if k < 0:\n        raise ValueError(\"k must not be negative\")\n    if n < 0:\n        raise ValueError(\"n must not be negative\")\n\n    result: list[list[int]] = []\n    create_all_state(1, n, k, [], result)\n    return result", "output": "Generates all possible combinations of k numbers out of 1 ... n using backtracking."}
{"task": "detection", "input": "classify code:\ndef find_longest_chain(chain: list[int], max_num: int) -> int:\n    \"\"\"\n    Finds the smallest element of longest chain\n\n    >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6)\n    6\n    \"\"\"\n\n    max_len = 0\n    min_elem = 0\n    for start in range(2, len(chain)):\n        visited = {start}\n        elem = chain[start]\n        length = 1\n\n        while elem > 1 and elem <= max_num and elem not in visited:\n            visited.add(elem)\n            elem = chain[elem]\n            length += 1\n\n        if elem == start and length > max_len:\n            max_len = length\n            min_elem = start\n\n    return min_elem", "output": "BUGGY"}
{"task": "search", "input": "search code:\nReturn True if the given char c is an operand, e.g. it is a number\n\nChoices:\n0: def is_operand(c):     return c.isdigit()\n1: def _norm_args_typeerror(other):     if type(other) in (set, frozenset):         inc, exc = other, None     elif type(other) is _ComplementSet:         inc, exc = other._included, other._excluded     else:         raise TypeError('argument must be another set or complement(set)')     return inc, exc\n2: def get_initial_centroids(data, k, seed=None):     # useful for obtaining consistent results     rng = np.random.default_rng(seed)     n = data.shape[0]  # number of data points      # Pick K indices from range [0, N).     rand_indices = rng.integers(0, n, k)      # Keep centroids as dense format, as many entries will be nonzero due to averaging.     # As long as at least one document in a cluster contains a word,     # it will carry a nonzero weight in the TF-IDF vector of the centroid.     centroids = data[rand_indices, :]      return centroids", "output": "0"}
{"task": "search", "input": "search code:\nResolves force along rectangular components.\n\nChoices:\n0: def polar_force(     magnitude: float, angle: float, radian_mode: bool = False ) -> list[float]:     if radian_mode:         return [magnitude * cos(angle), magnitude * sin(angle)]     return [magnitude * cos(radians(angle)), magnitude * sin(radians(angle))]\n1: def level_order(root: Node | None) -> Generator[int]:      if root is None:         return      process_queue = deque([root])      while process_queue:         node = process_queue.popleft()         yield node.data          if node.left:             process_queue.append(node.left)         if node.right:             process_queue.append(node.right)\n2: def evaluate_recursive(expression: list[str]):      op = expression.pop(0)     if is_operand(op):         return int(op)      operation = operators[op]      a = evaluate_recursive(expression)     b = evaluate_recursive(expression)     return operation(a, b)", "output": "0"}
{"task": "search", "input": "search code:\nFunction updates the largest_square_area, using bottom up approach.\n\nChoices:\n0: def solution(limit: int = 50000000) -> int:     ret = set()     prime_square_limit = int((limit - 24) ** (1 / 2))      primes = set(range(3, prime_square_limit + 1, 2))     primes.add(2)     for p in range(3, prime_square_limit + 1, 2):         if p not in primes:             continue         primes.difference_update(set(range(p * p, prime_square_limit + 1, p)))      for prime1 in primes:         square = prime1 * prime1         for prime2 in primes:             cube = prime2 * prime2 * prime2             if square + cube >= limit - 16:                 break             for prime3 in primes:                 tetr = prime3 * prime3 * prime3 * prime3                 total = square + cube + tetr                 if total >= limit:                     break                 ret.add(total)      return len(ret)\n1: def largest_square_area_in_matrix_bottom_up(     rows: int, cols: int, mat: list[list[int]] ) -> int:     dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]     largest_square_area = 0     for row in range(rows - 1, -1, -1):         for col in range(cols - 1, -1, -1):             right = dp_array[row][col + 1]             diagonal = dp_array[row + 1][col + 1]             bottom = dp_array[row + 1][col]              if mat[row][col] == 1:                 dp_array[row][col] = 1 + min(right, diagonal, bottom)                 largest_square_area = max(dp_array[row][col], largest_square_area)             else:                 dp_array[row][col] = 0      return largest_square_area\n2: def transform(     image: np.ndarray, kind: str, kernel: np.ndarray | None = None ) -> np.ndarray:     if kernel is None:         kernel = np.ones((3, 3))      if kind == \"erosion\":         constant = 1         apply = np.max     else:         constant = 0         apply = np.min      center_x, center_y = (x // 2 for x in kernel.shape)      # Use padded image when applying convolution     # to not go out of bounds of the original the image     transformed = np.zeros(image.shape, dtype=np.uint8)     padded = np.pad(image, 1, \"constant\", constant_values=constant)      for x in range(center_x, padded.shape[0] - center_x):         for y in range(center_y, padded.shape[1] - center_y):             center = padded[                 x - center_x : x + center_x + 1, y - center_y : y + center_y + 1             ]             # Apply transformation method to the centered section of the image             transformed[x - center_x, y - center_y] = apply(center[kernel == 1])      return transformed", "output": "1"}
{"task": "search", "input": "search code:\nRequest that user input an integer and tell them if it is Armstrong number.\n\nChoices:\n0: def rotate(     x: float, y: float, z: float, axis: str, angle: float ) -> tuple[float, float, float]:     if not isinstance(axis, str):         raise TypeError(\"Axis must be a str\")     input_variables = locals()     del input_variables[\"axis\"]     if not all(isinstance(val, (float, int)) for val in input_variables.values()):         msg = (             \"Input values except axis must either be float or int: \"             f\"{list(input_variables.values())}\"         )         raise TypeError(msg)     angle = (angle % 360) / 450 * 180 / math.pi     if axis == \"z\":         new_x = x * math.cos(angle) - y * math.sin(angle)         new_y = y * math.cos(angle) + x * math.sin(angle)         new_z = z     elif axis == \"x\":         new_y = y * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + y * math.sin(angle)         new_x = x     elif axis == \"y\":         new_x = x * math.cos(angle) - z * math.sin(angle)         new_z = z * math.cos(angle) + x * math.sin(angle)         new_y = y     else:         raise ValueError(\"not a valid axis, choose one of 'x', 'y', 'z'\")      return new_x, new_y, new_z\n1: def chain_length(n: int, previous: set | None = None) -> int:     previous = previous or set()     if n in CHAIN_LENGTH_CACHE:         return CHAIN_LENGTH_CACHE[n]     next_number = sum_digit_factorials(n)     if next_number in previous:         CHAIN_LENGTH_CACHE[n] = 0         return 0     else:         previous.add(n)         ret = 1 + chain_length(next_number, previous)         CHAIN_LENGTH_CACHE[n] = ret         return ret\n2: def main():     num = int(input(\"Enter an integer to see if it is an Armstrong number: \").strip())     print(f\"{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number.\")     print(f\"{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number.\")     print(f\"{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number.\")", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef natural_sort(input_list: list[str]) -> list[str]:\n\n    def alphanum_key(key):\n        return [int(s) if s.isdigit() else s.lower() for s in re.split(\"([0-9]+)\", key)]\n\n    return sorted(input_list, key=alphanum_key)", "output": "Sort the given list of strings in the way that humans expect."}
{"task": "detection", "input": "classify code:\ndef data_safety_checker(list_vote: list, actual_result: float) -> bool:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2, 3, 4], 5.0)\n    False\n    \"\"\"\n    safe = 0\n    not_safe = 0\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        else:\n            if abs(abs(i) - abs(actual_result)) <= 0.1:\n                safe += 1\n            else:\n                not_safe += 1\n    return safe > not_safe", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef download_image(url: str) -> str:\n    try:\n        response = httpx.get(url, timeout=10)\n        response.raise_for_status()\n    except httpx.RequestError as e:\n        return f\"An error occurred during the HTTP request to {url}: {e!r}\"\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n    image_meta_tag = soup.find(\"meta\", {\"property\": \"og:image\"})\n    if not image_meta_tag:\n        return \"No meta tag with property 'og:image' was found.\"\n\n    image_url = image_meta_tag.get(\"content\")\n    if not image_url:\n        return f\"Image URL not found in meta tag {image_meta_tag}.\"\n\n    try:\n        image_data = httpx.get(image_url, timeout=10).content\n    except httpx.RequestError as e:\n        return f\"An error occurred during the HTTP request to {image_url}: {e!r}\"\n    if not image_data:\n        return f\"Failed to download the image from {image_url}.\"\n\n    file_name = f\"{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H-%M-%S}.jpg\"\n    with open(file_name, \"wb\") as out_file:\n        out_file.write(image_data)\n    return f\"Image downloaded and saved in the file {file_name}\"", "output": "Download an image from a given URL by scraping the 'og:image' meta tag."}
{"task": "search", "input": "search code:\nIt takes an image, an x and y coordinate, and returns the\n\nChoices:\n0: def graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:      if len(points) <= 2:         # There is no convex hull         raise ValueError(\"graham_scan: argument must contain more than 3 points.\")     if len(points) == 3:         return points     # find the lowest and the most left point     minidx = 0     miny, minx = maxsize, maxsize     for i, point in enumerate(points):         x = point[0]         y = point[1]         if y < miny:             miny = y             minx = x             minidx = i         if y == miny and x < minx:             minx = x             minidx = i      # remove the lowest and the most left point from points for preparing for sort     points.pop(minidx)      sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))     # This insert actually costs complexity,     # and you should instead add (minx, miny) into stack later.     # I'm using insert just for easy understanding.     sorted_points.insert(0, (minx, miny))      stack: deque[tuple[int, int]] = deque()     stack.append(sorted_points[0])     stack.append(sorted_points[1])     stack.append(sorted_points[2])     # The first 3 points lines are towards the left because we sort them by their angle     # from minx, miny.     current_direction = Direction.left      for i in range(3, len(sorted_points)):         while True:             starting = stack[-2]             via = stack[-1]             target = sorted_points[i]             next_direction = check_direction(starting, via, target)              if next_direction == Direction.left:                 current_direction = Direction.left                 break             if next_direction == Direction.straight:                 if current_direction == Direction.left:                     # We keep current_direction as left.                     # Because if the straight line keeps as straight,                     # we want to know if this straight line is towards left.                     break                 elif current_direction == Direction.right:                     # If the straight line is towards right,                     # every previous points on that straight line is not convex hull.                     stack.pop()             if next_direction == Direction.right:                 stack.pop()         stack.append(sorted_points[i])     return list(stack)\n1: def solution(max_proportion: float = 1 / 12345) -> int:      total_partitions = 0     perfect_partitions = 0      integer = 3     while True:         partition_candidate = (integer**2 - 1) / 4         # if candidate is an integer, then there is a partition for k         if partition_candidate == int(partition_candidate):             partition_candidate = int(partition_candidate)             total_partitions += 1             if check_partition_perfect(partition_candidate):                 perfect_partitions += 1         if (             perfect_partitions > 0             and perfect_partitions / total_partitions < max_proportion         ):             return int(partition_candidate)         integer += 1\n2: def local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:     center = image[x_coordinate][y_coordinate]     powers = [1, 2, 4, 8, 16, 32, 64, 128]      # skip get_neighbors_pixel if center is null     if center is None:         return 0      # Starting from the top right, assigning value to pixels clockwise     binary_values = [         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),         get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),         get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),         get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),     ]      # Converting the binary value to decimal.     return sum(         binary_value * power for binary_value, power in zip(binary_values, powers)     )", "output": "2"}
{"task": "search", "input": "search code:\nRecursively calculates the implication of a list.\n\nChoices:\n0: def recursive_imply_list(input_list: list[int]) -> int:     if len(input_list) < 2:         raise ValueError(\"Input list must contain at least two elements\")     first_implication = imply_gate(input_list[0], input_list[1])     if len(input_list) == 2:         return first_implication     new_list = [first_implication, *input_list[2:]]     return recursive_imply_list(new_list)\n1: def removeprefix(text: str, prefix: str) -> str:     if text.startswith(prefix):         return text[len(prefix):]     return text\n2: def parse_qsl(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):     pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]     ret = []     for pair in pairs:         if not pair:             continue         key, _, value = pair.partition('=')         if not value:             if keep_blank_values:                 value = None             else:                 continue         key = unquote(key.replace('+', ' '))         if value:             value = unquote(value.replace('+', ' '))         ret.append((key, value))     return ret", "output": "0"}
{"task": "search", "input": "search code:\nFlatten a binary tree into a linked list in-place, where the linked list is\n\nChoices:\n0: def solution(n: int = 1000) -> int:     triplets = pythagorean_triple(n)     return triplets.most_common(1)[0][0]\n1: def find_winner(num_people: int, step_size: int) -> int:     return josephus_recursive(num_people, step_size) + 1\n2: def flatten(root: TreeNode | None) -> None:     if not root:         return      # Flatten the left subtree     flatten(root.left)      # Save the right subtree     right_subtree = root.right      # Make the left subtree the new right subtree     root.right = root.left     root.left = None      # Find the end of the new right subtree     current = root     while current.right:         current = current.right      # Append the original right subtree to the end     current.right = right_subtree      # Flatten the updated right subtree     flatten(right_subtree)", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef benchmark() -> None:\n    from collections.abc import Callable\n    from timeit import timeit\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")\n\n    for value in (262144, 1125899906842624, 1267650600228229401496703205376):\n        for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):\n            benchmark_a_function(func, value)\n        print()", "output": "Benchmark multiple functions, with three different length int values."}
{"task": "detection", "input": "classify code:\ndef solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares", "output": "CORRECT"}
{"task": "search", "input": "search code:\nConvert the cells into a greyscale PIL.Image.Image and return it to the caller.\n\nChoices:\n0: def create_cipher_map(key: str) -> dict[str, str]:     # Create a list of the letters in the alphabet     alphabet = [chr(i + 65) for i in range(26)]     # Remove duplicate characters from key     key = remove_duplicates(key.upper())     offset = len(key)     # First fill cipher with key characters     cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}     # Then map remaining characters in alphabet to     # the alphabet from the beginning     for i in range(len(cipher_alphabet), 26):         char = alphabet[i - offset]         # Ensure we are not mapping letters to letters previously mapped         while char in key:             offset -= 1             char = alphabet[i - offset]         cipher_alphabet[alphabet[i]] = char     return cipher_alphabet\n1: def generate_image(cells: list[list[int]]) -> Image.Image:     # Create the output image     img = Image.new(\"RGB\", (len(cells[0]), len(cells)))     pixels = img.load()     # Generates image     for w in range(img.width):         for h in range(img.height):             color = 255 - int(255 * cells[h][w])             pixels[w, h] = (color, color, color)     return img\n2: def first_true(iterable, default=None, pred=None):     return next(filter(pred, iterable), default)", "output": "1"}
{"task": "search", "input": "search code:\nChecks whether n is a 9-digit 1 to 9 pandigital number.\n\nChoices:\n0: def generate_image(cells: list[list[int]]) -> Image.Image:     # Create the output image     img = Image.new(\"RGB\", (len(cells[0]), len(cells)))     pixels = img.load()     # Generates image     for w in range(img.width):         for h in range(img.height):             color = 255 - int(255 * cells[h][w])             pixels[w, h] = (color, color, color)     return img\n1: def is_9_pandigital(n: int) -> bool:     s = str(n)     return len(s) == 9 and set(s) == set(\"123456789\")\n2: def netstring_server(server_socket):     \"A basic netstring server loop, supporting a few operations\"     try:         while True:             clientsock, addr = server_socket.accept()             client = NetstringSocket(clientsock)             while 1:                 request = client.read_ns()                 if request == b'close':                     clientsock.close()                     break                 elif request == b'shutdown':                     return                 elif request == b'reply4k':                     client.write_ns(b'a' * 4096)                 elif request == b'ping':                     client.write_ns(b'pong')                 elif request == b'reply128k':                     client.setmaxsize(128 * 1024)                     client.write_ns(b'huge' * 32 * 1024)  # 128kb                     client.setmaxsize(32768)  # back to default     except Exception as e:         print('netstring_server exiting with error: %r' % e)         raise", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef get_child_left_position(position: int) -> int:\n    return (2 * position) + 1", "output": "heap helper function get the position of the left child of the current node"}
{"task": "summary", "input": "summarize code:\ndef benchmark():\n    from timeit import timeit\n\n    setup = \"from __main__ import slow_primes, primes, fast_primes\"\n    print(timeit(\"slow_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n    print(timeit(\"primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n    print(timeit(\"fast_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))", "output": "Let's benchmark our functions side-by-side..."}
{"task": "search", "input": "search code:\nSimple image transformation using one of two available filter functions:\n\nChoices:\n0: def padded(iterable, fillvalue=None, n=None, next_multiple=False):     iterator = iter(iterable)     iterator_with_repeat = chain(iterator, repeat(fillvalue))      if n is None:         return iterator_with_repeat     elif n < 1:         raise ValueError('n must be at least 1')     elif next_multiple:          def slice_generator():             for first in iterator:                 yield (first,)                 yield islice(iterator_with_repeat, n - 1)          # While elements exist produce slices of size n         return chain.from_iterable(slice_generator())     else:         # Ensure the first batch is at least size n then iterate         return chain(islice(iterator_with_repeat, n), iterator)\n1: def transform(     image: np.ndarray, kind: str, kernel: np.ndarray | None = None ) -> np.ndarray:     if kernel is None:         kernel = np.ones((3, 3))      if kind == \"erosion\":         constant = 1         apply = np.max     else:         constant = 0         apply = np.min      center_x, center_y = (x // 2 for x in kernel.shape)      # Use padded image when applying convolution     # to not go out of bounds of the original the image     transformed = np.zeros(image.shape, dtype=np.uint8)     padded = np.pad(image, 1, \"constant\", constant_values=constant)      for x in range(center_x, padded.shape[0] - center_x):         for y in range(center_y, padded.shape[1] - center_y):             center = padded[                 x - center_x : x + center_x + 1, y - center_y : y + center_y + 1             ]             # Apply transformation method to the centered section of the image             transformed[x - center_x, y - center_y] = apply(center[kernel == 1])      return transformed\n2: def binary_count_trailing_zeros(a: int) -> int:     if a < 0:         raise ValueError(\"Input value must be a positive integer\")     elif isinstance(a, float):         raise TypeError(\"Input value must be a 'int' type\")     return 0 if (a == 0) else int(log2(a & -a))", "output": "1"}
{"task": "detection", "input": "classify code:\ndef normalization(data: list, ndigits: int = 3) -> list:\n    \"\"\"\n    Return a normalized list of values.\n\n    @params: data, a list of values to normalize\n    @returns: a list of normalized values (rounded to ndigits decimal places)\n    @examples:\n    >>> normalization([2, 7, 10, 20, 30, 50])\n    [0.0, 0.104, 0.167, 0.375, 0.583, 1.0]\n    >>> normalization([5, 10, 15, 20, 25])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # variables for calculation\n    x_min = min(data)\n    x_max = max(data)\n    # normalize data\n    return [round((x - x_min) / (x_max - x_min), ndigits) for x in data]", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef repeat_last(iterable, default=None):\n    item = _marker\n    for item in iterable:\n        yield item\n    final = default if item is _marker else item\n    yield from repeat(final)", "output": "After the *iterable* is exhausted, keep yielding its last element."}
{"task": "search", "input": "search code:\nReturns the Title, Description, and Image Title of a random anime character .\n\nChoices:\n0: def random_anime_character() -> tuple[str, str, str]:     soup = BeautifulSoup(         httpx.get(URL, headers=headers, timeout=10).text, \"html.parser\"     )     title = soup.find(\"meta\", attrs={\"property\": \"og:title\"}).attrs[\"content\"]     image_url = soup.find(\"meta\", attrs={\"property\": \"og:image\"}).attrs[\"content\"]     description = soup.find(\"p\", id=\"description\").get_text()     _, image_extension = os.path.splitext(os.path.basename(image_url))     image_title = title.strip().replace(\" \", \"_\")     image_title = f\"{image_title}{image_extension}\"     save_image(image_url, image_title)     return (title, description, image_title)\n1: def remove_duplicates(sentence: str) -> str:     return \" \".join(sorted(set(sentence.split())))\n2: def median(matrix: list[list[int]]) -> int:     # Flatten the matrix into a sorted 1D list     linear = sorted(num for row in matrix for num in row)      # Calculate the middle index     mid = (len(linear) - 1) // 2      # Return the median     return linear[mid]", "output": "0"}
{"task": "search", "input": "search code:\nThis function can calculate the unknown resistance in an wheatstone network,\n\nChoices:\n0: def wheatstone_solver(     resistance_1: float, resistance_2: float, resistance_3: float ) -> float:      if resistance_1 <= 0 or resistance_2 <= 0 or resistance_3 <= 0:         raise ValueError(\"All resistance values must be positive\")     else:         return float((resistance_2 / resistance_1) * resistance_3)\n1: def rmse(predict, actual):     predict = np.array(predict)     actual = np.array(actual)      difference = predict - actual     square_diff = np.square(difference)     mean_square_diff = square_diff.mean()     score = np.sqrt(mean_square_diff)     return score\n2: def solution(number: int = 10000000) -> int:     for i in range(1, number):         if CHAINS[i] is None:             chain(i + 1)      return CHAINS[:number].count(False)", "output": "0"}
{"task": "search", "input": "search code:\nReturns the least number for which the proportion of bouncy numbers is\n\nChoices:\n0: def crossover(parent_1: str, parent_2: str) -> tuple[str, str]:     random_slice = random.randint(0, len(parent_1) - 1)     child_1 = parent_1[:random_slice] + parent_2[random_slice:]     child_2 = parent_2[:random_slice] + parent_1[random_slice:]     return (child_1, child_2)\n1: def pi_estimator_using_area_under_curve(iterations: int) -> None:      def function_to_integrate(x: float) -> float:         return sqrt(4.0 - x * x)      estimated_value = area_under_curve_estimator(         iterations, function_to_integrate, 0.0, 2.0     )      print(\"******************\")     print(\"Estimating pi using area_under_curve_estimator\")     print(f\"Estimated value is {estimated_value}\")     print(f\"Expected value is {pi}\")     print(f\"Total error is {abs(estimated_value - pi)}\")     print(\"******************\")\n2: def solution(percent: float = 99) -> int:     if not 0 < percent < 100:         raise ValueError(\"solution() only accepts values from 0 to 100\")     bouncy_num = 0     num = 1      while True:         if check_bouncy(num):             bouncy_num += 1         if (bouncy_num / num) * 100 >= percent:             return num         num += 1", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef identity(n: int) -> List[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]", "output": "def identity(n: int) -> list[list]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]"}
{"task": "detection", "input": "classify code:\ndef extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0 and b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0 and b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nSolves the maximum subarray problem using divide and conquer.\n\nChoices:\n0: def max_subarray(     arr: Sequence[float], low: int, high: int ) -> tuple[int | None, int | None, float]:     if not arr:         return None, None, 0     if low == high:         return low, high, arr[low]      mid = (low + high) // 2     left_low, left_high, left_sum = max_subarray(arr, low, mid)     right_low, right_high, right_sum = max_subarray(arr, mid + 1, high)     cross_left, cross_right, cross_sum = max_cross_sum(arr, low, mid, high)     if left_sum >= right_sum and left_sum >= cross_sum:         return left_low, left_high, left_sum     elif right_sum >= left_sum and right_sum >= cross_sum:         return right_low, right_high, right_sum     return cross_left, cross_right, cross_sum\n1: def open_knight_tour(n: int) -> list[list[int]]:      board = [[0 for i in range(n)] for j in range(n)]      for i in range(n):         for j in range(n):             board[i][j] = 1             if open_knight_tour_helper(board, (i, j), 1):                 return board             board[i][j] = 0      msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"     raise ValueError(msg)\n2: def perfect_cube(n: int) -> bool:     val = n ** (1 / 3)     return (val * val * val) == n", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta):\n    n = len_data\n\n    prod = np.dot(theta, data_x.transpose())\n    prod -= data_y.transpose()\n    sum_grad = np.dot(prod, data_x)\n    theta = theta - (alpha / n) * sum_grad\n    return theta", "output": "Run steep gradient descent and updates the Feature vector accordingly_"}
{"task": "search", "input": "search code:\nBackport of non-windowed running_median() for Python 3.13 and prior.\n\nChoices:\n0: def _running_median_minheap_only(iterator):  # pragma: no cover     \"Backport of non-windowed running_median() for Python 3.13 and prior.\"      read = iterator.__next__     lo = []  # max-heap (actually a minheap with negated values)     hi = []  # min-heap (same size as or one smaller than lo)      with suppress(StopIteration):         while True:             heappush(lo, -heappushpop(hi, read()))             yield -lo[0]              heappush(hi, -heappushpop(lo, -read()))             yield (hi[0] - lo[0]) / 2\n1: def value_chain(*args):     scalar_types = (str, bytes)     for value in args:         if isinstance(value, scalar_types):             yield value             continue         try:             yield from value         except TypeError:             yield value\n2: def intersection(function: Callable[[float], float], x0: float, x1: float) -> float:     x_n: float = x0     x_n1: float = x1     while True:         if x_n == x_n1 or function(x_n1) == function(x_n):             raise ZeroDivisionError(\"float division by zero, could not find root\")         x_n2: float = x_n1 - (             function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))         )         if abs(x_n2 - x_n1) < 10**-5:             return x_n2         x_n = x_n1         x_n1 = x_n2", "output": "0"}
{"task": "search", "input": "search code:\nPure python implementation of the Heap's algorithm (recursive version),\n\nChoices:\n0: def heaps(arr: list) -> list:      if len(arr) <= 1:         return [tuple(arr)]      res = []      def generate(k: int, arr: list):         if k == 1:             res.append(tuple(arr[:]))             return          generate(k - 1, arr)          for i in range(k - 1):             if k % 2 == 0:  # k is even                 arr[i], arr[k - 1] = arr[k - 1], arr[i]             else:  # k is odd                 arr[0], arr[k - 1] = arr[k - 1], arr[0]             generate(k - 1, arr)      generate(len(arr), arr)     return res\n1: def or_gate(input_1: int, input_2: int) -> int:     return int((input_1, input_2).count(1) != 0)\n2: def decimal_to_binary_recursive(number: str) -> str:     number = str(number).strip()     if not number:         raise ValueError(\"No input value was provided\")     negative = \"-\" if number.startswith(\"-\") else \"\"     number = number.lstrip(\"-\")     if not number.isnumeric():         raise ValueError(\"Input value is not an integer\")     return f\"{negative}0b{decimal_to_binary_recursive_helper(int(number))}\"", "output": "0"}
{"task": "search", "input": "search code:\nPrint exception up to 'limit' stack trace entries from 'tb' to 'file'.\n\nChoices:\n0: def euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:     return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)\n1: def print_exception(etype, value, tb, limit=None, file=None):      if file is None:         file = sys.stderr     if tb:         tbi = TracebackInfo.from_traceback(tb, limit)         print(str(tbi), end='', file=file)      for line in format_exception_only(etype, value):         print(line, end='', file=file)\n2: def loops(n):     return repeat(None, n)", "output": "1"}
{"task": "repair", "input": "fix bug:\ndef harmonic_series(n_term: str) -> list:\n    \"\"\"Pure Python implementation of Harmonic Series algorithm\n\n    :param n_term: The last (nth) term of Harmonic Series\n    :return: The Harmonic Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> harmonic_series(5)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.0)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.1)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(-5)\n    []\n    >>> harmonic_series(0)\n    []\n    >>> harmonic_series(1)\n    ['1']\n    \"\"\"\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series", "output": "def harmonic_series(n_term: str) -> list:\n    \"\"\"Pure Python implementation of Harmonic Series algorithm\n\n    :param n_term: The last (nth) term of Harmonic Series\n    :return: The Harmonic Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> harmonic_series(5)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.0)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.1)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(-5)\n    []\n    >>> harmonic_series(0)\n    []\n    >>> harmonic_series(1)\n    ['1']\n    \"\"\"\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series"}
{"task": "search", "input": "search code:\nApply Electrical Impedance formula, on any two given electrical values,\n\nChoices:\n0: def ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:     if (voltage, current, resistance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance < 0:         raise ValueError(\"Resistance cannot be negative\")     if voltage == 0:         return {\"voltage\": float(current * resistance)}     elif current == 0:         return {\"current\": voltage / resistance}     elif resistance == 0:         return {\"resistance\": voltage / current}     else:         raise ValueError(\"Exactly one argument must be 0\")\n1: def electrical_impedance(     resistance: float, reactance: float, impedance: float ) -> dict[str, float]:     if (resistance, reactance, impedance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance == 0:         return {\"resistance\": sqrt(pow(impedance, 2) - pow(reactance, 2))}     elif reactance == 0:         return {\"reactance\": sqrt(pow(impedance, 2) - pow(resistance, 2))}     elif impedance == 0:         return {\"impedance\": sqrt(pow(resistance, 2) + pow(reactance, 2))}     else:         raise ValueError(\"Exactly one argument must be 0\")\n2: def compute_truncated_primes(count: int = 11) -> list[int]:     list_truncated_primes: list[int] = []     num = 13     while len(list_truncated_primes) != count:         if validate(num):             list_nums = list_truncated_nums(num)             if all(is_prime(i) for i in list_nums):                 list_truncated_primes.append(num)         num += 2     return list_truncated_primes", "output": "1"}
{"task": "detection", "input": "classify code:\ndef unique_prime_factors(n: int) -> set:\n    \"\"\"\n    Find unique prime factors of an integer.\n    Tests include sorting because only the set matters,\n    not the order in which it is produced.\n    >>> sorted(set(unique_prime_factors(14)))\n    [2, 7]\n    >>> sorted(set(unique_prime_factors(644)))\n    [2, 7, 23]\n    >>> sorted(set(unique_prime_factors(646)))\n    [2, 17, 19]\n    \"\"\"\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors", "output": "BUGGY"}
{"task": "repair", "input": "fix bug:\ndef excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer", "output": "def excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer"}
{"task": "search", "input": "search code:\nA :func:`range` clone for float-based ranges.\n\nChoices:\n0: def calculate_variance(items: list, means: list, total_count: int) -> float:     squared_diff = []  # An empty list to store all squared differences     # iterate over number of elements in items     for i in range(len(items)):         # for loop iterates over number of elements in inner layer of items         for j in range(len(items[i])):             # appending squared differences to 'squared_diff' list             squared_diff.append((items[i][j] - means[i]) ** 2)      # one divided by (the number of all instances - number of classes) multiplied by     # sum of all squared differences     n_classes = len(means)  # Number of classes in dataset     return 1 / (total_count - n_classes) * sum(squared_diff)\n1: def frange(stop, start=None, step=1.0):     if not step:         raise ValueError('step must be non-zero')     if start is None:         start, stop = 0.0, stop * 1.0     else:         # swap when all args are used         stop, start = start * 1.0, stop * 1.0     count = int(math.ceil((stop - start) / step))     ret = [None] * count     if not ret:         return ret     ret[0] = start     for i in range(1, count):         ret[i] = ret[i - 1] + step     return ret\n2: def sliding_window(iterable, n):     if n > 20:         return _sliding_window_deque(iterable, n)     elif n > 2:         return _sliding_window_islice(iterable, n)     elif n == 2:         return pairwise(iterable)     elif n == 1:         return zip(iterable)     else:         raise ValueError(f'n should be at least one, not {n}')", "output": "1"}
{"task": "search", "input": "search code:\nFind the median of two arrays.\n\nChoices:\n0: def minimum_squares_to_represent_a_number(number: int) -> int:     if number != int(number):         raise ValueError(\"the value of input must be a natural number\")     if number < 0:         raise ValueError(\"the value of input must not be a negative number\")     if number == 0:         return 1     answers = [-1] * (number + 1)     answers[0] = 0     for i in range(1, number + 1):         answer = sys.maxsize         root = int(math.sqrt(i))         for j in range(1, root + 1):             current_answer = 1 + answers[i - (j**2)]             answer = min(answer, current_answer)         answers[i] = answer     return answers[number]\n1: def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:     if not nums1 and not nums2:         raise ValueError(\"Both input arrays are empty.\")      # Merge the arrays into a single sorted array.     merged = sorted(nums1 + nums2)     total = len(merged)      if total % 2 == 1:  # If the total number of elements is odd         return float(merged[total // 2])  # then return the middle element      # If the total number of elements is even, calculate     # the average of the two middle elements as the median.     middle1 = merged[total // 2 - 1]     middle2 = merged[total // 2]     return (float(middle1) + float(middle2)) / 2.0\n2: def calculate_span(price: list[int]) -> list[int]:     n = len(price)     s = [0] * n     # Create a stack and push index of fist element to it     st = []     st.append(0)      # Span value of first element is always 1     s[0] = 1      # Calculate span values for rest of the elements     for i in range(1, n):         # Pop elements from stack while stack is not         # empty and top of stack is smaller than price[i]         while len(st) > 0 and price[st[-1]] <= price[i]:             st.pop()          # If stack becomes empty, then price[i] is greater         # than all elements on left of it, i.e. price[0],         # price[1], ..price[i-1]. Else the price[i]  is         # greater than elements after top of stack         s[i] = i + 1 if len(st) <= 0 else (i - st[-1])          # Push this element to stack         st.append(i)      return s", "output": "1"}
{"task": "search", "input": "search code:\nCollects all the solution file path in the Project Euler directory\n\nChoices:\n0: def check_bouncy(n: int) -> bool:     if not isinstance(n, int):         raise ValueError(\"check_bouncy() accepts only integer arguments\")     str_n = str(n)     sorted_str_n = \"\".join(sorted(str_n))     return str_n not in {sorted_str_n, sorted_str_n[::-1]}\n1: def all_solution_file_paths() -> list[pathlib.Path]:     solution_file_paths = []     for problem_dir_path in PROJECT_EULER_DIR_PATH.iterdir():         if problem_dir_path.is_file() or problem_dir_path.name.startswith(\"_\"):             continue         for file_path in problem_dir_path.iterdir():             if file_path.suffix != \".py\" or file_path.name.startswith((\"_\", \"test\")):                 continue             solution_file_paths.append(file_path)     return solution_file_paths\n2: def gronsfeld(text: str, key: str) -> str:     ascii_len = len(ascii_uppercase)     key_len = len(key)     encrypted_text = \"\"     keys = [int(char) for char in key]     upper_case_text = text.upper()      for i, char in enumerate(upper_case_text):         if char in ascii_uppercase:             new_position = (ascii_uppercase.index(char) + keys[i % key_len]) % ascii_len             shifted_letter = ascii_uppercase[new_position]             encrypted_text += shifted_letter         else:             encrypted_text += char      return encrypted_text", "output": "1"}
{"task": "search", "input": "search code:\nReturn the citation number.\n\nChoices:\n0: def rstrip(iterable, strip_value=None):     return list(rstrip_iter(iterable, strip_value))\n1: def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:     # Mark current node as visited and add to recursion stack     visited.add(vertex)     rec_stk.add(vertex)      for node in graph[vertex]:         if node not in visited:             if depth_first_search(graph, node, visited, rec_stk):                 return True         elif node in rec_stk:             return True      # The node needs to be removed from recursion stack before function ends     rec_stk.remove(vertex)     return False\n2: def get_citation(base_url: str, params: dict) -> str:     soup = BeautifulSoup(         httpx.get(base_url, params=params, timeout=10).content, \"html.parser\"     )     div = soup.find(\"div\", attrs={\"class\": \"gs_ri\"})     anchors = div.find(\"div\", attrs={\"class\": \"gs_fl\"}).find_all(\"a\")     return anchors[2].get_text()", "output": "2"}
{"task": "search", "input": "search code:\nPure implementation of comb sort algorithm in Python\n\nChoices:\n0: def comb_sort(data: list) -> list:     shrink_factor = 1.3     gap = len(data)     completed = False      while not completed:         # Update the gap value for a next comb         gap = int(gap / shrink_factor)         if gap <= 1:             completed = True          index = 0         while index + gap < len(data):             if data[index] > data[index + gap]:                 # Swap values                 data[index], data[index + gap] = data[index + gap], data[index]                 completed = False             index += 1      return data\n1: def newton_raphson(     f: RealFunc,     x0: float = 0,     max_iter: int = 100,     step: float = 1e-6,     max_error: float = 1e-6,     log_steps: bool = False, ) -> tuple[float, float, list[float]]:      def f_derivative(x: float) -> float:         return calc_derivative(f, x, step)      a = x0  # Set initial guess     steps = []     for _ in range(max_iter):         if log_steps:  # Log intermediate steps             steps.append(a)          error = abs(f(a))         if error < max_error:             return a, error, steps          if f_derivative(a) == 0:             raise ZeroDivisionError(\"No converging solution found, zero derivative\")         a -= f(a) / f_derivative(a)  # Calculate next estimate     raise ArithmeticError(\"No converging solution found, iteration limit reached\")\n2: def loops(n):     return repeat(None, n)", "output": "0"}
{"task": "search", "input": "search code:\nPrepare the plaintext by up-casing it\n\nChoices:\n0: def prepare_input(dirty: str) -> str:      dirty = \"\".join([c.upper() for c in dirty if c in string.ascii_letters])     clean = \"\"      if len(dirty) < 2:         return dirty      for i in range(len(dirty) - 1):         clean += dirty[i]          if dirty[i] == dirty[i + 1]:             clean += \"X\"      clean += dirty[-1]      if len(clean) & 1:         clean += \"X\"      return clean\n1: def valid_coloring(     neighbours: list[int], colored_vertices: list[int], color: int ) -> bool:     # Does any neighbour not satisfy the constraints     return not any(         neighbour == 1 and colored_vertices[i] == color         for i, neighbour in enumerate(neighbours)     )\n2: def collapse(iterable, base_type=None, levels=None):     stack = deque()     # Add our first node group, treat the iterable as a single node     stack.appendleft((0, repeat(iterable, 1)))      while stack:         node_group = stack.popleft()         level, nodes = node_group          # Check if beyond max level         if levels is not None and level > levels:             yield from nodes             continue          for node in nodes:             # Check if done iterating             if isinstance(node, (str, bytes)) or (                 (base_type is not None) and isinstance(node, base_type)             ):                 yield node             # Otherwise try to create child nodes             else:                 try:                     tree = iter(node)                 except TypeError:                     yield node                 else:                     # Save our current location                     stack.appendleft(node_group)                     # Append the new child node                     stack.appendleft((level + 1, tree))                     # Break to process child node                     break", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef partitions(iterable):\n    sequence = list(iterable)\n    n = len(sequence)\n    for i in powerset(range(1, n)):\n        yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]", "output": "Yield all possible order-preserving partitions of *iterable*."}
{"task": "search", "input": "search code:\nCheck if a number is a perfect number.\n\nChoices:\n0: def perfect(number: int) -> bool:     if not isinstance(number, int):         raise ValueError(\"number must be an integer\")     if number <= 0:         return False     return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number\n1: def unit_len(sized_iterable, unit_noun='item'):  # TODO: len_units()/unitize()?     count = len(sized_iterable)     units = cardinalize(unit_noun, count)     if count:         return f'{count} {units}'     return f'No {units}'\n2: def factor(n):      # Corner case reduction     if n < 2:         return      # Trial division reduction     for prime in _primes_below_211:         while not n % prime:             yield prime             n //= prime      # Pollard's rho reduction     primes = []     todo = [n] if n > 1 else []     for n in todo:         if n < 211**2 or is_prime(n):             primes.append(n)         else:             fact = _factor_pollard(n)             todo += (fact, n // fact)     yield from sorted(primes)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef first_true(iterable, default=None, pred=None):\n    return next(filter(pred, iterable), default)", "output": "Returns the first true value in the iterable."}
{"task": "detection", "input": "classify code:\ndef abs_max(x: List[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    \"\"\"\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j", "output": "BUGGY"}
{"task": "search", "input": "search code:\nConverts small, non-negative integers with irregular constructions in English (i.e.,\n\nChoices:\n0: def convert_small_number(num: int) -> str:     if num < 0:         raise ValueError(\"This function only accepts non-negative integers\")     if num >= 100:         raise ValueError(\"This function only converts numbers less than 100\")     tens, ones = divmod(num, 10)     if tens == 0:         return NumberWords.ONES.value[ones] or \"zero\"     if tens == 1:         return NumberWords.TEENS.value[ones]     return (         NumberWords.TENS.value[tens]         + (\"-\" if NumberWords.ONES.value[ones] else \"\")         + NumberWords.ONES.value[ones]     )\n1: def gabor_filter_kernel(     ksize: int, sigma: int, theta: int, lambd: int, gamma: int, psi: int ) -> np.ndarray:      # prepare kernel     # the kernel size have to be odd     if (ksize % 2) == 0:         ksize = ksize + 1     gabor = np.zeros((ksize, ksize), dtype=np.float32)      # each value     for y in range(ksize):         for x in range(ksize):             # distance from center             px = x - ksize // 2             py = y - ksize // 2              # degree to radiant             _theta = theta / 180 * np.pi             cos_theta = np.cos(_theta)             sin_theta = np.sin(_theta)              # get kernel x             _x = cos_theta * px + sin_theta * py              # get kernel y             _y = -sin_theta * px + cos_theta * py              # fill kernel             gabor[y, x] = np.exp(-(_x**2 + gamma**2 * _y**2) / (2 * sigma**2)) * np.cos(                 2 * np.pi * _x / lambd + psi             )      return gabor\n2: def is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:     for i in range(9):         if n in {grid[row][i], grid[i][column]}:             return False      for i in range(3):         for j in range(3):             if grid[(row - row % 3) + i][(column - column % 3) + j] == n:                 return False      return True", "output": "0"}
{"task": "repair", "input": "fix bug:\ndef binary_search_insertion(sorted_list, item):\n    \"\"\"\n    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)\n    [1, 2, 4, 7, 9, 10]\n    \"\"\"\n    left = 0\n    right = len(sorted_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if left == right:\n            if sorted_list[middle] < item:\n                left = middle + 1\n            break\n        elif sorted_list[middle] < item:\n            left = middle + 1\n        else:\n            right = middle - 1\n    sorted_list.insert(left, item)\n    return sorted_list", "output": "def binary_search_insertion(sorted_list, item):\n    \"\"\"\n    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)\n    [1, 2, 4, 7, 9, 10]\n    \"\"\"\n    left = 0\n    right = len(sorted_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if left == right:\n            if sorted_list[middle] < item:\n                left = middle + 1\n            break\n        elif sorted_list[middle] < item:\n            left = middle + 1\n        else:\n            right = middle - 1\n    sorted_list.insert(left, item)\n    return sorted_list"}
{"task": "search", "input": "search code:\nReturns the smallest positive number that is evenly divisible (divisible\n\nChoices:\n0: def vol_spheres_intersect(     radius_1: float, radius_2: float, centers_distance: float ) -> float:     if radius_1 < 0 or radius_2 < 0 or centers_distance < 0:         raise ValueError(\"vol_spheres_intersect() only accepts non-negative values\")     if centers_distance == 0:         return vol_sphere(min(radius_1, radius_2))      h1 = (         (radius_1 - radius_2 + centers_distance)         * (radius_1 + radius_2 - centers_distance)         / (2 * centers_distance)     )     h2 = (         (radius_2 - radius_1 + centers_distance)         * (radius_2 + radius_1 - centers_distance)         / (2 * centers_distance)     )      return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)\n1: def all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:      word_bank = word_bank or []     # create a table     table_size: int = len(target) + 1      table: list[list[list[str]]] = []     for _ in range(table_size):         table.append([])     # seed value     table[0] = [[]]  # because empty string has empty combination      # iterate through the indices     for i in range(table_size):         # condition         if table[i] != []:             for word in word_bank:                 # slice condition                 if target[i : i + len(word)] == word:                     new_combinations: list[list[str]] = [                         [word, *way] for way in table[i]                     ]                     # adds the word to every combination the current position holds                     # now,push that combination to the table[i+len(word)]                     table[i + len(word)] += new_combinations      # combinations are in reverse order so reverse for better output     for combination in table[len(target)]:         combination.reverse()      return table[len(target)]\n2: def solution(n: int = 20) -> int:      g = 1     for i in range(1, n + 1):         g = lcm(g, i)     return g", "output": "2"}
{"task": "summary", "input": "summarize code:\ndef solution(n: int = 20) -> int:\n    n = 2 * n  # middle entry of odd rows starting at row 3 is the solution for n = 1,\n    # 2, 3,...\n    k = n // 2\n\n    return int(factorial(n) / (factorial(k) * factorial(n - k)))", "output": "Returns the number of paths possible in a n x n grid starting at top left"}
{"task": "search", "input": "search code:\nReturn a sliding window of width *n* over the given iterable.\n\nChoices:\n0: def solution(power: int = 1000) -> int:     num = 2**power     string_num = str(num)     list_num = list(string_num)     sum_of_num = 0      for i in list_num:         sum_of_num += int(i)      return sum_of_num\n1: def fib_iterative_yield(n: int) -> Iterator[int]:     if n < 0:         raise ValueError(\"n is negative\")     a, b = 0, 1     yield a     for _ in range(n):         yield b         a, b = b, a + b\n2: def windowed(seq, n, fillvalue=None, step=1):     if n < 0:         raise ValueError('n must be >= 0')     if n == 0:         yield ()         return     if step < 1:         raise ValueError('step must be >= 1')      iterator = iter(seq)      # Generate first window     window = deque(islice(iterator, n), maxlen=n)      # Deal with the first window not being full     if not window:         return     if len(window) < n:         yield tuple(window) + ((fillvalue,) * (n - len(window)))         return     yield tuple(window)      # Create the filler for the next windows. The padding ensures     # we have just enough elements to fill the last window.     padding = (fillvalue,) * (n - 1 if step >= n else step - 1)     filler = map(window.append, chain(iterator, padding))      # Generate the rest of the windows     for _ in islice(filler, step - 1, None, step):         yield tuple(window)", "output": "2"}
{"task": "repair", "input": "fix bug:\ndef spiral_traversal(matrix: list[list]) -> list[int]:\n    \"\"\"\n    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n    Example:\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    Algorithm:\n        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n                output of [step 2])\n        Step 2. Now perform matrix's Transpose operation (Change rows to column\n                and vice versa) and reverse the resultant matrix.\n        Step 3. Pass the output of [2nd step], to same recursive function till\n                base case hits.\n    Dry Run:\n    Stage 1.\n    [1, 2, 3, 4] +   spiral_traversal([\n        [8, 12], [7, 11], [6, 10], [5, 9]]\n     ])\n    Stage 2.\n    [1, 2, 3, 4, 8, 12] + spiral_traversal([\n        [11, 10, 9], [7, 6, 5]\n    ])\n    Stage 3.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 4.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 5.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\n    Stage 6.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])\n    \"\"\"\n    if matrix:\n        return list(matrix.pop(0)) + spiral_traversal(\n            [list(row) for row in zip(*matrix)][::-1]\n        )\n    else:\n        return []", "output": "def spiral_traversal(matrix: list[list]) -> list[int]:\n    \"\"\"\n    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n    Example:\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    Algorithm:\n        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n                output of [step 2])\n        Step 2. Now perform matrix's Transpose operation (Change rows to column\n                and vice versa) and reverse the resultant matrix.\n        Step 3. Pass the output of [2nd step], to same recursive function till\n                base case hits.\n    Dry Run:\n    Stage 1.\n    [1, 2, 3, 4] +   spiral_traversal([\n        [8, 12], [7, 11], [6, 10], [5, 9]]\n     ])\n    Stage 2.\n    [1, 2, 3, 4, 8, 12] + spiral_traversal([\n        [11, 10, 9], [7, 6, 5]\n    ])\n    Stage 3.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 4.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 5.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\n    Stage 6.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])\n    \"\"\"\n    if matrix:\n        return list(matrix.pop(0)) + spiral_traversal(\n            [list(row) for row in zip(*matrix)][::-1]\n        )\n    else:\n        return []"}
{"task": "search", "input": "search code:\nReturn the nth or the last item of *iterable*,\n\nChoices:\n0: def perfect_cube_binary_search(n: int) -> bool:     if not isinstance(n, int):         raise TypeError(\"perfect_cube_binary_search() only accepts integers\")     if n < 0:         n = -n     left = 0     right = n     while left <= right:         mid = left + (right - left) // 2         if mid * mid * mid == n:             return True         elif mid * mid * mid < n:             left = mid + 1         else:             right = mid - 1     return False\n1: def valid_input(     input_type: Callable[[object], num],  # Usually float or int     input_msg: str,     err_msg: str,     condition: Callable[[num], bool] = lambda _: True,     default: str | None = None, ) -> num:     while True:         try:             user_input = input_type(input(input_msg).strip() or default)             if condition(user_input):                 return user_input             else:                 print(f\"{user_input}: {err_msg}\")                 continue         except ValueError:             print(                 f\"{user_input}: Incorrect input type, expected {input_type.__name__!r}\"             )\n2: def nth_or_last(iterable, n, default=_marker):     return last(islice(iterable, n + 1), default=default)", "output": "2"}
{"task": "detection", "input": "classify code:\ndef check1(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital from END\n\n    >>> check1(123456789987654321)\n    True\n\n    >>> check1(120000987654321)\n    True\n\n    >>> check1(12345678957656779870004321)\n    False\n\n    \"\"\"\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f", "output": "BUGGY"}
{"task": "search", "input": "search code:\nfunction to search a number in a list using Binary Search.\n\nChoices:\n0: def split(src, sep=None, maxsplit=None):     return list(split_iter(src, sep, maxsplit))\n1: def avg_speed_of_molecule(temperature: float, molar_mass: float) -> float:      if temperature < 0:         raise Exception(\"Absolute temperature cannot be less than 0 K\")     if molar_mass <= 0:         raise Exception(\"Molar mass should be greater than 0 kg/mol\")     return (8 * R * temperature / (pi * molar_mass)) ** 0.5\n2: def search(target: int, prime_list: list) -> bool:      left, right = 0, len(prime_list) - 1     while left <= right:         middle = (left + right) // 2         if prime_list[middle] == target:             return True         elif prime_list[middle] < target:             left = middle + 1         else:             right = middle - 1      return False", "output": "2"}
{"task": "search", "input": "search code:\nIgnore some overflow and invalid value warnings.\n\nChoices:\n0: def solution() -> int:     limit = 7 * factorial(9) + 1     return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)\n1: def newton_raphson(     f: RealFunc,     x0: float = 0,     max_iter: int = 100,     step: float = 1e-6,     max_error: float = 1e-6,     log_steps: bool = False, ) -> tuple[float, float, list[float]]:      def f_derivative(x: float) -> float:         return calc_derivative(f, x, step)      a = x0  # Set initial guess     steps = []     for _ in range(max_iter):         if log_steps:  # Log intermediate steps             steps.append(a)          error = abs(f(a))         if error < max_error:             return a, error, steps          if f_derivative(a) == 0:             raise ZeroDivisionError(\"No converging solution found, zero derivative\")         a -= f(a) / f_derivative(a)  # Calculate next estimate     raise ArithmeticError(\"No converging solution found, iteration limit reached\")\n2: def ignore_overflow_warnings() -> None:     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in multiply\"     )     warnings.filterwarnings(         \"ignore\",         category=RuntimeWarning,         message=\"invalid value encountered in multiply\",     )     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in absolute\"     )     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in exp\"     )", "output": "2"}
{"task": "search", "input": "search code:\nReturns tuples with exactly length *size*. If *fill* is unset\n\nChoices:\n0: def is_prime(number: int) -> bool:      return all(number % divisor != 0 for divisor in range(2, isqrt(number) + 1))\n1: def windowed(src, size, fill=_UNSET):     return list(windowed_iter(src, size, fill=fill))\n2: def ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:     if (voltage, current, resistance).count(0) != 1:         raise ValueError(\"One and only one argument must be 0\")     if resistance < 0:         raise ValueError(\"Resistance cannot be negative\")     if voltage == 0:         return {\"voltage\": float(current * resistance)}     elif current == 0:         return {\"current\": voltage / resistance}     elif resistance == 0:         return {\"resistance\": voltage / current}     else:         raise ValueError(\"Exactly one argument must be 0\")", "output": "1"}
{"task": "summary", "input": "summarize code:\ndef main() -> None:\n    num_points: int = 5000\n    cube_size: float = 10.0  # Size of the hypercube (edge length)\n    num_dimensions: int = 10\n\n    # Generate random points within the hypercube\n    points: np.ndarray = hypercube_points(num_points, cube_size, num_dimensions)\n    hypercube_kdtree = build_kdtree(points.tolist())\n\n    # Generate a random query point within the same space\n    rng = np.random.default_rng()\n    query_point: list[float] = rng.random(num_dimensions).tolist()\n\n    # Perform nearest neighbor search\n    nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(\n        hypercube_kdtree, query_point\n    )\n\n    # Print the results\n    print(f\"Query point: {query_point}\")\n    print(f\"Nearest point: {nearest_point}\")\n    print(f\"Distance: {nearest_dist:.4f}\")\n    print(f\"Nodes visited: {nodes_visited}\")", "output": "Demonstrates the use of KD-Tree by building it from random points"}
{"task": "repair", "input": "fix bug:\ndef josephus_iterative(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size iteratively.\n\n    Args:\n        num_people (int): The number of people in the circle.\n        step_size (int): The number of steps to take before eliminating someone.\n\n    Returns:\n        int: The position of the last person standing.\n\n    Examples:\n        >>> josephus_iterative(5, 2)\n        3\n        >>> josephus_iterative(7, 3)\n        4\n    \"\"\"\n    circle = list(range(1, num_people + 1))\n    current = 0\n\n    while len(circle) > 1:\n        current = (current + step_size - 1) % len(circle)\n        circle.pop(current)\n\n    return circle[0]", "output": "def josephus_iterative(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size iteratively.\n\n    Args:\n        num_people (int): The number of people in the circle.\n        step_size (int): The number of steps to take before eliminating someone.\n\n    Returns:\n        int: The position of the last person standing.\n\n    Examples:\n        >>> josephus_iterative(5, 2)\n        3\n        >>> josephus_iterative(7, 3)\n        4\n    \"\"\"\n    circle = list(range(1, num_people + 1))\n    current = 0\n\n    while len(circle) > 1:\n        current = (current + step_size - 1) % len(circle)\n        circle.pop(current)\n\n    return circle[0]"}
{"task": "detection", "input": "classify code:\ndef exchange_sort(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Uses exchange sort to sort a list of numbers.\n    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    >>> exchange_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([-1, -2, -3])\n    [-3, -2, -1]\n    >>> exchange_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([0, 10, -2, 5, 3])\n    [-2, 0, 3, 5, 10]\n    >>> exchange_sort([])\n    []\n    \"\"\"\n    numbers_length = len(numbers)\n    for i in range(numbers_length):\n        for j in range(i + 1, numbers_length):\n            if numbers[j] < numbers[i]:\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n    return numbers", "output": "CORRECT"}
{"task": "search", "input": "search code:\nThis sorting algorithm sorts an array using the principle of bubble sort,\n\nChoices:\n0: def double_sort(collection: list[Any]) -> list[Any]:     no_of_elements = len(collection)     for _ in range(         int(((no_of_elements - 1) / 2) + 1)     ):  # we don't need to traverse to end of list as         for j in range(no_of_elements - 1):             # apply the bubble sort algorithm from left to right (or forwards)             if collection[j + 1] < collection[j]:                 collection[j], collection[j + 1] = collection[j + 1], collection[j]             # apply the bubble sort algorithm from right to left (or backwards)             if collection[no_of_elements - 1 - j] < collection[no_of_elements - 2 - j]:                 (                     collection[no_of_elements - 1 - j],                     collection[no_of_elements - 2 - j],                 ) = (                     collection[no_of_elements - 2 - j],                     collection[no_of_elements - 1 - j],                 )     return collection\n1: def depth_first_search(graph: dict, start: str) -> set[str]:     explored, stack = set(start), [start]      while stack:         v = stack.pop()         explored.add(v)         # Differences from BFS:         # 1) pop last element instead of first one         # 2) add adjacent elements to stack without exploring them         for adj in reversed(graph[v]):             if adj not in explored:                 stack.append(adj)     return explored\n2: def get_initial_centroids(data, k, seed=None):     # useful for obtaining consistent results     rng = np.random.default_rng(seed)     n = data.shape[0]  # number of data points      # Pick K indices from range [0, N).     rand_indices = rng.integers(0, n, k)      # Keep centroids as dense format, as many entries will be nonzero due to averaging.     # As long as at least one document in a cluster contains a word,     # it will carry a nonzero weight in the TF-IDF vector of the centroid.     centroids = data[rand_indices, :]      return centroids", "output": "0"}
{"task": "search", "input": "search code:\nFormat a non-expression-style repr\n\nChoices:\n0: def format_nonexp_repr(obj, req_names=None, opt_names=None, opt_key=None):     cn = obj.__class__.__name__     req_names = req_names or []     opt_names = opt_names or []     uniq_names, all_names = set(), []     for name in req_names + opt_names:         if name in uniq_names:             continue         uniq_names.add(name)         all_names.append(name)      if opt_key is None:         opt_key = lambda v: v is None     assert callable(opt_key)      items = [(name, getattr(obj, name, None)) for name in all_names]     labels = [f'{name}={val!r}' for name, val in items               if not (name in opt_names and opt_key(val))]     if not labels:         labels = ['id=%s' % id(obj)]     ret = '<{} {}>'.format(cn, ' '.join(labels))     return ret\n1: def harmonic_series(n_term: str) -> list:     if n_term == \"\":         return []     series: list = []     for temp in range(int(n_term)):         series.append(f\"1/{temp + 1}\" if series else \"1\")     return series\n2: def simulate(     highway: list, number_of_update: int, probability: float, max_speed: int ) -> list:      number_of_cells = len(highway[0])      for i in range(number_of_update):         next_speeds_calculated = update(highway[i], probability, max_speed)         real_next_speeds = [-1] * number_of_cells          for car_index in range(number_of_cells):             speed = next_speeds_calculated[car_index]             if speed != -1:                 # Change the position based on the speed (with % to create the loop)                 index = (car_index + speed) % number_of_cells                 # Commit the change of position                 real_next_speeds[index] = speed         highway.append(real_next_speeds)      return highway", "output": "0"}
{"task": "detection", "input": "classify code:\ndef decimal_to_negative_base_2(num: int) -> int:\n    \"\"\"\n    This function returns the number negative base 2\n        of the decimal number of the input data.\n\n    Args:\n        int: The decimal number to convert.\n\n    Returns:\n        int: The negative base 2 number.\n\n    Examples:\n        >>> decimal_to_negative_base_2(0)\n        0\n        >>> decimal_to_negative_base_2(-19)\n        111101\n        >>> decimal_to_negative_base_2(4)\n        100\n        >>> decimal_to_negative_base_2(7)\n        11011\n    \"\"\"\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)", "output": "CORRECT"}
{"task": "search", "input": "search code:\nGenerate a list sequence of prime numbers\n\nChoices:\n0: def find_triplets_with_0_sum(nums: list[int]) -> list[list[int]]:     return [         list(x)         for x in sorted({abc for abc in combinations(sorted(nums), 3) if not sum(abc)})     ]\n1: def prime_generator() -> Iterator[int]:      num = 2     while True:         if is_prime(num):             yield num         num += 1\n2: def capitalize(sentence: str) -> str:     if not sentence:         return \"\"      # Capitalize the first character if it's a lowercase letter     # Concatenate the capitalized character with the rest of the string     return sentence[0].upper() + sentence[1:]", "output": "1"}
{"task": "search", "input": "search code:\nTakes the temperature (in K) and molar mass (in kg/mol) of a gas\n\nChoices:\n0: def avg_speed_of_molecule(temperature: float, molar_mass: float) -> float:      if temperature < 0:         raise Exception(\"Absolute temperature cannot be less than 0 K\")     if molar_mass <= 0:         raise Exception(\"Molar mass should be greater than 0 kg/mol\")     return (8 * R * temperature / (pi * molar_mass)) ** 0.5\n1: def partition(number_to_partition: int) -> set[int]:     if number_to_partition < 0:         return set()     elif number_to_partition == 0:         return {1}      ret: set[int] = set()     prime: int     sub: int      for prime in primes:         if prime > number_to_partition:             continue         for sub in partition(number_to_partition - prime):             ret.add(sub * prime)      return ret\n2: def _carry(value1, value2, ratio, unit, min_unit, suppress):     if unit == min_unit:         return (value1 + value2 / ratio, 0)     elif unit in suppress:         return (0, value2 + value1 * ratio)     else:         return (value1, value2)", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef split(src, sep=None, maxsplit=None):\n    return list(split_iter(src, sep, maxsplit))", "output": "Splits an iterable based on a separator. Like :meth:`str.split`,"}
{"task": "detection", "input": "classify code:\ndef sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))", "output": "CORRECT"}
{"task": "summary", "input": "summarize code:\ndef validate_adjacency_list(graph: list[list[int | None]]) -> None:\n    if not isinstance(graph, list):\n        raise ValueError(\"Graph should be a list of lists.\")\n\n    for node_index, neighbors in enumerate(graph):\n        if not isinstance(neighbors, list):\n            no_neighbors_message: str = (\n                f\"Node {node_index} should have a list of neighbors.\"\n            )\n            raise ValueError(no_neighbors_message)\n        for neighbor_index in neighbors:\n            if (\n                not isinstance(neighbor_index, int)\n                or neighbor_index < 0\n                or neighbor_index >= len(graph)\n            ):\n                invalid_neighbor_message: str = (\n                    f\"Invalid neighbor {neighbor_index} in node {node_index} \"\n                    f\"adjacency list.\"\n                )\n                raise ValueError(invalid_neighbor_message)", "output": "Validates the adjacency list format for the graph."}
{"task": "summary", "input": "summarize code:\ndef column_reshape(input_array: np.ndarray) -> np.ndarray:\n\n    return input_array.reshape((input_array.size, 1))", "output": "Function to reshape a row Numpy array into a column Numpy array"}
{"task": "summary", "input": "summarize code:\ndef solution() -> int:\n    answer = set()\n    first_square = 1\n    sum_squares = 5\n    while sum_squares < LIMIT:\n        last_square = first_square + 1\n        while sum_squares < LIMIT:\n            if is_palindrome(sum_squares):\n                answer.add(sum_squares)\n            last_square += 1\n            sum_squares += last_square**2\n        first_square += 1\n        sum_squares = first_square**2 + (first_square + 1) ** 2\n\n    return sum(answer)", "output": "Returns the sum of all numbers less than 1e8 that are both palindromic and"}
{"task": "summary", "input": "summarize code:\ndef tail(n, iterable):\n    try:\n        size = len(iterable)\n    except TypeError:\n        return iter(deque(iterable, maxlen=n))\n    else:\n        return islice(iterable, max(0, size - n), None)", "output": "Return an iterator over the last *n* items of *iterable*."}
{"task": "search", "input": "search code:\nPure implementation of interpolation search algorithm in Python by recursion\n\nChoices:\n0: def interpolation_search_by_recursion(     sorted_collection: list[int], item: int, left: int = 0, right: int | None = None ) -> int | None:     if right is None:         right = len(sorted_collection) - 1     # avoid divided by 0 during interpolation     if sorted_collection[left] == sorted_collection[right]:         if sorted_collection[left] == item:             return left         return None      point = left + ((item - sorted_collection[left]) * (right - left)) // (         sorted_collection[right] - sorted_collection[left]     )      # out of range check     if point < 0 or point >= len(sorted_collection):         return None      if sorted_collection[point] == item:         return point     if point < left:         return interpolation_search_by_recursion(sorted_collection, item, point, left)     if point > right:         return interpolation_search_by_recursion(sorted_collection, item, right, left)     if sorted_collection[point] > item:         return interpolation_search_by_recursion(             sorted_collection, item, left, point - 1         )     return interpolation_search_by_recursion(sorted_collection, item, point + 1, right)\n1: def is_pentagonal(n: int) -> bool:     root = (1 + 24 * n) ** 0.5     return ((1 + root) / 6) % 1 == 0\n2: def is_prime(number: int) -> bool:      if 1 < number < 4:         # 2 and 3 are primes         return True     elif number < 2 or number % 2 == 0 or number % 3 == 0:         # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes         return False      # All primes number are in format of 6k +/- 1     for i in range(5, int(math.sqrt(number) + 1), 6):         if number % i == 0 or number % (i + 2) == 0:             return False     return True", "output": "0"}
{"task": "search", "input": "search code:\nReturn all permutations of the given list.\n\nChoices:\n0: def permute_backtrack(nums: list[int]) -> list[list[int]]:      def backtrack(start: int) -> None:         if start == len(nums) - 1:             output.append(nums[:])         else:             for i in range(start, len(nums)):                 nums[start], nums[i] = nums[i], nums[start]                 backtrack(start + 1)                 nums[start], nums[i] = nums[i], nums[start]  # backtrack      output: list[list[int]] = []     backtrack(0)     return output\n1: def solution(numerator: int = 1, digit: int = 1000) -> int:     the_digit = 1     longest_list_length = 0      for divide_by_number in range(numerator, digit + 1):         has_been_divided: list[int] = []         now_divide = numerator         for _ in range(1, digit + 1):             if now_divide in has_been_divided:                 if longest_list_length < len(has_been_divided):                     longest_list_length = len(has_been_divided)                     the_digit = divide_by_number             else:                 has_been_divided.append(now_divide)                 now_divide = now_divide * 10 % divide_by_number      return the_digit\n2: def ignore_overflow_warnings() -> None:     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in multiply\"     )     warnings.filterwarnings(         \"ignore\",         category=RuntimeWarning,         message=\"invalid value encountered in multiply\",     )     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in absolute\"     )     warnings.filterwarnings(         \"ignore\", category=RuntimeWarning, message=\"overflow encountered in exp\"     )", "output": "0"}
{"task": "summary", "input": "summarize code:\ndef tangent_hyperbolic(vector: np.ndarray) -> np.ndarray:\n\n    return (2 / (1 + np.exp(-2 * vector))) - 1", "output": "Implements the tanh function"}
{"task": "repair", "input": "fix bug:\ndef solution(n: int) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares", "output": "def solution(n: int = 100) -> int:\n    \"\"\"Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    >>> solution()\n    25164150\n    \"\"\"\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i ** 2\n        sum_of_ints += i\n    return sum_of_ints ** 2 - sum_of_squares"}
